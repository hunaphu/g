<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::49638</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>018</td><td>Jelly</td><td>251008T091421Z</td><td><a href="https://codegolf.stackexchange.com/questions/49638/not-your-routine-bean-machine/284030#284030">Adam&#22</a></td></tr>
<tr d-ix="1"><td>090</td><td>Dyalog APL</td><td>251007T193914Z</td><td><a href="https://codegolf.stackexchange.com/questions/49638/not-your-routine-bean-machine/284022#284022">Aaron</a></td></tr>
<tr d-ix="2"><td>117</td><td>Javascript</td><td>150518T055032Z</td><td><a href="https://codegolf.stackexchange.com/questions/49638/not-your-routine-bean-machine/50363#50363">Not that</a></td></tr>
<tr d-ix="3"><td>076</td><td>TIBASIC</td><td>150517T210400Z</td><td><a href="https://codegolf.stackexchange.com/questions/49638/not-your-routine-bean-machine/50354#50354">lirtosia</a></td></tr>
<tr d-ix="4"><td>040</td><td>CJam</td><td>150505T091905Z</td><td><a href="https://codegolf.stackexchange.com/questions/49638/not-your-routine-bean-machine/49644#49644">Optimize</a></td></tr>
<tr d-ix="5"><td>140</td><td>Ruby</td><td>150505T094303Z</td><td><a href="https://codegolf.stackexchange.com/questions/49638/not-your-routine-bean-machine/49645#49645">Cristian</a></td></tr>
<tr d-ix="6"><td>247</td><td>C#</td><td>150505T095919Z</td><td><a href="https://codegolf.stackexchange.com/questions/49638/not-your-routine-bean-machine/49646#49646">VisualMe</a></td></tr>
<tr d-ix="7"><td>138</td><td>Python 3</td><td>150505T114600Z</td><td><a href="https://codegolf.stackexchange.com/questions/49638/not-your-routine-bean-machine/49650#49650">randomra</a></td></tr>
<tr d-ix="8"><td>041</td><td>Pyth</td><td>150505T114131Z</td><td><a href="https://codegolf.stackexchange.com/questions/49638/not-your-routine-bean-machine/49649#49649">Jakube</a></td></tr>
<tr d-ix="9"><td>140</td><td>Ruby</td><td>150505T091118Z</td><td><a href="https://codegolf.stackexchange.com/questions/49638/not-your-routine-bean-machine/49643#49643">blutoran</a></td></tr>
<tr d-ix="10"><td>113</td><td>Python 3</td><td>150506T011239Z</td><td><a href="https://codegolf.stackexchange.com/questions/49638/not-your-routine-bean-machine/49665#49665">xnor</a></td></tr>
<tr d-ix="11"><td>078</td><td>Perl</td><td>150505T134140Z</td><td><a href="https://codegolf.stackexchange.com/questions/49638/not-your-routine-bean-machine/49653#49653">nutki</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/DennisMitchell/jellylanguage" rel="nofollow noreferrer">Jelly</a>, <s>19</s> 18 bytes</h1>
<pre><code>×C}Ż+×
ỴO%7‘H’HÇƒ1
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m700KzUnp3LBgqWlJWm6FnsPT3euPbpb-_B0roe7t_irmj9qmOHxqGGmx-H2Y5MMlxQnJRdDVW6PVoqLyYuJARJxcTExYKZ-nFIsVBoA" rel="nofollow noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu1" class="pu"><h1>Dyalog APL, 90 bytes</h1>
<p>Not super in love with this, but I did like that fit into a reduction.</p>
<pre><code>{{{1⌽(2↑t),{∊+/¨(1 0⍴⍨≢⍵)⊂⍵}2↓t←¯1⌽⍵}∊⍺{⍺⌷(⍵0)(0⍵)(2⍴⍵÷2)}¨⍵}/⌽1,3⌊1+0⌈¯91+⎕UCS¨(⍳≢⍵)↑¨↓⍵}­⁡​‎‎⁪⁡⁪⁠⁪⁢⁢⁢⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁣⁡⁪‏‏​⁡⁠⁡‌⁢​‎‎⁪⁡⁪⁠⁪⁢⁢⁡⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁡⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁡⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁡⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁢⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁢⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁢⁣⁪‏‏​⁡⁠⁡‌⁣​‎‎⁪⁡⁪⁠⁪⁢⁡⁣⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁤⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁤⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁤⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁤⁤⁪‏‏​⁡⁠⁡‌⁤​‎‎⁪⁡⁪⁠⁪⁢⁡⁡⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁡⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁡⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁢⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁢⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁢⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁣⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁣⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁣⁣⁪‏‏​⁡⁠⁡‌⁢⁡​‎‎⁪⁡⁪⁠⁪⁤⁤⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁡⁡⁪‏‏​⁡⁠⁡‌⁢⁢​‎‎⁪⁡⁪⁠⁪⁤⁤⁣⁪‏‏​⁡⁠⁡‌⁢⁣​‎‎⁪⁡⁪⁠⁪⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁤⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁤⁢⁪‏‏​⁡⁠⁡‌⁢⁤​‎‎⁪⁡⁪⁠⁪⁣⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁢⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁣⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁣⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁣⁤⁪‏‏​⁡⁠⁡‌⁣⁡​‎‎⁪⁡⁪⁠⁪⁣⁣⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁤⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁤⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁡⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁡⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁣⁡⁪‏‏​⁡⁠⁡‌⁣⁢​‎‎⁪⁡⁪⁠⁪⁣⁣⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁣⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁤⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁤⁢⁪‏‏​⁡⁠⁡‌⁣⁣​‎‎⁪⁡⁪⁠⁪⁣⁤⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁤⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁡⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁡⁢⁪‏‏​⁡⁠⁡‌⁣⁤​‎‎⁪⁡⁪⁠⁪⁤⁡⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁡⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁢⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁢⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁢⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁣⁡⁪‏‏​⁡⁠⁡‌⁤⁡​‎‎⁪⁡⁪⁠⁪⁣⁣⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁣⁢⁪‏‏​⁡⁠⁡‌⁤⁢​‎‎⁪⁡⁪⁠⁪⁣⁢⁢⁪‏‏​⁡⁠⁡‌⁤⁣​‎‎⁪⁡⁪⁠⁪⁣⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁢⁡⁪‏‏​⁡⁠⁡‌⁤⁤​‎‎⁪⁡⁪⁠⁪⁢⁤⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁡⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁡⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁡⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁡⁤⁪‏‏​⁡⁠⁡‌⁢⁡⁡​‎‎⁪⁡⁪⁠⁪⁣⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁤⁪‏‏​⁡⁠⁡‌⁢⁡⁢​‎‎⁪⁡⁪⁠⁪⁤⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁤⁪‏‏​⁡⁠⁡‌⁢⁡⁣​‎‎⁪⁡⁪⁠⁪⁢⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁣⁪‏‏​⁡⁠⁡‌⁢⁡⁤​‎‎⁪⁡⁪⁠⁪⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁪‏‏​⁡⁠⁡‌­
                                                                                       ↓⍵   # ‎⁡Split lines into nested array
                                                                                (⍳≢⍵)↑¨     # ‎⁢Take as many characters as its row number
                                                                                            # ‎⁢This just eliminates trailing spaces
                                                                           ⎕UCS¨            # ‎⁣Convert to char codes
                                                                 3⌊1+0⌈¯91+                 # ‎⁤Subtract 91, clamp to zero, add 1, clamp to 3
                                                                                            # ‎⁤This converts '/\^' to 1 2 3
                                                               1,                           # ‎⁢⁡Prepend the beginning probability of 1
                                                              ⌽                             # ‎⁢⁢Reverse because the upcoming reduce happens right-to-left
 {                                                          }/                              # ‎⁢⁣Apply between each element (starting from the rightmost two elements)
                                                                                            # ‎⁢⁣The function is expecting the plinko elements on the left and the list of probabilities going into it on the right
                                      ⍺{                 }¨⍵                                # ‎⁢⁤For each set of elements and probabilities
                                          (  )(  )(     )                                   # ‎⁣⁡Generate the 3 possibilities:
                                          (⍵0)                                              # ‎⁣⁢  All left
                                              (0⍵)                                          # ‎⁣⁣  All right
                                                  (2⍴⍵÷2)                                   # ‎⁣⁤  2 copies of half of the input (50/50)
                                        ⍺⌷                                                  # ‎⁤⁡and select my element from this list
                                     ∊                                                      # ‎⁤⁢Flatten
           {                        }                                                       # ‎⁤⁣and apply
                            2↓t←¯1⌽⍵                                                        # ‎⁤⁤  rotate back 1 and drop 2 to eliminate the ends
           {    (1 0⍴⍨≢⍵)⊂⍵}                                                                # ‎⁢⁡⁡  take as many pairs of 1 0 as the remaining length
            ∊+/¨                                                                            # ‎⁢⁡⁢  sum each of those and flatten
                                                                                            # ‎⁢⁡⁢  This gets the combined probability from the multiple elements above
     (2↑t),                                                                                 # ‎⁢⁡⁣  Prepend the first 2 elements from my modified list
   1⌽                                                                                       # ‎⁢⁡⁤ and rotate back to restore original ends
💎
</code></pre>
<p>Created with the help of <a href="https://vyxal.github.io/Luminespire" rel="nofollow noreferrer">Luminespire</a>.</p>
</div>
<div id="pu2" class="pu"><h2>Javascript - 117</h2>

<p>Tried using recursion, but that was too long...</p>

<p>Hat tip to <a href="https://codegolf.stackexchange.com/a/49665/13950">xnor</a> for the subtraction idea, which shaved off a dozen or more characters.</p>



<pre class="lang-js prettyprint-override"><code>w=s=&gt;{a=[1];s.split('\n').map(m=&gt;{for(b=[i=0];z=a[i],f=m[i];b[i++]+=z-b[i])b[i+1]=f&gt;']'?z/2:f&lt;':'?0:z;a=b})
return a}
</code></pre>

<p>Ungolfed:</p>

<pre class="lang-js prettyprint-override"><code>// s must not have spaces
w=s=&gt;{
  // a is the current probability array
  a=[1];
  s.split('\n').map(
    // for each row of input...
    m=&gt;{
      b=[0];  // b is the next row's probability array
      for(i=0; i&lt;m.length;){
        z=a[i]; // z = probability
        f=m[i]; // f = letter
                                  // let's assume i == 0
        b[i+1] = (f&gt;']') ? z/2 :  // if f == '^', b[1] = z/2
          (f&lt;':' ? 0 :            // else if f == '/', b[1] = 0 
            z);                   // else b[1] = z
        b[i++]+=z-b[i];           // then add (z-b[1]) to b[0]
      }
      a=z-b    // increment current probability array
    }
  )
  return a;
}
</code></pre>
</div>
<div id="pu3" class="pu"><h1>TI-BASIC, <s>73</s> 76</h1>

<p>Takes input one line at a time, and ends when a space is entered on its own, because neither line breaks in strings nor empty strings are legal in TI-BASIC.</p>

<pre><code>{1→X
Input Str1
While Str1≠"  //one space
.5seq(inString("^/",sub(Str1,I,1)),I,1,dim(Ans
augment(Ans∟X,{0})+augment({0},∟X-∟XAns→X
Input Str1
End
∟X
</code></pre>

<p>I'm pretty sure I got the size right (TI-BASIC is tokenized, so each command takes either one or two bytes—seq() takes one, inString() takes two, dim() takes one, and so on. I counted the size manually.)</p>

<p>Although the backslash character is valid in a string, note that there is no way to input one from inside the program unless you have modified your calculator.</p>
</div>
<div id="pu4" class="pu"><h1>CJam, <s>50 48 45 44 42</s> 40 bytes</h1>

<pre><code>1]q{iD%"(+0 0+( (\Y/::+ (d2/_a+"S/=~+}/p
</code></pre>

<p>This expects the input to be without space and have a trailing newline. For example:</p>

<pre><code>^
\^
^^\
\^/^
</code></pre>

<blockquote>
  <p>[0 0.1875 0.5625 0.125 0.125]</p>
</blockquote>

<p><strong>Algorithm</strong></p>

<p>The basic idea is that you keep on parsing each character (there are only 4 different characters) and perform different operations on the probability distribution (initially an array containing 1 element of value 1). For each row of input characters (starting with the first character on first row), we maintain a probability array of that same size. Each character acts upon the first probability from the list and pushes the resultant pair to the end of the list. After each line, we sum up pairs from the list to get exact number of items as the items on the next line.</p>

<p>Here are the four characters and the required actions corresponding to each:</p>

<ul>
<li><code>^</code> : When this character occurs, you split the current probability to two parts. For example, if we have this on the first line, we have to convert the <code>[1]</code> to <code>[0.5 0.5]</code></li>
<li><code>/</code> : When this characters occurs, we have to put <code>&lt;current probability&gt; 0</code> in place of the current probability in the array.</li>
<li><code>\</code> : When this characters occurs, we have to put <code>0 &lt;current probability&gt;</code> in place of the current probability in the array.</li>
<li><code>\n</code> : When this character occurs, we have a new line. Thus we group together all pairs from above 3 characters and sum them up to get probability of each item for the next line. For ex. <code>[0 0.5 0.25 0.25]</code> gets converted to <code>[0 0.75 0.25]</code>. Note that the first and last items have an implicit pair (valued 0) before and after them.</li>
</ul>

<p>Now we only have to identify the right character and perform the right action. Lets use the usual maths here to do that. The ASCII codes for <code>^</code>, <code>\</code>, <code>/</code> and <code>\n</code> are <code>94</code>, <code>92</code>, <code>47</code>, and <code>10</code>. After a few trials, we get this simple equation to convert these numbers into 0, 1, 2 and 3:</p>

<pre><code>"^\/
":ied13f%ed4f%ed
</code></pre>

<p>gives:</p>

<pre><code>Stack: [[94 92 47 10]]
Stack: [[3 1 8 10]]
Stack: [[3 1 0 2]]
3102
</code></pre>

<p>In an array of length 4, the last <code>4f%</code> would be implicit. So we simply do <code>%13</code> to the ASCII code of the character and choose the right action from an array of actions.</p>

<p><strong>Code explanation</strong>:</p>

<pre><code>1]                                 e# Initial probability array with 1 probability
  q{                          }/   e# Read the whole input and iterate char by char
    iD%                            e# mod the ASCII code of the character with 13
"(+0 0+( (\Y/::+ (d2/_a+"S/        e# This is our actions array in order of [\ / \n ^]
                           =~      e# We pick the correct action and eval it
                             +     e# Evaling each action will leave one number out of the
                                   e# pairs out of the array. So we put it back in
                                p  e# Print the final probability array
</code></pre>

<p><a href="http://cjam.aditsu.net/#code=1%5Dq%7BiD%25%22(%2B0%200%2B(%20(%5CY%2F%3A%3A%2B%20(d2%2F_a%2B%22S%2F%3D~%2B%7D%2Fp&amp;input=%5E%0A%5C%5E%0A%5E%5E%5C%0A%5C%5E%2F%5E%0A" rel="nofollow">Try it online here</a></p>
</div>
<div id="pu5" class="pu"><h1>Ruby 140</h1>



<pre class="lang-rb prettyprint-override"><code>-&gt;s{r=[1.0]
s.lines.map{|l|n=[i=0.0]*(r.size+1)
l.scan(/\S/).map{|e|a,b=e&gt;?/?e&gt;?]?[0.5]*2:[0,1]:[1,0]
z=r[i]
n[i]+=z*a
n[i+=1]+=z*b}
r=n}
r}
</code></pre>

<p>Function that takes as input the string (can be nicely formatted as a pyramid) and returns an array of floats.</p>

<p>Test it online: <a href="http://ideone.com/kmsZMe" rel="nofollow">http://ideone.com/kmsZMe</a></p>

<p>Pretty straightforward implementation. Here it is ungolfed:</p>

<pre class="lang-rb prettyprint-override"><code>F = -&gt; input {
  probabilities = [1.0]

  input.lines.each { |line|

    new_probabilities = [0.0] * (probabilities.size+1)
    elements = line.scan /\S/
    elements.map.with_index{|el, i|
      deltas = el &gt; '/' ? (el &gt; ']' ? [0.5,0.5] : [0,1]) : [1,0]

      d1, d2 = deltas

      new_probabilities[i] += probabilities[i] * d1
      new_probabilities[i + 1] += probabilities[i] * d2
    }
    probabilities = new_probabilities
  }
  return probabilities
}
</code></pre>
</div>
<div id="pu6" class="pu"><h1>C#, <s>274</s> 247 bytes</h1>

<p>Nothing fancy, complete program that reads lines (with or without spaces, it just strips them) in from STDIN, and prints space separated results to STDOUT.</p>



<pre class="lang-c# prettyprint-override"><code>using Q=System.Console;class P{static void Main(){decimal[]k={1},t;string L;for(int l=0,i;(L=Q.ReadLine())!=null;k=t)for(L=L.Replace(" ",""),t=new decimal[++l+1],i=0;i&lt;l;)t[i]+=k[i]-(t[i+1]=(8-L[i]%8)/2*k[i++]/2);Q.WriteLine(string.Join(" ",k));}}
</code></pre>

<p>Tidier code with comments:</p>

<pre class="lang-c# prettyprint-override"><code>using Q=System.Console;

class P
{
    // / 47
    // \ 92
    // ^ 94

    static void Main()
    {
        decimal[]k={1},t; // k is old array, t is new array

        string L; // L is the current line, R is the current result (1 if no rows)
        for(int l=0,i; // l is length of old array, i is index in old array
            (L=Q.ReadLine())!=null; // for each line of input
            k=t) // swap array over
            for(L=L.Replace(" ",""), // remove spaces
                t=new decimal[++l+1], // create a new array
                i=0;

                i&lt;l;) // for each position

                t[i]+=k[i]-( // add to left position (for last time)
                        t[i+1]=(8-L[i]%8)/2*k[i++]/2 // assign right position (k is decimal)
                    );

        Q.WriteLine(string.Join(" ",k)); // print result
    }
}
</code></pre>
</div>
<div id="pu7" class="pu"><h1>Python 3, 138 bytes</h1>



<pre class="lang-python prettyprint-override"><code>def f(s):
 r=[1];p=t=0
 for e in s:
  if'!'&lt;e:b=p==t*-~t/2;r+=[0]*b;t+=b;v=ord(e)%7+1;a=r[p]/2;r[-1]+=v//3*a;r+=v%3*a,;p+=1
 return r[~t:]
</code></pre>

<p>Works with any whitespaces as they are all filtered out (by <code>if'!'&lt;e</code>).</p>

<p>Method:</p>

<ul>
<li>We keep an ever expanding list <code>r</code> of the probabilities of reaching any obstacles and the implicit troughs below them. We start from the list <code>[1]</code>.</li>
<li>If we are at the first obstacle in a row we need to add an extra <code>0</code> to the list for the leading trough. We decide if it is the first obstacle by comparing its index <code>p</code> to the next triangular number <code>t*-~t/2</code>.</li>
<li>For every obstacle we add its list-value partially to the last element and partially to a new trailing element. We divide the list-value based on the obstacle character (<code>^:0.5 0.5; /:1 0; \:0 1</code>). We use the following method:
<ul>
<li>Take <code>v = ord(char) mod 7 + 1</code> yielding <code>^:4 /:6 \:2</code></li>
<li><code>v div 3 / 2</code> yields the first fraction (<code>^:0.5 /:1 \:0</code>)</li>
<li><code>v mod 3 / 2</code> yields the second fraction (<code>^:0.5 /:0 \:1</code>)</li>
</ul></li>
<li>The result is the last <code>t + 1</code> elements of the final list <code>r</code>.</li>
</ul>

<p>2 bytes thanks to @Sp3000's chat advice.</p>
</div>
<div id="pu8" class="pu"><h1>Pyth, <s>43</s> <s>42</s> 41 bytes</h1>

<pre><code>umsdc+0sm@c[ZJhkJZKcJ2K)2x"\/"ekC,GH2.z]1
</code></pre>

<p>This expects the input to be without spaces. Try it online: <a href="https://pyth.herokuapp.com/?code=umsdc%2B0sm%40c%5BZJhkJZKcJ2K)2x%22%5C%2F%22ekC%2CGH2.z%5D1&amp;input=%5E%0A%2F%5E%0A%5E%5E%2F%0A%2F%5C%2F%5C%0A%5E%5E%2F%5E%5C%0A%5E%5C%5E%5C%2F%5E%0A%5C%5E%5E%5E%5C%5E%2F&amp;debug=0" rel="nofollow">Pyth Compiler/Executor</a></p>

<h1>Pyth, 40 bytes (questionable)</h1>

<pre><code>umsdc+0sm,K@[ZJhkcJ2)x"\/"ek-JKC,GH2.z]1
</code></pre>

<p>Thanks to @isaacg, for saving one byte. Notice that this version didn't actually work in the version of Pyth, when the question was asked. There was a tiny bug in the compiler. Despite this code uses no new features of Pyth (only stuff that was in the Pyth docs for a long time and should have worked), this might not be a valid answer. Decide for yourself. </p>

<p>Try it online: <a href="https://pyth.herokuapp.com/?code=umsdc%2B0sm%2CK%40%5BZJhkcJ2)x%22%5C%2F%22ek-JKC%2CGH2.z%5D1&amp;input=%5E%0A%2F%5E%0A%5E%5E%2F%0A%2F%5C%2F%5C%0A%5E%5E%2F%5E%5C%0A%5E%5C%5E%5C%2F%5E%0A%5C%5E%5E%5E%5C%5E%2F&amp;debug=0" rel="nofollow">Pyth Compiler/Executor</a></p>

<h3>Explanation:</h3>

<pre><code>umsdc+0sm,K@[ZJhkcJ2)x"\/"ek-JKC,GH2.z]1   
u                                   .z]1  reduce G, starting with G = [1], for H in all_input():
                               C,GH         zip(G,H)
        m                                   map each pair k to:
            [ZJhkcJ2)                         create a list [0, k[0], k[0]/2]
                     x"\/"ek                  index of k[1] in "\/" (-1 for "^")
          K@                                  take the correspondent element of the list and store in K
         ,                  -JK               create a pair (K, k[0]-K)                                                      
     +0s                                    sum and insert 0 at the begin
    c                              2        chop into pairs
 msd                                        sum up each pair
                                            G gets updated with this new list
</code></pre>

<p>For instance if I currently have the input probabilities <code>G = [0.5, 0.5, 0.0]</code> and the row <code>H = "^/^"</code> the following happens:</p>

<ul>
<li>zip       ... <code>[(0.5,"^"), (0.5,"/"), (0.0,"^")]</code></li>
<li>create output probabilities ... <code>[[0.25,0.25], [0.5,0.0], [0.0, 0.0]]</code></li>
<li>0+sum ... <code>[0, 0.25, 0.25, 0.5, 0.0, 0.0, 0.0]</code></li>
<li>chop      ... <code>[0,0.25], [0.25,0.5], [0.0,0.0], [0.0]]</code></li>
<li>sum       ... <code>[0.25, 0.75, 0.0, 0.0]</code></li>
</ul>
</div>
<div id="pu9" class="pu"><h1>Ruby, 140 <s>158</s> bytes</h1>
<p><s>Don't keep upvoting this when <a href="https://codegolf.stackexchange.com/a/49645/26465">there's a better ruby version</a>.</s> Here are more tricks for you.</p>
<p>Unnamed function with one argument. Must not contain any spaces. May or may not contain a trailing newline.</p>
<pre><code>-&gt;s{Z=(s.split'
')&lt;&lt;[]
K=[]
F=-&gt;i,j,f{k=Z[i][j]
K[i]||=0
k==?^?2.times{|m|F[i+1,j+m,f/2]}:!k ?K[j]+=f :F[i+1,j+(k==?/?0:1),f]}
F[0,0,1.0]
K}
</code></pre>
<p><s>Wastes 9 bytes on having to handle <code>0 levels</code> (empty string).</s> All test cases work out correctly, <a href="https://ideone.com/RFMCkN" rel="noreferrer">see here at ideone</a>.</p>
</div>
<div id="pu10" class="pu"><h2>Python 3, 113</h2>

<pre class="lang-python prettyprint-override"><code>P=[1]
for C in input().split():
 l,*Q=0,
 for p,c in zip(P,C):r=p*"\^/".find(c)/2;Q+=l+r,;l=p-r
 P=Q+[l]
print(P)
</code></pre>

<p>Repeatedly updates the probability vector <code>P</code> in response to each line. This new probability vector <code>Q</code> is created one entry at a time. Iterates through the new slots, and computes the contribution from the peg to its right as <code>r</code>, while also computing the remaining contribution to the upcoming slot as <code>p-r</code>.</p>

<p>Expects each line to end in at least one space to avoid an issue where lines end in a backslash.</p>
</div>
<div id="pu11" class="pu"><h1>Perl, 78</h1>

<pre><code>#!perl -p0a
@r=($/=1);$^=.5;@r=map$r-$l+($l=$$_*($r=shift@r)),/./g,$r=$l=0for@F;$_="@r"
</code></pre>

<p>Takes input without spaces.</p>

<p>Try <a href="http://ideone.com/Vv36Dp" rel="nofollow">me</a>.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/49638/">49638</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




