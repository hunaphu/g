<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::264291</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>002</td><td>JavaScript</td><td>230819T173142Z</td><td><a href="https://codegolf.stackexchange.com/questions/264291/how-turing-complete-is-your-language/264382#264382">Joao-3</a></td></tr>
<tr d-ix="1"><td>002</td><td>Lua</td><td>230819T134818Z</td><td><a href="https://codegolf.stackexchange.com/questions/264291/how-turing-complete-is-your-language/264380#264380">bluswimm</a></td></tr>
<tr d-ix="2"><td>002</td><td>Javascript</td><td>230819T073458Z</td><td><a href="https://codegolf.stackexchange.com/questions/264291/how-turing-complete-is-your-language/264377#264377">emanresu</a></td></tr>
<tr d-ix="3"><td>003</td><td>Python 3</td><td>230819T052458Z</td><td><a href="https://codegolf.stackexchange.com/questions/264291/how-turing-complete-is-your-language/264375#264375">dingledo</a></td></tr>
<tr d-ix="4"><td>002</td><td>Python 3</td><td>230818T194537Z</td><td><a href="https://codegolf.stackexchange.com/questions/264291/how-turing-complete-is-your-language/264367#264367">Unrelate</a></td></tr>
<tr d-ix="5"><td>002</td><td>Python 2</td><td>230818T100339Z</td><td><a href="https://codegolf.stackexchange.com/questions/264291/how-turing-complete-is-your-language/264330#264330">Bubbler</a></td></tr>
<tr d-ix="6"><td>nan</td><td>Incident</td><td>230817T212355Z</td><td><a href="https://codegolf.stackexchange.com/questions/264291/how-turing-complete-is-your-language/264310#264310">ais523</a></td></tr>
<tr d-ix="7"><td>002</td><td>C</td><td>230817T190151Z</td><td><a href="https://codegolf.stackexchange.com/questions/264291/how-turing-complete-is-your-language/264302#264302">l4m2</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>JavaScript, 2 subsets</h1>
<p>Here are the subsets, one on each line:</p>
<pre><code>x=&gt;()
Function`${re \}.al
</code></pre>
<p>Both implement lambda calculus, <a href="https://en.wikipedia.org/wiki/Lambda_calculus#Computability" rel="nofollow noreferrer">which is Turing Complete</a>, so I'll explain both.</p>
<p>The first subset allows you to (trivially) express any lambda calculus expression, so it is Turing Complete.</p>
<p>The second subset is possible because of tagged template literals, type coercion and template literal nesting. Here is the identity function on itself:</p>
<pre class="lang-javascript prettyprint-override"><code>Function`F${`return F.call\`F\${F}\``}`.call`F${Function`F${`return F`}`}`
</code></pre>
</div>
<div id="pu1" class="pu"><h1>Lua, 2</h1>

<pre class="lang-lua prettyprint-override"><code>#load(').chr
</code></pre>
<p>The <code>load</code> function allows for arbitrary code execution. <code>('').char</code> allows us to construct a string using charcodes. To get a charcode, all we need to do call char with a string of a certain length. For example, <code>('').char(#'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')</code> gets us a space.</p>
<pre class="lang-lua prettyprint-override"><code>_G[]&quot;\0123456789
</code></pre>
<p>Again, allows for arbitrary code execution. Every global function, including <code>load</code>, is located within the <code>_G</code> table. We can use backslash followed by a number to get an arbitrary character (<code>\32</code> gives us a space). <code>_G[&quot;\108\111\97\100&quot;]</code> allows us to use load, and we can keep using the same trick to execute any code we want.</p>
<p>I don't believe it's possible to get higher than this, as most of the keywords involved in flow control use overlapping characters (<code>for</code>, <code>do</code>, <code>end</code>, <code>then</code>, <code>goto</code>, <code>while</code>, <code>function</code>, etc). I'd love to be proven wrong, though.</p>
</div>
<div id="pu2" class="pu"><h1>Javascript, score 2</h1>
<pre><code>(x)=&gt;
</code></pre>
<p>With this we can implement untyped lambda calculus (idea stolen from <a href="https://codegolf.stackexchange.com/questions/210753/minimal-maximum-byte-for-turing-completeness/210764#210764">this answer</a>)</p>
<pre class="lang-js prettyprint-override"><code>x=xx=&gt;xx // I
xx=x=&gt;xx=&gt;x // K
xxx=x=&gt;xx=&gt;xxx=&gt;x(xxx)(x(xxx)) // S
</code></pre>
<p>Although we don't have newlines or spaces it's easy to do something like this:</p>
<pre><code>(f=()=&gt;f)(&lt;definition&gt;)(&lt;definition&gt;)(&lt;definition&gt;)
</code></pre>
<p>Where each <code>&lt;definition&gt;</code> is a statement.</p>
<hr />
<pre><code>Functioesap`${}%bdf0123456789
</code></pre>
<p>From this we can construct</p>
<pre class="lang-js prettyprint-override"><code>Function`a${unescape`...`}```
</code></pre>
<p>Where the ... is URL-encoded text, in which each character is represented by a <code>%</code> followed by two hexadecimal digits. This allows the execution of arbitrary code. It's not necessary to use all the hex digits, as you could evaluate some other Turing-complete subset of JS, but whatever.</p>
<p>I seriously doubt a score of 3 is possible. Either function calls or some form of loop is required. Function calls require <code>()</code> or backticks, and loops require <code>()</code>. While there are ways to use proxies to allow function calls with <code>[]</code>, those require function calls themselves.</p>
</div>
<div id="pu3" class="pu"><h1>Python 3, score 3</h1>
<pre><code>()+1ğ’¸ğ‘’ğ’½ğ“‡ğ“
'*.23;&lt;=F^_{}ğ“ªğ“¬ğ“®ğ“±ğ“µğ“¹ğ“ºğ“»ğ“¼ğ”
 &quot;%,-0:[]acefinorst~ğ€ğ„ğœğğ¢ğ§ğ¨ğ«ğ¬ğ­ğ±
</code></pre>
<p>This is an extension of <strong><a href="https://codegolf.stackexchange.com/a/264367/88546">@UnrelatedString's answer</a></strong>, but too long to fit in a comment. Each line contains a subset of characters that can perform arbitrary code execution. A meaningless bonus is that none of these require newlines, although there was a reason for this which I explain later.</p>
<h3>Subset 1</h3>
<p>The first subset is simple, and is the same as <a href="https://codegolf.stackexchange.com/users/85334/unrelated-string">@UnrelatedString's</a> second subset. The code itself looks something like this:</p>
<pre class="lang-py prettyprint-override"><code>ğ‘’ğ“ğ‘’ğ’¸(ğ’¸ğ’½ğ“‡(1+1+...+1)+ğ’¸ğ’½ğ“‡(...)+...)
</code></pre>
<h3>Subset 2</h3>
<p>In the other answer, they wondered whether it was possible to set attributes on a type without creating a new <code>class</code>. Yes we can, and a quick examination shows that the following built-ins are available:</p>
<pre class="lang-py prettyprint-override"><code>__loader__, quit, exit, copyright, credits, license, help
</code></pre>
<p>Using one of these built-ins, we can redefine one of its class attributes to avoid using parentheses. We can for example, redefine the less-than operator (<code>&lt;</code>):</p>
<pre class="lang-py prettyprint-override"><code>help.__class__.__lt__=exec;help&lt;'print(1)'
</code></pre>
<p>To construct arbitrary strings, f-strings are a reasonable replacement for concatenation. We can also re-use the trick of redefining operators to call <code>chr()</code>. Here's how to execute <code>print(1)</code> using this subset:</p>
<pre class="lang-py prettyprint-override"><code>ğ“±ğ“®ğ“µğ“¹.__ğ“¬ğ“µğ“ªğ“¼ğ“¼__.__ğ“®ğ“º__=ğ“®ğ”ğ“®ğ“¬;ğ“±ğ“®ğ“µğ“¹.__ğ“¬ğ“µğ“ªğ“¼ğ“¼__.__ğ“µğ“®__=ğ“¬ğ“±ğ“»;ğ“±ğ“®ğ“µğ“¹==F'{ğ“±ğ“®ğ“µğ“¹&lt;=2*2*2*2^2*2*2*2*2^2*2*2*2*2*2}{ğ“±ğ“®ğ“µğ“¹&lt;=2^2*2*2*2^2*2*2*2*2^2*2*2*2*2*2}{ğ“±ğ“®ğ“µğ“¹&lt;=2^3^2*2*2^2*2*2*2*2^2*2*2*2*2*2}{ğ“±ğ“®ğ“µğ“¹&lt;=2^2*2^2*2*2^2*2*2*2*2^2*2*2*2*2*2}{ğ“±ğ“®ğ“µğ“¹&lt;=2*2^2*2*2*2^2*2*2*2*2^2*2*2*2*2*2}{ğ“±ğ“®ğ“µğ“¹&lt;=2*2*2^2*2*2*2*2}{ğ“±ğ“®ğ“µğ“¹&lt;=2^3^2*2*2*2^2*2*2*2*2}{ğ“±ğ“®ğ“µğ“¹&lt;=2^3^2*2*2^2*2*2*2*2}'
</code></pre>
<h3>Subset 3</h3>
<p>We've already used up <code>.</code>, <code>=</code>, and <code>()</code>, so finding a way to call <code>exec</code> is becoming difficult. The one thing that is free are variable names, since Unicode provides us with more than enough variations of each letter. However, it is possible to do so by abusing asserts:</p>
<pre class="lang-py prettyprint-override"><code>AssertionError=exec;assert 0,'print(1)'
</code></pre>
<p><code>assert</code> takes two arguments: the pass/fail condition, and a string which is printed when the condition fails. This is roughly equivalent to <code>if cond: raise AssertionError(msg)</code>. By reassigning <code>AssertionError</code> to <code>exec</code>, the <code>msg</code> parameter effectively becomes the first argument of <code>exec</code>. Curiously, this feature seems exclusive to <code>AssertionError</code>, as other error types I've tried don't behave like this. Anyway, this by itself doesn't work because we can't use <code>=</code> or <code>;</code>.</p>
<p>The second trick is to abuse <code>for</code> loops. Let's just do <code>for AssertionError in[exec]:</code> instead! The last thing we need is the string construction, which can be done using <code>%</code>-formatting and repeated <code>-~</code>s. The size of the code grows exponentially, but here's an <code>exec('print(1)')</code>:</p>
<pre class="lang-py prettyprint-override"><code>for ğ€ğ¬ğ¬ğğ«ğ­ğ¢ğ¨ğ§ğ„ğ«ğ«ğ¨ğ« in[ğğ±ğğœ]:assert 0,&quot;%c%%c%%%%c%%%%%%%%c%%%%%%%%%%%%%%%%c%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%c%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%c%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%c&quot;%-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~0%-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~0%-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~0%-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~0%-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~0%-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~0%-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~0%-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~0
</code></pre>
<h3>Subset 4??</h3>
<p>Originally, I planned for a 4th subset through executing Python bytecode, since Python is able to natively run <code>pyc</code> files. The magic header for <code>pyc</code> files in Python 3.11 is <code>\xa7\x0d\x0d\x0a</code>. I noticed the <code>\x0d</code> and <code>\x0a</code> as being newlines, so I crafted my other solutions specifically without them. But I somehow missed the <code>\xa7</code> byte which is not representable in UTF-8, making this solution automatically invalid.</p>
<p>Still, there is some good potential for a 4th subset. For example, using <code>#coding:u7</code> to change the source's encoding could've also worked in place of Subset 3. Decorators are a possibility as well. I also vaguely recall Python also being able to natively handle zip files, and the PKZip magic header makes this a possibility: <code>\x50\x4b\x03\x04</code>.</p>
<p>Lastly, the challenge only asks for &quot;Turing-completeness&quot;, not arbitrary code execution. I only tried to do the latter, so it's possible that scoring 4 is quite a bit easier than I'm making it.</p>
</div>
<div id="pu4" class="pu"><h1>Python 3, score 2</h1>
<h2>Arbitrary code execution without <code>()</code></h2>
<pre><code>clags x:[]
_.time=hr+1
</code></pre>
<p>Any function <code>f</code> of a single argument can be called without parentheses as so:</p>
<pre class="lang-python prettyprint-override"><code>class F:[]
F.__class_getitem__=f
F[arg]
</code></pre>
<p>where <code>F</code> can obviously be any identifier constructed from the characters in the set, and the <code>[]</code> is just a funny way to <code>pass</code> because it would feel weird to put <code>p</code> in the set just for that. <code>exec</code> and <code>chr</code> only need one argument, and <code>+</code> doesn't need parentheses to begin with.</p>
<p><a href="https://ato.pxeger.com/run?1=m72soLIkIz9vwYKlpSVpuhY3ZxcUZeaVaKirqyfnJBYXK6RaRcdyperFx4O58empJZklqbnx8bapFanJXBA1ySA1yVjUJGcUAQ3S5IKamRqtrg2Eeln5mXka6skoPEN1rfyiFI1kTU1t9Vj1tPwihWSFzDwgKigt0YAIakKcCHXpgm0QU5U8UnNy8nUUyvOLclIUlaCKAA" rel="noreferrer">Translate here.</a></p>
<h2>Arbitrary code execution without <code>=</code>, or the characters in <code>exec</code></h2>
<pre><code>(~{f0ï½’&quot;ï½ƒï½ˆï½…ï½˜}-)
</code></pre>
<p>I guess the lack of <code>=</code> isn't a big deal since this doesn't <a href="https://codegolf.stackexchange.com/a/110722/78410">have to milk out every last character</a>, actually; the real highlight is <code>exec</code>ing without <code>exec</code> by abusing Python's NFKC normalization of identifiers. With <code>+1</code> taken, arbitrary integers are constructed with <code>-~0</code>, and the characters are concatenated in an f-string.</p>
<p><a href="https://ato.pxeger.com/run?1=m72soLIkIz9vwYKlpSVpuhY3wwqKMvNKNNTf7219v3cGmGzWSFNS11ZX18vKz8zTUK8Girzf2_F-7yQNoKhunbpWflGKRrKmtrqBZq16Wn6RQrJCZh4QFZSWaGgChZU01TUhpkMtWbANYomSR2pOTr6OQnl-UU6KohJUEQA" rel="noreferrer">Translate here.</a></p>
<hr />
<p>While it's difficult to imagine a score-3 solution, a few extra bits of note:</p>
<ul>
<li>Spaces can be replaced with backslash-newline combinations.</li>
<li>There's plenty of other stuff that normalizes to <code>exec</code>, provided you can find a third way to call it.</li>
<li>Obviously, arbitrary code execution isn't necessary for Turing completeness; I actually meant to do the <code>__class_getitem__</code> set without <code>exec</code> to begin with by implementing ais's <a href="https://esolangs.org/wiki/The_Waterfall_Model" rel="noreferrer">Waterfall Model</a> but once I started using list comprehensions I realized I may as well just cheap out and do something easier to play with.</li>
<li>If there's any way to get a type you can set <code>__class_getitem__</code> on (or make a type you can define normal <code>__getitem__</code> for) without a <code>class</code> definition (or calling <code>type</code>), then that frees <code>:</code> up for control flow statements. How to do anything with them without newlines, parentheses, or <code>=</code> is beyond me.</li>
</ul>
</div>
<div id="pu5" class="pu"><h1>Python 2, score 2</h1>
<h3>Arbitrary code execution with <code>exec</code> and <code>%</code> formatting (from <a href="https://codegolf.stackexchange.com/a/110722/78410">this answer</a> by xsot)</h3>
<pre><code>exc=&quot;%

</code></pre>
<p>(six visible chars and newline)</p>
<h3>Untyped lambda calculus with <code>lambda</code> (from <a href="https://codegolf.stackexchange.com/a/210764/78410">this answer</a> of mine)</h3>
<pre><code>lambd :()
</code></pre>
<p>The score for Python 3 would be very likely 1 since <code>()</code>s are necessary for more things.</p>
</div>
<div id="pu6" class="pu"><h2><a href="https://esolangs.org/wiki/Incident" rel="noreferrer">Incident</a>, 128 or 557056</h2>
<h3>If &quot;character&quot; means byte</h3>
<p>Any set of two bytes is Turing-complete in Incident; thus it's possible to create 128 disjoint subsets, e.g. {0x00, 0x01}, {0x02, 0x03}, {0x04, 0x05}, and so on up to {0xFE, 0xFF}.</p>
<p>The reason is that the language determines its token set at runtime: the set of tokens used by a program is the set of substrings of that program that appear exactly three times (without being contained within or overlapping other such substrings within the input program). The language gives meanings to tokens based on their relative positioning, rather than the bytes that make them up. As such, an Incident program is <code>tr</code>-invariant; you can change the character set it uses simply by consistently replacing bytes, because that doesn't change the token structure of the program.</p>
<p>(The creation of Incident was actually inspired by this site: I wanted to find a way to avoid <a href="/questions/tagged/answer-chaining" class="post-tag" title="show questions tagged &#39;answer-chaining&#39;" aria-label="show questions tagged &#39;answer-chaining&#39;" rel="tag" aria-labelledby="tag-answer-chaining-tooltip-container">answer-chaining</a> <a href="/questions/tagged/restricted-code" class="post-tag" title="show questions tagged &#39;restricted-code&#39;" aria-label="show questions tagged &#39;restricted-code&#39;" rel="tag" aria-labelledby="tag-restricted-code-tooltip-container">restricted-code</a> questions getting stuck in a set of bytes that they had no way to get themselves out of. So being Turing-complete off any set of two bytes is a natural consequence of the way the language developed.)</p>
<h3>If &quot;character&quot; means Unicode character</h3>
<p>Incident doesn't attempt to parse its input into characters; it just looks at it as a single binary stream of bytes. However, that doesn't mean that you can't just simply feed a text file to the Incident interpreter. As such, it's meaningful to ask about what subsets of Unicode characters are Turing-complete if you put them into a text file, and ask the Incident interpreter to run the resulting text file as a program.</p>
<p>Assuming that the two characters in question have no bytes in common in their encodings, you actually end up with the exact same case as when you're using two different bytes: the &quot;identify substrings that occur three times&quot; routine is invariant under the operation of replacing one byte with two or more, so long as each byte that appear within the encoding always uniquely comes from one of the same two original characters. As such, the goal is to find 557056 subsets (because there are 1114112 encodeable Unicode characters).</p>
<p>This can be done fairly simply using UTF-8, choosing the two characters in each subset to always be the same length as each other:</p>
<ul>
<li><p>For ASCII (0x00 to 0x7F), simply pair the characters as bytes, as in the previous case;</p>
</li>
<li><p>For two-byte characters, sort the characters into four groups {00, 01, 10, 11}, based on the least significant bit of their leading byte and least significant bit of their trailing byte: all four groups are the same size. Characters in group 00 have no bytes in common with characters in group 11, so you can form a subset by pairing an arbitrary character in each group. Likewise, characters in group 01 have no bytes in common with characters in group 10, so those form subsets in the same way.</p>
</li>
<li><p>For three-byte characters, divide into groups based on the least significant bit of the leading byte and the least significant two bits of the trailing byte: this produces 32 groups which are all the same size. The groups can be paired into 16 pairs as follows:</p>
<pre><code>0 00 00 with 1 11 11
0 00 01 with 1 11 10
0 00 10 with 1 11 01
0 00 11 with 1 01 10
0 01 00 with 1 10 11
0 01 01 with 1 10 10
0 01 10 with 1 00 11
0 01 11 with 1 10 00
0 10 00 with 1 01 11
0 10 01 with 1 11 00
0 10 10 with 1 01 01
0 10 11 with 1 01 00
0 11 00 with 1 10 01
0 11 01 with 1 00 10
0 11 10 with 1 00 01
0 11 11 with 1 00 00
</code></pre>
<p>For each pair of groups, picking an arbitrary character from each group will produce a valid subset (i.e. no bytes that exist in one character in UTF-8 will exist in the other).</p>
</li>
<li><p>Four-byte characters use a similar construction, but now 1024 groups are used (taking one bit from the leading byte and three bits from each of the trailing bytes). Listing all the pairings wouldn't easily fit in the post, so here are the rules:</p>
<ul>
<li>Label the bits of each group as <code>A BCD EFG HIJ</code>.</li>
<li>Consider the three values obtained by bitwise-XORing two of <code>BCD</code>, <code>EFG</code> and <code>HIJ</code>:
<ul>
<li>if none of them are 1 (001), XOR the group number with <code>1 001 001 001</code> to produce the group number it's paired with; otherwise,</li>
<li>if none of them are 2 (010), XOR the group number with <code>1 010 010 010</code> to produce the group number it's paired with; otherwise,</li>
<li>if none of them are 4 (100), XOR the group number with <code>1 100 100 100</code> to produce the group number it's paired with.</li>
</ul>
</li>
</ul>
<p>It is not possible for the three resulting values to be 1, 2 and 4 (if BCD xor EFG is 1 and EFG xor HIJ is 2, then BCD xor HIJ is BCD xor EFG xor EFG xor HIJ which is 3; likewise for other assigments of positions to values). So these rules will always produce a result. Additionally, the pairing is consistent (i.e. if X is paired with Y, then Y will be paired with X); this is because the same number is being XORed into all three of the relevant segments of the trailing bytes, so it won't change the result you get when you XOR two of those segments together. Finally, it will ensure that the two members of each subset have no bytes in common because their leading bytes have different parities, and there is no way for a trailing byte of one member to equal a trailing byte of the other member (which can be seen by considering the pairwise XORs of the two equal trailing bytes, and the bytes in the corresponding position of the other member).</p>
</li>
</ul>
<p>There is some room for interpretation as to whether 557056 is actually the correct number of subsets here, depending on what exactly you consider a Unicode character to be. For example, the original version of UTF-8 allowed up to 2<sup>31</sup> different characters, meaning 2<sup>30</sup> subsets, but Unicode is nowadays capped at 1114112. Additionally, some of the characters may be considered invalid due to, e.g., being noncharacters or surrogates. However, the Incident interpreter doesn't care about any of this because it isn't trying to parse the UTF-8 anyway, and just looks at the bytes that make it up.</p>
</div>
<div id="pu7" class="pu"><h2>C, 2</h2>
<p><a href="https://tio.run/##LcmxCoAwDIThvU/RUYfg3hJ8FskQhJhb3MRnj2lxuQ/@E1KRuI7Tl/UJg2u1Xqb49ZSNMoNBWZ2dMhZthUY2Hptg96bz3/JX3Kja440P" rel="nofollow noreferrer"><code>longt=-/ ?:;</code></a></p>
<p><a href="https://tio.run/##S9ZNT07@/z9NI1EnSSdZs7qWKzcxM09DszozTSNNw0AHCDWBorX//wMA" rel="nofollow noreferrer">others</a></p>
<p><sup>Body must be at least 30 characters; you entered 24.</sup></p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/264291/">264291</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




