<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::101709</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>004</td><td>Uiua</td><td>251011T231514Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/284094#284094">phidas</a></td></tr>
<tr d-ix="1"><td>nan</td><td></td><td>251011T074147Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/284086#284086">maledisc</a></td></tr>
<tr d-ix="2"><td>031</td><td>Rust</td><td>200813T163343Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/209530#209530">TehPers</a></td></tr>
<tr d-ix="3"><td>002</td><td>Keg</td><td>200814T083116Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/209554#209554">lyxal</a></td></tr>
<tr d-ix="4"><td>015</td><td>asm2bf</td><td>200814T082204Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/209552#209552">Kamila S</a></td></tr>
<tr d-ix="5"><td>002</td><td>Aceto</td><td>170529T103413Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/123313#123313">L3viatha</a></td></tr>
<tr d-ix="6"><td>014</td><td>Flurry</td><td>200813T083326Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/209508#209508">Esolangi</a></td></tr>
<tr d-ix="7"><td>005</td><td>SMBF</td><td>161201T225606Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101866#101866">mbomb007</a></td></tr>
<tr d-ix="8"><td>002</td><td>Implicit</td><td>171125T181437Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/149067#149067">MD XF</a></td></tr>
<tr d-ix="9"><td>008</td><td>Whitespace</td><td>170529T095557Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/123310#123310">Ephphath</a></td></tr>
<tr d-ix="10"><td>162</td><td>VB.NET</td><td>170406T110242Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/115505#115505">David</a></td></tr>
<tr d-ix="11"><td>010</td><td>C</td><td>170315T212958Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/113000#113000">Bijan</a></td></tr>
<tr d-ix="12"><td>5804</td><td>Sinclair ZX80/ZX81 BASIC</td><td>170405T115951Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/115317#115317">Shaun Be</a></td></tr>
<tr d-ix="13"><td>055</td><td>c#</td><td>170406T063220Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/115460#115460">jdt</a></td></tr>
<tr d-ix="14"><td>012</td><td>OIL</td><td>170405T120640Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/115318#115318">L3viatha</a></td></tr>
<tr d-ix="15"><td>003</td><td>√ å ı ¥ ® Ï Ø ¿</td><td>170315T211040Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/112999#112999">caird co</a></td></tr>
<tr d-ix="16"><td>109</td><td>C#</td><td>170307T121733Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/112231#112231">TheLetha</a></td></tr>
<tr d-ix="17"><td>028</td><td>C#</td><td>170215T084320Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/110110#110110">Mika</a></td></tr>
<tr d-ix="18"><td>002</td><td>V</td><td>170215T083313Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/110109#110109">DJMcMayh</a></td></tr>
<tr d-ix="19"><td>010</td><td>BrainFlak</td><td>170215T073223Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/110105#110105">Pavel</a></td></tr>
<tr d-ix="20"><td>064</td><td>Commodore</td><td>170210T163326Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/109686#109686">Shaun Be</a></td></tr>
<tr d-ix="21"><td>005</td><td>sed</td><td>161201T203138Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101834#101834">zeppelin</a></td></tr>
<tr d-ix="22"><td>018</td><td>SmileBASIC</td><td>170206T232038Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/109340#109340">12Me21</a></td></tr>
<tr d-ix="23"><td>004</td><td>Dyalog APL</td><td>161208T115007Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/102495#102495">Ad&#225;</a></td></tr>
<tr d-ix="24"><td>018</td><td>JavaScript</td><td>161208T095636Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/102490#102490">Filip Du</a></td></tr>
<tr d-ix="25"><td>001</td><td>Labyrinth</td><td>161202T190259Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101965#101965">Stefnotc</a></td></tr>
<tr d-ix="26"><td>104</td><td>Java</td><td>161205T133531Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/102186#102186">Aron_dc</a></td></tr>
<tr d-ix="27"><td>236</td><td>BotEngine</td><td>161205T131631Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/102184#102184">SuperJed</a></td></tr>
<tr d-ix="28"><td>022</td><td>F#</td><td>161205T101909Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/102172#102172">pmbanka</a></td></tr>
<tr d-ix="29"><td>014</td><td>PowerShell</td><td>161204T063340Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/102081#102081">Booga Ro</a></td></tr>
<tr d-ix="30"><td>016</td><td>Mathematica</td><td>161204T050951Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/102077#102077">Eric Tow</a></td></tr>
<tr d-ix="31"><td>008</td><td>Python</td><td>161203T213913Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/102051#102051">asmeurer</a></td></tr>
<tr d-ix="32"><td>004</td><td>Perl</td><td>161203T094844Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/102022#102022">primo</a></td></tr>
<tr d-ix="33"><td>035</td><td>Ceylon</td><td>161201T224830Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101864#101864">Paŭlo Eb</a></td></tr>
<tr d-ix="34"><td>nan</td><td>JAVA</td><td>161202T031500Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101878#101878">Depresse</a></td></tr>
<tr d-ix="35"><td>nan</td><td>Java</td><td>161202T215148Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101995#101995">user1893</a></td></tr>
<tr d-ix="36"><td>013</td><td>Python REPL</td><td>161201T202543Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101833#101833">FlipTack</a></td></tr>
<tr d-ix="37"><td>005</td><td>Bash + coreutils</td><td>161201T223638Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101862#101862">Digital </a></td></tr>
<tr d-ix="38"><td>023</td><td>C linux</td><td>161201T034304Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101722#101722">Digital </a></td></tr>
<tr d-ix="39"><td>019</td><td>SAS</td><td>161202T103126Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101895#101895">user3490</a></td></tr>
<tr d-ix="40"><td>003</td><td>Fission</td><td>161202T143018Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101933#101933">user4180</a></td></tr>
<tr d-ix="41"><td>013</td><td>PHP</td><td>161201T213343Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101852#101852">MonkeyZe</a></td></tr>
<tr d-ix="42"><td>003</td><td>Microscript II</td><td>161201T202043Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101831#101831">SuperJed</a></td></tr>
<tr d-ix="43"><td>008</td><td>TIBASIC</td><td>161202T105342Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101898#101898">user5550</a></td></tr>
<tr d-ix="44"><td>003</td><td>Actually</td><td>161202T104703Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101896#101896">user4594</a></td></tr>
<tr d-ix="45"><td>027</td><td>Kotlin</td><td>161202T061217Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101885#101885">F. Georg</a></td></tr>
<tr d-ix="46"><td>012</td><td>tinylisp repl</td><td>161202T060953Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101884#101884">DLosc</a></td></tr>
<tr d-ix="47"><td>011</td><td>Haskell using ghc 8.0.1</td><td>161201T191822Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101819#101819">nimi</a></td></tr>
<tr d-ix="48"><td>007</td><td>dc</td><td>161202T010909Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101874#101874">faubi</a></td></tr>
<tr d-ix="49"><td>009</td><td>WinDbg</td><td>161201T232313Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101869#101869">milk</a></td></tr>
<tr d-ix="50"><td>001</td><td>Funge98 cfunge</td><td>161201T190541Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101817#101817">user6213</a></td></tr>
<tr d-ix="51"><td>015</td><td>C++ using g++ compiler</td><td>161201T025551Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101715#101715">Wheat Wi</a></td></tr>
<tr d-ix="52"><td>005</td><td>Brainfuck</td><td>161201T111428Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101759#101759">vsz</a></td></tr>
<tr d-ix="53"><td>007</td><td>///</td><td>161201T203207Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101835#101835">steenber</a></td></tr>
<tr d-ix="54"><td>007</td><td>TI83 Hex Assembly</td><td>161201T194742Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101827#101827">habs</a></td></tr>
<tr d-ix="55"><td>002</td><td>05AB1E</td><td>161201T185640Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101816#101816">Magic Oc</a></td></tr>
<tr d-ix="56"><td>003</td><td>Pushy</td><td>161201T192047Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101822#101822">FlipTack</a></td></tr>
<tr d-ix="57"><td>011</td><td>Ruby</td><td>161201T192037Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101821#101821">daniero</a></td></tr>
<tr d-ix="58"><td>001</td><td>><> Fish</td><td>161201T191504Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101818#101818">redstarc</a></td></tr>
<tr d-ix="59"><td>016</td><td>Python</td><td>161201T185312Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101815#101815">FlipTack</a></td></tr>
<tr d-ix="60"><td>019</td><td>Haskell</td><td>161201T071839Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101733#101733">Angs</a></td></tr>
<tr d-ix="61"><td>015</td><td>JavaScript  15 Bytes</td><td>161201T100301Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101752#101752">Lmis</a></td></tr>
<tr d-ix="62"><td>035</td><td>Python</td><td>161201T113134Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101763#101763">Noelkd</a></td></tr>
<tr d-ix="63"><td>012</td><td>Perl</td><td>161201T030614Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101718#101718">BenGoldb</a></td></tr>
<tr d-ix="64"><td>046</td><td>Rust</td><td>161201T091115Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101748#101748">user6126</a></td></tr>
<tr d-ix="65"><td>101</td><td>Java</td><td>161201T081513Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101741#101741">masterX2</a></td></tr>
<tr d-ix="66"><td>013</td><td>Racket</td><td>161201T074307Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101735#101735">Winny</a></td></tr>
<tr d-ix="67"><td>024</td><td>Haskell</td><td>161201T065546Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101731#101731">Laikoni</a></td></tr>
<tr d-ix="68"><td>106</td><td>Java 7</td><td>161201T053900Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101730#101730">Poke</a></td></tr>
<tr d-ix="69"><td>002</td><td>BASH</td><td>161201T042007Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101726#101726">Ipor Sir</a></td></tr>
<tr d-ix="70"><td>002</td><td>Jelly</td><td>161201T033201Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101721#101721">Jonathan</a></td></tr>
<tr d-ix="71"><td>016</td><td>Python 3</td><td>161201T034614Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101723#101723">artifici</a></td></tr>
<tr d-ix="72"><td>013</td><td>Perl 6</td><td>161201T024643Z</td><td><a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101713#101713">Brad Gil</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Uiua, 4 bytes</h1>
<pre><code>⍢1 1
</code></pre>
<p><a href="https://uiua.org/pad?src=0_18_0-dev_1__4o2iMSAxCg==" rel="nofollow noreferrer">(don't) Try it in the pad!</a></p>
<p>Repeatedly pushes <code>1</code> to the stack. An out of memory error is hard to achieve in Uiua pad due to execution time and array size limits and I didn't want to test it on my computer, but it would (theoretically) work.</p>
</div>
<div id="pu1" class="pu"><h1>Binary encoded lambda calculus: 22 bits</h1>
<p>while not realy memory allocation it does need infinite space</p>
<p><code>0100011010000101101010</code></p>
<p>More conventional notation:
(λx.(x x) λx.((x x) x))</p>
<p>How does that work?</p>
<p>It first beta reduces to
(λx.((x x) x) λx.((x x) x))</p>
<p>which then reduces to
((λx.((x x) x) λx.((x x) x)) λx.((x x) x))</p>
<p>then reduces to
(((λx.((x x) x) λx.((x x) x)) λx.((x x) x))) λx.((x x) x))</p>
<p>and then to
((((λx.((x x) x) λx.((x x) x)) λx.((x x) x))) λx.((x x) x)) λx.((x x) x))</p>
<p>im sure you see the pattern.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.rust-lang.org/" rel="nofollow noreferrer">Rust</a>, <s>35</s> 31 bytes</h1>
<p>-4 bytes thanks to madlaina (<code>into_raw</code> -&gt; <code>leak</code>)</p>
<pre><code>||loop{Box::leak(Box::new(0));}
</code></pre>
<p><a href="https://tio.run/##HcwxDoAgDIXhvafo2A4mzmgcHLiHQ4lGBaMYTJCzI7i9N/zfeV8@G4v7tFhijIDo5fKU33dz7oije5TaZFrpX1YCtcxdyojcQQIobQ16PZBRqBnCLKcURpdXyWZAYqiwoZrkDw" rel="nofollow noreferrer">Try it online</a></p>
<h3>Full program, 40 bytes</h3>
<pre><code>fn main(){loop{Box::leak(Box::new(0));}}
</code></pre>
<p><a href="https://tio.run/##KyotLvn/Py1PITcxM09DszonP7@g2im/wsoqJzUxWwPMykst1zDQ1LSurf3/HwA" rel="nofollow noreferrer">Try it online</a></p>
<p>Unlike the other Rust solution, this uses <code>Box::leak</code> to leak the boxed value, turning it into a <code>&amp;'static mut i32</code>.</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/JonoCode9374/Keg" rel="nofollow noreferrer">Keg</a>, 2 bytes</h1>
<pre><code>{a
</code></pre>
<p><a href="https://tio.run/##y05N//@/OvH/fwA" rel="nofollow noreferrer" title="Keg – Try It Online">Try it online!</a></p>
<p>Simply push infinite <code>a</code>s</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/kspalaiologos/asmbf" rel="nofollow noreferrer">asm2bf</a> - 15 bytes</h1>
<pre><code>@l
psh 1
jmp %l
</code></pre>
<p>Will push <code>1</code> until the interpreter/system runs out of memory.</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/aceto/aceto" rel="nofollow noreferrer">Aceto</a>, 2 bytes</h1>
<pre><code>e&gt;
</code></pre>
<p>Pushes <em>e</em> (2.71..) on the stack, and moves the IP back to the first cell.</p>
<p>There are of course many 2-byte solutions in Aceto, (any single character literal (<code>1234567890ePR'</code>), followed by a command that makes the thing infinite (I can think of <code>&lt;&gt;O</code>, but there might be more), but I chose <code>e&gt;</code> because it looks a bit like a heart (<code>&lt;3</code> sadly doesn't work).</p>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/Reconcyl/flurry" rel="nofollow noreferrer">Flurry</a>, 14 bytes</h1>
<pre><code>(&lt;&gt;{}{({})}){}
</code></pre>
<p>Adapted from <a href="https://codegolf.stackexchange.com/a/209408/61384">this answer</a>. One of the <code>{}</code> terms is replaced with <code>{({})}</code>, a function which pushes its argument to the stack. Thus the infinite loop grows the stack on every iteration.</p>
</div>
<div id="pu7" class="pu"><h1><a href="https://esolangs.org/wiki/Self-modifying_Brainfuck" rel="nofollow noreferrer">SMBF</a>, 5 bytes</h1>
<p>Although the <a href="https://codegolf.stackexchange.com/a/101759/34718">brainfuck solution</a> also works in SMBF, I decided to create a solution that only works in SMBF.</p>
<pre><code>&lt;[&gt;+]
</code></pre>
<p>Since the source is placed on the tape to the left of the pointer, <code>&lt;</code> will move the pointer to point at <code>]</code>, and then we loop, traveling forever on the tape.</p>
</div>
<div id="pu8" class="pu"><h1><a href="//git.io/sS" rel="nofollow noreferrer">Implicit</a>, 2 bytes</h1>

<pre><code>(a
</code></pre>

<p><a href="https://tio.run/##K87MLchJLS5JTM7@/18j8f9/AA" rel="nofollow noreferrer">Try it online!</a> (Uses up all allowed TIO memory in about 1 second)</p>

<pre><code>(   create jump point
 a  push 97
    implicit infinite loop
</code></pre>
</div>
<div id="pu9" class="pu"><h1><a href="https://web.archive.org/web/20150618184706/http://compsoc.dur.ac.uk/whitespace/tutorial.php" rel="nofollow noreferrer">Whitespace</a>, 8 bytes</h1>

<pre><code>
&#32;&#32;

&#32;&#9;

</code></pre>

<p><a href="https://tio.run/nexus/whitespace#@8@loMDFpcDJ9f8/AA" rel="nofollow noreferrer" title="Whitespace – TIO Nexus">Try it online!</a></p>

<h2>Explanation</h2>

<p>(s - space, t - tab, n - newline)</p>

<pre><code>nssn ; Declares a label consisting of the empty sequence
nstn ; Call the procedure given by the empty label (declared above)
</code></pre>

<p>This is a slight abuse of the rules. The call procedure command jumps to the specified label and marks the current location for a later return. The mechanisms for doing this are implementation dependent but a basic implementation used by many interpreters is to push the current location to a call stack and pop values when a ret command is encountered. This will therefore end up filling up the call stack of the interpreter.</p>

<hr>

<h1><a href="https://web.archive.org/web/20150618184706/http://compsoc.dur.ac.uk/whitespace/tutorial.php" rel="nofollow noreferrer">Whitespace</a>, 12 bytes - Fills the stack</h1>

<pre><code>
&#32;&#32;
&#32;&#32;&#32;

&#32;


</code></pre>

<p><a href="https://tio.run/nexus/whitespace#@8@loABEClxcQPT/PwA" rel="nofollow noreferrer" title="Whitespace – TIO Nexus">Try it online!</a></p>

<h2>Explanation</h2>

<pre><code>nssn ; Declare label ''
sssn ; Push 0
nsnn ; Jump to label ''
</code></pre>

<p>Continuously pushes the value 0 to the stack, causing the stack to grow until the interpreter crashes.</p>

<hr>

<h1><a href="https://web.archive.org/web/20150618184706/http://compsoc.dur.ac.uk/whitespace/tutorial.php" rel="nofollow noreferrer">Whitespace</a>, 29 bytes - Fills the heap</h1>

<pre><code>&#32;&#32;&#32;&#9;

&#32;&#32;
&#32;
&#32;&#9;&#32;&#32;&#32;&#32;
&#32;&#32;
&#32;&#9;&#9;&#32;
&#32;


</code></pre>

<p><a href="https://tio.run/nexus/whitespace#@6@goMDJxaWgwAWEnECOApjNyQkS4Pr/HwA" rel="nofollow noreferrer" title="Whitespace – TIO Nexus">Try it online!</a></p>

<h2>Explanation</h2>

<pre><code>ssstn ; push 1
nssn  ; label ''
sns   ; duplicate n
tsss  ; add (effectively multiplies by 2)
sns   ; duplicate n (to use as a heap address)
sns   ; duplicate n (to use as a value)
tts   ; store n at the address n
nsnn  ; jump ''
</code></pre>

<p>Fills heap addresses given by 2^n with the value of 2^n, starting at n=1. Consumes memory faster on interpreters that implement the heap as an array but will also work for interpreters that use a non-contiguous data structure backing the heap (such as a dictionary/map).</p>
</div>
<div id="pu10" class="pu"><h1>VB.NET, 162 bytes</h1>

<pre><code>Module m
    Sub Main()
        Dim s = ""
        While (1)
            s = s + "1" : Threading.Thread.Sleep(2147483647)
        End While
    End Sub
End Module
</code></pre>

<p>It won't really run forever but close enough. It should take about 584942417 years to allocate 8gb.</p>
</div>
<div id="pu11" class="pu"><h1>C, 10 bytes</h1>

<pre><code>f(x){f();}
</code></pre>

<p>The x is needed for memory to be used in addition to stack space. This will endlessly make calls to itself each time taking ~32bits to store x.</p>
</div>
<div id="pu12" class="pu"><h1>Sinclair ZX80/ZX81 BASIC, <strike>~14 bytes</strike> ~7 bytes (ZX81/ZX80 8K ROM), <strike>~10 bytes</strike> ~5 bytes (ZX80 4K ROM)</h1>

<pre><code> 1 GOSUB 1
</code></pre>

<p>As there is never a return from the GOSUB (presented as <code>GO SUB</code> on the ZX80 with 4K ROM), the stack is filled which will eventually cause the interpreter to error. To clear the stack, simply enter <code>NEW</code> which should initiate a soft reset.</p>
</div>
<div id="pu13" class="pu"><h1>c#, 55 bytes</h1>
<pre><code>class c{static void Main(){string c=&quot;&quot;;for(;;)c+='c';}}
</code></pre>
<p>Alternative 54 bytes</p>
<pre><code>class c{static void Main(){string c=&quot;c&quot;;for(;;)c+=c;}}
</code></pre>
</div>
<div id="pu14" class="pu"><h1><a href="https://github.com/L3viathan/OIL" rel="nofollow noreferrer">OIL</a>, 12 bytes</h1>
<p>Here in annotated form (remove anything but numbers to run):</p>
<pre><code>1 # copy
-1 # from line -1 (containing, by default, a 0)
6 # to line 6 (the first line after the last line) %
8 # increment
2 # line 2 (marked with %)
6 # goto (since the next line will now be 0, go to line 0)
</code></pre>
<p>Even though seemingly nothing changes (lines are 0 by default and are being set to 0), internally, there's a difference between an unallocated line and a line with an explicit 0 in it.</p>
</div>
<div id="pu15" class="pu"><h1><a href="https://github.com/ValyrioCode/Valyrio" rel="nofollow noreferrer">√ å ı ¥ ® Ï Ø ¿</a> , 3 bytes</h1>

<pre><code>(1)
</code></pre>

<h2>Explanation</h2>

<pre><code>(   › Start an infinite loop
 1  › Push 1 to the stack
  ) › End an infinite loop
</code></pre>
</div>
<div id="pu16" class="pu"><h2>C#, 109 bytes</h2>
<pre><code>public class P{static void Main({for(;;)System.Xml.Serialization.XmlSerializer.FromTypes(new[]{typeof(P)});}}
</code></pre>
<p>Cross posted from <a href="https://codegolf.stackexchange.com/a/112228/38550">here</a> because it answers this question nicely as well.</p>
<p>We found the idea behind this leak in production code and researching it leads to <a href="https://blogs.msdn.microsoft.com/tess/2006/02/15/net-memory-leak-xmlserializing-your-way-to-a-memory-leak/" rel="nofollow noreferrer">this article.</a> The main problem is in this long quote from the article (read it for more info):</p>
<blockquote>
<p>Searching my code for <code>PurchaseOrde</code>r, I find this line of code in <code>page_load</code> of one of my pages <code>XmlSerializer serializer = new XmlSerializer(typeof(PurchaseOrder), new XmlRootAttribute(“”));</code></p>
<p>This would seem like a pretty innocent piece of code. We create an <code>XMLSerializer</code> for <code>PurchaseOrder</code>. But what happens under the covers?</p>
<p>If we take a look at the <code>XmlSerializer</code> constructor with Reflector we find that it calls <code>this.tempAssembly = XmlSerializer.GenerateTempAssembly(this.mapping, type, defaultNamespace, location, evidence);</code> which generates a temp (dynamic) assembly. So every time this code runs (i.e. every time the page is hit) it will generate a new assembly.</p>
<p>The reason it generates an assembly is that it needs to generate functions for serializing and deserializing and these need to reside somewhere.</p>
<p>Ok, fine… it creates an assembly, so what? When we’re done with it, it should just disappear right?</p>
<p>Well… an assembly is not an object on the GC Heap, the GC is really unaware of assemblies, so it won’t get garbage collected. The only way to get rid of assemblies in 1.0 and 1.1 is to unload the app domain in which it resides.</p>
<p>And therein lies the problem Dr Watson.</p>
</blockquote>
<p>Running from the compiler in Visual Studio 2015 and using the Diagnostic Tools Window shows the following results after about 38 seconds. Note the Process memory is steadily climbing and the Garbage Collector (GC) keeps running but can't collect anything.</p>
<p><a href="https://blogs.msdn.microsoft.com/tess/2006/02/15/net-memory-leak-xmlserializing-your-way-to-a-memory-leak/" rel="nofollow noreferrer"><img src="https://i.sstatic.net/2xuNb.png" alt="Diagnostic Tools Window" /></a></p>
</div>
<div id="pu17" class="pu"><h1>C#, 28 bytes</h1>

<pre><code>()=&gt;{var _="a";for(;;)_+=_;}
</code></pre>

<p>What is there to say? It adds the contents of <code>_</code> to <code>_</code> forever. Throws <code>OutOfMemoryException</code> almost instantly.</p>
</div>
<div id="pu18" class="pu"><h1><a href="https://github.com/DJMcMayhem/V" rel="nofollow noreferrer">V</a>, 2 bytes</h1>

<pre><code>òé
</code></pre>

<p>You can <a href="https://tio.run/nexus/v#@3940@GV//8DAA" rel="nofollow noreferrer" title="V – TIO Nexus">try it online,</a> even though it won't output anything.</p>

<p>This simply fills up the interal "buffer" with the <code>ÿ</code> character (<code>0xFF</code>) until the end of time.</p>
</div>
<div id="pu19" class="pu"><h1><a href="https://github.com/DJMcMayhem/Brain-Flak" rel="nofollow noreferrer">Brain-Flak</a>, 10 bytes</h1>

<pre><code>(()){(())}
</code></pre>

<p><a href="https://tio.run/nexus/brain-flak#@6@hoalZDSJq//8HAA" rel="nofollow noreferrer" title="Brain-Flak – TIO Nexus">Try it online!</a></p>
</div>
<div id="pu20" class="pu"><h1>Commodore 64</h1>

<p>If <code>?STRING TOO LONG  ERROR</code> counts, then this will work on the Commodore 64 and VIC-20:</p>

<pre><code>0 a$=a$+" ":goto
</code></pre>

<p>or if you need <code>?OUT OF MEMORY  ERROR</code> then:</p>

<pre><code>0 dim a(255,255)
</code></pre>

<p>However, the last solution does not use a loop as the error is reported as soon as <code>run</code> is entered.</p>
</div>
<div id="pu21" class="pu"><h1>sed, 5 bytes</h1>
<p><strong>Golfed</strong></p>
<pre><code>H;G;D
</code></pre>
<p><strong>Usage (any input will do)</strong></p>
<pre><code>sed 'H;G;D' &lt;&lt;&lt;&quot;&quot;
</code></pre>
<p><strong>Explained</strong></p>
<pre><code>#Append a newline to the contents of the hold space, 
#and then append the contents of the pattern space to that of the hold space.
H

#Append a newline to the contents of the pattern space, 
#and then append the contents of the hold space to that of the pattern space. 
G

#Delete text in the pattern space up to the first newline, 
#and restart cycle with the resultant pattern space.
D
</code></pre>
<p><strong>Screenshot</strong></p>
<p><a href="https://i.sstatic.net/hRBzu.gif" rel="noreferrer"><img src="https://i.sstatic.net/hRBzu.gif" alt="enter image description here" /></a></p>
<p><a href="https://tio.run/nexus/bash#@1@cmqKg7mHtbu2irmBjY6Ok9P8/AA" rel="noreferrer">Try It Online !</a></p>
</div>
<div id="pu22" class="pu"><h1>SmileBASIC, 18 bytes</h1>
<pre><code>@L
A$=A$+@A
GOTO@L
</code></pre>
<p>Keeps creating strings consisting of <code>@A@A@A...</code>.
It would be much faster to use PUSH to modify the original string, but that would use more characters.</p>
</div>
<div id="pu23" class="pu"><h1><a href="https://dyalog.com/download-zone.htm" rel="nofollow noreferrer">Dyalog APL</a>, 4 <a href="http://meta.codegolf.stackexchange.com/a/9429/43319">bytes</a></h1>

<pre class="lang-apl prettyprint-override"><code>⊂⍣≡⍬
</code></pre>
<p><code>⊂</code> enclose</p>
<p><code>⍣</code> until</p>
<p><code>≡</code> identical to the previous iteration (i.e. never, as each iteration has one more level of enclosure)</p>
<p><code>⍬</code> empty (numeric) list</p>
<p>The program starts as follows:</p>
<p><code>[]</code>, enclose that, yielding</p>
<p><code>[[]]</code>. Is that identical to <code>[]</code>? No, so we enclose that, yielding</p>
<p><code>[[[]]]</code>. Is that identical to <code>[[]]</code>? No, so we enclose that...</p>
<p>Since each enclosure needs a new pointer, memory usage will slowly increase until WORKSPACE FULL.</p>
</div>
<div id="pu24" class="pu"><h1>JavaScript - <s>14</s> 18 bytes</h1>

<pre><code>while(x=[self.x]);
</code></pre>

<p>Based on the activity on @Lmis' answer, some fun with evaluating expressions in intermediate scopes. Didn't manage to avoid reference errors :'(!</p>
</div>
<div id="pu25" class="pu"><h1><a href="https://github.com/m-ender/labyrinth" rel="nofollow noreferrer">Labyrinth</a>, 1 byte</h1>

<pre><code>_
</code></pre>

<p>This keeps pushing a 0 to the stack.</p>
</div>
<div id="pu26" class="pu"><h1>Java 104 bytes</h1>

<pre><code>import java.util.*;class A{public static void main(String[]a){List b=new ArrayList();for(;;)b.add(1);}}
</code></pre>

<p>This will allocate a List and let it grow constantly until it runs out of space.</p>
</div>
<div id="pu27" class="pu"><h1>BotEngine, 2x3=6</h1>

<pre><code>ve&lt;
&gt;e^
</code></pre>

<p>Rough translation:</p>

<pre><code>forever:
  enqueue 'e'
  enqueue 'e'
</code></pre>
</div>
<div id="pu28" class="pu"><h1>F#, 22 bytes</h1>
<p><code>let rec f x=f(1::x);()</code></p>
<p>Call it in F# interactive passing an empty list: <code>f []</code></p>
<p>The function recursively calls itself, adding elements to the list. The tuple at the end is there so that the type inference can determine that the function return type is unit.</p>
</div>
<div id="pu29" class="pu"><h2>PowerShell, 14 bytes</h2>

<pre><code>for(){$i+="z"}
</code></pre>

<p>Infinite loop creates a variable(string) and appends new characters to the end. Unbearably slow, took over an hour to consume two megabytes. Verified it would consume all the RAM available using something a bit faster:  <code>for(){$i+=("z"*9MB)}</code></p>
</div>
<div id="pu30" class="pu"><h2>Mathematica,  16 bytes</h2>

<pre><code>For[i=0,0&lt;1,i++]
</code></pre>

<p>Endlessly adds <code>1</code> to an arbitrary precision integer, causing its representation in memory to slowly grow.</p>

<p>Might also be the slowest submission since memory allocated only grows logarithmically with time.  In fact, I've only let it run to several hundred billion, which barely alters allocated memory.  So how do I know it grows without bound?  Try the variant </p>

<pre><code>For[i = 1, 0 &lt; 1, i += i]
</code></pre>

<p>so that the memory usage is now linear in time...  (If you want to watch <code>i</code>, </p>

<pre><code>Monitor[For[i = 1, 0 &lt; 1, i += i], i]
</code></pre>

<p>and notice, for instance, that the front end is allocating memory to hold the displayed values faster than the kernel is, because the binary representation is much less fluffy that the decimal representation and resulting graphical object.  I suppose one could stress test one's 2D video acceleration by switching to the console interface and running the <code>Monitor[]</code> there...  Heh.)</p>
</div>
<div id="pu31" class="pu"><h1>Python, 8 bytes</h1>
<pre><code>2**9**99
</code></pre>
<p>The <a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory?noredirect=1#comment247805_101709">OP</a> has allowed the technicality of a program that doesn't technically run &quot;forever&quot;, but allocates more memory than any computer could possibly handle. This isn't quite a googolplex (that would be <code>10**10**100</code>, 11 bytes), but naively, log base 2 of the number is</p>
<pre><code>&gt;&gt;&gt; 9**99.
2.9512665430652752e+94
</code></pre>
<p>i.e., 10^94 bits to represent it. <a href="http://www.wolframalpha.com/input/?dataset=&amp;i=2.9512665430652752e%2B94+bits" rel="noreferrer">WolframAlpha</a> puts that as 10^76 larger than the deep web (keep in mind that there are about 10^80 <a href="http://www.wolframalpha.com/input/?dataset=&amp;i=atoms+in+the+universe" rel="noreferrer">atoms in the universe</a>).</p>
<p>Why 2 instead of 9 you ask? It doesn't make much of a difference (using 9 would only increase the number of bits by a factor of <code>log2(9) = 3.2</code>, which doesn't even change the exponent). But on the other hand, the program runs much faster with 2, since the calculation is simpler. This means it fills up memory immediately, as opposed to the 9 version, which takes a little longer due to the calculations required. Not necessary, but nice if you want to &quot;test&quot; this (which I did do).</p>
</div>
<div id="pu32" class="pu"><h1>Perl, 4 bytes</h1>

<pre class="lang-perl prettyprint-override"><code>do$0
</code></pre>
<p>Executes itself, in the current interpreter. When finished, execution returns to the calling script, which requires a call stack.</p>
</div>
<div id="pu33" class="pu"><h1>Ceylon, <strike>55</strike> <strike>54</strike> 35 bytes</h1>

<pre class="lang-ceylon prettyprint-override"><code>shared void r(){variable Object x=0;while(0&lt;1){x=[x];}}
</code></pre>

<p>This is a simple while loop, which creates a one-element tuple containing the previous value, i.e. an ever-growing linked list.</p>

<p>I get an OutOfMemoryError (with the default JVM settings on my computer) after:</p>

<pre><code>real    5m42.727s
user    21m31.200s
sys     0m3.472s
</code></pre>

<p>5m42s (using 21 minutes of processor time, says <code>time</code>).</p>

<p>Even shorter is the "functional" approach (which in effect does exactly the same):</p>

<pre class="lang-ceylon prettyprint-override"><code>shared void r(){loop&lt;Object&gt;(0)((x)=&gt;[x]).each(noop);}
</code></pre>

<p>Unfortunately I need the type parameter here, otherwise Ceylon assumes <code>Integer</code> (which is the type of <code>0</code>) and complains that <code>[0]</code> is not an Integer.</p>

<p>The second version is much slower (I've let it run overnight):</p>

<pre><code>real    197m26.677s
user    770m9.300s
sys     1m23.744s
</code></pre>

<p>A different approach is just filling a really big sequence of integers:</p>

<pre class="lang-ceylon prettyprint-override"><code>shared void r(){max((1:9^9)*.not);}
</code></pre>

<p><code>1:9^9</code> is a <code>Measure&lt;Integer&gt;</code> (an Iterable containing 9^9 elements, starting with 1), by itself not having lots of memory (just the two numbers). But the <code>*.not</code> attribute spread creates a big ArraySequence with the value of <code>i.not</code> for each element of the Iterable. We need to do something with the result (otherwise the compiler complains that this is not a statement), therefore the <code>max(...)</code>. The <code>max</code> function is never called here, because this gives an OutOfMemoryError (with "GC overhead limit exceeded") after 6 minutes while trying to build and fill the array:</p>

<pre><code>real    6m23.948s
user    23m46.956s
sys     0m5.200s
</code></pre>
</div>
<div id="pu34" class="pu"><h1>JAVA, <del>81</del> <del>79</del> 78 bytes</h1>
<h1>JAVA (HotSpot) <del>71</del> 70 bytes</h1>
<p>Shorter than other Java answers at the time I posted (81, later 79 bytes):</p>
<pre><code>class A{public static void main(String[]a){String x=&quot;1&quot;;for(;;)x+=x.intern();}}
</code></pre>
<p>As suggested by @Olivier Grégoire, a further byte can be saved:</p>
<pre><code>class A{public static void main(String[]a){for(String x=&quot;1&quot;;;)x+=x.intern();}}
</code></pre>
<p>Placing <code>x+=x.intern()</code> as the for loop increment would not help anything, because a semicolon is still required to end the for statement.</p>
<p>As suggested by @ETHproductions, just using <code>x+=x</code> works too:</p>
<pre><code>class A{public static void main(String[]a){String x=&quot;1&quot;;for(;;)x+=x;}}
</code></pre>
<p>Which can also benefit from @Olivier Grégoire's tip:</p>
<pre><code>class A{public static void main(String[]a){for(String x=&quot;1&quot;;;)x+=x;}}
</code></pre>
<p>My only misgivings about that is that it is not guaranteed to allocate data <em>on the heap</em>, as an efficient JVM can easily realize that <code>x</code> never escapes the local function. Using <code>intern()</code> avoids this concern because interned strings ultimately end up stored in a static field. However, HotSpot does generate an <code>OutOfMemoryError</code> for that code, so I guess it's alright.</p>
<p>Update: @Olivier Gregoire also pointed out that the <code>x+=x</code> code can run into <code>StringIndexOutOfBoundsException</code> rather than <code>OOM</code> when a lot of memory is available. This is because Java uses the 32-bit <code>int</code> type to index arrays (and Strings are just arrays of <code>char</code>). This doesn't affect the <code>x+=x.intern()</code> solution as the memory required for the latter is quadratic in the length of the string, and should thus scale up to on the order of 2^62 allocated bytes.</p>
</div>
<div id="pu35" class="pu"><h1>Java, 127+19=146</h1>



<p>Golfed:</p>

<pre class="lang-java prettyprint-override"><code>import java.util.*;class A{public static void main(String[]q){List l=new LinkedList();for(;;){String s="";for(int i=0;i&gt;-1;++i)s+=' ';l.add(s);}}}
</code></pre>

<p>Ungolfed:</p>

<pre class="lang-java prettyprint-override"><code>import java.util.*;

public class A {
  public static void main(String[] args) {
    List&lt;String&gt; l = new LinkedList&lt;&gt;();
    for (;;) {
      String s = new String();
      for (int i = 0; i &gt; -1; ++i) {
        s += ' ';
      }
      l.add(s);
    }
  }
}
</code></pre>

<p>This program does <em>not</em> rely on the garbage collector or <code>finalize()</code> method like the other Java answers do. Java only interns and merges strings that are constructed from literals, unless specifically interned. That means this program will end up creating strings of size 2<sup>31</sup> essentially forever, assuming <a href="https://stackoverflow.com/a/7632240">LinkedList works as expected</a>.</p>
</div>
<div id="pu36" class="pu"><h1>Python REPL, 13 bytes</h1>

<pre><code>9
while 1:_*9
</code></pre>

<p>The first line, <code>9</code>, sets the built-in <code>_</code> (last-integer) variable to 9. The infinite loop then keeps setting this to itself multiplied by 9.</p>

<p>Python integers have no upper limit, so this will keep growing until <code>MemoryError</code>.</p>

<p>This only works in the shell, where the <code>_</code> variable is available. <a href="http://meta.codegolf.stackexchange.com/questions/7842/when-is-code-that-requires-a-repl-acceptable/7844#7844">This is allowed by meta</a>.</p>
</div>
<div id="pu37" class="pu"><h1>Bash + coreutils, 5</h1>
<p>or</p>
<h1>Ruby, 5</h1>
<pre><code>`yes`
</code></pre>
<p><code>yes</code> produces endless output.  Putting <code>yes</code> in backticks tells the shell to capture all output and then execute that output as a command.  Bash will continue allocating memory for this unending string until the heap runs out.  Of course the resulting output would end up being an invalid command, but we should run out of memory before that happens.</p>
<p>Thanks to @GB for pointing out this is a polyglot in ruby too.</p>
</div>
<div id="pu38" class="pu"><h1>C (linux), 23 bytes</h1>
<pre><code>main(){while(sbrk(9));}
</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Sbrk" rel="nofollow noreferrer"><code>sbrk()</code></a> increments the top of the data segment by the given number of bytes, thus effectively increasing the amount of memory allocated to the program - at least as reported in the <code>VIRT</code> field of <code>top</code> output.  This only works on Linux - the macOS implementation is apparently an emulation that only allows allocation of up to 4MB.</p>
<hr />
<p>So a slightly more general answer:</p>
<h1>C, 25 bytes</h1>
<pre><code>main(){while(malloc(9));}
</code></pre>
<p>I watched it on the macOS Activity Monitor.  It went all the way up to about 48GB, then eventually the process received a SIGKILL signal.  FWIW my macbook pro has 16GB.  Most of the memory used was reported as compressed.</p>
<p>Note that the question effectively requires each allocation to be written to, which doesn't happen explicitly here.  However it is important to note that for every <code>malloc(9)</code> call, it is not just the 9 user requested bytes that are allocated.  For each block allocated there will be a malloc header that is also allocated from somewhere on the heap, which is necessarily written to by the <code>malloc()</code> internals.</p>
</div>
<div id="pu39" class="pu"><h2>SAS, <s>75</s> 19</h2>

<p>SAS doesn't really lend itself to golfing but I thought I'd have a go, and at least it beats <s>Java</s> <s>some of the Java answers</s> quite a lot of stuff, actually.</p>

<p><strong>Original submission:</strong></p>

<pre><code>data;dcl hash h();h.definekey('i');h.definedone();a:i+1;h.add();goto a;run;
</code></pre>

<p>This creates a hash object and keeps adding new values to it until SAS runs out of memory. None of the hash operations fail prior to that point, so no need to capture any pesky return codes for them. SAS does have <code>do</code> loops, but <code>goto</code> saves a few characters.</p>

<p><strong>New submission:</strong></p>

<pre><code>%macro a;%a%mend;%a
</code></pre>

<p>Much simpler - a trivial recursive macro. If left running for long enough, it eventually fails with an out of memory error. Both submissions assume that SAS was invoked with <code>option memsize = 0</code>, otherwise it will instead fail when it hits that limit if it is lower than the available system memory.</p>
</div>
<div id="pu40" class="pu"><h1><a href="http://esolangs.org/wiki/Fission" rel="nofollow noreferrer">Fission</a>, 3 bytes</h1>
<pre><code>RX+
</code></pre>
<p>Continuously creates atoms and increments its mass.</p>
<p><a href="http://fission.tryitonline.net/#code=Ulgr&amp;input=" rel="nofollow noreferrer">Try it online!</a></p>
<pre><code>R                 creates an atom moving right
 X                clones atom, one keeps moving to the right, the other gets reflected left
  +               increment the atom's mass
</code></pre>
<p>Because of wrapping, this program will continuously create atoms with non-negative mass</p>
<p>Another alternative:</p>
<pre><code>RX'
</code></pre>
<p><code>R</code> and <code>X</code> works like you expect it to, and <code>'</code> sets the atom's mass to the ASCII value of the next character it hits, ie <code>'R'</code> (because of wrapping). Thus, this continuously creates atoms with the ASCII value of <code>'R'</code>.</p>
</div>
<div id="pu41" class="pu"><h1>PHP, <s>14</s> 13 bytes</h1>

<p>Saved a byte thanks to <a href="https://codegolf.stackexchange.com/questions/101709/shortest-program-that-continuously-allocates-memory/101852?noredirect=1#comment247292_101852">Alex Howansky</a></p>

<pre><code>while($a.=1);
</code></pre>

<p>Indefinitely builds a string of 111111111111...</p>
</div>
<div id="pu42" class="pu"><h1>Microscript II, 3 bytes</h1>

<pre><code>1[s
</code></pre>

<p>Rough translation:</p>

<pre><code>x=1
while x
  push x
</code></pre>
</div>
<div id="pu43" class="pu"><h2>TI-BASIC, 8</h2>

<pre><code>:Lbl A
:While 1
:Goto A
</code></pre>

<p>(all 1-byte tokens, and two newlines)</p>

<p>This continuously leaks memory because structured control flow such as <code>While</code> anticipated being closed by an <code>End</code> and pushes something on the stack (not the OS stack, a separate stack in heap memory) to keep track of that. But here we're using <code>Goto</code> to leave the loop (so no <code>End</code> is executed to remove the thing from the stack), the <code>While</code> is seen again, the thing gets pushed again, etc. So it just keeps pushing them until you get <code>ERR:MEMORY</code></p>
</div>
<div id="pu44" class="pu"><h1><a href="http://github.com/Mego/Seriously" rel="nofollow noreferrer">Actually</a>, 3 bytes</h1>

<pre><code>1W1
</code></pre>

<p><a href="http://actually.tryitonline.net/#code=MVcx&amp;input=" rel="nofollow noreferrer">Try it online!</a></p>

<p>This is an infinite loop that pushes a <code>1</code> to the stack each time it runs. Actually is implemented in Python, and its stack is a deque, so, despite the name, all memory is dynamically allocated on the heap.</p>
</div>
<div id="pu45" class="pu"><h1>Kotlin, 27 bytes</h1>
<pre><code>var o=Any()
while(1&gt;0)o={o}
</code></pre>
<p>Stacking functions returning functions.</p>
<p>54 bytes if no .kts: <code>fun main(a:Array&lt;String&gt;){var o=Any();while(1&gt;0)o={o}}</code></p>
</div>
<div id="pu46" class="pu"><h2><a href="https://github.com/dloscutoff/Esolangs/tree/master/tinylisp" rel="nofollow noreferrer">tinylisp</a> repl, 12 bytes</h2>

<pre><code>(d f(q(L(f L
</code></pre>

<p>Defines a function <code>f</code> that will keep allocating memory when called. If submissions must be full programs, here's a 15-byte solution:</p>

<pre><code>((v(d f(q(L(f L
</code></pre>

<h3>Explanation</h3>

<p>The repl supplies missing parens at the end of the line, so the code is really <code>(d f(q(L(f L))))</code>.</p>

<p><code>(d f(q(...)))</code> defines <code>f</code> to be the unevaluated list <code>(...)</code>. In tinylisp, functions are simply two-element lists. The first element is the parameter list and the second is the function body. Here, the first element is <code>L</code>, which (because it's not wrapped in parentheses) makes this a variadic function in which the entire argument list is assigned to <code>L</code>. The function body <code>(f L)</code> simply calls <code>f</code> again with <code>L</code> as its argument.</p>

<p>This is tail recursion, so the call stack doesn't come into play. But notice what happens to <code>L</code> on successive calls:</p>

<pre><code>(f)        Called with no arguments; L gets empty list ()
(f ())     Called with one argument, empty list; L gets (())
(f (()))   Called with one argument, (()); L gets ((()))
</code></pre>

<p>And so on, wrapping the argument in another layer of list each time.</p>
</div>
<div id="pu47" class="pu"><h2>Haskell (using ghc 8.0.1), 11 bytes</h2>

<pre><code>m@main=m&gt;&gt;m
</code></pre>

<p>Non-tail recursion. <code>main</code> calls itself and then itself again.</p>
</div>
<div id="pu48" class="pu"><h2>dc, 7 bytes</h2>

<pre><code>[ddx]dx
</code></pre>

<p><code>[ddx]</code> pushes a string containing "ddx" to the stack. <code>dx</code> duplicates it then executes it as code (leaving one copy on the stack). When executed, it makes two duplicates then executes one, leaving one more copy on the stack each time.</p>
</div>
<div id="pu49" class="pu"><h1>WinDbg, 9 bytes</h1>
<pre><code>as/c a z1
</code></pre>
<p>This works by creating a string of infinite length. <code>as /c</code> Sets an alias (here called <code>a</code>) to the result of the following command(s): <code>z 1</code> is an infinite do while loop that also prints a line when the while condition is true: <code>redo [###] {redone_code}</code>. So <code>a</code> will be set to a string like:</p>
<pre><code>redo [1] z1
redo [2] z1
redo [3] z1
.
.
.
redo [23489723984] z1
.
.
.
</code></pre>
</div>
<div id="pu50" class="pu"><h1>Funge-98 (<a href="https://launchpad.net/cfunge" rel="noreferrer"><code>cfunge</code></a>), 1 byte</h1>
<pre><code>9
</code></pre>
<p>I would have posted this earlier, but decided to test it, and it took a while to get my computer back to a usable state. <code>cfunge</code> stores the Funge stack on the operating system's heap (which is easily verifiable by running the program with a small memory limit, something that I should have done earlier!), so an infinitely growing stack (as with this program, which just pushes <code>9</code> repeatedly; Funge programs wrap from the end of a line back to the start by default) will allocate memory forever. This program likely also works in some Befunge-93 implementations.</p>
<p>More interesting:</p>
<pre><code>&quot;NULL #(4
</code></pre>
<p>This was my first idea, and is an infinite allocation that doesn't rely on the Funge stack (although it blows up the Funge stack too). To start with, the <code>&quot;</code> command pushes a copy of the rest of the program to the stack (it's a string, and the program wraps round, so the close quote also serves as the open quote). Then the <code>N</code> reflects (it has no meaning by default), causing the program to run backwards. The <code>&quot;</code> runs again, and pushes the program to the stack – the other way round this time, with the <code>N</code> at the top of the stack – then the program wraps around, loading a library with a 4-letter name (<code>4(</code>; the <code>NULL</code> library is part of <code>cfunge</code>'s standard library). <code>NULL</code> defines all uppercase letters to do reflect, so the <code>L</code> reflects, the <code>#</code> skips the library load on the way back, the <code>4</code> pushes junk we don't care about to the stack and the whole program repeats from the start. Given that loading a library multiple times has an effect, and requires the library's command list to be stored once for each copy of the library (this is implied by Funge-98's semantics), it leaks memory via non-stack storage (which is an alternative method of defining &quot;heap&quot;, relative to the language rather than the OS).</p>
</div>
<div id="pu51" class="pu"><h1>C++ (using g++ compiler), <s>27</s> <s>23</s> 15 bytes</h1>

<p><em>Thanks to Neop for helping me to remove 4 bytes</em></p>

<p>This solution does not really leak any memory because it allocates everything on the stack and thus causes a stack overflow.  It is simply infinitely recursive.  Each recursion causes some memory to be allocated until the stack overflows.</p>

<pre><code>main(){main();}
</code></pre>

<h2>Alternative solution</h2>

<p>This solution actually leaks memory.</p>

<pre><code>main(){for(;;new int);}
</code></pre>

<h2>Valgrind output</h2>

<p>This is the Valgrind output after terminating the program several seconds into the run time.  You can see that it is certainly leaking memory.</p>

<pre><code>==2582== LEAK SUMMARY:
==2582==    definitely lost: 15,104,008 bytes in 3,776,002 blocks
==2582==    indirectly lost: 0 bytes in 0 blocks
==2582==      possibly lost: 16 bytes in 4 blocks
==2582==    still reachable: 4 bytes in 1 blocks
==2582==         suppressed: 0 bytes in 0 blocks
</code></pre>
</div>
<div id="pu52" class="pu"><h2>Brainfuck, 5 bytes</h2>
<pre><code>+[&gt;+]
</code></pre>
<p>This requires an interpreter that has no limit on the length of the tape.</p>
</div>
<div id="pu53" class="pu"><h2>///, 7 bytes</h2>
<pre><code>/a/aa/a
</code></pre>
<p>Constantly replace <code>a</code> with <code>aa</code>, ad nauseum.</p>
</div>
<div id="pu54" class="pu"><h1>TI-83 Hex Assembly, 7 bytes</h1>
<pre><code>PROGRAM:M
:AsmPrgm
:EF6A4E
:C3959D
:C9
</code></pre>
<p>Creates appvars indefinitely until an <code>ERR:MEMORY</code> is thrown by the OS. Run with <code>Asm(prgmM)</code>. I count each pair of hex digits as one byte.</p>
</div>
<div id="pu55" class="pu"><h1><a href="http://github.com/Adriandmen/05AB1E" rel="nofollow noreferrer">05AB1E</a>, 2 bytes</h1>

<pre><code>[A
</code></pre>

<p><a href="http://05ab1e.tryitonline.net/#code=W0E&amp;input=" rel="nofollow noreferrer">Try it online!</a>
Will just keep pushing <code>abcdefghijklmnopqrstuvwyxz</code> onto the stack for eternity.</p>

<p><strong>All possible 2-byte solutions:</strong></p>

<pre><code>[  # Infinite loop.
 A # Push alphabet.
 0 # Push 0.
 1 # Push 1.
 2 # Push 2.
 3 # Push 3.
 4 # Push 4.
 5 # Push 5.
 6 # Push 6.
 7 # Push 7.
 8 # Push 8.
 9 # Push 9.
 T # Push 10.
 X # Push 1.
 Y # Push 2.
 ® # Push -1.
 ¶ # Push \n.
 º # Push len(stack) &gt; 0, so 0 once then 1 for eternity.
 ð # Push a space.
 õ # Push an empty string.
 ¾ # Push 0.
 ¯ # Push [].
 M # Push -inf.
 ) # Wrap current stack in an array.
</code></pre>
</div>
<div id="pu56" class="pu"><h1><a href="https://github.com/FTcode/Pushy" rel="nofollow noreferrer">Pushy</a>, 3 bytes</h1>

<pre><code>1$a
</code></pre>

<p>Just keeps pushing to the stack...</p>

<pre><code>1     % Push 1
$     % While last item != 0 (forever):
a     %   Push char-codes of the lowercase alphabet
</code></pre>

<p>This is just one example: several 3 byte solutions exist, such as <code>1$1</code>, <code>1$&amp;</code>, <code>9$9</code>, etc - anything that will "infinitely" push to the stack.</p>
</div>
<div id="pu57" class="pu"><h1>Ruby, 11 bytes</h1>

<pre><code>loop{$*&lt;&lt;9}
</code></pre>

<p>Keeps pushing <code>9</code> onto <code>$*</code>, which is an array initially holding the command line arguments to the Ruby process.</p>
</div>
<div id="pu58" class="pu"><h2>>&lt;> (Fish), 1 byte</h2>

<pre><code>0
</code></pre>

<p><a href="https://fishlanguage.com/playground/oQ5qkLuN8MgLfR5L5">Try it here!</a></p>

<p><code>0</code> can actually be substituted for any hexadecimal number 1-f.</p>

<p><strong>Explanation</strong></p>

<p><code>0</code> in >&lt;> simply makes a 1x1 codebox for the fish to swim in. It constantly adds a <code>0</code> onto the stack, swims right, which loops backaround to <code>0</code>, adding it to the stack again. This will go on forever.</p>
</div>
<div id="pu59" class="pu"><h1>Python, 16 bytes</h1>

<p>Keeps nesting <code>a</code> until an error is reached:</p>

<pre class="lang-py prettyprint-override"><code>a=0
while 1:a=a,
</code></pre>

<p>The first few iterations (as tuples) look like this:</p>

<pre><code>0
(0,)
((0,),)
(((0,),),)
</code></pre>

<p>and so on and so forth.</p>
</div>
<div id="pu60" class="pu"><h1>Haskell, <s>23</s> 19 bytes</h1>

<pre><code>main=print$sum[0..]
</code></pre>

<p>Print the sum of an infinite list</p>
</div>
<div id="pu61" class="pu"><h1>JavaScript <s>22</s> <s>21</s> <s>17</s> <s>16</s> 15 Bytes</h1>

<pre><code>for(a=0;;)a=[a]
</code></pre>

<p>Saved 4 bytes by wrapping the list in another list as in @Jonathan Allan's Jelly answer.</p>

<p>Saved 1 byte thanks to @ETHProductions</p>

<h3>Alternative solution 15 Bytes (only works with proper tail calls)</h3>

<pre><code>f=a=&gt;f([a]);f()
</code></pre>
</div>
<div id="pu62" class="pu"><h2>Python, 35 bytes</h2>

<pre><code>def f(a=[]):a.append(a)
while 1:f()
</code></pre>

<p><code>a</code> is never released and just gets bigger until you hit a <code>MemoryError</code></p>

<p>You can view the execution on <a href="http://pythontutor.com/visualize.html#code=def%20f(a%3D%5B%5D%29%3Aa.append(a%29%0Awhile%201%3Af(%29%0A&amp;cumulative=false&amp;curInstr=17&amp;heapPrimitives=false&amp;mode=display&amp;origin=opt-frontend.js&amp;py=2&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false" rel="nofollow noreferrer">Python Tutor</a>.</p>
</div>
<div id="pu63" class="pu"><h2>Perl, 12 bytes</h2>
<pre><code>{$&quot;x=9;redo}
</code></pre>
<p>In perl, the <code>x</code> operator, with a string on the left and a number on the right, produces a repeated string.  So <code>&quot;abc&quot; x 3</code> evaluates to <code>&quot;abcabcabc&quot;</code>.</p>
<p>The <code>x=</code> operator mutates the left argument, replacing contents of the variable on its left with the result of repeating it's contents as many times as its right hand side indicates.</p>
<p>Perl has a number of a number of strangely named built in variables, one of which is <code>$&quot;</code>, whose <em>initial</em> value is a single space.</p>
<p>The <code>redo</code> operator jumps to the beginning of the enclosing <code>{}</code>.</p>
<p>The first time the <code>x=</code> operator is done, it changes the value of <code>$&quot;</code> from <code>&quot; &quot;</code>&quot; to <code>&quot;         &quot;</code>, which is 9 spaces.</p>
<p>The second time the <code>x=</code> operator is done, it changes the value of <code>$&quot;</code> to <code>&quot;                                                                                 &quot;</code>, which is 81 spaces.</p>
<p>The third time, <code>$&quot;</code> becomes a 729 byte long string of spaces.</p>
<p>I think you can see where this is going :).</p>
</div>
<div id="pu64" class="pu"><h2>Rust, 46 bytes</h2>

<pre class="lang-rs prettyprint-override"><code>fn main(){loop{std::mem::forget(Box::new(1))}}
</code></pre>
<p>Notice something interesting about this Rust program, leaking heap allocations until out of memory?</p>
<p>That's right, no unsafe block. Rust guarantees memory safety in safe code (no reading of uninitialized data, read after free, double free etc.), but memory leaks are considered perfectly safe. There's even an explicit function to make the compiler forget about RAII cleanup of out of scope variables, which I use here.</p>
</div>
<div id="pu65" class="pu"><h2>Java 101 bytes</h2>
<pre><code>class A{public void finalize(){new A();new A();}public static void main(String[]a){for(new A();;);}}
</code></pre>
<p>Catching main Program in a endless Loop after creating and throwing away a object. Garbage collection does the job of leaking by creating 2 objects for each deleted ones</p>
</div>
<div id="pu66" class="pu"><h1>Racket, 13 bytes</h1>

<pre><code>(let l()(l)1)
</code></pre>

<p>I'm not entirely certain if my answer falls under this question. Please let me know if I should remove this answer.</p>
</div>
<div id="pu67" class="pu"><h1>Haskell, 24 bytes</h1>

<pre class="lang-haskell prettyprint-override"><code>f x=f$x*x
main=pure$!f 9
</code></pre>
<p>The main problem in Haskell is to beat the laziness. <code>main</code> needs to have some <code>IO</code> type, so simply calling <code>main=f 9</code> would not work. Using <code>main=pure(f 9)</code> lifts the type of <code>f 9</code> to an <code>IO</code> type. However using constructs like <code>main=pure 9</code> does not do anything, the <code>9</code> is returned or displayed nowhere but simply discarded, so there is no need to evaluate the argument of <code>pure</code>, hence <code>main=pure(f 9)</code> does not cause any memory to be allocated as <code>f</code> is not called.
To enforce evaluation, the <code>$!</code> operator exists. It simply applies a function to an argument but evaluates the argument first. So using <code>main=pure$!f 9</code> evaluates <code>f</code> and hence continuously allocates more memory.</p>
</div>
<div id="pu68" class="pu"><h1>Java 7, 106 bytes</h1>

<pre><code>class A{public void finalize(){for(;;)Thread.yield();}public static void main(String[]a){for(;;)new A();}}
</code></pre>

<h3>Less Golfed</h3>

<pre><code>class A{
    @Override
    public void finalize(){
        for(;;) {
            Thread.yield();
        }
    }
    public static void main(String[]a){
        for(;;){
            new A();
        }
    }
}
</code></pre>

<p>The <code>finalize</code> method is called on an object by the garbage collector when garbage collection determines that there are no more references to the object. I have simply redefined this method to loop forever so the garbage collector never actually frees the memory. In the <code>main</code> loop I create new objects which will never be cleaned up so eventually this will use up all the available memory.</p>

<h1>Java 7 (fun alternative), 216 bytes</h1>

<pre><code>import sun.misc.*;class A{public static void main(String[]a)throws Exception{java.lang.reflect.Field f=Unsafe.class.getDeclaredField("theUnsafe");f.setAccessible(1&gt;0);for(;;)((Unsafe)f.get(null)).allocateMemory(9);}}
</code></pre>

<h3>Less Golfed</h3>

<pre><code>import sun.misc.*;
class A{
    public static void main(String[]a)throws Exception{
        java.lang.reflect.Field f=Unsafe.class.getDeclaredField("theUnsafe");
        f.setAccessible(true);
        Unsafe u = (Unsafe)f.get(null);
        for(;;) {
            u.allocateMemory(9);
        }
    }
}
</code></pre>

<p>This is a fun one more than anything else. This answer makes use of the <code>Unsafe</code> Sun library which is an undocumented internal API. You may need to change your compiler settings to allow restricted APIs. <code>Unsafe.allocateMemory</code> allocates a specified amount of bytes (without any boundary checking) which is not on the heap and <strong>not</strong> under java's garbage collector management so this memory will stick around until you call <code>Unsafe.freeMemory</code> or until the jvm runs out of memory.</p>
</div>
<div id="pu69" class="pu"><h1>BASH, 2 bytes</h1>

<pre><code>$0
</code></pre>

<p>Parameter $0 is the filename of the script, so it will call itself forever.</p>
</div>
<div id="pu70" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly">Jelly</a>, <s>3</s> 2 <a href="https://github.com/DennisMitchell/jelly/wiki/Code-page">bytes</a></h1>

<p>-1 byte thanks to Dennis (<code>W</code> wraps)</p>

<pre><code>Wß
</code></pre>

<p>A link (i.e. function or method), which also works as a full program, that recursively wraps its input into a list.</p>

<p>The input starts as zero so the first pass creates the list <code>[0]</code><br>
The second pass then makes this <code>[[0]]</code><br>
The third pass then makes this <code>[[[0]]]</code><br>
and so on...</p>

<hr>

<p>Previous 3 byter, which leaks much faster:</p>

<pre><code>;Ẇß
</code></pre>

<p>recursively concatenates all non-empty contiguous sublists of its input to its input.<br>
<code>[0]</code> -> <code>[0,[0]]</code> -> <code>[0,[0],[0],[[0]],[0,[0]]]</code> and so on...</p>
</div>
<div id="pu71" class="pu"><h1>Python 3, 16 bytes</h1>

<pre><code>i=9
while 1:i*=i
</code></pre>

<p>This comes from the fact that there is no limit to integer size in Python 3; instead, integers can take up as much memory as the system can handle (if something about my understanding of this is wrong, do correct me).</p>
</div>
<div id="pu72" class="pu"><h1><a href="https://perl6.org">Perl 6</a>, 13 bytes</h1>



<pre class="lang-perl6 prettyprint-override"><code>@= eager 0..*
</code></pre>

<h2>Explanation:</h2>

<p><code>@ =</code> store the result into an unnamed array</p>

<p><code>eager</code> make the following list eager</p>

<p><code>0 .. *</code> infinite range starting at zero</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/101709/">101709</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




