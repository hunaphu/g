<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::266208</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>560</td><td>Haskell</td><td>231025T184339Z</td><td><a href="https://codegolf.stackexchange.com/questions/266208/help-i-cant-bloody-well-memorize-this-number/266225#266225">Silvio M</a></td></tr>
<tr d-ix="1"><td>156</td><td>Charcoal</td><td>231025T161910Z</td><td><a href="https://codegolf.stackexchange.com/questions/266208/help-i-cant-bloody-well-memorize-this-number/266220#266220">Neil</a></td></tr>
<tr d-ix="2"><td>273</td><td>JavaScript ES7</td><td>231025T121905Z</td><td><a href="https://codegolf.stackexchange.com/questions/266208/help-i-cant-bloody-well-memorize-this-number/266215#266215">Arnauld</a></td></tr>
<tr d-ix="3"><td>114</td><td>05AB1E</td><td>231025T145922Z</td><td><a href="https://codegolf.stackexchange.com/questions/266208/help-i-cant-bloody-well-memorize-this-number/266217#266217">Kevin Cr</a></td></tr>
<tr d-ix="4"><td>268</td><td>JavaScript Node.js</td><td>231025T114432Z</td><td><a href="https://codegolf.stackexchange.com/questions/266208/help-i-cant-bloody-well-memorize-this-number/266214#266214">l4m2</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Haskell, 560 bytes</h1>
<pre><code>i x=read[x]
r x c=(\(a,b)-&gt;(a+c,x:b)).f
m(a:b:c:l)|i a+i b==i c&amp;&amp;a/='0'=r[a,b,c]2l
 |i a*i b==i c&amp;&amp;a/='0'=r[a,b,c]3l
m(a:b:c:d:l)|i a+i b==read[c,d]&amp;&amp;a/='0'&amp;&amp;c/='0'=r[a,b,c,d]3l
 |i a*i b==read[c,d]&amp;&amp;a/='0'&amp;&amp;c/='0'=r[a,b,c,d]5l
m _=(maxBound::Int,[])
y(a:b:c:d:l)|elem[a,b,c,d]$words&quot;1714 1727 1760 1820 1830 1837&quot;=r[a,b,c,d]4l
 |elem[a,b,c,d]$words&quot;1901 1910 1936 1952 1972&quot;=r[a,b,c,d]2l
 |[a,b,c,d]==&quot;2022&quot;=r[a,b,c,d]1l
 |elem[a,b,c,d]$words&quot;3215 3507 3573 3705 5507 5508 5537 7105 7108 7718 7735 7738&quot;=r[a,b,c,d]3l
y(x:l)=r[x]2l
f[]=(0,[])
f l=min(m l)$y l
</code></pre>
<p>Ungolfed version:</p>
<pre><code>
import Data.Char
import Control.Arrow

type Partition = [String]

badResult :: (Int, Partition)
badResult = (maxBound, [])


optimalMemorization :: String -&gt; (Int, Partition)
optimalMemorization [] = (0, [])
optimalMemorization xs = minimum $ map ($ xs) [math, relation]

recurse :: String -&gt; String -&gt; Int -&gt; (Int, Partition)
recurse prefix rest cost = ((+ cost) *** (prefix :)) (optimalMemorization rest)

math :: String -&gt; (Int, Partition)
math (a:b:c:xs)
    | digitToInt a + digitToInt b == digitToInt c &amp;&amp; a /= '0' = recurse [a, b, c] xs 2
    | digitToInt a * digitToInt b == digitToInt c &amp;&amp; a /= '0' = recurse [a, b, c] xs 3
math (a:b:c:d:xs)
    | digitToInt a + digitToInt b == read ([c, d]) &amp;&amp; a /= '0' &amp;&amp; c /= '0' = recurse [a, b, c, d] xs 3
    | digitToInt a * digitToInt b == read ([c, d]) &amp;&amp; a /= '0' &amp;&amp; c /= '0' = recurse [a, b, c, d] xs 5
math _ = badResult

relation :: String -&gt; (Int, Partition)
relation (a:b:c:d:xs)
    | [a, b, c, d] `elem` [&quot;1714&quot;, &quot;1727&quot;, &quot;1760&quot;, &quot;1820&quot;, &quot;1830&quot;, &quot;1837&quot;] = recurse [a, b, c, d] xs 4
    | [a, b, c, d] `elem` [&quot;1901&quot;, &quot;1910&quot;, &quot;1936&quot;, &quot;1952&quot;, &quot;1972&quot;] = recurse [a, b, c, d] xs 2
    | [a, b, c, d] == &quot;2022&quot; = recurse [a, b, c, d] xs 1
    | [a, b, c, d] `elem` [&quot;3215&quot;, &quot;3507&quot;, &quot;3573&quot;, &quot;3705&quot;, &quot;5507&quot;, &quot;5508&quot;, &quot;5537&quot;, &quot;7105&quot;, &quot;7108&quot;, &quot;7718&quot;, &quot;7735&quot;, &quot;7738&quot;] = recurse [a, b, c, d] xs 3
relation (x:xs) = recurse [x] xs 2 -- Residual option
</code></pre>
<p>We pass around <code>(Int, Partition)</code>s where the <code>Int</code> is the cost and <code>Partition</code> is the answer. As we go, we take a <code>min</code> of these. <code>min</code> on tuples compares the first element first, so we always take a minimum cost element using the default Haskell comparison.</p>
<p>In terms of branching, we only have to check <code>math</code> (<code>m</code> in the golfed version) and <code>relation</code> (resp. <code>y</code>). <code>relation</code> checks the year condition and the symbol condition, which are mutually exclusive and hence safe to check together. <code>math</code> checks the four mathematical conditions in order: 3-digit sum, 3-digit product, 4-digit sum, 4-digit product. This order will always produce an optimal mathematical result.</p>
<p>Proof: If 3-digit sum succeeds, then 3-digit product just costs more and is not optimal. 4-digit sum cannot succeed since two numbers cannot add up to two different results simultaneously, and 4-digit product is not optimal because it's worse than just taking the 3-digit sum and treating the fourth digit as residual (<code>2 + 2</code> vs. <code>5</code>). If 3-digit product succeeds, then 4-digit sum must fail (sums are not larger than products), and 4-digit product must fail since the product can't be two different numbers. Finally, if 4-digit sum succeeds, it's better than 4-digit product by cost alone. ∎</p>
<p>So implement our main function <code>optimalMemorization</code> (resp. <code>f</code>) recursively. If the string is empty, cost is zero. Else, try <code>math</code> and <code>relation</code> and take the minimum cost between the two (if the cost is the same, we choose the string that would appear first in the dictionary, which is a harmless tiebreaker).</p>
<p><code>recurse</code> (resp. <code>r</code>) is a helper function, since we always combine our results in the same way, so it's better to give this helper a name. <code>i</code> in the golfed version is just <code>Data.Char.digitToInt</code>, but it's shorter to write it ourselves rather than importing.</p>
<p>Our <code>badResult</code> is just the &quot;failure&quot; case (since the math rules might not even apply at all) and produces a memorization string with the worst possible cost. Unfortunately, in the golfed version, we need a <code>::Int</code> here. It didn't have to be here, but we had to put a type annotation somewhere, because without specifying that our math is being done with integers, all Haskell can tell is that our math is being done with some <code>(Num a, Bounded a, Ord a) =&gt; a</code> type, and it's ambiguous which one.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 156 bytes</h1>
<pre><code>≔⟦⟦⁰Ｓ⟧⟧θＦθ«≔⊟ιη¿ηＦ⊞Ｏ⁺Ｅ⪪”)¶≕⁰∨℅U:.ï4◧Π-⊙⁵z›“Dνq⬤◧≦rＳ=≦:nＷ→NＥE⊕ζTΣ✂aＨ⟲“↶¿!⧴p↘Y”⁵⪪κ⁴Ｅ∧›η1⟦Σ…η²Π…η²⟧⟦⁺…η²κ×⊕λＬκ⟧⟦…η¹2⟧Ｆ¬⌕η§κ⁰⊞θ⁺Ｅι⎇νμ⁺Σ⊟κμ⟦…ηＬ§κ⁰✂ηＬ§κ⁰⟧⊞υι»✂⌊υ¹
</code></pre>
<p><a href="https://tio.run/##dVJNi9swED1vfoXwaQQu6CNeZdlTWGgJdFtDegs5GEcbi9iyI8ulS@lvd5@S7KG71KCHNW8@3oymbqpQ91U7z@txdEdPu53I2cYPU9zG4PyR@H6fszN/XLz0gdGZs9@Lu5tv2Q/keM4asHfuhVHD2cWrnMbm@2BDFftAZTuN9FwNtB1aFymTRi6X0igDuBdLuVIJ9AVgexBSyQcpAPoeUCiAUUoJ/GglC60LYQA42ohCF@kKWAG00UbCBkAykzKCS7DSWc4KiL2qOOVsyXFLutb@QF@CraIN1OQskxmI3Xbq6Om1bu1TgzZhV8m/DP1hquMHZp9CLp2@Y3J2wvnhOjvSxtfBdtZHe6AW1q/WH2NDpxSe4v8JlbBkKgNznem3PtJnB6ng1nHjD/ZX6kJwfCwNnM6Q9zZrh5o2@Cq8ks9Zd2NST@nRTqlcxz8WvSl6lx9Da11t/@8AkdgA2472qmTKmYPlz6LECkW6Rj877zoImHhqjj/Oc9qEQsj05MD0wPOnn@1f" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Gives alternative results for two of the inputs. Explanation:</p>
<pre><code>≔⟦⟦⁰Ｓ⟧⟧θＦθ«
</code></pre>
<p>Perform a breadth first search over partitions starting with no partitions yet and a score of zero.</p>
<pre><code>≔⊟ιη
</code></pre>
<p>Get the next unpartitioned suffix.</p>
<pre><code>¿η
</code></pre>
<p>If it wasn't empty:</p>
<pre><code>Ｆ⊞Ｏ⁺Ｅ⪪”...”⁵⪪κ⁴Ｅ∧›η1⟦Σ…η²Π…η²⟧⟦⁺…η²κ×⊕λＬκ⟧⟦…η¹2⟧
</code></pre>
<p>Loop over three lists: a) A list of years and symbols, with their scores b) If the suffix does not begin with <code>0</code>, then a list of additions and products, with their scores c) A list of the first digit with a score of <code>2</code>.</p>
<pre><code>Ｆ¬⌕η§κ⁰
</code></pre>
<p>If the suffix starts with this potential partition, then...</p>
<pre><code>⊞θ⁺Ｅι⎇νμ⁺Σ⊟κμ⟦…ηＬ§κ⁰✂ηＬ§κ⁰⟧
</code></pre>
<p>Push the updated partition and score to the search list.</p>
<pre><code>⊞υι
</code></pre>
<p>But if it was empty, then collect the completed partition in the predefined empty list.</p>
<pre><code>»✂⌊υ¹
</code></pre>
<p>Output the partition with the lowest score, tied by shortest length of the first different substring.</p>
</div>
<div id="pu2" class="pu"><h1>JavaScript (ES7), 273 bytes</h1>
<p>Expects a string and returns the partition as an array of integers.</p>
<pre class="lang-javascript prettyprint-override"><code>f=([v,...a],p=[],s=q=0,c=&quot;&quot;,[w,x,y,z]=c)=&gt;(v&amp;&amp;!z&amp;&amp;f(a,p,s,c+v),c?f(a,[...p,c++],s+=x?+w?/1(bn|c0|cx|el|ev|f2|gu|h3|ht|i9|it|k7)|2(hc|pg|ra|uy)|49[01u]|5(he|hh|y[fwz])/.test(c.toString(36))?w&gt;2?3:1&lt;&lt;16/x:w-+-x==(y+=[z])?3-!z:w*x==y?z?5:3:1/0:1/0:2,v):v||q&amp;&amp;s&gt;q||(q=s,o=p),o)
</code></pre>
<p><a href="https://tio.run/##dVLLkqIwFN3PV9AsKBgj5AGEWB35iFlSLBzG14wlKAhq5d@dG5RuNUolAXLuuee@/s7aWV3s11Uz3pZ/5pfLQrpZi3zfn@WoklmOarmTGBXStlHWoSM6oXMuC09O3dZxPs6Os3BnqEI1Kkath4pU/2bAr@BiBPSRPKajLg2I@3urCqyKo5pv1LxVC6qWB7ViatWotVDrRv3jnqLuqlDVUu1n6nDyVCgyTA65itzVXK1W6pQtunPuBX4zrxu38JvyV7Nfb5cuiz0v7aY0ZRPy@Uni4DjpxqPxUUr3NJIZcFI2/jhPup9wdUrPaTQBywD3m6LWm7RK7Rynnu6UcneyRqWsPFR6l6Lc1uVm7m/KpbtwbSI4ta2Hx/OsILAyjeQ/XpgL@505ssRLBqYPGgMDzJHFkaVxgycoSRinxDZ4GkGWxkwxyp6S@RKjzLAOw4TQl8mEyNKYyUgMhYEBCARlRpTo7MKYYNtMP7nmDmKAm2IMxDiOIswxtx/EWC8GGLJgYagi5gY/CntpRklkP0prBKQppKlRM2hOQiIwuWvcEDQgyNLYm7ZpgwgTbQFn7@CBeg2XDD5u3@9mQCRECJJci2jfzwAgMD5CT8J3IV/MA/QlZjQOCU3sp@oD1pNjXQU4wmsg4O3VXEXDtp@7CHdX5vfbcAB3EU44J7BZcp@JbiSUBVDoIif9ycwIODSKMQGrbw6P8VBXjYAPJm7HrUVgkV/@Aw" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<p>This gives alternate solutions for a few test cases.</p>
<h2>Scoring method</h2>
<p>We make sure that each part <span class="math-container">\$c\$</span> is made of at most 4 characters and split them into <span class="math-container">\$[w,x,y,z]\$</span>.</p>
<ul>
<li><p>If <span class="math-container">\$x\$</span> is not defined: this is a single digit ➝ the score is <span class="math-container">\$2\$</span>.</p>
</li>
<li><p>If <span class="math-container">\$w=0\$</span>, this is an illegal pattern ➝ the score is <span class="math-container">\$\infty\$</span>.</p>
</li>
<li><p>We test all special patterns at once with the following regular expression applied to the base-36 representation of <span class="math-container">\$c+1\$</span>:</p>
<pre><code>/1(bn|c0|cx|el|ev|f2|gu|h3|ht|i9|it|k7)|2(hc|pg|ra|uy)|
49[01u]|5(he|hh|y[fwz])/
</code></pre>
<p>If a match is found:</p>
<ul>
<li>if <span class="math-container">\$w&gt;2\$</span>, this is a 'symbol' ➝ the score is <span class="math-container">\$3\$</span>.</li>
<li>otherwise the score is given by the expression <code>1&lt;&lt;16/x</code> (<span class="math-container">\$1\$</span> for <code>2<b>0</b>22</code>, <span class="math-container">\$2\$</span> for <code>1<b>9</b>xx</code>, <span class="math-container">\$4\$</span> for <code>1<b>7</b>xx</code> or <code>1<b>8</b>xx</code>)</li>
</ul>
</li>
<li><p>If <code>w-+-x==y+[z]</code>, the score is either <span class="math-container">\$2\$</span> or <span class="math-container">\$3\$</span>.</p>
</li>
<li><p>If <code>w*x==y+[z]</code>, the score is either <span class="math-container">\$3\$</span> or <span class="math-container">\$5\$</span>.</p>
</li>
<li><p>If none of the above worked out, the score is <span class="math-container">\$\infty\$</span>.</p>
</li>
</ul>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 114 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>.œDεεgÐVi·ë5;÷i•иΩÅjnÃñ8ä{5pqŒΩ&amp;™ l
&amp;5ƒZtøà₆é~λãÝαB‡~hq•žEвyk©(iy¬_iëR3äí©`+QY&lt;*D_i\®`*QYD4Q+*D_I*+}ë®Žζ›₂в@O]OWkè
</code></pre>
<p><a href="https://tio.run/##AbsARP9vc2FiaWX//y7Fk0TOtc61Z8OQVmnCt8OrNTvDt2nigKLQuM6pw4VqbsODw7E4w6R7NXBxxZLOqSbihKIgbAomNcaSWnTDuMOg4oKGw6l@zrvDo8OdzrFC4oChfmhx4oCixb5F0LJ5a8KpKGl5wqxfacOrUjPDpMOtwqlgK1FZPCpEX2lcwq5gKlFZRDRRKypEX0kqK33Dq8Kuxb3OtuKAuuKCgtCyQE9dT1drw6j//zU0MjAyMjQzMjE1" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##NYzBSgJRFIb3PYW4kNCLzLlzr/cOBUZMazHItBItiJqMSopgiESsXIetgzIXDVOCgilFLeYwLQefYV5kmlFa/B@c8/N/p@e7e8Z@cGlm4zG/3YnFs6a@EQ/S7oPujbzRAd4XDGeMNl/CseE3u9OJZ@Hd0Qne4EBi74qf1d2OZyX8227seCHBfztbFzjBJ7/VRqvhfeELPnqDVb/53Dish3v3Z206NGuOtWiYzlvFKKK9rmIP3x2rmsqXlpN6xdhx@tVkvqSzfCo8i8nUNdpO3/32Pvzmp99qTYcrObSL5dxmDV@DeLpAgm3QBCURtBkVSolGQaqCAgGqEsYkUBJBJSCjnmVAIUwNH0LhXBGKIJzNCpUCJyCAgabAXKVJ0DSQ82UoDEUZlWYYUBnp@X9IGK5IISCMKst/" rel="nofollow noreferrer">verify almost all test cases</a> (the largest two are omitted because they'll timeout on TIO).</p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>.œ                         # Get all partitions of the (implicit) input
  D                        # Duplicate it
   ε                       # Map over each partition:
    ε                      #  Inner map over each part:
     g                     #   Pop and push the length of the part
      Ð                    #   Triplicate this length
       V                   #   Pop one copy, and store it in variable `Y`
      i                    #   Pop another copy, and if it's 1:
       ·                   #    Double the length to 2
      ë                    #   Else (the length is &gt;=2):
       5;                  #    Push 2.5 (halve 5)
         ÷                 #    Integer-divide the length by this 2.5
       i                   #    If this is 1 (aka the length was 3 or 4):
        •иΩÅjnÃñ8ä{5pqŒΩ&amp;™ l\n&amp;5ƒZtøà₆é~λãÝαB‡~hq•
                           #     Push compressed integer 2059679753934118777767891051414020721847227706932308941504785260793787677550089063849770927917
         žEв               #     Convert it to base-8192 as list: [2022,1901,1910,1936,1952,1972,3215,3507,3573,3705,5507,5508,5537,7105,7108,7718,7735,7738,1714,1727,1760,1820,1830,1837]
             yk            #     Get the index of the current part in this list
                           #     (or -1 if it's not in this list)
               ©           #     Store this index in variable `®` (without popping)
        (i                 #     If the index is -1:
          y                #      Push the current part again
           ¬               #      Push its leading digit (without popping)
          _i               #      If this leading digit is a 0:
                           #       (use the current part implicitly)
           ë               #      Else:
            R              #       Reverse the part
             3ä            #       Split it into three parts
               í           #       Reverse each part
                           #       (converts the part to a triplet: ABC→[C,B,A] and ABCD→[CD,B,A])
                ©          #       Store this triplet in variable `®` (without popping)
                 `         #       Pop and push the parts to the stack
                  +        #       Add the top two (B+A)
                   Q       #       Check if its equal to the other integer (C or CD)
                    Y&lt;     #       Push the part's length - 1
                      *    #       Multiply it to the check
            D              #       Duplicate it
             _i            #       Pop and if it's 0:
               \           #        Discard the duplicated part
                ®          #        Push triplet `®` again
                 `*Q       #        B*A this time
                    YD4Q+  #        Push the part's length + (length==4)
                         * #        Multiply it to the check
               D           #        Duplicate it
                _          #        Pop and check whether its 0
                 I*        #        Multiply it to the input
                   +       #        Add it to the earlier value
              }            #       Close this if-statement
                           #       (implicit else: use the duplicated value)
         ë                 #     Else (the index was not -1):
          ®                #      Push the index again from variable `®`
           Žζ›             #      Push compressed integer 17749
              ₂в           #      Convert it to base-26 as list: [1,0,6,17]
                @          #      Check for each whether it's &gt;= the index
                 O         #      Sum those checks together
                           #    (implicit else: the length is 2 or &gt;=5)
                           #     (implicitly use the implicit input-integer)
   ]                       # Close all if-else statements and the nested maps
    O                      # Sum each inner list together
     W                     # Push the minimum of the sums (without popping the list)
      k                    # Get the (first) index of this minimum in the list of sums
       è                   # Use that to index into the list of partitions
                           # (after which this partition is output implicitly as result)
</code></pre>
<p><a href="https://codegolf.stackexchange.com/a/166851/52210">See this 05AB1E tip of mine (sections <em>How to compress large integers?</em> and <em>How to compress integer lists?</em>)</a> to understand how the compressed integers and lists work.</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 268 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>f=([c,...x],s='')=&gt;c?Math.min(f(x,s+=c),f(x)+('171417271760182018301837190119101936195219722022321535073573370555075508553771057108771877357738'.match(/..../g).includes([A,B,C,D,E]=s)?s&lt;1900?4:s&lt;3e3?3-A:3:B?!+A|E?1/0:A- -B==C+[D]?D?3:2:A*B==C+[D]?D?5:3:1/0:2)):s?1/0:0
</code></pre>
<p><a href="https://tio.run/##dY/NTsMwEITvPAWcEhPH8XrrOrFqrPTnyBNUPURu@oPaBOGAeuDdw4YTh3L4pNHsrHbnrflqYvg4vw951@/bcTy4dBu4EOK249ElCXMvwb82w0lcz116SG88Zi4wToplaQIGZmCUATOXUCoCJwxUEqACCRXOodIKKqOUVAoVaNTSoDaIRmpNmii1RmNAaqIkQVDCYJmIazOEU1rQR6I4MnHuwuVz38Z0W/MlX/E13@xcZD4u6KT0MxsX2KLHvLZol/4pq783Hgpp6/wxXzq3yrbrnV97tMrWz38MTfkppxiz8XdDjqHvYn9pxaU/UvVkKpEw9nDHrv7xqfK9icLJHX8A" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<p>f(string left, to encode)</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/266208/">266208</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




