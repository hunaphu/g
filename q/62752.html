<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::62752</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>050</td><td>Red</td><td>241205T081240Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/277056#277056">Galen Iv</a></td></tr>
<tr d-ix="1"><td>041</td><td>JavaScript Node.js</td><td>241205T064925Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/277053#277053">l4m2</a></td></tr>
<tr d-ix="2"><td>052</td><td>AWK</td><td>241205T063046Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/277052#277052">xrs</a></td></tr>
<tr d-ix="3"><td>005</td><td>Uiua SBCS</td><td>240630T055657Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/273844#273844">chunes</a></td></tr>
<tr d-ix="4"><td>7149</td><td>R</td><td>240616T111935Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/273680#273680">int 21h </a></td></tr>
<tr d-ix="5"><td>005</td><td>Nekomata</td><td>230613T023348Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/261801#261801">alephalp</a></td></tr>
<tr d-ix="6"><td>006</td><td>Thunno 2</td><td>230611T140056Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/261767#261767">The Thon</a></td></tr>
<tr d-ix="7"><td>010</td><td>05AB1E</td><td>161212T144422Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/102986#102986">Magic Oc</a></td></tr>
<tr d-ix="8"><td>040</td><td>V vim</td><td>210409T030618Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/223122#223122">Razetime</a></td></tr>
<tr d-ix="9"><td>004</td><td>Vyxal</td><td>210219T102552Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/219387#219387">lyxal</a></td></tr>
<tr d-ix="10"><td>046</td><td>Zsh</td><td>210219T093003Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/219386#219386">pxeger</a></td></tr>
<tr d-ix="11"><td>059</td><td>C</td><td>210202T110456Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/218457#218457">Toby Spe</a></td></tr>
<tr d-ix="12"><td>006</td><td>x8616 machine code</td><td>210202T091328Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/218440#218440">user9915</a></td></tr>
<tr d-ix="13"><td>004</td><td>Husk</td><td>201023T114906Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/214014#214014">Razetime</a></td></tr>
<tr d-ix="14"><td>006</td><td>Japt h</td><td>201023T105533Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/214007#214007">Shaggy</a></td></tr>
<tr d-ix="15"><td>055</td><td>Kotlin</td><td>200316T080703Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/201115#201115">snail_</a></td></tr>
<tr d-ix="16"><td>006</td><td>05AB1E</td><td>200312T175107Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/200927#200927">Kevin Cr</a></td></tr>
<tr d-ix="17"><td>009</td><td>MATL</td><td>180706T130128Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/168071#168071">Sundar R</a></td></tr>
<tr d-ix="18"><td>019</td><td>K oK / K4</td><td>180706T132308Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/168075#168075">mkst</a></td></tr>
<tr d-ix="19"><td>075</td><td>Rust</td><td>180704T192853Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/167947#167947">null</a></td></tr>
<tr d-ix="20"><td>006</td><td>Jelly</td><td>180704T174851Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/167941#167941">Erik the</a></td></tr>
<tr d-ix="21"><td>062</td><td>C# Visual C# Compiler</td><td>180704T154423Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/167926#167926">Jeppe St</a></td></tr>
<tr d-ix="22"><td>048</td><td>Powershell + Regex</td><td>180703T165204Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/167789#167789">mazzy</a></td></tr>
<tr d-ix="23"><td>012</td><td>Regex</td><td>180703T172211Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/167793#167793">mazzy</a></td></tr>
<tr d-ix="24"><td>077</td><td>Scala</td><td>151105T144201Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/63016#63016">Leonardo</a></td></tr>
<tr d-ix="25"><td>027</td><td>Japt</td><td>151103T230246Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62851#62851">ETHprodu</a></td></tr>
<tr d-ix="26"><td>076</td><td>Java 8</td><td>161212T150914Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/102989#102989">Xanderha</a></td></tr>
<tr d-ix="27"><td>145</td><td>Java 7</td><td>161212T090213Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/102972#102972">Kevin Cr</a></td></tr>
<tr d-ix="28"><td>049</td><td>PHP</td><td>161212T081301Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/102970#102970">jimmy230</a></td></tr>
<tr d-ix="29"><td>061</td><td>Brainfuck</td><td>161212T073337Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/102969#102969">Mitch Sc</a></td></tr>
<tr d-ix="30"><td>146</td><td>C#</td><td>151105T150934Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/63018#63018">Yytsi</a></td></tr>
<tr d-ix="31"><td>012</td><td>Dyalog APL</td><td>160516T103756Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/80002#80002">Ad&#225;</a></td></tr>
<tr d-ix="32"><td>037</td><td>><></td><td>160516T113436Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/80007#80007">Sok</a></td></tr>
<tr d-ix="33"><td>067</td><td>Javascript 67 Bytes</td><td>151108T234016Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/63356#63356">Fuzzyzil</a></td></tr>
<tr d-ix="34"><td>028</td><td>Perl 6</td><td>151108T231231Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/63354#63354">Brad Gil</a></td></tr>
<tr d-ix="35"><td>040</td><td>MATLAB</td><td>151105T124700Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/63004#63004">Jonas</a></td></tr>
<tr d-ix="36"><td>054</td><td>MUMPS</td><td>151110T214855Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/63551#63551">senshin</a></td></tr>
<tr d-ix="37"><td>099</td><td>C++</td><td>151104T132027Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62914#62914">sweerpot</a></td></tr>
<tr d-ix="38"><td>047</td><td>Python 3</td><td>151104T210457Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62959#62959">xnor</a></td></tr>
<tr d-ix="39"><td>2539</td><td>ùîºùïäùïÑùïöùïü</td><td>151104T051821Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62891#62891">Mama Fun</a></td></tr>
<tr d-ix="40"><td>072</td><td>Python 3</td><td>151103T184338Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62793#62793">Morgan T</a></td></tr>
<tr d-ix="41"><td>073</td><td>C99</td><td>151106T022327Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/63071#63071">Cominter</a></td></tr>
<tr d-ix="42"><td>091</td><td>brainfuck</td><td>151105T200630Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/63039#63039">undergro</a></td></tr>
<tr d-ix="43"><td>090</td><td>Scala</td><td>151104T150748Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62931#62931">corvus_1</a></td></tr>
<tr d-ix="44"><td>130</td><td>R</td><td>151105T181413Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/63031#63031">Catherin</a></td></tr>
<tr d-ix="45"><td>044</td><td>Ruby</td><td>151104T162441Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62937#62937">manatwor</a></td></tr>
<tr d-ix="46"><td>105</td><td>pb</td><td>151105T180305Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/63029#63029">undergro</a></td></tr>
<tr d-ix="47"><td>018</td><td>Perl 5</td><td>151104T222623Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62963#62963">msh210</a></td></tr>
<tr d-ix="48"><td>063</td><td>MATLAB</td><td>151105T104241Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62997#62997">slvrbld</a></td></tr>
<tr d-ix="49"><td>052</td><td>PHP</td><td>151105T094340Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62992#62992">insertus</a></td></tr>
<tr d-ix="50"><td>062</td><td>Julia</td><td>151104T043025Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62888#62888">Alex A.</a></td></tr>
<tr d-ix="51"><td>021</td><td>Minkolang 0.10</td><td>151105T023618Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62976#62976">El&#39;e</a></td></tr>
<tr d-ix="52"><td>009</td><td>CJam</td><td>151103T174047Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62771#62771">Dennis</a></td></tr>
<tr d-ix="53"><td>016</td><td>TeaScript</td><td>151104T043601Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62889#62889">Downgoat</a></td></tr>
<tr d-ix="54"><td>152</td><td>Java</td><td>151104T223315Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62964#62964">user4691</a></td></tr>
<tr d-ix="55"><td>112</td><td>C#</td><td>151104T223841Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62966#62966">Hand-E-F</a></td></tr>
<tr d-ix="56"><td>065</td><td>Powershell</td><td>151104T221241Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62962#62962">Jonathan</a></td></tr>
<tr d-ix="57"><td>050</td><td>Python 2</td><td>151104T005524Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62863#62863">Zach Gat</a></td></tr>
<tr d-ix="58"><td>034</td><td>Swift</td><td>151104T203709Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62957#62957">user3369</a></td></tr>
<tr d-ix="59"><td>147</td><td>C#</td><td>151103T214901Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62837#62837">Jakothes</a></td></tr>
<tr d-ix="60"><td>019</td><td>ed</td><td>151104T170305Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62942#62942">Random83</a></td></tr>
<tr d-ix="61"><td>007</td><td>Pyth</td><td>151103T174628Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62774#62774">FryAmThe</a></td></tr>
<tr d-ix="62"><td>024</td><td>K</td><td>151104T050507Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62890#62890">JohnE</a></td></tr>
<tr d-ix="63"><td>051</td><td>Clojure/ClojureScript</td><td>151103T233336Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62855#62855">MattPutn</a></td></tr>
<tr d-ix="64"><td>215</td><td>AppleScript</td><td>151103T232424Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62854#62854">Addison </a></td></tr>
<tr d-ix="65"><td>014</td><td>Retina</td><td>151103T223822Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62847#62847">mbomb007</a></td></tr>
<tr d-ix="66"><td>052</td><td>Javascript ES6</td><td>151103T220317Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62843#62843">Dendrobi</a></td></tr>
<tr d-ix="67"><td>026</td><td>CJam</td><td>151103T173836Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62769#62769">geokavel</a></td></tr>
<tr d-ix="68"><td>039</td><td>Common Lisp</td><td>151103T215252Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62838#62838">Joshua T</a></td></tr>
<tr d-ix="69"><td>029</td><td>Haskell</td><td>151103T203240Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62818#62818">xnor</a></td></tr>
<tr d-ix="70"><td>018</td><td>sed</td><td>151103T192451Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62806#62806">Digital </a></td></tr>
<tr d-ix="71"><td>054</td><td>Python 3</td><td>151103T190618Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62800#62800">Beta Dec</a></td></tr>
<tr d-ix="72"><td>045</td><td>K</td><td>151103T183842Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62791#62791">kirbyfan</a></td></tr>
<tr d-ix="73"><td>014</td><td>rs</td><td>151103T180149Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62779#62779">kirbyfan</a></td></tr>
<tr d-ix="74"><td>038</td><td>Haskell</td><td>151103T175451Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62776#62776">nimi</a></td></tr>
<tr d-ix="75"><td>013</td><td>APL</td><td>151103T174504Z</td><td><a href="https://codegolf.stackexchange.com/questions/62752/longest-common-prefix-of-2-strings/62773#62773">marinus</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="http://www.red-lang.org" rel="nofollow noreferrer">Red</a>, 50 bytes</h1>
<pre><code>func[a b][copy/part a find a first difference a b]
</code></pre>
<p><a href="https://tio.run/##TYzBCsMwDEPv/QqTH@i9n7Fr6MGJ7RFoneCkhX59thQ2epLEk2RM/cXk10mWLodGjxBWH3O55oLWAEGS0i1WG1ASYWONDKPYiyVtIODeWw64udvUina56c@Ix9XO2twvPOh3cPIAQ/oH" rel="nofollow noreferrer" title="Red ‚Äì Try It Online">Try it online!</a></p>
<pre><code>copy/part a                              ; copy the head of the first string
            find a                       ; that ends at the position
                   first                 ; of the first symbol
                         difference a b  ; in the special difference of the two strings
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 41 bytes</h1>

<pre class="lang-none prettyprint-override"><code>f=([a,...A],[b,...B])=&gt;[a]==b?a+f(A,B):''
</code></pre>
<p><a href="https://tio.run/##y0osSyxOLsosKNHNy09J/f8/zVYjOlFHT0/PMVYnOgnEcIrVtLWLToy1tU2yT9RO03DUcdK0Ulf/n5yfV5yfk6qXk5@ukaahlJ6Tn5SYo6SgowBiFhcnFlUqaWpyoalKSS1ILCrJTc0rAauEcLGoAxpRlqoEUgGicclDLYOo@A8A" rel="nofollow noreferrer" title="JavaScript (Node.js) ‚Äì Try It Online">Try it online!</a></p>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.gnu.org/software/gawk/" rel="nofollow noreferrer">AWK</a>, 52 bytes</h1>
<pre><code>{while((x=substr($1,++i,1))~substr($2,i,1))printf x}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m704sTx7wYKlpSVpuhY3TarLMzJzUjU0KmyLS5OKS4o0VAx1tLUzdQw1NetgIkY6YH5BUWZeSZpCRS1EL9SIBevSc_LLUhWAZHFxYlElRBQA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<pre><code>{while((x=substr($1,++i,1)) # grab each char from first string
~substr($2,i,1))            # compare to each char of second
printf x}                   # print match
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://uiua.org" rel="nofollow noreferrer">Uiua</a> <sup><a href="https://tinyurl.com/Uiua-SBCS-Apr-12" rel="nofollow noreferrer">SBCS</a></sup>, 5 bytes</h1>
<pre><code>‚ñΩ\√ó‚àä,
</code></pre>
<p><a href="https://uiua.org/pad?src=0_12_0-dev_1__RiDihpAg4pa9XMOX4oiKLAoKRiAiZ2xvYmFsIiAiZ2xvc3NhcnkiCkYgImRlcGFydG1lbnQiICJkZXBhcnQiCkYgImdsb3ZlIiAiZG92ZSIKRiAiIiAiYWJjIgo=" rel="nofollow noreferrer">Try it!</a></p>
<h3>Explanation</h3>
<pre><code>‚ñΩ\√ó‚àä,¬≠‚Å°‚Äã‚Äé‚Äé‚Å™‚Å°‚Å™‚Å†‚Å™‚Å§‚Å™‚Äè‚Å†‚Äé‚Å™‚Å°‚Å™‚Å†‚Å™‚Å¢‚Å°‚Å™‚Äè‚Äè‚Äã‚Å°‚Å†‚Å°‚Äå‚Å¢‚Äã‚Äé‚Äé‚Å™‚Å°‚Å™‚Å†‚Å™‚Å¢‚Å™‚Äè‚Å†‚Äé‚Å™‚Å°‚Å™‚Å†‚Å™‚Å£‚Å™‚Äè‚Äè‚Äã‚Å°‚Å†‚Å°‚Äå‚Å£‚Äã‚Äé‚Äé‚Å™‚Å°‚Å™‚Å†‚Å™‚Å°‚Å™‚Äè‚Äè‚Äã‚Å°‚Å†‚Å°‚Äå¬≠
   ‚àä,  # ‚Äé‚Å°mask of where letters match
 \√ó    # ‚Äé‚Å¢cumulative product
‚ñΩ      # ‚Äé‚Å£keep
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://www.r-project.org" rel="nofollow noreferrer">R</a>, 71 bytes (the function-only version: 49 bytes)</h1>
<h3>A recursive approach with regex:</h3>
<pre class="lang-r prettyprint-override"><code>s=scan(,&quot;&quot;);`?`=\(a,b)`if`(regexpr(b,a)-1,a?sub(&quot;.$&quot;,&quot;&quot;,b),b);s[1]?s[2]
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m72waMGCpaUlaboWN92LbYuTE_M0dJSUNK0T7BNsYzQSdZI0EzLTEjSKUtNTKwqKNJJ0EjV1DXUS7YtLkzSU9FSUgIqBaoDIujjaMNa-ONooFmLcmvSc_KTEHAUgVVQJEYLZBAA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<ol>
<li>Checks if one string matches the beginning of another one.</li>
<li>If true, the substring is output.</li>
<li>Else remove the last character from the substring, pass to the function and call it again.</li>
</ol>
<h3>Matching substrings:</h3>
<h3># <a href="https://www.r-project.org" rel="nofollow noreferrer">R</a>, 80 bytes</h3>
<pre class="lang-r prettyprint-override"><code>s=scan(,&quot;&quot;);a=s[1];b=s[2];`+`=\(x)substring(x,1,1:nchar(a));max((+a)[+a==+b],&quot;&quot;)
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m72waMGCpaUlaboWNwOKbYuTE_M0dJSUNK0TbYujDWOtk4CUUax1gnaCbYxGhWZxaVJxSVFmXrpGhY6hjqFVXnJGYpFGoqamdW5ihYaGdqJmtHaira12UizIEIi5G1NSCxKLSnJT80q4IEyIOMxeAA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Creates all possible sequential substrings that start from the 1st character for the both strings, subset for those that match and output the longest one.</p>
<h3>An attempt to use a built-in <code>abbreviate</code></h3>
<h3># <a href="https://www.r-project.org" rel="nofollow noreferrer">R</a>, 48 bytes</h3>
<pre class="lang-r prettyprint-override"><code>sub(&quot;.$&quot;,&quot;&quot;,max(abbreviate(scan(,&quot;&quot;),1,F,,,,F)))
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m72waMGCpaUlaboWNw2KS5M0lPRUlHSUlHRyEys0EpOSilLLMhNLUjWKkxPzNIDimjqGOm46QOCmqakJ0bcpPSe_qFIBSJalgsikxByIBMxgAA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Note: unfortunately, this is not a valid answer, as it would fail if the provided strings contain a &quot;<code> </code>&quot;, &quot;<code>\t</code>&quot; or similar. We assume that, if not otherwise specified, an input string might contain at least a space symbol.</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/AlephAlpha/Nekomata" rel="nofollow noreferrer">Nekomata</a>, 5 bytes</h1>
<pre><code>·µÉp=al
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m70iLzU7PzexJHFZtJJurlLsgqWlJWm6Fssfbm0usE3MWVKclFwMFVtw00IpPSc_KTFHSQHEKC5OLKpU4lJKSS1ILCrJTc0rAYpDOEBRoIKyVJAAiIIYAAA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<pre><code>·µÉp=al
·µÉp      Non-deterministically choose a prefix of both inputs
  =     Check if the two prefixes are equal
   al   Find the last possible solution, which is the longest
</code></pre>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/Thunno/Thunno2" rel="nofollow noreferrer">Thunno 2</a>, 6 <a href="https://github.com/Thunno/Thunno2/blob/main/docs/codepage.md" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>Z‚Ç¨·∫°ƒ°h·ªã
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m728JKM0Ly_faMGCpaUlaboWa6MeNa15uGvhkYUZD3d3LylOSi6GyizYrJSek5-UmKPEBWIUFycWVSpBpAA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<h4>Explanation</h4>
<pre class="lang-python prettyprint-override"><code>Z‚Ç¨·∫°ƒ°h·ªã  # Implicit input
Z       # Zip them together
 ‚Ç¨      # To each inner pair:
  ·∫°     #  Check if they're equal
   ƒ°    # Group consecutive items
    h   # Get the first group
     ·ªã  # Corresponding filter
        # Implicit output
</code></pre>
</div>
<div id="pu7" class="pu"><h1><a href="http://github.com/Adriandmen/05AB1E" rel="nofollow noreferrer">05AB1E</a>, 10 bytes</h1>
<pre><code>.ps.p¬©√•¬Æ√è¬§
</code></pre>
<p><a href="http://05ab1e.tryitonline.net/#code=LnBzLnDCqcOlwq7Dj8Kk&amp;input=YmxhdGhhemFyCmJsYXI" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu8" class="pu"><h1><a href="https://github.com/DJMcMayhem/V" rel="nofollow noreferrer">V (vim)</a>, <sup><s>41</s></sup> 40 bytes</h1>
<pre><code>qqhYp$x@qq@qo&lt;esc&gt;j$@qo&lt;esc&gt;:%!awk 'a[$0]++'
jdG
</code></pre>
<p><a href="https://tio.run/##K/v/v7AwI7JApcKhsNChMN8mtTjZLksFxrJSVUwsz1ZQT4xWMYjV1lbnykpx//8/JbUgsagkNzWvhAvC/K9bBgA" rel="nofollow noreferrer" title="V (vim) ‚Äì Try It Online">Try it online!</a></p>
<p>No regex.</p>
<p>Takes the strings on two separate lines. The awk command is from <a href="https://stackoverflow.com/a/26982021/4568534">here.</a></p>
<p>Once the matching prefixes are found, we delete everything except the first line.</p>
</div>
<div id="pu9" class="pu"><h1><a href="https://github.com/Lyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a>, <code>a</code>, <s>5</s> 4 bytes</h1>
<pre><code>R√∑ƒ°·πò
</code></pre>
<p><a href="http://lyxal.pythonanywhere.com?flags=a&amp;code=R%C3%B7%C4%A1%E1%B9%98&amp;inputs=pog%0Apogchamo&amp;header=&amp;footer=" rel="nofollow noreferrer">Try it Online!</a></p>
<h2>Explained</h2>
<pre><code>R√∑ƒ°·πò
R√∑   # vectorise reverse over the input (wrapped in an array by the -a flag) and push contents onto the stack
  ƒ°  # Push the greatest common suffix
   ·πò # and reverse it to get the prefix
</code></pre>
</div>
<div id="pu10" class="pu"><h1><a href="https://www.zsh.org/" rel="nofollow noreferrer">Zsh</a>, 46 bytes</h1>

<pre class="lang-sh prettyprint-override"><code>until [[ $1 = ${2%$~s}* ]] {s+=?;}
&lt;&lt;&lt;${2%$~s}
</code></pre>
<p><a href="https://tio.run/##qyrO@P@/NK8kM0chOlpBxVDBVkGl2khVpa64VkshNlahuljb1t66lsvGxgYm/v///5TUgsSiktzUvBIoEwA" rel="nofollow noreferrer" title="Zsh ‚Äì Try It Online">Try it online!</a></p>
</div>
<div id="pu11" class="pu"><h1>C, 59 bytes</h1>
<pre class="lang-c prettyprint-override"><code>main(int c,char**a){while(*a[1]==*a[2]++)putchar(*a[1]++);}
</code></pre>
<p>Input from the command-line arguments.</p>
<p>Note - will overrun after printing the final null character if the input strings are identical.</p>
</div>
<div id="pu12" class="pu"><h2>x86-16 machine code, 6 bytes</h2>
<pre><code>00000000  56 A6 74 FD 4E C3                                 V.t.N.
</code></pre>
<p>Callable function.</p>
<p>Expects <code>[SI]</code> = address of first string, <code>[DI]</code> = address of second string.</p>
<p>Outputs as: <code>Top of stack</code> = start of memory slice, <code>SI</code> = end of memory slice (like the slice in Python).</p>
<p>Disassembly:</p>
<pre><code>56            PUSH    SI    ; Store original SI onto stack
A6      LOOP: CMPSB         ; Compare [SI++] with [DI++]
74 FD         JZ      LOOP  ; If they're equal, jump to tag 'LOOP'
4E            DEC     SI    ; -- SI
C3            RET           ; Return to caller
</code></pre>
<h2>Example run</h2>
<pre><code>-d 0100
0B4A:0100  56 A6 74 FD 4E C3 00 00-00 00 00 00 00 00 00 00   V.t.N...........
0B4A:0110  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0B4A:0120  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0B4A:0130  67 6C 6F 62 61 6C 00 00-00 00 00 00 00 00 00 00   global..........
0B4A:0140  67 6C 6F 73 73 61 72 79-00 00 00 00 00 00 00 00   glossary........
0B4A:0150  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0B4A:0160  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0B4A:0170  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
-r
AX=0000  BX=0000  CX=0000  DX=0000  SP=FFEA  BP=0000  SI=0130  DI=0140
DS=0B4A  ES=0B4A  SS=0B4A  CS=0B4A  IP=0100   NV UP EI PL NZ NA PO NC
0B4A:0100 56            PUSH    SI
-t

AX=0000  BX=0000  CX=0000  DX=0000  SP=FFE8  BP=0000  SI=0130  DI=0140
DS=0B4A  ES=0B4A  SS=0B4A  CS=0B4A  IP=0101   NV UP EI PL NZ NA PO NC
0B4A:0101 A6            CMPSB
...
-t

AX=0000  BX=0000  CX=0000  DX=0000  SP=FFE8  BP=0000  SI=0133  DI=0144
DS=0B4A  ES=0B4A  SS=0B4A  CS=0B4A  IP=0105   NV UP EI PL NZ NA PE CY
0B4A:0105 C3            RET
-d ss:ffe0
0B4A:FFE0  00 00 00 00 30 01 4A 0B-AE 05 30 01 30 01 00 00   ....0.J...0.0...
0B4A:FFF0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
-rsp
SP FFEA
:
-
</code></pre>
</div>
<div id="pu13" class="pu"><h1><a href="https://github.com/barbuz/Husk" rel="nofollow noreferrer">Husk</a>, <sup><s>6</s></sup> 4 bytes</h1>
<pre><code>‚Üí¬§n·∏£
</code></pre>
<p><a href="https://tio.run/##yygtzv7//1HbpENL8h7uWPz///@U1ILEopLc1LwSKLO0KBUA" rel="nofollow noreferrer" title="Husk ‚Äì Try It Online">Try it online!</a></p>
<p>-2 bytes from Dominic Van essen.</p>
</div>
<div id="pu14" class="pu"><h1><a href="https://github.com/ETHproductions/japt" rel="nofollow noreferrer">Japt</a> <a href="https://codegolf.meta.stackexchange.com/a/14339/"><code>-h</code></a>, 6 <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>¬Æ√•+√Érf
</code></pre>
<p><a href="https://petershaggynoble.github.io/Japt-Interpreter/?v=1.4.6&amp;flags=LWg&amp;code=ruUrw3Jm&amp;input=WyJnbG9iYWwiLCJnbG9zc2FyeSJd" rel="nofollow noreferrer">Try it</a></p>
</div>
<div id="pu15" class="pu"><h1><a href="https://kotlinlang.org" rel="nofollow noreferrer">Kotlin</a>, 55 bytes</h1>

<p>Not-Lame Edition! (no builtin) </p>

<pre><code>{zip(it).takeWhile{(a,b)-&gt;a==b}.fold(""){a,(f,_)-&gt;a+f}}

{zip(it)                                                 // zip first string with second
        .takeWhile{(a,b)-&gt;a==b}                          // take pairs while chars are equal
                               .fold(""){a,(f,_)-&gt;a+f}}  // fold into string
</code></pre>

<p><a href="https://tio.run/##dY47DsIwEET7nGLlai0SHyCSwwXoKCjRhthgxWyixFBg@ezGfETHNCPN29XMOAXvON/Jg21hHxbHZ4Ufl9B03wh0jg83owtSBRrN4eK8iUh1L5uOtO6TspMfUAgZqUZbH1/5xqaU7Y3hSo5RQqyg6N21BtCwGBp2jk1B2xaE@OGVh394LnMCln9lsZxJWaXcGzpNXBXjJw" rel="nofollow noreferrer" title="Kotlin ‚Äì Try It Online">Try it online!</a></p>
</div>
<div id="pu16" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 6 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>√∏‚Ç¨√ãŒ≥–Ω√è
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//8I5HTWsOd5/bfGHv4f7//9Nz8pMSc7iAVHFxYlElAA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/V9Waa@k8KhtkoKSfWWCy9EF/w/veNS05nD3uc0X9h7u/6/zPzpaKT0nPykxR0kHxCguTiyqVIrViVZKSS1ILCrJTc0rAcpAOGBxoKKyVJAQiAIJlGRkFisAUaJCSWoxSDFcIC@/JCO1CCIMUpmYlGyYkmppkQZUBGQbpaRamKcpxcYCAA" rel="nofollow noreferrer">verify all test cases</a>.</p>
<p>Or alternatively:</p>
<pre><code>Œ∑R.Œî√Ö?
</code></pre>
<p>Might be invalid, since it outputs <code>-1</code> instead of an empty string if the strings have no common prefix.</p>
<p><a href="https://tio.run/##yy9OTMpM/f//3PYgvXNTDrfa//@fnpOflJjDBaSKixOLKgE" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/V9Waa@k8KhtkoKSfWVC6P9z24P0zk2JKD7cav@/Vud/dLRSek5@UmKOkg6IUVycWFSpFKsTrZSSWpBYVJKbmlcClIFwwOJARWWpICEQBRIoycgsVgCiRIWS1GKQYrhAXn5JRmoRRBikMjEp2TAl1dIiDagIyDZKSbUwT1OKjQUA" rel="nofollow noreferrer">verify all test cases</a>.</p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>√∏      # Zip the two (implicit) inputs together, creating pairs
       #  i.e. &quot;abc1de98f&quot; and &quot;abc2de87f&quot;
       #   ‚Üí [&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;12&quot;,&quot;dd&quot;,&quot;ee&quot;,&quot;98&quot;,&quot;87&quot;,&quot;ff&quot;]
 ‚Ç¨√ã    # Check for each if all inner items (the two characters in this case) are the same
       #  ‚Üí [1,1,1,0,1,1,1,0,0,1]
   Œ≥   # Split it into parts, grouping the same subsequent values together
       #  ‚Üí [[1,1,1],[0],[1,1],[0,0],[1]]
    –Ω  # Pop and only leave the first item
       #  ‚Üí [1,1,1]
     √è # Only leave the characters at the truthy indices in the (implicit second) input
       #  i.e. &quot;abc2de87f&quot; and [1,1,1] ‚Üí &quot;abc&quot;
       # (after which the result is output implicitly)

Œ∑      # Get the prefixes of the first (implicit) input
       #  i.e. &quot;abc1de98f&quot;
       #   ‚Üí [&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;,&quot;abc1&quot;,&quot;abc1d&quot;,&quot;abc1de&quot;,&quot;abc1de9&quot;,&quot;abc1de98&quot;,&quot;abc1de98f&quot;]
 R     # Reverse this list
       #  ‚Üí [&quot;abc1de98f&quot;,&quot;abc1de98&quot;,&quot;abc1de9&quot;,&quot;abc1de&quot;,&quot;abc1d&quot;,&quot;abc1&quot;,&quot;abc&quot;,&quot;ab&quot;,&quot;a&quot;]
  .Œî   # Then find the first item in this list which is truthy for:
       # (which will result in -1 if none are found)
    √Ö? #  Check if the second (implicit) input starts with the current prefix
       #   i.e. &quot;abc2de87f&quot; and &quot;abc1d&quot; ‚Üí 0 (falsey)
       #   i.e. &quot;abc2de87f&quot; and &quot;abc&quot; ‚Üí 1 (truthy)
       # (after which the result is output implicitly)
</code></pre>
</div>
<div id="pu17" class="pu"><h1><a href="https://github.com/lmendo/MATL" rel="nofollow noreferrer">MATL</a>, <s>11</s> 9 bytes</h1>

<pre><code>y!=XdYpf)
</code></pre>

<p><a href="https://tio.run/##y00syfn/v1LRNiIlsiBN8/9/9ZTUgsSiktzUvBJ1LignNUUdAA" rel="nofollow noreferrer" title="MATL ‚Äì Try It Online">Try it online!</a></p>

<p><em>(-2 bytes thanks to Giuseppe)</em></p>

<pre><code> y  % implicitly input the two strings, then duplicate the
    %  first one into the stack again
    %  stack: ['department' 'deported' 'department']
 !  % transpose the last string into a column vector
 =  % broadcast equality check - gives back a matrix comparing
    %  every letter in first input with the letters in the second
 Xd % diagonal of the matrix - comparison result of each letter with
    %  only corresponding letter in the other string
    %  stack: ['department' [1; 1; 1; 0; 1; 1; 0; 0;]]
 Yp % cumulative product (so only initial sequence of 1s remains
    %  1s, others become 0)
    %  stack: ['department' [1; 1; 1; 0; 0; 0; 0; 0;]]
 f  %  find the indices of the 1s
 )  % index at those elements so we get those letters out
    % (implicit) convert to string and display
</code></pre>
</div>
<div id="pu18" class="pu"><h1><a href="https://github.com/JohnEarnest/ok" rel="nofollow noreferrer">K (oK)</a> / <a href="http://kx.com/download" rel="nofollow noreferrer">K4</a>, <s>21</s> 19 bytes</h1>

<p><strong>Solution:</strong></p>

<pre><code>(*x)@&amp;&amp;\=/(#,/x)$x:
</code></pre>

<p><a href="https://tio.run/##y9bNz/7/X0OrQtNBTS3GVl9DWUe/QlOlwkpDKT0nPykxR8kaxCguTiyqVNL8/x8A" rel="nofollow noreferrer" title="K (oK) ‚Äì Try It Online">Try it online!</a></p>

<p><strong>Explanation:</strong></p>

<p>Pad strings to combined length of the strings, check for equality, find matching indices, take minimum over resulting list, and index into first element of original input at these indices.</p>

<pre><code>(*x)@&amp;&amp;\=/(#,/x)$x: / the solution
                 x: / save input as x
                $   / pad
          (    )    / do together
            ,/x     / flatten (,/) x
           #        / count (returns length)
        =/          / compare, equals (=) over (/)
      &amp;\            / mins, min (&amp;) scan (\)
     &amp;              / indices where true
    @               / index into
(  )                / do this together
 *x                 / first (*) x
</code></pre>
</div>
<div id="pu19" class="pu"><h1><a href="https://www.rust-lang.org/" rel="nofollow noreferrer">Rust</a>, 75 bytes</h1>



<pre class="lang-rust prettyprint-override"><code>|a,b|a.chars().zip(b.chars()).take_while(|(a,b)|a==b).map(|v|v.0).collect()
</code></pre>

<p><a href="https://tio.run/##NY1BCoMwFET3nuLXRfkfbOhasT1ED1B@JFFpjJKkltZ49lQLncXwBoYZ9/QhaQsD9xYJlgw2GRVAl6AtHn1wBexOcLrALbjetlCnyIWMLJqOnUcSn35C@U8kAj/U/dX1RmHErUmR61qSGHjCOMdZnEk0ozGqCUhpf6x@v9O2How9YL6U1zUvQGPemlGy2Xgn79m9c6IqW9MX" rel="nofollow noreferrer" title="Rust ‚Äì Try It Online">Try it online!</a></p>

<p>Does unnecessary heap allocation for the result (idiomatic Rust code would return <code>&amp;str</code> here as opposed to <code>String</code>), but it works so whatever. It's not like it matters.</p>

<p>This iterates over string characters as long as characters match and then collects matched characters into a <code>String</code>.</p>
</div>
<div id="pu20" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 6 bytes</h1>

<pre><code>¬π∆§‚Ç¨f/·π™
</code></pre>

<p><a href="https://tio.run/##y0rNyan8///QzmNLHjWtSdN/uHPV////o9XTc/KTEnPUdRRArOLixKJK9VgA" rel="nofollow noreferrer" title="Jelly ‚Äì Try It Online">Try it online!</a></p>
</div>
<div id="pu21" class="pu"><h1><a href="http://www.mono-project.com/docs/about-mono/releases/5.0.0/#csc" rel="nofollow noreferrer">C# (Visual C# Compiler)</a>, 62 bytes</h1>



<pre class="lang-cs prettyprint-override"><code>(a,b)=&gt;Concat(a.Zip(b,(x,y)=&gt;x==y?x:'$').TakeWhile(x=&gt;x!='$'))
</code></pre>

<p><a href="https://tio.run/##jY7BSgMxEIbveYq4CE0g5gFctx5ETwpChYK32XRcg9mkZrJlF@mzr0ltD4JgT5N8P9/8Y@jKkJkHsr7jlCBZw1cTJez1KsUMa/ZX9mj9p773Q48RWoc1Y8fcOCDizzF0EXr2dcK7YDf8CawXMsPjkofBmxs6tCj@ey75Ww55MwtQrWyWd8EbSAL0q92KVolRTZmOTTPdjteLy4XUL/CB63frUIw5uGgKlHN96soLKDjU62gT5utRlAJRdS604CrFy4sI4lRJ@a@1wS3E1KNPxfz5nePljh0elDKLsGf7@Rs" rel="nofollow noreferrer" title="C# (Visual C# Compiler) ‚Äì Try It Online">Try it online!</a></p>

<p><code>Zip</code>! This byte count includes only the lambda expression, and some necessary <code>using static</code> directives are not counted.</p>

<p>It is assumed that no word will contain the magical <code>char</code> value <code>$</code> (otherwise program may fail). Can use <code>\0</code> instead (but that is longer to type).</p>
</div>
<div id="pu22" class="pu"><h1>Powershell + Regex, 48 bytes</h1>

<pre><code>$m=$args-join"`n"-match"(^.*).*`n\1";$Matches[1]
</code></pre>

<p>one line input strings only.</p>

<h1>Powershell pure, <s>58</s> 56 bytes</h1>

<pre><code>param($a,$b)for($i=0;$a[$i]-eq$b[$i]){$c+=$a[$i++]};"$c"
</code></pre>

<p>Test script:</p>

<pre><code>$f = {
param($a,$b)for($i=0;$a[$i]-eq$b[$i]){$c+=$a[$i++]};"$c"
}

"glo" -eq (&amp;$f "global" "glossary")
"depart" -eq (&amp;$f "department"  "depart")
"" -eq (&amp;$f "glove" "dove")
</code></pre>

<p>Output:</p>

<pre><code>True
True
True
</code></pre>
</div>
<div id="pu23" class="pu"><h1>Regex, 12 bytes</h1>

<pre><code>(^.*).*$\n\1
</code></pre>

<p>each input string is separate line. <a href="https://regex101.com/r/bTf1ud/1" rel="nofollow noreferrer">https://regex101.com/r/bTf1ud/1</a></p>
</div>
<div id="pu24" class="pu"><h1>Scala, <strike>85</strike> <strike>83</strike> 77 bytes</h1>
<pre><code>def f(a:String,b:String)=a zip b takeWhile(a=&gt;a._1==a._2) map(_._1) mkString
</code></pre>
<p>for example,</p>
<pre><code>f(&quot;global&quot; , &quot;glossary&quot;)
</code></pre>
<p>returns</p>
<pre><code>glo
</code></pre>
</div>
<div id="pu25" class="pu"><h1>Japt, 27 bytes</h1>
<p><strong>Japt</strong> is a shortened version of <strong>Ja</strong>vaScri<strong>pt</strong>. <a href="https://codegolf.stackexchange.com/a/62685/42545">Interpreter</a></p>
<pre><code>Um$(X,Y)=&gt;$A&amp;&amp;X==VgY ?X:A=P
</code></pre>
<p>(The strings go into the Input box like so: <code>&quot;global&quot; &quot;glossary&quot;</code>)</p>
<p>This code is exactly equivalent to the following JS:</p>
<pre><code>A=10;(U,V)=&gt;U.split``.map((X,Y)=&gt;A&amp;&amp;X==V[Y]?X:A=&quot;&quot;).join``
</code></pre>
<p>I have not yet implemented anonymous functions, which is what the <code>$...$</code> is for: anything between the dollar signs is left untouched in the switch to JS. After I add functions, this 21-byte code will suffice:</p>
<pre><code>UmXY{A&amp;&amp;X==VgY ?X:A=P
</code></pre>
<p>And after I implement a few more features, it will ideally be 18 bytes:</p>
<pre><code>UmXY{AxX=VgY ?X:AP
</code></pre>
<p>Suggestions welcome!</p>
<hr />
<p>So it turns out that this program is only 15 bytes in modern Japt:</p>
<pre><code>¬°A¬©X¬•VgY ?X:A=P
</code></pre>
<p><a href="https://tio.run/nexus/japt#@39ooeOhlRGHloalRyrYR1g52gb8/6@UnpOflJijpABiFBcnFlUqAQA" rel="nofollow noreferrer" title="Japt ‚Äì TIO Nexus">Try it online!</a></p>
</div>
<div id="pu26" class="pu"><h1>Java 8, 76 bytes</h1>

<pre><code>(a,b)-&gt;{String m="";for(int i=0;i&lt;a.length&amp;&amp;a[i]==b[i];)m+=a[i++];return m;}
</code></pre>

<p>Lambda that takes 2 <code>char[]</code> arguments. Loops through until the letters stop matching or we match them all, appending them to a blank string as it goes.</p>
</div>
<div id="pu27" class="pu"><h1>Java 7, 145 bytes</h1>
<pre><code>class M{public static void main(String[]a){for(char i=0,c;i&lt;a[0].length();){c=a[0].charAt(i);if(c!=a[1].charAt(i++))break;System.out.print(c);}}}
</code></pre>
<p>Those pesky program-requirements instead of function..</p>
<p><strong>Ungolfed:</strong></p>
<pre><code>class M{
  public static void main(String[] a){
    for(char i = 0, c; i &lt; a[0].length(); ){
      c = a[0].charAt(i);
      if(c != a[1].charAt(i++)){
        break;
      }
      System.out.print(c);
    }
  }
}
</code></pre>
<p><a href="https://ideone.com/2Meoxw" rel="nofollow noreferrer">Try it here.</a></p>
</div>
<div id="pu28" class="pu"><h1>PHP, 49 bytes</h1>
<pre><code>&lt;?=substr($t=$argv[1],0,strspn($t^$argv[2],&quot;\0&quot;));
</code></pre>
<p>Replace <code>\0</code> with the actual byte.</p>
</div>
<div id="pu29" class="pu"><h2>Brainfuck, 61 bytes</h2>

<pre><code>+
[
  ,[&lt;+&gt; &gt;+&lt;-]
  ++++[&gt;--------&lt;-]
  &gt;
]
&lt;&lt;[&lt;]
&lt;+
[
  ,[&gt;+&gt;-&lt;&lt;-]
  &gt;&gt;[&lt;]
  &lt;[.&gt;]
  &lt;
]
</code></pre>

<p>Expects two words separated by a space.</p>

<p><a href="http://brainfuck.tryitonline.net/#code=K1ssWzwrPj4rPC1dKysrK1s-LS0tLS0tLS08LV0-XTw8WzxdPCtbLFs-Kz4tPDwtXT4-WzxdPFsuPl08XQ&amp;input=Z2xvYmFsIGdsb3NzYXJ5" rel="nofollow noreferrer">Try it online.</a></p>
</div>
<div id="pu30" class="pu"><h2>C# <strike>147</strike> 146</h2>
<pre><code>string l(string a,string b){var s=&quot;&quot;;for(int i=0;i&lt;Math.Min(a.Length,b.Length);i++){if(a[i]==b[i])s+=a[i];else return a.Substring(0,i);}return s;}
</code></pre>
<p>Readable and ungolfed version</p>
<pre><code>    string longestPrefix(string a, string b)
    {
        var s = &quot;&quot;;
        for (int i = 0; i &lt; Math.Min(a.Length, b.Length); i++)
        {
            if (a[i] == b[i]) s+=a[i];
            else return a.Substring(0, i);
        }

        return s;
    }
</code></pre>
<h2>How it works:</h2>
<p>It loops until characters on the same index do not match. Every character that matches is added to <strong>s</strong> string, otherwise return a new string from zero index to current iteration.</p>
</div>
<div id="pu31" class="pu"><h1><a href="http://goo.gl/9KrKoM" rel="nofollow noreferrer">Dyalog APL</a>, 12 bytes</h1>
<pre><code>{‚ä•‚ç®‚åΩ=‚åø‚Üë‚çµ}‚Üë‚àä
</code></pre>
<p>That's two bytes less than the previous APL solution!</p>
<p>The overall function is <code>‚Üë</code>, which takes <em>n</em> elements (characters) from the flattened (<code>‚àä</code>) argument, where <em>n</em> is the result of applying the function <code>{‚ä•‚ç®‚åΩ=‚åø‚Üë‚çµ}</code> to the argument:</p>
<p><code>‚Üë‚çµ</code> convert list of strings to table (padding with spaces to form rectangle)<br>
<code>=‚åø</code> compare down (columns) giving boolean list<br>
<code>‚åΩ</code> reverse<br>
<code>‚ä•‚ç®</code> count trailing trues*</p>
<hr />
<p>*Literally it is a mixed-base to base-10 conversion, using the boolean list as both number and base:</p>
<p><code>‚ä•‚ç®0 1 0 1 1</code> is the same as <code>0 1 0 1 1‚ä•‚ç®0 1 0 1 1</code> which is  <code>0√ó(0√ó1√ó0√ó1√ó1) 1√ó(1√ó0√ó1√ó1) 0√ó(0√ó1√ó1) 1√ó(1√ó1) + 1√ó(1)</code> which again is two (the number of trailing 1s).</p>
</div>
<div id="pu32" class="pu"><h1><a href="https://esolangs.org/wiki/Fish" rel="nofollow">>&lt;></a>, 37 bytes</h1>

<pre><code>i:0( ?\
4*=?\$&gt;1+{:8
+[r]\$1
?!;o&gt;:{=
</code></pre>

<p><a href="http://fish.tryitonline.net/#code=aTowKCA_XAo0Kj0_XCQ-MSt7OjgKK1tyXVwkMQo_ITtvPjp7PQ&amp;input=ZGVwYXJ0bWVudCBkZXBhcnQ" rel="nofollow">Try it online!</a></p>

<p>Input is via STDIN, and is expected without quotes, separated by a space. For example, <code>global glossary</code>.</p>

<p>After the input is read, the characters up to and including the space are reversed and pushed back onto the stack. For example, if the input were <code>global glossary</code>, the stack would be <code>glossary labolg</code>. The stack is then rotated to the left one step at a time. If the top two chars are the same, output. Otherwise, end.</p>
</div>
<div id="pu33" class="pu"><h1>Javascript: 67 Bytes</h1>

<pre><code>(a,b)=&gt;{for(i=0;i&lt;a.length;i++){if(a[i]!=b[i])return a.slice(0,i)}}
</code></pre>
</div>
<div id="pu34" class="pu"><h1><a href="http://perl6.org" rel="nofollow">Perl 6</a>, 28 bytes</h1>



<p>I came up with two that take their values from STDIN which are based on the Perl 5 answer.</p>

<pre class="lang-perl6 prettyprint-override"><code>lines~~/(.*).*' '$0/;say ~$0
</code></pre>



<pre class="lang-perl6 prettyprint-override"><code>lines~~/:s(.*).* $0/;say ~$0
</code></pre>

<p>The first requires exactly one space between the inputs, while the other requires at least one whitespace character between the inputs.</p>

<hr>

<p>That is quite a bit shorter than the first thing I tried which takes the values from the command line.</p>

<pre class="lang-perl6 prettyprint-override"><code>say [~] map -&gt;($a,$b){$a eq$b&amp;&amp;$a||last},[Z] @*ARGS¬ª.comb # 58 bytes
</code></pre>

<p>or even the lambda version of it:</p>

<pre class="lang-perl6 prettyprint-override"><code>{[~] map -&gt;($a,$b){$a eq$b&amp;&amp;$a||last},[Z] @_¬ª.comb} # 52 bytes
</code></pre>

<p>Though this is much easier to adjust so that it accepts any number of input strings, at the cost of only one stroke.</p>

<pre class="lang-perl6 prettyprint-override"><code>{[~] map -&gt;@b {([eq] @b)&amp;&amp;@b[0]||last},[Z] @_¬ª.comb} # 53 bytes
#          ‚îó‚îÅ‚îõ ‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ  ‚îó‚îÅ‚îÅ‚îÅ‚îõ
</code></pre>



<pre class="lang-perl6 prettyprint-override"><code>my &amp;common-prefix = {[~] map -&gt;@b {([eq] @b)&amp;&amp;@b[0]||last},[Z] @_¬ª.comb}

say common-prefix &lt;department depart&gt;; # "depart"
say common-prefix; # ""
say common-prefix &lt;department depart depot deprecated dependant&gt;; # "dep"

# This code does not work directly with a single argument, so you have
# to give it an itemized List or Array, containing a single element.

say common-prefix $('department',); # "department"

# another option would be to replace `@_` with `(@_,)`
</code></pre>
</div>
<div id="pu35" class="pu"><h2>MATLAB, <s>50</s> 40 bytes</h2>

<p>Defines a function that accepts 2 strings as input, outputs to command window</p>

<pre><code>function t(a,b);a(1:find([diff(char(a,b)) 1],1)-1)
</code></pre>

<p>This solution will work for any string, outputs </p>

<pre><code>ans =

   Empty string: 1-by-0
</code></pre>

<p>if no match is given.</p>

<p>Can be golfed by  using a script instead of a function (using local variables a, b) (-16 bytes).</p>

<p>so getting 34 Bytes</p>

<pre><code>a(1:find([diff(char(a,b)) 1],1)-1)
</code></pre>

<p>The function style (which seems to be the accepted style), yields </p>

<pre><code>@(a,b)a(1:find([diff(char(a,b)) 1],1)-1)
</code></pre>

<p>(Thanks @Stewie Griffin)</p>
</div>
<div id="pu36" class="pu"><h1>MUMPS, 54 bytes</h1>

<pre><code>t(a,b) f i=$L(a):-1:0 s p=$E(a,1,i) q:p=$E(b,1,i)
    q p
</code></pre>

<p>Typically primitive stuff - it just compares successively-shorter prefixes of the strings until it hits a match.</p>
</div>
<div id="pu37" class="pu"><h2>C++, <s>101</s> <s>100</s> 99 bytes</h2>

<pre class="lang-c prettyprint-override"><code>#include&lt;iostream&gt;
int i;main(){std::string s,t;std::cin&gt;&gt;s&gt;&gt;t;for(;s[i]==t[i];std::cout&lt;&lt;s[i++]);}
</code></pre>
<p>Reads two strings from <code>stdin</code>, prints the character at the current position from one of the strings while the character at the current position is equal to the character at the same position in the other string.</p>
<p>Thanks to <a href="https://codegolf.stackexchange.com/users/43365/zereges">Zereges</a> for saving one byte.</p>
</div>
<div id="pu38" class="pu"><h2>Python 3, 47</h2>

<pre class="lang-python prettyprint-override"><code>def f(w):[print(end=c[c!=d])for c,d in zip(*w)]
</code></pre>

<p>A function that takes a list <code>w</code> of two words, and prints the common prefix before terminating with an error.</p>

<p>Python 3's <code>print</code> function lets you prints strings flush against each other with <code>print(end=c)</code> (thanks to Sp3000 for saving 3 bytes with this shorter syntax). This repeatedly take two letters from the words, and prints the first of the letters. The indexing <code>c[c!=d]</code> gives an out-of-bounds error where <code>c!=d</code>, terminating the execution when two unequal letters are encountered.</p>

<p>An explicit for loop is one char longer than the list comprehension:</p>

<pre><code>def f(w):
 for c,d in zip(*w):print(end=c[c!=d])
</code></pre>
</div>
<div id="pu39" class="pu"><h1>ùîºùïäùïÑùïöùïü, 25 chars / 39 bytes</h1>
<pre><code>√¥‚ü¶√Ø0]ƒÇ‚áÄ$‚âî√Ø1[_]?1:√Ø1=0)√∏‚¨Ø)
</code></pre>
<p><kbd><a href="http://molarmanful.github.io/ESMin//interpreter.html?eval=true&amp;input=%5B%27global%27%2C%27glob%27%5D&amp;code=%C3%B4%E2%9F%A6%C3%AF0%5D%C4%82%E2%87%80%24%E2%89%94%C3%AF1%5B_%5D%3F1%3A%C3%AF1%3D0%29%C3%B8%E2%AC%AF%29" rel="nofollow noreferrer">Try it here (Firefox only).</a></kbd></p>
<p>It barely looks like ES6.</p>
</div>
<div id="pu40" class="pu"><h1>Python 3, 72</h1>
<p>31 bytes saved thanks to FryAmTheEggman.
8 saved thanks to DSM.</p>
<pre><code>r=''
for x,y in zip(input(),input()):
 if x==y:r+=x
 else:break
print(r)
</code></pre>
</div>
<div id="pu41" class="pu"><h2>C99, 73 bytes</h2>

<pre><code>main(int c,char *a[]){for(char *x=a[1],*y=a[2];*x==*y++;putchar(*x++));}
</code></pre>

<p>Similar to <a href="https://codegolf.stackexchange.com/a/62967/7464">this answer</a>, but shorter and meets spec (takes input from stdin).</p>
</div>
<div id="pu42" class="pu"><h1>brainfuck, 91 bytes</h1>

<pre><code>+[&gt;&gt;,&gt;++++[&lt;--------&gt;-]&lt;]&lt;&lt;[&lt;&lt;]&gt;+[&gt;&gt;++++[&gt;++++++++&lt;-],]&lt;[&lt;]&gt;&gt;-&lt;[&gt;&gt;[&lt;+&gt;&gt;-&lt;-]+&gt;[&lt;-&gt;,]&lt;[&lt;.,]&gt;]
</code></pre>

<p>Requires an interpreter that either allows negative positions on the tape or wraps if you <code>&lt;</code> from 0. Also requires <code>,</code> to return 0 every time you use it after input runs out. (In my experience these are both the most common behaviour.) Takes input as two words separated by a space.</p>

<p>This was a lot easier than I expected it to be! Usually I decide to write a brainfuck program and end up devoting quite a bit of time to it, but this one played nice. My first idea ended up working well and being rather short, especially for brainfuck.</p>

<p>This works by getting the entire first word and storing the characters in every second cell, then weaving in the second word (e.g. <code>gglloosbsaalr y</code>). Then, for each pair of characters <code>a</code> and <code>b</code>, it copies <code>a</code> a cell to the left and simultaneously replaces <code>b</code> with <code>b-a</code>. The cell <code>a</code> used to be in becomes <code>NOT (b-a)</code>. If that's true, <code>a</code> is printed and the loop continues to the next set of characters. Otherwise, nothing is printed and the loop terminates.</p>

<p>I only used two real golfing tricks in this program. The first was combining two unrelated loops while gathering input. The first word is initially stored with each of its bytes subtracted by 32, so that space becomes 0 and the loop can end. Rather than adding 32 to each of those bytes and then getting the second word, the program does both at the same time. The second trick I used was abuse of <code>,</code> when I know the input is empty. The idiomatic way of setting a cell to 0 is <code>[-]</code>. However, if you know that the program has already read the entire input, most interpreters will let you try to get a byte of input anyway and set the current cell to <code>NUL</code>, or 0. I use this twice in my program, saving 4 bytes.</p>

<p><strong>Ungolfed:</strong></p>

<pre><code>+[&gt;&gt;,&gt;++++[&lt;--------&gt;-]&lt;]          get first word (minus 32 at each byte)

&lt;&lt;[&lt;&lt;]&gt;                            go back to start

+[&gt;&gt;++++[&gt;++++++++&lt;-],]            get second word and add 32 to each byte of
                                   first word

&lt;[&lt;]&gt;&gt;-&lt;                           go back to start and clean up a little bit

[                                  main loop

  &gt;&gt;[&lt;+&gt;&gt;-&lt;-]                        subtract letter from second word from
                                     letter of first word 

  +&gt;[&lt;-&gt;,]&lt;                          logical NOT the result

  [&lt;.,]&gt;                             if the result is 1: print the letter
                                     else: the loop dies and execution is
                                     terminated 

]
</code></pre>
</div>
<div id="pu43" class="pu"><h1>Scala, 90 bytes</h1>

<pre><code>object S extends App{print(args(0)zip args(1)takeWhile{case(a,b)=&gt;a==b}map(_._1)mkString)}
</code></pre>

<p>It takes to Strings as arguments and outputs to stdout.</p>
</div>
<div id="pu44" class="pu"><h1>R, 130 bytes</h1>

<pre><code>substr(x[1],1,which.max(apply(do.call(rbind,lapply(strsplit(x,''),`length&lt;-`,nchar(x[1]))),2,function(i)!length(unique(i))==1))-1)
</code></pre>

<p>Usage:</p>

<pre><code>x &lt;- c('bubblegum','bubbafish')
</code></pre>
</div>
<div id="pu45" class="pu"><h1>Ruby, 44 characters</h1>

<pre class="lang-ruby prettyprint-override"><code>-&gt;a,b{i=0;i+=1while a[i]&amp;&amp;a[i]==b[i];a[0,i]}
</code></pre>

<p>Sample run:</p>

<pre><code>2.1.5 :001 &gt; -&gt;a,b{i=0;i+=1while a[i]&amp;&amp;a[i]==b[i];a[0,i]}["global , "glossary"]
 =&gt; "glo"

2.1.5 :002 &gt; -&gt;a,b{i=0;i+=1while a[i]&amp;&amp;a[i]==b[i];a[0,i]}["department", "depart"]
 =&gt; "depart"

2.1.5 :003 &gt; -&gt;a,b{i=0;i+=1while a[i]&amp;&amp;a[i]==b[i];a[0,i]}["glove", "dove"]
 =&gt; ""
</code></pre>
</div>
<div id="pu46" class="pu"><h1><a href="https://esolangs.org/wiki/pb" rel="nofollow">pb</a>, 105 bytes</h1>

<pre><code>^w[B!32]{&gt;}&gt;w[B!0]{t[B]vb[1]&lt;[X]w[B!0]{&gt;}b[T]w[B!1]{&gt;}b[0]^&gt;}v&lt;[X]&lt;t[0]w[T=0]{&gt;t[B]^t[T-B]v}w[B!0]{b[0]&gt;}
</code></pre>

<p>Takes two words separated by a single space. (I can save a byte by using a tab instead but that feels like cheating.)</p>

<p>In pb, the area that can be written to is thought of as a 2D space, with (0, 0) in the upper left. Additionally, input is initially kept at Y=-1. This program copies the second word of the input to Y=0 (starting at (0, 0)). Then, each letter is compared to the letter immediately above it until one is found that doesn't match. The rest of the word is erased and the desired output is already on the canvas so it's printed when execution halts.</p>

<p><strong>Ungolfed:</strong></p>

<pre><code>^w[B!32]{&gt;}&gt;       # Go to the first letter of the second word
w[B!0]{            # For each letter in the second word:
    t[B]             # Save the letter to T
    vb[1]            # Put a flag below that letter so it can be found later
    &lt;[X]w[B!0]{&gt;}    # Go to the first empty space on Y=0
    b[T]             # Write the contents of T
    w[B!1]{&gt;}b[0]    # Go back to the flag and erase it
    ^&gt;               # Restart loop from next letter
}

v&lt;[X]&lt;             # Go to (-1, 0)
t[0]               # Set T to 0
w[T=0]{            # While T is 0:
    &gt;t[B]            # Save the next letter of the second word to T
    ^t[T-B]v         # Subtract the equivalent letter of the first word from T

    # If they were the same, T is 0 and the loop continues.
}

w[B!0]{b[0]&gt;}      # Erase the rest of the second word
</code></pre>
</div>
<div id="pu47" class="pu"><h2>Perl 5, <s>20</s> <s>19</s> 18 bytes</h2>
<p>19 bytes, plus 1 for the <code>-E</code> flag instead of <code>-e</code>:</p>
<pre><code>say&lt;&gt;=~/^(.*).* \1/
</code></pre>
<p>This is copied shamelessly from <a href="/u/11259">Digital Trauma</a>'s <a href="/a/62806">sed answer</a>. It assumes the input is a couple of words without spaces in them (or before the first) and with one space between them.</p>
<hr />
<p>Update:</p>
<p><a href="/u/31388">ThisSuitIsBlackNot</a> suggested using <code>-pe</code> as follows, to save a byte (thanks!):</p>
<pre><code>($_)=/^(.*).* \1/
</code></pre>
<p>And then <a href="/u/42827">Luk Storms</a> suggested using <code>-nE</code> as follows to save another byte (thanks!):</p>
<pre><code>say/^(.*).* \1/
</code></pre>
<p>(I'm counting <code>-E</code> as one byte instead of the standard <code>-e</code>, but <code>-n</code> or <code>-p</code> as two. My impression is that that's SOP around here.)</p>
</div>
<div id="pu48" class="pu"><h2>MATLAB, 63 bytes</h2>

<p>Defines a function that accepts 2 strings as input.</p>

<pre><code>function f(a,b),c=1;try,while a(c)==b(c),c=c+1;end,end,a(1:c-1)
</code></pre>

<p>Had to include a try-statement for those cases where a would be <strong>a</strong> is a longer string than <strong>b</strong>.</p>

<ul>
<li>If we have the freedom to always supply the shorter string to <strong>a</strong>, then <strong>8 bytes</strong> can be removed.</li>
<li>If it is allowed to define <strong>a</strong> and <strong>b</strong> in the workspace, then another <strong>16 bytes</strong> can be removed.</li>
</ul>
</div>
<div id="pu49" class="pu"><h1>PHP, 52 bytes</h1>
<p>Not spectacular but does the job:</p>
<pre><code>$a=$argv;while($a[1][$i]==$a[2][$i])echo$a[1][$i++];
</code></pre>
<p>Takes two command line arguments:</p>
<pre><code>php prefix.php department depart
</code></pre>
</div>
<div id="pu50" class="pu"><h1>Julia, 62 bytes</h1>



<pre class="lang-julia prettyprint-override"><code>f(a,b)=(c="";for(i,j)=zip(a,b) i!=j?break:(c*=string(i))end;c)
</code></pre>

<p>Ungolfed:</p>

<pre class="lang-julia prettyprint-override"><code>function f(a::AbstractString, b::AbstractString)
    # Initialize an output string
    c = ""

    # Iterate over the pairs of characters in a and b,
    # truncated to the shorter of the two lengths
    for (i, j) in zip(a, b)
        if i == j
            # If they match, append to the output string
            c *= string(i)
        else
            # Otherwise stop everything!
            break
        end
    end

    return c
end
</code></pre>

<p>Fixed an issue (at the hefty cost of 14 bytes) thanks to xnor!</p>
</div>
<div id="pu51" class="pu"><h2><a href="https://github.com/elendiastarman/Minkolang" rel="nofollow noreferrer">Minkolang 0.10</a>, 21 bytes</h2>
<pre><code>(od&quot; &quot;=,)x(0gdo=?.O1)
</code></pre>
<p>Expects input as two words, space-separated, like so: <code>department depart</code>. <a href="http://play.starmaninnovations.com/minkolang/?code=%28od%22%20%22%3D%2C%29x(0gdo%3D%3F%2EO1)&amp;input=department%20depart" rel="nofollow noreferrer">Try it here.</a></p>
<h3>Explanation</h3>
<pre><code>(od&quot; &quot;=,)      Loops through input until a space is encountered
x              Dumps extraneous space
(0gdo=   1)    Loops through second word and compares letters
      ?.O      Halts if two letters are not equal, outputs them otherwise
</code></pre>
</div>
<div id="pu52" class="pu"><h1>CJam, <s>12</s> <s>11</s> 9 bytes</h1>

<pre><code>l_q.-{}#&lt;
</code></pre>

<p>This reads the strings on two separate lines with Unix-style line ending, i.e., <code>&lt;string&gt;\n&lt;string&gt;\n</code>.</p>

<p><em>Thanks to @MartinB√ºttner for -1 byte, and to @jimmy23013 for -2 bytes!</em></p>

<p>Try it online in the <a href="http://cjam.aditsu.net/#code=l_l.-X%2B%7B%7D%23%3C&amp;input=department%0Adepart" rel="nofollow">CJam interpreter</a>.</p>

<h3>How it works</h3>

<pre><code>l_         e# Read a line (w/o trailing LF) from STDIN and push a copy.
  q        e# Read another line from STDIN (with trailing LF).
           e# The trailing linefeed makes sure that the lines are not equal.
   .-      e# Perform vectorized character subtraction. This yields 0 for equal
           e# characters, a non-zero value for two different characters, and the
           e# characters themselves (truthy) for the tail of the longer string.
     {}#   e# Find the index of the first truthy element.
        &lt;  e# Keep that many characters from the first string.
</code></pre>
</div>
<div id="pu53" class="pu"><h1>TeaScript, 16 bytes <s>20</s></h1>

<pre><code>xf¬ªl¬¶y[i]?1:b=0)
</code></pre>

<p>Takes each input separated by a space.</p>
</div>
<div id="pu54" class="pu"><h1>Java, 152 bytes</h1>

<pre><code>String a="aa",b="ab";char[]c=a.toCharArray(),d=b.toCharArray();int e=0,f=Math.min(c.length,d.length);for(;e&lt;f&amp;&amp;c[e]==d[e];e++);return new String(c,0,e);
</code></pre>
</div>
<div id="pu55" class="pu"><h1>C#, 112 bytes</h1>

<pre><code>class P{static void Main(string[]a){try{for(int i=0;a[0][i]==a[1][i];)System.Console.Write(a[0][i++]);}catch{}}}
</code></pre>

<p>Newlines and indentation for clarity:</p>

<pre><code>class P{
    static void Main(string[]a){
        try{
            for(int i=0;a[0][i]==a[1][i];)
                System.Console.Write(a[0][i++]);
        }
        catch{}
    }
}
</code></pre>
</div>
<div id="pu56" class="pu"><h2>Powershell, 65 bytes</h2>

<p>Compare the strings, shrinking the first until it either matches (print and exit) or the string is null and the loop terminates.</p>

<pre><code>param($a,$b)while($a){if($b-like"$a*"){$a;exit}$a=$a-replace".$"}
</code></pre>
</div>
<div id="pu57" class="pu"><h1>Python 2, 50 bytes</h1>

<pre><code>for a,b in zip(*input()):print(1/0if a!=b else a),
</code></pre>

<hr>

<h3>Input</h3>

<p>The input is taken as two strings:</p>

<pre><code>"global", "glossary"
</code></pre>

<hr>

<h3>Output</h3>

<p>The output is each character followed by a space; which, hopefully, isn't a problem. However, if it is, I'll edit my answer.</p>

<pre><code>g l o 
</code></pre>
</div>
<div id="pu58" class="pu"><p><strong>Swift, 34 bytes</strong></p>

<p><code>import UIKit
"global".commonPrefixWith("glossary")</code></p>

<p>But with Swift 2 it is actually more like:
<code>"global".commonPrefixWithString("glossary",options:.CaseInsensitiveSearch)</code></p>
</div>
<div id="pu59" class="pu"><h2>C#, <s>201</s> 147 bytes</h2>

<pre><code>using System.Linq;class a{static void Main(string[]a){a[0].Take(a[1].Length).TakeWhile((t,i)=&gt;a[1][i]==t).ToList().ForEach(System.Console.Write);}}
</code></pre>

<p>I know it isn't terribly competitive. I just wanted to see what it would look like.</p>

<p>EDIT: Thanks Ash Burlakzenko, Berend, and Dennis_E</p>
</div>
<div id="pu60" class="pu"><h2>ed, sed, 19 bytes</h2>

<h2>ex, 18 bytes</h2>

<h2>vim, 20 bytes</h2>

<pre><code>s/\(.*\).* \1.*/\1/
</code></pre>

<p>This also works with ex/vi (heirloom ex 050325), and the trailing slash is not required.</p>

<p>Oddly, this <em>should</em> work in vim, but mysteriously fails. It works if I add another unused capture group, something which should not change the semantics of the regex at all:</p>

<pre><code>s/\v(.*)(.* \1.*)/\1
</code></pre>

<p>It fails and gives garbage answers in nvi and the results are downright mysterious:</p>

<pre><code>:1
global glossary
:s/\(.*\)\(.*\) \1\(.*\)/\1{\2,\3}/
global{,ry}
</code></pre>

<p>NOTE: This expects the words on the current [last in the file] line [or every line for the sed script] separated by a space, and containing no space. To operate on every line in ex/vim, add % to the beginning. I don't think I'm the only program here to have constraints like these.</p>
</div>
<div id="pu61" class="pu"><h1>Pyth, <s>8</s> 7 bytes</h1>

<pre><code>e@F._MQ
</code></pre>

<p>Thanks @isaacg for 1 byte off</p>

<p>Takes input quoted and comma separated, like <code>"abc", "acc"</code>. This exits on an error (but leaves stdout empty) when the result is the empty string. If that is unacceptable, add 2 bytes for <code>#e@F._MQq</code></p>

<p><a href="http://pyth.herokuapp.com/?code=e%40F._MQ&amp;input=%22global%22%2C%22glossary%22&amp;test_suite=1&amp;test_suite_input=%22global%22%2C%22glossary%22%0A%22department%22%2C%22depart%22%0A%22glove%22%2C%22dove%22&amp;debug=0">Test Suite</a></p>

<h3>Explanation</h3>

<pre><code>e@F._MQ        : implicit Q = eval(input)
   ._MQ        : Map the prefix operator onto both inputs
 @F            : Fold the setwise intersection operator over those lists
e              : Take the last such element, the prefixes are always made from shortest
               : to longest, so this always gives the longest matching prefix
</code></pre>
</div>
<div id="pu62" class="pu"><h1>K, 24 bytes</h1>

<pre><code>{(+/&amp;\=/(&amp;/#:'x)#'x)#*x}
</code></pre>

<p>Find the minimum of the length of each string. (<code>(&amp;/#:'x)</code>). Trim each string to that length (<code>#'x</code>). Then compare, smear and sum the resulting sequence:</p>

<pre><code>  =/("globaa";"glossa")
1 1 1 0 0 1
  &amp;\=/("globaa";"glossa")
1 1 1 0 0 0
  +/&amp;\=/("globaa";"glossa")
3
</code></pre>

<p>Finally, take that many characters from the first of the strings provided (<code>#*x</code>).</p>

<p>In action:</p>

<pre><code> f: {(+/&amp;\=/(&amp;/#:'x)#'x)#*x};
 f'(("global";"glossary")
    ("department";"depart")
    ("glove";"dove")
    ("aaa";"aaaaa")
    ("identical";"identical")
    ("aca";"aba"))
("glo"
 "depart"
 ()
 "aaa"
 "identical"
 ,"a")
</code></pre>
</div>
<div id="pu63" class="pu"><h2>Clojure/ClojureScript, 51</h2>

<pre><code>(defn f[[a &amp; b][c &amp; d]](if(= a c)(str a(f b d))""))
</code></pre>

<p>Pretty straightforward.  Unfortunately the spaces around the parameter destructuring are necessary (that's the <code>[a &amp; b]</code> stuff).  Not the shortest but I beat some other answers in languages that like to brag about their terseness so I'll post it.</p>
</div>
<div id="pu64" class="pu"><h1>AppleScript, 215 Bytes</h1>

<p>And I tried so hard... ;(</p>

<pre>set x to(display dialog""default answer"")'s text returned
set a to(display dialog""default answer"")'s text returned
set n to 1
set o to""
repeat while x's item n=a's item n
set o to o&x's item n
set n to n+1
end
o</pre>

<p>I wanted to see how well AppleScript could pull this off, and <em>man</em> is it not built for string comparisons.</p>
</div>
<div id="pu65" class="pu"><h1><a href="https://github.com/mbuettner/retina" rel="nofollow noreferrer">Retina</a>, 14 bytes</h1>
<p>Uses the same idea as <a href="https://codegolf.stackexchange.com/a/62779/34718">kirbyfan64sos</a>. Unfortunately, despite Martin's claim that eventually Match mode will feature a way to print capturing groups, it hasn't been implemented yet. Otherwise, <code>(.*).* \1</code> could be used along with 2 bytes or so for some not-yet-existing configuration string option.</p>
<pre><code>(.*).* \1.*
$1
</code></pre>
<p>Each line would go in its own file, with 1 byte added per additional file. Alternatively, run in a single file with the <code>-s</code> flag.</p>
</div>
<div id="pu66" class="pu"><h1>Javascript ES6, 52 bytes</h1>

<pre><code>f=(a,b)=&gt;[...a].filter((e,i)=&gt;e==b[i]?1:b='').join``
</code></pre>

<p>Usage:</p>

<pre><code>&gt;&gt; f("global","glossary")
"glo"
</code></pre>
</div>
<div id="pu67" class="pu"><h1>CJam, <strike>12</strike> <strike>8</strike> 26</h1>

<pre><code>r:AAr:B.=0#_W={;;ABe&lt;}{&lt;}?
</code></pre>

<p><a href="http://cjam.aditsu.net/#code=r%3AAAr%3AB.%3D0%23_W%3D%7B%3B%3BABe%3C%7D%7B%3C%7D%3F&amp;input=glowing%20glow" rel="nofollow">Try it Online.</a></p>

<p>(Got idea to use .= instead of .- after looking at Dennis's answer.)</p>

<p>With all the edge cases, it became to hard for a CJam beginner like me to keep it short. Hopefully, this at least works for all cases.</p>
</div>
<div id="pu68" class="pu"><h2>Common Lisp, 39</h2>

<pre><code>(lambda(a b)(subseq a 0(mismatch a b)))
</code></pre>

<p>Takes two string arguments, determines the index <em>i</em> where they differ, and returns a substring from 0 to <em>i</em>.</p>
</div>
<div id="pu69" class="pu"><h2>Haskell, 29 bytes</h2>
<pre class="lang-haskell prettyprint-override"><code>(c:x)%(d:y)|c==d=c:x%y;_%_=&quot;&quot;
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt; &quot;global&quot;%&quot;glossary&quot;
&quot;glo&quot;
</code></pre>
<p>Recursively defines the binary function <code>%</code> by pattern matching. On two strings with equal first letters, takes that first letters, and prepends it to the function of the remainder of the strings. On anything else, gives the empty string.</p>
</div>
<div id="pu70" class="pu"><h1>sed, 18</h1>
<p>I had something much longer and more complicated in mind, so credit for <a href="https://codegolf.stackexchange.com/a/62779/11259">this idea goes to @kirbyfan64sos</a>.</p>
<pre><code>s/(.*).* \1.*/\1/
</code></pre>
<p>Includes +1 for the <code>-r</code> option to sed.</p>
</div>
<div id="pu71" class="pu"><h1>Python 3, 54 bytes</h1>

<p>Thanks Python for having a built-in function for this task! :D</p>

<pre><code>import os;print(os.path.commonprefix(input().split()))
</code></pre>

<p>Takes input as two words separated by a space such as <code>glossary global</code>.</p>
</div>
<div id="pu72" class="pu"><h1>K, 45 bytes</h1>
<pre><code>{*|(*v)@{&amp;y~'x}.#[&amp;/#:'v;]'v:{#[;x]'1+!#x}'x}
</code></pre>
<p>Takes input as a 2-element list.</p>
</div>
<div id="pu73" class="pu"><h1><a href="https://github.com/kirbyfan64/rs" rel="noreferrer">rs</a>, 14 bytes</h1>
<pre><code>(.*).* \1.*/\1
</code></pre>
<p><a href="http://kirbyfan64.github.io/rs/index.html?script=%28.*%29.*%20%5C1.*%2F%5C1&amp;input=global%20glossary%0Adepartment%20depart%0Aglove%20dove" rel="noreferrer">Live demo and test cases.</a></p>
<p>This is pretty simple. It just matches the...longest common prefix and removes the rest of the string. If there is no longest common prefix, it just clears everything.</p>
</div>
<div id="pu74" class="pu"><h2>Haskell, 38 bytes</h2>

<pre><code>((map fst.fst.span(uncurry(==))).).zip
</code></pre>

<p>Usage example: <code>(  ((map fst.fst.span(uncurry(==))).).zip  ) "global" "glossary"</code> -> <code>"glo"</code>.</p>

<p>Zip both input string into a list of pairs of characters. Make two lists out of it: the first one with all pairs from the beginning as long as both characters are equal, the second one with all the rests. Drop the second list and extract all characters from the first list.  </p>
</div>
<div id="pu75" class="pu"><h1>APL, 13</h1>
<pre><code>{‚äÉ‚ÜìK/‚ç®=‚åøK‚Üê‚Üë‚çµ}
</code></pre>
<p>This is a function that takes an array of two strings, and returns the prefix:</p>
<pre><code>      {‚äÉ‚ÜìK/‚ç®=‚åøK‚Üê‚Üë‚çµ}'glossary' 'global'
glo
      {‚äÉ‚ÜìK/‚ç®=‚åøK‚Üê‚Üë‚çµ}'department' 'depart'
depart
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/62752/">62752</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




