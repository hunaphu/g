<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::133618</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>105</td><td>x86 32bit machine code with Linux system calls</td><td>170725T092928Z</td><td><a href="https://codegolf.stackexchange.com/questions/133618/extreme-fibonacci/135618#135618">Peter Co</a></td></tr>
<tr d-ix="1"><td>012</td><td>Pyth</td><td>231108T200645Z</td><td><a href="https://codegolf.stackexchange.com/questions/133618/extreme-fibonacci/266623#266623">alt_meta</a></td></tr>
<tr d-ix="2"><td>nan</td><td></td><td>231107T133116Z</td><td><a href="https://codegolf.stackexchange.com/questions/133618/extreme-fibonacci/266567#266567">RARE Kpo</a></td></tr>
<tr d-ix="3"><td>055</td><td>x86 .COM</td><td>221221T192526Z</td><td><a href="https://codegolf.stackexchange.com/questions/133618/extreme-fibonacci/255856#255856">l4m2</a></td></tr>
<tr d-ix="4"><td>081</td><td>Haskell</td><td>170720T224321Z</td><td><a href="https://codegolf.stackexchange.com/questions/133618/extreme-fibonacci/133662#133662">user1502</a></td></tr>
<tr d-ix="5"><td>063</td><td>Ruby</td><td>180310T104343Z</td><td><a href="https://codegolf.stackexchange.com/questions/133618/extreme-fibonacci/157790#157790">ulucs</a></td></tr>
<tr d-ix="6"><td>072</td><td>Python 2 + sympy</td><td>170720T204511Z</td><td><a href="https://codegolf.stackexchange.com/questions/133618/extreme-fibonacci/133637#133637">hyperneu</a></td></tr>
<tr d-ix="7"><td>453</td><td>TSQL</td><td>170721T204216Z</td><td><a href="https://codegolf.stackexchange.com/questions/133618/extreme-fibonacci/133902#133902">BradC</a></td></tr>
<tr d-ix="8"><td>1534</td><td>Mathematica</td><td>170721T033707Z</td><td><a href="https://codegolf.stackexchange.com/questions/133618/extreme-fibonacci/133693#133693">Keyu Gan</a></td></tr>
<tr d-ix="9"><td>nan</td><td>Pari/GP</td><td>170721T140024Z</td><td><a href="https://codegolf.stackexchange.com/questions/133618/extreme-fibonacci/133735#133735">alephalp</a></td></tr>
<tr d-ix="10"><td>061</td><td>Haskell</td><td>170720T220541Z</td><td><a href="https://codegolf.stackexchange.com/questions/133618/extreme-fibonacci/133656#133656">Anders K</a></td></tr>
<tr d-ix="11"><td>070</td><td>Python 2</td><td>170721T002224Z</td><td><a href="https://codegolf.stackexchange.com/questions/133618/extreme-fibonacci/133678#133678">Anders K</a></td></tr>
<tr d-ix="12"><td>078</td><td>Haskell</td><td>170720T232824Z</td><td><a href="https://codegolf.stackexchange.com/questions/133618/extreme-fibonacci/133666#133666">xnor</a></td></tr>
<tr d-ix="13"><td>162</td><td>Haskell</td><td>170720T215158Z</td><td><a href="https://codegolf.stackexchange.com/questions/133618/extreme-fibonacci/133652#133652">Wheat Wi</a></td></tr>
<tr d-ix="14"><td>106</td><td>Python 2</td><td>170720T213101Z</td><td><a href="https://codegolf.stackexchange.com/questions/133618/extreme-fibonacci/133647#133647">xnor</a></td></tr>
<tr d-ix="15"><td>045</td><td>PARI/GP</td><td>170720T213502Z</td><td><a href="https://codegolf.stackexchange.com/questions/133618/extreme-fibonacci/133648#133648">Christia</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>x86 32-bit machine code (with Linux system calls): <s>106</s> 105 bytes</h1>
<p>This is about 10x faster than the similar Python answer, on my Skylake CPU.</p>
<p>changelog: saved a byte in the fast version because an off-by-one constant doesn't change the result for Fib(1G).</p>
<p>Or 102 bytes for an 18% slower (on Skylake) version (using <code>mov</code>/<code>sub</code>/<a href="http://felixcloutier.com/x86/CMC.html" rel="nofollow noreferrer"><code>cmc</code></a> instead of <code>lea</code>/<code>cmp</code> in the inner loop. We need to generate carry-out and wrapping at <code>10**9</code> instead of the <code>2**32</code> we'd get for free).  Or 101 bytes for a ~5.3x slower version with a branch in the carry-handling in the inner-most loop.  (I measured a 25.4% branch-mispredict rate!)</p>
<p>Or 104/101 bytes if a leading zero is allowed.  (It takes 1 extra byte to hard-code skipping 1 digit of the output, which is what happens to be needed for <code>Fib(10**9)</code>).</p>
<p>Unfortunately, TIO's NASM mode seems to ignore <code>-felf32</code> in the compiler flags.  <a href="https://tio.run/##pVprc@PGsf3OXzHXVa4VJZIiuPReSQx9ax/eylZ2E1dkV5JyVKoBMCTHAgEEA4qkU/nrd@/p7hk8KK3j1JW9u@IA6Onpx@nTDWrnzDbOjuNcu@3nz@usiHWm7l2tq3og/9wMBgo/2@KR/jHJYaSiafhR8rNQ7218hmtDlRVFqZJil9emGizoYmY0PxmXI/UT7hlHd6r5wR2xdmYcKZuremP401lZWHp@qCqztg6/qcWwpwXJgih6XpelrkxeZ0dWIpqen18PVW4e8ZQzximtMruNl8uO1uagEzwwUq6ArlsIsPla6bW2uatZjX1VYCXfbWOIsU4VDwM5jWjQN8Ng8LVdqSlruFioapcr7dTkUk@KXa2m0aynu7NkB1deXN3xem2wp6zjDy/9/Iua5MW9rtYuPPrLwe8aH2tDz9uLqTzvdnHjmRfTF7xmt7usVbMnQ/dkRCIj@IjuJx@pC7pRjUng3X8mcfZbJC5OQ2oGK4Yj3wy@Npkzg8VCfcGi03m46GVUKW1TwajRq7twzRuWruFPWCXbugdb3sPr7SZPLYxHyML@@qmR/fKJVU6E6Z6wqBHWs03Ftqk6tvnPRc9@u@hnLY/1jk3I/nlqV4O@mxxyLt6totNl65d7q6ms9iM/xnbjaDqb86rO00YuLgka6Myu8y3SGRmcGOd0dVSrokKW5o8mt3TBg8O4Ms7UsituazaIRHj6RDikB@ukPgUpKOPD3USptzp/USuyAdLfuhv1@vbjn1Wic1Ui4L67/R76YBNGqKKui60qVkCWUq9NL9z7ks99ei0OyWbdqJNaVuYH7EPQ4nDkDcHXShPUQZkP7/6g9pvjRJB3oT7ULwiB2BDfvfug6kLF0MNkxZ5Vi48KwVLbMjNq/sBKOTJ/rWyt9jbLAITrlcYtigDO6JS0N4ea3AyYo1MB65MHBRg7Fju1LrBHAYWqiVfh9YpQGOYAruYBFyHE7XWJvUgr3gh6sX9YbMGSoSW8BYfAYc6kFBYr1AbVGkFnuIeA2m01yeAblLO/AIdtvaGU3@jHVlNGa5yjVIUUDdFnQpEZKobDBV0rlAb1i6kKhd/LqqCQUlzWdvDEfmOTjdoblZoSpoC0G4mnQ1GxMw/kLUEO3KUzlIvmVrU124KiE2EhrrC5rS3KJ7vEkI60s0m9H12diPRy5zb4Z6q6PwtRi56iMjYdRcPxt/gb/81GL9Wjm0h5G02xjr/lSvvQVzH8t9dV6r6ikHVq51QkhRjKbGyeeosDJe2dWnLO/jSl36Y4WYWgOPZS2CN6au@QU/IoJTQeWaoziR2T3peVSayzRT6MIOmf0UhNR2oymfwLvli03oA2CMobXmPsAmzcKJdUuoYHKK7JjTpNYMQctxOLGDFCwPn@szwcH24EQ5AnH2F0VtPScRFa2rEcljFmJkKlP9ARqC3xjlggz4ygnquLKgRWFsQhrnmLoWyZYEtWQ0TCDUWuk8QiuwwOgMO3hIfuT3F/itJDNh3vK8sSVwArdUYn/aqifFduY1fkua8oT1LrEvhO1DDAgbEDDtqVBQLVfAivS2pFtgdBWXQlbFkl/cUYi55aLdV1@IHVXif1Dml2ROxQxm5AoEzuSIt9UT1wxtHTHb6EAJ6swqlvBqSOBJb5x05F0fwkkKNohi3x@CtkS2KR0zjf2iImL9V1@LUkr0IQFPpjAUl5sVtLJNC@MGiFyKr93QJmtJN1gkhf/qH9X@IouywlNBLBIqCb6ao9heQqAxuMoB8LmxIW7eJu8YqzUfvIYCJ63QPVbiSvsiJ16RdVun04ZvrB3KiZ2hUlcln9CQhTIpqoOovNwV668Iw07ZdUfZDScten1a70dHJ@JxU0/XnnpGQF8NTA04RR4u17CoAMQZIjcB8NzlRgu8pk/JHOT@WJEi83a43IBeRL8P4P60x1lbacQyhXBKRsbOA2o5JtyaagU4m@vhInHfUh/IIy5FyagAUniVpVKKiopgVQhSAUDYnPmKxIJMPOyIESsZSzJlQXPJrXaA4Q8sTs6LhMGf9YlDidFvBnb4UOA0lPlTAtjKOavzVa1hEX/6XUGayz4VjEE1vOVDxHiaS4tfBgBcRBOYkzsx122T/7iilROD4TR4G8uOTobNsQYL5BKrx9r4qyLBwBxZ6KFuI0N4Az2ioH1LZAwyIT7JI0MOqXkl9LCKr1lVbJMckY3eBtkyfHBngJ18YAoMpiV0kRuj5RL69G0//@5lMSEvMTq@LUGUcsHOHS4b9LSNIgR4pvd1RsCyKYvOksUejRqHYwpcoMGN@DCyWd/TqmXG0v@r6gF/3Mt5jhtoa98zYp215RH54qFYy/3xiKL8bKofod3YwssRMzkUv4/O2SLnes35j/qVja6@slh8xIPRhTUuK14ffTdDKha2hudQ72GLg2BVHkiULxRSjpo8nLgCYf7YPh3LyAqfPx1iZVMV5xTeRswS0vZ6Pr6fUnjgH3vD9h1EtYbcTuQuDiQzJsjO5xyFOCZy36MhpdfzN/fo8bz2@Jl@Xq9oc/3b4bBD962pxaAbG@0D@bMtOJFGmkHWv6@t074pyAIQ8@ZNm3n74nJsBx5ph1wkLfjKZXL5/XqDE97YNKJTD/JaOX1G9Uj8YJiP7QIAlpVhIL09l4lek1EKVaG4rj1@/etoWINKJFyBnf5m/U2@9/lOb@5xy41dYTT9PibDnl1mXZdkwLDrgNWA5V0A3AScUILMLJBkAAi2/fDyY42T3TIErtmzCZ8JjNMcLASDkPrAVonr19v4yGN4rJyZjJCWXexrNxR01GxBVwpIpHI7iBYoh0JkRhFk5QVe@LFq5c2LiPYr7eXRFL4FoDFLhYzm@UVAMP/VwUSAUQdSZReVGBS8D2OJyPAyjdjF1WBbURkmzQ79k9ps/tkYIF/n/3mPb3YPAgRk7@EJkjBeJgMzFFx@7wm7MoJHDLyux9PhJAV8NBM1FC2WTG/lck@Py85SHhuvPX/9a/zp94r/sMyXdf263x7TtOTwH/E0T3xzEpNE03T1EtPSynsAtQO1QPOPL2Dx@FWr37PcdlbICX3EtwrmlUFspb2nbRJQPorPCnkQzlOamiN6DFRdWgBCtJCtEWFdimRcqJKmRYGVN2TpNmXcoWkAryF4E0UNA2tgdbLrin5erIrUJsjgUc2bew22RBazULNn8D@E42vs@Fsmkm4utql3vO4nMf9njgS6mu9bgtr@oMieM5uxuSOVvVODAZ7/q1n1pRirTM1G3OtYnFFmnIbls5n1bVs2uuHcNGKmH@r3CBkORtf6bOZqqDq3Dt@FuqueNvFcOgzWl0QmMSOL3Rs9nw1uaJWKzUNRFSYDfxMTQGxFbRn6B53GW6wnHY1GBjDuCZ2gTgJ6bd7KoanV@TJzId49KcbsKixIbOms9UXsMHnhEyh5537gcip839PAvgKISMMJKhui5NItV1wDSi90dH0YAK0tCqbvOJSkfFA5cZeTemMjx/tjTcCVAhEs/w/Hg2nV/R3sQIaZjtDcfep3IpZWHRHU4SGTpFh273QHMpEkGHvpRjJmxHavwkaoqcGkPWVPveekWhRJMwV2zNBkVMOiQ6IOkHw3jb@oEeQd08wAbLI/GOBLXAhMCmhgu1BHKqvUUV2ZsXqfBeSu1djJxM6s4jK1u5evL0xIFpLxZxHRqikKVySJ21OAZOJAByGQl8a3U@V346Rf7bFqk4hrNPTCG/AgUIAmYSA2GkR74Ihm1GA9Kkk0GoL6ch2fMjz4X3ODdCcHLdwBoljpReGlOsdQV8cY5WpXT15LEOHXmDpzPQ9HAC6N0yiBCGnt2@Uog11bPq6nx@NzhhENxj8hSuSlpjsbOl2XQy/WjlM/5RnWVuWSXSNXRz67Ti8LiNnq6uUh@FG82dOVhH0sxUqLBxhRmdAPEs788aFwpYpSum/L3OqjkcGkh@78LsJyzi/79suKpx27iuaFTJlYNTnHYXVmS3ZWYTS8gl9EnmPA1vupQuND6yach4HuTBDU0Sqo6ohUB6CvydEcOi8a1tkq1juuagHWBsQiEAXXNS/4aPMb2d85CcT/oI5jqdTKOvPaOWugyyfEm0lYggunUJHGLQJjnIBya1jazBoMZePLelGSBStoKVzMHWHerBEBVRe/O323u6tvTvFGBspaaHq2mgIrh2Rsw4CgxJRPvJEg@lprNXgyer1x1mBDkXKrryoHry5gIVWB6@6MoI9xpmYzzkvxwrwukwSkYO0DjYD7P0Xh9lrOTjn5pf4n4EdoT/tHh8gX8pqIRJ8AQXpoAwRsaw564EeUDHxynGkKFLLvW93BOgpeCWbUMEjfnMjjOkJKCBAch3GXApdBbJgWlsE5M8JpOaDz/KBFZCj0GH2@oouEQ2jk2iCV9Ph6nN9JEMND2sVoPn3gtfRNO2@Vt03/RG024pS4AWZ12/XFwNL68Hk7rQLrGAXmJ7vH2oZ9wHF6AbbC6aAhbENLjW6PDqxCYyArM5TSW4kXIl3bErUW8fOY99HyDJJxMtnqY3ff/GT6CZyIktG4SAYmj9XyoZNSBrz2WiNDyZmj3XfHLqn44j2zPfsyGkzUvSf/zK6EC4c3AU7Zbwm6@NfhS/dbtKaYxtcMSX5FVmqy1YYoUAIrsLzi3ptDRvxiaXS5guYFEonJp7gJaVpU9QDEgD@NkU9AqhYWwe@YhlhLfdntTFz@/Asl69ocpD5Rxh4/h1Ckc2OYfSlCgXug8k6qv5mI5PNMBnKQEbAnf2Ztgtq2lHgWdNzSoJGhcxvS7jXmtE@@YEagm1dd3Zg7wY7DxOewt6Qa9Pt@/GTIGQwf4FW1GlRA8o@Zh5hjdAzyaxZMwz/RGYbn8C0kwlVD@@umXCXwjo8WNJ83zKd6YosDyijIzH42Yk3euP6gMBVe55Jr@cE8KPQFztsgBDMcFQO/KQ8Sm/iIsPnXaRIfCCQ0ydZb6espZDbHkxDZDb@UoI4W73uywdntqfrqH88DCgRSl@sUxjxjFt2nx/ZaFW6VJmdoJX/EK968ZwH3hIR1riR@EX3W/C4K7fw3mAagQeQXireigvhC5Fzm@I0vB6MRyU8tZ4pAkkeVN520WdEscLvdLox1tUZrOiZgeCe9uMY8rm9Aoe/DPWazOZTAYnkiL6@kBYYsAXMMfFcYTomh704sXf8xecCFSFLpaRp1977CBG7lf4U@OxM84i/kLBiOvtsONHP1s/9InDv@UN4cslnSBD4Y@i2fl177slFCXRE5LyTLAEge0rgIZF@K9Iffjrp@9uQP5wR@NDGcOVwBS6zzckmxAHgaBPJHI8KUfgtF9y6bxxAJr0FlPbGdP6WO3fcBoJ4ERRiFhyJTsMm/@F6yWBidfQO6/NZfSwROz9jCad9L5q4sOCu4nfGhbhezdHl9B3Ap4PCFiYY4LeNQ5bl3rAdXz6pUo2RIbpodrkg0YzfskvRjq1HDn51bS5U7JWyn1qxxEw4FXnq0HPqYhFDsWzKWJtwFOFhCc0ahI7Rwv8TRc1n16/ok/0Nv4mSESrEQvCdd6ongOslmo@v3rTkj4ah6N4bWW0hXJJlAalUgTOngqkhSYs@5cpr5oTNw@cN38NPn/@34QGO@7zeGWy1cvZ/wE" rel="nofollow noreferrer">Here's a link anyway</a> with my full source code, with all the mess of experimental ideas in comments.</p>
<p><strong>This is a complete program</strong>.  It prints the first 1000 digits of Fib(10**9) followed by some extra digits (the last few of which are wrong)  followed by some garbage bytes (not including a newline).  Most of the garbage is non-ASCII, so you may want to pipe through <code>cat -v</code>.  It doesn't break my terminal emulator (KDE <code>konsole</code>), though.  The &quot;garbage bytes&quot; are storing Fib(999999999).  I already had <code>-1024</code> in a register, so it was cheaper to print 1024 bytes than the proper size.</p>
<p>I'm counting just the machine-code (size of the text segment of my static executable), not the fluff that makes it an ELF executable.  (<a href="http://www.muppetlabs.com/%7Ebreadbox/software/tiny/teensy.html" rel="nofollow noreferrer">Very tiny ELF executables are possible</a>, but I didn't want to bother with that).  It turned out to be shorter to use stack memory instead of BSS, so I can kind of justify not counting anything else in the binary since I don't depend on any metadata.  (Producing a stripped static binary the normal way makes a 340 byte ELF executable.)</p>
<p>You could make a function out of this code that you could call from C.  It would cost a few bytes to save/restore the stack pointer (maybe in an MMX register) and some other overhead, but also save bytes by returning with the string in memory, instead of making a <code>write(1,buf,len)</code> system call.  I think golfing in machine code should earn me some slack here, since nobody else has even posted an answer in any language without native extended-precision, but I think a function version of this should still be under 120 bytes without re-golfing the whole thing.</p>
<hr />
<h3>Algorithm:</h3>
<p><strong>brute force <code>a+=b; swap(a,b)</code>, truncating as needed to keep only the leading &gt;= 1017 decimal digits.  It runs in 1min13s on my computer (or 322.47 billion clock cycles +- 0.05%)</strong> (and could be a few % faster with a few extra bytes of code-size, or down to 62s with much larger code size from loop unrolling.  No clever math, just doing the same work with less overhead).  It's based on <a href="https://codegolf.stackexchange.com/questions/133618/extreme-fibonacci/133678#133678">@AndersKaseorg's Python implementation</a>, which runs in 12min35s on my computer (4.4GHz Skylake i7-6700k).  Neither version has any L1D cache misses, so my DDR4-2666 doesn't matter.</p>
<p>Unlike Python, <strong>I store the extended-precision numbers in a format that makes truncating decimal digits free</strong>.  I store groups of 9 decimal digits per 32-bit integer, so a pointer offset discards the low 9 digits.  This is effectively base 1-billion, which is a power of 10.  (It's pure coincidence that this challenge needs the 1-billionth Fibonacci number, but it does save me a couple bytes vs. two separate constants.)</p>
<p>Following <a href="https://gmplib.org/" rel="nofollow noreferrer">GMP</a> terminology, each 32-bit chunk of an extended-precision number is called a &quot;limb&quot;.  Carry-out while adding has to be generated manually with a compare against 1e9, but is then used normally as an input to the usual <a href="http://felixcloutier.com/x86/ADC.html" rel="nofollow noreferrer"><code>ADC</code> instruction</a> for the next limb.  (I also have to manually wrap to the <code>[0..999999999]</code> range, rather than at 2^32 ~= 4.295e9.  I do this branchlessly with <code>lea</code> + <code>cmov</code>, using the carry-out result from the compare.)</p>
<p>When the last limb produces non-zero carry-out, the next two iterations of the outer loop read from 1 limb higher than normal, but still write to the same place.  This is like doing a <code>memcpy(a, a+4, 114*4)</code> to right-shift by 1 limb, but done as part of the next two addition loops.  This happens every ~18 iterations.</p>
<hr />
<p>Hacks for size-saving and performance:</p>
<ul>
<li><p>The usual stuff like <code>lea  ebx, [eax-4 + 1]</code> instead of <code>mov ebx, 1</code>, when I know that <code>eax=4</code>.  And using <code>loop</code> in places where <a href="https://stackoverflow.com/questions/35742570/why-is-the-loop-instruction-slow-couldnt-intel-have-implemented-it-efficiently"><code>LOOP</code>'s slowness</a> only has a tiny impact.</p>
</li>
<li><p>Truncate by 1 limb for free by offsetting the pointers that we read from, while still writing to the start of the buffer in the <code>adc</code> inner loop.  We read from <code>[edi+edx]</code>, and write to <code>[edi]</code>.  So we can get <code>edx=0</code> or <code>4</code> to get a read-write offset for the destination.  We need to do this for 2 successive iterations, first offsetting both, then only offsetting the dst.  We detect the 2nd case by looking at <code>esp&amp;4</code> before resetting the pointers to the front of the buffers (using <code>&amp;= -1024</code>, because the buffers are aligned).  See comments in the code.</p>
</li>
<li><p>The Linux process-startup environment (for a static executable) zeros most registers, and stack-memory below <code>esp</code>/<code>rsp</code> is zeroed.  My program takes advantage of this.  In a callable-function version of this (where unallocated stack could be dirty), I could use BSS for zeroed memory (at the cost of maybe 4 more bytes to set up pointers).  Zeroing <code>edx</code> would take 2 bytes.  The x86-64 System V ABI doesn't guarantee either of these, but Linux's implementation of it does zero (to avoid information-leaks out of the kernel).  In a dynamically-linked process, <code>/lib/ld.so</code> runs before <code>_start</code>, and does leave registers non-zero (and probably garbage in memory below the stack pointer).</p>
</li>
<li><p>I keep <code>-1024</code> in <code>ebx</code> for use outside of loops.  Use <code>bl</code> as a counter for inner loops, ending in zero (which is the low byte of <code>-1024</code>, thus restoring the constant for use outside the loop).  Intel Haswell and later don't have partial-register merging penalties for low8 registers <a href="https://stackoverflow.com/questions/45660139/how-exactly-do-partial-registers-on-haswell-skylake-perform-writing-al-seems-to">(and in fact don't even rename them separately)</a>, so there's a dependency on the full register, like on AMD (not a problem here).  This would be horrible on Nehalem and earlier, though, which have partial-register stalls when merging.  There are other places where I write partial regs and then read the full reg without <a href="https://stackoverflow.com/questions/33666617/what-is-the-best-way-to-set-a-register-to-zero-in-x86-assembly-xor-mov-or-and"><code>xor</code>-zeroing</a> or a <code>movzx</code>, usually because I know that some previous code zeroed the upper bytes, and again that's fine on AMD and Intel SnB-family, but slow on Intel pre-Sandybridge.</p>
<p>I use <code>1024</code> as the number of bytes to write to stdout (<code>sub edx, ebx</code>), so my program prints some garbage bytes after the Fibonacci digits, because <code>mov edx, 1000</code> costs more bytes.</p>
</li>
<li><p>(not used) <code>adc ebx,ebx</code> with EBX=0 to get EBX=CF, saving 1 byte vs. <code>setc bl</code>.</p>
</li>
<li><p><code>dec</code>/<code>jnz</code> inside an <code>adc</code> loop preserves CF without causing a partial-flag stall when <code>adc</code> reads flags on Intel Sandybridge and later.  <a href="https://stackoverflow.com/questions/32084204/problems-with-adc-sbb-and-inc-dec-in-tight-loops-on-some-cpus/32087095#32087095">It's bad on earlier CPUs</a>, but AFAIK free on Skylake.  Or at worst, an extra uop.</p>
</li>
<li><p>Use memory below <code>esp</code> as a giant <a href="https://stackoverflow.com/tags/red-zone/info">red-zone</a>.  Since this is a complete Linux program, I know I didn't install any signal handlers, and that nothing else will asynchronously clobber user-space stack memory.  This may not be the case on other OSes.</p>
</li>
<li><p>Take advantage of <a href="https://stackoverflow.com/questions/36631576/what-is-the-stack-engine-in-the-sandybridge-microarchitecture">the stack-engine</a> to save uop issue bandwidth by using <code>pop eax</code> (1 uop + occasional stack-sync uop) instead of <code>lodsd</code> (2 uops on Haswell/Skylake, 3 on IvB and earlier according to <a href="http://agner.org/optimize/" rel="nofollow noreferrer">Agner Fog's instruction tables</a>)).  IIRC, this dropped the run-time from about 83 seconds to 73.  I could probably get the same speed from using a <code>mov</code> with an indexed addressing mode, like <code>mov eax, [edi+ebp]</code> where <code>ebp</code> holds the offset between src and dst buffers.  (It would make the code outside the inner loop more complex, having to negate the offset register as part of swapping src and dst for Fibonacci iterations.)  See the &quot;performance&quot; section below for more.</p>
</li>
<li><p>start the sequence by giving the first iteration a carry-in (one byte <a href="http://felixcloutier.com/x86/STC.html" rel="nofollow noreferrer"><code>stc</code></a>), instead of storing a <code>1</code> in memory anywhere.  Lots of other problem-specific stuff documented in comments.</p>
</li>
</ul>
<p><strong>NASM listing (machine-code + source)</strong>, generated with <code>nasm -felf32 fibonacci-1G.asm -l /dev/stdout | cut -b -28,$((28+12))- | sed 's/^/ /'</code>.  (Then I hand-removed some blocks of commented stuff, so the line numbering has gaps.)  To strip out the leading columns so you can feed it into YASM or NASM, use <code>cut -b 27- &lt;fibonacci-1G.lst &gt; fibonacci-1G.asm</code>.</p>
<pre><code>  1          machine      global _start
  2          code         _start:
  3 address

  4 00000000 B900CA9A3B       mov    ecx, 1000000000       ; Fib(ecx) loop counter
  5                       ;    lea    ebp, [ecx-1]          ;  base-1 in the base(pointer) register ;)
  6 00000005 89CD             mov    ebp, ecx    ; not wrapping on limb==1000000000 doesn't change the result.
  7                                              ; It's either self-correcting after the next add, or shifted out the bottom faster than Fib() grows.
  8                       
 42                       
 43                       ;    mov    esp, buf1
 44                       
 45                       ;    mov    esi, buf1   ; ungolfed: static buffers instead of the stack
 46                       ;    mov    edi, buf2

 47 00000007 BB00FCFFFF       mov    ebx, -1024
 48 0000000C 21DC             and    esp, ebx    ; alignment necessary for convenient pointer-reset
 49                       ;    sar    ebx, 1
 50 0000000E 01DC             add    esp, ebx     ; lea    edi, [esp + ebx].  Can't skip this: ASLR or large environment can put ESP near the bottom of a 1024-byte block to start with
 51 00000010 8D3C1C           lea    edi, [esp + ebx*1]
 52                           ;xchg   esp, edi   ; This is slightly faster.  IDK why.
 53                       
 54                           ; It's ok for EDI to be below ESP by multiple 4k pages.  On Linux, IIRC the main stack automatically extends up to ulimit -s, even if you haven't adjusted ESP.  (Earlier I used -4096 instead of -1024)
 55                           ; After an even number of swaps, EDI will be pointing to the lower-addressed buffer
 56                           ; This allows a small buffer size without having the string step on the number.
 57
 58                       ; registers that are zero at process startup, which we depend on:
 59                       ;    xor   edx, edx
 60                       ;;  we also depend on memory far below initial ESP being zeroed.
 61
 62 00000013 F9               stc    ; starting conditions: both buffers zeroed, but carry-in = 1
 63                       ; starting Fib(0,1)-&gt;0,1,1,2,3 vs. Fib(1,0)-&gt;1,0,1,1,2 starting &quot;backwards&quot; puts us 1 count behind
 66
 67                       ;;; register usage:
 68                       ;;; eax, esi: scratch for the adc inner loop, and outer loop
 69                       ;;; ebx: -1024.  Low byte is used as the inner-loop limb counter (ending at zero, restoring the low byte of -1024)
 70                       ;;; ecx: outer-loop Fibonacci iteration counter
 71                       ;;; edx: dst read-write offset (for &quot;right shifting&quot; to discard the least-significant limb)
 72                       ;;; edi: dst pointer
 73                       ;;; esp: src pointer
 74                       ;;; ebp: base-1 = 999999999.  Actually still happens to work with ebp=1000000000.
 75
 76                       .fibonacci:
 77                       limbcount equ 114             ; 112 = 1006 decimal digits / 9 digits per limb.  Not enough for 1000 correct digits, but 114 is.
 78                                                     ; 113 would be enough, but we depend on limbcount being even to avoid a sub
 79 00000014 B372             mov    bl, limbcount
 80                       .digits_add:
 81                           ;lodsd                       ; Skylake: 2 uops.  Or  pop rax  with rsp instead of rsi
 82                       ;    mov    eax, [esp]
 83                       ;    lea    esp, [esp+4]   ; adjust ESP without affecting CF.  Alternative, load relative to edi and negate an offset?  Or add esp,4 after adc before cmp
 84 00000016 58               pop    eax
 85 00000017 130417           adc    eax, [edi + edx*1]    ; read from a potentially-offset location (but still store to the front)
 86                        ;; jz .out   ;; Nope, a zero digit in the result doesn't mean the end!  (Although it might in base 10**9 for this problem)
 87
 88                       %if 0   ;; slower version
                          ;; could be even smaller (and 5.3x slower) with a branch on CF: 25% mispredict rate
 89                           mov  esi, eax
 90                           sub  eax, ebp  ; 1000000000 ; sets CF opposite what we need for next iteration
 91                           cmovc eax, esi
 92                           cmc                         ; 1 extra cycle of latency for the loop-carried dependency. 38,075Mc for 100M iters (with stosd).
 93                                                       ; not much worse: the 2c version bottlenecks on the front-end bottleneck
 94                       %else   ;; faster version
 95 0000001A 8DB0003665C4     lea    esi, [eax - 1000000000]
 96 00000020 39C5             cmp    ebp, eax                ; sets CF when (base-1) &lt; eax.  i.e. when eax&gt;=base
 97 00000022 0F42C6           cmovc  eax, esi                ; eax %= base, keeping it in the [0..base) range
 98                       %endif
 99                       
100                       %if 1
101 00000025 AB               stosd                          ; Skylake: 3 uops.  Like add + non-micro-fused store.  32,909Mcycles for 100M iters (with lea/cmp, not sub/cmc)
102                       %else
103                         mov    [edi], eax                ; 31,954Mcycles for 100M iters: faster than STOSD
104                         lea   edi, [edi+4]               ; Replacing this with ADD EDI,4 before the CMP is much slower: 35,083Mcycles for 100M iters
105                       %endif
106                       
107 00000026 FECB             dec    bl                      ; preserves CF.  The resulting partial-flag merge on ADC would be slow on pre-SnB CPUs
108 00000028 75EC             jnz .digits_add
109                           ; bl=0, ebx=-1024
110                           ; esi has its high bit set opposite to CF
111                       .end_innerloop:
112                           ;; after a non-zero carry-out (CF=1): right-shift both buffers by 1 limb, over the course of the next two iterations
113                           ;; next iteration with r8 = 1 and rsi+=4:  read offset from both, write normal.  ends with CF=0
114                           ;; following iter with r8 = 1 and rsi+=0:  read offset from dest, write normal.  ends with CF=0
115                           ;; following iter with r8 = 0 and rsi+=0:  i.e. back to normal, until next carry-out (possible a few iters later)
116                       
117                           ;; rdi = bufX + 4*limbcount
118                           ;; rsi = bufY + 4*limbcount + 4*carry_last_time
119                       
120                       ;    setc   [rdi]
123 0000002A 0F92C2           setc   dl
124 0000002D 8917             mov    [edi], edx ; store the carry-out into an extra limb beyond limbcount
125 0000002F C1E202           shl    edx, 2

139                           ; keep -1024 in ebx.  Using bl for the limb counter leaves bl zero here, so it's back to -1024 (or -2048 or whatever)
142 00000032 89E0             mov    eax, esp   ; test/setnz could work, but only saves a byte if we can somehow avoid the  or dl,al
143 00000034 2404             and    al, 4      ; only works if limbcount is even, otherwise we'd need to subtract limbcount first.

148 00000036 87FC             xchg   edi, esp   ; Fibonacci: dst and src swap
149 00000038 21DC             and    esp, ebx  ; -1024  ; revert to start of buffer, regardless of offset
150 0000003A 21DF             and    edi, ebx  ; -1024
151                       
152 0000003C 01D4             add    esp, edx             ; read offset in src

155                           ;; after adjusting src, so this only affects read-offset in the dst, not src.
156 0000003E 08C2             or    dl, al              ; also set r8d if we had a source offset last time, to handle the 2nd buffer
157                           ;; clears CF for next iter

165 00000040 E2D2             loop .fibonacci  ; Maybe 0.01% slower than dec/jnz overall

169                       to_string:

175                       stringdigits equ 9*limbcount  ; + 18
176                       ;;; edi and esp are pointing to the start of buffers, esp to the one most recently written
177                       ;;;  edi = esp +/- 2048, which is far enough away even in the worst case where they're growing towards each other
178                       ;;;  update: only 1024 apart, so this only works for even iteration-counts, to prevent overlap

180                           ; ecx = 0 from the end of the fib loop
181                           ;and   ebp, 10     ; works because the low byte of 999999999 is 0xff
182 00000042 8D690A           lea    ebp, [ecx+10]         ;mov    ebp, 10
183 00000045 B172             mov    cl, (stringdigits+8)/9
184                       .toascii:  ; slow but only used once, so we don't need a multiplicative inverse to speed up div by 10
185                           ;add   eax, [rsi]    ; eax has the carry from last limb:  0..3  (base 4 * 10**9)
186 00000047 58               pop    eax                  ; lodsd
187 00000048 B309             mov    bl, 9
188                       .toascii_digit:
189 0000004A 99               cdq                         ; edx=0 because eax can't have the high bit set
190 0000004B F7F5             div    ebp                  ; edx=remainder = low digit = 0..9.  eax/=10

197 0000004D 80C230           add    dl, '0'
198                                              ; stosb  ; clobber [rdi], then  inc rdi
199 00000050 4F               dec    edi         ; store digits in MSD-first printing order, working backwards from the end of the string
200 00000051 8817             mov    [edi], dl
201                       
202 00000053 FECB             dec    bl
203 00000055 75F3             jnz  .toascii_digit
204                       
205 00000057 E2EE             loop .toascii
206                       
207                           ; Upper bytes of eax=0 here.  Also AL I think, but that isn't useful
208                           ; ebx = -1024
209 00000059 29DA             sub  edx, ebx   ; edx = 1024 + 0..9 (leading digit).  +0 in the Fib(10**9) case
210                       
211 0000005B B004             mov   al, 4                 ; SYS_write
212 0000005D 8D58FD           lea  ebx, [eax-4 + 1]       ; fd=1
213                           ;mov  ecx, edi               ; buf
214 00000060 8D4F01           lea  ecx, [edi+1]           ; Hard-code for Fib(10**9), which has one leading zero in the highest limb.
215                       ;    shr  edx, 1 ;    for use with edx=2048
216                       ;    mov  edx, 100
217                       ;    mov byte  [ecx+edx-1], 0xa;'\n'  ; count+=1 for newline
218 00000063 CD80             int  0x80                   ; write(1, buf+1, 1024)
219                       
220 00000065 89D8             mov  eax, ebx ; SYS_exit=1
221 00000067 CD80             int  0x80     ; exit(ebx=1)
222                       
  # next byte is 0x69, so size = 0x69 = 105 bytes
</code></pre>
<p>There's probably room to golf some more bytes out of this, but I've already spent at least 12 hours on this over 2 days.  <strong>I don't want to sacrifice speed, even though it's way more than fast enough and there is room to make it smaller in ways that cost speed</strong>.  Part of my reason for posting is showing how fast I can make a brute-force asm version.  If anyone wants to really go for minimum-size but maybe 10x slower (e.g. 1 digit per byte), feel free to copy this as a starting point.</p>
<p>The resulting executable (from <code>yasm -felf32 -Worphan-labels -gdwarf2 fibonacci-1G.asm &amp;&amp; ld -melf_i386 -o fibonacci-1G fibonacci-1G.o</code>) is 340B (stripped):</p>
<pre><code>size fibonacci-1G
 text    data     bss     dec     hex filename
  105       0       0     105      69 fibonacci-1G
</code></pre>
<h3>Performance</h3>
<p>The inner <code>adc</code> loop is 10 fused-domain uops on Skylake (+1 stack-sync uop every ~128 bytes), so it can issue at one per ~2.5 cycles on Skylake with optimal front-end throughput (ignoring the stack-sync uops).  The critical-path latency is 2 cycles, for the <code>adc</code>-&gt;<code>cmp</code> -&gt; next iteration's <code>adc</code> loop-carried dependency chain, so the bottleneck should be the front-end issue limit of ~2.5 cycles per iteration.</p>
<p><code>adc eax, [edi + edx]</code> is 2 unfused-domain uops for the execution ports: load + ALU.  It micro-fuses in the decoders (1 fused-domain uop), but <a href="https://stackoverflow.com/questions/26046634/micro-fusion-and-addressing-modes/31027695#31027695">un-laminates in the issue stage to 2 fused-domain uops, because of the indexed addressing mode, even on Haswell/Skylake</a>.  I thought it would stay micro-fused, like <code>add eax, [edi + edx]</code> does, but maybe keeping indexed addressing modes micro-fused doesn't work for uops that already have 3 inputs (flags, memory, and destination).  When I wrote it, I was thinking it wouldn't have a performance downside, but I was wrong.  This way of handling of truncation slows down the inner loop every time, whether <code>edx</code> is 0 or 4.</p>
<p>It would be faster to handle the read-write offset for the dst by offsetting <code>edi</code> and using <code>edx</code> to adjust the store.  So <code>adc eax, [edi]</code> / ... / <code>mov [edi+edx], eax</code> / <code>lea edi, [edi+4]</code> instead of <code>stosd</code>.  Haswell and later can keep an indexed store micro-fused.  (Sandybridge/IvB would unlaminate it, too.)</p>
<p><strong>On Intel Haswell and earlier, <code>adc</code> and <code>cmovc</code> are 2 uops each, with 2c latency</strong>.  (<code>adc eax, [edi+edx]</code> is still un-laminated on Haswell, and issues as 3 fused-domain uops).  Broadwell and later allow 3-input uops for more than just FMA (Haswell), making <code>adc</code> and <code>cmovc</code> (and a couple other things) single-uop instructions, like they have been on AMD for a long time.  (This is one reason AMD has done well in extended-precision GMP benchmarks for a long time.)  Anyway, Haswell's inner loop should be 12 uops (+1 stack-sync uop occasionally), with a front-end bottleneck of ~3c per iter best-case, ignoring stack-sync uops.</p>
<p><strong>Using <code>pop</code> without a balancing <code>push</code> inside a loop means the loop can't run from the LSD (loop stream detector)</strong>, and has to be re-read from the uop cache into the IDQ every time.  If anything, it's a good thing on Skylake, since <a href="https://stackoverflow.com/questions/39311872/is-performance-reduced-when-executing-loops-whose-uop-count-is-not-a-multiple-of">a 9 or 10 uop loop doesn't quite issue optimally at 4 uops every cycle</a>.  This is probably part of why replacing <code>lodsd</code> with <code>pop</code> helped so much.  (The LSD can't lock down the uops because that wouldn't leave room to insert a <a href="https://stackoverflow.com/questions/36631576/what-is-the-stack-engine-in-the-sandybridge-microarchitecture">stack-sync uop</a>.)  (BTW, a microcode update disables the LSD entirely on Skylake and Skylake-X to fix an erratum.  I measured the above before getting that update.)</p>
<p>I profiled it on Haswell, and found that it runs in 381.31 billion clock cycles (regardless of CPU frequency, since it only uses L1D cache, not memory).  Front-end issue throughput was 3.72 fused-domain uops per clock, vs. 3.70 for Skylake.  (But of course instructions per cycle was down to 2.42 from 2.87, because <code>adc</code> and <code>cmov</code> are 2 uops on Haswell.)</p>
<p><code>push</code> to replace <code>stosd</code> probably wouldn't help as much, because <code>adc [esp + edx]</code> would trigger a stack-sync uop every time.  And would cost a byte for <code>std</code> so <code>lodsd</code> goes the other direction.  (<code>mov [edi], eax</code> / <code>lea edi, [edi+4]</code> to replace <code>stosd</code> is a win, going from 32,909Mcycles for 100M iters to 31,954Mcycles for 100M iters.  It seems that <code>stosd</code> decodes as 3 uops, with the store-address/store-data uops not micro-fused, so <code>push</code> + stack-sync uops might still be faster than <code>stosd</code>)</p>
<p><strong>The actual performance of ~322.47 billion cycles for 1G iterations of 114 limbs works out to 2.824 cycles per iteration of the inner loop</strong>, for the fast 105B version on Skylake.  (See <code>ocperf.py</code> output below).  That's slower than I predicted from static analysis, but I was ignoring the overhead of the outer-loop and any stack-sync uops.</p>
<p>Perf counters for <code>branches</code> and <code>branch-misses</code> show that the inner loop mispredicts once per outer loop (on the last iteration, when it's not taken).  That also accounts for part of the extra time.</p>
<hr />
<p><strong>I could save code-size by making the inner-most loop have 3-cycle latency for the critical path, using <code>mov esi,eax</code>/<code>sub eax,ebp</code>/<code>cmovc eax, esi </code>/<code>cmc</code></strong> (2+2+3+1 = 8B) instead of <code>lea  esi, [eax - 1000000000]</code>/<code>cmp ebp,eax</code>/<code>cmovc</code> (6+2+3 = 11B).  The <code>cmov</code>/<code>stosd</code> is off the critical path.  (The increment-edi uop of <code>stosd</code> can run separately from the store, so each iteration forks off a short dependency chain.)  It used to save another 1B by changing the ebp init instruction from <code>lea ebp, [ecx-1]</code> to <code>mov ebp,eax</code>, but I discovered that having the wrong <code>ebp</code> didn't change the result.  This would let a limb be exactly == 1000000000 instead of wrapping and producing a carry, but this error propagates slower than we Fib() grows, so this happens not to change the leading 1k digits of the final result.  Also, I think that error can correct itself when we're just adding, since there's room in a limb to hold it without overflow.  Even 1G + 1G doesn't overflow a 32-bit integer, so it will eventually percolate upwards or be truncated away.</p>
<p>The 3c latency version is 1 extra uop, so the front-end can issue it at one per 2.75c cycles on Skylake, only slightly faster than the back-end can run it.  (On Haswell, it will be 13 uops total since it still uses <code>adc</code> and <code>cmov</code>, and bottleneck on the front-end at 3.25c per iter).</p>
<p>In practice it runs a factor of 1.18 slower on Skylake (3.34 cycles per limb), rather than 3/2.5 = 1.2 that I predicted for replacing the front-end bottleneck with the latency bottleneck from just looking at the inner loop without stack-sync uops.  Since the stack-sync uops only hurt the fast version (bottlenecked on the front-end instead of latency), it doesn't take much to explain it.  e.g. 3/2.54 = 1.18.</p>
<p>Another factor is that the 3c latency version may detect the mispredict on leaving the inner loop while the critical path is still executing (because the front-end can get ahead of the back-end, letting out-of-order execution run the loop-counter uops), so the effective mispredict penalty is lower.  Losing those front-end cycles lets the back-end catch up.</p>
<p>If it wasn't for that, we could maybe speed up the 3c <code>cmc</code> version by using a branch in the outer loop instead of branchless handling of the carry_out -&gt; edx and esp offsets.  Branch-prediction + speculative execution for a control dependency instead of a data dependency could let the next iteration start running the <code>adc</code> loop while uops from the previous inner loop were still in flight.  In the branchless version, the load addresses in the inner loop have a data dependency on CF from the last <code>adc</code> of the last limb.</p>
<p>The 2c latency inner-loop version bottlenecks on the front-end, so the back-end pretty much keeps up.  If the outer-loop code was high-latency, the front-end could get ahead issuing uops from the next iteration of the inner loop.  (But in this case the outer-loop stuff has plenty of <a href="https://en.wikipedia.org/wiki/Instruction-level_parallelism" rel="nofollow noreferrer">ILP</a> and no high-latency stuff, so the back-end doesn't have much catching up to do when it starts chewing through uops in the out-of-order scheduler as their inputs become ready).</p>
<pre><code>### Output from a profiled run
$ asm-link -m32 fibonacci-1G.asm &amp;&amp; (size fibonacci-1G; echo disas fibonacci-1G) &amp;&amp; ocperf.py stat -etask-clock,context-switches:u,cpu-migrations:u,page-faults:u,cycles,instructions,uops_issued.any,uops_executed.thread,uops_executed.stall_cycles -r4  ./fibonacci-1G
+ yasm -felf32 -Worphan-labels -gdwarf2 fibonacci-1G.asm
+ ld -melf_i386 -o fibonacci-1G fibonacci-1G.o
   text    data     bss     dec     hex filename
    106       0       0     106      6a fibonacci-1G
disas fibonacci-1G
perf stat -etask-clock,context-switches:u,cpu-migrations:u,page-faults:u,cycles,instructions,cpu/event=0xe,umask=0x1,name=uops_issued_any/,cpu/event=0xb1,umask=0x1,name=uops_executed_thread/,cpu/event=0xb1,umask=0x1,inv=1,cmask=1,name=uops_executed_stall_cycles/ -r4 ./fibonacci-1G
79523178745546834678293851961971481892555421852343989134530399373432466861825193700509996261365567793324820357232224512262917144562756482594995306121113012554998796395160534597890187005674399468448430345998024199240437534019501148301072342650378414269803983873607842842319964573407827842007677609077777031831857446565362535115028517159633510239906992325954713226703655064824359665868860486271597169163514487885274274355081139091679639073803982428480339801102763705442642850327443647811984518254621305295296333398134831057713701281118511282471363114142083189838025269079177870948022177508596851163638833748474280367371478820799566888075091583722494514375193201625820020005307983098872612570282019075093705542329311070849768547158335856239104506794491200115647629256491445095319046849844170025120865040207790125013561778741996050855583171909053951344689194433130268248133632341904943755992625530254665288381226394336004838495350706477119867692795685487968552076848977417717843758594964253843558791057997424878788358402439890396,�X\�;3�I;ro~.�'��R!q��%��X'B ��      8w��▒Ǫ�
 ... repeated 3 more times, for the 3 more runs we're averaging over
  Note the trailing garbage after the trailing digits.

 Performance counter stats for './fibonacci-1G' (4 runs):

      73438.538349      task-clock:u (msec)       #    1.000 CPUs utilized            ( +-  0.05% )
                 0      context-switches:u        #    0.000 K/sec                  
                 0      cpu-migrations:u          #    0.000 K/sec                  
                 2      page-faults:u             #    0.000 K/sec                    ( +- 11.55% )
   322,467,902,120      cycles:u                  #    4.391 GHz                      ( +-  0.05% )
   924,000,029,608      instructions:u            #    2.87  insn per cycle           ( +-  0.00% )
 1,191,553,612,474      uops_issued_any:u         # 16225.181 M/sec                   ( +-  0.00% )
 1,173,953,974,712      uops_executed_thread:u    # 15985.530 M/sec                   ( +-  0.00% )
     6,011,337,533      uops_executed_stall_cycles:u #   81.855 M/sec                    ( +-  1.27% )

      73.436831004 seconds time elapsed                                          ( +-  0.05% )
</code></pre>
<p><code>( +- x %)</code> is the standard-deviation over the 4 runs for that count.  Interesting that it runs such a round number of instructions.  That 924 billion is <em>not</em> a coincidence.  I guess that the outer loop runs a total of 924 instructions.</p>
<p><code>uops_issued</code> is a fused-domain count (relevant for front-end issue bandwidth), while <code>uops_executed</code> is an unfused-domain count (number of uops sent to execution ports).  Micro-fusion packs 2 unfused-domain uops into one fused-domain uop, but <a href="https://stackoverflow.com/questions/44169342/can-x86s-mov-really-be-free-why-cant-i-reproduce-this-at-all">mov-elimination</a> means that some fused-domain uops don't need any execution ports.  See the linked question for more about counting uops and fused vs. unfused domain.  (Also see <a href="http://agner.org/optimize/" rel="nofollow noreferrer">Agner Fog's instruction tables and uarch guide</a>, and other useful links in the SO <a href="https://stackoverflow.com/tags/x86/info">x86 tag wiki</a>).</p>
<p>From another run measuring different things: L1D cache misses are totally insignificant, as expected for reading/writing the same two 456B buffers.  The inner-loop branch mispredicts once per outer loop (when it's not-taken to leave the loop).  (The total time is higher because the computer wasn't totally idle.  Probably the other logical core was active some of the time, and more time was spent in interrupts (since the user-space-measured frequency was farther below 4.400GHz).  Or multiple cores were active more of the time, lowering the max turbo.  I didn't track <code>cpu_clk_unhalted.one_thread_active</code> to see if HT competition was an issue.)</p>
<pre><code>     ### Another run of the same 105/106B &quot;main&quot; version to check other perf counters
      74510.119941      task-clock:u (msec)       #    1.000 CPUs utilized          
                 0      context-switches:u        #    0.000 K/sec                  
                 0      cpu-migrations:u          #    0.000 K/sec                  
                 2      page-faults:u             #    0.000 K/sec                  
   324,455,912,026      cycles:u                  #    4.355 GHz                    
   924,000,036,632      instructions:u            #    2.85  insn per cycle         
   228,005,015,542      L1-dcache-loads:u         # 3069.535 M/sec
           277,081      L1-dcache-load-misses:u   #    0.00% of all L1-dcache hits
                 0      ld_blocks_partial_address_alias:u #    0.000 K/sec                  
   115,000,030,234      branches:u                # 1543.415 M/sec                  
     1,000,017,804      branch-misses:u           #    0.87% of all branches        
</code></pre>
<p>My code may well run in fewer cycles on Ryzen, which can issue 5 uops per cycle (or 6 when some of them are 2-uop instructions, like AVX 256b stuff on Ryzen).  I'm not sure what its front-end would do with <code>stosd</code>, which is 3 uops on Ryzen (same as Intel).  I think the other instructions in the inner loop are the same latency as Skylake and all single-uop.  (Including <code>adc eax, [edi+edx]</code>, which is an advantage over Skylake).</p>
<hr />
<p><strong>This could probably be significantly smaller, but maybe 9x slower, if I stored the numbers as 1 decimal digit per byte</strong>.  Generating carry-out with <code>cmp</code> and adjusting with <code>cmov</code> would work the same, but do 1/9th the work.  2 decimal digits per byte (base-100, not 4-bit BCD with a <a href="http://felixcloutier.com/x86/DAA.html" rel="nofollow noreferrer">slow <code>DAA</code></a>) would also work, and <code>div r8</code> / <code>add ax, 0x3030</code> turns a 0-99 byte into two ASCII digits in printing order.  But 1 digit per byte doesn't need <code>div</code> at all, just looping and adding 0x30.  If I store the bytes in printing order, that would make the 2nd loop really simple.</p>
<hr />
<p>Using 18 or 19 decimal digits per 64-bit integer (in 64-bit mode) would make it run about twice as fast, but cost significant code-size for all the REX prefixes, and for 64-bit constants.  32-bit limbs in 64-bit mode prevents using <code>pop eax</code> instead of <code>lodsd</code>.  I could still avoid REX prefixes by using <code>esp</code> as a non-pointer scratch register (swapping the usage of <code>esi</code> and <code>esp</code>), instead of using <code>r8d</code> as an 8th register.</p>
<p>If making a callable-function version, converting to 64-bit and using <code>r8d</code> may be cheaper than saving/restoring <code>rsp</code>.  64-bit also can't use the one-byte <code>dec r32</code> encoding (since it's a REX prefix).  But mostly I ended up using <code>dec bl</code> which is 2 bytes.  (Because I have a constant in the upper bytes of <code>ebx</code>, and only use it outside of inner loops, which works because the low byte of the constant is <code>0x00</code>.)</p>
<hr />
<h3>High-performance version</h3>
<p>For maximum performance (not code-golf), you'd want to unroll the inner loop so it runs at most 22 iterations, which is a short enough taken/not-taken pattern for the branch-predictors to do well.  In my experiments, <code>mov cl, 22</code> before a <code>.inner: dec cl/jnz .inner</code> loop has very few mispredicts (like 0.05%, far less than one per full run of the inner loop), but <code>mov cl,23</code> mispredicts from 0.35 to 0.6 times per inner loop.  <code>46</code> is particularly bad, mispredicting ~1.28 times per inner-loop (128M times for 100M outer-loop iterations).  <code>114</code> mispredicted exactly once per inner loop, same as I found as part of the Fibonacci loop.</p>
<p>I got curious and tried it, unrolling the inner loop by 6 with a <code>%rep 6</code> (because that divides 114 evenly).  That mostly eliminated branch-misses.  I made <code>edx</code> negative and used it as an offset for <code>mov</code> stores, so <code>adc eax,[edi]</code> could stay micro-fused.  (And so I could avoid <code>stosd</code>).  I pulled the <code>lea</code> to update <code>edi</code> out of the <code>%rep</code> block, so it only does one pointer-update per 6 stores.</p>
<p>I also got rid of all the partial-register stuff in the outer loop, although I don't think that was significant.  It may have helped slightly to have CF at end of the outer loop not dependent on the final ADC, so some of the inner-loop uops can get started.  The outer-loop code could probably be optimized a bit more, since <code>neg edx</code> was the last thing I did, after replacing <code>xchg</code> with just 2 <code>mov</code> instructions (since I already still had 1), and re-arranging the dep chains along with dropping the 8-bit register stuff.</p>
<p>This is the NASM source of just the Fibonacci loop.  It's a drop-in replacement for that section of the original version.</p>
<pre><code>  ;;;; Main loop, optimized for performance, not code-size
%assign unrollfac 6
    mov    bl, limbcount/unrollfac  ; and at the end of the outer loop
    align 32
.fibonacci:
limbcount equ 114             ; 112 = 1006 decimal digits / 9 digits per limb.  Not enough for 1000 correct digits, but 114 is.
                              ; 113 would be enough, but we depend on limbcount being even to avoid a sub
;    align 8
.digits_add:

%assign i 0
%rep unrollfac
    ;lodsd                       ; Skylake: 2 uops.  Or  pop rax  with rsp instead of rsi
;    mov    eax, [esp]
;    lea    esp, [esp+4]   ; adjust ESP without affecting CF.  Alternative, load relative to edi and negate an offset?  Or add esp,4 after adc before cmp
    pop    eax
    adc    eax, [edi+i*4]    ; read from a potentially-offset location (but still store to the front)
 ;; jz .out   ;; Nope, a zero digit in the result doesn't mean the end!  (Although it might in base 10**9 for this problem)

    lea    esi, [eax - 1000000000]
    cmp    ebp, eax                ; sets CF when (base-1) &lt; eax.  i.e. when eax&gt;=base
    cmovc  eax, esi                ; eax %= base, keeping it in the [0..base) range
%if 0
    stosd
%else
  mov    [edi+i*4+edx], eax
%endif
%assign i i+1
%endrep
  lea   edi, [edi+4*unrollfac]

    dec    bl                      ; preserves CF.  The resulting partial-flag merge on ADC would be slow on pre-SnB CPUs
    jnz .digits_add
    ; bl=0, ebx=-1024
    ; esi has its high bit set opposite to CF
.end_innerloop:
    ;; after a non-zero carry-out (CF=1): right-shift both buffers by 1 limb, over the course of the next two iterations
    ;; next iteration with r8 = 1 and rsi+=4:  read offset from both, write normal.  ends with CF=0
    ;; following iter with r8 = 1 and rsi+=0:  read offset from dest, write normal.  ends with CF=0
    ;; following iter with r8 = 0 and rsi+=0:  i.e. back to normal, until next carry-out (possible a few iters later)

    ;; rdi = bufX + 4*limbcount
    ;; rsi = bufY + 4*limbcount + 4*carry_last_time

;    setc   [rdi]
;    mov    dl, dh               ; edx=0.  2c latency on SKL, but DH has been ready for a long time
;    adc    edx,edx    ; edx = CF.  1B shorter than setc dl, but requires edx=0 to start
    setc   al
    movzx  edx, al
    mov    [edi], edx ; store the carry-out into an extra limb beyond limbcount
    shl    edx, 2
    ;; Branching to handle the truncation would break the data-dependency (of pointers) on carry-out from this iteration
    ;;  and let the next iteration start, but we bottleneck on the front-end (9 uops)
    ;;  not the loop-carried dependency of the inner loop (2 cycles for adc-&gt;cmp -&gt; flag input of adc next iter)
    ;; Since the pattern isn't perfectly regular, branch mispredicts would hurt us

    ; keep -1024 in ebx.  Using bl for the limb counter leaves bl zero here, so it's back to -1024 (or -2048 or whatever)
    mov    eax, esp
    and    esp, 4               ; only works if limbcount is even, otherwise we'd need to subtract limbcount first.

    and    edi, ebx  ; -1024    ; revert to start of buffer, regardless of offset
    add    edi, edx             ; read offset in next iter's src
    ;; maybe   or edi,edx / and edi, 4 | -1024?  Still 2 uops for the same work
    ;;  setc dil?

    ;; after adjusting src, so this only affects read-offset in the dst, not src.
    or     edx, esp             ; also set r8d if we had a source offset last time, to handle the 2nd buffer
    mov    esp, edi

;    xchg   edi, esp   ; Fibonacci: dst and src swap
    and    eax, ebx  ; -1024

    ;; mov    edi, eax
    ;; add    edi, edx
    lea    edi, [eax+edx]
    neg    edx            ; negated read-write offset used with store instead of load, so adc can micro-fuse

    mov    bl, limbcount/unrollfac
    ;; Last instruction must leave CF clear for next iter
;    loop .fibonacci  ; Maybe 0.01% slower than dec/jnz overall
;    dec ecx
    sub ecx, 1                  ; clear any flag dependencies.  No faster than dec, at least when CF doesn't depend on edx
    jnz .fibonacci
</code></pre>
<p>Performance:</p>
<pre><code> Performance counter stats for './fibonacci-1G-performance' (3 runs):

      62280.632258      task-clock (msec)         #    1.000 CPUs utilized            ( +-  0.07% )
                 0      context-switches:u        #    0.000 K/sec                  
                 0      cpu-migrations:u          #    0.000 K/sec                  
                 3      page-faults:u             #    0.000 K/sec                    ( +- 12.50% )
   273,146,159,432      cycles                    #    4.386 GHz                      ( +-  0.07% )
   757,088,570,818      instructions              #    2.77  insn per cycle           ( +-  0.00% )
   740,135,435,806      uops_issued_any           # 11883.878 M/sec                   ( +-  0.00% )
   966,140,990,513      uops_executed_thread      # 15512.704 M/sec                   ( +-  0.00% )
    75,953,944,528      resource_stalls_any       # 1219.544 M/sec                    ( +-  0.23% )
       741,572,966      idq_uops_not_delivered_core #   11.907 M/sec                    ( +- 54.22% )

      62.279833889 seconds time elapsed                                          ( +-  0.07% )
</code></pre>
<p>That's for the same Fib(1G), producing the same output in 62.3 seconds instead of 73 seconds.  (273.146G cycles, vs. 322.467G.  Since everything hits in L1 cache, core clock cycles is really all we need to look at.)</p>
<p>Note the much lower total <code>uops_issued</code> count, well below the <code>uops_executed</code> count.  That means many of them were micro-fused: 1 uop in the fused domain (issue/ROB), but 2 uops in the unfused domain (scheduler / execution units)).  And that few were eliminated in the issue/rename stage (like <code>mov</code> register copying, or <code>xor</code>-zeroing, which need to issue but don't need an execution unit).  Eliminated uops would unbalance the count the other way.</p>
<p><code>branch-misses</code> is down to ~400k, from 1G, so unrolling worked.  <code>resource_stalls.any</code> is significant now, which means the front-end is not the bottleneck anymore: instead the back-end is getting behind and limiting the front-end.  <code>idq_uops_not_delivered.core</code> only counts cycles where the front-end didn't deliver uops, but the back-end <em>wasn't</em> stalled.  That's nice and low, indicating few front-end bottlenecks.</p>
<hr />
<p>Fun fact: the python version spends more than half its time dividing by 10 rather than adding.  (Replacing the <code>a/=10</code> with <code>a&gt;&gt;=64</code> speeds it up by more than a factor of 2, but changes the result because binary truncation != decimal truncation.)</p>
<p>My asm version is of course optimized specifically for this problem-size, with the loop iteration-counts hard coded.  Even shifting an arbitrary-precision number will copy it, but my version can just read from an offset for the next two iterations to skip even that.</p>
<p><strong>I profiled the python version</strong> (64-bit python2.7 on Arch Linux):</p>
<pre><code>ocperf.py stat -etask-clock,context-switches:u,cpu-migrations:u,page-faults:u,cycles,instructions,uops_issued.any,uops_executed.thread,arith.divider_active,branches,branch-misses,L1-dcache-loads,L1-dcache-load-misses python2.7 ./fibonacci-1G.anders-brute-force.py
795231787455468346782938519619714818925554218523439891345303993734324668618251937005099962613655677933248203572322245122629171445627564825949953061211130125549987963951605345978901870056743994684484303459980241992404375340195011483010723426503784142698039838736078428423199645734078278420076776090777770318318574465653625351150285171596335102399069923259547132267036550648243596658688604862715971691635144878852742743550811390916796390738039824284803398011027637054426428503274436478119845182546213052952963333981348310577137012811185112824713631141420831898380252690791778709480221775085968511636388337484742803673714788207995668880750915837224945143751932016258200200053079830988726125702820190750937055423293110708497685471583358562391045067944912001156476292564914450953190468498441700251208650402077901250135617787419960508555831719090539513446891944331302682481336323419049437559926255302546652883812263943360048384953507064771198676927956854879685520768489774177178437585949642538435587910579974100118580

 Performance counter stats for 'python2.7 ./fibonacci-1G.anders-brute-force.py':

     755380.697069      task-clock:u (msec)       #    1.000 CPUs utilized          
                 0      context-switches:u        #    0.000 K/sec                  
                 0      cpu-migrations:u          #    0.000 K/sec                  
               793      page-faults:u             #    0.001 K/sec                  
 3,314,554,673,632      cycles:u                  #    4.388 GHz                      (55.56%)
 4,850,161,993,949      instructions:u            #    1.46  insn per cycle           (66.67%)
 6,741,894,323,711      uops_issued_any:u         # 8925.161 M/sec                    (66.67%)
 7,052,005,073,018      uops_executed_thread:u    # 9335.697 M/sec                    (66.67%)
   425,094,740,110      arith_divider_active:u    #  562.756 M/sec                    (66.67%)
   807,102,521,665      branches:u                # 1068.471 M/sec                    (66.67%)
     4,460,765,466      branch-misses:u           #    0.55% of all branches          (44.44%)
 1,317,454,116,902      L1-dcache-loads:u         # 1744.093 M/sec                    (44.44%)
        36,822,513      L1-dcache-load-misses:u   #    0.00% of all L1-dcache hits    (44.44%)

     755.355560032 seconds time elapsed
</code></pre>
<p>Numbers in (parens) are how much of the time that perf counter was being sampled.  When looking at more counters than the HW supports, perf rotates between different counters and extrapolates.  That's totally fine for a long run of the same task.</p>
<p>If I ran <code>perf</code> after setting sysctl <code>kernel.perf_event_paranoid = 0</code> (or running <code>perf</code> as root), it would measure <code>4.400GHz</code>.  <code>cycles:u</code> doesn't count time spent in interrupts (or system calls), only user-space cycles.  My desktop was almost totally idle, but this is typical.</p>
</div>
<div id="pu1" class="pu"><h1>Pyth, 12 bytes</h1>
<pre><code>A(Z1)V^T9HA(H+HG
</code></pre>
<p>yuhhhh</p>
</div>
<div id="pu2" class="pu"><p><code>gawk</code> with <code>GMP</code> bigint library -</p>
<h2><em>0.012</em> secs</h2>
<p>total for first <code>1000</code> digits of <code>Fib - 1,000,000,000</code></p>
<pre><code>    # gawk profile, created Tue Nov  7 08:13:56 2023

    # Rule(s)

     1  {
     1      print fib_ultraP(($++_) ^ $++_)

    }

function fib_ultraP(__, ______, _, ___, ____,
                    _____, _______, ________, _________) {

    if ((____ = _ = ! (_______ = length(______ = __)))      || 
        (__ *= _++ &lt; (__ = int(__))) &lt;= (___ = ++_ + _) + _ || 
               (____ = (___ + ___) ^ ___ ^ _ &lt;= __))
        return \
            (____ &lt; _ ? __ + (__ &lt; ++___ ? -(_ &lt;= __) : \
            (___ &lt; __) * _) * _______ : &quot;_ERR_FIBP_OUTPUT_GE_32BITS_&quot;)
        
    ______ += _____ = substr(___ = __ = --_, _______ = --_, _)
    
    while ((___ += ___) &lt;= ______)_______++

     _________ = _ 
      ________ = (((_+=(_+=_^=_&lt;_)*_*_)^_)^_)^_ 
           ___ = ______ + substr(_____, 
       (______ = ___) == (_ = _________))
     _________ = ________ * ________

    do {         ____ = (__ + __) * _
                  __ *= __
            if ((___ += ___) &lt; ______ || ___ &lt; (___ -= ______)) {
                    __ -= _ *= -_
                    _ += ____
            } else {
                    _ = __ + _*_
                    __ += ____
            }
            if (____ = _________&lt;_)
                do                  __ = (__ - __%________) /________
                while (_________ &lt; ( _ =  (_ - _%________) /________))
            
    } while (_______--)
    
    return \
    substr((_________ = ________ = ___++) \
        ? (__ - __ % (_ = (_ += (_ = ___) * _ * _) ^ (\
            int(log(__) / log(_)) - (___ = _ * _ * _)))) / _ \
        : (_ - _ % (__ = (__ += (__ = ++___) * __ * __) ^ (\
            int(log(_) / log(__)) - (___ = __ * __ * __)))) / __, !!___, ___)
}

 out9: 2.52KiB 0:00:00 [24.7MiB/s] [24.7MiB/s] [  &lt;=&gt; ]

( echo 10 9 | gawk -p- -Mbe ; )  0.00s user 0.00s system 74% cpu 0.012 total
</code></pre>
<hr />
<pre><code>7952317874554683467829385196197148189255542185234398913453039937
3432466861825193700509996261365567793324820357232224512262917144
5627564825949953061211130125549987963951605345978901870056743994
6844843034599802419924043753401950114830107234265037841426980398
3873607842842319964573407827842007677609077777031831857446565362
5351150285171596335102399069923259547132267036550648243596658688
6048627159716916351448788527427435508113909167963907380398242848
0339801102763705442642850327443647811984518254621305295296333398
1348310577137012811185112824713631141420831898380252690791778709
4802217750859685116363883374847428036737147882079956688807509158
3722494514375193201625820020005307983098872612570282019075093705
5423293110708497685471583358562391045067944912001156476292564914
4509531904684984417002512086504020779012501356177874199605085558
3171909053951344689194433130268248133632341904943755992625530254
6652883812263943360048384953507064771198676927956854879685520768
4897741771784375859496425384355879105799
</code></pre>
</div>
<div id="pu3" class="pu"><h1>x86 .COM, <s>62</s> <s>61</s> <s>56</s> 55 bytes</h1>
<pre><code>    org $100
    mov di, $8000
    mov ds, di
    mov es, di
    mov cx, di
    xor ax, ax
    xor si, si
    rep stosw
    mov ecx, 1000000000
    ;mov ecx, 6
    stc

lop:    
    mov bx, ds
adding:
    lodsb
    adc al, [di]
    aaa
    stosb
    dec bx
    jnz adding
    
    jnc nocy
    and [si], byte 0
    lodsb
    inc ax
    stosb
nocy:   
    loopd lop
    
    std
    mov si, di
    dec si
delta:
    lodsb
    add al, '0'
    int $29
    loop delta

    ret
</code></pre>
<p>Should run more than one day, keep 32768 digits of precision of both number</p>
<p>Ran for 165979.100 seconds, result <a href="https://tio.run/##PN1rjiTNbqThLUVExnU5kgABggD9EKD1S3xer08zZ@b06a7KjIs7nTSaGf/1v//lP/7r3//n3/7zf//3@a7jtz/vc17Xeb@/837e4/u91/7d@/fs57u/33HNPx77Oz96/r7323/n9dt@3/d75i@O877fe3@P@Z3fs23X9n3ffdz7776u@3m@3/zIe2y/6zl@x3Gc134c9/Ht8@nndR/Pdc8/X9/5ffOp937s@/7b9vnS@Zv3@e7fd@33ds2Xfs/7bfvrS@5nLuWbSz7P95yLmX/83u049@87zu38PfPz2/5d2z73MB@3zZefx31tv@c99/nT/PTcy@99fvc2f3XMf37zy/d5zU3N3xz@ctueuYN7@7bH/9l@@zv/uZ7zvK/7@t3H9bv2/dqOeWDPfs21zv/ejrmy7Z4L@c1tXeezz23f88vzPDb3ev7mJ@/rvd/33s53HsH86rPf337Pr88NPe886@ec//zmV955Ht82/9iz2J5fV3645PnT/HHucTueex7@dc6dzT/Mbc4vn7/7fOa3v3ee@Tzi8z7myV7HvHNX6lfnVc4dbdczF/nMQ5@fnvvb5w@H675/8/jmaW1u29Pajmse3fbM25tFs31zBccxf56rnHvym/f80vv@fs@8l7mFucL7@c2rnns65ve@a1bL@27zG99@vb9nFsQ3l@eNzfo5tn0e6vzkNv@Zdz6/MW/ve99nFtRxPfOk50e@ft39zrr8zXqdB/Bs7/k9cwlz3fO5v@udtfX79u2ch/585/nt85HzsuaZzOo75r8/C3CbVTcfaCXNczr3WVyzkueOZ62ccxWzgC3Gbf9ddzdtic1ynBu@5nvmtc@7mSudRfqbZTG7Y77r95sHfdzzEOcJzwOZtec7Pnc5C3WW/zX35o3c1zFP67UlfvPPsxhnRfzmWmZlzT3NxT5e4P3c3zGb1f3ZE/Plc2lzze/3zBXND81ynQ9/7aNZAdd8xKyd@VEv9/vmTVhWs3@O/Z7t9Mwj@/bW@@6n5mtnBV2z7p5ZrNe5/975wvnAWQGzVWbZf/NyJwjMC5/ftmDmRcwvzz3N85z9d3rDs8DmAc5CmnV9PL9tluE7F2fRbBNi5mYvvz/7a3bvhJy5jHlUs0Tm9679@s1u8xSswXkjxzyiuZXZfr/9OucRnnOZsyifb7boXMr3m200nz@/Ps9xHoBHMMFnYos1Ort9nt3c1fz2PPFtvmCft315Ouv9zg3OJc9znl@b/z2fP//js5vPY9bVfM988CzId6LhZll/84gmtj0izLHNP@8i1mzd@f57rnf@65sreyYOzS9YdvMAnl8PZHbgLIHZorMC7tnuc@8TG@eK7n1izvz3b9bORMcJE8cs@vueBT63OKvn2ecbZ7GKtM8E4dkDu6/28j3zCSiz4Gd5iWS74PbO65zwPe9w9tQ8jPm0WaBzK@8hCM0yahXPe7s@j/7nsU7sbytMbNjmUUwQsIn8r3f2ysTD@ee50Ll5e352@LzBiWH7z9P5fmtfzNaatyIgzefMO5tjYBboZ6s@s@vmFvZ7n308MW32wKzBeWoTiLb5pHkF86nvfPW5TZw/ZlHPO7P65z5FhFlE871@5hIx5pYm8MyjnOcglr627YRZVzw3YIHN5rQ@inSzH6@5tmPfXN762P2dheWtzjOYNzt/@Lb3ba947bME5n2KIHvRueNgFvb80OySU8CfUObInH0yD/lqEbfK5i4nmmwTa2cv@dSJbXMGzgo4H385MeY6jll0E@4nUM0PPU6705KY7TinwiwqgWGu6nLyzEOcxfMJyredMs9pE4vf2VHvbLHfnBg/L/3@5shy6s7vHA6sR6SaVTJv5nZ4TjAWIc@5SqthYt7p91@rdi6uHeXEmpUwR32H/ASb@ahZYN/2KyL8LOhtLnD@ff5rPmv@7hAIRMR7As3spbmg9@8zf86oXYifhzZnhAPv3jpk54JPx/szb2se0T4BcK7rlHP46LmGufL54XlUs5QkI/MxztX5vHkIgoj0ZTb97LR9TtSJHnNz817mkLz6oSLmtnkl4tw89dlNj@xgwuz87t7B/X6z3OfYm2g5YXNe2iuSTRCaxTiBa35RyJrD3wnyK4V5t9OCnBuaPTjvZd7y/NIE8DmoClIT6s9tdudsslk9P5vsm200K3jOydc5MpmEM3BOgPb1fMNR@HvOvmU2@Sy2uVIRaR6pEDLx3uua1fpz4P08muNzrM0TtZCkPpNxCEJztbMgxQln8VzW3O7ZRpvYMpHocpg6tZ8yn2/uUfo1a0aS9TpU99n/7@z42TEOuUsssqwmjs@bnVXm9C8rmFU/2@sQqY61ZOYZi/0Ct3RottQnq3DyTbibQ/lzRpSmTMibL739H7nD@@7uZ672sgnm377Ol6ME6ydzu6R78@HzROd6rc3jtRznq@Y8nt00vzN74JVSzWL15/na08d8EqF5vu2ruS3/MO9vLvTnAJinMa91wtc5X/aJOK3UWRli6KQY89vzKA7hcU7BS/j/Oa7mEk6Hx2zTuZRZDJ9fmF02FzDPcbbQpF5zVgou8342ifTdm5pTRQ46j2S@dyWD8xTncc7ze2YB3Y7nU3STIj1i3Xd5fLPnN5F2PnpShrn8R1Y@F/v6vPbJPOiJ7L@5sOd20k8qZnnONezW0dzl/MM5MXo@cXbQRJ8JBvMI5pFJPeaZOjzm1iaEzBLxQ7biJgeRr8@ynpubhGC@ZV6X0@j2aifQz41KLDa3OufLvG2R@fB47by5@Mvp/siUJ2zMhvt5ELOc5DDOpVm1czZMvrTbLBK/iXizMoScuYdZgHNpds28pFkL8/JUNIc8@JH6WEWfvz4FgMtpPInIrMgpcOYhzufP/2sZCvmzpGYdzx47yp4PtzMXNa98fnkCrXR41tIcLhMdTxc6PzeJ4@zoubA5xhxsc15JOiV8h7U/kU5ckw9JSGXP8/Ys0AkJ7RI1yjzaeTa3tHXezASP@cFZafM4pGuzZ2ZnzNY/y9LnrWzyjXlWn4A/l/I5R@Yj3rm6zyO/ZCduft686kPa5@CfvTgn5neWZN8qNum5pGz25TxnCeBczWz0TWL4ODQvAeHnLJuzUrrpLDj2ktB5w/Mc53yV8VoZ8/Q3VdQ8Bo9iDpGJ4vPoeznzU/MCJjOYu3S56qTbUTlvQZD9yaBmp/yklxNENlHKmbOrJzZHwzvLSia2i0YTEefUmLPpVcndLdCJp4q6XUXq3SpJCxmP3T@J3JSLDgGn9@d4nssRhWYJvTK@@fJHcj@3NtHzlQLNA7bU5jB2ono9XxWKe1Id713tbIl5IMfTklsf5PS8HSk/x@os5HlUU6bth42kXDs73Uuk34K1QC2gbUrZzXqYbPx81skwF/UoM/zfDoTZ5xMSDvt9lu2sRaHPnc9KVdrPtppPnc@cJGBueR7a5uif1zbP6fI@HL@z2bbOqPmKQ746e3Ji1@bxfuKlvGUC2SFSbUeR4ufkPFRls6bnlueR3fK/WUOzJHc51eUg/@2FRsmbGl@SNtXxDh44yupO@e68Ap/pKavzJlGY9aPOfOy3yVtE0WqqOVI9byFTMjCLdDaG8mwe5qfKfIQSR@3E7Dkt50MmKCt1HIoBAPPfkxJPPiDv2NUns93mce8VML92gXp7ssoJV3ML80GubJboJ/bMd8@emFJksoivPN7KEwlf5a5YPBvkVBX//IJgZh2dAIAgg3lCs5Ympswb3JWOayXM83sck5tqY17JZcNNJjgbDDwjJ3ol7VN7fz26uav5aQeG3HyudZbVJaZNvJjrl9UDPua5ymrmf8hg5icn75sd77a34qf0eDbWZMOTjZyKUgnerId5wddd@nEIGvMd9uDkHvL8q8rmW/88C9VhrYqcVWcFzq3OI5hFOlvh67C@yxUu@Y0TTDr9WRVleZe6d9bUBdt5ZIYiySWIvm/1mM9ZS2/C61xcCMCstcmpZ5FIpeaPytJ5vWq3@bbZVWLD7CQlxeUlvL3tSVGfI1Rivs4ZM69a8SG9eqWjFmYYwOFQ3sXzuSApktNgcpTTLb9rOdgwhxPSsvhVZFpl85uzh@YD5nof9zcLR9J8OyTflSCesvRPojMr3nnicJ@HLHI4PWcPyiGm0DwdJj5C4jFHg5Tnp5qbQCoyHbav5yotnyB4@c751CovSwB8BhmTPXlR84oV2A7/uV3xD0rkCcxHyJtntb2Oir2FXzgXumePbO5yFrylPi9/W8emGmiKlHVdEpZ5GnN/k7XNgeKD/aKbmggzL0JJcZzhHl7Q7uB9JLyfYDS3P/t0iuJZ8oetNav0kyPB0WZpiRCPYuSwLuZVTvqrwJrAP6t78pVNtXxWc8zzfR3NsywVG4f0HoKmwpQR2d6n2gmosJXO3qL/7P3LiQ/kdFTOOlG8zoN6S6smVk/aMMtngxSGJxSXbNettXOvFelpys6t/0NuPc9slrRMXkoze1lw3hTU8wJtoXkkRWH5ijp1vnpK2Unld@fCvOjJqWZLhu3cnuohXs6dADqEp4nLc1Dd1eC7iDKHyORMW4tuouBjvzmj5nTcKnXmNU2sfBR2AROqoiCoiRuewS4FngdiQ9h3au55H6e8e5N1XBalD5ikb1bR5EvyaeCa9zOJ7VwQwAAEOntV7q4qnXc5gVH5fEPpDnt8zjBQnBR33qCTZm4D3gVQCCo9gvkOCNg8lHmECs@5yQcG9FpLExXnw506T4XyLV89LCY41762xjy42foqcrlMGbOabvIvdYbAPuuvdBNCeMqjQLOeMoTb58w/zOpzYB998iE5ORSfljncdg4HwKagMxlJlWDXPfv5UoX/QBHQURFHhTkfKDN0iOyzNIBys3lCXeYTvmDBD9w13xpe49hyqm8gxwkml2XuxBQM55nO6laezvKdZSnfgGAI5PPNsxnmVJ0jeXOKfIXxT3hQI74BL5Mnvaq@s4s5Wr8On3lgNvWsCWVHh91cBNwDhDFpr8x/kqQNTDFxcs7hrQqpqPI6my45sQxMMgEPn4d@dVJs0iUV10JtrzJTEUPmp7qdC9ygWJMwPiuLseGuwqbCxyEAP3eYXiLT5VLn1c2eCcgCLp3e7OQDEy5OlztPZwvxla9eoKa7unpuYX7GoQjSblNYjxL2ycimtJhXpWqYFzG51a4n8XjulyP6nNMRDhSU@@mMXFAWa2izWCdhnZNiAmEZxzyKSe5vWccrLE1kcPaAyn6Qqwuw@EgYbrjaA2@SyNlHh1bHRMwPJDWhxVu1YKUTs9p0XGwxtc5uUZTCz@N0js6K2doYECwLVJ4kHM5NTSV7Qu4eicksoV0PCGSiIp9D3@4u7Msj5nSZrfZ44rMwP9nQ3AMYYQr7n7ppV//MilRLyKwnK5l/l1tsMnFQ6a4a7@Q@q4Enxu3S2Pl1y2dO@60rmexz6k/3@3OOTYajhJ@ILFGpvzDRA647qf7E2RdsCDU@7bKn8@8tMdMImDcroYV3zVMC8Cj9Zk/Nkt3dIywNQjLJ0gZYlCo6SD8NiEeYnyBqqYhtP9nr/bUBH5HzV70ozwKUqS5VmnOREr6jFVELaV6iRhGQQQCc39ZFkFM/Ep9NB2mHdzlkoAX3FmBQc2o2WY0Ypc/11rSDMM@LAe0dEp8nhE5lOp93t54mZmhFnEr7n0bDfJ8Szzno0HD2e88ynZ88flfmT4agEzeXdq7mkEcxF7NKE00L56ODZBfPfx00IIR55MDU@X9CJfDaAj@VtcCR6sMejiA5T9dR9YOUy7oABLMobQxdI@2GWR8adbOZn/C/eThe36y/q/QdwqiIOor4m8Cq/NYQU4PucPMPxjfnExjH0pqi7YYTiXV6Eh42AE5mZk@o/CCE8yW7SAQK1Xp56@zMuXWDCLVzJKyH5EQHcF7MrFntT4fCrEWpZI2XKY3n@UE8bqXknDSqfe/wksptXtOsZmDRru6cS7898vn3R@ajFt/bSr/War2f2cXAP29YCjCRRP9gQUqixqkvK/w7pYSGOVjnWdYtBfJsCw@aFQHL/FaUUMXpUNV0eUO4zpokekxfj@3SvDtA37snKecGEWpizvOepQlvm/cu6fL/izVWrTRO2aHxqxmtHrJYdkFnChaV8ym71JDcnerQCLBT@2Ui2aM7Uovg8l4eX/jpEqolehtXnyuSONTnQcKF5y5VP6ekR9Ihi3@KKBPVhGShMlT7E80@QW/ekhbhXIOu2Kxfd7J3xrzCvNaejaaD7YybU0sNc@tAXoB6MNX8lIr4/MJtocQnzEEMl3oX6TvNNo3H@TrYs9emX/QJLH5zl4Ocgu6p7p47OMux3do81x0@fG7tO8jTo9mxKbjmYIIrXyqUSW/mbZ4ilgJrfjzgaR6XNtwndZ0jfMLvPCa9zDru8tEQcO9xtsdTmJ748TgM5mT0xwkLWAWXKv/SZRAEBcnJ0haae2gWgjjUnb9ZivO9XoBa4VqwRdnpA5Z5VK3KgllOl86KhdHD1ETyrG8A/6trO4feTxk4y0MDEmZ9FyRnr1y2DUxSqejAmFU@ue9t@ziRYAqKuXmCl57fXO0cEH5RHVr7QMv8fKrSnWB9iqThFSsnf1bJqdMch5dW@KVJPg8YMA5H2iC4b8n1ZP/nr/iignvhsLsy1sENzPgKmj/o/@xaRQeQz1VhUQhcTjFtsdlbE4pnOz5qOAc8KGYSxiBCj@90FOpN2cAhepZS8N0P5hwxws463yBU0LLu4yzu1TS/RVSI/uxteVAFTB14MKG@4SEvmkX2AoFl7bcteEF2HFYPoMxC9@gC4earJ0ubL1KMyCFuQNQuQJcEWpcQMt10kXySm3kn5y802fEPtJwg90EMQ93nhV8KlquUeBbhhHunK0JDve0fbFcWcVzv4izMcQaamHR2A0q9FuyOOKHu1ymDQYM5Ps3ZrScJM9aOVyFACOqYzt9sAWmHctW6epAzXs2zD@w@BxS0fG4GptH2gksJnlbiHCKH7V402iHR7SHZin7CHYoBkv80lJEj6jgq0qbwmScFiZGtfIqF8NvZSJIIsFlH3RwGJ4rID8kCuixL/dpnZzyGHumxRbHRqofXxV6QyADYb@XHo345BF5Zyfz4o@OMxWCp1VnzQ3b3LR@cQIpxYGU9d2WS4t25uF@6blqVh3TjrDvhhSm6d0ncoTIWce9ApKsuSNtLnxTpRnLp8Dj0oO8On2gYYpEtfgZgzG6Z2uWpzj81MpEFIG5zW8gveha/XmOt501KpufhyAacajjaLBJ66ddCft46f7uD4dHmmhf506o7I04AGWbDgLtkTp/0S/qmXS35OI@YJPb@ZCOCmke2h0m8iknNhihUjuVTJnQLrHNQOBoAXLtj9qmvvnLG@BJiqAudQ0wqpZbp2OlUOfxRqa@Ztlu0gMbQc/l87J7fVXC4YAdSG8vZ@TqRS3lzhGorib51sw6jW@T53khm6DTYQhpsepKX5GYu7ATeTXyzkLYab3gwSqj5KeAD4hTW0Ry8Ageu2C3/unsRZ3nVB8dDSbIeIbM/nYxv4YFf2Ya9Ks/@wVEWlWluSsfaeaa74EpCguC6wqm8BUVC0WshQjGuaqdHtS4Nn8g1rzAKTWc1Co2FjMHkyi/rTu36LMB/Vt/7W6/3rXX4BtrcJU7Ca40M/XzgymxFmPiu9f2d1VhXrdNLCxnoOoFpHvmGpzerMyARdgADPMFcNZcmaup5qqzBlbOI3zc2GI7JdgfRHPJGHfNa16KghwSX0bFUyiq5bymmLHjKqMpn6c@j8jiDZX/S@MOaUAtD1oXAUz6kXNbRe8t9Du0XMLj9@1PEntBvgVDedaoY6jwqRhHg4vt9qtMgdJm@zODCN5iw/kWZ0MDB14NjWozirUsuW7GYHAUbgh1yo3xNt2SKkkdvBZ/NNe9xARy7GkwT6GfhzvVoompLvjLy2s74OK/L8rIV42LbpSeiMnyr1OeRzBb2wYgyV2wyiaY78F3iKn7CJ7RP2DmUtruOPFqNpykv7tBQkEyabHt8yHaIEcojh88E5201bA4HCLKjgubVl3wwk8R7kNmjQ4@z4sbmQlXRiEhvHThHN/DjAdkccugwLWn5Bw9evXQYDzbZ6UVjZCGvLLbBpQeH1qe//@tUx1TUGRYW/RbgSHPNLp83VWPJWgSb3s4RrTtIdvsjQsTc0hPiBllvI8uUZOrQS4Cd8/9VDhW/wPDynqMjAVNzVmHBbYNrhRFuFbngMNBaRXaEVktb5aP8Rp8DCwVsqzQ@dBDbQyp@blGZHvDJZeM6mFaY@WkM48kKZNAA5Rfc9cF/kV/M@5nb/iqSXptT5f4ECCJH7p0enm1gwWSiG8KoEn9fueq8LScbOoacAKFgL9vX43nRGQQwjd6Vi19IYsexegyQ7DmIhEp5/SXuCbgdJqGTh4P6F9JgAzpU9xqTr5ru8uxubFmQ9t6708C9QONabTVY5mD46d96@voNExlwJISmEx9Uc/cD2Wn1/tYGu6MfijDAhPkxZN0NDwUy9mpenMqneGsyn1bmW/omsXBE/8BNR2SVH2qFQhzndUdKcquoJKoBCdcWHoMuOvegzkKMqO@1Rx5QaCmZxMtLynY5659TOK8BuQWkzDU6NkI151N2u0CKgtAIcIUZv6GfT4QBGapX8uv0xRNBCnhVdhpVcJTbtsHBUhJ7xZ@oDZUUbLDY9Nnn/ahC19/PFz84aRHL9BiVzUBc5xPCi3CpwRu888PxCeKCh0paJr5E9JHaz8r96jic8F8UB3Xdg4kLkwFvvwgI8qRTV9L6mOwjxpFYFg4yN4BEc1aRn1HIQViw7FmmdT8QYK7elK4mVFsrLsgBnAyfi1al3NX2nHpxfss@gJjKnPz7tVjFcxs6Xzhn9c1ONEgkhTkknBRYONcXe/mtcnzr2H26v1tIvHoQmmOZxkeJzqkfOA/f@pjgtPrfTxC63O8CMqgIlQkvMhsU5Ix1s9lQAhuwRYaMmaeCw3cA6qNG3VU/n4LMmefAfsuNw/O1ZHdF7HU9q1rX4pb1qv4mcnR2yb4@HEihIzLTDch69AN/CjFd818tljD@29u89ggs4ofya57WJXd0q9dioUl5vRGbfqLF3Ynnl7WX7PzVP7ggSFJ6nL65mCoDNYQexdz9HPWo165EhTsb9nnqBYNL9qLFU4POmlANi1yL6vAgkEgTN93yChP01aLLT7kd@O5y1cL1vrwFFVYR/HX6XKKP2z7rK4AI4aCITDCRB9B@SaT2MvifZumjf6h41j2fhxTT1yrWMp0VPLnRJIToB4uz65V8V31rzR5lQnXU4Zx8VZRHDcYw6Dn8H2T6ebNKb4eLsuTQjcBRxYA/1W9wPVnS/Ppk5WLUi7oxS1VBrx0Zx1mxdkHg0aZCIBd9cJbdbCKcMoEdSQwOqWqTamC4iiQ6xI7lqDu7qoXkYtaUwuFDtZKpTfzVpVKjeek4@j85UCoAreltsRpckaRqkgtU8RrwioCf0syB6nN35PffX/X2SlkFyW/VgvGtZ@@1qneXb@@hMs3r8qAcp6o0H0WnUrH5iH5JWYBJQC6Jr1pu8mknBbpwOgQbA/FxkzDXlAdLXHUZhVS8fynLF53KeV6hqL8ykUimFVH/xhp3cL1VztUI5x4T9EIpgNcoeHS29l7BFqdauH6BVbr@DgkN2VnHEnT4xA0weux87TOnxWQKd7hfUMQrmAIX8XsF948SAN4r4qC0noim2x2F0HPCOUIPOM@o@RLT8w1E26Fvvz2BzSxmm@uAlp5ROo86j3dU1X1BexsUU7mx2ADwq3ha78pn9oACaIBVpVWKvnSpNQgNUAkggnoXT@iU7mxRSvV6qXNfWJ7y6k5aYEeh3qs/EFKUAXNnTiY74dmrmHX8YaZbTwAh8dzk@aj9pBrYZijDR7WDUIn1d4BSVkIDgFfMnlqDUkvQq/b/ZsFMuHCQ/JzlKPWfIJ@ISVL/gw/RkOwAafttkwz5B6xGJF3NTFF3NjEkbQ7L/vmIRrTrpYCj1RoVAA/UURpEYKWYU7kSaewdk1BHgPzEUueZf3/V/HGCZtMpYDZI9Cb98F2vTjPFTMkMkvj1xhJUdtyqO1SG74ljL9ws8oTW7V75QQrhwUD6JU646TXsHZgV1Q@0UsmhIaAcq0yYGFrj/dVgRvdGUlf0Ouw8NA1AvYK@41RuWJNgGniRFw0AkaV1NoNDCCYueY7ArU9FT4ZYgnxntz8WjlKufp8cHJKJd/az9NS3sW9iJYhYW8QnVQC0/6y1OvnFDklBWXtVz/LgMxZ8lMm5pN1v4@wsOF1veY@7@tDHbPgHr9RN4xqb@ef82RMc6Z0T7YAy7oQc/iTU7jh46vxTLSdmR5vUD0egdZZPZJFjXkeEJU8ZPgpWF@UAYYC8ebJ@tFo3Fv2lLwqWOcvoRDBZyva0cE5wxSX7@FJhSNYhsFWFh3odexlcIfmBbcP45QFi3fzYLLw4mXpoQWhnvYcvNFVVjxFoP56CK7o8NckeIH8Tx2ilKLHvkLYyfzxKXFW90esMVxL6xUXIMvKTU/VD7di@Hl65A6mexjmqQ0AG@BNWvqncCK60BJ67x1i5LPe2OMMe9/rml5g35/2lFeXgEzRjTr8ugDoD7mLfJh5zuDup5iw93yRteCrw5FfHJfrABusXdDzSuM4H/PyzFn5/ROy3QDkPkbjKh8S1@bTbDpHogvQ86pi9LDAuiu4@RgV94FcU0RGW6Huk8sTtD67zc3gaPoByhRDC1tN@m02NkbkHQd17WdgZsVzcWt3x914teFy5K8KEulcPiwLuqFmyOehQgi3LJW502EO4Fd5XCRre0/z@PPLTRoVhYrXg@84i/iHzoUo4JymTruIc9sUOKIQTa7I71vb4CJp@t9wFuKBSQNBM67laOTbmll5u7uulEPNKRPnSOfXOrBVL4Mb6puhBndEl/eqQfhXlTp5A9oumT4WEGq5VSXRkYcRVvX4BQDQM31dj6HPM7hhWG3KDYwnbcNesQOH440bfUWLFuR@sAOwC2IOViFBErsIjQafy7UlDEvVn/ies0Cn5yoXR@xS@VyIDHczoEIACVd8PdS2OJ/oPfoC8JNLPocckLzjU25AMahrMRb0KIGfpiLScIpFmtLqc1OiJYiwqbZFLdejPuhCOtN9RvS4b90A1XDboxJTPFCBfmsIIWHcwaSXnVaaprD1Taf4sFbk/Pi6e16bO@WmJkgbiZcrFLgKkM2lrNGBQ7i4FSU1w6/4rErSs3iOu1oF/R614aXvoWWLxEdlNoia7xDX@9U/IyBE/pQ@v6ueHn7c7lHViEBhxH5C/UiEDl6SrdmMIqKTVg5STLD7EHEtfdXEVGsZhvDNBSpL/VveUSmB9bh33eP9PRdYVUWVPciM4xnkgqjy@@heltKo@p0oiVBLqM2nOqrN@CMHaEhZqsL9PPEvHJcKToIt1RflNwaJLHiWjVJLG4rUbIPz627Cp2Q94ybbZ7vjR6ZD4IlLHYVuYwobpgwR3AWkd4Vj1V/rGHQ5j585xKlLFeyRSeLACNm1YEjjLRqsr/r3MMDqC0xtchnP0le6TA2kBP9LKMsBajESvlsTpgNo7ZSjkOqvueoxzU/cCoJPS7Ol8YABpTupSKJ73lKHXuVJote0cGG9CFjSFz75JmOYzlNGAX@27LSE16Cpg7FWN7vWMEiTp4bxARzC5JtqJYvzVDPSiPxpQ/Q9c9DMlhcMN8iTauSSBF9fxXrcod3oKsOjbXqk9NVvVIw4Xhls55y8PAuyGWPA6xZ70wN5IooxNkD83YtevdLGen04cCbpkQrf1e5JyLw48QP/W5VD7FzSAGfMwFJWoTlvkOeHKqQillVOJmtBvElDtdryXrftMK43CEjjhupUdd6pyawgTTB561TcvnVCzxulVGb5CyCGR2SWJeBQUCamEp2Smc4/U6aU5HCTWbZFbTMxKQJFne9@2gw6R09/7Sb31IVzRxl5likea8Gh@uL/lZ87PR3n8s@sw6KBx8TNkcPJqFEhk7V2H@xc@Fy0PFZdM1bLUtdTF13TRDFj0bHd@CJfg2Rddc8ki58miqF1nJHC84fpPkaUUKvJuPb@7r46tSEt0WIn3k37ijhBN/qBm3fEfr9prOkz7najh28oM48Ugoz9Ajl/imm8ZEID0MI4D3LMh0Nrxd06lm4jSY3q/EF4xQx9Xy8aKnbep6XR23s7rn8VkzVDf4lxcb0xoeeS9xyD5RUiigxJ14LW3g1NvDa8LLI7CBR8BkkHQCFicBmcfLoLrpUly5IifTsNXh15EwRBQNp0JRL5Vnj1Br9q7RLeTHEBZgCO/SDbIdVoeAJMpyEsnyc6VVz@nUjTZGrYVrokytyTCO2mtWhpiXzqD0Qt3vu2tL0Z6z5MRxBtt0@rUF1FzkZz7kQjXwHG9qbfHJmcDVkvhMO9mS6AeMRpInnOEV0ll3yhiJ4KIJq8tXKPlKa@PgGKlnCgg5bne9iTjO86LZtpRoz7SERXMJiGW9/yiZKNsv3lFHLExvKETXLtTFEAyEE29rBp8ACb4t0A14YdcDIZyJW7ArVHJ4DmeofpxA@hnDiXhXdB8lWFWAcqYpf0LasfTjS8utgpAuIKVZMJTD@eKMn0vBt6vbBv37qYMTBGgf4RFdcWOinfvVHFUiMHYair0evLfka7ziGOtKPmqJvKEUJukkCJm2kpPfhqpr4z0C/LQeZRO7/UIiEBi1H2KHPpfpOVdJaZ6jNpG5HZKQgQ02M/v@3MXIXGZgH@vnjtoABoA/QTNqXmDoHzkAthxkPYVgubRFMBt4PPoOE3Z@i4fmPfoKD715m@0qlxmgNoX55JD8fBB0Sd1v4BBdFbSXptsnrK0APNT8/HuVcXnJ3YiT5Fcgr3DWS9pV9JCZKS3ktIKTwU0L8OhvGFknX6Bs8Sjlf@WI4kWVXUoEaIMpKgEUD7wPnGnZAQStz38yufLdcr3sfaX@0oEeT1xfOkjuGGrCaaBvUc8w0bb9oigXn2gpANwznDYrLDpaqUf5HewV1U5eFcRblkntiKQij9BWCMhPDs6VF58ap6Y1oqLJ1YRe5k3hBbXDiREEP/BdA5J3ZFKkqeBsxW3kNmGDwEuJ/aFm22IO/WKmLxg6XzOXDkhKwXR33KBPCatxAkAoUQOCizYM46hZwhS0OzSgLkCG0mUT1QlMGOCZRuM3KTYgjUQaSLKmDYSQYxqXMRzwNkdlkUg7lmO7xjt2R3ULBdZt8aYBKdqV8oF1IFrvalocYgAhBLrJ2b9u4SLe2SIaEiR7ycZqosn4HmcJ@iOBQ/g5owW39LaU0ylkIdk6GnIs2AzGikEIgu9xAjmgiFN12/fY83UP@Hz0kLSIG5n7djNgHHkDsJ5aHC6NO9ObbOVRUZthNHtS6iw6tqCf6mcvHSKDkknUBKjB5l9T3TJieiJSvu0tpz4tFYOg0LsFu/DI8HfxDGG0X0aoW/itCT2WU2hZCHjotVAtJIH0Baoz48cWF5pFRqK3EmvpcfMvoh2j0kDWxxH6EK1Lmk0XOxDNdPY1sHXfpOW08H7aoc6G5ej3aGKm4rkTXddu0yPoxNrZ38xt0WztcBnRyy0DQcLCIzsMSsn6O6lObxiK5dukKVgq3/p@WkKjnpAG78oOrY95va2NKmKGe1OWl29X8UR6ojmpqrLWSX@TXp5F6N3BSo1KE2ZlAAGoLuw2L8n@ciKrWL1bzkTZAMir0EqIoyHR3xhsdhSMna2PnqeV33ukAIuG7mC2GlsAK7U6sRgu3PFU47X4tnpu2PN7MkXvjZXvC1SIyH9XAW4/AAm5AjccFVBISAT0VMvMX0hZcxJ@veUhWGNJgJB64KS/4JoyZIlxewzRP1kyGouXbDDd9G7CMnfSv1gwrhZG6hiP0uWrliee0QKREM9p3OxlHXy0BviBv7y2wmfivVZjugEsdC/qIBwkGjXNFkqVJwS@aoPPvEjdNPTm9wh1Bt4ZRY/owGbiRuMBrh84W5TnV8kRAixZKsT1MUhjThmUIph07lxrc7EwsxBnM4TYBxEEYi0MXN76iqW76JkorijDzl9rlQIh8zgSkJ4hd7Wts80gMwhk6otORYZI51utLovxgXmhDckP17uRJoJ/nMyjZALRXiRcsFkVTx7wlnJxTwA6JxDA/C5Qht4R/@SCBhsohIV0bcCA2LGWWsYlcbqCY@kAlR4zluq/lO6Okl2uu0Tq@yqjLJuse@gwLbZvDyIxJPiHDEoN62QxowzfmiOFsydzEouMO@f0J5GbqLEpH/Ug2f5SLiIjY2bg8zK50MiTytRXhYX6MseyLmrKF5kB5zr545NFu681Q/81JYB6pJhxX9dHALvih@5wVWJDEHTTtMfIuUM3OttXPG/5YXs23xbtit02eci5Hzyx8ymmG@ligRI0509lTHIOxaUCPOmo1vMQrV4ieqPAFjV@pbBzupUNWTXAhje69h8RFMAc39W6EWwPD1274N/Aq4cRhha3y8q3y@XC@W01oBojTpzq7rOBXHq@V1amQ/EYgcW62THWpDMvZQ@Z0xAqCAvLfAqOhm4/qkiBIHQFlYuZKKk4e2M8yyXXlRe8Usxi/eVm5FKHYMhDJwmpcS1dHtVTZr8AGnPBQh/dL@grS1dN1Aa1eMm3viVo2vbwc7qDCCbRkO8gcSXF2OJP/k/ZPlD2mNHS1GlgpkHXZ352AWeq2CDRpsFlHt6GB0eUYn6fJjBb5Vlnk@MJC@JHcoTjjnFHMRPp@qJsgXlZ5oWQ7uLY1Yifiq3tbDSImaMpWVzrqYGaFUDc@keof27BXWlzYBPOiZ/uYl9f05kmkBbxxzYQE6C4os8oqI8Q2twvjT/j7q90gmIldxXqXwtZjf0o1zjzAdRP5n45YhQ/hyhOzFGrLMgiPhsHaZn2QFM/mN6qUdGGZmo/ruTOGUyZH9yNoiV@2Qlk28iilS@lI75Lcees74F9c4LESRWe630LX9GzcJYQII4cU1tReSdjLo8sjta40HWQ0cQXkJGQVj/s42KANCWc0GynqiKMoMeNOitgoLK2alALDlHoU7knmxYm0XOpbyB5UlCyCGUh/eiTjNDIDM67qUDfjJgsXUwgbMXpaTWxVS@OX2PXEYSQiD@S7jzzZGGauLfGW0eZLsevZYcg0xVy@9KUXjlLvYknzsAoJT3Z8V6NRkp2@NtfxH6gC1kjpHO1eXgYDeFRXvTWGnz3RjP6NsLqYiyqlwkBZqY6iXPUcFAJnqvx6KUgze9v1Llw8YsRdWZkJu/ZZVfup6XI9Abm@HGG@ZCech6peZEhofOgO9VcWB2eS@OaRJL/D2SBF2QrAK1fORCbH7E4lyIVvH7oR5eT@144iNhEISJzqOoBMlC21kdTSCk/Nuz7kFGt3OAxmrhB3R834uyqHigVPjKgI8SLPKqL4r1HqfE5uaZ9IJoN1AU@xmvTbKgM3BUKzmrtwTXfGHU53JJ1hhsNnXh/0wm2z/7Ep65C2RY9GjEKWW8IkmXpXMAJTBoEFfd0X6/AaM3N8etFE4ige91pMIUhXDX5vXwNolTJrJyY90qtfHAWCoomq6MdeBRUYKPdAH6PYveTTu847zkeplLEf@uM6HOy2vh0oxXj9Wh2nKAmEQZ1sw7Ut/tWRxdcGKZTdYed1Yp@MhPtTmI5ftlRseE6047oL6Bcli@uHxarBv9Cv@Yki1edls9nSSPh1T2DIVFIfyWkdATQEEQva9SUCUYJHv1/JFlrclsF9/fciY9l9g0fwVq74jkd8rRqMhb5SE/X4IfOMYPZmeplKBHdgR7A@c3EL2aJQbSou/TAl@dCx/uuNOIXvDJFkozNkFdpKSJDnvieeZweVU4znKIixcPuT@zHUgP8tVt5gIAqn0DRqyWR15Fgobk8sQxQFT4CmOyIEQN1IDENH9CbEmO6InfVOPiV68YkkgOTVKrgt9XI9FOTvuRRD33IHG@W0h3i81S/@8Dmen17MsYdWOqRe8mx6S7/Qo9cF7YCrEQVlJsSfs1/brmrRN9LzkVGf4shnixAAQ3TmHQlt8S/WNcYRJkpKPPndEvzKQ6zcZyDOm54kxKgFdCsLxQtBGJ0i8kN/zpXQFB/3c4wZXmsWdIBc9n6UL1X2QgmjEMW7mmfjAg@SUILsYNOGh5czzC6c/@j3aAm12gONOkvB4TpPpdur4laLCs2aGqzaD1ECCvHo1Pk0gOx7LkTH8DUqNrihZHpfFSXMJFwLTP8s95oXEEmE4orLUv9SOziTsHPM0WyHO6Zg1KpmKSdWJIPofAnNKtGyTBgkXosqz3JAwSXQmYzXyEQh45QgXuId5/d96j7xe6c9do8lBknn9EgvamPoX0aM@wQXKq3A5E3dCxsoQ8tDbzmgTQ6E8AXiNA7LVEalfC0FMaWZWUvc9Ru@/K6lTuIxmASsxfcKP6IkDcfEI@VQHfpzPYQYfgq5OnSOKjLI8WHH4475gBauIlr71j1fEIlfH/sr5AyHZWahO@y6hzSzYrGD0rTcsU4YW7KdZmCf5xne3F1hvgW4OhKG798Xs54fvu7InF@vxdKmYnuR89MWtB9GHasBxCWKu8W5VL69PliEZSAS0625v4I4ELPoiGUhpdttihxs4v6BYRPIcrGBMOpyPOuw00hWuJNUwWtrq86P96bVb276mID4M9QtZzE5KMo7Qll1xWd/h46yB3KlhVFuUPLaum7805JL@rMwsKpFllsL2yJUJ7iv93pnBoplIKcR3dRwtUvYEPctcLhalk85ACbBY61F1DSFoNG2CunnahnVSc4x/BLo30JInJdi1zQyqmPWrJk/3rm89P2cgvpIJqQ5lO66Lnl48wLOpRDz8sVhAItjQiLwxev/mNQy8yyy4JdFUT2LsvHQkxacQi9jLZoRYA4ylKxTg85al@ljJoU2qwOJBYaWi@35xjIUCLPZrmWw6YrMxZx2fjF@3nSx0vb/7KG45sIc7MawNKohpR@awOCQDLIvklHlU2lmbVYtuSsOKS7VfmndVw2VBEGaUswu3GodHerugDySFzoKiiljG3JiTDFOAPx/WDUAU0qkY4lQQgL1/dQUPoU7a752uphby6/W/JLTcc/GykKhA@DtadT3itR21owFCu66EEFt8Dwadq1p/e0ujDxNCPhUX23DwtgU65XyqiK/U0E8ph80dx3qkKKgpEeXqiZQX@SP3P0GfSLIMGcNb0Da3OHTyQTzTe8JHBJiIUjYGr1tPm/M@3D@BdEYmRmGE9ndO6@0T8wDEvDb3QPsi@EzcPi4L/dqoxjA@Y8pFmMRowG4AnAivXPL4lMFtUw19RdzV4tmyW5QkEULIpSicAX2zRHH50PjBFMn@@lxPbzm3Jsc9@@A9laR7BFnfql9eOWxF1cW7zkkWQ9BANiJAv/TxTrcV8bbZEmrnrvkvlEjzzXElIeKRdkRQWYlyYYS4HNoieImpEiYmqSXT5prSD0j9cIyJZ5BI3n7@aenGyyCTJXi5kYHVnv0X/ra@bhk0@gztEXOeWz/Qgiqcfm4uvuQI5kDBN55n4YWSmKL/Kn0Fui/TttIEQaYQts5gMde2KQ6amCSmCMITCxeKyINPFukIh@EHb5xtIO5UuMbH0/IWRTVk1vyfvO/IdUlK7jk9Bw1hYHOT1olFvVb11yPQQznyD93AMAgALe54qtJMxij7BE1d/Dx5ZnOOrzBjpR0jpXEzEeB0xNl2yYzI63ZzjF9Iwm@03oJVWdY@qluaEVrhQoYX7JzHm/e5ZL@MxPP9D0sAQHUNn9bfPqj6qVT4Y6j@dsFOcuRZEmIo3iQcNFYOOY7mxXCvEv/yUBEJtC8kFgKjayDmFg4Lw7hEzKcqo@1t5TTw@/mRitZgUWtgEkbts0yZClCe2t/tzZlQ@6wQhl2Azmw3gmoxeAe47hu74yHB7Z8wdLrjleH8uu@R7MS2OjJMRcHsLFmDIKERYnakDx00ergykfvhA@uyYAch8AhVsUcuTiBgogqgUxnIunzMsr6ODQs70y7EjtmOW56jsCRRkZy7ul/cadCbCHFxP9SZ6XjhzSH2ZVN11bwm085oSb5zK7OpqYBxLCQvYh6e8cZTSPEAEnbb4GZz2CkC/JgbQTaOgUhlwSc0q4sMz0c6F63i98x3yHExCB8CbB0NQPRpoJibQPw0YPwJYhX7d3s0pl4ck0VY/0Ukw4eaFflS6hMaqCCALXRSxdtLBxMq/nHQdmgHg2gKO@eddGvytlSZdydl7e5e3CiDBafZA9DfPI8vPmjJv5pvWCzMO8yfOcqvkkrBUpxQGle4rqpctEs22aRd7YoqbjlsEDYqAGBBZutEErm8OIDrsqvwsIDXkieTvUqgnMmQALmm61EbXXNtUSAHJZgLKBYxFt6bsIgg4qWdhn7FvzjVTyOuKj6mq3RpooVSq88rQDnwe4lXTLPQXOY2@ixATk/9trs9TI05/1eKvJ/5Er@SXqIQgrYEaot02oCWzPIQALdrgF1m7pqIiUrMJiQKJv@aaokYAhVqk/YBSXZl/PnFLlbW8b64sKYVufAAgVFOYgFLZpqi1r4i/OAkKl4wUUTtYTjLPeyXgaRF8WswEYm@Qu1kTNdRB603P4Oh6JHgwieLLDfbXWUy8p5C/zzVkA@WAWJK6CuhaMrIt2bV0R2PbT0jXuYMSXzVwAZder9R8kJQdRxIVsbmkOit4J3v9oxuakbXL4z3qzn9CDhqWhCym8BbJWtzvUO/RMgQ4Im9nfAZNFRHoKZ6lFXrj0UdXQDki388iUCZz1SgChoRJZtTqq5XTT8cDADcFwRbz7HmCIigskLGOJpvIHUDzR0MDNDgkuedvTaYgsUTTzjOx5GiPPIi8@Vuu/tdSYgKGCPAKI7Fu9pW2q/X05PSBtoxKs3szceNZBqCIJG/GK1hT8t9keveVP4Cwz3xuzwwEhiOtWAXl00icxSWUmTeYYKk67sVbyPxUe5ZHgpBNshDKT8qTMyHbLmo53u5kvnm6PakAU4BDampj64L6Vcd59tGQPJQFIMPWFZUyQdnyXL7/oiy64UaxhRYCd6KE0CkTQ@DDP3J3jTTpfqH3zu9jS/pBZAZ0upfgE52keUF78wwC/vY8anA4IKHnFZTwxMgsPnHaXbbJyuSNQD2@k6zdPJiacMjj0CAaanxMq0X3xaQPostGpuUV5Fl5DPiYeoQYpGs0SMOV3kjz8Gx4Fmj5plfMrVSHEsCfHXHsnTPYCKXNcwLzZESQCF9OAmd/K92QqJAj0GyvvV4Epvevwx/Y0s4ATgQ79GZTeEQ0Uj51guocGQyU5Umdb2qaNyxFvaFFxownRxmt3ttGaB4MmEmytycvZ7cnUfLRrCBZt9VFymHxyRQMjJyO/KzjBhI@/7Hm0C74RbJaDcp98ZePxnrEU1XZo1pta67Ok5mua74jX/yWo7gwVVecVcQeWe5nIoM0GnhIzSHyPelOmsFSAy9DrcwNGhLG3fBqkhXG9ZuXKerVt0aZZOH0q4UC8wwv3cPbbDytWs3XtuSzokqTwvTagb7Gm4A50hl3@ue6d9XW4SWItS3EsSmQDNY6rHOPJ6Wu3HMdwsxFIZVZ@3eWpnq3GN8faJ0VQ431WdnJcW2j/EwSgLN1Mc8g@h7@hIfdCy@VtpOi46xZWneQ0bnM82ZlkbRwK8mbsMi@SgzlUsPpMqBP9dCiRAul0wjlAf08ZYUQuAqOZt0F81uFGGjnnXgQby6f1uX@ed2hj7l7ftn/0F8HF/709a/Uz5FPTPTi7HOHs0lOtxw1t6U81sNvFtjZZCDdbvVgdpGaI6udvzfeBSFK7@D51tgYxM59mcGrBNVEdHPcL0pQYfYIo@p2gS2qDAoJ6CfeN8AUQCuf8rTzfcvnGHJ30NxIbufG9ciyeNklUHBzBafsHyqaYRggM@dp1UekXInP21CchiEFPgtC4F/tKN6tb923XTPJ9rsLZ3s0pZPdVh7UxdRVsh0xKiB3ajEpt9V9/JF@5EL5p9Dt7WHwcBlREEAIkYOde9Z65y/11BOZ74yoiv2iOGXC97K5ujTRdglLouMnpywiMJn58pUAVWswqNCiz2@/BnHoaizijRxUvpsFHDsQVLJWzBfzdw/IEwrzyNVtPLIFCol48wO@HOD0l0fTQSTTlBRErzLyYwlqm38jxjZgC8/lTIGQJeCdteRVv@EMBEnaB6SBJ9IGkLY@@cQdSwifkaSjDJZS@fpXPzyRGvnuiRNIqVs74aiZHWf3FwnwNLjnSbIsrctv3P/Ng7IpRu7TA@Ee0YqdvXOmxb1WNZqpRb2N/WtADuebrxYUxgSC1tVQp4RdJD1gqTekUZP@rR5gbLhMw0ieiOSeZnCssUoV58wuJR0fQWPWXx73nrNojBS4eyefp6B/BERRPCdHOTJipSyoE0kh21DKX1BfxmtwK5LCWkxvDiuJl4IPoUa/bFU0f9ZAB4nUOvVgjkfD7ZpmwuLMAzLWJixSZPubMOo@/9ileMOR6stACV3xcCAjv@VkcynRimpnEkj4UEAPGEqetWV3lzKyl6Bt4In/YDY8XDSSfvxsaTe/osNdYvKlTLxS@qAshQP6cJk@VKERpTjD5DZrPCfu1erBafPHMLZLeLU@eWw/WI87YmSJ3hY32tP6xfnle9nEUlnh8S7xKdYuZ8bmy3DIUIODMqLYOQeM2rH0t0SXNrrfDoUwaEMjOKlTDklPhfMa@VP@yuzBOsVbzwj1zW5VlEI6duA6@KPFnovRWKj2w5zHfrksxAQ7XS47tnwBm9XWRFhBu2QezYS0QT7NTPnK4Lofy9UA6@VJGpZM0InI037N6gPUJ37ZYgIt/2688GZ@MXVkUMC/ht7H2eC8opv@GpxXLXo71LfssZzjX2clNuaV9dvX5L/UIulQ@A0X5LJr3kPqoiPh/In26T@aAfU7s3hSfPGsNCugcX6/ujVbLn3LX4wnDNwXN04jd9uW/4TTmua/zirlJau9PWbk85c5/b4sTxr9RvBESrls0hiSGdqVcJtGIB/SX355TgbIZ0N1yFzP3A7p/KwuQLhA0EiQPSM1ndWq5UixJaJ1js9MK6BzNWi5iCC26iNhg0Y9z4YivkOuJGA7Jjeh1/n22kFYq0lH0dSxV5VEcVuXiOmqNQ3S0PPTuVIbw1@q5tMU44@mqbR1zOAVwXJrF0LZ6GvmOW/JPLJyvAw5QG/KkBau3gQuILibWl5HpPkMpcFmy9XHtvZk/K65pllsq9r7ZSGsmiM7ALxXcKFqVs0KUjmCic/SdBSWwL0j9V6DOGQ59VyLjJgfMGglwx5m739drBdgF@TQb2ryrG2owkHvTL2ocqWLPyXhAcug44xXHGkTvAvXcxJiL9zPGqISJ6hpYiSA4aRgBvrk3C0XWg7Q1jq5F@vob5DXktnJuXX@mMywl3RSZTPyNqdDQdR8zIpyWiie0w25ogB@6gey6jGNSXv7l7vZ1YimChId2Awv3iYZNC7kU6Sey7tcbu/UTVruIFQ16Ab@lquz23mSKxAHvGtWaaVuTp5HWpevyRd756DmKnvB@NId3A1KfhKeALaeprs6r03cBQU2pZX@xTbCBeeahe1nw4IigFagcoctY1Vvw25IYmani974F3lSL3M2V2ffyiqAARa2FhqHAoWkiocDkk58/c48yo5lBoRiF32Yl4Vm977cEEgW5XLNd262FX4zIOarr8N2ORsVpjyRk0te8isq9/nS6KN3IRXSMxy5xcAeVaJ7OEWYr2xRUQqfwXi@03ID@a/alEfSN4eTQgfu@tbZD0uncOfxuvQiHo9oXa/lrOo5SiSa/Uc3Ms9gFtzeBKd7ASVEZneDT7NivXNBNu2ApwCpA9b2l3OCbO3qTG2QOaCcxrHMkZNWcKFOu5eTPuKLH0DS1tzYM0ZjHuYGtZeINCnDjWEn5NJ1NJLm3Zr4pBGtM4dnQg9c4pL5IOg5jjQmU2NLGn8nBjMl4ulXyNQ/w2OKsYfL1Cz7LVG0XHdJLH6xgVFYFhbdkpP0rAHzeonXW75@hMl/gXpp8HITw0Z9GwOImPHW2mY@9q5OhaSE7SDTczn71aQjDhj5FV6x84KnnACciwqHDYKFCMttn5SFKrnnWm9oyz8KjSmmVbUn/Zgfyu@dFwXYeG@q@XutaTwvBJ3eJGxsjR75sg00yCYVef4myjmbE/fvzej3i2byLTdmVTG4cD1bSU06sjd/z@tvFJNVvVeIZxGxB7MbLpWlBf7Q0ZiGJlVk3pXTvH1HbEyAVHbo@EWYAJhL/b/mToLOJOW4Yb9Vy@RyvmUpCRhhZnAvd8@nYKQ7mfcdkcybCZLdU6uGNTGay2vSog50cbBen2FL2@pLgMqWa/CvoemZo0nrrzXgiQcKyFHHuPlgSr66W2esDqPMm@XCQupsAnqz2vkyatOQDp@9lf1cJF@qq1@uaUiOKGGsCeEsvyakI0VVCoGOPsY5R34H6QB/2aYlFeV0oc/uCqlQ33fJBjNlW47dvlTO/TXecLGNFmaSZlqDohwoDzXdla3QSEx4/0U9HP/rzTWbLsedm7yE3GDTnlRduJu5GYFFvb3CECgP9AlV0u788lxQ7xwuKCqDcIcd591hbPzV8dXBzFmXd2T8LfwyDlr@oslTsHyE1Xs1b5TwrJU8k/bxVn9Xr8@5qq@zxl@F4DWgtQmV7/M3Vhq1cAM64bTQ0SpWj6wfm7HL7Ujm3diqyCigtl/Sn8iemhZGs0iu39QG6SpyaiBmasgR4onl@jcqC0y@kPs/Mz2p9tecgD2DW0amqkkc6Ia4Y1v@MrtClGRhw9pDFfo1oYtZhV6jGs7XSmbFf6maIOzcyMkC66DR3PrPVM97glZ8KCNIPIhfNuprcMnRVDn@a8oQJNkjP3@9FMO0PTFTV32jSYxA6bMXoiUkP3IwagOr/TUSReatqY1n/qHfmsQX4Q6PTCLQVA4BmIXZ0wxIPZomCMcgaTxylglpZzMVf7fcFCHwHZ9HYGuuAep@L9RKkH7SeUhKVXg8yqJhvs@5Rm3oK5IFNmkx@@mjgPGrnUoXaalabVAFDaKv5jy2BulWYmFbrB4LU4/wQ3Vw4q7fmuOt9wcOst5SLcW1kPQhGcc7inwVjyIku0zoH1fBuwFsWLx7PuAOnmzVviY6Vl/ljU6TQhzNcVdrCnnwS6yckQeYb4HhDFB@K1zsKcarbFOsmT52p0lV4QMxmsgnGtGlwK6zRo65baBmzinN59Ru3Vo23J6iT4J/SOSeqB1AB2ywo1ykASfggrUPkjlVadJjOJR1TO@k7ZIehbhHFKh6Z4qVb3XDkVWFvhvr4k1SEcTiTMp1Kj8MFLgG7LBVUX3spraQtj1Rb6yq@rLclLZOga8c/m@W0ddjaJBzDopgl4YcHA0ye5YuxXn@lFQdGM25MqWd5qwI91eq3Xt27qlljJpFY480mcYon/xr7QP5RcYw2h6Uh@IcqfqRKRuapvYBlLRae4/q29556jS0Re/oS5peakfAuJTGDs7cYI3xpmozqvEqoYOaEy1xB7rX@LZs/5D3BQh8EKqlq/HFetBe09HZuSqbrzEnDqhQYq30xmpihCoXnc@Ypfdv2aAR8z5LZ8HS99oTU9j3dxlurX@VP75bpcebP3cDn58Gvt3LrNm7QurI0iTKkef3ZqYfEpW8Jw8m@Vesukxufk06RyaCXbFbydD6CHqronubKJ2TGcCTX@gbO@VJxNh8jjcaIpX/L94Wz7ozcQvmyXEunlaSWxJFWbziB5jg@x06mirgxlB9vLfGlbgJm5uSWSg5mz7YqEI54fKDVeuCHaFwwSZyt61JSjz2bIW78UNHRpbSyvfPIfDJQfNLaOaNa60KxFVGte09sHtNp0xskDkmOp4v2hpxSdV9/fk554GnSqIgfzNS1I/Jb6LuT2OT7gbvnY0KFVWvRkvSgGFPWDdE3ngDazYSMiDS4NtA34Y@5QlARsya910lgGOns0yunMJ8TTC@GwTWFMK9Ga7vn7k3FcS1JKv@Hm9nv@LEOQ0jTLuCxq9DSTR4v0pJPOovcxYMpYZxZIgCEu0d6etqaZc@wH6pcdWOMB7nS@J84uWtyXRaSl9It96ToznqrIpaCpHkvEkSWovU8Q22yALXZ/MpNKUhP6ctgdmaXfjkLqC9l7NwE6sKbkfDCK7U5nvzQ80ibsyrs3lJtEVMGV1MsYrlZnorqN9c936/ZfO1Q@6Tb@cXlm4Xxhzx9U7I9iwNOVeowBzFYeUz8nXTd/SFkICjsC93mNXivpsXtT95x4lbV0Q5xIuiD8sIisgwD4DX2cH3q5VfqZILbzw4ovY7LcXRlPbfUmkhtUCZI4sTx8X@X0BN8/KaO4omfGUteZZOtJyvpkzlUebJkVIQd/XumsIFZn1ReMRwkhTO@ZbsMlaDj2lQ1qBnvIOQxZqPwqZphHFTWcXhWZ7x5fYaUSCkIIqz7sXePOYjq3ZRSoL1/al1Ba1YVfqX4DitEAjtT@qeWiKppBpYCNqbOSyc1dmDa8GznZZn4M6XgVTMO18T1@hoo1KnXE/fRFhnHaMS54euM/CFRmlIihhqNFS/hA1P9iHMJKQBTZ7Me1cWd6fKqy2QTiJkTrL8NY7tiHtpydyl778o7ECP/EHYfP0azSo9f7M9eZpMHSEPr/1XlkfycDRBGPBGrtzcB4oZ1nJ7rFcVw5kl45XZJGsQY9Ya2mtp8yj53Un/sIeuK4stxmUVSg9z6zsRtlkOMiTto1xYuwmADJIp4l0K1MjzZ0d0U1qcLF3Fl8jkjlNwl3HGiukY1odl8Id6VOXBVDK@BpV5bI5fHJAnhph@T856Zzq2NpNWiurXyMmtQ45/9LbaVmuCEkYNRg457K8jQjCXFV8hn/Yb842v7AMcUfNJaY8GrImfaRrwKp9druKM9dDRwUgsXs/l9hIsvsetB44cnck5mFIcoNA4xhr7JIw2KbChtHm1NZzDC4rJRUv6ayYFlwFNFigiyvxdbFATCRDgDyLURn1wjxdc75VrbeVZLnAN@sPNedeYYralmv/fGgKm0N5ytyJvMYexj3IwqP08Ff1rGbh2XFAAkrmCu1PiWPrSTPhSVd6Yn0B1R9uXw0wjn7ccewvR5HEwKhC0yZ1bdmFyIo1LiIUoEGCRqIeKPsKvRtQXsQe82IBpPfizAehPfWJGT6jST1nqno@/0ZT6PVEf1OFP53iWRei9ToWMxdkZPZn1mAdwKvY19eCTdyPijqbvgDpkqWdjFfbmK7RcOtGbfnXkcyodqHmeqUwEWFoKbzKM2TkjWXWsvCQXVIoNgsV9WORf1Fx8zX8oLpZMVluNk7cujDxM60zW65WK4qhQDtv097aYkvSIckLyAyNrREFYDIqldIKyvpl/gTLZAr4Vzw4RdoeUPYKqxSr1gF7qFF4po/zJcIgGKN1NLtuWp06jk1MHnk5MgicTdMCjN8goNQoqL0@S/HXelWe9jYH6Vun@Nn58zd17S1dIS/MIPBoWzWHGiZ05SGlBHNrKyDwl7UR04hxV1lCbRg02N@5p3NhRJ/pK7JGxvdqrwXd1ZiWVVmfeX/AQrgr8ocnjzBGjTcmtaM@d8qj14dVApiHoODVqM35mXxbFtrsUUaL4JtekONB4Z1T4hnbUZBCAtxxgngSUzK2zNdZ/l@5sHabNubn@CP2ORa4hvDi3kuVoq2CrRiQZXxiQlE@JSvZOfnslT2OXD3Q29ahVnxXQr6VIFPdGpcNZ3SLcPjF5bHVkqQt8GaGlZW3q7Nk0v6PlYvBekB1ay56IGx6FC49fmYsx3YNDRjalcbHlldSwJ3u1JJWKS5aju@V9CftRmhWA7FH1b0K83kz8wgeyBSShkz3ktapZ3NzcauYYqynV431peHjbeNDc3paqzFewN9Bx4q208WyrJxAa0dv@NPgdE5xRHQ3/tFvYETwwdBSe5dSHo82Kp/RTvZramwS3mYRPySiq6G@5pDN2YG6k2yb07TXInmShSk7o/l6viIIuyh9fMZa1Wbcc2WFRF1BAVeocySrr3jxJtamttYV/8THk4Lo3pzBe0Xgs63Km/E/ygvxSxLgYX42D2moME7xqdb@JWXlsxqGSTqU1181aRqRmCuSOoMWBO@DrvN@zWSZAJ7DDu4Iq2Ywu09OoZw9GWf781iwAmOUVBfVXWsRhEv@JOYz0gGIQidhwIEnpvYxJTWquCGz4sLT@Wwm31g1Po8/Ubz0zgGUSKWTDoymQmUNtrWbAM@ics1ISOYDql@GsCSRrlIfkCWtQWypqkK5v9VIVohoaMOX0OfIF35rCZ7gUw08kaHQb8g5kl1@6s1/OsqK05aqDggPNzUG9@MuCkMfBn0kh5NSRfi/LO9TJb5nO4ly@cS/eJfTacx9JNiFu7EuDciaS5LeN4XOmyA6TykX6zjThTeyr7/ikieWmQPIr474yBsYgXqJXXO0vMyD93l8@gEdOipyFbZO3PsXHTLeHc9WY0AJFhXny5M05oVlF2cig5d5ZEOmTM8A/VMU1C95EWjjjZ0PZaWIbIF8t3Qjd3KREyt@yXzXuRO@zljrJcW6whNMhV4I89cQXbPAF5DNtJRESlH/fGisHSrN@nzXUGyjA3bPhtRK9N4Lls6YWv80APRdLiUdRM6qLW/mX7MswBBXx@eJPwRRwRp6ESYFcPHjgR0/NbdXBYofuVSYgYAXsGSVIVtYQ7hqGOjT7mkHTUMq9ASl3c2bSdOrmmnCEC5ydRlB2lqoJl9UBLKtil0tAGvXVGBxY23KjOluu2@r6OHfPZlej1QOnMM4yC9Y3w@KngAyNi@KBwfumLD@WKMGXmnjuZyuD3rq0y7jbMmXoCXfQVRD78K2b@Za5ud2QzdmW76tecMNkaxUDabkphRHIS682nVfL0SbeTomNsPfLIhd10qKko9/iuuLwP6tbpNHehOW3b81KB4OH1ciZATsra/YVDhmjEvNDcM5JBNtSlhO/1Dcd4kNHsQiesCSKku1b/Mk1GMDPBWNuRVfw75dzUEqQL5RUzv@lxz3/Jiw5FIKSjqwijvWvBSCMz3sF23MZv4KQ69xngQZ0tCkCL4@Y8skhGrtoX2rF5Uz3JRy6axXuwQtZoOYEn6OGzducB1VD4@zAuVGyFOuUsZiwKJa1Zxju4d65Jq39Zw3D0uFX1Tf27cvd5Pfm03aEKhtvEA1kI6h7lrenA5JuR3ZgOErKMU5c57lWGopxvltrejP6jQb3F8MEIIK@lwcnfrkmYiwtjQkcsmcNxsj050wfB3J02IPamOIdOb56KY6LNfypnmlkPckv2mruTM0W475D92HHEcDwUVfOMibXC0d/L2BWZINM1B8aBITlvAB2bLtv@f7wJs8X6MghOF@@BwfmzfNrpeL1IC95TRIFiIretUYJpoebZX9wMtUz4drmgYkg9dQSMPAwo4PPmEM9gC0hmbb4rxHmW8j3mQ@K7PtqmOOa7teD35NDOdyoBfhNt62vpldi0kvpvViuOuV1ziBXKx6cKXF4OUqtvjVwrxoo4MWf@gT6l6wgVlZ69pqq1FA47iYod5Td2cwmLc4besud5FyziuULNggYuq48BEpxs30rvePMeS1bmHfZ9TV22VOoBwFL9Kd8UnUYOIgIJiSHB6DArDKgQuhLP3E0jGTx@wsjDx9Gqa2Cg53WXSxhL4PbLZDvTYu8gh3udK89qmWrsygf5xrTdaV7qruOV9JAI1zgXy5TTYOxJbLlEIk52CWzAqhZfs6XI7GSRqzMh2tCgmDZ7JGFuWMAdKZV3ICaa/0n3HtNXr/Ks8S9fW9UTb5Vae2SufgJOurlkIN8Y0KJEJWfBsSY8tlyL/VtFMdTaW3EAdmKU2F71qDn20KGnJZ9GgeQeUbK0StpgxfQuAD8U10SVeX7NGuK/YCdXUbuxN@eZo5kgpvk52z6KHSLzA4DtplUprZ/SVvW@Fio693c86ZI5CrLeNkpb36bmcRqgYYL/OIIbdmy0v2BHdOEglK3JsDzXaP6QISptNNhIAyhhiiQ3M2WP9O2iepafnDr7Lrezu6tkR4h4a7gaRAQ3Dt2rgx3Tbv@EnRrXXvMd/WYo51ZWqZwsibcb8vlbN7tV8cBvajhu1cazb1R3EyrsP8u82rz3VozJtDxj8ShgcYg4S29Ri4P/OoR0Bwfkqav3ldFT015oG24cQOd/MPVb9K3yw6QvsAgEYIU8s7HrcOSTJTR7ZvhiyizhFsarPxptUqB7Xlz4FPuuWAYatNJ9paNfzUnsOv3ssLIactyuklhoibVxlaHnHQQgxJzOlWdX9mWSvhau6@h1FUWoAYtl1@4ZQ/@jW9G/tZeFAzPtkTNYDPUZQMOZmV/Lsxv9ow46azSiP21jYElfwiXyqIz/r4ak@1EoBzFjEZwxyJsWrc3nb4acIvlszwYmSE1R0RzryG3RSWFbPhyNk0s8eATmhWBKPsanJIOdqtLwslQkY6vUUNE2sIa4gviCFPkkIQvCxKPdONeazyjFqmsFzMveOhrjtZRq2GRZxuVp1myN2xbN1275k474gxjtXsUVWJJNVnQEmDMlkHZr@mWFg5UBC4MYTpybpIfWVxffvFPnxPjoSb6lWtPxjlnrqeE4zqKBhSePSv0OnYy1/JZ/iVJ3jOttuP2Zqt@YZJHMyzUN7wFOEup0eGILupa3mZ1IzC8Z9@x5MIvBEkylmnz5okHL9YFacgfBlbjzoSJM48N/EWNsx@0NC95TZQ1qxhlTTtOhelkQKi0yPOKuFfadi@q5Z5pxa@Bs5766oVtDVUCmnO9A2EKSLpg99Lk9dsQAzAcbsmyZs11@oi4KRl41mxcakeMt6tREZCKxkbLiDIMyq/@i4GnChRGozs0gueozxQJ12togm8OhfIsqaLk7Woec/GAlP2r/XlE7m16VLBetP0EkKiDEYhIzCWpObfE6EOG25uHdWTiHWRsOtNuTL3SLNFmQ1yaiKmkckuwc/IGEudw0bCCMyOfrWZUYxiuRtxTHIP@yd2hvc0yNts5/z5jIbZGDBtTbe9ksaThaBP/mmqmRBFTqqYSG9gWin@Kc6ZG2Q1dDQ2/tU/lmU8dbikkTUgT3BvYkmtQNszU8LkemQKiZpFjYn8rzhtjfqK61zuyzxlTajBjL7ECxBfscYbKG7pcn8kGE44wwnNZRY1@g@rhP09MGnNGfJ0n6LFEBWwMTVwUWz67GgDJ2WxhtkDlaqoLboA42I2Bzv8THtKwL7OWfk0H3tSRJm4gNfGa0L9Tmb64yowrUB88pBKhZnVR/9WURwFZZFfNsYa8N1Dx3hs5tFfrybV@Uc6XHX3jXDLiyBLwJ5qDEB2qpPJBzPksGHltxhtN9F8/VEGduV3TGMViDBeHRUPCvqDUsyFJnAD5yxm7ohcmXv/yddASyUMzK0hwmjF9pEjnwjdZdX2NYtnW8DglOJY7HxhRVLfrqRpE91rc8S@ZQnaJV9iwHNM40XuNZs/ZIVNBrdfKl2gZJdxbatMJI7@8xBCR6yaZX3dGi9eOjyJXFIQ9IG8ExN5xbOC@T2pZdsseYZYPdxM5MnfPLQBWuUbDr@Ecc5pfZf4kCCQPa/jEllThbt45eH076iUCAdQpoaiV7Jjt258DGJIkhxj10NcAVX36N/po3hRS2P4UAivYSbKl5NrU2kxwXM1t6IZAYbLXHdhJJgPvomjCZtMeEMux4vi@aMlV6VOdwsU4EjfhgEKColsIv4MbHPxPhtPiNPhT36e2d/PMleiJGGk2XAGAvk4zk4nGTyh5SrIbVMEr6@iQVdfaA1dsll96XlhDM1@1XJ/l4/dDfLvSJzu8vzykISi4LVsTOi1x013Ftyf4TXWRjUuiEKTuPWAFyNpU71aN/djsjYaqvOefw9JiwfB846y6/OmQYksa9CvMNSDBMoJrq5nLqFFCCOTdI9UCnrkQgDyPNbQ9KgsOeAPCEvufjd1Ax/acNU2/ZTDncYAtvpiIJzLQYtzTlkGIKNH5JrNQjhSiERg7/Fl3Yph2kwYiwT1pjjOh5jT@43grUEt5agSuSVK17CzqPXlU6BPoHD/rC35m2nI1j/SKZGFGBszubodLt48G9lFDuhErjMvT02AXlfaXl4pkWJtEcmUBgYpNMGHZnExpS9hs4BxfF5aMaV@onOix2HV@abjTOYmzmjh3ua6kReN3Uc7rJsgC15vn4PjLh1XrEPvtXI4CGJHJ8@NqS@uo9sQl3BhYasMKQnlEQ3UW/q5WQhILgECJlo2IZomh6CgB/ZC3hf2i7aV9kI1nLCnHvWPXv2ny84QAQ8XN2/NhkQFmwNbZuZHH2SJ7xDWV0Bpfd2Sr9CR14GfjcICQ7Dk6cviTtNh/mG9HfIul@ktyEFmHSqTOQIPp3yw4sFgcxeyRRX4IjkMI8wudDmuHNKTZFU3oXPqkq2FrxxfnPuI/iAXmj5x/1aplHnX8TXv7RUXXVqqHpq5/G74t9YiZpAUDgloSE9Y4/JyvVIIGb8eTD43VUIWLZiCNyIi@T5DiiSpkdL55PR6gDHV@gnL9NQIMc1KwNr484J9GZ@3J@LLZhv1kWZhJkRtweAl68qwsVd9gh1nLrGsb1kegTLarHY8he9Z0COUFAsebyTaG6LzH@8sX6Gm@bbOXOIOf2R/eTTPNDU4qXS0XiZ50OGKg4nN1YLZK5mrY35rwyXdtj8/WhNRmmf7CPQ1nvZCHHG6J@But4wi1IHUgCVfh/ZCJpKta8J@dFufuztcfWHGF9jtiS9V@sWkg1fqf8AsCrCe0QanbqLDsdMEAUPQK8eB1/cbTZZhABMuAF@vOagw5MekUvoxLG/t3GU/9WzN8vzV2B29nGVCrFUW0o1FVdPRwhoxG5TaLadyDh9IrPtXjpi2hBJpi3sD5bw2ZR3JPkHMnF4ZZaxO4DyTNKuYQmuggsU0U8cs12RTTGLTLhCV66NHqY@4AH1D4o9Fy3xSwnjxU@R2cSc6cZTpKR3mHsr3RllqTW5VCogW48Z1rD/xH53JJUbfV87JGnmeR1ZuD@MTn@OrJaldmxKclpZMo/9n@wTtZvWxpgxFgdS113TVVzhrjbzbJ1KeH6Yl3Q7wc3Plua7TDuH5woX2ZOwPSsl@B4z8ZFLDXjJ/0NjW5AphDfIMvdNd/zSb9hSptqaEbQyeLprwUlX2tx7pH7acsiR0rE/617KIPPVgoP/NaeG/8FQm6HzCLMHHcNytf4w4LLJ47F7dYtL/C3lMbvYpOcgoLy6cPcpmTcGSdu@lohp9cLZI1Ie3XOGjsPIk3n1mefx2/HkuKcBdfsxbG8YjZTQzEC6rpfVY2S4PvvwPbInqiRyF5UgAAUgX8KIdPg/KqnQkbvm75xg5r4s@xxiQQTvySuLEVtG8aQqjDkoeviuXZa@1HAtFv@X8OgSC/N@uwycyMrEDkYDEbEiYes1VFHvMlYzBEPImPwiy90y/q89tgiEJ1fruxyNioYLgdzd1DPnbL4TE5QRpvIQ88V9Hu9xX1X1TURqthshGOvznz8U2WXpwJAjFxMp8yvfpIyLUtzfe1DFm2Cgn6jLNpRdodyMhPCCdxxCc4qs6tPHg@V@T3TDmBKbWV4mfEqXnG1hBF4InvU1MoyXArMRyMjoTAMdEvYOcLqgCx5z2veMQB2sPm6Mju5nCkbD2z7/w1exQ49DZ9WE8FKWNvIOWTCWNTnX@NhW7wDQp1Z@NWL/DNEfJbw2l/Dcl68i9S@LDBPFN8f43oZfSagbd6mAeM2Q/4Phg8JxTHK04tGn0xTpoNDi1EzHP0J@1JDY0H/UvMSAvXzPUqnysNBdNin3Jl8XQ0UuVD4eMseJntw7ThKUfCosHq4i/hOOuVAdn5RxhknXJpi1dnYNib7z4YUTx@lykCKx69/5zMyhL5rL21gnAGIh8Q0mVd86RbrlDPuFLqRlX/NmuwcfJNVRGBWM1oymXhh@DlxfJ6p1z9NXrzWEaHJYnKE3KSp/F662jwUu48/Jqy4Eg/1GZgRucNi8cmogH0l/HnuzjrZlCEHhKaHJmg8O9k2OB7AbhOh8iDXsqefRSF2bGg/LMhkuJtp//e0LpFVdZXPaNBgosJW7gvYSz@QkEbeOOcQ9pWJ6EeSRciizV@Q7j/Kvt30tfsVpB13jx73lqv@LnKvbfJL29rLNFBuorSFAKZrZP9yFR/8U@TSd/5PlvJsqq9edUAoi@BdbR1FGhlSoWlF/HUmYpVLINUXAjHLIh53mRzl2AjaWMDPygl9mDcPZS9FnJXr5wQvbzQ41i2I5AqNsLeoozwzmGJ5QA3onPNRYWhZlZzHkvHdGXKTdBRxETlwaggQfjeZfeAyrlVgEhuSuqOPwa8DOYok44OsofF6oiJUdLWisXmf@DgyCiarZNmHWBDhiPx/iqE4PT76uE3pSO3BJmzKkL4/epbbQmlvgZwMQLTICI9dmlf8jQ90yDiI3@RfauOPesCUrG5bIx1nFSgCyJGVrH66r9IN@wdldQQHWAtSqai78q14K@lS72ZeeMa5Pc0dDqO7Bfn2eBYZSzV1Yr2Alv@HGI3YpjGg1PkFJ/Ty4k2sLjyxDca5dPMSWzzs2oeeiDhs@jF57S7W3OsMn42WQ@6qHZkzBKxoykqVKM64A2EZTak6fVkCm3MDWZhU0ix/oHhWEq5RaaP@Op0/LHHGldyP1mFPU1qauJ2TMov57zKwJpJ9G1MNreGn58oAvrfZ7bGrBOj7s16haLQZ53J@oEOUcxYt@m7NqBu4Svxf85MnuwM27UpXlvmrRvT/dp5DqszA0otu0jcnLOYNX@4xcRxDl2cFXA7CoxhqPW3t3xkvyo6qcS3CD8yKkqhBgtj@CGBeLJ1tb5mWq6l2ZJsBOO3JnzBTusfC8k4T79IJW@@jmc6/yf3oZjte4N8Xr2f5jedDaIQ8rldID0rKppBuJ2NaWvcRTd8ZrqqIkvK1DhZHUw/zEmEDP5a5Hn8IU5Z31/JkQWDXvy7iAU0@JDYFKI691dTM54ksdcSzUr13hrSCNdBcAsGr1SFq23RI4@iUhMQ90xAyI4Tja2i@qitfXXjZ@OuWe6f@eTdkUxSSS5ITIMpRr3DAUcj@@cq@/xHryUxvxvwcj9/o0@4gKtCrJpGdDtG0eUBVM0z4BYhn@HyKoIqlUguyUUk2Y2iU7ZVf1qkTSSSFFoLmpH7GnSadogN6uql62rszvrAy6z2wS9Rl0x50RIy85ZaBFahMufkzSz5ytqaJnNPx0Qq4ABv9ApnVfht1BPuGfBnDhtbe86MLGEkn1IvqIH04ha2PRLP1emo6F2MBRg@HRk6b6Mt5VbfG72B3AlXFANDwkclgO0loSdnuZO@qaRkybopy0xX3ZlfVQISbk9XznZqoy@7yTMPwKxLjKeKX31mDLq1@oPDa10UQSCeoEvRT9MjL8sNoZGohoi22R5uBOTUAJGKDly8mtAol@xWGE3kW/TL2Ra34ExZb40zepGr6Z9VNZvtuS@yKZaUHnSUBxkNbhPSHce9Xi6MQwu8YSZPVsJaW0mpeGTJ7jv4GoCRwU7vbFMoP3m85plw3k2902KjHwgL7uRIcJy8FJh0JkLjMSB6IMPV//u@sL4r05JftpINmtSgD@2kYCQi0fUBoyBbk9d7KWzbzzj9vu6r8VT7JW//ptFCi3kbnE0/gf41o2lNiM/mSfc@Br2VoAzacpdRbGg3oK60AZ6Qs5ylUjw1/3ZPYG/svcrMwo3IOeGLJCPbEodkQHrOFb8MwxtKfhPNSeVT92VS4cy6I9nEEdnyQ5Da7Elv5Zx7uUp0Yuf21@AF4FyDZ5L5yZIYmTRh/msqZHwUs3iSpUtfQl4aN7iEg5zUXwZEzWTS3W4m6hexZ803RKd5m8HCKv@I1A5b0tNlcZDAuNpTxF2dxNy5WhQYjH2mHn/0g19DrOE19bO0iGG4tNw8btPzgpKaIGc8wxUhtA5igyzvCAlExoH8a0S6GUcYp2@ztJkQSF7vOF2ajvKRJZfQD/sqsI7sLaNxwmTzORFzScncmKLkjvgU3NfOi3Ry1q2rpvSIhYm6Nb0FOWMth4zfkvOw1zSSQ7r2N2c4x@E1FzR5HocTOC1fDhXV8uHiUnT8Cmn6h03j/XKSzAINKVt54@rIffUVclhTLksW7NjFIj@sNQsTWJZzBjWHqSxPqoOtIRfpi5qFZBKo5mAMcEOtE7GLLw213fiiKB6zsd6az2RUw9aAeM7Jmbvkwm9dMOrOJlpaUxLDWzsWrIr27FjpxHjSSnviIIUWMPySCdoWkYMSXD4ciCa//sqNVmWd756kWEt/b0AlgYVpa2WpdY2kmm7UkcNlUGzOlX3NcGFbYLI1hPdI3fI3z7ZJPVcjazDqgzi/kEk14i9ABcEMpistDXStoC8SQea2Ru1wej0quVgxozdtNb@UDfmkqZMQ3TaW87Za/mjP39hibBLC8EgbKKyIiGwFSjjd1VdMxtfgXtbENs8yo0WBxfBBYqtIiAQgLM6aeRwucDS3N3olx6UrroLegZ4nLL7LYmawN5fjaIiFretbK65R/y09Us@82@jfWIXdAYfPs@B6Awnwf2gHzhzb36iLkoBqpnvx/KXizYBVZ14YslfeOQ0jQLnH60ZMjkWFBFrR0eH@ZBqfKI40ayltjRKgijKEkm4vsw7XGkO0qQrNq/zrFuahnec/ivtROqfykaVpuLFely9sR6bguQhGWj4awbUtawYNpOL/nnEQ1ctKl83A9cj2PMlw5pbSESxhGbE7fUt5Gr217FCc4qHKqVDyMBO8pOPx7JzD7laTVhzFvG@FO/kh6LrWvgU9NoJFpva7p3dUJrN4WOZJgDw@6EaygPdAY/uKjpAEiFCTuKA2XY0CqEEq8P@z3c1p4okJ2mQd7DBGkXnUNGYuNO/OVlzfupHF59LSWu@exvFm6Ock2kBo4TExI3K3Z@pLm7M15Y67kNovOtdTQbyGoCTPkIR7kN72dcaeU1dmG6xjrw1YpX4mCDscVr9UHb/OUtnAbrYonA6aQlyQ3kWOfYRr85d88gb81rDwc5XnzNNeNN7F7L4q3vC4rlrYBNAcJ7Q2eShdCU1C/Z54Aw0fwe/ttInVHX5IFXk1VXMpas41pD5qzp8mh9nE8a57VmgTy1m8BtLpZYazolgcRoEtqw/GD9ar7q7IhKeT@/C@ramZiklwWXytp5vVX1NaIzf/9JpvoNTzNDg8lDEbUH3fewFfW7YM1uvXsFn7V4puEhEsDWPg/IfuouwBjgnyGP/NLjOUpAQJv1jqb5YItd7W37w5YtzNY9masZE9hbbOUU8jP3AeO088gm@RXqO/r6qtdgJTXUH@jdqfGbdQ0IDJsxoHmKOJ6Q70e9keAsCenKdUU3Anna008c0Dqdq/gjGfnHgNKsilPgNi8AoLM5xrKawG0poK@CSrqvTpiNmbIJ58pLHXsf4bTnI0zSAQF@axnGpeR2Y9/WR9TS33/Pdko03elmOzNaamwGE4Q3wre2B12hR70OueHvmKW0fVIlBKA9hNXHl2ydDRpYHHqTMk0FvT0JuAQ1X0RQhhmLAGiTOpy@jQfgb6WXx8fN7lYIppgKacFW@jcLIacyDd9VyMmcjlbl26cNoAUtL81NLaZVu2YoSga0CHprI0b7uWANWQ4axYzzDnelc5C60RaaDwLT0PW806RhmkZzKYRF6WWmYW@eANLGD/Q0m37JQ/hOm8iTipfBklCGGLKa6PklZxD9wwZuNXBwaUZ@3lCCrvgmfTG@Lq1QqXqtJ965zWtLyTmu1RxBOuFadAwfQ2v5z5rYGGworhCAOae7z9bkv9l@FdvJ8znRc@JsUVgB6bKAy14Vf1RAGCi9q85zkvCDTNTY8nibIYKJ//NTmimYL4UgjD358AwZKy4e@/QeVb1eO9jGKQXPJjeEOrZK@v9F/1fzfE522QZqa9X5YQ7/GHzIAKVCBphwSXPOupQ9oqJrrZlV7dGV9AgQ2dK4GN49CML6E8mz9RgJHVemvI8SRyuAkQfF6aUgFOjN8aWQ1xvFNUv1ke7s0aa2DZD0k8Iz8oO7QM@qWE0Js7Ymbqbhl3lzZ@JYgNTXtCB4wJx6aJgu32Y0TqrX9JT0wEyPeFnc7XIHm9gYp7RdMHi02IUBP/de6XCaK24VDHqq1PsTx/UDDw/9cUgoSBe141X0pXCrwjlnCdpvoPplscKKxrCGUg/9oeXhxH8iONHSgeyCh03UGcFta@LWDjSFVFtmMjR9JumCiTxIa4NrapV3@WzaL/qoJYCSkwn0ZNwLGWJK3WKgfcCwfwqj3PHTOLq2XJkS0sW@29mGq3NDQsj7KG6iJHvr04/RR4yrmn4rjSWcmCLj1FwVpLew1cyJUAswqJUifeUzxC9jjq/JrAHD/rSbV1NTkMgu8RkFl7Shqv2K/Icsf2F6Rk6rodRlc0Gg6Z4ejVQORzQWzK71uE5X1BHlXHU/Kjey6v3gv5TwTTpssT50egthK2RlUsc1llx1HBZRInvPWJVJLrV6x88GLnUoQobkDyxX0xX2A48YfyiFjQ95GLWEnFZq5A1k2RQiDTPlIK67a5@x2/iuWm4Kj@zzVYOn83TlCmcJkaFtMKMnw0kSA0Bxvqa@Tfk59FhEgSQW6xsVq8yiNznB@irBoTDvuWuKT4zdcfESreuKBypJMM/IFsE2NrtcpzNMxoOzvLAEREA@txauslwEDzyXD5zW/JXCDxB3U5bijaZAWX5jWxKimzJ4QExQa0k1mh18RdR8ObObz1lY9dPj9kAo6IZVmVDnT5PNh0OV08UaTbLBEOPNV7zdR6On8suIZUYePgsNAQbdRluCbf8lkRTR@BMgv9sx9gLHZqqJHn6JNJW5WdgBGooksl3t8bnmaRO2zKPIIVr1oPOPz5ETfRUrWjwwdurKeELNec@kpc2YE2Ii7vPO2cR46MqxXBmtYvQmtzdo88o2IN7w2raeb81hjBLU87CzBTRSXCV/H2xuDXJP5lNAP9iHXalMzat8ALuWo4wi9rbtHhCuY970h5P@qmoznB7miZ1HByzwvw14RqaWbA@nUkJ38bDiV52P4M5jT7EXP0BJKk7qkppbh8P7APARL4gLUsXbMhTLUKMfx1TDQgXVyjQIBqzipGVg6sL0sJfDZlWfncqhUa9PJbQyKxnJxbr83xNsU@Kdy3pkvdTZm2zhLpxsGHW4LWf2u/ZilGPdpAOASqXwhic6gyob3z/NbGR9D5p8Ru3rc09xdRQwXZEOW0TEyjwk2ACGfEQKVsfq3R9eiByHr7C6n@miZ@NuaMwMHVIboEZknVtLks20svIhjoKAFoGidIg0BcTn6vWVmNDExSfTcGEFfX2CS6av1uZtY9ALJ@1PetsvfE9NdkeDLr5MWwL5@9tMXNm18wGzYEhfOVUXT0tl/ThetwYhjo1RchVGJE0I@sL6wXGeCMLgmgvAKHs23eG/qlXSAjWvuu8v47VodOZ7@JnxHK4/fpgkqvyF72EDpwdg64R97H6F6iyb6UHXfeL5Evt@ZqCHF3PjqOiHwmlj0bBq7woENNmi061i/8NaYdHTf71rN2lbWu8rbJzoYrppDJqOlXnXblwmxyrnAvxYjBabaj3hW@bNOxEcPunPspCZC7lKY0IjvwfotZDCA8Fz7yNfnduj@bFQxRgJpdDenYv8X@ThspirrhI8OALyHPkxg6g7dGzBVf0d4zGUYvKRP@4f8YUCQOriAtX21KPY4v5YAg1ZAYLlMywbOx6w6ZDHV/cBOc@acBsQw77KU0zI2FPbtO5IMYqTQT6JFRQnSODMPKrupqmDSyqz6xQW/nsh7LAGBb3J1jYZu4ekj2TBDP4hGdgPP8zO0ty17kr3QkZBJlJXeMW@I2OAF0zEj6X9Od9GjKqe26X6NzUMx0jYwQIWHJPLHZ3YqwM1ZCnoZaZ4DtJv5EGgrtV2tVmpvRSQJEzvvL7mLPsUiRIaxTKkhMmdUytsIH0gsBrWSksCF36iUL4kcjGpvOSKO0N2dmTXPNVpVXNJeiqHR5d1xpUHhKQMJxYO0llj/EPno0zjjUrCBqvLAGFGeerj@KXZsvXi0DCnx4pvFaAaooGgBeDqLuQXXfeAdzL@9oFr@GlcVKr0dj7DbD5mXfyaIJlHs1n/BYxoHNPMsr5Vn9FSTMs3GfKPBHXDCc0mWdoZeBqX69a3yBLvGZXT9ZwZbaormAv1Cyd18VEQVLk@uuWoR3eiMtZdgU5RI6TlctYc95NjXbSk9/mT3bGVeOcFdzNZ5813z6uSz2/hmPN88kK@58jhedDM8gVv0WE5SBUHEyo1/mNtTWcsA7y9XY7IqDeERkCXBLkzdyn8DQJq1/GqmawTtiqlpcfNG2@ZpeLxW/lqdvDWriZvVmPNzAnhAv7PfrXMMKDQq50vffy4BGg8Y6shvegA4ibXif4yoRC10kZF0mniJ8deTynTxz46XYeNC/KGgUGsaxW@YBrG/TAr/GKadZx8dhC/d/Ld1Zgts4EkXRLXEAp/0vzM5zQ99dnZZEEAi88egjXiOxoF3G7jVg8gYRDZ8Ra8xsVKpSlpEEkJsuMBNfx6loI6kSA0UkqHFVmtb2njppSyEvQeBolvv2KU45sj6G3gmIHDRREZkcJFbN/YkB2McQpg/iLpItX34d5@hLnULPEUaGVabQ6B@Kj79rnITQyJVbXx4O9/R3ID9@@D259SrmBothmFeu7U@WFbel3UIguubwM15KvOAEVS@B4OtG2eB59cFpIrrqPZHiv/XfQUP7GwjSXyUqKTWZmQdh6xVtQ3jFhJnQGeT7pnwdewzUssz@Nz@rL8PLuidWhnAaEgkTu@pfA7ELKzpGSaEHJEuZblzC6qi6c@5Uhum7lkcC5UJpdfrREpC18ynfrUOuMdMW4KTYLjynklNxXOS5WaQjEk1etGdewknOzChQDGcescTvT2L6ezKMnaGrpNeSMPIReX3HRF9Hlq9AUmLPDmNHh2YE3Jj4aUSCZa4JzZmLCR73S8JmFDXzvpN3VIGCO2ChVrkQa684vgoBPeLv11ItZOeKzHOFKrUKZXJ2A6c4a9IOOqpBk2S8etUTHMj6fxeqn7YBEeuWQCF81TLDs0KV5AVwttuVwaOQpmRBbz2jAle3cp5WFddnUnib5OMH2wMtve1Ge0HVOqj1NIQMUbNVOm1@IWChTJNMhjs18L4jyJ9K14t7IZqm6qZtbi72y/AKD/vNg1cPriIJNMjIAJ6xu@1D01wpx21qIvmvacl5U/RVD7Lq4HbegYGy/stPQDacgazGqhIFWEbURJXhgdx90y6cYo5lOng43WGteQhpAp5qDY0qyqbePvCXssoWGOufJANmiKjoeD4zhXd7xa66v4As6GDLRn7oFL/YjavSdjvmHjQIioQRK8RjIL6qx7gT@RyF3eMf2GJ0XLgAH@kv6ZFEG113YZaMGl14JuyW3ksixF4zWQjt3u2hz52S8ChP3AtO9QP@ThHR5/KLs2l1YlaHWhpp@z9EUw6t1g5jhmtmZXi8f28VWSyFW/VwWDxbeE5yBnuyRClJpS23e@@RkU9u46PcQLKma6oTCs6xq4z1ujpGfSGCLkCTT4LLKzcRWx7i56tXd42yatnw3xqJQ89BMTlLTHBX2miPtzLaQOnqw49SQrasYHeS8yu1dRlJKaNdQTFJIkq4SsgX3mTcvvo7EYYID4ef4Tf381nmXME08M2q3M0X23xvA4ZNIdfDW6zy0xtiiN6TdvN3Aoz838D3K7lFOapncrdi69MxEzCgUL63g8u@ekdf36WS2JEAzUXyWNtvv7CxA2a0V1klYfHIngUi6JpTlcAWQswgZROoItlFBIdG0Ut/arOqsSvr3Ypiu6eWwhBEkUlbauIt@oq0RqysGa9INNQkjI76jF3gGPjnKZ9es9P61Y8CoCtu3wo3JZWhvKkeoC60uFNtk2dIT6XqAVAey13CJuNjdTnncLrCjZiCk5W805t113bY8Bvc5RqdR8IxuLXaV@qiM1NzCVtqaWEc3i@xJISFX2XuZkLHQpwcxoO7wE@KKidYAQx9XfaKE03dDh68p38n5Uc6ACIrUxDrAaXS0XB92raZQZJ4Bj5jidzkUEeGFmAigobJctXOQ@PK6rs1G@JIK47m9sdfF1ZoxaU8rrAEsSrEImHBSEeeStS9uK496DEX9GvIdJMeiQGYSS6XeWx/a9ouQiP5VH5NYOEHVkLCKTuiBgufK0dU8Alxm9sfp6@zm9SMOAksLvCZd9eJVs/CnW3xKBmrImZb6J2qycWkVBU3htVFy4RwpPi4xlW9iqbZZps5I@RVUNEOAsr2xsRGtS9Fs83aJmD2DP4RBjRhrJMIBHJ2FrJ64YT5JLKhgnKcMk1naxr/uPn3KrYACTpwSzHxb65wsjLmBK4uXMbqFzGU2Oh8bHASIrvQ9xgl@/5ZBcRbNMxreKlVrK5eExMWKk9gPX5bVULil8qu44fqDvd22g7W/1S5swoYEgBMTe@4gldTUdPzeJHNp@bzlnbl7TyeZ8zwU5WCj@xudHeXyl@wGie2KCIYkkFDBELPL9MXI0alAcA99yKRiC6SK3GU8acshC@vf7@vW5Nb15FI7CvP3/bqN4FaGWxEPhR0pbD4tWoNjk71xMQFwDVY1seMYp10mlFVvcW3PqnHRfzrzKGVfPLJTEtW56prZIPYVVlIpmcwBtlfuRF@G4gdthQzmwkd2/3WbMPrd1VOd1VzRBW27XGiekmcsj1mIwF@nnZnWBmomdkDig0p4HEQAXgUMkncYhAwRjqxjNr0HLMULMzyt1g5e1QQpXuo0Olv3RPKllrzqMPR@eBv4XjLPGUzeuMg3Hzbqywvewefi/ccfARHIR/dxT7sRZjvxWbGtVcgJ/QOQPi@IZvCtSRZ0mhB4b46LlybPG6xZ8RPco1LLwQvpBIlhTwjve1hoq7QBCn1cMXxykcb5j5yytrfkKyEsv7IXY8bRw2JiMH6rrFupyQlvcNAhjUWSuua0lRPv1qySPGrd/igl/aeDchqPytpqrq5yBS5IorXiGOvQXO28sAqsim1/ys5eGIiVNI4yJ7amrnz7ZES0t8GyaM1c5Xn/ishivJT0764YdxWW7jiLunAqAunYqKKi9rS6h4pTDwmlhqKMXqqq48UGLVJle3HA02hWDyv2KuR0/FLeXRYM3wEqsOvQQjApWtZm4nC10vKy@MoaVEATbIj3kg7/lvoDbeaKY4EHeRi2GCcZNR2NdsqgIAmOVXM2dFQDt8tg@xVmt89UMSqIg62S8rsrbwlv2e701Np7kH2TWWN9UZ8R6DtjEuEkJziKJT0LIx3SprApOU1woKYA7BHzMLb@DBwTV/H5qruxqQmTc/7kbGmj/kV2Ewd2VRHmlhtUhYjE/zV/YN8bWZPYO3VuZhle0@UBZrfp6QGesl4hQ5mmqum283E4nJFyaFSUR@xXAvfCpr58ywGRQ6X2dTSTN7/1B3hGHsmIxfxdZdOaTbypNiDvqYCl3DpHwU0exUqaIDWUa8By94yi7eKSt0Ogx5LDK0K8hMKCVcFqFZ7UKlBYdtAtYHp1xWNJnLCZFxIn5OKzk60XeD@Ko8zWcVTjd9HBQ9vY7lhUzVAsSx2hLPNqsiNzzjOarArIYyedEJRPJcIgELZ6xexXlZxQCQKmBFLIDDYyJPuFQLifjANkAAF@x61MuYgqaGQTsMWiYBxoNrU3k4XjUxnrkrFpL1b6vlnQsVXhX3PXlyuS0ZJS46KXkf5jmJ/Q1iToaZf@PuQT6mL/c@Is8gqLaer3NBVB4z3xRG5Jf8vAZQq4m8bLFHnTdQC5FDMhXUlePNS@HfvSZG2cdWsQUGbtu4LKrznvlNlBiJ2bz0AoD5KYV8aGty7Q4NWfsY7Ut01BUwdAH5ecBHIz6plargKxzT1lmgWPrDKnvdrCWcpXY5gQaWzqJ@vyO@q2/1LdKECoL@Elnvbhf/0GdcjTfX0GiWh/wLe6Iyz7h71cHWAwPOFHJPkbVF@vetHhNmXUQogTb1rbVf4nIWOhb/618I6Y0QVDMh@qhQbL7Qn4wdWajukM3f@cfvU12pTu7Iel5njzE8QcuRHknIbdFQMduI@IbtGWXEekowc/egZHqc8wnh7@bu1FtJKfsXLmSqwXE/dC47Z0hCfs9kss3scDkFGjn4c3QuRA0fYAJPXF7v1RapKNGA8QGFfRcc@a7II7s4WUK0DsWEHcOamjByDX/shsh6bHMwKhuB7DO5gwcLCyOO/oMGi@3xN8CqkiHx05eixpM/osL35n5oOSnXW0FrkgqBMCOVTx249D0U0ErtlfE0ZmzJ74rZMAVRaT8GhFYOgcqm8LtTZ0a5uGPTsfTNCe46u4htGn2BgnTS@mmx4vrUqbLXIXz9tAGaFrKHqzLJ1l7@4PWE4vgtJMSR4KzIXUe1uaqNBLdlmFFaL0nRq5KRS5wP1g5bUjAf/N3PTRka/rm/qncjlgVkAqlUbBVuT7u4tD4y0AZJxihRXDLDOXVOE3VdvBM/yN8Zt0fh3jr17L2kpQZACYTF77/rBqiGMxFHgB/xYkkdUyRnmB0fgppSJiDvYo0v3utEkEn1Ta3Z30BOESk954wJgBzlOYL8GlpI53RGZBUjmTeV3COk3uoZVaOh4O@v9kt1DxC1TyOotoI86nDZyC3r1XDQknBPbyDkrinAl4Tkr2NbsVn4VAeVTfQYiepacFm1iSfi5V@VM7@B19eQKCEDw8VyJBDHjnT7VU0P8nQaO8MebTufq21WMXCzDNXW6vHwhcYALbwKOzqXiKM0v1Km@N1MdF36uMTFxNPxL5IKpIPE7dhZSfGe3vBKQGj@u0lqm8Mvt8@@t20owhkI99cEa5GsaToNzVsZlP3j3SdC9Wn3EbmhQbQSGBZmQaQMZYwVTOByjAxxdBWCxtzJdsoA8@79//wE" rel="nofollow noreferrer">here</a></p>
</div>
<div id="pu4" class="pu"><h1>Haskell, 81 bytes</h1>
<pre><code>f n|n&lt;3=1|even n=fk*(2*f(k+1)-fk)|1&gt;0=f(k+1)^2+fk^2 where k=n`div`2;fk=f k
f$10^9
</code></pre>
<p><strong>Explanation</strong></p>
<p><code>f n</code> recursively computes the <code>n</code>th fibonacci number using the recurrence from xnor's answer with common-subexpression elimination. Unlike the other solutions which have been posted, which use O(log(n)) multiplications, we have a O(log(n))-depth recursion with a branching factor of 2, for a complexity of O(n) multiplications.</p>
<p>However, all is not lost! Because almost all calls will be near the bottom of the recursion tree, we can use fast native arithmetic where possible and avoid lots of manipulation of huge bignums. It spits out an answer in a couple of minutes on my machine.</p>
</div>
<div id="pu5" class="pu"><h1>Ruby, 63 bytes</h1>

<p>man, I'm bad at golfing ruby; but the BigInt class does wonders for this kind of stuff. We use the same algorithm as Anders Kaseorg.</p>

<pre><code>require 'matrix'
m=Matrix
puts m[[1,1],[1,0]]**10**9*m[[1],[1]]
</code></pre>
</div>
<div id="pu6" class="pu"><h1><a href="https://docs.python.org/2/" rel="noreferrer">Python 2</a> + sympy, 72 bytes</h1>



<pre class="lang-python prettyprint-override"><code>from sympy import*
n=sqrt(5)
print'7'+`((.5+n/2)**1e9/n).evalf(1e3)`[2:]
</code></pre>

<p><a href="https://tio.run/##K6gsycjPM/r/P60oP1ehuDK3oFIhM7cgv6hEiyvPtriwqETDVJOroCgzr0TdXF07QUNDz1Q7T99IU0vLMNVSP09TL7UsMSdNwzDVWDMh2sgq9v9/AA" rel="noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>

<p>-10 bytes by removing the practically-0 term thanks to Jeff Dege<br>
-1 byte (1000 -> 1e3 thanks to Zacharý)<br>
-2 bytes by removing the unnecessary variable thanks to Erik the Outgolfer<br>
-2 bytes by moving to Python 2 thanks to Zacharý<br>
-3 bytes by 11'ing the <code>-11</code> thanks to ThePirateBay 
-3 bytes by swapping <code>str</code> for backticks thanks to notjagan  </p>

<p>now beats OP's unposted haskell solution!</p>
</div>
<div id="pu7" class="pu"><h1>T-SQL, <s>422 414</s> 453 bytes (Verified, now competing!)</h1>
<p><strong>EDIT 2</strong>: Changed to <s><code>INT  BIGINT</code></s> <code>DECIMAL(37,0)</code>, Gained a few bytes but increased speed enough to complete to 1 billion! Completed in <strong>45 hours 29 minutes</strong>, verifies against the given string, and displays an additional 8 characters (which may or may not be right due to rounding errors).</p>
<p>T-SQL has no native &quot;huge number&quot; support, so had to roll my own text-based huge number adder using 1008-character strings:</p>
<pre class="lang-sql prettyprint-override"><code>DECLARE @a char(1008)=REPLICATE('0',1008),@ char(1008)=REPLICATE('0',1007)+'1',@c varchar(max),@x bigint=1,@y int,@t varchar(37),@f int=0o:SELECT @x+=1,@c='',@y=1i:SELECT @t=CONVERT(DECIMAL(37,0),RIGHT(@a,36))+CONVERT(DECIMAL(37,0),RIGHT(@,36))+@f,@a=RIGHT(@a,36)+@a,@=RIGHT(@,36)+@,@c=RIGHT(REPLICATE('0',36)+@t,36)+@c,@y+=1IF LEN(@t)&gt;36SET @f=1 ELSE SET @f=0IF @y&lt;29GOTO i
IF @f=1SELECT @a='0'+@,@='1'+@c ELSE SELECT @a=@,@=@c
If @x&lt;1e9 GOTO o
PRINT @
</code></pre>
<p>Here's the formatted version with comments:</p>
<pre class="lang-sql prettyprint-override"><code>DECLARE @a char(1008)=REPLICATE('0',1008)       --fib(a), have to manually fill
       ,@ char(1008)=REPLICATE('0',1007)+'1'    --fib(b), shortened variable
       ,@c varchar(max), @x bigint=1, @y int, @t varchar(37), @f int=0
o:  --outer loop
    SELECT @x+=1, @c='', @y=1
    i:  --inner loop
        SELECT @t=CONVERT(DECIMAL(37,0),RIGHT(@a,36))      --adds last chunk of string
                 +CONVERT(DECIMAL(37,0),RIGHT(@,36)) + @f
              ,@a=RIGHT(@a,36)+@a                          --&quot;rotates&quot; the strings
              ,@=RIGHT(@,36)+@
              ,@c=RIGHT(REPLICATE('0',36)+@t,36)+@c        --combines result
              ,@y+=1
        IF LEN(@t)&gt;36 SET @f=1 ELSE SET @f=0               --flag for carrying the 1
     IF @y&lt;29 GOTO i                                       --28 * 36 digits = 1008 places
     IF @f=1 SELECT @a='0'+@, @='1'+@c                     --manually carries the 1
        ELSE SELECT @a=@, @=@c
If @x&lt;1e9 GOTO o
PRINT @
</code></pre>
<p>Basically I'm manually manipulating 1008-character zero-filled strings representing my two Fibonacci variables, <code>@a</code> and <code>@</code>.</p>
<p>I add them <s>8 18</s> 36 digits at a time, by stripping off the last 36 digits, converting to a manageable numeric type (<code>DECIMAL(37,0)</code>), adding them up, then smashing it back into another long string <code>@c</code>. I then &quot;rotate&quot; <code>@a</code> and <code>@</code> by moving the last 36 digits to the front, and repeating the process. 28 rotations * 36 digits covers all 1008. I have to &quot;carry the one&quot; manually.</p>
<p>Once our number starts to exceed my string length, I &quot;shift left&quot; and we start to lose some precision, but the error is well within my extra characters.</p>
<p>I tried using a SQL table full of INTs and BIGINTs, with similar logic, and it was <em>dramatically</em> slower. Weird.</p>
</div>
<div id="pu8" class="pu"><h1>Mathematica, 15 <del>34</del> bytes</h1>

<p><code>Fibonacci</code> <strong>itself</strong> takes ~6s on my computer. And 95(+/-5)s for frontend to display it.</p>

<pre><code>Fibonacci@1*^9&amp;
</code></pre>

<p><a href="https://i.sstatic.net/3RJR5.png" rel="noreferrer"><img src="https://i.sstatic.net/3RJR5.png" alt="enter image description here"></a></p>

<p>The first 1000 digits (34 bytes): <code>⌊Fibonacci@1*^9/1*^208986640⌋&amp;</code></p>

<p><a href="https://i.sstatic.net/0H4OU.png" rel="noreferrer"><img src="https://i.sstatic.net/0H4OU.png" alt="test 1"></a></p>

<p>Longer but faster <code>ToString@Fibonacci@1*^9~StringTake~1000&amp;</code>:</p>

<p><a href="https://i.sstatic.net/vcZTn.png" rel="noreferrer"><img src="https://i.sstatic.net/vcZTn.png" alt="test screenshot"></a></p>
</div>
<div id="pu9" class="pu"><h1><a href="http://pari.math.u-bordeaux.fr/" rel="nofollow noreferrer">Pari/GP</a>, 15 + 5 = 20 bytes</h1>

<pre><code>fibonacci(10^9)
</code></pre>

<p>Run with the command line option <code>-s1g</code> to allocate 1 Gbytes of memory.</p>
</div>
<div id="pu10" class="pu"><h1>Haskell, <s>83</s> 61 bytes</h1>



<pre class="lang-hs prettyprint-override"><code>p(a,b)(c,d)=(a*d+b*c-a*c,a*c+b*d)
t g=g.g.g
t(t$t=&lt;&lt;t.p)(1,1)
</code></pre>

<p>Outputs (<em>F</em><sub>1000000000</sub>,<em>F</em><sub>1000000001</sub>).  On my laptop, it correctly prints the left paren and the first 1000 digits within 133 seconds, using 1.35 GiB of memory.</p>

<h3>How it works</h3>

<p>The Fibonacci recurrence can be solved using matrix exponentiation:</p>

<p>[<em>F</em><sub><em>i</em> − 1</sub>, <em>F</em><sub><em>i</em></sub>; <em>F</em><sub><em>i</em></sub>, <em>F</em><sub><em>i</em> + 1</sub>] = [0, 1; 1, 1]<sup><em>i</em></sup>,</p>

<p>from which we derive these identities:</p>

<p>[<em>F</em><sub><em>i</em> + <em>j</em> − 1</sub>, <em>F</em><sub><em>i</em> + <em>j</em></sub>; <em>F</em><sub><em>i</em> + <em>j</em></sub>, <em>F</em><sub><em>i</em> + <em>j</em> + 1</sub>] = [<em>F</em><sub><em>i</em> − 1</sub>, <em>F</em><sub><em>i</em></sub>; <em>F</em><sub><em>i</em></sub>, <em>F</em><sub><em>i</em> + 1</sub>] ⋅ [<em>F</em><sub><em>j</em> − 1</sub>, <em>F</em><sub><em>j</em></sub>; <em>F</em><sub><em>j</em></sub>, <em>F</em><sub><em>j</em> + 1</sub>],<br>
<em>F</em><sub><em>i</em> + <em>j</em></sub> = <em>F</em><sub><em>i</em> + 1</sub><em>F</em><sub><em>j</em> + 1</sub> − <em>F</em><sub><em>i</em> − 1</sub><em>F</em><sub><em>j</em> − 1</sub> = <em>F</em><sub><em>i</em> + 1</sub><em>F</em><sub><em>j</em> + 1</sub> − (<em>F</em><sub><em>i</em> + 1</sub> − <em>F</em><sub><em>i</em></sub>)(<em>F</em><sub><em>j</em> + 1</sub> − <em>F</em><sub><em>j</em></sub>),<br>
<em>F</em><sub><em>i</em> + <em>j</em> + 1</sub> = <em>F</em><sub><em>i</em></sub><em>F</em><sub><em>j</em></sub> + <em>F</em><sub><em>i</em> + 1</sub><em>F</em><sub><em>j</em> + 1</sub>.</p>

<p>The <code>p</code> function computes (<em>F</em><sub><em>i</em> + <em>j</em></sub>, <em>F</em><sub><em>i</em> + <em>j</em> + 1</sub>) given (<em>F</em><sub><em>i</em></sub>, <em>F</em><sub><em>i</em> + 1</sub>) and (<em>F</em><sub><em>j</em></sub>, <em>F</em><sub><em>j</em> + 1</sub>).  Writing <code>f n</code> for (<em>F</em><sub><em>i</em></sub>, <em>F</em><sub><em>i</em> + 1</sub>), we have <code>p (f i) (f j)</code> = <code>f (i + j)</code>.</p>

<p>Then,</p>

<p><code>(t=&lt;&lt;t.p) (f i)</code><br>
= <code>t ((t.p) (f i)) (f i)</code><br>
= <code>t (p (f i).p (f i).p (f i)) (f i)</code><br>
= <code>(p (f i).p (f i).p (f i).p (f i).p (f i).p (f i).p (f i).p (f i).p (f i)) (f i)</code><br>
= <code>f (10 * i)</code>,</p>

<p><code>(t$t=&lt;&lt;t.p) (f i)</code><br>
= <code>((t=&lt;&lt;t.p).(t=&lt;&lt;t.p).(t=&lt;&lt;t.p)) (f i)</code><br>
= <code>f (10^3 * i)</code>,</p>

<p><code>t(t$t=&lt;&lt;t.p) (f i)</code><br>
= <code>((t$t=&lt;&lt;t.p).(t$t=&lt;&lt;t.p).(t$t=&lt;&lt;t.p)) (f i)</code><br>
= <code>f (10^9 * i)</code>,</p>

<p>and we plug in <code>f 1</code> = <code>(1,1)</code>.</p>
</div>
<div id="pu11" class="pu"><h1>Python 2, 70 bytes</h1>

<pre class="lang-python prettyprint-override"><code>a,b=0,1
i=1e9
while i:
 a,b=b,a+b;i-=1
 if a&gt;&gt;3360:a/=10;b/=10
print a
</code></pre>

<p>This ran in 18 minutes and 31 seconds on my laptop, producing the correct 1000 digits followed by <code>74100118580</code> (the correct following digits are <code>74248787892</code>).</p>
</div>
<div id="pu12" class="pu"><h1><a href="https://www.haskell.org/" rel="noreferrer">Haskell</a>, 78  bytes</h1>



<pre class="lang-hs prettyprint-override"><code>(a%b)n|n&lt;1=b|odd n=b%(a+b)$n-1|r&lt;-2*a*b-a*a=r%(a*a+b*b)$div n 2
1%0$2143923439
</code></pre>

<p><a href="https://tio.run/##DcnBCoMwDADQ@74ihxY0UrDVy8B8TEKVlWmUOnbqv9de3uV9@P6u@15rx1Z6Lbp4knLGCEpiOx6kN@p8yYsLyCiOkSm3wFbYMqY/KITXRt6OJvh5eoepUQ9OCgRXTvoDA1t9AA" rel="noreferrer" title="Haskell – Try It Online">Try it online!</a></p>

<p>Took 48 seconds on TIO. Same recursive formula as <a href="https://codegolf.stackexchange.com/a/133647/20260">my Python answer</a>, but without truncating. </p>

<p>The constant <code>2143923439</code> is <code>10**9-1</code>, reversed in binary, and with an extra 1 at the end. Iterating through its binary digits in reverse simulates iterating through the binary digits of <code>10**9-1</code>. It seems shorter to hardcode this than to compute it.</p>
</div>
<div id="pu13" class="pu"><h1><a href="https://www.haskell.org/" rel="noreferrer">Haskell</a>, <s>202</s> <s>184</s> <s>174</s> <s>173</s> <s>170</s> <s>168</s> <s>164</s>  162 bytes</h1>



<pre class="lang-hs prettyprint-override"><code>(a,b)!(c,d)=a*c+b*d
l x=((34,55)!x,(55,89)!x)
f(a,b)|x&lt;-l(a,b)=(x!l(b-a,a),x!x)
r=l.f
k=f.f.f
j=f.r.r.r.r
main=print$take 1000$show$fst$f$r$k$k$r$k$j$f$r$j$r(0,1)
</code></pre>

<p><a href="https://tio.run/##JYrbCoMwEETf8xUK@7BpV4m0gRaaj1kvQU1qSxSah/57Gi0HZs7AjLy6wfuUkKmVJXbUS8On7tyeeuGLaBAvV9JalpFQa7rds0lhj/s3Pip/mMFYemwrJpYU90cwvrbCGVtnxJw7/BFPnhbzDtOywcZuKBqlFKzj6wN23cBCAJfZcz7WDAEVNTKlHw" rel="noreferrer" title="Haskell – Try It Online">Try it online!</a></p>

<h2>Explanation</h2>

<p>This uses a rather fast way to calculate fibonacci numbers.  The function <code>l</code> takes two fibonacci numbers and calculates the fibonacci numbers 10 later, while <code>f</code> takes the <strong>n</strong>th and <strong>n+1</strong>th fibonacci numbers and calculates the <strong>2n+20</strong>th and <strong>2n+21</strong>th fibonacci numbers.  I chain them rather haphazardly to get 1 billion and grab the first 1000 digits.</p>
</div>
<div id="pu14" class="pu"><h1><a href="https://docs.python.org/2/" rel="noreferrer">Python 2</a>, 106 bytes</h1>



<pre class="lang-python prettyprint-override"><code>a,b=0,1
for c in bin(10**9):
 a,b=2*a*b-a*a,a*a+b*b
 if'1'==c:a,b=b,a+b
 while a&gt;&gt;3340:a/=10;b/=10
print a
</code></pre>

<p><a href="https://tio.run/##NZTbbhMwEETf8xV5A0IRe/HeisK/JAhEJNRCVQnx9eW4iMpNHO@uPTM79s8/z98fH@zl5XJ3PcudHr49Ph2/HG8Px@vt4a3K6TTv7g/HHbXT5XT9cDld7vh/fz1dD8fbtzf65nz@cr/j1ztWD8ff328/vh4vnz@7L7m/fDyrfLruz8PPp9vD8/Hy8utcE@ZaXStiZfvKahvv0Emd0tXaY0HQtEldPj3qK1x8xosFW5md2kaNl0jIzKSlekZk1TgpbeJR5ma2Qs3SRtl9RVpFEo5ZM@yaaqrqohzKStekT2hKcOhUj2jvQ7KAMkBeqxdgCE6LLZ2xJcuLfNEJUTiwnXD4sgzx6qXMyIaLd3kKS8ZwinMFpFixvShSMEgZqf0nrs2IWisjw9PCQzXEEKw0wMpvMZBJAsShFasU2kkxesjmupzMjM7ulNVIQGlpjiblEKpG61oMp6TRY4TgqxZS/orcNmRmTOEoVon4sWBGAJoUL89VVE@jORKvNJQNo@cb6S6llTCSKEAWopMNP2ViG3c68qGWbNpbLbFAOim6h2lkQGDGHJRw2pVJUbd70RcogDDLaTWcjLoJ3NItVIxGe2GIAd7uGP4xUUQlUxj0nAq6N92FoSwKpUmZ1/LNF186fkWAkl5TQAA3@3o03vJRWYhes9YoW9IsNMF9xvdsAwquY8PtJHRairlwMozxygIFBt5mFPXIV9LbYtgRwsE5tJ3egBSTOrbgdnCWO0JbIiIKIwje22fMZolRsX/AbXckw1Cr95VwwpgRRzhYcBacAFu7gVk5xmXd/Pad4HCggbmnQEQSdmXz3vcIBwRb4B1Sd3NnDof/r8F@SRRt/z0I/5@C8/nXy18" rel="noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>

<p>No libraries, just integer arithmetic. Runs almost instantly.</p>

<p>The core is the divide-and-conquer identity:</p>

<pre class="lang-python prettyprint-override"><code>f(2*n)   = 2*f(n)*f(n+1) - f(n)^2
f(2*n+1) = f(n)^2 + f(n+1)^2
</code></pre>

<p>This lets us update <code>(a,b) = (f(n),f(n+1))</code> to double <code>n -&gt; 2*n</code>. Since we want to get <code>n=10**9</code>, this takes only <code>log_2(10**9)=30</code> iterations.  We build <code>n</code> up to <code>10**9</code> by repeatedly doing <code>n-&gt;2*n+c</code> for each digit <code>c</code> of its binary expansion. When <code>c==1</code>, the doubled value is shifted up <code>2*n -&gt; 2*n+1</code> with a one-step Fibonacci shift <code>(a,b)=(b+a,b)</code></p>

<p>To keep the values <code>a,b</code> manageable, we store only their first <code>1006</code> digits by floor-dividing by <code>10</code> until they are under <code>2**3340 ~ 1e1006</code>.</p>
</div>
<div id="pu15" class="pu"><h2>PARI/GP, 45 bytes</h2>

<pre><code>\p1100
s=sqrt(5)
((1+s)/2)^1e9/s/1e208986640
</code></pre>

<p>Somehow <code>\p1000</code> isn't enough. This doesn't work  with 32 bit systems. The final division is to avoid the decimal point in scientific notation.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/133618/">133618</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




