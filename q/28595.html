<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::28595</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>076</td><td>APLNARS</td><td>250908T045520Z</td><td><a href="https://codegolf.stackexchange.com/questions/28595/resistors-of-unusual-value/283571#283571">Rosario</a></td></tr>
<tr d-ix="1"><td>119</td><td>Janet</td><td>250907T142856Z</td><td><a href="https://codegolf.stackexchange.com/questions/28595/resistors-of-unusual-value/283567#283567">Adam&#22</a></td></tr>
<tr d-ix="2"><td>185</td><td>Perl</td><td>140528T113009Z</td><td><a href="https://codegolf.stackexchange.com/questions/28595/resistors-of-unusual-value/28701#28701">Zaid</a></td></tr>
<tr d-ix="3"><td>163</td><td>Julia  179</td><td>140526T162516Z</td><td><a href="https://codegolf.stackexchange.com/questions/28595/resistors-of-unusual-value/28616#28616">Glen O</a></td></tr>
<tr d-ix="4"><td>070</td><td>J</td><td>140526T140100Z</td><td><a href="https://codegolf.stackexchange.com/questions/28595/resistors-of-unusual-value/28611#28611">algorith</a></td></tr>
<tr d-ix="5"><td>nan</td><td></td><td>140526T110852Z</td><td><a href="https://codegolf.stackexchange.com/questions/28595/resistors-of-unusual-value/28606#28606">edc65</a></td></tr>
<tr d-ix="6"><td>186</td><td>JavaScript ECMAScript 6  186 Characters</td><td>140526T125734Z</td><td><a href="https://codegolf.stackexchange.com/questions/28595/resistors-of-unusual-value/28608#28608">MT0</a></td></tr>
<tr d-ix="7"><td>nan</td><td>Ruby 2.1</td><td>140526T083205Z</td><td><a href="https://codegolf.stackexchange.com/questions/28595/resistors-of-unusual-value/28605#28605">josh</a></td></tr>
<tr d-ix="8"><td>248</td><td>Javascript</td><td>140526T062838Z</td><td><a href="https://codegolf.stackexchange.com/questions/28595/resistors-of-unusual-value/28604#28604">Snack</a></td></tr>
<tr d-ix="9"><td>270</td><td>Python 3  250 247</td><td>140526T013618Z</td><td><a href="https://codegolf.stackexchange.com/questions/28595/resistors-of-unusual-value/28599#28599">undergro</a></td></tr>
<tr d-ix="10"><td>102</td><td>APL</td><td>140526T011113Z</td><td><a href="https://codegolf.stackexchange.com/questions/28595/resistors-of-unusual-value/28598#28598">marinus</a></td></tr>
<tr d-ix="11"><td>122</td><td>Mathematica</td><td>140525T235631Z</td><td><a href="https://codegolf.stackexchange.com/questions/28595/resistors-of-unusual-value/28596#28596">Martin E</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>APL(NARS), 76 chars</h1>
<pre><code>{⍪k[⍋∣¯1+⍺÷⍨¨↑¨k←(,¨⍵)∪(({÷+/÷⍵}¨k),¨'∣',¨k)∪(+/¨k),¨'+',¨k←k/⍨≤/¨k←,∘.,⍨⍵]}
</code></pre>
<p>The list is composed I column the result, or the value if it is a single too, II column
| for resistors in parallel and + for resistors in series, III and IV columns the values from ⍵ input list.</p>
<p>test:</p>
<pre><code>  f←{⍪k[⍋∣¯1+⍺÷⍨¨↑¨k←(,¨⍵)∪(({÷+/÷⍵}¨k),¨'∣',¨k)∪(+/¨k),¨'+',¨k←k/⍨≤/¨k←,∘.,⍨⍵]}
  510 f 100 150 220 330 470 680 1000 1500 2200 3300 4700
519.4444444 ∣ 680 2200  
500 ∣ 1000 1000         
480 + 150 330           
550 + 220 330           
470                     
467.8899083 ∣ 680 1500  
563.8190955 ∣ 680 3300  
570 + 100 470           
440 + 220 220           
430 + 100 330           
...
6200 + 1500 4700        
6600 + 3300 3300        
6900 + 2200 4700        
8000 + 3300 4700        
9400 + 4700 4700        
  ≢510 f 100 150 220 330 470 680 1000 1500 2200 3300 4700
143
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://janet-lang.org/" rel="nofollow noreferrer">Janet</a>, 119 bytes</h1>
<pre><code>(fn[a t](sort-by|(math/abs(-(/($ 3)t)1))(catseq[r :in a s :in a](if(&gt; r s)[][[r'+ s(+ r s)][r'&amp; s(/(+(/ r)(/ s)))]]))))
</code></pre>
<p>A function that takes a list of available resistors <code>a</code> and a target resistance <code>t</code> and outputs an array like this:</p>
<pre><code>@[(680 &amp; 2200 519.444444444444) (1000 &amp; 1000 500) (150 + 330 480) … (4700 + 4700 9400)]
</code></pre>
</div>
<div id="pu2" class="pu"><h1>Perl, <strike>213</strike> <strike>199</strike> 185 bytes</h1>

<p><strong>213 bytes:</strong></p>

<pre><code>$t=pop;sub t{abs 1-(split/=/,pop)[1]/$t}sub S{$_[0]+$_[1]}sub P{$_[0]*$_[1]/&amp;S}$"=',';@i=@ARGV;say for sort{t($a)&lt;=&gt;t($b)}grep s!(..\b(\d+)\b,?\b(\d+)?\b\))=\K(??{$2&lt;$3})!$1!ee&amp;&amp;/\d$/,&lt;{S,P}({@i},{@i})= S({@i})=&gt;;
</code></pre>

<p><strong>199 bytes:</strong></p>

<pre><code>$t=pop;sub t{abs 1-(split/=/,pop)[1]/$t}sub S{$_[0]+$_[1]}sub P{$_[0]*$_[1]/&amp;S}$"=',';@i=@ARGV;say for sort{t($a)&lt;=&gt;t($b)}grep/(..(\d+),?(\d+)?\))/&amp;&amp;$2&gt;=$3&amp;&amp;($_.=eval$1),&lt;{S,P}({@i},{@i})= S({@i})=&gt;;
</code></pre>

<p><strong>185 bytes:</strong></p>

<pre><code>$t=pop;sub t{abs 1-$_[0]=~s!.*=!!r/$t}sub S{$_[0]+$_[1]}sub P{$_[0]*$_[1]/&amp;S}$"=',';$i="{@ARGV}";say for sort{t($a)&lt;=&gt;t$b}grep{my($x,$y)=/\d+/g;$_.='='.eval,$x&gt;=$y}&lt;{S,P}($i,$i) S($i)&gt;
</code></pre>

<p>Pass all available resistors as arguments. The target resistance should be the last:</p>

<pre><code>$ perl -E 'code' R1 R2 R3 ... Rn target
</code></pre>

<h3>How it works (old code)</h3>

<ul>
<li><p>Define subroutines <code>S</code> and <code>P</code> to compute the sum and parallel values of two resistors.</p></li>
<li><p>Set <a href="http://perldoc.perl.org/perlvar.html" rel="nofollow"><code>$"</code></a> to "," to interpolate <code>@ARGV</code> inside the <a href="http://perldoc.perl.org/functions/glob.html" rel="nofollow"><code>glob</code></a> operator</p></li>
<li><p><code>&lt;{S,P}({@i},{@i})= S({@i})=&gt;</code> generates a cartesian of all possibilities:</p>

<p>S(100,100), S(100,150), S(100,220), ... P(100,100), P(100,150) ... S(100), S(150) ...</p></li>
<li><p>Combine <code>s///ee</code> with <code>grep</code> to evaluate the equivalent resistances and filter out unwanted repeats (performed by <code>(??{$2&lt;$3})</code> and <code>/\d$/</code></p></li>
<li><p><code>sort</code> by fitness computed in subroutine <code>t</code></p></li>
</ul>

<h3>Changes in new code</h3>

<ul>
<li><p>Avoid use of <code>s///ee</code>, use shorter regex with conditional checking and <code>eval</code> inside <code>grep</code></p></li>
<li><p>Replace repeats of <code>"{@i}" with</code>$i`</p></li>
<li><p>Introduce <code>$x</code>, <code>$y</code> instead of <code>$2</code>, <code>$3</code></p></li>
<li><p>Replace <code>split/=/,pop</code> with <code>$_[0]=~s!!!r</code></p></li>
<li><p>No need for trailing <code>;</code></p></li>
<li><p><code>eval;</code> is equivalent to <code>eval $_;</code></p></li>
<li><p>Add <code>=</code> along with <code>eval</code>-ed answer instead of declaring it up front</p></li>
</ul>

<h3>Output:</h3>

<p><code>P</code> represents resistors in parallel, <code>S</code> represents resistors in series.</p>

<pre><code>P(2200,680)=519.444444444444
P(1000,1000)=500
S(330,150)=480
S(330,220)=550
S(470)=470
P(1500,680)=467.889908256881
P(3300,680)=563.819095477387
S(470,100)=570
S(220,220)=440
S(330,100)=430
P(4700,470)=427.272727272727
P(4700,680)=594.052044609665
P(1500,1000)=600
P(3300,470)=411.405835543767
P(1000,680)=404.761904761905
S(470,150)=620
P(2200,470)=387.265917602996
S(220,150)=370
S(330,330)=660
P(1500,470)=357.868020304569
S(680)=680
P(680,680)=340
P(2200,1000)=687.5
S(330)=330
S(470,220)=690
S(220,100)=320
P(1000,470)=319.727891156463
P(4700,330)=308.349900596421
S(150,150)=300
P(3300,330)=300
P(2200,330)=286.95652173913
P(680,470)=277.913043478261
P(1500,330)=270.491803278689
P(1500,1500)=750
P(3300,1000)=767.441860465116
S(150,100)=250
P(1000,330)=248.12030075188
S(680,100)=780
P(470,470)=235
P(680,330)=222.178217821782
S(470,330)=800
S(220)=220
P(4700,220)=210.162601626016
P(3300,220)=206.25
S(100,100)=200
P(2200,220)=200
P(4700,1000)=824.561403508772
P(470,330)=193.875
P(1500,220)=191.860465116279
S(680,150)=830
P(1000,220)=180.327868852459
P(680,220)=166.222222222222
P(330,330)=165
S(150)=150
P(470,220)=149.855072463768
P(4700,150)=145.360824742268
P(3300,150)=143.478260869565
P(2200,150)=140.425531914894
P(1500,150)=136.363636363636
P(330,220)=132
P(1000,150)=130.434782608696
P(2200,1500)=891.891891891892
P(680,150)=122.89156626506
S(680,220)=900
P(470,150)=113.709677419355
P(220,220)=110
P(330,150)=103.125
S(100)=100
P(4700,100)=97.9166666666667
P(3300,100)=97.0588235294118
P(2200,100)=95.6521739130435
P(1500,100)=93.75
P(1000,100)=90.9090909090909
P(220,150)=89.1891891891892
P(680,100)=87.1794871794872
P(470,100)=82.4561403508772
S(470,470)=940
P(330,100)=76.7441860465116
P(150,150)=75
P(220,100)=68.75
P(150,100)=60
P(100,100)=50
S(1000)=1000
S(680,330)=1010
P(3300,1500)=1031.25
S(1000,100)=1100
P(2200,2200)=1100
P(4700,1500)=1137.09677419355
S(680,470)=1150
S(1000,150)=1150
S(1000,220)=1220
P(3300,2200)=1320
S(1000,330)=1330
S(680,680)=1360
S(1000,470)=1470
P(4700,2200)=1498.55072463768
S(1500)=1500
S(1500,100)=1600
S(1500,150)=1650
P(3300,3300)=1650
S(1000,680)=1680
S(1500,220)=1720
S(1500,330)=1830
P(4700,3300)=1938.75
S(1500,470)=1970
S(1000,1000)=2000
S(1500,680)=2180
S(2200)=2200
S(2200,100)=2300
S(2200,150)=2350
P(4700,4700)=2350
S(2200,220)=2420
S(1500,1000)=2500
S(2200,330)=2530
S(2200,470)=2670
S(2200,680)=2880
S(1500,1500)=3000
S(2200,1000)=3200
S(3300)=3300
S(3300,100)=3400
S(3300,150)=3450
S(3300,220)=3520
S(3300,330)=3630
S(2200,1500)=3700
S(3300,470)=3770
S(3300,680)=3980
S(3300,1000)=4300
S(2200,2200)=4400
S(4700)=4700
S(3300,1500)=4800
S(4700,100)=4800
S(4700,150)=4850
S(4700,220)=4920
S(4700,330)=5030
S(4700,470)=5170
S(4700,680)=5380
S(3300,2200)=5500
S(4700,1000)=5700
S(4700,1500)=6200
S(3300,3300)=6600
S(4700,2200)=6900
S(4700,3300)=8000
S(4700,4700)=9400
</code></pre>
</div>
<div id="pu3" class="pu"><h1>Julia - <del>179</del> 163 bytes</h1>

<pre><code>f(t,s)=(\ =repmat;m=endof(s);A=A[v=(A=s\m).&gt;=(B=sort(A))];B=B[v];F=[s,C=A+B,A.*B./C];n=sum(v);print([[s P=[" "]\m P;A [+]\n B;A [|]\n B] F][sortperm(abs(F-t)),:]))
</code></pre>

<p>This works the same as the old version, but the argument in the print statement has been organised slightly differently to reduce the number of square brackets necessary. Saves 4 bytes. Absorbing the spaces vector creation into the print argument saves an extra 2 bytes. It has also switched from using "find" to get the relevant indices to using the logical form. Saves 6 bytes. Absorbing the calculation of the index vector into the adjustment of A saved another 2 bytes. Finally, replacing endof(v) with sum(v) saved 2 more bytes. Total saving: 16 bytes.</p>

<p>Old version:</p>

<pre><code>f(t,s)=(\ =repmat;m=endof(s);A=s\m;v=find(A.&gt;=(B=sort(A)));A=A[v];B=B[v];F=[s,C=A+B,A.*B./C];n=endof(v);P=[" "]\m;print([[s,A,A] [P,[+]\n,[|]\n] [P,B,B] F][sortperm(abs(F-t)),:]))
</code></pre>

<p>Within the function, here's what it's doing:</p>

<pre><code>\ =repmat            # Overloads \ operator to save lots of characters
m=endof(s)           # Length of input s ("Stock")
A=s\m                # Equivalent to repmat(s,m) (see first command)
B=sort(A)            # Same as A but sorted - rather than cycling through
                     # the resistors m times, it repeats each one m times
v=find(A.&gt;=B)        # Identify which pairs for A,B have A&gt;=B
A=A[v];B=B[v]        # Remove pairs where A&lt;B (prevents duplicates)
F=[s,C=A+B,A.*B./C]  # Constructs vector containing results for single resistor,
                     # resistors in series, and resistors in parallel
n=endof(v)           # equivalent to n=(m+1)m/2, gets number of relevant pairs
P=[" "]\m            # Construct array of blank entries for use in constructing output
print([[s,A,A] [P,[+]\n,[|]\n] [P,B,B] F][sortperm(abs(F-t)),:]))
# The following are the components of the argument in the print statement:
[s,A,A]              # Set of resistor values for resistor 1
[P,[+]\n,[|]\n]      # Operator column, prints either nothing, +, or |
[P,B,B]              # Set of resistor values for resistor 2 (blank for single resistor)
F                    # Contains resulting equivalent resistance
[sortperm(abs(F-t)),:] # Determines permutation for sorting array by distance from Target t
                     # and applies it to array
</code></pre>

<p>Sample output:</p>

<pre><code>julia&gt; f(170,[100,220,300])
300  |  300  150
100  +  100  200
300  |  220  126.92307692307692
220          220
220  |  220  110
100          100
300  |  100  75
220  |  100  68.75
100  |  100  50
300          300
220  +  100  320
300  +  100  400
220  +  220  440
300  +  220  520
300  +  300  600
</code></pre>
</div>
<div id="pu4" class="pu"><h1>J - <strike>86</strike> <strike>71</strike> 70 char</h1>

<pre><code>((]/:[|@&lt;:@%~2{::"1])(;a:,&lt;)"0,[:,/(&lt;,.+`|,.+/;+&amp;.%/)"1@;@((&lt;@,.{:)\))
</code></pre>

<p>I'm not going to bother to explain every little detail because a lot of the code is spent syncing up the results of different functions, but here's the gist of the golf:</p>

<ul>
<li><p><code>;@((&lt;@,.{:)\)</code> makes every possible pair of resistors, to be connected either in parallel or in series.</p></li>
<li><p><code>[:,/(&lt;,.+`|,.+/;+&amp;.%/)"1@</code> then connects them, in parallel and in series, making a big list of possible connections.</p></li>
<li><p><code>(;a:,&lt;)"0,</code> adds in the possibility of using only one resistor by itself to approximate.</p></li>
<li><p><code>(]/:[|@&lt;:@%~2{::"1])</code> sorts the list of combinations of resistors by the pseudolog distance (<code>|@&lt;:@%</code>) between the target and the resultant resistance from each combination.</p></li>
</ul>

<p>And this is how to use it:</p>

<pre><code>   rouv =: ((]/:[|@&lt;:@%~2{::"1])(;a:,&lt;)"0,[:,/(&lt;,.+`|,.+/;+&amp;.%/)"1@;@((&lt;@,.{:)\))
   # 510 rouv 100 150 220 330 470 680 1000 1500 2200 3300 4700      NB. how many?
143
   10 {. 510 rouv 100 150 220 330 470 680 1000 1500 2200 3300 4700  NB. view first 10
+---------+-+-------+
|680 2200 |||519.444|
+---------+-+-------+
|1000 1000|||500    |
+---------+-+-------+
|150 330  |+|480    |
+---------+-+-------+
|220 330  |+|550    |
+---------+-+-------+
|470      | |470    |
+---------+-+-------+
|680 1500 |||467.89 |
+---------+-+-------+
|680 3300 |||563.819|
+---------+-+-------+
|100 470  |+|570    |
+---------+-+-------+
|220 220  |+|440    |
+---------+-+-------+
|100 330  |+|430    |
+---------+-+-------+
</code></pre>

<p>You don't have to only view the first 10 like I did above, but this is a function and the J REPL truncates very large return values, and the full output for this example has 287 lines. You can force it all to STDOUT with something like <code>tmoutput toCRLF , LF ,.~ ": blah rouv blah</code> on Windows&mdash;drop the <code>toCRLF</code> on Linux&mdash;but <code>rouv</code> is a function and internally, all the rows exist.</p>

<h2>Note:</h2>

<p>The question seems to have been changed right under our noses, and now the log distance is defined as <code>abs(log(Rapprox/Rtarget))</code> instead of <code>abs(Rapprox/Rtarget-1)</code>. To correct this in my golf, we can change the <code>|@&lt;:@%</code> to <code>|@^.@%</code>: <code>&lt;:</code> is Decrement while <code>^.</code> is Logarithm.</p>
</div>
<div id="pu5" class="pu"><h1>Javascript (E6) 156 <s>162 164 186</s></h1>

<p><strong>Last Edit</strong> Assuming all resistor values > 0, you can use them for the loop condition</p>

<pre><code>F=(t,s)=&gt;{D=a=&gt;Math.abs(a[1]/t-1);for(i=r=[];a=s[j=i++];r[l]=[a,a])for(;b=s[j--];)l=r.push([a+'+'+b,c=a+b],[a+'|'+b,a*b/c]);return r.sort((a,b)=&gt;D(a)-D(b))}
</code></pre>

<p>Usage : <code>F(510, [100, 150, 220, 330, 470, 680, 1000, 1500, 2200, 3300, 4700])</code></p>

<p><strong>Ungolfed</strong></p>

<pre><code>F = (t,s) =&gt; 
{
  D = a =&gt; Math.abs(a[1]/t-1);
  for (i=r=[]; a=s[j=i++]; r[l]=[a,a])
    for(; b=s[j--];)
      l = r.push([a+'+'+b, c=a+b], [a+'|'+b, a*b/c]);
   return r.sort((a,b) =&gt; D(a)-D(b))
}
</code></pre>
</div>
<div id="pu6" class="pu"><h1>JavaScript (ECMAScript 6) - 186 Characters</h1>
<pre><code>f=(R,T)=&gt;(D=x=&gt;Math.abs(x[3]/T-1),r={p:(x,y)=&gt;x*y/(x+y),s:(x,y)=&gt;x+y},[...[[x,0,0,x]for(x of R)],...[[x,y,z,r[z](x,y)]for(x of R)for(y of R)for(z in r)if(x&lt;=y)]].sort((a,b)=&gt;D(a)-D(b)))
</code></pre>
<p><strong>Input:</strong></p>
<ul>
<li>An array <code>R</code> of resistor strengths; and</li>
<li><code>T</code>, the target resistance.</li>
</ul>
<p><strong>Output:</strong></p>
<p>An array of arrays (sorted by distance from <code>T</code>) each containing:</p>
<ul>
<li>the smaller resistor's value;</li>
<li>the higher resistor's value (or 0 if a solitary resistor);</li>
<li><code>p</code>, <code>s</code> or 0 if the resistors are in parallel, serial or solitary; and</li>
<li>the net resistance.</li>
</ul>
<p><strong>Explanation:</strong></p>
<pre><code>f=(R,T)=&gt;(                               // Create a function f with arguments R &amp; T
  D=x=&gt;Math.abs(x[3]/T-1),               // A function D to calculate relative
                                         // distance from the target value
  r={p:(x,y)=&gt;x*y/(x+y),s:(x,y)=&gt;x+y},   // An object containing the formulae
                                         // to calculate resistance in serial and parallel
  solitary = [[x,0,0,x]for(x of R)],     // Create an array of solitary resistors
  pairs =                                // Use Array Comprehension to create the array of
   [[x,y,z,r[z](x,y)]                    // arrays
      for(x of R)                        // for each resistor value
      for(y of R)                        // for each resistor value (again)
      for(z in r)                        // for both serial &amp; parallel
      if(x&lt;=y)],                         // where the first resistor value is smaller than the second
  [
    ...solitary,                         // Use the spread ... operator to combine
    ...pairs                             // the two arrays
  ]
    .sort((a,b)=&gt;D(a)-D(b))              // Sort the arrays by minimum distance
                                         // and return.
)
</code></pre>
</div>
<div id="pu7" class="pu"><h1>Ruby 2.1, <del>156</del> 154 bytes</h1>

<pre><code>s=-&gt;(a,z){c={};a.map{|e|a.map{|f|c[e]=e;c[e+f]="#{e}+#{f}";c[1/(1.0/f+1.0/e)]="#{e}|#{f}"}};c.sort_by{|k,|(k/z.to_f-1).abs}.map{|e|puts"#{e[1]}=#{e[0]}"}}
</code></pre>

<h2>Ungolfed:</h2>

<pre><code>s =-&gt;(a,z) {
  c={}
  a.map{|e|
    a.map{|f|
      c[e]=e
      c[e+f]="#{e}+#{f}"
      c[1/(1.0/f+1.0/e)]="#{e}|#{f}"
    }
  }
  c.sort_by{|k,|
    (k/z.to_f-1).abs
  }.map{|e|
    puts "#{e[1]}=#{e[0]}"
  }
}
</code></pre>

<h2>What it does:</h2>

<ul>
<li>For each value <code>e</code> in <code>a</code>;
<ul>
<li>Iterate through <code>a</code>, computing single, series, and parallel values as keys to printed values in hash <code>c</code>;</li>
</ul></li>
<li>Determine distance from <code>z</code> for each key in <code>c</code>; and, </li>
<li>For each value <code>e[1]</code> for each key <code>e[0]</code> in <code>c</code>, print <code>e[1]=e[0]</code>.</li>
</ul>

<h2>Sample usage:</h2>

<p><code>s[[100, 150, 220, 330, 470, 680, 1000, 1500, 2200, 3300, 4700], 510]</code> </p>

<h2>Sample output:</h2>

<pre><code>2200|680=519.4444444444445
1000|1000=500.0
330+150=480
330+220=550
470=470
1500|680=467.88990825688074
3300|680=563.8190954773869
.
.
.
4700+1500=6200
3300+3300=6600
4700+2200=6900
4700+3300=8000
4700+4700=9400
</code></pre>
</div>
<div id="pu8" class="pu"><h1>Javascript, 248 bytes</h1>

<pre class="lang-js prettyprint-override"><code>function r(T,L){R=[],O="";for(i in L){R.push([a=L[i],a]);for(j=i;j&lt;L.length;)b=L[j++],s=a+b,R.push([a+"+"+b,s],[a+"|"+b,a*b/s])}R.sort(function(a,b){A=Math.abs;return A(a[1]/T-1)-A(b[1]/T-1)});for(i in R)q=R[i],O+=q[0]+"="+q[1]+"\n";console.log(O)}
</code></pre>

<p>Usage : <code>r(510, [100, 150, 220, 330, 470, 680, 1000, 1500, 2200, 3300, 4700]);</code></p>

<h3>Output</h3>

<pre><code>670|2200=519.4444444444445
1000|1000=500
150+330=480

(...such rows...)

2200+4700=6900
3300+4700=8000
4700+4700=9400
</code></pre>
</div>
<div id="pu9" class="pu"><h1>Python 3 - <del>250</del> <del>247</del> 270 bytes</h1>

<pre><code>from itertools import*
import sys
r=sys.argv[1:]
t=int(r.pop())
p=set(map(tuple,map(sorted,product(r,r))))
a=[('+'.join(b),sum(map(int,b)))for b in p]+[('|'.join(b),1/sum(map(lambda n:1/int(n),b)))for b in p]
for s in sorted(a,key=lambda b:abs(float(b[1])/t-1)):print(s)
</code></pre>

<p>Run like this:</p>

<pre><code>python resistors.py 100 150 220 330 470 680 1000 1500 2200 3300 4700 510
</code></pre>

<p>(that is, a space-delimited list of resistors, with the target value at the end)</p>

<p>Output:</p>

<pre><code>('2200|680', 519.4444444444445)
('1000|1000', 500.0)
('150+330', 480)
('220+330', 550)
('1500|680', 467.88990825688074)
('3300|680', 563.8190954773869)

[snip]

('2200+4700', 6900)
('3300+4700', 8000)
('4700+4700', 9400)
</code></pre>

<p><del>I would say that outputting, say, <code>680|2200</code> and <code>2200|680</code> separately is still pretty clear. If this is unacceptable, I can change it, but it'll cost me bytes.</del> Wasn't acceptable. Cost me bytes. Now I sort the tuples before chucking them into the set, otherwise the solution is identical.</p>
</div>
<div id="pu10" class="pu"><h1>APL (102)</h1>

<pre><code>{V←{⊃¨⍺{⍺,⍺⍺,⍵,'=',⍺⍵⍵⍵}⍺⍺/¨Z/⍨≤/¨Z←,∘.,⍨⍵}⋄K[⍋|¯1+⍺÷⍨0 4↓K←↑('|'{÷+/÷⍺⍵}V⍵),('+'+V⍵),{⍵,'  =',⍵}¨⍵;]}
</code></pre>

<p>This takes the target resistance as the left argument and a list of available resistors as the right argument.</p>

<p>Explanation:</p>

<ul>
<li><code>V←{</code>...<code>}</code>: <code>V</code> is a function that:
<ul>
<li><code>Z/⍨≤/¨Z←,∘.,⍨⍵</code>: finds every unique combination of two values in <code>⍵</code>,
<ul>
<li><code>Z←,∘.,⍨⍵</code>: join each value in <code>⍵</code> with each value in <code>⍵</code>, store in <code>Z</code>,</li>
<li><code>Z/⍨≤/¨Z</code>: select from <code>Z</code> those combinations where the first value is less than or equal to the second value</li>
</ul></li>
<li><code>⍺{</code>...<code>}⍺⍺/¨</code>: and then applies following function, bound with the left function (<code>⍺⍺</code>) on the right and the left argument (<code>⍺</code>) on the left, to each pair:
<ul>
<li><code>⍺,⍺⍺,⍵,'=',⍺⍵⍵⍵</code>, the left argument, followed by the left bound argument, followed by the right argument, followed by <code>=</code>, followed by the right function (<code>⍵⍵</code>) applied to both arguments. (This is the formatting function, <code>X [configuration] Y [equals] (X [fn] Y)</code>.)</li>
</ul></li>
<li><code>⊃¨</code>: and then unbox each element.</li>
</ul></li>
<li><code>{⍵,'  =',⍵}¨⍵</code>: for each element in <code>⍵</code>, make the configurations for the individual resistors. (<code>⍵</code>, nothing, nothing, <code>=</code>, <code>⍵</code>).</li>
<li><code>('+'+V⍵)</code>: use the <code>V</code> function to make all serial configurations (character is <code>'+'</code> and function is <code>+</code>).</li>
<li><code>'|'{÷+/÷⍺⍵}V⍵</code>: use the <code>V</code> function to make all parallel configurations (character is <code>'|'</code> and function is <code>{÷+/÷⍺⍵}</code>, inverse of sum of inverse of arguments).</li>
<li><code>K←↑</code>: make this into a matrix and store it in <code>K</code>.</li>
<li><code>0 4↓K</code>: drop the 4 first columns from <code>K</code>, leaving only the resistance values.</li>
<li><code>|¯1+⍺÷⍨</code>: calculate the distance between <code>⍺</code> and each configuration.</li>
<li><code>K[⍋</code>...<code>;]</code>: sort <code>K</code> by the distances.</li>
</ul>
</div>
<div id="pu11" class="pu"><h2>Mathematica, <s>151</s> 122 characters</h2>

<p>Expects the target resistance to be stored in <code>r</code> and the list of available resistors in <code>l</code>.</p>

<pre><code>SortBy[Join[{#,#}&amp;/@l,Join@@(#@@@Union[Sort/@N@l~Tuples~{2}]&amp;/@{{"+",##,#+#2}&amp;,{"|",##,#*#2/(#+#2)}&amp;})],Abs[#[[-1]]/r-1]&amp;]
</code></pre>

<p>Less golf:</p>

<pre><code>SortBy[Join[{#, #} &amp; /@ l,
  Join @@ (# @@@ 
       Union[Sort /@ N@l~Tuples~{2}] &amp; /@ {{"+", ##, # + #2} &amp;, {"|", ##, 
        #*#2/(# + #2)} &amp;})], Abs[#[[-1]]/r - 1] &amp;]
</code></pre>

<p>The output format differs from the suggested one but configurations are easily determinable. The output is a list of configurations. Each configuration is of one of the following forms:</p>

<pre><code>{R1, Total}
{"+", R1, R2, Total}
{"|", R1, R2, Total}
</code></pre>

<p>So the first three elements of the output read</p>

<pre><code>{{"|", 680., 2200., 519.444}, {"|", 1000., 1000., 500.}, {"+", 150., 330., 480.}, ...}
</code></pre>

<p>If you're fine with rational numbers, I could save two characters from omitting <code>N@</code>. That is, the first element (for instance) would be returned as <code>4675/9</code> instead of <code>519.444</code>.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/28595/">28595</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




