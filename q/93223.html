<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::93223</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td></td><td>240712T075854Z</td><td><a href="https://codegolf.stackexchange.com/questions/93223/simplify-a-continued-fraction/274120#274120">RARE Kpo</a></td></tr>
<tr d-ix="1"><td>005</td><td>Vyxal</td><td>210412T071407Z</td><td><a href="https://codegolf.stackexchange.com/questions/93223/simplify-a-continued-fraction/223296#223296">lyxal</a></td></tr>
<tr d-ix="2"><td>004</td><td>Husk</td><td>210412T043424Z</td><td><a href="https://codegolf.stackexchange.com/questions/93223/simplify-a-continued-fraction/223293#223293">Razetime</a></td></tr>
<tr d-ix="3"><td>302</td><td>APLNARS</td><td>190724T130510Z</td><td><a href="https://codegolf.stackexchange.com/questions/93223/simplify-a-continued-fraction/188719#188719">user5898</a></td></tr>
<tr d-ix="4"><td>004</td><td>Stax</td><td>190724T155008Z</td><td><a href="https://codegolf.stackexchange.com/questions/93223/simplify-a-continued-fraction/188725#188725">recursiv</a></td></tr>
<tr d-ix="5"><td>034</td><td>Ruby</td><td>190724T140436Z</td><td><a href="https://codegolf.stackexchange.com/questions/93223/simplify-a-continued-fraction/188721#188721">IMP1</a></td></tr>
<tr d-ix="6"><td>005</td><td>J</td><td>160914T230732Z</td><td><a href="https://codegolf.stackexchange.com/questions/93223/simplify-a-continued-fraction/93245#93245">Ad&#225;</a></td></tr>
<tr d-ix="7"><td>145</td><td>Zephyr</td><td>160916T075458Z</td><td><a href="https://codegolf.stackexchange.com/questions/93223/simplify-a-continued-fraction/93436#93436">DLosc</a></td></tr>
<tr d-ix="8"><td>024</td><td>Perl 6</td><td>160915T200636Z</td><td><a href="https://codegolf.stackexchange.com/questions/93223/simplify-a-continued-fraction/93385#93385">Brad Gil</a></td></tr>
<tr d-ix="9"><td>018</td><td>Haskell</td><td>160914T204146Z</td><td><a href="https://codegolf.stackexchange.com/questions/93223/simplify-a-continued-fraction/93225#93225">nimi</a></td></tr>
<tr d-ix="10"><td>044</td><td>JavaScript ES6</td><td>160915T090331Z</td><td><a href="https://codegolf.stackexchange.com/questions/93223/simplify-a-continued-fraction/93304#93304">Neil</a></td></tr>
<tr d-ix="11"><td>022</td><td>Mathematica</td><td>160914T204243Z</td><td><a href="https://codegolf.stackexchange.com/questions/93223/simplify-a-continued-fraction/93226#93226">Martin E</a></td></tr>
<tr d-ix="12"><td>054</td><td> Common Lisp</td><td>160915T075109Z</td><td><a href="https://codegolf.stackexchange.com/questions/93223/simplify-a-continued-fraction/93294#93294">coredump</a></td></tr>
<tr d-ix="13"><td>017</td><td>05AB1E</td><td>160914T205851Z</td><td><a href="https://codegolf.stackexchange.com/questions/93223/simplify-a-continued-fraction/93232#93232">Emigna</a></td></tr>
<tr d-ix="14"><td>062</td><td>Python 2</td><td>160914T225551Z</td><td><a href="https://codegolf.stackexchange.com/questions/93223/simplify-a-continued-fraction/93243#93243">Sp3000</a></td></tr>
<tr d-ix="15"><td>050</td><td>Python</td><td>160915T004955Z</td><td><a href="https://codegolf.stackexchange.com/questions/93223/simplify-a-continued-fraction/93254#93254">xnor</a></td></tr>
<tr d-ix="16"><td>030</td><td>Haskell</td><td>160915T002934Z</td><td><a href="https://codegolf.stackexchange.com/questions/93223/simplify-a-continued-fraction/93253#93253">xnor</a></td></tr>
<tr d-ix="17"><td>016</td><td>CJam</td><td>160914T230921Z</td><td><a href="https://codegolf.stackexchange.com/questions/93223/simplify-a-continued-fraction/93247#93247">Sp3000</a></td></tr>
<tr d-ix="18"><td>050</td><td>Javascript ES6</td><td>160914T234531Z</td><td><a href="https://codegolf.stackexchange.com/questions/93223/simplify-a-continued-fraction/93249#93249">Hedi</a></td></tr>
<tr d-ix="19"><td>005</td><td>M</td><td>160914T234904Z</td><td><a href="https://codegolf.stackexchange.com/questions/93223/simplify-a-continued-fraction/93251#93251">miles</a></td></tr>
<tr d-ix="20"><td>055</td><td>Javascript ES6</td><td>160914T230750Z</td><td><a href="https://codegolf.stackexchange.com/questions/93223/simplify-a-continued-fraction/93246#93246">Arnauld</a></td></tr>
<tr d-ix="21"><td>010</td><td>Dyalog APL</td><td>160914T214342Z</td><td><a href="https://codegolf.stackexchange.com/questions/93223/simplify-a-continued-fraction/93235#93235">Ad&#225;</a></td></tr>
<tr d-ix="22"><td>036</td><td>LabVIEW</td><td>160914T224318Z</td><td><a href="https://codegolf.stackexchange.com/questions/93223/simplify-a-continued-fraction/93241#93241">ijustlov</a></td></tr>
<tr d-ix="23"><td>053</td><td>Julia 53 Bytes</td><td>160914T205338Z</td><td><a href="https://codegolf.stackexchange.com/questions/93223/simplify-a-continued-fraction/93230#93230">Magic Oc</a></td></tr>
<tr d-ix="24"><td>013</td><td>GolfScript</td><td>160914T201557Z</td><td><a href="https://codegolf.stackexchange.com/questions/93223/simplify-a-continued-fraction/93224#93224">Martin E</a></td></tr>
</table>
<div id="pu0" class="pu"><h2><code>awk</code></h2>
<p><code>POSIX</code>-compliant <code>awk</code> code - the extra <code>temp</code> variable at each layer is absolutely superfluous.</p>
<pre><code>function _______(_____,_,___,____,__) {
    if (!(___ = split(_,____,/,/)))
        return +_____
    else
        __ = (_ = +____[___]) || ++_
    while (--___)
        _ = __ + ____[___] * (__ = _)
    return (__ += _*_____)&quot;:&quot;(_ &quot; =&gt; &quot;)__/_
}
</code></pre>
<hr />
<pre><code>4
    2,1,3,1,2
    170
    39
    170:39 =&gt; 4.35897435897435858720427859225310385227203369140625
1
    0,1,1,2,1,1
    19
    7
    19:7 =&gt; 2.71428571428571441259691710001789033412933349609375
3
    7,15,1,292,1
    104348
    33215
    104348:33215 =&gt; 3.1415926539214211743455962277948856353759765625
1
    1,1,1,1,1
    13
    8
    13:8 =&gt; 1.625
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/Lyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a>, <s>6</s> 5 bytes</h1>
<pre><code>‡Ė+ḭƒ
</code></pre>
<p><a href="http://lyxal.pythonanywhere.com?flags=&amp;code=%E2%80%A1%C4%96%2B%E1%B8%AD%C6%92&amp;inputs=%5B4%2C2%2C1%2C3%2C1%2C2%5D&amp;header=&amp;footer=" rel="nofollow noreferrer">Try it Online!</a></p>
<p>I added <code>foldr</code> lol.</p>
<h2>Explained</h2>
<pre><code>‡Ė+ḭƒ
‡Ė+    # lambda x, y: 1 / x + y
   ḭ   # reduce input by ↑, going right-to-left
    ƒ  # fractionify the result
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/barbuz/Husk" rel="nofollow noreferrer">Husk</a>, 4 bytes</h1>
<pre><code>Ḟ·+\
</code></pre>
<p><a href="https://tio.run/##yygtzv7//@GOeYe2a8f8//8/2kTHSMdQxxiIjWIB" rel="nofollow noreferrer" title="Husk – Try It Online">Try it online!</a></p>
<p>pretty simple with <code>TNum</code> being a rational type.</p>
</div>
<div id="pu3" class="pu"><h1>APL(NARS), 15+1 chars, 30+2 bytes</h1>
<pre><code>{1=≢⍵:↑⍵⋄+∘÷/⍵}
</code></pre>
<p>Translation in Apl(Nars) from Adam J solution...
the input allowed for that function will be
all list of integer numbers, where the first element
will be of type rational. Test:</p>
<pre><code>  f←{1=≢⍵:↑⍵⋄+∘÷/⍵}      
  f 4x 2 1 3 1 2
170r39 
  f 1x 0 1 1 2 1 1
19r7 
  f 3x 7 15 1 292 1
104348r33215 
  f 1x 1 1 1 1 1
13r8 
  f 3x 89 888 999 11 222 373 7282 9272 3839 2828 
158824716824887954093160207727r52744031585005490644982548907 
  f ,0x
0 
  f ,9x
9 
</code></pre>
<p>so it would be 15 chars as length of function and 1 char for &quot;x&quot; for enter the type of input I want
and exit the type I want...</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/tomtheisen/stax" rel="nofollow noreferrer">Stax</a>, 4 <a href="https://github.com/tomtheisen/stax/blob/master/docs/packed.md#packed-stax" rel="nofollow noreferrer">bytes</a></h1>

<pre><code>╣╩┼►
</code></pre>

<p><a href="https://staxlang.xyz/#p=b9cac510&amp;i=[4,2,1,3,1,2]%0A[1,0,1,1,2,1,1]%0A[3,7,15,1,292,1]%0A[1,1,1,1,1,1]&amp;a=1&amp;m=2" rel="nofollow noreferrer">Run and debug it</a></p>

<p>As small as it is, it's not a built-in.  The built-in rationals help quite a bit though.  Unpacked to ascii, the program is <code>rksu+</code>.</p>

<ol>
<li>Reverse the array.</li>
<li>Fold the array using <code>(a, b) =&gt; (a + 1/b)</code>.</li>
</ol>
</div>
<div id="pu5" class="pu"><h1>Ruby, 34 bytes</h1>

<pre><code>-&gt;a{a.reverse.inject{|b,i|i+1r/b}}
</code></pre>

<p>This performs a right fold (by reversing and then left folding), adding each element to 1 over the running total (the elements to the right). Ruby has the Rational type, which is really nice. And literal rationals are a number suffixed with <code>r</code>.</p>
</div>
<div id="pu6" class="pu"><h1>J, <s>8</s> 5 bytes</h1>
<p>Same as <a href="https://codegolf.stackexchange.com/a/93235/43319">this</a>, but uses a build-in for rationals.</p>
<p>Argument is {a0,a1,a2,a3,...} as a list of J extended precision rational numbers. Result is the fraction as a J extended precision rational number.</p>
<pre><code>(+%)/
</code></pre>
<p><code>(+%)</code> the plus-the-reciprocal-of</p>
<p><code>/</code> reduction over</p>
<p><a href="https://tio.run/##y/r/P83WSkNbVVP/f2pyRr5CmoKCSZGhgoIRiDAEEcZwFkiMC6YKLGIAlzNE1WSIrBRsgjlY2BSh1tIIQ6EhqnGoxH8A" rel="noreferrer" title="J – Try It Online">Try it online!</a></p>
<p>-3 thanks to <a href="https://codegolf.stackexchange.com/users/6710/miles">miles</a>.</p>
</div>
<div id="pu7" class="pu"><h2><a href="https://github.com/dloscutoff/zephyr" rel="nofollow">Zephyr</a>, 145 bytes</h2>

<pre><code>input n as Integer
set a to Array(n)
for i from 1to n
input a[i]as Integer
next
set r to a[n]
for i from 1to n-1
set r to(/r)+a[n-i]
next
print r
</code></pre>

<p>Zephyr is the first programming language I ever created. It was designed to be intuitive and have clean syntax--rather at the expense of brevity. Why am I golfing with it, you ask? Because, unlike any language I've written since, it has a built-in <code>Fraction</code> type. You can even use the division operator <code>/</code> as a unary operator for "inverse" (a feature I borrowed for Pip).</p>

<p>Now, there are significant limitations. The biggest problem for this challenge is that arrays must be defined with fixed size, which means that the program starts by reading the size of the array from the user. (I hope this is ok; the alternative is hardcoding the size.) There's also the minor problem that operator precedence doesn't exist, meaning multi-operator expressions have to have parentheses.</p>

<p>Here's an example run:</p>

<pre><code>C:\Zephyr&gt; python zephyr.py contfrac.zeph
6
1
1
1
1
1
1
13/8
</code></pre>
</div>
<div id="pu8" class="pu"><h1><a href="https://perl6.org" rel="nofollow">Perl 6</a>, 24 bytes</h1>



<pre class="lang-perl6 prettyprint-override"><code>{[R[&amp;(1/*+*)]](@_).nude}
</code></pre>

<h2>Explanation:</h2>

<ul>
<li><p><code>1 / * + *</code> is a lambda with two parameters (<code>*</code>) which takes the reciprocal of the first, and adds the second. ( returns a <a href="https://docs.perl6.org/type/Rat" rel="nofollow">Rat</a> )</p></li>
<li><p><code>R[&amp;(…)]</code> uses that as if it was an infix operator and reverses it.<br>
( including making it right associative )</p></li>
<li><p><code>[…](@_)</code> takes that and uses it to reduce the input.</p></li>
<li><p><code>… .nude</code> returns the <strong><em>nu</em></strong>merator and <strong><em>de</em></strong>nominator of the <a href="https://docs.perl6.org/type/Rat" rel="nofollow">Rat</a>.</p></li>
<li><code>{ … }</code> make it a bare block lambda with implicit parameter <code>@_</code>.</li>
</ul>

<h2>Usage:</h2>

<pre class="lang-perl6 prettyprint-override"><code>say {[R[&amp;(1/*+*)]](@_).nude}(3,7,15,1,292,1) #*/# (104348 33215)

my &amp;code = {[R[&amp;(1/*+*)]](@_).nude}; # stupid highlighter */

say code 4,2,1,3,1,2;    # (170 39)
say code 1,0,1,1,2,1,1;  # (19 7)
say code 1,1,1,1,1,1;    # (13 8)
</code></pre>
</div>
<div id="pu9" class="pu"><h2>Haskell, <s>37</s> <s>36</s> 18 bytes</h2>

<pre><code>foldr1$(.(1/)).(+)
</code></pre>

<p>This function expects Haskell's <code>Ratio</code> type as input. Usage example:</p>

<pre><code>Prelude Data.Ratio&gt; ( foldr1$(.(1/)).(+) )  [4%1,2,1,3,1,2] 
170 % 39
</code></pre>

<p>Note: one explicit <code>Ratio</code> in the input list (<code>4%1</code>) is enough, the type systems figures out that the others have to be <code>Ratio</code>s, too. </p>

<p>Edit: @Lynn saved a byte. Thanks!</p>

<p>Edit II: removed the <code>import</code> (see this <a href="http://meta.codegolf.stackexchange.com/q/10081/34531">discussion on meta</a>).</p>
</div>
<div id="pu10" class="pu"><h2>JavaScript (ES6), 44 bytes</h2>

<pre><code>a=&gt;a.reduceRight(([n,d],v)=&gt;[v*n+d,n],[1,0])
</code></pre>
</div>
<div id="pu11" class="pu"><h2>Mathematica, <s>23</s> 22 bytes</h2>

<pre><code>Fold[#2+1/#&amp;]@*Reverse
</code></pre>

<p>Essentially <a href="https://codegolf.stackexchange.com/a/93224/8478">a port of my GolfScript answer</a>. Here are some alternatives:</p>

<p>For 24 bytes, we can write a recursive variadic function:</p>

<pre><code>f@n_=n
n_~f~m__:=n+1/f@m
</code></pre>

<p>For 21 bytes, we can even define a "variadic operator", but its calling convention would be so weird, that I'm reluctant to count this one:</p>

<pre><code>±n_=n
n_ ±m__:=n+1/±m
</code></pre>

<p>You would have to call this with a <em>sequence</em> of the input values, e.g. <code>±Sequence[3, 7, 15, 1, 292, 1]</code> or <code>±##&amp;[3, 7, 15, 1, 292, 1]</code>.</p>

<p>And also for 21 bytes, there would be the (forbidden) built-in:</p>

<pre><code>FromContinuedFraction
</code></pre>
</div>
<div id="pu12" class="pu"><h2> Common Lisp, 54</h2>
<p>A somewhat verbose fold-right:</p>
<pre><code>(lambda(s)(reduce(lambda(a r)(+(/ r)a))s :from-end t))
</code></pre>
<h3>Tests</h3>
<pre><code>PASS  NAME  ACTUAL               EXPECTED
===============================================
T     √19   170/39               170/39              
T     ℯ     19/7                 19/7                
T     π     104348/33215         104348/33215        
T     ϕ     13/8                 13/8                
</code></pre>
</div>
<div id="pu13" class="pu"><h1><a href="http://github.com/Adriandmen/05AB1E" rel="nofollow">05AB1E</a>, <s>19</s> 17 bytes</h1>

<pre><code>R¬V¦vyY*X+YUV}YX)
</code></pre>

<p><strong>Explanation</strong></p>

<p>Input taken as a list of numbers</p>

<pre><code>                     # variable X is initialized as 1
R¬V¦                 # reverse the list, remove the first item and store it in variable Y
    v        }       # for each item N left in list
     yY*X+  V        # store N*Y+X in Y
          YU         # store Y in X
              YX)    # wrap X and Y in a list
</code></pre>

<p><a href="http://05ab1e.tryitonline.net/#code=UsKsVsKmdnlZKlgrWVVWfVlYKQ&amp;input=WzMsNywxNSwxLDI5MiwxXQ" rel="nofollow">Try it online!</a></p>
</div>
<div id="pu14" class="pu"><h2>Python 2, 62 bytes</h2>

<pre class="lang-py prettyprint-override"><code>a=d=0
b=c=1
for n in input():a,b=b,n*b+a;c,d=d,n*d+c
print b,d
</code></pre>

<p>It's unfortunately not as golfy (see <a href="https://codegolf.stackexchange.com/a/93254/21487">@xnor's answer</a> for shorter), but it calculates the fraction without needing to reverse the input. This uses the <a href="http://www.maths.usyd.edu.au/u/bobh/UoS/MATH3009/wk2.pdf" rel="nofollow noreferrer">"magic table"</a> approach for convergents – given the last two fractions <code>a/c</code> and <code>b/d</code>, the next fraction is <code>(n*b+a)/(n*c+d)</code>.</p>

<p>For instance, for pi:</p>

<pre><code>          3    7    15     1      292        1

  0   1   3   22   333   355   103993   104348
  1   0   1    7   106   113    33102    33215
</code></pre>

<p>We can see that <code>15*22 + 3 = 333</code>, <code>15*7 + 1 = 106</code>, <code>1*333 + 22 = 355</code>, <code>1*106 + 7 = 113</code>, etc.</p>
</div>
<div id="pu15" class="pu"><h2>Python, 50 bytes</h2>

<pre class="lang-python prettyprint-override"><code>f=lambda l,n=1,d=0:l and f(l,l.pop()*n+d,n)or(n,d)
</code></pre>

<p>Builds the continued fraction from the end of the list going backwards, repeatedly updating the fraction <code>n/d</code> on the last element <code>x</code> as <code>n/d -&gt; 1+1/(n/d) == (x*n+d)/n</code>.</p>
</div>
<div id="pu16" class="pu"><h2>Haskell, 30 bytes</h2>

<pre class="lang-haskell prettyprint-override"><code>foldr(\h(n,d)-&gt;(h*n+d,n))(1,0)
</code></pre>

<p>Recursively adds each layer going outward, updating <code>n/d</code> to <code>h+(1/(n/d))</code>, which equals <code>h+d/n</code> or <code>(h*n+d)/n</code>. The fraction is stored as a tuple of <code>(num,denom)</code>. The initial fraction of <code>(1,0)</code> flips to <code>0/1</code> which is <code>0</code>.</p>
</div>
<div id="pu17" class="pu"><h2><a href="http://sourceforge.net/projects/cjam/" rel="nofollow">CJam</a>, <s>18</s> 16 bytes</h2>

<pre><code>XUq~W%{2$*+\}/]p
</code></pre>

<p><a href="http://cjam.aditsu.net/#code=XUq~W%25%7B2%24*%2B%5C%7D%2F%5Dp&amp;input=%5B3%207%2015%201%20292%201%5D" rel="nofollow">Online interpreter</a>.</p>

<pre><code>XU                  Push 1 and 0 to the stack
  q~W%              Push input, eval and reverse it
      {     }/      For each n in the reversed input...
       2$             Copy numerator
         *+           Calculate n*denominator + numerator
           \          Swap numerator and denominator
              ]p   Wrap in array and output
</code></pre>
</div>
<div id="pu18" class="pu"><h2>Javascript (ES6), 50 bytes</h2>

<pre class="lang-js prettyprint-override"><code>f=(s,n=1,d=s.pop())=&gt;s+&quot;&quot;?f(s,d,s.pop()*d+n):[d,n]
</code></pre>
<p>It's thanks to Arnauld's answer, before seeing it I was stuck to 66 bytes:</p>
<pre class="lang-js prettyprint-override"><code>f=(b,s,i=s.length-1,n=1,d=s[i])=&gt;i?f(b,s,--i,d,s[i]*d+n):[n+b*d,d]
</code></pre>
<p>Example:<br />
Call: <code>f([1, 0, 1, 1, 2, 1, 1])</code><br />
Output: <code>Array [ 19, 7 ]</code></p>
</div>
<div id="pu19" class="pu"><h1>M, 5 bytes</h1>

<pre><code>Ṛİ+¥/
</code></pre>

<p>The input is a list of the values <code>[a0, a1, ..., aN]</code> and it outputs a rational number.</p>

<p><a href="http://m.tryitonline.net/#code=4bmaxLArwqUv&amp;input=&amp;args=NCwyLDEsMywxLDI" rel="noreferrer">Try it online!</a> or <a href="http://m.tryitonline.net/#code=4bmaxLArwqUvCsOH4oKs&amp;input=&amp;args=W1s0LDIsMSwzLDEsMl0sWzEsMCwxLDEsMiwxLDFdLFszLDcsMTUsMSwyOTIsMV0sWzEsMSwxLDEsMSwxXV0" rel="noreferrer">Verify all test cases.</a></p>

<h2>Explanation</h2>

<pre><code>Ṛİ+¥/  Input: list A
Ṛ      Reverse A
    /  Reduce A from left to right using
   ¥     A dyadic chain
 İ         Take the reciprocal of the left value
  +        Add the reciprocal to the right value
       Return and print implicitly
</code></pre>
</div>
<div id="pu20" class="pu"><h2>Javascript (ES6), 55 bytes</h2>

<pre><code>s=&gt;eval('for(F=[1,0];s+"";)F=[s.pop()*F[0]+F[1],F[0]]')
</code></pre>

<h3>Test cases</h3>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var f =
s=&gt;eval('for(F=[1,0];s+"";)F=[s.pop()*F[0]+F[1],F[0]]')

console.log(f([4, 2, 1, 3, 1, 2]));
console.log(f([1, 0, 1, 1, 2, 1, 1]));
console.log(f([3, 7, 15, 1, 292, 1]));
console.log(f([1, 1, 1, 1, 1, 1]));</code></pre>
</div>
</div>
</p>
</div>
<div id="pu21" class="pu"><h1><a href="http://goo.gl/9KrKoM" rel="noreferrer">Dyalog APL</a>, 10 <a href="http://meta.codegolf.stackexchange.com/a/9429/43319">bytes</a></h1>

<p>Does not even use a build-in for rationals.</p>
<p>Takes {a<sub>0</sub>,a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,...} as argument, returns {denominator,numerator}.</p>
<pre class="lang-apl prettyprint-override"><code>1(,÷∨)+∘÷/
</code></pre>
<p><code>1(,÷∨)</code> 1-prepended-to divided by the GCD of 1 and</p>
<p><code>+∘÷</code> plus-the-reciprocal-of</p>
<p><code>/</code> reduction over</p>
<p><a href="http://tryapl.org/?a=f%u21901%28%2C%F7%u2228%29+%u2218%F7/%20%u22C4%20f%A8%284%2C2%2C1%2C3%2C1%2C2%29%281%2C0%2C1%2C1%2C2%2C1%2C1%29%283%2C7%2C15%2C1%2C292%2C1%29%281%2C1%2C1%2C1%2C1%2C1%29&amp;run" rel="noreferrer">TryAPL online!</a></p>
</div>
<div id="pu22" class="pu"><h1>LabVIEW, 36 equivalent bytes</h1>

<p>Fairly straight forward naive implementation using OP's algorithm. Is there a nicer way to do this?</p>

<p><a href="https://i.sstatic.net/eZ6ee.png" rel="noreferrer"><img src="https://i.sstatic.net/eZ6ee.png" alt="enter image description here"></a></p>
</div>
<div id="pu23" class="pu"><h1>Julia (53 Bytes)</h1>

<p>This is my first time ever using Julia, if I overlooked an iterator I could have used to lose some more bytes, let me know. Here's a hint to anyone who doesn't know what language to choose for this specific challenge: <a href="https://en.wikipedia.org/wiki/Rational_data_type" rel="nofollow">https://en.wikipedia.org/wiki/Rational_data_type</a></p>

<pre><code>f(x,c)=(a=0;for b in x[end:-1:1];a=1//(b+a);end;a+c;)
</code></pre>

<ul>
<li>Reverse the input array.</li>
<li>Iterate through it with rational division.</li>
<li>Add c to the decimal result.</li>
</ul>
</div>
<div id="pu24" class="pu"><h2><a href="http://www.golfscript.com/golfscript/" rel="nofollow noreferrer">GolfScript</a>, 13 bytes</h2>

<pre><code>~]-1%{\-1?+}*
</code></pre>

<p><a href="http://golfscript.tryitonline.net/#code=fl0tMSV7XC0xPyt9Kg&amp;input=Mwo3IDE1IDEgMjkyIDE" rel="nofollow noreferrer">Try it online!</a></p>

<p>Yay for GolfScript's <a href="https://codegolf.stackexchange.com/a/26553/8478">hidden rationals</a>. :)</p>

<h3>Explanation</h3>

<p>GolfScript's only "official" number type is integers. But the exponentiation operator doesn't cast its result to integer and conveniently the native result of an integer exponentiation in Ruby (the language of GolfScript's interpreter) is a rational number. So we can easily get fractions by raising something to the power of -1. Conveniently, we want reciprocals anyway...</p>

<pre><code>~]     # Evaluate input and wrap all a_i in a list.
-1%    # Reverse the list so that a_n is at the start and a_0 at the end.
{      # Fold... (apply this block to each element from a_n-1 down to a_0, with
       # the previous result on the stack)
  \    #   Swap previous result with current a_i.
  -1?  #   Raise previous result to the power of -1, computing its reciprocal
       #   as a rational number.
  +    #   Add a_i.
}*
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/93223/">93223</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




