<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::1487</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>036</td><td>Dyalog APL</td><td>250815T060852Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/283115#283115">Aaron</a></td></tr>
<tr d-ix="1"><td>076</td><td>Python</td><td>110312T070028Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1554#1554">paperhor</a></td></tr>
<tr d-ix="2"><td>031</td><td>Wolfram Language Mathematica</td><td>190827T070910Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/190927#190927">Roman</a></td></tr>
<tr d-ix="3"><td>nan</td><td>Its not exactly shortest</td><td>190828T002749Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/190969#190969">kot</a></td></tr>
<tr d-ix="4"><td>141</td><td>C gcc</td><td>190420T082752Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/183519#183519">ceilingc</a></td></tr>
<tr d-ix="5"><td>014</td><td>Stax</td><td>190621T143214Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/187237#187237">recursiv</a></td></tr>
<tr d-ix="6"><td>071</td><td>Python</td><td>110311T063502Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1501#1501">user932</a></td></tr>
<tr d-ix="7"><td>049</td><td>Python 2</td><td>190420T051316Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/183516#183516">xnor</a></td></tr>
<tr d-ix="8"><td>008</td><td>Jelly</td><td>190420T031615Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/183513#183513">lynn</a></td></tr>
<tr d-ix="9"><td>066</td><td>Mathematica</td><td>130513T125632Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/11676#11676">DavidC</a></td></tr>
<tr d-ix="10"><td>nan</td><td>Python</td><td>130514T225748Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/11689#11689">Brian Ca</a></td></tr>
<tr d-ix="11"><td>066</td><td>Python</td><td>130514T125105Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/11683#11683">Reinstat</a></td></tr>
<tr d-ix="12"><td>091</td><td>Smalltalk Squeak 4.x flavour</td><td>130503T170024Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/11566#11566">aka.nice</a></td></tr>
<tr d-ix="13"><td>145</td><td>OCaml</td><td>110311T165025Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1521#1521">bltxd</a></td></tr>
<tr d-ix="14"><td>132</td><td>OCaml + Batteries</td><td>110315T190105Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1640#1640">Mat&#237</a></td></tr>
<tr d-ix="15"><td>033</td><td>K</td><td>110408T182227Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1994#1994">isawdron</a></td></tr>
<tr d-ix="16"><td>107</td><td>C#</td><td>110311T181736Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1528#1528">user965</a></td></tr>
<tr d-ix="17"><td>nan</td><td></td><td>110312T033216Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1551#1551">mrjbq7</a></td></tr>
<tr d-ix="18"><td>159</td><td>Clojure</td><td>110311T085216Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1506#1506">Meikel</a></td></tr>
<tr d-ix="19"><td>100</td><td>Haskell</td><td>110315T043859Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1630#1630">user1027</a></td></tr>
<tr d-ix="20"><td>nan</td><td></td><td>110315T042039Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1629#1629">Jagu</a></td></tr>
<tr d-ix="21"><td>082</td><td>PHP</td><td>110314T122809Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1615#1615">arek</a></td></tr>
<tr d-ix="22"><td>nan</td><td>C#  not exactly short. Abusing LINQ. Selects distinct twocombinations of points in the input</td><td>110314T055744Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1609#1609">Daniel C</a></td></tr>
<tr d-ix="23"><td>066</td><td>GoRuby</td><td>110313T110844Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1584#1584">Nemo157</a></td></tr>
<tr d-ix="24"><td>112</td><td>JavaScript 1.8</td><td>110311T200358Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1532#1532">ecatmur</a></td></tr>
<tr d-ix="25"><td>158</td><td>PHP</td><td>110310T225024Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1488#1488">Kevin Br</a></td></tr>
<tr d-ix="26"><td>042</td><td>Python</td><td>110311T002937Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1494#1494">gnibbler</a></td></tr>
<tr d-ix="27"><td>144</td><td>JavaScript</td><td>110311T132539Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1513#1513">aaaaaaaa</a></td></tr>
<tr d-ix="28"><td>1104</td><td>Haskell</td><td>110311T165035Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1522#1522">Chris Ku</a></td></tr>
<tr d-ix="29"><td>146</td><td>Scala</td><td>110311T164535Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1520#1520">Gareth</a></td></tr>
<tr d-ix="30"><td>028</td><td>J</td><td>110310T233035Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1491#1491">J B</a></td></tr>
<tr d-ix="31"><td>123</td><td>Mathematica</td><td>110311T145406Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1517#1517">user503</a></td></tr>
<tr d-ix="32"><td>106</td><td>Smalltalk for</td><td>110311T143954Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1516#1516">user952</a></td></tr>
<tr d-ix="33"><td>026</td><td>J</td><td>110311T082033Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1504#1504">Eelvex</a></td></tr>
<tr d-ix="34"><td>212</td><td>Haskell</td><td>110311T050353Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1498#1498">Dan Burt</a></td></tr>
<tr d-ix="35"><td>105</td><td>Python</td><td>110311T040844Z</td><td><a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1497#1497">Hoa Long</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Dyalog APL, 36 chars</h1>
<pre><code>{∧/1 1 2∊(⊢÷1⌈⌊/){+/⍺⍵*2}/¨⊃-/1 1⊂⍵}­⁡​‎‎⁪⁡⁪⁠⁪⁢⁤⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁡⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁡⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁡⁣⁪‏⁠⁪⁪‏​⁡⁠⁡‌⁢​‎‎⁪⁡⁪⁠⁪⁢⁣⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁢⁪‏⁠⁪⁪‏​⁡⁠⁡‌⁣​‎‎⁪⁡⁪⁠⁪⁢⁣⁣⁪‏⁠⁪⁪‏​⁡⁠⁡‌⁤​‎‎⁪⁡⁪⁠⁪⁢⁡⁢⁪‏⁠⁪⁪⁠‎⁪⁡⁪⁠⁪⁢⁣⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁢⁪‏⁠⁪⁪‏​⁡⁠⁡‌⁢⁡​‎‎⁪⁡⁪⁠⁪⁢⁢⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁤⁪‏⁠⁪⁪‏​⁡⁠⁡‌⁢⁢​‎‎⁪⁡⁪⁠⁪⁢⁡⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁤⁪‏⁠⁪⁪‏​⁡⁠⁡‌⁢⁣​‎‎⁪⁡⁪⁠⁪⁣⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁡⁪‏⁠⁪⁪‏​⁡⁠⁡‌⁢⁤​‎‎⁪⁡⁪⁠⁪⁤⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁤⁪‏‏​⁡⁠⁡‌⁣⁡​‎‎⁪⁡⁪⁠⁪⁤⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁢⁪‏‏​⁡⁠⁡‌⁣⁢​‎‎⁪⁡⁪⁠⁪⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁡⁪‏‏​⁡⁠⁡‌⁣⁣​‎‎⁪⁡⁪⁠⁪⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁪‏‏​⁡⁠⁡‌­
                              1 1⊂⍵   # ‎⁡Split the input into head and tail
                           ⊃-/        # ‎⁢Subtract the head from each element of the tail and disclose
                          ¨           # ‎⁣For each of the results which is a pair of numbers
                 {      }/            # ‎⁤Apply this between them to find their distance from the head
                    ⍺⍵*2              # ‎⁢⁡Square the left and right args
                  +/                  # ‎⁢⁢and take their sum.  I don't have to then find the square root because I'm going to compare with the squared distance (2) later
         (⊢÷    )                     # ‎⁢⁣Normalize these numbers by dividing by
              ⌊/                      # ‎⁢⁤The minimum of the numbers
            1⌈                        # ‎⁣⁡with a minimum of 1 in case there was a distance of zero to avoiding dividing by zero
   1 1 2∊                             # ‎⁣⁢Check that the result, in any order, consists of a 1, a 1, and a 2
 ∧/                                   # ‎⁣⁣And-Over to ensure they were all present which implies they make a square
💎
</code></pre>
<p>Created with the help of <a href="https://vyxal.github.io/Luminespire" rel="nofollow noreferrer">Luminespire</a>.</p>
</div>
<div id="pu1" class="pu"><h1>Python <s>176</s> <s>90</s> 76 bytes</h1>
<pre><code>def S(A):c=sum(A)/4.0;return set(A)==set((A[0]-c)*1j**i+c for i in range(4))
</code></pre>
<p>
Function S takes a list of complex numbers as its input (A). If we know both the centre and one corner of a square, we can reconstruct the square by rotating the corner 90,180 and 270 degrees around the centre point (c). On the complex plane rotation by 90 degrees about the origin is done by multiplying the point by <i>i</i>. If our original shape and the reconstructed square have the same points then it must have been a square.
</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.wolfram.com/wolframscript/" rel="nofollow noreferrer">Wolfram Language (Mathematica)</a>, <s>32</s> 31 bytes</h1>

<pre><code>Tr[#^2]==Tr[#^3]==0&amp;[#-Mean@#]&amp;
</code></pre>

<p><a href="https://tio.run/##y00syUjNTSzJTE78H6xg@z@kKFo5zijW1hbMMAYyDNSilXV9UxPzHJRj1f4HFGXmlQAF7IKjlfWqDXU8a2Nj1RT0Hbiqq6sNdBQManUUQLQhiDZE0Aa1tTpcCgglRlApYx0FXZgaXSM0RTD9BrjNAdJGUHNgNLoSoJAJiLaA0qbISmCGoNuHxR4DuBNgTqqt/Q8A" rel="nofollow noreferrer" title="Wolfram Language (Mathematica) – Try It Online">Try it online!</a></p>

<p>Takes a list of points represented by complex numbers, calculates the second and third central moment, and checks that both are zero.</p>

<p>Un-golfed:</p>

<pre><code>S[p_] := Total[(p - Mean[p])^2] == Total[(p - Mean[p])^3] == 0
</code></pre>

<p>or</p>

<pre><code>S[p_] := CentralMoment[p, 2] == CentralMoment[p, 3] == 0
</code></pre>

<h1>proof</h1>

<p>This criterion works on the entire complex plane, not just on the <a href="https://en.wikipedia.org/wiki/Gaussian_integer" rel="nofollow noreferrer">Gaussian integers</a>.</p>

<ol>
<li><p>First, we note that the <a href="https://en.wikipedia.org/wiki/Central_moment" rel="nofollow noreferrer">central moments</a> do not change when the points are translated together. For a set of points</p>

<pre><code>P = Table[c + x[i] + I*y[i], {i, 4}]
</code></pre>

<p>the central moments are all independent of <code>c</code> (that's why they are called <em>central</em>):</p>

<pre><code>{FreeQ[FullSimplify[CentralMoment[P, 2]], c], FreeQ[FullSimplify[CentralMoment[P, 3]], c]}
(*    {True, True}    *)
</code></pre></li>
<li><p>Second, the central moments have a simple dependence on overall complex scaling (scaling and rotation) of the set of points:</p>

<pre><code>P = Table[f * (x[i] + I*y[i]), {i, 4}];
FullSimplify[CentralMoment[P, 2]]
(*    f^2 * (...)    *)
FullSimplify[CentralMoment[P, 3]]
(*    f^3 * (...)    *)
</code></pre>

<p>This means that if a central moment is zero, then scaling and/or rotating the set of points will keep the central moment equal to zero.</p></li>
<li><p>Third, let's prove the criterion for a list of points where the first two points are fixed:</p>

<pre><code>P = {0, 1, x[3] + I*y[3], x[4] + I*y[4]};
</code></pre>

<p>Under what conditions are the real and imaginary parts of the second and third central moments zero?</p>

<pre><code>C2 = CentralMoment[P, 2] // ReIm // ComplexExpand // FullSimplify;
C3 = CentralMoment[P, 3] // ReIm // ComplexExpand // FullSimplify;
Solve[Thread[Join[C2, C3] == 0], {x[3], y[3], x[4], y[4]}, Reals] // FullSimplify
(*    {{x[3] -&gt; 0, y[3] -&gt; -1, x[4] -&gt; 1, y[4] -&gt; -1},
       {x[3] -&gt; 0, y[3] -&gt; 1, x[4] -&gt; 1, y[4] -&gt; 1},
       {x[3] -&gt; 1/2, y[3] -&gt; -1/2, x[4] -&gt; 1/2, y[4] -&gt; 1/2},
       {x[3] -&gt; 1/2, y[3] -&gt; 1/2, x[4] -&gt; 1/2, y[4] -&gt; -1/2},
       {x[3] -&gt; 1, y[3] -&gt; -1, x[4] -&gt; 0, y[4] -&gt; -1},
       {x[3] -&gt; 1, y[3] -&gt; 1, x[4] -&gt; 0, y[4] -&gt; 1}}    *)
</code></pre>

<p>All of these six solutions represent squares:
<a href="https://i.sstatic.net/N5ZPS.png" rel="nofollow noreferrer"><img src="https://i.sstatic.net/N5ZPS.png" alt="enter image description here"></a>
Therefore, the only way that a list of points of the form <code>{0, 1, x[3] + I*y[3], x[4] + I*y[4]}</code> can have zero second and third central moments is when the four points form a square.</p></li>
</ol>

<p>Due to the translation, rotation, and scaling properties demonstrated in points 1 and 2, this means that any time the second and third central moments are zero, we have a square in some translation/rotation/scaling state. ∎</p>

<h1>generalization</h1>

<p>The k-th central moment of a regular n-gon is zero if k is not divisible by n. Enough of these conditions must be combined to make up a sufficient criterion for detecting n-gons. For the case n=4 it was enough to detect zeros in k=2 and k=3; for detecting, e.g., hexagons (n=6) it may be necessary to check k=2,3,4,5 for zeros. I haven't proved the following, but suspect that it will detect any regular n-gon:</p>

<pre><code>isregularngon[p_List] :=
  And @@ Table[PossibleZeroQ[CentralMoment[p, k]], {k, 2, Length[p] - 1}]
</code></pre>

<p>The code challenge is essentially this code specialized for length-4 lists.</p>
</div>
<div id="pu3" class="pu"><p>Its not exactly shortest, but I dont think anyone proposed this strategy.</p>

<p>Scala, 152</p>

<pre><code>def f(p:Seq[(Double,Double)])={p.map(b=&gt;{math.sqrt(math.pow((p.map(_._1).sum/p.size)-b._1,2)+math.pow((p.map(_._2).sum/p.size)-b._2,2))}).toSet.size==1}
</code></pre>

<p>Basically we calculate average of all points across each axis to find presumably center of the square, and then validate that center has same distance from all points.</p>

<p>Properly formatted solution:</p>

<pre><code>type Point = (Double, Double)
def isSquare(points: Seq[Point]): Boolean = {
  //finds center point along an axis
  def avg(axis: Seq[Double]): Double = {
    axis.sum / axis.size
  }

  //finds distance between 2 points
  def distance(a: Point, b: Point): Double = {
    val x = a._1 - b._1
    val y = a._2 - b._2
    math.sqrt((x * x) + (y * y))
  }

  //point in the center of square
  val center = (
    avg(points.map(_._1)),
    avg(points.map(_._2)))

  //find a set of distances from center to all points
  //and make sure only one is in the set
  points.map(distance(center, _)).toSet.size == 1
}
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C (gcc)</a>, <s>159</s> 141 bytes</h1>



<pre class="lang-c prettyprint-override"><code>g;f(a,e)_Complex*a,e;{e=(*a+a[1]+a[2]+a[3])/4;for(g=0;a[g]-=e,g&lt;4&amp;cabs(a[g])==cabs(*a)&amp;!fmod(carg(a[g++])-carg(*a),atan(1)););return g&gt;4;}
</code></pre>

<p>-18 thanks to @G.Sliepen.</p>

<p><a href="https://tio.run/##pZDBSsQwEIbvPoUuWJI2qW23ghDjxceoQcZsEgptumQrCKWvbkyDVUEPu@tl@CbDfPwTSY2U3humERCFnx@Hft@ptzQ0bFIcpZBBU4pQqqVsBb6pmR4cMrxg0BhBuSLmvk4kvBzQ8oA5j5wCTq50P@yQBGeWUZYJTGMTZgRGsKjEmGHm1Pjq7KV5qNnse2gtwtPF3rV21GhzvXuyG6JRgtZwjcBTkWdFnpYtCVBGKH9AHM3BfaylWpe3OV0ttDrV8hWh@E@WANVnlm842RJ26gh3K9yel@X3aedb/v6X2b9L3YE5eNr1Hw" rel="nofollow noreferrer" title="C (gcc) – Try It Online">Try it online!</a></p>

<p>After subtracting the center point, checks that the absolute values of each complex number are equal, and that all the arguments are equal modulo π/2.</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/tomtheisen/stax" rel="nofollow noreferrer">Stax</a>, 14 <a href="https://github.com/tomtheisen/stax/blob/master/docs/packed.md#packed-stax" rel="nofollow noreferrer">bytes</a></h1>

<pre><code>┐cÜ╦┤╖ó#┬├{%ì↔
</code></pre>

<p><a href="https://staxlang.xyz/#p=bf639acbb4b7a223c2c37b258d1d&amp;i=[[0,0],[0,1],[1,1],[1,0]]%0A[[0,0],[2,1],[3,-1],[1,-2]]%0A[[0,0],[1,1],[0,1],[1,0]]%0A[[0,0],[0,2],[3,2],[3,0]]%0A[[0,0],[3,4],[8,4],[5,0]]%0A[[0,0],[0,0],[1,1],[0,0]]%0A[[0,0],[0,0],[1,0],[0,1]]&amp;a=1&amp;m=2" rel="nofollow noreferrer">Run and debug it</a></p>

<ul>
<li>Calculate the square of the distance between each pair of points.  This yields 6 numbers.</li>
<li>"Reduce" the 6-array by dividing each element by the array's gcd.</li>
<li>The shape is a square iff the product of the reduced array is 4.</li>
</ul>

<pre><code>2S{M{:sJF+m square of the distance between each pair of points
:_          "reduce"; divide each by the gcd of the array
:*4=        does the product of the array equal 4?
</code></pre>

<p><a href="https://staxlang.xyz/#c=2S%7BM%7B%3AsJF%2Bm%09square+of+the+distance+between+each+pair+of+points%0A%3A_+++++++++%09%22reduce%22%3B+divide+each+by+the+gcd+of+the+array%0A%3A*4%3D+++++++%09does+the+product+of+the+array+equal+4%3F&amp;i=[[0,0],[0,1],[1,1],[1,0]]%0A[[0,0],[2,1],[3,-1],[1,-2]]%0A[[0,0],[1,1],[0,1],[1,0]]%0A[[0,0],[0,2],[3,2],[3,0]]%0A[[0,0],[3,4],[8,4],[5,0]]%0A[[0,0],[0,0],[1,1],[0,0]]%0A[[0,0],[0,0],[1,0],[0,1]]&amp;m=2" rel="nofollow noreferrer">Run this one</a></p>
</div>
<div id="pu6" class="pu"><h1>Python, 71 <s>42</s></h1>
<pre><code>lambda A: len(set(A))==4 and len(set(abs(i-j)for i in A for j in A))==3
</code></pre>
<p>Update 1) to require 4 different points (would previously give false positives for repeated points - are there others?)  2) to define a function per spec</p>
<p>For a square, the vector between any two points must be 0 (the same point), a side, or a diagonal. So, the set of the magnitude of these vectors must have length 3.</p>
<pre><code># Accepts co-ordinates as sequences of complex numbers

SQUARES=[
 (0+0j,0+1j,1+1j,1+0j),  # standard square
 (0+0j,2+1j,3-1j,1-2j),  # non-axis-aligned square
 (0+0j,1+1j,0+1j,1+0j)   # different order
]

NONSQUARES=[
 (0+0j,0+2j,3+2j,3+0j),  # rectangle
 (0+0j,3+4j,8+4j,5+0j),  # rhombus
 (0+0j,0+1j,1+1j,0+0j),   # duplicated point
 (0+0j,1+60j,1+0j,1-60j)  # rhombus 2 (J B)
] 
 
test = &quot;lambda A: len(set(A))==4 and len(set(abs(i-j)for i in A for j in A))==3&quot;
assert len(test)==71

is_square=lambda A: len(set(A))==4 and len(set(abs(i-j)for i in A for j in A))==3    
    
for A in SQUARES:
    assert is_square(A)
    
for A in NONSQUARES:
    assert not is_square(A)
</code></pre>
</div>
<div id="pu7" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>, 49 bytes</h1>



<pre class="lang-python prettyprint-override"><code>lambda l:all(1j*z+(1-1j)*sum(l)/4in l for z in l)
</code></pre>

<p><a href="https://tio.run/##ZZDBboMwEETv@YqVerFTo2JIpCpVvqTtwWATHC02tY0K@XnqAKEV3cNoD/NmVtsOobYmG6vzx4iiKaQAPAlEwq/72zPhCb/Sve8agvTloA0gVNbBDe4rHb9rjQr4SbCClUyetWm7QOhb67QJUJH30jYtqp70bKATOW@RJgtDP@lIUpZSFpVH5YumFOI8gQ/CSOEk@K9OOLVbzNlky1kyu5OM3s3GmkT02icC9cWoLTRnp5sGqatKORUvtk4qt1vPyaaGWdMp36kynnPBNTFnh6ivkx4fpto2Red/c/5WzxZrcIAsNvugTRmgtfFh/4jHU1Yi3xI/" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>

<p>Takes a list of four complex numbers as input. Rotates each point 90 degrees around the average, and checks that each resulting point is in the original list.</p>

<p>Same length (though shorter in Python 3 using <code>{*l}</code>).</p>



<pre class="lang-python prettyprint-override"><code>lambda l:{1j*z+(1-1j)*sum(l)/4for z in l}==set(l)
</code></pre>

<p><a href="https://tio.run/##ZZBRb4MgFIXf@ytushfoMANtk6WLv2TbAwpWGgQHmGmX/XZH1brF8XBCbs75zs1th1Bbk45V/jZq3hSCgz59scv@@ohYwi5477sGafx0qKyDKygD@jvPvQxxOH7WSktgJ04KUhKRK9N2AeGX1ikToEKvpW1aLXvUkwHDjTD/IgUtGfyOR0QJxSQqi8oWpRjiewAfuBHcCfAfHXdyt5jTyZaRZHYnKb6ZjTUJ75VPuFZnI7ehmU03DUJVlXQybmydkG63rpNODbPSie9kGdc565WYkUPU50mPd1Ntm6Lzv5y/1bPFGj1AGpt9UKYM0Np4sH@J@1HWRLZN/AA" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>
</div>
<div id="pu8" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 8 bytes</h1>

<pre><code>_Æm×ıḟƊṆ
</code></pre>

<p><a href="https://tio.run/##y0rNyan8/z/@cFvu4elHNj7cMf9Y18Odbf8Ptz9qWhP5/390tEGWjoIhEGsYahtmaYJpgyzNWB0FsIyGEVTUWBcqq2uEJAvVA9WPpM8IJGKsbQTRi2KisbYJWNQCSpsiyyKbapCFJmoAsSs2FgA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>

<p>Takes a list of complex numbers as a command line argument. Prints <code>1</code> or <code>0</code>.</p>

<pre><code>_Æm        Subtract mean of points from each point (i.e. center on 0)
   ×ıḟƊ    Rotate 90°, then compute set difference with original.
       Ṇ   Logical negation: if empty (i.e. sets are equal) then 1 else 0.
</code></pre>

<p>This seems like an enjoyable challenge to revive!</p>
</div>
<div id="pu9" class="pu"><h1>Mathematica <strike>65 80 69</strike> 66</h1>
<p>Checks that the number of distinct inter-point distances (not including distance from a point to itself) is 2 and the shorter of the two is not 0.</p>
<pre><code>h = Length@# == 2 \[And] Min@# != 0 &amp;[Union[EuclideanDistance @@@ Subsets[#, {2}]]] &amp;;
</code></pre>
<p><strong>Usage</strong></p>
<pre><code>h@{{0, 0}, {0, 1}, {1, 1}, {1, 0}}       (*standard square *)
h@{{0, 0}, {2, 1}, {3, -1}, {1, -2}}     (*non-axis aligned square *)
h@{{0, 0}, {1, 1}, {0, 1}, {1, 0}}       (*a different order *)

h@{{0, 0}, {0, 2}, {3, 2}, {3, 0}}       (* rectangle *)
h@{{0, 0}, {3, 4}, {8, 4}, {5, 0}}       (* rhombus   *)
h@{{0, 0}, {0, 0}, {1, 1}, {0, 0}}       (* only 2 distinct points *)
h@{{0, 0}, {0, 1}, {1, 1}, {0, 1}}       (* only 3 distinct points *)
</code></pre>
<blockquote>
<p>True<br />
True<br />
True<br />
False<br />
False<br />
False<br />
False</p>
</blockquote>
<p>N.B.: <code>\[And]</code> is a single character in Mathematica.</p>
</div>
<div id="pu10" class="pu"><h2>Python, 67 chars, complex and distance-based, and no false positives ...</h2>

<pre><code>S=lambda A:len(set(A))-1==len(set([abs(K-J)for K in A for J in A]))
</code></pre>

<p>(I hope;-).  </p>

<p>The sqrt in abs() may cause some roundoff problems, but probably not - abs((K-J)**2) is more reliable but compresses domain as numbers can approach to within a few digits of double precision limits.</p>

<p>Combines <a href="https://codegolf.stackexchange.com/a/1629/8156">Jagu's answer</a> (len(set(Points))-1==len(set(distances)) - brilliant IMNSHO - which drops to 85 as outer pow(...,.5) calls are unnecessary, and (...)**2 is shorter anyway) and <a href="https://codegolf.stackexchange.com/a/1501/8156">user932's</a> (lambda instead of def).</p>

<p>Neither as elegant, nor as short, as <a href="https://codegolf.stackexchange.com/a/1554/7971">paperhorse's rotation as modified by WolframH</a>.</p>

<p>I had a solution that put only the squares of the side and diagonal lengths in the set L and tested "len(L)==2 and max(set(L))/2 in L" but it never went much below 90 chars.</p>

<p>Tests (all should print True):</p>

<pre><code>print S([(0+1j),(1+0j),(0+0j),(1+1j)])
print S([(0+0j),(2+1j),(3-1j),(1-2j)])
print S([(0+0j),(1+1j),(0+1j),(1+0j)])
print S([(1000+1j),(-1+1000j),(1-1000j),(-1000-1j)])

print not S([(0+1j),(0-1j),(0+0j),(0+1j)])
print not S([(999+1j),(-1+1000j),(1-1000j),(-1000-1j)])
print not S([(0+1j),(1+0j),(0+0j),(0-1j)])
print not S([(0+0j),(0+2j),(3+2j),(3+0j)])
print not S([(0+0j),(3+4j),(8+4j),(5+0j)])
print not S([(0+0j),(0+0j),(1+1j),(0+0j)])
print not S([(0+0j),(0+0j),(1+0j),(0+1j)])
</code></pre>
</div>
<div id="pu11" class="pu"><h1>Python, 66</h1>

<p>Improving <a href="https://codegolf.stackexchange.com/a/1554/7971">paperhorse's answer</a> from 76 to 66:</p>

<pre><code>def U(A):c=sum(A)/4;d=A[0]-c;return{d+c,c-d,d*1j+c,c-d*1j}==set(A)
</code></pre>
</div>
<div id="pu12" class="pu"><p><strong>Smalltalk</strong> Squeak 4.x flavour, <strong>91</strong> char in the form of a block:</p>

<pre><code>[:p||b|b:=Bag new.p do:[:x|p do:[:y|b add:(x dist:y)]].b valuesAndCounts asSet={4. 8}asSet]
</code></pre>

<p>Test it with:</p>

<pre><code>{
"Example squares:"
    {0@ 0. 0@ 1. 1@ 1. 1@ 0}. " standard square"
    {0@ 0. 2@ 1. 3@ -1. 1@ -2}.  " non-axis-aligned square"
    {0@ 0. 1@ 1. 0@ 1. 1@ 0}. " different order"
"Example non-squares:"
    {0@ 0. 0@ 2. 3@ 2. 3@ 0}.  " rectangle"
    {0@ 0. 3@ 4. 8@ 4. 5@ 0}.  " rhombus"
    {0@ 0. 0@ 0. 1@ 1. 0@ 0}.  " only 2 distinct points"
    {0@ 0. 0@ 0. 1@ 0. 0@ 1}.   " only 3 distinct points"
}
collect:
[:p||b|b:=Bag new.p do:[:x|p do:[:y|b add:(x dist:y)]].b valuesAndCounts asSet={4. 8}asSet].
</code></pre>

<p>It's a variant of #(4 8 4)</p>

<ul>
<li>Bag is collecting the pairs ( interdistance -> number_of_occurences )</li>
<li>valuesAndCounts send the bag contents (a Dictionary)</li>
<li>asSet apply to the values in the dictionary (number_of_occurences)</li>
</ul>

<p>A degenerated (0,0)*4 is not considered as a valid square.</p>
</div>
<div id="pu13" class="pu"><p><strong>OCaml, 145 <strike>164</strike></strong></p>

<pre><code>let(%)(a,b)(c,d)=(c-a)*(c-a)+(d-b)*(d-b)
let t a b c d=a%b+a%c=b%c&amp;&amp;d%c+d%b=b%c&amp;&amp;a%b=a%c&amp;&amp;d%c=d%b
let q(a,b,c,d)=t a b c d||t a c d b||t a b d c
</code></pre>

<p>Run like this:</p>

<pre><code>q ((0,0),(2,1),(3,-1),(1,-2))
</code></pre>

<p>Let's deobfuscate and explain a bit.</p>

<p>First we define a norm:</p>

<pre><code>let norm (ax,ay) (bx,by) = (bx-ax)*(bx-ax)+(by-ay)*(by-ay)
</code></pre>

<p>You'll notice that there is no call to sqrt, it's not needed here.</p>

<pre><code>let is_square_with_fixed_layout a b c d =
  (norm a b) + (norm a c) = norm b c
  &amp;&amp; (norm d c) + (norm d b) = norm b c
  &amp;&amp; norm a b = norm a c
  &amp;&amp; norm d c = norm d b
</code></pre>

<p>Here a, b, c and d are points.
We assume that these points are layed out like this:</p>

<pre><code>a - b
| / |
c - d
</code></pre>

<p>If we have a square then all these conditions must hold:</p>

<ul>
<li>a b c is a right triangle</li>
<li>b c d is a right triangle</li>
<li>the smaller sides of each right triangle have the same norms</li>
</ul>

<p>Observe that the following always holds:</p>

<pre><code>is_square_with_fixed_layout r s t u = is_square_with_fixed_layout r t s u
</code></pre>

<p>We will use that to simplify our test function below.</p>

<p>Since our input is not ordered, we also have to check all permutations. Without loss of generality we can avoid permuting the first point:</p>

<pre><code>let is_square (a,b,c,d) =
  is_square_with_fixed_layout a b c d
  || is_square_with_fixed_layout a c b d
  || is_square_with_fixed_layout a c d b
  || is_square_with_fixed_layout a b d c
  || is_square_with_fixed_layout a d b c
  || is_square_with_fixed_layout a d c b
</code></pre>

<p>After simplification:</p>

<pre><code>let is_square (a,b,c,d) =
  is_square_with_fixed_layout a b c d
  || is_square_with_fixed_layout a c d b
  || is_square_with_fixed_layout a b d c
</code></pre>

<p>Edit: followed M.Giovannini's advice.</p>
</div>
<div id="pu14" class="pu"><h1>OCaml + Batteries, 132 characters</h1>

<pre><code>let q l=match List.group(-)[?List:(x-z)*(x-z)+(y-t)*(y-t)|x,y&lt;-List:l;z,t&lt;-List:l;(x,y)&lt;(z,t)?]with[[s;_;_;_];[d;_]]-&gt;2*s=d|_-&gt;false
</code></pre>

<p>(look, Ma, no spaces!) The list comprehension in <code>q</code> forms the list of squared norms for each distinct unordered pair of points. A square has four equal sides and two equal diagonals, the squared lengths of the latter being twice the squared lengths of the former. Since there aren't equilateral triangles in the integer lattice the test isn't really necessary, but I include it for completeness.</p>

<p>Tests:</p>

<pre><code>q [(0,0);(0,1);(1,1);(1,0)] ;;
- : bool = true
q [(0,0);(2,1);(3,-1);(1,-2)] ;;
- : bool = true
q [(0,0);(1,1);(0,1);(1,0)] ;;
- : bool = true
q [(0,0);(0,2);(3,2);(3,0)] ;;
- : bool = false
q [(0,0);(3,4);(8,4);(5,0)] ;;
- : bool = false
q [(0,0);(0,0);(1,1);(0,0)] ;;
- : bool = false
q [(0,0);(0,0);(1,0);(0,1)] ;;
- : bool = false
</code></pre>
</div>
<div id="pu15" class="pu"><h2><a href="https://github.com/kevinlawler/kona" rel="nofollow noreferrer">K</a> - 33</h2>

<p>Translation of the <a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1491#1491">J solution by J B</a>:</p>

<pre><code>{4 8 4~#:'=_sqrt+/'_sqr,/x-/:\:x}
</code></pre>

<p>K suffers here from its reserved words(<code>_sqr</code> and <code>_sqrt</code>).</p>

<p>Testing:</p>

<pre><code>  f:{4 8 4~#:'=_sqrt+/'_sqr,/x-/:\:x}

  f (0 0;0 1;1 1;1 0)
1

  f 4 2#0 0 1 1 0 1 1 0
1

  f 4 2#0 0 3 4 8 4 5 0
0
</code></pre>
</div>
<div id="pu16" class="pu"><h3>C#, 107 characters</h3>

<pre><code>return p.Distinct().Count()==4&amp;&amp;
(from a in p from b in p select (a-b).LengthSquared).Distinct().Count()==3;
</code></pre>

<p>Where points is List of Vector3D containing the points.</p>

<p>Computes all distances squared between all points, and if there are exactly three distinct types (must be 0, some value a, and 2*a) and 4 distinct points then the points form a square.</p>
</div>
<div id="pu17" class="pu"><h2>Factor</h2>

<p>An implementation in the <a href="http://www.factorcode.org" rel="nofollow">Factor</a> programming language:</p>

<pre><code>USING: kernel math math.combinatorics math.vectors sequences sets ;

: square? ( seq -- ? )
    members [ length 4 = ] [
        2 [ first2 distance ] map-combinations
        { 0 } diff length 2 =
    ] bi and ;
</code></pre>

<p>And some unit tests:</p>

<pre><code>[ t ] [
    {
        { { 0 0 } { 0 1 } { 1 1 } { 1 0 } }   ! standard square
        { { 0 0 } { 2 1 } { 3 -1 } { 1 -2 } } ! non-axis-aligned square
        { { 0 0 } { 1 1 } { 0 1 } { 1 0 } }   ! different order
        { { 0 0 } { 0 4 } { 2 2 } { -2 2 } }  ! rotated square
    } [ square? ] all?
] unit-test

[ f ] [
    {
        { { 0 0 } { 0 2 } { 3 2 } { 3 0 } }   ! rectangle
        { { 0 0 } { 3 4 } { 8 4 } { 5 0 } }   ! rhombus
        { { 0 0 } { 0 0 } { 1 1 } { 0 0 } }   ! only 2 distinct points
        { { 0 0 } { 0 0 } { 1 0 } { 0 1 } }   ! only 3 distinct points
    } [ square? ] any?
] unit-test
</code></pre>
</div>
<div id="pu18" class="pu"><p>Clojure, 159 chars.</p>

<pre><code>user=> (def squares
         [[[0,0] [0,1] [1,1]  [1,0]]   ; standard square
         [[0,0] [2,1] [3,-1] [1,-2]]  ; non-axis-aligned square
         [[0,0] [1,1] [0,1]  [1,0]]]) ; different order
#'user/squares
user=> (def non-squares
         [[[0,0] [0,2] [3,2] [3,0]]    ; rectangle
          [[0,0] [3,4] [8,4] [5,0]]])  ; rhombus
#'user/non-squares
user=> (defn norm
         [x y]
         (reduce + (map (comp #(* % %) -) x y)))
#'user/norm
user=> (defn square?
         [[a b c d]]
         (let [[x y z] (sort (map #(norm a %) [b c d]))]
           (and (= x y) (= z (* 2 x)))))
#'user/square?
user=> (every? square? squares)
true
user=> (not-any? square? non-squares)
true
</code></pre>

<p>Edit: To also explain a little bit.</p>

<ul>
<li>First define a norm which basically gives the distance between two given points.</li>
<li>Then calculate the distance of the first point to the other three points.</li>
<li>Sort the three distances. (This allows any order of the points.)</li>
<li>The two shortest distances must be equal to be a square.</li>
<li>The third (longest) distance must be equal to the square root of the sum of the squares of the short distances by the theorem of Pythagoras.</li>
</ul>

<p>(Note: the square rooting is not needed and hence in the code saved above.)</p>
</div>
<div id="pu19" class="pu"><h2>Haskell, 100 characters</h2>

<p>Here's how I'd write the JB's J solution in Haskell. With no attempt made to damage readability by removing nonessential characters, it's about 132 characters:</p>

<pre><code>import Data.List
d (x,y) (x',y') = (x-x')^2 + (y-y')^2
square xs = (== [4,8,4]) . map length . group . sort $ [d x y | x&lt;-xs, y&lt;-xs]
</code></pre>

<p>You can scrape it down a bit to 100 by removing excess spaces and renaming some things</p>

<pre><code>import Data.List
d(x,y)(a,b)=(x-a)^2+(y-b)^2
s l=(==[4,8,4]).map length.group.sort$[d x y|x&lt;-l,y&lt;-l]
</code></pre>

<p>Let's use QuickCheck to ensure that it accepts arbitrary squares, with one vertex at (x,y) and edge vector (a,b):</p>

<pre><code>prop_square (x,y) (a,b) = square [(x,y),(x+a,y+b),(x-b,y+a),(x+a-b,y+b+a)]
</code></pre>

<p>Trying it in ghci:</p>

<pre><code>ghci&gt; quickCheck prop_square
*** Failed! Falsifiable (after 1 test):  
(0,0)
(0,0)
</code></pre>

<p>Oh right, the empty square isn't considered a square here, so we'll revise our test:</p>

<pre><code>prop_square (x,y) (a,b) =
   (a,b) /= (0,0) ==&gt; square [(x,y),(x+a,y+b),(x-b,y+a),(x+a-b,y+b+a)]
</code></pre>

<p>And trying it again:</p>

<pre><code>ghci&gt; quickCheck prop_square
+++ OK, passed 100 tests.
</code></pre>
</div>
<div id="pu20" class="pu"><p><strong>Python 97 (without complex points)</strong></p>

<pre><code>def t(p):return len(set(p))-1==len(set([pow(pow(a-c,2)+pow(b-d,2),.5)for a,b in p for c,d in p]))
</code></pre>

<p>This will take lists of point tuples in [(x,y),(x,y),(x,y),(x,y)] in any order, and can handle duplicates, or the wrong number of points. It does NOT require complex points like the other python answers.</p>

<p>You can test it like this:</p>

<pre><code>S1 = [(0,0),(1,0),(1,1),(0,1)]   # standard square
S2 = [(0,0),(2,1),(3,-1),(1,-2)] # non-axis-aligned square
S3 = [(0,0),(1,1),(0,1),(1,0)]   # different order
S4 = [(0,0),(2,2),(0,2),(2,0)]   #
S5 = [(0,0),(2,2),(0,2),(2,0),(0,0)] #Redundant points

B1 = [(0,0),(0,2),(3,2),(3,0)]  # rectangle
B2 = [(0,0),(3,4),(8,4),(5,0)]  # rhombus
B3 = [(0,0),(0,0),(1,1),(0,0)]  # only 2 distinct points
B4 = [(0,0),(0,0),(1,0),(0,1)]  # only 3 distinct points
B5 = [(1,1),(2,2),(3,3),(4,4)]  # Points on the same line
B6 = [(0,0),(2,2),(0,2)]        # Not enough points

def tests(f):
    assert(f(S1) == True)
    assert(f(S2) == True)
    assert(f(S3) == True)
    assert(f(S4) == True)
    assert(f(S5) == True)

    assert(f(B1) == False)
    assert(f(B2) == False)
    assert(f(B3) == False)
    assert(f(B4) == False)
    assert(f(B5) == False)
    assert(f(B6) == False)

def t(p):return len(set(p))-1==len(set([pow(pow(a-c,2)+pow(b-d,2),.5)for a,b in p for c,d in p]))

tests(t)
</code></pre>

<p>This will take a little explaining, but the overall idea is that there are only three distances between the points in a square (Side, Diagonal, Zero(point compared to itself)):</p>

<pre><code>def t(p):return len(set(p))-1==len(set([pow(pow(a-c,2)+pow(b-d,2),.5)for a,b in p for c,d in p]))
</code></pre>

<ul>
<li>for a list p of tuples (x,y)</li>
<li>Remove duplicates using set(p) and then test the length</li>
<li>Get every combination of points (a,b in p for c,d in p)</li>
<li>Get list of the distance from every point to every other point</li>
<li>Use set to check there are only three unique distances
-- Zero (point compared to itself)
-- Side length
-- Diagonal length</li>
</ul>

<p>To save code characters I am:</p>

<ul>
<li>using a 1 char function name</li>
<li>using a 1 line function definition</li>
<li>Instead of checking the number of unique points is 4, I check that it is -1 the different point lengths (saves ==3==)</li>
<li>use list and tuple unpacking to get a,b in p for c,d in p, instead of using a[0],a[1] </li>
<li>uses pow(x,.5) instead of including math to get sqrt(x)</li>
<li>not putting spaces after the )</li>
<li>not putting a leading zero on the float</li>
</ul>

<p>I fear someone can find a test case that breaks this. So please do and Ill correct. For instance the fact I just check for three distances, instead of doing an abs() and checking for side length and hypotenuse, seems like an error.</p>

<p>First time I've tried code golf. Be kind if I've broken any house rules.</p>
</div>
<div id="pu21" class="pu"><p><strong>PHP, 82 characters</strong></p>

<hr>

<pre><code>//$x=array of x coordinates
//$y=array of respective y coordinates
/* bounding box of a square is also a square - check if Xmax-Xmin equals Ymax-Ymin */
function S($x,$y){sort($x);sort($y);return ($x[3]-$x[0]==$y[3]-$y[0])?true:false};

//Or even better (81 chars):
//$a=array of points - ((x1,y1), (x2,y2), (x3,y3), (x4,y4))
function S($a){sort($a);return (bool)($a[3][0]-$a[0][0]-abs($a[2][1]-$a[3][1]))};
</code></pre>
</div>
<div id="pu22" class="pu"><p>C# -- not exactly short. Abusing LINQ. Selects distinct two-combinations of points in the input, calculates their distances, then verifies that exactly four of them are equal and that there is only one other distinct distance value. Point is a class with two double members, X and Y. Could easily be a Tuple, but meh.</p>

<pre><code>var points = new List&lt;Point&gt;
             {
                 new Point( 0, 0 ), 
                 new Point( 3, 4 ), 
                 new Point( 8, 4 ), 
                 new Point( 5, 0 )
              };    
var distances = points.SelectMany(
    (value, index) =&gt; points.Skip(index + 1),
    (first, second) =&gt; new Tuple&lt;Point, Point&gt;(first, second)).Select(
        pointPair =&gt;
        Math.Sqrt(Math.Pow(pointPair.Item2.X - pointPair.Item1.X, 2) +
                Math.Pow(pointPair.Item2.Y - pointPair.Item1.Y, 2)));
return
    distances.Any(
        d =&gt; distances.Where( p =&gt; p == d ).Count() == 4 &amp;&amp;
                distances.Where( p =&gt; p != d ).Distinct().Count() == 1 );
</code></pre>
</div>
<div id="pu23" class="pu"><h2>GoRuby - 66 characters</h2>
<pre><code>f=-&gt;a{z=12;a.pe(2).m{|k,l|(k-l).a}.so.go{|k|k}.a{|k,l|l.sz==z-=4}}
</code></pre>
<p>expanded:</p>
<pre><code>f=-&gt;a{z=12;a.permutation(2).map{|k,l|(k-l).abs}.sort.group_by{|k|k}.all?{|k,l|l.size==(z-=4)}}
</code></pre>
<p>Same algorithm as <a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1491#1491">J B's answer</a>.</p>
<p>Test like:</p>
<pre><code>p f[[Complex(0,0), Complex(0,1), Complex(1,1), Complex(1,0)]]
</code></pre>
<p>Outputs <code>true</code> for true and blank for false</p>
</div>
<div id="pu24" class="pu"><h2>JavaScript 1.8, 112 characters</h2>

<p>Update: saved 2 characters by folding the array comprehensions together.</p>

<pre><code>function i(s)(p=[],[(e=x-a,f=y-b,d=e*e+f*f,p[d]=~~p[d]+1)for each([a,b]in s)for each([x,y]in s)],/8,+4/.test(p))
</code></pre>

<p>Another reimplementation of J B's answer.  Exploits JavaScript 1.7/1.8 features (expression closures, array comprehensions, destructuring assignment).  Also abuses <code>~~</code> (double bitwise not operator) to coerce <code>undefined</code> to numeric, with array-to-string coercion and a regexp to check that the length counts are <code>[4, 8, 4]</code> (it assumes that exactly 4 points are passed).  The abuse of the comma operator is an old obfuscated C trick.</p>

<p>Tests:</p>

<pre><code>function assert(cond, x) { if (!cond) throw ["Assertion failure", x]; }

let text = "function i(s)(p=[],[(e=x-a,f=y-b,d=e*e+f*f,p[d]=~~p[d]+1)for each([a,b]in s)for each([x,y]in s)],/8,+4/.test(p))"
assert(text.length == 112);
assert(let (source = i.toSource()) (eval(text), source == i.toSource()));

// Example squares:
assert(i([[0,0],[0,1],[1,1],[1,0]]))    // standard square
assert(i([[0,0],[2,1],[3,-1],[1,-2]]))  // non-axis-aligned square
assert(i([[0,0],[1,1],[0,1],[1,0]]))    // different order

// Example non-squares:
assert(!i([[0,0],[0,2],[3,2],[3,0]]))  // rectangle
assert(!i([[0,0],[3,4],[8,4],[5,0]]))  // rhombus
assert(!i([[0,0],[0,0],[1,1],[0,0]]))  // only 2 distinct points
assert(!i([[0,0],[0,0],[1,0],[0,1]]))  // only 3 distinct points

// Degenerate square:
assert(!i([[0,0],[0,0],[0,0],[0,0]]))   // we reject this case
</code></pre>
</div>
<div id="pu25" class="pu"><h2>PHP, <s>161</s> 158 characters</h2>

<pre><code>function S($a){for($b=4;--$b;)for($c=$b;$c--;){$e=$a[$c][0]-$a[$b][0];$f=$a[$c][1]-$a[$b][1];$d[$g++]=$e*$e+$f*$f;}sort($d);return$d[0]==$d[3]&amp;&amp;$d[4]==$d[5];}
</code></pre>

<p>Proof (1x1): <a href="http://codepad.viper-7.com/ZlBpOB" rel="nofollow noreferrer">http://codepad.viper-7.com/ZlBpOB</a></p>

<p>This is based off of <a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1513#1513">eBuisness's JavaScript answer</a>.</p>
</div>
<div id="pu26" class="pu"><h2>Python - 42 chars</h2>

<p>Looks like its an improvement to use complex numbers for the points</p>

<pre><code>len(set(abs(x-y)for x in A for y in A))==3
</code></pre>

<p>where
    A = [(11+13j), (14+12j), (13+9j), (10+10j)]</p>

<p>old answer:</p>

<pre><code>from itertools import*
len(set((a-c)**2+(b-d)**2 for(a,b),(c,d)in combinations(A,2)))==2
</code></pre>

<p>Points are specified in any order as a list, eg</p>

<pre><code>A = [(11, 13), (14, 12), (13, 9), (10, 10)]
</code></pre>
</div>
<div id="pu27" class="pu"><h1>JavaScript 144 characters</h1>
<p>Mathematically equal to J Bs answer. It generates the 6 lengths and assert that the 2 greatest are equal and that the 4 smallest are equal. Input must be an array of arrays.</p>
<pre><code>function F(a){d=[];g=0;for(b=4;--b;)for(c=b;c--;d[g++]=(e*e+f*f)/1e6)e=a[c][0]-a[b][0],f=a[c][1]-a[b][1];d.sort();return d[0]==d[3]&amp;&amp;d[4]==d[5]} //Compact function
testcases=[
[[0,0],[1,1],[1,0],[0,1]],
[[0,0],[999,999],[999,0],[0,999]],
[[0,0],[2,1],[3,-1],[1,-2]],
[[0,0],[0,2],[3,2],[3,0]],
[[0,0],[3,4],[8,4],[5,0]],
[[0,0],[0,0],[1,1],[0,0]],
[[0,0],[0,0],[1,0],[0,1]]
]
for(v=0;v&lt;7;v++){
    document.write(F(testcases[v])+&quot;&lt;br&gt;&quot;)
}

function G(a){ //Readable version
    d=[]
    g=0
    for(b=4;--b;){
        for(c=b;c--;){
            e=a[c][0]-a[b][0]
            f=a[c][1]-a[b][1]
            d[g++]=(e*e+f*f)/1e6 //The division tricks the sort algorithm to sort correctly by default method.
        }
    }
    d.sort()
    return (d[0]==d[3]&amp;&amp;d[4]==d[5])
}
</code></pre>
</div>
<div id="pu28" class="pu"><p>Haskell, "wc -c" reports 110 characters.  Does not check that the input has 4 elements.</p>

<pre><code>import Data.List
k [a,b]=2*a==b
k _=0&lt;1
h ((a,b):t)=map (\(c,d)-&gt;(a-c)^2+(b-d)^2) t++h t
h _=[]
j=k.nub.sort.h
</code></pre>

<p>I tested on</p>

<pre><code>test1 = [(0,0),(3,4),(-4,3),(-1,7)] -- j test1 is True
test2 = [(0,0),(3,4),(-3,4),(0,8)]  -- j test2 is False
</code></pre>
</div>
<div id="pu29" class="pu"><h2>Scala (146 characters)</h2>

<pre><code>def s(l:List[List[Int]]){var r=Set(0.0);l map(a=&gt;l map(b=&gt;r+=(math.pow((b.head-a.head),2)+math.pow((b.last-a.last),2))));print(((r-0.0).size)==2)}
</code></pre>
</div>
<div id="pu30" class="pu"><h2>J, 28 <s>17</s> <s>25</s> <s>27</s></h2>

<p>J doesn't really have functions, but here's a monadic verb that takes a vector of points from the complex plane:</p>

<pre><code>4 8 4-:#/.~&amp;(/:~&amp;:|&amp;,&amp;(-/~))
</code></pre>

<p>Method is a mix of <a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1501#1501">Michael Spencer</a> (work solely on inter-vertex lengths; but he's currently failing my rhombus2) and <a href="https://codegolf.stackexchange.com/questions/1487/determine-if-4-points-form-a-square/1504#1504">Eelvex's</a> (check the sets' sizes) works.  Reading right to left:</p>

<ul>
<li><code>-/~</code> compute all point differences</li>
<li><code>,</code> flatten</li>
<li><code>|</code> extract magnitude</li>
<li><code>/:~</code> sort up</li>
<li><code>#/.~</code> nub and count</li>
<li><code>4 8 4 -:</code> must have exactly 4 equidistant (at 0), 8 a bit bigger (length 1, sides), 4 bigger yet (length <code>sqrt 2</code>, diagonals)</li>
</ul>

<p>Demonstration:</p>

<pre><code>   NB. give the verb a name for easier use
   f =: 4 8 4-:#/.~&amp;(/:~&amp;:|&amp;,&amp;(-/~))

   NB. standard square
   f 0 0j1 1j1 1
1

   NB. non-axis-aligned square
   f 0 2j1 3j_1 1j_2
1

   NB. different order
   f 0 1j1 0j1 1
1

   NB. rectangle
   f 0 0j2 3j2 3
0

   NB. rhombus 1
   f 0 3j4 8j4 5
0

   NB. rhombus 2
   f 0 1ad_60 1ad0 1ad60
0
</code></pre>

<p>For memory's sake, my previous method (required ordered vertices, but could detect regular polygons of any order):</p>

<pre><code>*./&amp;(={.)&amp;(%1&amp;|.)&amp;(-1&amp;|.)
</code></pre>

<p>See history for explanation and demo.  The current method could probably be expanded to other polygons, that <code>4 8 4</code> does look a lot like a binomial distribution.</p>
</div>
<div id="pu31" class="pu"><h2>Mathematica, 123 characters (but you can do better):</h2>

<pre><code>Flatten[Table[x-y,{x,a},{y,a}],1]
Sort[DeleteDuplicates[Abs[Flatten[Table[c.d,{c,%},{d,%}]]]]]
%[[1]]==0&amp;&amp;%[[3]]/%[[2]]==2
</code></pre>

<p>Where 'a' is the input in Mathematica list form, eg: <code>a={{0,0},{3,4},{8,4},{5,0}}</code></p>

<p>The key is to look at the <em>dot</em> products between all the vectors and note that they must have exactly three values: 0, x, and 2*x for some value of x. The dot product checks both perpendicularity AND length in one swell foop.</p>

<p>I know there are Mathematica shortcuts that can make this shorter, but I don't know what they are.</p>
</div>
<div id="pu32" class="pu"><h2>Smalltalk for 106 characters</h2>

<pre><code>s:=Set new.
p permutationsDo:[:e|s add:((e first - e second) dotProduct:(e first - e third))].
s size = 2
</code></pre>

<p>where p is a collection of points, e.g. </p>

<pre><code>p := { 0@0. 2@1. 3@ -1. 1@ -2}. "twisted square"
</code></pre>

<p>I think the math is sound...</p>
</div>
<div id="pu33" class="pu"><h2>J, <sup><strike>31 29 27</strike></sup> 26</h2>

<pre><code>3=[:#[:~.[:,([:+/*:@-)"1/~
</code></pre>

<p><strike>checks if the 8 smallest distances between the points are the same.</strike>
checks if there are exactly three kinds of distances between the points (zero, side length and diagonal length).</p>

<pre><code>f 4 2 $ 0 0 2 1 3 _1 1 _2
1
f 4 2 $ 0 0 0 2 3 2 3 0
0
</code></pre>

<p><code>4 2 $</code> is a way of writing an array in J.</p>
</div>
<div id="pu34" class="pu"><h2>Haskell (212)</h2>

<pre><code>import Data.List;j=any f.permutations where f x=(all g(t x)&amp;&amp;s(map m(t x)));t x=zip3 x(drop 1$z x)(drop 2$z x);g(a,b,c)=l a c==sqrt 2*l a b;m(a,b,_)=l a b;s(x:y)=all(==x)y;l(m,n)(o,p)=sqrt$(o-m)^2+(n-p)^2;z=cycle
</code></pre>

<p>Naive first attempt. Checks the following two conditions for all permutations of the input list of points (where a given permutation represents, say, a clockwise ordering of the points):</p>

<ul>
<li>all angles are 90 degrees</li>
<li>all sides are the same length</li>
</ul>

<p>Deobfuscated code and tests</p>

<pre><code>j' = any satisfyBothConditions . permutations
          --f
    where satisfyBothConditions xs = all angleIs90 (transform xs) &amp;&amp; 
                                     same (map findLength' (transform xs))
          --t
          transform xs = zip3 xs (drop 1 $ cycle xs) (drop 2 $ cycle xs)
          --g
          angleIs90 (a,b,c) = findLength a c == sqrt 2 * findLength a b
          --m
          findLength' (a,b,_) = findLength a b
          --s
          same (x:xs) = all (== x) xs
          --l
          findLength (x1,y1) (x2,y2) = sqrt $ (x2 - x1)^2 + (y2 - y1)^2


main = do print $ "These should be true"
          print $ j [(0,0),(0,1),(1,1),(1,0)]
          print $ j [(0,0),(2,1),(3,-1),(1,-2)]
          print $ j [(0,0),(1,1),(0,1),(1,0)]
          print $ "These should not"
          print $ j [(0,0),(0,2),(3,2),(3,0)]
          print $ j [(0,0),(3,4),(8,4),(5,0)]
          print $ "also testing j' just in case"
          print $ j' [(0,0),(0,1),(1,1),(1,0)]
          print $ j' [(0,0),(2,1),(3,-1),(1,-2)]
          print $ j' [(0,0),(1,1),(0,1),(1,0)]
          print $ j' [(0,0),(0,2),(3,2),(3,0)]
          print $ j' [(0,0),(3,4),(8,4),(5,0)]
</code></pre>
</div>
<div id="pu35" class="pu"><h2>Python (105)</h2>

<p>Points are represented by <code>(x,y)</code> tuples.  Points can be in any order and only accepts squares.  Creates a list, <code>s</code>, of pairwise (non-zero) distances between the points.  There should be 12 distances in total, in two unique groups.</p>

<pre>
def f(p):s=filter(None,[(x-z)**2+(y-w)**2for x,y in p for z,w in p]);return len(s)==12and len(set(s))==2
</pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/1487/">1487</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




