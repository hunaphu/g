<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::QNNN</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
  <!-- TXXX -->
<tr d-ix="0"><td>026</td><td>Perl 5 + 0p</td><td>200814T223335Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/209576#209576">Dom Hast</a></td></tr>
<tr d-ix="1"><td>014</td><td>SM83/Z80 machine language</td><td>210628T184912Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/230660#230660">NoLonger</a></td></tr>
<tr d-ix="2"><td>009</td><td>Vyxal s</td><td>220711T212610Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/249833#249833">naffetS</a></td></tr>
<tr d-ix="3"><td>009</td><td>05AB1E</td><td>220711T150858Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/249818#249818">Kevin Cr</a></td></tr>
<tr d-ix="4"><td>007</td><td>Japt m</td><td>210630T095305Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/230754#230754">Shaggy</a></td></tr>
<tr d-ix="5"><td>145</td><td>PHP</td><td>210701T190546Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/230865#230865">SlamJamm</a></td></tr>
<tr d-ix="6"><td>021</td><td>K ngn/k</td><td>210110T183543Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/217497#217497">coltim</a></td></tr>
<tr d-ix="7"><td>014</td><td>Pyth</td><td>150713T030403Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/53025#53025">isaacg</a></td></tr>
<tr d-ix="8"><td>116</td><td>C#</td><td>150713T001640Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/53021#53021">Hand-E-F</a></td></tr>
<tr d-ix="9"><td>024</td><td>REGXY</td><td>150712T224355Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/53016#53016">Jarmex</a></td></tr>
<tr d-ix="10"><td>051</td><td>Bash+sed</td><td>150623T155250Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/52065#52065">Toby Spe</a></td></tr>
<tr d-ix="11"><td>051</td><td>Perl</td><td>150625T000958Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/52174#52174">Allen G</a></td></tr>
<tr d-ix="12"><td>057</td><td>C</td><td>150624T141115Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/52138#52138">Toby Spe</a></td></tr>
<tr d-ix="13"><td>5247</td><td>Ruby</td><td>150622T191815Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/52014#52014">Brian Da</a></td></tr>
<tr d-ix="14"><td>056</td><td>Perl</td><td>150624T143706Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/52139#52139">jja</a></td></tr>
<tr d-ix="15"><td>122</td><td>R</td><td>150622T191238Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/52013#52013">Alex A.</a></td></tr>
<tr d-ix="16"><td>119</td><td>R</td><td>150624T113713Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/52132#52132">jja</a></td></tr>
<tr d-ix="17"><td>092</td><td>JavaScript</td><td>150623T221458Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/52107#52107">SirPytho</a></td></tr>
<tr d-ix="18"><td>034</td><td>><> Fish</td><td>150623T205049Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/52093#52093">Fongoid</a></td></tr>
<tr d-ix="19"><td>039</td><td>rs</td><td>150622T170759Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/51999#51999">kirbyfan</a></td></tr>
<tr d-ix="20"><td>077</td><td>Python 2</td><td>150622T175427Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/52005#52005">Beta Dec</a></td></tr>
<tr d-ix="21"><td>047</td><td>JavaScript ES6</td><td>150622T225651Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/52031#52031">Shmiddty</a></td></tr>
<tr d-ix="22"><td>033</td><td>Retina</td><td>150622T164346Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/51997#51997">Martin E</a></td></tr>
<tr d-ix="23"><td>046</td><td>Ruby</td><td>150623T193216Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/52081#52081">daniero</a></td></tr>
<tr d-ix="24"><td>053</td><td>Lua</td><td>150622T192129Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/52015#52015">user4073</a></td></tr>
<tr d-ix="25"><td>066</td><td>Mathematica</td><td>150623T153815Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/52062#52062">alephalp</a></td></tr>
<tr d-ix="26"><td>056</td><td>Prolog</td><td>150622T152637Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/51991#51991">Fatalize</a></td></tr>
<tr d-ix="27"><td>110</td><td>Excel VBA</td><td>150623T100622Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/52049#52049">user3464</a></td></tr>
<tr d-ix="28"><td>016</td><td>Pyth</td><td>150622T203930Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/52022#52022">Jakube</a></td></tr>
<tr d-ix="29"><td>047</td><td>Javascript</td><td>150622T161857Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/51994#51994">Cereal</a></td></tr>
<tr d-ix="30"><td>065</td><td>Python 2</td><td>150622T144241Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/51986#51986">Kade</a></td></tr>
<tr d-ix="31"><td>061</td><td>Python</td><td>150622T203444Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/52021#52021">xnor</a></td></tr>
<tr d-ix="32"><td>072</td><td>JavaScript ES6</td><td>150622T181730Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/52009#52009">NinjaBea</a></td></tr>
<tr d-ix="33"><td>017</td><td>Pyth</td><td>150622T164804Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/51998#51998">kirbyfan</a></td></tr>
<tr d-ix="34"><td>092</td><td>Python</td><td>150622T185549Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/52011#52011">mbomb007</a></td></tr>
<tr d-ix="35"><td>042</td><td>Haskell</td><td>150622T174851Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/52004#52004">nimi</a></td></tr>
<tr d-ix="36"><td>062</td><td>C</td><td>150622T171545Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/52001#52001">BrainSte</a></td></tr>
<tr d-ix="37"><td>015</td><td>CJam</td><td>150622T150320Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/51988#51988">Sp3000</a></td></tr>
<tr d-ix="38"><td>015</td><td>CJam</td><td>150622T144023Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/51985#51985">Dennis</a></td></tr>
<tr d-ix="39"><td>4563</td><td>Brainfuck</td><td>150622T150440Z</td><td><a href="https://codegolf.stackexchange.com/questions/51984/stretching-words/51989#51989">Mitch Sc</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.perl.org/" rel="nofollow noreferrer">Perl 5</a> + <code>-0p</code>, 26 bytes</h1>

<pre class="lang-perl prettyprint-override"><code>1while s;(.)(.+
)\1;$1$1$2</code></pre>
<p><a href="https://dom111.github.io/code-sandbox/#eyJsYW5nIjoid2VicGVybC01LjI4LjEiLCJjb2RlIjoiMXdoaWxlIHM7KC4pKC4rXG4pXFwxOyQxJDEkMiIsImFyZ3MiOiItMHAiLCJpbnB1dCI6ImJhbmFuYVxubmEifQ==" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1>SM83/Z80 machine language, 14 bytes</h1>
<p>Takes input 1 in <code>de</code>, input 2 in <code>hl</code>, output to <code>bc</code>.</p>
<pre><code>1A 13 02 03 B7 C8 BE 20
F7 02 03 23 18 F2
</code></pre>
<pre><code>stretch:
 ld a,(de)                  // 1A       load input 1 char
 inc de                     // 13       and increment
 ld (bc),a                  // 02       store it
 inc bc                     // 03       and increment
 or a                       // B7       test for 0
 ret z                      // C8       return if so
 cp (hl)                    // BE       test against input 2 char
 jr nz,stretch              // 20 F7    if not same, continue
 ld (bc),a                  // 02       if same, store again
 inc bc                     // 03       and increment again
 inc hl                     // 23       also increment input 2 char
 jr stretch                 // 18 F2    loop back
</code></pre>
<p>The register pressure is extreme on this one. There's just enough room for three pointers and a character without pushing things to memory. It's impossible to do it this efficiently without putting the second input into <code>hl</code>.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a> <code>s</code>, 9 bytes</h1>
<pre><code>£ƛ¥h=[&amp;Ḣd
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/#WyJzIiwiIiwiwqPGm8KlaD1bJuG4omQiLCIiLCJvb2Fvb1xub25vbWF0b3BvZWlhIl0=" rel="nofollow noreferrer">Try it Online!</a></p>
<pre><code>£ƛ¥h=[&amp;Ḣd
£         # Put the first input in the register
 ƛ        # Map over the second input:
  ¥h=[    #  Is the current character equal to the first character of the register?
      &amp;Ḣd #  If so, remove the first character of the register and double the current character
          #  (implicit) else, return the current character unchanged
          # s flag smashes this list into a string
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 9 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>vy?¬yQić?
</code></pre>
<p>Pretty similar to my 05AB1E answer for two related challenges: <a href="https://codegolf.stackexchange.com/a/217695/52210">Speed of Lobsters</a> and <a href="https://codegolf.stackexchange.com/a/249812/52210">Backronymiser</a>.</p>
<p><a href="https://tio.run/##yy9OTMpM/f@/rNL@0JrKwMwj7fb//ycl5gEhV7RSnpKOUqJSLAA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##fY09DsIwDIWvUnnuHXIG5qoSzg80KI1RW5CC1LXsnIOZA1SchIsEJykrst7w3mf70YjSmngNAqrP8qhAhP2Y7PoMO/u@izjP60vEpgHVYW@cIQ81G6gBWY7loW05kuh5EvQZ5hCl0uZw7OwpgXQhWapAZ2846ATs9m5g6QIVKfKX6VdGJSVPPU50JmNzFWVUjun/Gm64/QI" rel="nofollow noreferrer">verify all test cases</a>.</p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>v        # Loop over the characters `y` of the first (implicit) input-string:
 y?      #  Print this character
 ¬       #  Push the first letter of the list
         #  (which will be the second implicit input-list in the first iteration)
  yQi    #  If it's equal to the current character `y`:
     ć   #   Extract the head of the list
      ?  #   Pop and print it as well
</code></pre>
</div>
<div id="pu4" class="pu"><h1 id="japt-m-10-7-bytes-2fl9"><a href="https://github.com/ETHproductions/japt" rel="nofollow noreferrer">Japt</a> <a href="https://codegolf.meta.stackexchange.com/a/14339/"><code>-m</code></a>, <s>10</s> 7 <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>iVvUèVÎ
</code></pre>
<p><a href="https://petershaggynoble.github.io/Japt-Interpreter/?v=1.4.6&amp;flags=LW0&amp;code=aVZ2VehWzg&amp;input=ImJhbmFuYSIKWyJuIiwiYSJd" rel="nofollow noreferrer">Try it</a></p>
<pre><code>iVvUèVÎ     :Implicit map of each character U in the first input (the string)
i           :Prepend
 V          :  The second input (the array)
  v         :  Remove this many elements from the start ...
   Uè       :    Count the occurrences in U of
     VÎ     :    The first element of V 
</code></pre>
</div>
<div id="pu5" class="pu"><h2>PHP, 145 Bytes</h2>
<pre><code>  &lt;?php
$a=str_split($argv[1]);
$b=str_split($argv[2]);
foreach($a as $x){
if($x==$b[0])
{
    $w[] = $x . $x;
    array_shift($b);
}
else $w[] = $x;
}
echo implode($w);
</code></pre>
<p><a href="https://tio.run/##ZYwxDgIhFER7T0HxC2iM2iLxIIRsPrsgJBgIbFx049m/FHY2k8x7kymhEF1vJZQDoGprnVpJceWA9f7UZyMk2D98Gdjn6nAOgzBsDLrYo@fQlQKrT0bssGmjoLPjcBJrxdfUQvTjwgr5cak59puMNofM4qOkvDgOm5BElOIb60JxxBc" rel="nofollow noreferrer">Link to compact version</a></p>
<p>Definitely not the shortest answer, but no one else has done PHP yet so why not!
Takes the word as the first argument, and a string representing the characters to be duplicated for the second argument.</p>
<p>I'm still new to golfing, so let me know if you see anything I could improve.
Thanks!</p>
</div>
<div id="pu6" class="pu"><h1><a href="https://codeberg.org/ngn/k" rel="nofollow noreferrer">K (ngn/k)</a>, <s>41</s> 21 bytes</h1>
<p>-20 bytes by adapting my answer <a href="https://codegolf.stackexchange.com/questions/217690/speed-of-lobsters/218688#218688">here</a></p>
<pre><code>{x@&amp;y{y_x,1+y~:*x}/x}
</code></pre>
<p><a href="https://ngn.bitbucket.io/k#eJxLs6qucFCrrK6Mr9Ax1K6ss9KqqNWvqOXiSotWSs5IzE3NSc3PU7JWSk7MyVOKBYkmJiWnpKalZ2RmAYWBHIhoTmZVYlEKUCQTRIGFkvOT8/NKS0Ca8yEi+Xn5uYkl+QX5qZmJQOH8/MR8HDKJIHEA2J8znA==" rel="nofollow noreferrer">Try it online!</a></p>
<ul>
<li><code>y{...}/x</code> set up a reduction seeded with <code>y</code> (the characters to repeat), run over the characters in <code>x</code> (the full string). confusingly, within the function itself, <code>x</code> and <code>y</code> are flipped. this ends up returning a boolean array with <code>2</code>s in the positions containing the desired matches and <code>1</code>s everywhere else
<ul>
<li><code>1+y~:*x</code> compare the first character to search for (<code>*x</code>) to the current character being iterated over (<code>y</code>), updating <code>y</code> with the result of <code>0</code> or <code>1</code>. then add one to this; this represents the number of copies of the current character to end up returning. note that as soon as we have matched all the search characters, no more matches will be identified (since a character will never <code>~</code> (match) a <code>1</code> or <code>2</code>)</li>
<li><code>x,</code> append this result to the list of characters to search for (essentially overloading the reduction to end up returning the desired output)</li>
<li><code>y_</code> if there was a match, drop the first character (if there wasn't a match, this is a no-op). this allows us to search for the next search character in the next iteration of the reduction</li>
</ul>
</li>
<li><code>x@&amp;</code> return the correct number of copies of each character</li>
</ul>
</div>
<div id="pu7" class="pu"><h1>Pyth, 14 bytes</h1>

<pre><code>s+L&amp;@d&lt;Q1.(QZz
</code></pre>

<p><a href="https://pyth.herokuapp.com/?code=s%2BL%26%40d%3CQ1.(Q0z&amp;input=onomatopoeia%0A%5B%22o%22%2C%22o%22%2C%22a%22%2C%22o%22%2C%22o%22%5D&amp;debug=0">Demonstration.</a></p>

<p>Input style:</p>

<pre><code>banana
["b","a","n","a"]
</code></pre>

<p>Explanation:</p>

<pre><code>s+L&amp;@d&lt;Q1.(Q0z
                  Implicit: z = input(); Q = eval(input())
 +L          z    Map (lambda d) over z, adding the result to each character.
    @d&lt;Q1         Intersection of d with Q[:1], up to the first element of Q.
   &amp;              Logical and - if the first arg is truthy, evaluate and
                  return the second arg, otherwise return first arg.
         .(Q0     Q.pop(0)
                  The addition will either be the empty string, for the empty
                  intersection, or the character that was Q[0] otherwise.

s                 Concatenate and print.
</code></pre>
</div>
<div id="pu8" class="pu"><h2>C#, 116 bytes</h2>

<p>Indented for clarity:</p>

<pre><code>string F(string s,string c){
    int i;
    return c==""
        ?s
        :s.Remove(i=s.IndexOf(c[0]))+c[0]+F(s.Substring(i),c.Substring(1));
}
</code></pre>
</div>
<div id="pu9" class="pu"><h1>REGXY, 24 bytes</h1>

<p>Uses <a href="http://esolangs.org/wiki/REGXY" rel="nofollow">REGXY</a>, a regex substitution based language. Input is assumed to be the starting word and the array, space separated (e.g. "chameleon caln"). </p>

<pre><code>/(.)(.* )\1| /\1\1\2/
//
</code></pre>

<p>The program works by matching a character in the first string with the first character after a space. If this matches, the character is repeated in the substitution and the character in the array is removed (well, not appended back into the string). Processing moves on to the second line, which is just a pointer back to the first line, which causes processing to repeat on the result of the previous substitution. Eventually, there will be no characters after the space, at which point the second branch of the alternation will match, removing the trailing space from the result. The regex will then fail to match, processing is completed and the result is returned.</p>

<p>If it helps, the iterative steps of execution are as follows:</p>

<pre><code>chameleon caln
cchameleon aln
cchaameleon ln
cchaameleonn n
cchaameleonn  (with trailing space)
cchaameleonn
</code></pre>

<p>The program compiles and executes correctly with the sample interpreter in the link above, but the solution is perhaps a bit cheeky as it relies on an assumption in the vagueness of the language specification. The spec states that the first token on each line (before the /) acts as a label, but the assumption is that a null label-pointer will point back to the first command in the file with a null label (or in other words, that 'null' is a valid label). A less cheeky solution would be:</p>

<pre><code>a/(.)(.* )\1| /\1\1\2/
b//a
</code></pre>

<p>Which amounts to 27 bytes</p>
</div>
<div id="pu10" class="pu"><h1>Bash+sed, 51</h1>

<pre><code>sed "`sed 's/./s!^[^&amp;]*&amp;!\U\&amp;&amp;!;/g'&lt;&lt;&lt;$1`s/.*/\L&amp;/"
</code></pre>

<p>Input from stdin; characters to be doubled as a single argument:</p>

<pre><code>$ echo chameleon | strtech caln
cchaamelleonn
</code></pre>

<p>This works by constructing a sed program from <code>$2</code> and then executing it against <code>$1</code>.  The sed program replaces the first occurrence of each replacement letter with two copies of its uppercase version, and downcases the whole lot at the end.  For the example above, the generated sed program is</p>

<pre><code>s!^[^c]*c!\U&amp;C!;s!^[^a]*a!\U&amp;A!;s!^[^l]*l!\U&amp;L!;s!^[^n]*n!\U&amp;N!;s/.*/\L&amp;/
</code></pre>

<p>pretty-printed:</p>

<pre><code># if only sed had non-greedy matching...
s!^[^c]*c!\U&amp;C!
s!^[^a]*a!\U&amp;A!
s!^[^l]*l!\U&amp;L!
s!^[^n]*n!\U&amp;N!
s/.*/\L&amp;/
</code></pre>

<p>I use the uppercase to mark characters processed so far; this avoids re-doubling characters that have already been doubled, or applying a doubling earlier than the previous one.</p>

<p>Earlier version, before clarification that order of replacement list is significant (44 chars):</p>

<pre><code>sed "`sed 's/./s!&amp;!\U&amp;&amp;!;/g'&lt;&lt;&lt;$1`s/.*/\L&amp;/"
</code></pre>
</div>
<div id="pu11" class="pu"><h2>Perl, 51 bytes</h2>

<pre><code>$s=&lt;&gt;;$s=~s=^.*$_=$_=,$,.=$&amp;for split"",&lt;&gt;;print$,;
</code></pre>

<p>Input is provided via STDIN. First input is the starting word (e.g. <code>chameleon</code>), second input is the letters as a single string (e.g. <code>caln</code>).</p>

<p>The above is just an obfuscated (read "prettier") way of doing the following:</p>

<pre><code>$word = &lt;&gt;;
for $letter(split "", &lt;&gt;) {
   $word =~ s/^.*$letter/$letter/;
   $result .= $&amp;;
}
print $result;
</code></pre>

<p>As we go through each letter, we replace from the start of the word up to the letter in the source word with just the new letter, and append the match (stored in <code>$&amp;</code>) to our result. Since the match includes the letter and then gets replaced with the letter, each letter ends up appearing twice.</p>

<p>Because STDIN appends a new line character to both of our inputs, we're guaranteed to capture the remnants of the full word on the last match, i.e. the new line character.</p>
</div>
<div id="pu12" class="pu"><h1>C, 57</h1>
<p>Inspired by <a href="/a/52001">BrainSteel's answer</a>:</p>
<pre><code>f(char*s,char*c){while(*c-putchar(*s++)||putchar(*c++));}
</code></pre>
<p>This uses the result of <code>putchar</code> to determine whether we've hit one of the replacement list, and if so, advance one through the replacement list, outputting as we go.</p>
<p>If we don't consume all the replacements, we'll go off the end of the input string, but luckily the rules guarantee we wont.  :-)</p>
<h3>Test harness:</h3>
<pre><code>int main(int argc, char* argv[]) {
    f(argv[1], argv[2]);
    return 0;
}
</code></pre>
</div>
<div id="pu13" class="pu"><h2>Ruby, <del>52</del> 47 bytes</h2>

<p><strong>Solution:</strong></p>

<p><code>f=-&gt;(s,a){s.chars.map{|c|c==a[0]?a.shift*2:c}.join}</code></p>

<p><strong>Example:</strong></p>

<p><code>p f.call('banana', ['n','a']) # =&gt; "bannaana"</code></p>

<p><strong>Explanation:</strong></p>

<p>Proc form of a method which takes a string as the first argument, and an array of characters as the second argument.  Maps a block onto an array of the characters in the string argument, which checks each character against first element of the comparison array, and if there is a match, removes the first element of the comparison array, and doubles it.</p>

<hr>

<p><em>update</em></p>

<p><code>f=-&gt;s,a{s.chars.map{|c|c==a[0]?a.shift*2:c}*''}</code></p>
</div>
<div id="pu14" class="pu"><h1>Perl, <s>73</s> <s>62</s> <s>59</s> 56</h1>

<p>Entirely new approach yields much better results. Still, I bet it can be shorter.</p>

<p>Call as <code>f('coconut', ['c','o'])</code>.</p>

<pre><code>sub f{($s,$a)=@_;$s=~s/(.*?)($_)/\U$1$2$2/ for@$a;lc$s}
</code></pre>

<p>For each character in the array, find the first occurrence and duplicate it, and turn everything up to it to uppercase. Then return the entire string, converted to lowercase.</p>

<p>EDIT: shaved a couple of more characters by getting rid of <code>shift</code> and <code>pop</code>.</p>

<hr>

<p>The previous version:</p>

<pre><code>sub f{join '',map{shift @{$_[0]}if s/($_[0][0])/$1$1/;$_}split //,shift}
</code></pre>
</div>
<div id="pu15" class="pu"><h1>R, <s>136</s> <s>128</s> 122 bytes</h1>



<pre class="lang-r prettyprint-override"><code>function(s,a){p=strsplit(s,"")[[1]];for(i in 1:nchar(s))if(length(a)&amp;&amp;(x=p[i])==a[1]){p[i]=paste0(x,x);a=a[-1]};message(p)}
</code></pre>

<p>This creates an unnamed function that accepts a string and a character vector as input and prints a string to STDOUT. To call it, give it a name.</p>

<p>Ungolfed + explanation:</p>

<pre class="lang-r prettyprint-override"><code>f &lt;- function(s, a) {
    # Split s into letters
    p &lt;- strsplit(s, "")[[1]]

    # Loop over the letters of s
    for (i in 1:nchar(s)) {

        # If a isn't empty and the current letter is the first in a
        if (length(a) &gt; 0 &amp;&amp; p[i] == a[1]) {

            # Replace the letter with itself duplicated
            p[i] &lt;- paste0(p[i], p[i])

            # Remove the first element from a
            a &lt;- a[-1]
        }
    }

    # Combine p back into a string and print it
    message(p)
}
</code></pre>

<p>Examples:</p>

<pre class="lang-r prettyprint-override"><code>&gt; f("coconut", c("c","o"))
ccooconut

&gt; f("onomatopoeia", c("o","a","o"))
oonomaatoopoeia
</code></pre>

<p>Saved 8 bytes thanks to MickeyT and another 3 thanks to jja!</p>
</div>
<div id="pu16" class="pu"><h1>R, 119</h1>

<p>Based on @Alex's <a href="https://codegolf.stackexchange.com/a/52013/41782">answer</a>, this one is a couple of bytes shorter:</p>

<pre><code>function(s,a){message(unlist(lapply(strsplit(s,"")[[1]],function(x){if(length(a)&amp;x==a[1]){a&lt;&lt;-a[-1];c(x,x)}else x})))}
</code></pre>

<p>Ungolfed:</p>

<pre><code>function(s, a) {
  message(                             # Prints to output
    unlist(                            # Flattens list to vector
      lapply(                          # R's version of map
        strsplit(s,"")[[1]],           # Split vector to characters
        function (x) {
          if (length(a) &amp; x == a[1]) { # If there are still elements in a
                                       # and there's a match
            a &lt;&lt;- a[-1]                # Modify a
            c(x, x)                    # And return the repeated character
          } else x                     # Otherwise just return it
        }
      )
    )
  )
}
</code></pre>
</div>
<div id="pu17" class="pu"><h1>JavaScript, 92 characters</h1>
<pre><code>function f(s,c){r=&quot;&quot;;for(i=0;i&lt;s.length;i++){r+=s[i];if(c.indexOf(s[i])&gt;-1)r+=s[i]}return r}
</code></pre>
<p>Unobfuscated version:</p>
<pre><code>function stretch(str, chars) {
    var ret = &quot;&quot;;
    for(var i = 0; i &lt; str.length; i++) {
        ret += str[i];
        if(chars.indexOf(str[i]) &gt; -1) {
            ret += str[i];
        }
    }
    return ret;
}
</code></pre>
</div>
<div id="pu18" class="pu"><h2><a href="http://esolangs.org/wiki/Fish" rel="nofollow">>&lt;> (Fish)</a>, <strike>68</strike> 34 Bytes</h2>

<pre><code>ri&amp;:o&amp;:&amp;=\
l&amp;io&amp; /!?/
?!;20.\l!\
</code></pre>

<p>You can run it at <a href="http://fishlanguage.com/playground/Libf2RavJY5mHi7iT" rel="nofollow">http://fishlanguage.com/playground</a> inputting the string as the initial stack (with " marks, i.e. "chameleon") and the array of extra letters as the input stack (no " marks i.e. caln).</p>

<p>Don't forget to press the Give button to seed the input stack.</p>

<pre><code>r       reverses the stack
i&amp;      reads in the first input, and stores it in the register
:o      copies the top of the stack, and outputs the top of the stack
&amp;:&amp;     puts register value on stack, copies it, then puts top stack into register
=       checks if the top two values are equal, if yes push 1, else push 0
?       if top value is non-zero, execute next instruction
!       skips the following instruction (unless it was skipped by the previous ?)

If yes, then we proceed on the same line
&amp;o      puts register value on stack, and outputs it
i&amp;      reads in the first input, and stores it in the register
l       puts length of stack on stack, then proceed to lowest line

If no, we go directly to the last line
l       As above.
?!;     If zero value (from length), then end execution
20.     Push 2 and 0 onto stack, then pop top two values, and go to that position (2,0) (i.e. next instruction is at (3,0))
</code></pre>

<p>EDIT: Halved it! :)</p>
</div>
<div id="pu19" class="pu"><h1>rs, 39 bytes</h1>
<p><a href="https://github.com/kirbyfan64/rs" rel="nofollow noreferrer">More information about rs.</a></p>
<p>There's already a Retina answer, but I think this one uses a slightly different approach. They were also created separately: when I began working on this one, that answer hadn't been posted.</p>
<p>Besides, this one is 6 bytes longer anyway. :)</p>
<pre><code>#
+#(\S)(\S*) ((\1)|(\S))/\1\4#\2 \5
#/
</code></pre>
<p><a href="http://kirbyfan64.github.io/rs/index.html?script=%23%0A%2B%23(%5CS)(%5CS*)%20((%5C1)%7C(%5CS))%2F%5C1%5C4%23%5C2%20%5C5%0A%23%2F%0A&amp;input=chameleon%20caln%0Aabcdefghij%20abc%0Alizard%20iard%0Acoconut%20co%0Aonomatopoeia%20ooaoo%0Aonomatopoeia%20oao%0A" rel="nofollow noreferrer">Live demo and test suite.</a></p>
</div>
<div id="pu20" class="pu"><h1>Python 2, 77</h1>

<pre><code>def f(x,y,b=''):
 for i in x:
    try:
     if i==y[0]:i=y.pop(0)*2
    except:0
    b+=i
 print b
</code></pre>

<p>Call as:</p>

<pre><code>f('onomatopoeia',['o','a','o'])
</code></pre>

<p>I may have got the byte count horribly wrong... Uses a mixture of spaces and tabs.</p>
</div>
<div id="pu21" class="pu"><h1>JavaScript ES6, 47 bytes</h1>

<pre><code>(w,s)=&gt;w.replace(/./g,c=&gt;c==s[0]?c+s.shift():c)
</code></pre>

<p>Assumes <code>s</code> is an array <code>["c","a","l","n"]</code></p>
</div>
<div id="pu22" class="pu"><h1>Retina, 33 bytes</h1>

<p><a href="https://github.com/mbuettner/retina" rel="nofollow">More information about Retina.</a></p>

<pre><code>+`(?=(.))(((.)(?&lt;!\4.))+\n)\1
$1$2
</code></pre>

<p>This expects the two strings on STDIN, separated by a newline.</p>

<p>For counting purposes, each line goes into a separate file, <code>\n</code> should be replaced with an actual newline character (0x0A). If you actually want to test this, it's more convenient to put this in a single file where <code>\n</code> remains as it is and then invoke Retina with the <code>-s</code> option before passing the file.</p>

<h2>Explanation</h2>

<p><em>(Outdated... I managed to get rid of the marker... I'll update this later.)</em></p>

<p>Each pair of lines is a regex substitution (first line the pattern, second line the substitution).</p>

<pre><code>^
#
</code></pre>

<p>This puts a <code>#</code> as a marker at the start of the input string.</p>

<pre><code>+`#(.*?(.))(.*\n)\2
$1$2#$3
</code></pre>

<p>This finds the first letter in the input (after the marker) corresponding to the next letter to be duplicated, duplicates that letter, moves the marker behind it, and drops the first character of the second string. The <code>+`</code> at the front tells Retina to do this repeatedly until the string stops changing (in this case, because the second string is empty and all required letters have been duplicated).</p>

<pre><code>#
&lt;empty&gt;
</code></pre>

<p>Finally, we clean up the string by dropping the marker.</p>
</div>
<div id="pu23" class="pu"><h1>Ruby, 46 bytes</h1>

<pre><code>f=-&gt;s,a{a.map{|c|y,s=s.split(c,2);y+c*2}*''+s}
</code></pre>

<p>For each character <code>c</code> in the array <code>a</code>, divide the string <code>s</code> in two halves on the first occurrence of <code>c</code>. Add two copies of the <code>c</code> to the first half, and continue with the other half of <code>s</code>. Join it all together and add the remainder of <code>s</code> :)</p>

<p>Examples:</p>

<pre><code>f["coconut", %w(c o)]
=&gt; "ccooconut"
f["banana", %w(b a a)]
=&gt; "bbaanaana"
</code></pre>
</div>
<div id="pu24" class="pu"><h1>Lua, <s>76</s> <s>78</s> <s>76</s> <s>75</s> <s>58</s> 53 bytes</h1>
<p>New, completely reworked solution with help from wieselkatze and SquidDev! come on guys, we can beat brainfuck :P</p>
<pre><code>function f(a,b)print((a:gsub(&quot;[&quot;..b..&quot;]&quot;,&quot;%1%1&quot;)))end
</code></pre>
<p>Explanation coming tommorow. <a href="https://repl.it/tpW/1" rel="nofollow noreferrer">Try it here.</a></p>
<hr />
<p>Original solution:
Saved 2 bytes thanks to @kirbyfan64sos!</p>
<p>Lua is a pretty terrible language to golf in, so I think I did pretty good for this one.</p>
<pre><code>function f(x,y)for i=1,#x do g=y:sub(i,i)x=x:gsub(g,g..g,1)end print(x)end
</code></pre>
<p>Code explanation, along with ungolfed version:</p>
<pre><code>function f(x,y) --Define a function that takes the arguements x and y (x is the string to stretch, y is how to stretch it)
  for i=1,#x do --A basic for loop going up to the length of x
    g=y:sub(i,i) -- Define g as y's &quot;i&quot;th letter
    x=x:gsub(g,g..g,1) --Redefine x as x with all letter &quot;g&quot;s having an appended g after them, with a replace limit of 1.
  end
  print(x)
end
</code></pre>
<p><a href="https://repl.it/tfG/1" rel="nofollow noreferrer">Try it here. (Outdated code but same concept, just less golfed, will update tommorow)</a></p>
</div>
<div id="pu25" class="pu"><h1>Mathematica, 66 bytes</h1>
<pre><code>&quot;&quot;&lt;&gt;Fold[Most@#~Join~StringSplit[Last@#,#2-&gt;#2&lt;&gt;#2,2]&amp;,{&quot;&quot;,#},#2]&amp;
</code></pre>
<p>Example:</p>
<pre><code>In[1]:= f = &quot;&quot;&lt;&gt;Fold[Most@#~Join~StringSplit[Last@#,#2-&gt;#2&lt;&gt;#2,2]&amp;,{&quot;&quot;,#},#2]&amp;

In[2]:= f[&quot;banana&quot;, {&quot;n&quot;, &quot;a&quot;}]

Out[2]= &quot;bannaana&quot;
</code></pre>
</div>
<div id="pu26" class="pu"><h1>Prolog, <s>95</s> <s>83</s> <s>79</s> 56 bytes</h1>
<pre><code>d([A|S],H):-put(A),H=[A|T],put(A),d(S,T);d(S,H).
d(_,_).
</code></pre>
<p>Example:</p>
<pre><code>d(`chameleon`,`caln`).
</code></pre>
<p>returns</p>
<pre><code>cchaamelleonn
</code></pre>
<p>Edit: Saved 4 bytes thanks to Oliphaunt</p>
<p>Edit2: Saved 20 bytes using the deprecated <code>put/1</code> SWI-Prolog predicate instead of <code>writef</code>. Saved one byte replacing the recursion end predicate <code>d([],_).</code> to <code>d(_,_).</code>. Won't work if the ordering of the two definitions of <code>d</code> is swapped though, but we don't care about that in golfed code. Saved another 2 bytes removing the parenthesis around <code>H=[A|T],put(A),d(S,T)</code></p>
</div>
<div id="pu27" class="pu"><h3>Excel VBA, 110 bytes</h3>
<p>This is my first entry to CodeGolf so I hope this is ok.</p>
<p>You enter the input word in A1 and then the letters to be replaced in B1 and the resulting word is displayed in a message box.</p>
<pre><code>w = Cells(1, 1)
l = Cells(2, 1)
For i = 1 To Len(w)
x = Left(w, 1)
R = R + x
If InStr(l, x) &gt; 0 Then
R = R + x
End If
w = Right(w, Len(w) - 1)
Next
MsgBox R
</code></pre>
</div>
<div id="pu28" class="pu"><h1>Pyth, 16 bytes</h1>

<pre><code>u|pH&lt;GJxGH&gt;GJwz
</code></pre>

<p>Try it online: <a href="https://pyth.herokuapp.com/?code=u%7CpH%3CGJhxGH%3EGJwz&amp;input=coconut%0Aco&amp;debug=0" rel="nofollow">Demonstration</a></p>

<p>This is quite hacky. Stack-based languages might have an advantage here. </p>

<h3>Explanation</h3>

<pre><code>                   implicit: z = 1st input line, w = 2nd
u             wz   reduce, start with G = z
                   for each H in w, update G to:
        xGH          index of H in G
       h             +1
      J              store in J
    &lt;GJ              substring: G[:J] (everything before index J)
  pH                 print substring then H (without newlines)
 |                   afterwards (actually or, but p always returns 0)
           &gt;GJ       substring: G[J:] (everything from index J to end)
                     update G with ^
                   afterwards implicitly print the remainder G
</code></pre>
</div>
<div id="pu29" class="pu"><h1>Javascript, 47 bytes</h1>
<pre><code>(a,b)=&gt;a.replace(/./g,d=&gt;b[0]!=d?d:d+b.shift())
</code></pre>
<p>Taking advantage of some ES6 features.</p>
</div>
<div id="pu30" class="pu"><h1>Python 2, <s>83</s> <s>74</s> <s>72</s> 65 Bytes</h1>

<p>No real special tricks here. <code>x</code> is the string, <code>y</code> is the array of characters that are duplicated. <s>To clarify if this doesn't copy properly, the first indentation level is a space, the next is a tab.</s></p>

<p><em>Edit 1: Saved 9 bytes by using string manipulation instead of pop().</em></p>

<p><em>Edit 2: Saved 2 bytes by using <code>-~</code> to increment <code>g</code> by 1.</em></p>

<p><em>Edit 3: Saved 7 bytes by using <code>y[:1]</code> trick, thanks to xnor for this!</em></p>



<pre class="lang-python prettyprint-override"><code>def f(x,y,s=''):
 for c in x:g=y[:1]==c;s+=c*-~g;y=y[g:]
 print s
</code></pre>

<p><a href="http://ideone.com/itjEAj" rel="nofollow">Check it out here.</a></p>

<p>Properly formatted and explained:</p>

<pre class="lang-python prettyprint-override"><code>def f(x,y,s=''):           # Defining a function that takes our input,
                           # plus holds a variable we'll append to.
  for c in x:              # For every character in 'x', do the following:
    g = y[:1] == c         # Get the first element from the second string, will
                           # return an empty string if there's nothing left.
                           # Thanks to xnor for this trick!
    s += c * -~g           # Since int(g) would either evaluate to 0 or 1, we
                           # use the -~ method of incrementing g to multiply
                           # the character by 1 or 2 and append it to 's'
    y = y[g:]              # Again, since int(g) would either evaluate to 0
                           # or 1, use that to cut the first value off y, or
                           # keep it if the characters didn't match.
  print s                  # Print the string 's' we've been appending to.
</code></pre>
</div>
<div id="pu31" class="pu"><h2>Python, 61</h2>



<pre class="lang-python prettyprint-override"><code>def f(s,l):b=s[:1]==l[:1];return s and-~b*s[0]+f(s[1:],l[b:])
</code></pre>

<p>A greedy recursive solution. Saves to <code>b</code> whether the first letter of the string <code>s</code> is the first letter of the string <code>l</code> of letters to double. If so, take one of that letter and prepend it to the recursive call with the rest of <code>s</code>, removing the first element from <code>l</code>. If not <code>b</code>, do the same but don't double the letter and don't remove from <code>l</code>.</p>

<p>The code checks <code>s[:1]==l[:1]</code> rather than <code>s[0]==l[0]</code> to avoid an index-out-of-bounds error when <code>s</code> or <code>l</code> is empty.</p>
</div>
<div id="pu32" class="pu"><h1>JavaScript ES6, 72 bytes</h1>

<pre class="lang-js prettyprint-override"><code>(s,a,i=0,b=[...s])=&gt;a.map(l=&gt;b.splice(i=b.indexOf(l,i+2),0,l))&amp;&amp;b.join``
</code></pre>

<p>This is an anonymous function that takes 2 parameters: the starting word as a string and the characters to stretch as an array. Ungolfed code that uses ES5 and test UI below.</p>

<p><div class="snippet" data-lang="js" data-hide="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>f=function(s,a){
  i=0
  b=s.split('')
  a.map(function(l){
    i=b.indexOf(l,i+2)
    b.splice(i,0,l)
  })
  return b.join('')
}

run=function(){document.getElementById('output').innerHTML=f(document.getElementById('s').value,document.getElementById('a').value.split(''))};document.getElementById('run').onclick=run;run()</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;label&gt;Starting word: &lt;input type="text" id="s" value="onomatopoeia" /&gt;&lt;/label&gt;&lt;br /&gt;
&lt;label&gt;Leters to duplicate: &lt;input type="text" id="a" value="oao"/&gt;&lt;/label&gt;&lt;br /&gt;
&lt;button id="run"&gt;Run&lt;/button&gt;&lt;br /&gt;Output: &lt;output id="output"&gt;&lt;/output&gt;</code></pre>
</div>
</div>
</p>
</div>
<div id="pu33" class="pu"><h1>Pyth, <s>18</s> 17 bytes</h1>

<pre><code>sm?+d.(QZqd&amp;QhQdz
</code></pre>

<p><a href="https://pyth.herokuapp.com/?code=sm%3F%2Bd.(QZqd%26QhQdz&amp;input=chameleon%0A%5B%27c%27%2C%27l%27%2C%27a%27%2C%27n%27%5D&amp;debug=1" rel="nofollow">Live demo.</a></p>

<p>Saved 1 byte thanks to @Jakube.</p>

<h2>Explanation:</h2>

<pre><code>                z  Read the first line of input.
 m                 For each character in that line
  ?      qd&amp;QhQ    If (?) the first char of the stretch list (`&amp;QhQ`) 
                   and the current character are equal,
   +d.(QZ          Then double the current character and pop an element off
                   the stretch list.
               d   Otherwise, just return the same character.
s                  Join all the characters together.
</code></pre>

<h2>Original version:</h2>

<pre><code>jkm?+d.(QZqd&amp;QhQdz
</code></pre>

<p><a href="https://pyth.herokuapp.com/?code=jkm%3F%2Bd.(QZqd%26QhQdz&amp;input=chameleon%0A%5B%27c%27%2C%27l%27%2C%27a%27%2C%27n%27%5D&amp;debug=1" rel="nofollow">Live demo for original.</a></p>
</div>
<div id="pu34" class="pu"><h1>Python, <s>53</s> 92 bytes</h1>

<p>Found my solution to be the same length in both Python 2 and 3.</p>

<p>EDIT: Man, fixing that case when doing multiple replaces of the same letter (while still using the same method) took a bit of work.</p>



<h3>Python 2:</h3>

<p><a href="http://ideone.com/DWTDDZ" rel="nofollow"><strong>Try it here</strong></a></p>

<pre class="lang-python prettyprint-override"><code>def f(s,t):
 for c in t:s=s.replace(c,'%',1)
 print s.replace('%','%s')%tuple(x*2for x in t)
</code></pre>

<h3>Python 3:</h3>

<pre class="lang-python prettyprint-override"><code>s,*t=input()
for c in t:s=s.replace(c,'%',1)
print(s.replace('%','%s')%tuple(x*2for x in t))
</code></pre>
</div>
<div id="pu35" class="pu"><h1>Haskell, 42 bytes</h1>

<pre><code>(a:b)#e@(c:d)|a==c=a:a:b#d|1&lt;2=a:b#e
a#_=a
</code></pre>

<p>Usage example:</p>

<pre><code>*Main&gt; "coconut" # "co"
"ccooconut"
*Main&gt; "lizard" # "iard"
"liizaarrdd"
*Main&gt; "onomatopoeia" # "ooaoo"
"oonoomaatoopooeia"
</code></pre>

<p>How it works:</p>

<p>If one string is empty, the result is the first string. Else: if the first characters of the strings match, take it two times and append a recursive call with the tails of the strings. If the characters don't match, take the first character of the first string and append a recursive call with the tail of the first string and the same second string. </p>
</div>
<div id="pu36" class="pu"><h1>C, 62 bytes</h1>

<pre class="lang-c prettyprint-override"><code>f(char*s,char*c){while(*s-*c||putchar(*c++),*s)putchar(*s++);}
</code></pre>
<p>Well, this is surprisingly competetive.</p>
<p>We define a function <code>f(char*, char*)</code> that takes the string as its first input and the array of characters to duplicate as its second input.</p>
<p>Some testing code:</p>
<pre class="lang-c prettyprint-override"><code>int main (int argc, char** argv) {
    f(&quot;onomatopeia&quot;, &quot;oao&quot;);
    return 0;
}
</code></pre>
<p>Which prints:</p>
<pre class="lang-c prettyprint-override"><code>oonomaatoopeia
</code></pre>
<p>Try it <a href="http://ideone.com/IVHCqG" rel="noreferrer">online</a>!</p>
<p>If it is acceptable to submit a macro rather than a function, the following <code>#define g(s,c)</code> is just <strong>58 bytes</strong>, but requires <code>s</code> and <code>c</code> to be actual pointers:</p>
<pre class="lang-c prettyprint-override"><code>#define g(s,c)while(*s-*c||putchar(*c++),*s)putchar(*s++);
</code></pre>
</div>
<div id="pu37" class="pu"><h1>CJam, 15 bytes</h1>

<pre><code>rr{:X/(XX+@X*}/
</code></pre>

<p>An alternative CJam approach. <a href="http://cjam.aditsu.net/#code=rr%7B%3AX%2F%28XX%2B%40X*%7D%2F&amp;input=onomatopoeia%20oao">Try it online</a></p>

<h2>Explanation</h2>

<p>For each character in the second string, we do two things.</p>

<ol>
<li><p>Split the current suffix of the string by the character, e.g. <code>"beeper" "e"  -&gt;  ["b" "" "p" "r"]</code></p></li>
<li><p>Uncons the first string in the array, insert two of the character, then rejoin the rest of the array with the character, e.g. <code>"b" "ee" "eper"</code>. The last string is the new suffix.</p></li>
</ol>
</div>
<div id="pu38" class="pu"><h1>CJam, 15 bytes</h1>

<pre><code>rr{_C#)/(C@s}fC
</code></pre>

<p><a href="http://cjam.aditsu.net/#code=rr%7B_C%23)%2F(C%40s%7DfC&amp;input=onomatopoeia%20oao">Try it online.</a></p>

<h3>How it works</h3>

<pre><code>rr              e# Read two whitespace-separated tokens from STDIN.
  {         }fC e# For each character C in the second string.
   _            e#   Duplicate the first string.
    C#          e#   Compute the index of the character in the string.
      )/        e#   Add 1 and split the string in slice of that size.
        (       e#   Shift out the first slice.
         C      e#   Push the character.
          @     e#   Rotate the remainder of the string in top of the stack.
           s    e#   Stringify (concatenate the slices).
</code></pre>
</div>
<div id="pu39" class="pu"><h1>Brainfuck, <s>46</s> 45 (63 with printable characters in input)</h1>

<p>Compatible with Alex Pankratov's <a href="http://swapped.cc/#!/bff">bff</a> (brainfuck interpreter used on SPOJ and ideone) and Thomas Cort's <a href="http://esoteric.sange.fi/brainfuck/impl/interp/BFI.c">BFI</a> (used on Anarchy Golf).</p>

<p>The printable version takes the array first as a string, followed by a tab, followed by the starting string with no trailing newline.</p>

<p><a href="http://ideone.com/4d2L5E">Demonstration</a> on ideone.</p>

<pre><code>-[+&gt;,---------]
&lt;[++++++++&lt;]
&lt;,+
[
  -.
  [&gt;+&gt;-&lt;&lt;-]
  &gt;&gt;
  [
    &lt;[&gt;+&lt;-]
  ]
  &lt;[.[-]]
  ,+
]
</code></pre>

<p>We can save some bytes by using <code>\x00</code> as a separator instead of tab:</p>

<pre><code>,[&gt;,]
&lt;[&lt;]
&lt;,+
[
  -.
  [&gt;+&gt;-&lt;&lt;-]
  &gt;&gt;
  [
    &lt;[&gt;+&lt;-]
  ]
  &lt;[.[-]]
  ,+
]
</code></pre>
</div>
