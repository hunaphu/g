<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::21743</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>083</td><td>APLNARS</td><td>250325T164315Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/278903#278903">Rosario</a></td></tr>
<tr d-ix="1"><td>4411</td><td>MMIX</td><td>210429T193625Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/224693#224693">NoLonger</a></td></tr>
<tr d-ix="2"><td>nan</td><td></td><td>180326T153032Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/160336#160336">Ramanath</a></td></tr>
<tr d-ix="3"><td>nan</td><td></td><td>180326T152559Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/160335#160335">Ramanath</a></td></tr>
<tr d-ix="4"><td>nan</td><td>Stax</td><td>180302T172706Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/157057#157057">Weijun Z</a></td></tr>
<tr d-ix="5"><td>7372</td><td>Javascript 73/72 characters</td><td>140222T154645Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/21773#21773">Victor S</a></td></tr>
<tr d-ix="6"><td>057</td><td>Js</td><td>180302T144231Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/157048#157048">Luis fel</a></td></tr>
<tr d-ix="7"><td>069</td><td>C</td><td>170518T235817Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/121476#121476">ceilingc</a></td></tr>
<tr d-ix="8"><td>024</td><td>TIBasic</td><td>140222T181428Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/21786#21786">Timtech</a></td></tr>
<tr d-ix="9"><td>051</td><td>GameMaker Language</td><td>140222T183401Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/21790#21790">Timtech</a></td></tr>
<tr d-ix="10"><td>053</td><td>AWK</td><td>170228T150113Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/111662#111662">Robert B</a></td></tr>
<tr d-ix="11"><td>028</td><td>J</td><td>140227T164006Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/22334#22334">jpjacobs</a></td></tr>
<tr d-ix="12"><td>037</td><td>Smalltalk</td><td>140224T225200Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/22049#22049">blabla99</a></td></tr>
<tr d-ix="13"><td>nan</td><td></td><td>140225T204107Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/22143#22143">danmcard</a></td></tr>
<tr d-ix="14"><td>nan</td><td></td><td>140225T201940Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/22140#22140">Justin</a></td></tr>
<tr d-ix="15"><td>181</td><td>Java</td><td>140222T175522Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/21785#21785">md_rasle</a></td></tr>
<tr d-ix="16"><td>031</td><td>APL</td><td>140223T140115Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/21877#21877">mniip</a></td></tr>
<tr d-ix="17"><td>016</td><td>J</td><td>140223T123213Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/21871#21871">mudri</a></td></tr>
<tr d-ix="18"><td>6962</td><td>SageMath</td><td>140222T125801Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/21745#21745">yo&#39;</a></td></tr>
<tr d-ix="19"><td>055</td><td>Javascript</td><td>140222T155453Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/21774#21774">Michael </a></td></tr>
<tr d-ix="20"><td>092</td><td>Perl</td><td>140222T193518Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/21793#21793">Heiko Ob</a></td></tr>
<tr d-ix="21"><td>061</td><td>PHP</td><td>140222T182021Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/21788#21788">Amal</a></td></tr>
<tr d-ix="22"><td>157</td><td>Javascript</td><td>140222T130107Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/21748#21748">Victor S</a></td></tr>
<tr d-ix="23"><td>081</td><td>PHP</td><td>140222T125817Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/21747#21747">Razvan</a></td></tr>
<tr d-ix="24"><td>035</td><td>Haskell</td><td>140222T125808Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/21746#21746">mniip</a></td></tr>
<tr d-ix="25"><td>062</td><td>Python</td><td>140222T130133Z</td><td><a href="https://codegolf.stackexchange.com/questions/21743/calculate-the-cube-root-of-a-number/21749#21749">primo</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>APL(NARS), 83 chars</h1>
<pre><code>r←q w;t;e
t←1v⋄e←÷10*⌊(⎕FPC-{1&gt;∣w:0⋄1+2⍟∣w})÷3.322v
→3×⍳e&gt;∣t-r←t-3÷⍨t-w÷t×t⋄t←r⋄→2
</code></pre>
<p>//10+42+31=83</p>
<p>I followed the formula written in the post: <a href="https://codegolf.stackexchange.com/a/21793/120560">https://codegolf.stackexchange.com/a/21793/120560</a>.
I think I have found the formula for min error allowable from +-*/
operations in the float point lenght xBit, due the precision is
affected from the lenght of the integer part of the input number...</p>
<p>The error would be less than <code>e←÷10*⌊(⎕FPC-{1&gt;∣w:0⋄1+2⍟∣w})÷3.322v</code> where
<code>w</code> is the input number, <code>⎕FPC</code> is the lenght in bit of the float point
<code>1+2⍟w</code> would be the lenght in bit of integer part of <code>w</code>,
log_2(10)=3.32192809 here approximated as 3.322 (I don't know if
it is the right number).   Test</p>
<pre><code>  aaa←27 64 1 18.609625 3652264 0.001 7 2E¯13 0 
  q¨aaa
3 4 1 2.65 154 0.1 1.912931183 0.00005848035476 1.381590388E¯38 
  q¨-aaa
¯3 ¯4 ¯1 ¯2.65 ¯154 ¯0.1 ¯1.912931183 ¯0.00005848035476 1.381590388E¯38 
</code></pre>
<p>note that it seems ok even with rationals...</p>
<pre><code>  q 2
1.25992105 
  q 2v
1.25992105 
  q 2x
1.25992105 
</code></pre>
<p>for big numbers it is possible too</p>
<pre><code>  ⎕fpc←512
  512÷3.322
154.1240217
  150⍕q 2v
1.259921049894873164767210607278228350570251464701507980081975112155299676513959483729396562436255094154310256035615665259399024040613737228459110304269
</code></pre>
<p>It is possible that I make some error and there is a number that
generate one infinite loop because <code>e</code> variable in code is too little (for example if variable t or r have integer part &gt; of input w even if t-r decrease)</p>
</div>
<div id="pu1" class="pu"><h1>MMIX, 44 bytes (11 instrs)</h1>
<pre><code>E0013FF0 48000002 E8018000 C1FF0100
1001FFFF 14010001 040101FF E401FFF0
11FF01FF 53FFFFFA F8020000
</code></pre>
<h1>Disassembly</h1>
<pre><code>cbrt    SETH  $1,#3FF0      // y = 1.
        BNN   $0,0F         // if(x &gt;= 0) goto loop (ensuring sign is correct)
        ORH   $1,#8000      // y = fnabs(y) (bit tricks!)
0H      SET   $255,$1       // loop: prev = y
        FMUL  $1,$255,$255  // y = prev *. prev
        FDIV  $1,$0,$1      // y = x /. y
        FADD  $1,$1,$255    // y = y +. prev
        INCH  $1,#FFF0      // y = y /. 2. (bit tricks again)
        FCMPE $255,$1,$255  // prev = comp_eps(y, prev)
        PBNZ  $255,0B       // if(prev) goto loop
        POP   2,0           // return {y,x}
</code></pre>
<p>It is up to the caller to set a suitable value of <code>rE</code>. Much faster convergence may be arranged by essentially setting <code>y</code> up by dividing the exponent by 3, but that costs another four instructions (though in time it pays really quickly, since three <code>FDIV</code>s cost about the same amount as two <code>DIV</code>s):</p>
<pre><code>cbrt    SLU  $1,$0,1    // 3B010001 shift left to erase sign
        INCH $1,#8020   // E4018020 unbias exponent
        DIV  $1,$1,3    // 1D010103 divide by 3 as integer; approximate cube root
        INCH $1,#7FE0   // E4017FE8 rebias exponent
        SRU  $1,$1,1    // 3F010101 shift right again
</code></pre>
<p>and then continue from the second line in the original.</p>
<p>If mispredicted branches are particularly expensive, I would also replace the second and third lines of the original with:</p>
<pre><code>        ZSN $255,$0,1       // 71020001 $255 = ($0 neg? 1 : 0)
        SLU $255,$255,63    // 3B02023F $255 &lt;&lt;= 63
        OR  $1,$1,$255      // C0010102 $1 |= $255
</code></pre>
<p>This costs one more instruction, but is branchless.</p>
</div>
<div id="pu2" class="pu"><p><strong>Python Solution</strong></p>

<pre><code>def cube_root(num):
    if num == 0:
        return 0

    t = 0
    absNum = abs(num)
    root = absNum/3

    while (t - root) != 0:
        t = root
        root = (1/3) * ((2 * root) + absNum/(root * root))

    return root * (num / absNum)
</code></pre>
</div>
<div id="pu3" class="pu"><p><strong>JAVA Solution</strong></p>

<p>public BigDecimal cubeRoot(BigDecimal number) {</p>

<pre><code>    if(number == null || number.intValue() == 0) return BigDecimal.ZERO;
    BigDecimal absNum = number.abs();
    BigDecimal t;
    BigDecimal root =  absNum.divide(BigDecimal.valueOf(3), MathContext.DECIMAL128);


    do {

        t = root;
        root = root.multiply(BigDecimal.valueOf(2))
                .add(absNum.divide(root.multiply(root), MathContext.DECIMAL128))
                .divide(BigDecimal.valueOf(3), MathContext.DECIMAL128);

    } while (t.toBigInteger().subtract(root.toBigInteger()).intValue() != 0);

    return root.multiply(number.divide(absNum), MathContext.DECIMAL128);
}
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/tomtheisen/stax" rel="nofollow noreferrer">Stax</a>, 10 <a href="https://github.com/tomtheisen/stax/blob/master/docs/packed.md#packed-stax" rel="nofollow noreferrer">bytes</a><sup>CP437</sup></h1>
<pre><code>╘♀┘A╕äO¶∩'
</code></pre>
<p><a href="https://staxlang.xyz/#c=%E2%95%98%E2%99%80%E2%94%98A%E2%95%95%C3%A4O%C2%B6%E2%88%A9%27&amp;i=27%0A64%0A1%0A18.609625%0A3652264%0A0.001%0A7&amp;a=1&amp;m=2" rel="nofollow noreferrer">Run and debug online!</a></p>
<h2>Explanation</h2>
<p>Uses the unpacked version to explain.</p>
<pre><code>gpJux*_+h4je
gp              Iterate until a fixed point is found, output the fix point
  Ju            Inverse of square
    x*          Multiplied by input
      _+h       Average of the value computed by last command and the value at current iteration
         4je    Round to 4 decimal digits
  
</code></pre>
</div>
<div id="pu5" class="pu"><h2>Javascript: 73/72 characters</h2>
<p>This algorithm is lame, and exploits the fact that this question is limited to 4 digits after the decimal point. It is a modified version of the algorithm that I suggested in the sandbox for the purpose of reworking the question. It counts from zero to the infinite while <code>h*h*h&lt;a</code>, just with a multiplication and division trick to handle the 4 decimal digits pecision.</p>
<pre class="lang-javascript prettyprint-override"><code>function g(a){if(a&lt;0)return-g(-a);for(h=0;h*h*h&lt;1e12*a;h++);return h/1e4}
</code></pre>
<p>Edit, 4 years later: As suggested by Luis felipe De jesus Munoz, by using <code>**</code> the code is shorter, but that feature was not available back in 2014 when I wrote this answer. Anyway, by using it, we shave an extra character:</p>
<pre class="lang-javascript prettyprint-override"><code>function g(a){if(a&lt;0)return-g(-a);for(h=0;h**3&lt;1e12*a;h++);return h/1e4}
</code></pre>
</div>
<div id="pu6" class="pu"><h2>Js 57 bytes</h2>

<p><code>f=(x)=&gt;eval('for(w=0;w**3&lt;1e12*x;w++);x&lt;0?-f(-x):w/1e4')</code></p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>f=(x)=&gt;eval('for(w=0;w**3&lt;1e12*x;w++);x&lt;0?-f(-x):w/1e4')
document.getElementById('div').innerHTML += f(-27) + '&lt;br&gt;'
document.getElementById('div').innerHTML += f(-64) + '&lt;br&gt;'
document.getElementById('div').innerHTML += f(-1) + '&lt;br&gt;'
document.getElementById('div').innerHTML += f(-18.609625) + '&lt;br&gt;'
document.getElementById('div').innerHTML += f(-3652264) + '&lt;br&gt;'
document.getElementById('div').innerHTML += f(-0.001) + '&lt;br&gt;'
document.getElementById('div').innerHTML += f(-7) + '&lt;br&gt;&lt;hr&gt;'
document.getElementById('div').innerHTML += f(27) + '&lt;br&gt;'
document.getElementById('div').innerHTML += f(64) + '&lt;br&gt;'
document.getElementById('div').innerHTML += f(1) + '&lt;br&gt;'
document.getElementById('div').innerHTML += f(18.609625) + '&lt;br&gt;'
document.getElementById('div').innerHTML += f(3652264) + '&lt;br&gt;'
document.getElementById('div').innerHTML += f(0.001) + '&lt;br&gt;'
document.getElementById('div').innerHTML += f(7) + '&lt;br&gt;'</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;div id="div"&gt;&lt;/div&gt;</code></pre>
</div>
</div>
</p>
</div>
<div id="pu7" class="pu"><h1>C, 69 bytes</h1>
<pre><code>i;float g(float x){for(float y=x;++i%999;x=x*2/3+y/3/x/x);return x;}
</code></pre>
<p>Just another implementation of Newton's method. <a href="https://tio.run/nexus/c-gcc#NY/dqsIwEITv@xSDIjT2J3iKFyXWJ/Emx3Y1kCbSphiRvrqxOXpg2WGH@WB2rcxZT213GF2rbHk9Jut/p5fuuhhBCdJWOlzSj3r2JDt8j0fjRZapTV3Xwjd@@8Or7MEr7rlnYujcNBh4MQdlHHqpTMqeCRB5tHb61R2oKfYCdIgra8odGGIEuA0LRClWG8LfnMwqB@W42Xu6yK7kFctjLQYmFmRO5vA6k5aXMRREcnRF/CEUun8D" rel="nofollow noreferrer" title="C (gcc) – TIO Nexus">Try it online!</a></p>
</div>
<div id="pu8" class="pu"><h1>TI-Basic, <s>26</s> 24 bytes</h1>
<pre><code>Input :1:For(I,1,9:2Ans/3+X/(3AnsAns:End
</code></pre>
</div>
<div id="pu9" class="pu"><h1>GameMaker Language, 51 bytes</h1>
<pre><code>for(i=x=1;i++&lt;99;1)x=(2*x+argument0/x/x)/3;return x
</code></pre>
</div>
<div id="pu10" class="pu"><h2>AWK, 53 bytes</h2>
<pre><code>{for(n=x=$1;y-x;){y=x;x=(2*x+n/x/x)/3}printf&quot;%.4g&quot;,y}
</code></pre>
<p>Example usage:</p>
<pre><code>$ awk '{for(n=x=$1;y-x;){y=x;x=(2*x+n/x/x)/3}printf&quot;%.4g&quot;,y}' &lt;&lt;&lt; 18.609625 
2.65$
</code></pre>
<p>Thanks go to @Mig for the <code>JavaScript</code> solution which this is derived from. It runs surprisingly quickly given that the <code>for</code> loop requires the iteration to stop changing.</p>
</div>
<div id="pu11" class="pu"><h2>J 28</h2>

<pre><code>*@[*(3%~+:@]+(%*~@]))^:_&amp;|&amp;1
</code></pre>

<p>Using Newtons method, finding the root of <code>x^3 - X</code> the update step is <code>x - (x^3 - C)/(3*x^2)</code>, where x is the current guess, and C the input. Doing the maths on this one yields the ridiculously simple expression of <code>(2*x+C/x^2) /3</code> . Care has to be taken for negative numbers.</p>

<p>Implemented in J, from right to left:</p>

<ol>
<li><code>|</code> Take abs of both arguments, pass them on</li>
<li><code>^:_</code> Do until convergence</li>
<li><code>(%*~@])</code> is <code>C / x^2</code> (<code>*~ y</code> is equivalent to <code>y * y</code>)</li>
<li><code>+:@]</code> is <code>2 x</code></li>
<li><code>3%~</code> divide by three. This yields the positive root</li>
<li><code>*@[ * positive_root</code> multiplies positive root with the signum of C.</li>
</ol>

<p>Test run: </p>

<pre><code>   NB. give it a name:
   c=: *@[*(3%~+:@]+(%*~@]))^:_&amp;|&amp;1
   c 27 64 1 18.609625 3652264 0.001 7
3 4 1 2.65 154 0.1 1.91293
</code></pre>
</div>
<div id="pu12" class="pu"><h1>Smalltalk, 37</h1>
<p>credit goes to mniip for the algorithm; Smalltalk version of his code:</p>
<p>input in n; output in x:</p>
<pre><code>1to:(x:=99)do:[:i|x:=2*x+(n/x/x)/3.0]
</code></pre>
<p>or, as a block</p>
<pre><code>[:n|1to:(x:=99)do:[:i|x:=2*x+(n/x/x)/3.0].x]
</code></pre>
</div>
<div id="pu13" class="pu"><h2>Haskell: 99C</h2>

<p>Can't beat @mniip in cleverness. I just went with a binary search.</p>

<pre><code>c x=d 0 x x
d l h x
 |abs(x-c)&lt;=t=m
 |c &lt; x=d m h x
 |True=d l m x
 where m=(l+h)/2;c=m*m*m;t=1e-4
</code></pre>

<p>Ungolfed:</p>

<pre><code>-- just calls the helper function below
cubeRoot x = cubeRoot' 0 x x

cubeRoot' lo hi x
    | abs(x-c) &lt;= tol = mid           -- if our guess is within the tolerance, accept it
    | c &lt; x = cubeRoot' mid hi x      -- shot too low, narrow our search space to upper end
    | otherwise = cubeRoot' lo mid x  -- shot too high, narrow search space to lower end
    where
        mid = (lo+hi)/2
        cubed = mid*mid*mid
        tol = 0.0001
</code></pre>
</div>
<div id="pu14" class="pu"><h1>Befunge 98 - Work in progress</h1>
<p>This language does not support floating point numbers; this attempts to emulate them. It currently works for positive numbers that do not start with <code>0</code> after the decimal point (mostly). However, it only outputs to 2 decimal places.</p>
<pre><code>&amp;5ka5k*&amp;+00pv
:::**00g`!jv&gt;1+
/.'.,aa*%.@&gt;1-:aa*
</code></pre>
<p>It works by inputting the part before the decimal point, multiplying that by <code>100000</code>, then inputting the part after the point and adding the two numbers together. The second line does a counter until the cube is greater than the inputted number. Then the third line extracts the decimal number from the integer.</p>
<p>If anyone can tell me why the third line only divides by <code>100</code> to get the correct values, please tell me.</p>
<p>IOs:</p>
<pre><code>27.0       3 .0
64.0       4 .0
1.0        1 .0
18.609625  2 .65
0.001      0 .1
7.0        1 .91

0.1        0 .1
</code></pre>
</div>
<div id="pu15" class="pu"><h2>Java, <strike>207</strike> <strike>182</strike> 181</h2>

<p>Sometimes when I play golf I have two many beers and play really really bad</p>

<pre class="lang-java prettyprint-override"><code>class n{public static void main(String[]a){double d=Double.valueOf(a[0]);double i=d;for(int j=0;j&lt;99;j++)i=(d/(i*i)+(2.0*i))/3.0;System.out.println((double)Math.round(i*1e4)/1e4);}}
</code></pre>

<p>Iterative Newton's Method of Approximation, runs 99 iterations.</p>

<p>Here is the unGolfed:</p>

<pre class="lang-java prettyprint-override"><code>class n{
    public static void main(String a[]){
        //assuming the input value is the first parameter of the input
        //arguments as a String, get the Double value of it
        double d=Double.valueOf(a[0]);
        //Newton's method needs a guess at a starting point for the 
        //iterative approximation, there are much better ways at 
        //going about this, but this is by far the simplest. Given
        //the nature of the problem, it should suffice fine with 99 iterations
        double i=d;

        //make successive better approximations, do it 99 times
        for(int j=0;j&lt;99;j++){
            i=( (d/(i*i)) + (2.0*i) ) / 3.0;
        }
        //print out the answer to standard out
        //also need to round off the double to meet the requirements
        //of the problem.  Short and sweet method of rounding:
        System.out.println( (double)Math.round(i*10000.0) / 10000.0 );
    }
}
</code></pre>
</div>
<div id="pu16" class="pu"><h1>APL - 31</h1>

<pre><code>(×X)×+/1,(×\99⍴(⍟|X←⎕)÷3)÷×\⍳99
</code></pre>

<p>Uses the fact that <code>cbrt(x)=e^(ln(x)/3)</code>, but instead of doing naive <code>⋆</code> exponentiation, it computes <code>e^x</code> using Taylor/Maclaurin series.</p>

<p>Sample runs:</p>

<pre><code>⎕: 27
3
⎕: 64
4
⎕: 1
1
⎕: 18.609625
2.65
⎕: 3652264
154
⎕: 0.001
0.1
⎕: 7
1.912931183
⎕: ¯27
¯3
⎕: ¯7
¯1.912931183
</code></pre>

<p>Seeing as there's a <a href="https://codegolf.stackexchange.com/a/21871/7162">J answer</a> in 16 characters, I must be really terrible at APL...</p>
</div>
<div id="pu17" class="pu"><h1>J: 16 characters</h1>

<p>Loose translation of the Haskell answer:</p>

<pre><code>-:@((%*~)+])^:_~
</code></pre>

<p>Test cases:</p>

<pre><code>   -:@((%*~)+])^:_~27
3
   -:@((%*~)+])^:_~64
4
   -:@((%*~)+])^:_~1
1
   -:@((%*~)+])^:_~18.609625
2.65
   -:@((%*~)+])^:_~3652264
154
   -:@((%*~)+])^:_~0.001
0.1
   -:@((%*~)+])^:_~7
1.91293
</code></pre>

<p>It works like this:</p>

<pre><code>     (-:@((% *~) + ])^:_)~ 27
↔ 27 (-:@((% *~) + ])^:_) 27
↔ 27 (-:@((% *~) + ])^:_) 27 (-:@((% *~) + ])) 27
↔ 27 (-:@((% *~) + ])^:_) -: ((27 % 27 * 27) + 27)
↔ 27 (-:@((% *~) + ])^:_) 13.5185
↔ 27 (-:@((% *~) + ])^:_) 27 (-:@((% *~) + ])) 13.5185
↔ 27 (-:@((% *~) + ])^:_) -: ((27 % 13.5185 * 13.5185) + 13.5185)
↔ 27 (-:@((% *~) + ])^:_) 6.83313
...
</code></pre>

<p>In words:</p>

<pre><code>half =. -:
of =. @
divideBy =. %
times =. *
add =. +
right =. ]
iterate =. ^:
infinite =. _
fixpoint =. iterate infinite
by_self =. ~

-:@((%*~)+])^:_~ ↔ half of ((divideBy times by_self) add right) fixpoint by_self
</code></pre>

<p>Not one of the best wordy translations, since there's a dyadic fork and a <code>~</code> right at the end.</p>
</div>
<div id="pu18" class="pu"><h2>SageMath, (69) 62 bytes</h2>

<p>However, don't ever believe it will give you the result, it's very difficult to go randomly through all the numbers:</p>

<pre><code>def r(x):
 y=0
 while y*y*y-x:y=RR.random_element()
 return "%.4f"%y
</code></pre>

<p>if you didn't insist on truncating:</p>

<pre><code>def r(x):
 y=0
 while y*y*y-x:y=RR.random_element()
 return y
</code></pre>

<h2>SageMath, 12 bytes, if <code>exp</code> is allowed</h2>

<p>Works for all stuff: positive, negative, zero, complex, ...</p>

<pre><code>exp(ln(x)/3)
</code></pre>
</div>
<div id="pu19" class="pu"><h2>Javascript (55)</h2>

<p><code>function f(n){for(i=x=99;i--;)x=(2*x+n/x/x)/3;return x}</code></p>

<p><strong>BONUS, General formulation for all roots</strong><br>
<code>function f(n,p){for(i=x=99;i--;)x=x-(x-n/Math.pow(x,p-1))/p;return x}</code></p>

<p>For cube root, just use <code>f(n,3)</code>, square root <code>f(n,2)</code>, etc...
Example : <code>f(1024,10)</code> returns <code>2</code>.</p>

<p><strong>Explanation</strong><br>
Based on Newton method :</p>

<p>Find : <code>f(x) = x^3 - n = 0</code>, the solution is <code>n = x^3</code><br>
The derivation : <code>f'(x) = 3*x^2</code></p>

<p>Iterate :<br>
<code>x(i+1) = x(i) - f(x(i))/f'(x(i)) = x(i) + (2/3)*x + (1/3)*n/x^2</code></p>

<p><strong>Tests</strong>  </p>

<pre><code>[27,64,1,18.609625,3652264,0.001,7].forEach(function(n){console.log(n + ' (' + -n + ') =&gt; ' + f(n) + ' ('+ f(-n) +')')})

27 (-27) =&gt; 3 (-3)
64 (-64) =&gt; 4 (-4)
1 (-1) =&gt; 1 (-1)
18.609625 (-18.609625) =&gt; 2.65 (-2.65)
3652264 (-3652264) =&gt; 154 (-154)
0.001 (-0.001) =&gt; 0.09999999999999999 (-0.09999999999999999)
7 (-7) =&gt; 1.912931182772389 (-1.912931182772389) 
</code></pre>
</div>
<div id="pu20" class="pu"><h2>Perl, 92 bytes</h2>

<pre class="lang-perl prettyprint-override"><code>sub a{$x=1;while($d=($x-$_[0]/$x/$x)/3,abs$d&gt;1e-9){$x-=$d}$_=sprintf'%.4f',$x;s/\.?0*$//;$_}
</code></pre>

<ul>
<li>The function <code>a</code> returns a string with the number without
an unnecessary fraction part or insignificant zeroes at the right end.</li>
</ul>

<p>Result:</p>

<pre><code>              27 --&gt; 3
             -27 --&gt; -3
              64 --&gt; 4
             -64 --&gt; -4
               1 --&gt; 1
              -1 --&gt; -1
       18.609625 --&gt; 2.65
      -18.609625 --&gt; -2.65
         3652264 --&gt; 154
        -3652264 --&gt; -154
           0.001 --&gt; 0.1
          -0.001 --&gt; -0.1
               7 --&gt; 1.9129
              -7 --&gt; -1.9129
 0.0000000000002 --&gt; 0.0001
-0.0000000000002 --&gt; -0.0001
               0 --&gt; 0
              -0 --&gt; 0
</code></pre>

<p>Generated by</p>

<pre><code>sub test{
    my $a = shift;
    printf "%16s --&gt; %s\n", $a, a($a);
    printf "%16s --&gt; %s\n", "-$a", a(-$a);
}
test 27;
test 64;
test 1;
test 18.609625;
test 3652264;
test 0.001;
test 7;
test "0.0000000000002";
test 0;
</code></pre>

<p>The calculation is based on <a href="http://en.wikipedia.org/wiki/Newton%27s_method" rel="nofollow noreferrer">Newton's method</a>:</p>

<p><img src="https://i.sstatic.net/6BmRj.png" alt="Calculation"></p>
</div>
<div id="pu21" class="pu"><h1>PHP, 61</h1>
<p>Based on Newton's method. Slightly modified version of <a href="https://codegolf.stackexchange.com/a/21774/13847">Michael's answer</a>:</p>
<pre><code>for($i=$x=1;$i++&lt;99;)$x=(2*$x+$n/$x/$x)/3;echo round($x,14);
</code></pre>
<p>It works with negative numbers, can handle floating point numbers, and rounds the result to 4 numbers after the decimal point if the result is a floating point number.</p>
<p><a href="https://eval.in/104560" rel="nofollow noreferrer"><strong>Working demo</strong></a></p>
</div>
<div id="pu22" class="pu"><h2>Javascript - 157 characters</h2>

<p>This function:</p>

<ul>
<li>Handle negative numbers.</li>
<li>Handle floating-pointing numbers.</li>
<li>Execute quickly for any input number.</li>
<li>Has the maximum precision allowed for javascript floating-point numbers.</li>
</ul>

<pre class="lang-javascript prettyprint-override"><code>function f(a){if(p=q=a&lt;=1)return a&lt;0?-f(-a):a==0|a==1?a:1/f(1/a);for(v=u=1;v*v*v&lt;a;v*=2);while(u!=p|v!=q){p=u;q=v;k=(u+v)/2;if(k*k*k&gt;a)v=k;else u=k}return u}
</code></pre>

<p>Ungolfed explained version:</p>

<pre class="lang-javascript prettyprint-override"><code>function f(a) {
  if (p = q = a &lt;= 1) return a &lt; 0 ? -f(-a)      // if a &lt; 0, it is the negative of the positive cube root.
                           : a == 0 | a == 1 ? a // if a is 0 or 1, its cube root is too.
                           : 1 / f (1 / a);      // if a &lt; 1 (and a &gt; 0) invert the number and return the inverse of the result.

  // Now, we only need to handle positive numbers &gt; 1.

  // Start u and v with 1, and double v until it becomes a power of 2 greater than the given number.
  for (v = u = 1; v * v * v &lt; a; v *= 2);

  // Bisects the u-v interval iteratively while u or v are changing, which means that we still did not reached the precision limit.
  // Use p and q to keep track of the last values of u and v so we are able to detect the change.
  while (u != p | v != q) {
    p = u;
    q = v;
    k = (u + v) / 2;
    if (k * k * k &gt; a)
      v=k;
    else
      u=k
  }

  // At this point u &lt;= cbrt(a) and v &gt;= cbrt(a) and they are the closest that is possible to the true result that is possible using javascript-floating point precision.
  // If u == v then we have an exact cube root.
  // Return u because if u != v, u &lt; cbrt(a), i.e. it is rounded towards zero.
  return u
}
</code></pre>
</div>
<div id="pu23" class="pu"><h2>PHP - 81 bytes</h2>
<p>Iterative solution:</p>
<pre><code>$i=0;while(($y=abs($x=$argv[1]))-$i*$i*$i&gt;1e-4)$i+=1e-5;@print $y/$x*round($i,4);
</code></pre>
</div>
<div id="pu24" class="pu"><h1>Haskell - 35</h1>

<pre><code>c n=(iterate(\x-&gt;(x+n/x/x)/2)n)!!99
</code></pre>

<p>Example runs:</p>

<pre><code>c 27  =&gt;  3.0
c 64  =&gt;  4.0
c 1  =&gt;  1.0
c 18.609625  =&gt;  2.6500000000000004  # only first 4 digits are important, right?
c 3652264  =&gt;  154.0
c 0.001  =&gt;  0.1
c 7  =&gt;  1.9129311827723892
c (-27)  =&gt;  -3.0
c (-64)  =&gt;  -4.0
</code></pre>

<p>Moreover, if you import <code>Data.Complex</code>, it even works on complex numbers, it returns one of the roots of the number (there are 3):</p>

<pre><code>c (18:+26)  =&gt;  3.0 :+ 1.0
</code></pre>

<p>The <code>:+</code> operator should be read as 'plus <em>i</em> times'</p>
</div>
<div id="pu25" class="pu"><h2>Python - 62 bytes</h2>

<pre><code>x=v=input()
exec"x*=(2.*v+x*x*x)/(v+2*x*x*x or 1);"*99;print x
</code></pre>

<p>Evaluates to full floating point precision. The method used is <a href="http://en.wikipedia.org/wiki/Halley%27s_method" rel="nofollow">Halley's method</a>. As each iteration produces 3 times as many correct digits as the last, <em>99</em> iterations is a bit of overkill.</p>

<p>Input/output:</p>

<pre><code>27 -&gt; 3.0
64 -&gt; 4.0
1 -&gt; 1.0
18.609625 -&gt; 2.65
3652264 -&gt; 154.0
0.001 -&gt; 0.1
7 -&gt; 1.91293118277
0 -&gt; 1.57772181044e-30
-2 -&gt; -1.25992104989
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/21743/">21743</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




