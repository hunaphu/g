<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::44333</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>097</td><td>Uiua</td><td>241009T165913Z</td><td><a href="https://codegolf.stackexchange.com/questions/44333/are-these-dice-nontransitive/275996#275996">nyxbird</a></td></tr>
<tr d-ix="1"><td>214</td><td>Haskell</td><td>241008T215612Z</td><td><a href="https://codegolf.stackexchange.com/questions/44333/are-these-dice-nontransitive/275978#275978">colossus</a></td></tr>
<tr d-ix="2"><td>053</td><td>Vyxal</td><td>240919T084455Z</td><td><a href="https://codegolf.stackexchange.com/questions/44333/are-these-dice-nontransitive/275636#275636">emanresu</a></td></tr>
<tr d-ix="3"><td>427</td><td>Matlab</td><td>150108T194928Z</td><td><a href="https://codegolf.stackexchange.com/questions/44333/are-these-dice-nontransitive/44376#44376">flawr</a></td></tr>
<tr d-ix="4"><td>100</td><td>Dyalog APL</td><td>150113T024301Z</td><td><a href="https://codegolf.stackexchange.com/questions/44333/are-these-dice-nontransitive/44501#44501">ngn</a></td></tr>
<tr d-ix="5"><td>257</td><td>J</td><td>150110T222549Z</td><td><a href="https://codegolf.stackexchange.com/questions/44333/are-these-dice-nontransitive/44447#44447">Jay Bosa</a></td></tr>
<tr d-ix="6"><td>204</td><td>J</td><td>150112T191330Z</td><td><a href="https://codegolf.stackexchange.com/questions/44333/are-these-dice-nontransitive/44490#44490">ɐɔıʇǝɥʇu</a></td></tr>
<tr d-ix="7"><td>nan</td><td></td><td>150109T180024Z</td><td><a href="https://codegolf.stackexchange.com/questions/44333/are-these-dice-nontransitive/44416#44416">FryAmThe</a></td></tr>
<tr d-ix="8"><td>276</td><td>JavaScript</td><td>150108T143909Z</td><td><a href="https://codegolf.stackexchange.com/questions/44333/are-these-dice-nontransitive/44363#44363">Blackhol</a></td></tr>
<tr d-ix="9"><td>269</td><td>Python 2</td><td>150108T012428Z</td><td><a href="https://codegolf.stackexchange.com/questions/44333/are-these-dice-nontransitive/44337#44337">feersum</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://uiua.org" rel="nofollow noreferrer">Uiua</a>, 97 bytes</h1>
<pre><code>⨬&quot;none&quot;(⊂:&quot;nontransitive&quot;⨬(&quot;Grime-&quot;|&quot;&quot;|&quot;strongly &quot;)+1×)⊸⌵:∩(×=3⊃⌵±/+≡(±/+♭/⊞(±-))⊏⍉⊟⤙↻1⇡3)≡♭≡⊞+..
</code></pre>
<p><a href="https://www.uiua.org/pad?src=0_13_0-dev_3__ZiDihpAgKAogIOKJoeKZreKJoeKKnisuLiAgICAjIHRhYnVsYXRlIHRoZSB0d28tdGhyb3dzCiAg4oipKCAgICAgICAgICMgZm9yIGJvdGggdHdvLXRocm93cyBhbmQgb25lLXRocm93czoKICAgIOKKj-KNieKKn-KkmeKGuzHih6EzICMgZ2V0IHRoZSAwLTEsIDEtMiwgYW5kIDItMCBwYWlycwogICAg4omhKCAgICAgICAjICAgZm9yIGVhY2ggbWF0Y2h1cAogICAgICAv4oqeKMKxLSkgIyAgIGdldCBgMS8wLzEgKEwvVC9XKSBmb3IgZWFjaCBvdXRjb21lCiAgICAgIMKxLyvima0gICAjICAgYW5kIHN1bSB0aGVtCiAgICApICAgICAgICAjIAogICAgLysgICAgICAgIyBzdW0gdGhlbSBhbGwKICAgIMOXPTPiioPijLXCsSAgICMgYW5kIGdldCBgMS8wLzEgKENDVy9ub25lL0NXKQogICkgICAgICAgICAgIyAKICDiirjijLU6ICAgICAgICAjIGdldCBhYnMgb2Ygb25lLXRocm93cwogIOKorCJub25lIigKICAgICMgaWYgMCAobm8gY3ljbGUpOiAibm9uZSIsIG90aGVyd2lzZToKICAgICsxw5cgICAgICAgICAgICAgICAjIGdldCAwLzEvMiAoZGlmZi9ub25lL3NhbWUgc2lnbikKICAgIOKorCgiR3JpbWUtIiAgICAgICAgIyBkaWZmIHNpZ246ICJHcmltZS0iCiAgICB8ICIiICAgICAgICAgICAgICAjIG5vIGN5Y2xlOiAiIgogICAgfCAic3Ryb25nbHkgIiAgICAgIyBzYW1lIHNpZ246ICJzdHJvbmdseSAiCiAgICApICAgICAgICAgICAgICAgICAjIAogICAg4oqCOiJub250cmFuc2l0aXZlIiAjIGFwcGVuZCAibm9udHJhbnNpdGl2ZSIKICApCikKCiRub25lQCAKZlsxXzJfM180XzVfNiA2XzVfNF8zXzJfMSAxXzNfNV8yXzRfNl0KZlsxXzFfMV82XzZfNiA0XzRfNF81XzVfNSA1XzVfNV81XzVfNV0KZlsxXzFfMl81XzZfNiAyXzJfM180XzRfNiAyXzNfM180XzRfNV0KZlswXzFfMl8zXzRfNSAxXzFfMl8zXzNfNSAxXzJfMl8yXzNfNV0KZlszXzEzXzVfN18xM183IDVfN18xMV81XzdfMTMgNV85XzEzXzVfN185XQokbm9udHJhbnNAIApmWzFfMl8yXzRfNl82IDFfMl8zXzVfNV81IDJfM180XzRfNF80XQpmWzFfNF80XzRfNF80IDJfMl8yXzRfNV82IDJfM18zXzNfNV81XQpmWzFfMl8xXzZfNV82IDNfMV8zXzZfMl82IDJfNF8yXzRfNF81XQpmWzNfNF82XzZfN183IDRfNF80XzdfN183IDVfNV81XzVfNl83XQpmWzJfNV8xMV8xMV8xNF8xNCA1XzVfNV8xNF8xNF8xNCA4XzhfOF84XzhfMTddCiRncmltZUAgCmZbM18zXzNfM18zXzYgMl8yXzJfNV81XzUgMV80XzRfNF80XzRdCmZbMV8xXzRfNV81XzUgMl8yXzJfM182XzYgM18zXzNfNF80XzRdCmZbMl8xXzRfNl80XzQgMl80XzVfMl8zXzUgM18zXzZfM18zXzNdCmZbMTFfMTFfMTNfMTVfMTVfMTYgMTJfMTJfMTJfMTNfMTZfMTYgMTNfMTNfMTNfMTRfMTRfMTRdCmZbNF80XzdfMTZfMTlfMTkgNF83XzEzXzEzXzEzXzE5IDRfMTBfMTBfMTBfMTZfMTldCiRzdHJvbmdAIApmWzJfMl8yXzVfNV81IDJfM18zXzNfNV81IDFfMV80XzVfNV81XQpmWzJfMl8yXzNfNl82IDJfMl8yXzVfNV81IDJfMl80XzRfNF81XQpmWzFfNV8xXzNfNl81IDZfNl80XzJfMl8xIDVfM180XzNfNF8yXQpmWzBfMF8yXzRfNF81IDBfMV8xXzNfNV81IDFfMV8yXzNfNF80XQpmWzFfMV85XzE3XzE3XzIxIDFfNV81XzEzXzIxXzIxIDVfNV8xM18xM18xM18xN10K" rel="nofollow noreferrer">Try it!</a> (← commented explanation)</p>
<p>Takes input as a 3x6 array</p>
<p>Essentially, we generate the two-throws as their own (3x36) array, and get every possible win and loss for 0 against 1, 1 against 2, and 2 against 0 as -1/0/1. If you take the sign of the sum, you end up with a 3-element list with the signs for wins and losses (ie. <code>[1 `1 1]</code>). If the absolute value of the sum isn't three, there's no cycle, and if there is, the sign of the sum tells you which direction it's in. So, we can use <code>×=3⊃⌵±</code> to turn the list into -1 for a counterclockwise cycle, 1 for a clockwise cycle, or 0 for no cycle. After that you can switch twice (once to see if the one-throws make a cycle, and once to see if and how the two-throws make a cycle.)</p>
<p>I think this is golfable? The <code>:</code>s and <code>.</code>s seem like they might be replaceable somehow.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, 214 bytes</h1>

<pre class="lang-hs prettyprint-override"><code>a#b=sum[signum$p-q|p&lt;-a,q&lt;-b]&gt;0
(a!b)c=a#b&amp;&amp;b#c&amp;&amp;c#a
n=&quot;nontransitive&quot;
d a=[i+j|i&lt;-a,j&lt;-a]
h(w,x,y,z)|w&amp;&amp;y||x&amp;&amp;z=&quot;strongly &quot;++n|w&amp;&amp;z||x&amp;&amp;y=&quot;Grime-&quot;++n|w||x=n|1&gt;0=&quot;none&quot;
(a?b)c=h(a!b$c,c!b$a,d a!d b$d c,d c!d b$d a)
</code></pre>
<p><a href="https://tio.run/##fVTLbuMgFF2Pv4I6lpUoRDLgx0Sqm@VsZjdLywviRI07iZPmMW0i/3sGuGAT260ECA5wuJxzYcNPf9fb7f3OR8v0dNllp/K1uuy8w@y9PjzPOH5/ni3zl8AZ86flpEjFMt9fjgrfL0bcqVK32lfnI69O5bn8t3adFeJpVk7f6lJufhNN7mzGH/gTX/FtUn/4/rWuP33/lrqn83FfvW6vyJ1OKzlzUzPX1P11LHfrGcACS6uavATqKHHCmC9kIBsZkFfgQrQci2OfVmjprVAh@oXu88l9x8sqXe2dH4fL@c/5@LtCHsoIRhQjhlGIUYRRnC@yWPVChYo5kntyFVMoVRNx3iOBEkMRJKFaCKSyCJKoGWhoiIRCGEBCreDUsV4G4wbqkgSGRN9IkBALYhAJjBv2LomACFw3gV4iaPSItDhcaW4vnttMrjsktVYQLtgE1qpkX1iWvkrhw7RRibYWWiqxr6Smxi9tOlNjpiDakISGNxxUKTSOJ6BRE1aioUfT5cIOCdgtVVU1lBXEhgKIQr3sJ0Z2Icl3ajNLAmanE7XV7sk5lJNWFlskTLvotUcNk1BDEtuWheY96ZxkhlGzdSMxEkmjIl1VCkl6U@VkrCbE1XQaq9rK@Ejb2KW2yVyeg4@JtZkp2JMwCayqtnznQU/wRT8zvb7IX5Cwzr9AO8@GWkYOZHxkZXgE31xsMlx/c5FxEVra/1yChwex0P8N6V@nfcaDKSWVTqBSAh@BTnj56RKFmsfz4EOS3/8D" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
<p>The <code>a#b</code> operator returns <code>True</code> if <code>a</code> beats <code>b</code>. Step one is double iterating over both lists, subtracting their results, running those through <code>signum</code>. That gives us a 1, 0, or -1 for each possible result of rolling A and B where 1 represents A winning, -1 is B winning, and 0 is a tie. If the sum of all these results is positive that means A wins more than it loses.</p>
<p>The <code>(a!b)c</code> operator returns <code>True</code> if A beats B, B beats C, and C beats A.</p>
<p>The <code>d</code> function doubles up a die by double iterating over it and adding the results. Basically creates a 36 sided die with every possible result of two rolls.</p>
<p>In the <code>h</code> function <code>w</code> will be true if the die cycle forward, <code>x</code> will be true if the dice cycle backward, and <code>y</code> and <code>z</code> are the same but for the doubled dice. We then check for the double cases first, then checking for a simple nontransitive relationship, and finally return &quot;none&quot; if all else fails.</p>
<p>Finally we have <code>(a?b)c</code> which takes our three dice and passes h the required flags.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal/tree/version-2" rel="nofollow noreferrer">Vyxal</a>, 53 bytes</h1>
<pre><code>ƛẊṠ;&quot;ƛǔ¨£ǒ-±ṠṠ±₌≈h*;3βȧ`Gr⋏≬-

ġƈ `↵`⟑¢›≤ive`+‛»≤pǏǔi
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/?v=2&amp;c=1#WyJBIiwiIiwixpvhuorhuaA7XCLGm8eUwqjCo8eSLcKx4bmg4bmgwrHigoziiYhoKjszzrLIp2BHcuKLj+KJrC1cblxuxKHGiCBg4oa1YOKfkcKi4oC64omkaXZlYCvigJvCu+KJpHDHj8eUaSIsIiIsIltbMywgMywgMywgMywgMywgNl0sIFsyLCAyLCAyLCA1LCA1LCA1XSwgWzEsIDQsIDQsIDQsIDQsIDRdXVxuW1sxLCAyLCAzLCA0LCA1LCA2XSwgWzYsIDUsIDQsIDMsIDIsIDFdLCBbMSwgMywgNSwgMiwgNCwgNl1dXG5bWzEsIDIsIDIsIDQsIDYsIDZdLCBbMSwgMiwgMywgNSwgNSwgNV0sIFsyLCAzLCA0LCA0LCA0LCA0XV1cbltbMiwgMiwgMiwgNSwgNSwgNV0sIFsyLCAzLCAzLCAzLCA1LCA1XSwgWzEsIDEsIDQsIDUsIDUsIDVdXSJd" rel="nofollow noreferrer">Try it Online!</a></p>
<p>A bit of a mess, but I'm pretty happy with it.</p>
<p>The main &quot;trick&quot; this answer uses is the following: By checking whether each dice beats the next, we get an array of signs -1/0/1, which will be <code>[-1, -1, -1]</code> if we have a decreasing cycle and <code>[1, 1, 1]</code> if we have an increasing cycle. This can then be turned into <code>-1/1</code> for cycles and <code>0</code> otherwise by multiplying the first item by whether all items are the same. Since I'm performing this check for both the dice and their doubled rolls, this results in a pair of signs with the following possibilities:</p>
<ul>
<li><code>[0, 0]</code>, <code>[0, -1]</code> or <code>[0, 1]</code> if <code>none</code> i.e. there is no first cycle, and we don't care about the second.</li>
<li><code>[1, -1]</code> or <code>[-1, 1]</code> if <code>Grime-nontransitive</code> - there are two cycles and they're opposite.</li>
<li><code>[1, 0]</code> or <code>[-1, 0]</code> if <code>nontransitive</code> - there is no second cycle.</li>
<li><code>[1, 1]</code> or <code>[-1, -1]</code> if <code>strongly nontransitive</code> - there are two identical cycles.</li>
</ul>
<p>The clever part is converting these into base 3 and taking the absolute value. Then, <code>none</code> maps to <code>0</code> or <code>1</code>, <code>Grime-nontransitive</code> maps to <code>2</code>, <code>nontransitive</code> maps to <code>3</code> and <code>strongly nontransitive</code> maps to <code>4</code>. From here it's easy to index into a list.</p>
<pre><code>ƛ  ;                                      # Over each dice
 ẊṠ                                       # Sum all pairs from it, giving the distribution of two rolls of each
    &quot;                                     # Pair these with the original dice
     ƛ               ;                    # Over both the original and doubled dice,
                                          # Calculate the winner of each pair:
      ǔ¨£                                 # Over each pair of dice
         ǒ-±                              # Compare all pairs of values from each
            ṠṠ±                           # Sum and take the sign
                                          # This results in [1, 1, 1] if increasing cycle, [-1, -1, -1] if decreasing cycle
                  *                       # Multiply
                 h                        # The first item
               ₌≈                         # By whether they're all equal
                                          # Giving 1/-1 for cycles, 0 otherwise
                                          # Now we have [0, x] if none, [1,-1] / [-1,1] if Grime,
                                          # [1,1]/[-1,-1] if strong and [1,0]/[-1,0] otherwise 
                   3βȧ                    # Convert to base 3 and take the absolute value, giving
                                          # 0/1-&gt;none, 2-&gt;grime, 3-&gt;nontransitive, 4-&gt;strong
                                    i   i # Index into
                      `...`↵              # [&quot;Grime-&quot;,&quot;&quot;,&quot;strongly &quot;]
                            `...`+        # + &quot;nontransitive&quot;
                                  ‛»≤p    # With &quot;none&quot; prepended
                                      Ǐǔ  # twice
</code></pre>
</div>
<div id="pu3" class="pu"><h1>Matlab (427)</h1>

<p>It is not that short and I am sure it can be golfed a lot more, I just tried to solve this challenge because I thought it was a very fun task, so thanks <strong>@MartinBüttner</strong> for creating this challenge!</p>

<pre class="lang-matlab prettyprint-override"><code>a=input();b=input();c=input();
m = 'non';l=@(a)ones(numel(a),1)*a;n=@(a,b)sum(sum(l(a)&gt;l(b)'));g=@(a,b)n(a,b)&gt;n(b,a);s=@(a,b,c)sum([g(a,b),g(b,c),g(c,a)]);
x=s(a,b,c);y=s(a,c,b);if x~=3 &amp;&amp; y~=3;m=[m,'e'];else m=[m,'transitive'];o=ones(6,1);a=o*a;a=a+a';a=a(:)';b=o*b;b=b+b';b=b(:)';c=o*c;c=c+c';c=c(:)';u=s(a,b,c);
v=s(a,c,b);if u==3|| v==3;if x==3&amp;&amp;u==3 || y==3&amp;&amp;v==3 m=['strongly ',m];else m=['Grime-',m];end;end;end;disp(m);
</code></pre>

<p>Here the full length code with some comments if you want to try to understand what's going on. I included some test cases hare and excluced the input commands:</p>

<pre><code>%nontransitive
% a = [1 2 2 4 6 6];
% b = [1 2 3 5 5 5];
% c = [2 3 4 4 4 4];

%none
% a = [1 2 3 4 5 6];
% b = [6 5 4 3 2 1];
% c = [1 3 5 2 4 6];

%grime nontransitive
% a = [3 3 3 3 3 6];
% b = [2 2 2 5 5 5];
% c = [1 4 4 4 4 4];

%strongly nontransitive
% a = [2 2 2 5 5 5];
% b = [2 3 3 3 5 5];
% c = [1 1 4 5 5 5];

m = 'non';

l=@(a)ones(numel(a),1)*a;
n=@(a,b)sum(sum(l(a)&gt;l(b)'));
%input as row vector, tests whether the left one beats the right one:
g=@(a,b)n(a,b)&gt;n(b,a);
s=@(a,b,c)sum([g(a,b),g(b,c),g(c,a)]);
%if one of those x,y has the value 3, we'll have intransitivity
x=s(a,b,c); 
y=s(a,c,b);
if x~=3 &amp;&amp; y~=3 %nontransitive
    m=[m,'e'];
else %transitive
    m=[m,'transitive'];
    o=ones(6,1);
    a=o*a;a=a+a';a=a(:)'; %all possible sums of two elements of a
    b=o*b;b=b+b';b=b(:)';
    c=o*c;c=c+c';c=c(:)';
    u=s(a,b,c);
    v=s(a,c,b);

    %again: is u or v equal to 3 then we have transitivity
    if u==3 || v==3 %grime OR strongly
        % if e.g. x==3 and u==3 then the 'intransitivity' is in the same
        % 'order', that means stronlgy transitive
        if x==3 &amp;&amp; u==3 || y==3 &amp;&amp; v==3%strongly
            m=['strongly ',m];
        else %grime
            m=['Grime-',m];
        end   
    end
end

disp(m);
</code></pre>
</div>
<div id="pu4" class="pu"><h1>Dyalog APL, <s>107</s> 100 bytes</h1>
<p><s><a href="http://tryapl.org/?a=%7B%28%7B+/%D7+/%A8%2C%A8%D7%u2375%u2218.-%A81%u233D%u2375%7D%7B3%u2260%7Ca%u2190%u237A%u237A%u2375%3A1%u22C4a%3Db%u2190%u237A%u237A%u2218.+%u2368%A8%u2375%3A2%u22C43+a%3D-b%7D%u2375%29%u2283%28%u2282%27none%27%29%2C%27strongly%20%27%u236C%27Grime-%27%2C%A8%u2282%27nontransitive%27%7D%20%A8%20%28%281%202%203%204%205%206%29%286%205%204%203%202%201%29%281%203%205%202%204%206%29%29%20%28%281%201%201%206%206%206%29%284%204%204%205%205%205%29%285%205%205%205%205%205%29%29%20%28%281%201%202%205%206%206%29%282%202%203%204%204%206%29%282%203%203%204%204%205%29%29%20%28%280%201%202%203%204%205%29%281%201%202%203%203%205%29%281%202%202%202%203%205%29%29%20%28%283%2013%205%207%2013%207%29%285%207%2011%205%207%2013%29%285%209%2013%205%207%209%29%29%20%28%281%202%202%204%206%206%29%281%202%203%205%205%205%29%282%203%204%204%204%204%29%29%20%28%281%204%204%204%204%204%29%282%202%202%204%205%206%29%282%203%203%203%205%205%29%29%20%28%281%202%201%206%205%206%29%283%201%203%206%202%206%29%282%204%202%204%204%205%29%29%20%28%283%204%206%206%207%207%29%284%204%204%207%207%207%29%285%205%205%205%206%207%29%29%20%28%282%205%2011%2011%2014%2014%29%285%205%205%2014%2014%2014%29%288%208%208%208%208%2017%29%29%20%28%283%203%203%203%203%206%29%282%202%202%205%205%205%29%281%204%204%204%204%204%29%29%20%28%281%201%204%205%205%205%29%282%202%202%203%206%206%29%283%203%203%204%204%204%29%29%20%28%282%201%204%206%204%204%29%282%204%205%202%203%205%29%283%203%206%203%203%203%29%29%20%28%2811%2011%2013%2015%2015%2016%29%2812%2012%2012%2013%2016%2016%29%2813%2013%2013%2014%2014%2014%29%29%20%28%284%204%207%2016%2019%2019%29%284%207%2013%2013%2013%2019%29%284%2010%2010%2010%2016%2019%29%29%20%28%282%202%202%205%205%205%29%282%203%203%203%205%205%29%281%201%204%205%205%205%29%29%20%28%282%202%202%203%206%206%29%282%202%202%205%205%205%29%282%202%204%204%204%205%29%29%20%28%281%205%201%203%206%205%29%286%206%204%202%202%201%29%285%203%204%203%204%202%29%29%20%28%280%200%202%204%204%205%29%280%201%201%203%205%205%29%281%201%202%203%204%204%29%29%20%28%281%201%209%2017%2017%2021%29%281%205%205%2013%2021%2021%29%285%205%2013%2013%2013%2017%29%29&amp;run" rel="nofollow noreferrer"><code>{({+/×+/¨,¨×⍵∘.-¨1⌽⍵}{3≠|a←⍺⍺⍵:1⋄a=b←⍺⍺∘.+⍨¨⍵:2⋄3+a=-b}⍵)⊃(⊂'none'),'strongly '⍬'Grime-',¨⊂'nontransitive'}</code></a></s></p>
<p><a href="http://tryapl.org/?a=%7BT%u2190%7B+/%D7+/%A8%u220A%A8%D7%u2375%u2218.-%A81%u233D%u2375%7D%u22C43%u2260%7CS%u2190T%u2375%3A%27none%27%u22C4N%u2190%27nontransitive%27%u22C4S%3DD%u2190T%u2218.+%u2368%A8%u2375%3A%27strongly%20%27%2CN%u22C4S%3D-D%3A%27Grime-%27%2CN%u22C4N%7D%20%A8%20%28%281%202%203%204%205%206%29%286%205%204%203%202%201%29%281%203%205%202%204%206%29%29%20%28%281%201%201%206%206%206%29%284%204%204%205%205%205%29%285%205%205%205%205%205%29%29%20%28%281%201%202%205%206%206%29%282%202%203%204%204%206%29%282%203%203%204%204%205%29%29%20%28%280%201%202%203%204%205%29%281%201%202%203%203%205%29%281%202%202%202%203%205%29%29%20%28%283%2013%205%207%2013%207%29%285%207%2011%205%207%2013%29%285%209%2013%205%207%209%29%29%20%28%281%202%202%204%206%206%29%281%202%203%205%205%205%29%282%203%204%204%204%204%29%29%20%28%281%204%204%204%204%204%29%282%202%202%204%205%206%29%282%203%203%203%205%205%29%29%20%28%281%202%201%206%205%206%29%283%201%203%206%202%206%29%282%204%202%204%204%205%29%29%20%28%283%204%206%206%207%207%29%284%204%204%207%207%207%29%285%205%205%205%206%207%29%29%20%28%282%205%2011%2011%2014%2014%29%285%205%205%2014%2014%2014%29%288%208%208%208%208%2017%29%29%20%28%283%203%203%203%203%206%29%282%202%202%205%205%205%29%281%204%204%204%204%204%29%29%20%28%281%201%204%205%205%205%29%282%202%202%203%206%206%29%283%203%203%204%204%204%29%29%20%28%282%201%204%206%204%204%29%282%204%205%202%203%205%29%283%203%206%203%203%203%29%29%20%28%2811%2011%2013%2015%2015%2016%29%2812%2012%2012%2013%2016%2016%29%2813%2013%2013%2014%2014%2014%29%29%20%28%284%204%207%2016%2019%2019%29%284%207%2013%2013%2013%2019%29%284%2010%2010%2010%2016%2019%29%29%20%28%282%202%202%205%205%205%29%282%203%203%203%205%205%29%281%201%204%205%205%205%29%29%20%28%282%202%202%203%206%206%29%282%202%202%205%205%205%29%282%202%204%204%204%205%29%29%20%28%281%205%201%203%206%205%29%286%206%204%202%202%201%29%285%203%204%203%204%202%29%29%20%28%280%200%202%204%204%205%29%280%201%201%203%205%205%29%281%201%202%203%204%204%29%29%20%28%281%201%209%2017%2017%2021%29%281%205%205%2013%2021%2021%29%285%205%2013%2013%2013%2017%29%29&amp;run" rel="nofollow noreferrer"><code>{T←{+/×+/¨∊¨×⍵∘.-¨1⌽⍵}⋄3≠|S←T⍵:'none'⋄N←'nontransitive'⋄S=D←T∘.+⍨¨⍵:'strongly ',N⋄S=-D:'Grime-',N⋄N}</code></a></p>
<p>(Thanks @Tobia for this simpler, shorter, better solution)</p>
<p>Basics:</p>
<ul>
<li><p><code>←</code> assignment</p>
</li>
<li><p><code>⋄</code> statement separator</p>
</li>
<li><p><code>{}</code> lambda form</p>
</li>
<li><p><code>⍺⍵</code> left and right argument</p>
</li>
<li><p><code>A:B</code> guard (&quot;if <code>A</code> then return <code>B</code>&quot;)</p>
</li>
</ul>
<p><code>T</code> is a function that returns 3 if A beats B, B beats C, and C beats A; -3 if the exact opposite is the case; and something inbetween otherwise.  In detail:</p>
<ul>
<li><p><code>1⌽⍵</code> is the one-rotation of <code>⍵</code>.  If <code>⍵</code> is ABC, the rotation is BCA.</p>
</li>
<li><p><code>∘.-</code> computes a subtraction table between two vectors (<code>1 2...10 ∘.× 1 2...10</code> would be the multiplication table we know from school).  We apply this between each (<code>¨</code>) item of <code>⍵</code> and its corresponding item in <code>1⌽⍵</code>.</p>
</li>
<li><p><code>×</code> signum of all numbers in the subtraction tables</p>
</li>
<li><p><code>∊¨</code> flatten each table</p>
</li>
<li><p><code>+/¨</code> and sum it.  We now have three numbers that represent balances: number of winning minus losing cases for each of A vs B, B vs C, C vs A.</p>
</li>
<li><p><code>×</code> signum of those</p>
</li>
<li><p><code>+/</code> sum</p>
</li>
</ul>
<p>Then handle the cases in turn:</p>
<ul>
<li><p><code>3≠|S←T⍵:'none'</code> if <code>T⍵</code>'s absolute value isn't 3, return 'none'</p>
</li>
<li><p><code>N←'nontransitive'</code> we'll need this word a lot</p>
</li>
<li><p><code>S=D←T∘.+⍨¨⍵:'strongly ',N</code> compute <code>T</code> for pairs of dice (<code>∘.+⍨¨⍵</code> ←→ <code>⍵((∘.+)¨)⍵</code>) and return &quot;strongly...&quot; if the same relationships among ABC still hold</p>
</li>
<li><p><code>S=-D:'Grime-',N</code> ⍝ &quot;Grime&quot; if the relationships are in the opposite directions</p>
</li>
<li><p><code>N</code> if all else fails, just &quot;nontransitive&quot;</p>
</li>
</ul>
</div>
<div id="pu5" class="pu"><h1>J - <strike>311</strike> 257 bytes</h1>

<p>Update (13 Jan 2015):</p>

<pre><code>g=:4 :'(+/,x&gt;/y)&gt;+/,y&gt;/x'
h=:4 :'(,+/~x)g,+/~y'
f=: 3 :0
'a b c'=:y
if. (b g a)*(c g b)*a g c do.
a=.2{y
c=.0{y
end.
'none'([`]@.((a g b)*(b g c)*c g a))((''([`]@.((b h a)*(c h b)*a h c))'Grime-')([`]@.((a h b)*(b h c)*c h a))'strongly '),'nontransitive'
)
</code></pre>

<p>Explanation: Using Gerunds, simplify the <code>if.</code>s to <code>@.</code>s.</p>

<h2>Older version:</h2>

<p>First try at both coding in J as well as golfing.</p>

<pre><code>g=:4 :'(+/,x&gt;/y)&gt;+/,y&gt;/x'
h=:4 :'(,+/~x)g,+/~y'
f=: 3 :0
'a b c'=:y
if. (b g a)*(c g b)*a g c do.
a=.2{y
c=.0{y
end.
if. (a g b)*(b g c)*c g a do.
if. (a h b)*(b h c)*c h a do.
'strongly nontransitive'
elseif. (b h a)*(c h b)*a h c do.
'Grime-nontransitive'
elseif. do.
'nontransitive'
end.
else.
'none'
end.
)
</code></pre>

<p>Run it using a syntax similar to following (extra spaces for clarity):</p>

<pre><code>f 3 6 $          1 1 9 17 17 21, 1 5 5 13 21 21, 5 5 13 13 13 17
</code></pre>

<p>Explanation:</p>

<p><code>g</code> is defined as a diad taking two arrays that tells if first dice beats second dice<br>
<code>h</code> is defined as a diad taking two arrays that tells if throwing twice and summing, does first dice beat second<br>
<code>f</code> is a monad that takes a table and returns a string with the right answer</p>

<p>Edit: Fix a mistake in Grime-nontransitive condition (replacing <code>,</code> with <code>*</code>)</p>
</div>
<div id="pu6" class="pu"><h1>J (204)</h1>

<p>Way too long, could probably be golfed a lot by having a more efficient system for picking the right string.</p>

<pre><code>f=:3 :'(&lt;,&gt;)/"1+/"2&gt;"1,"2(&lt;,&gt;)/L:0{(,.(1&amp;|.))y'
n=:'nontransitive'
d=:3 :0
if.+/*/a=.f y do.+/*/b=.f&lt;"1&gt;,"2+/L:0{,.~y if.a-:b do.'strongly ',n elseif.a-:-.b do.'Grime-',n elseif.do.n end.else.'none'end.
)
</code></pre>
</div>
<div id="pu7" class="pu"><h2><a href="https://github.com/isaacg1/pyth" rel="nofollow">Pyth</a> 129 <s>133</s></h2>

<pre><code>Lmsd^b2Msmsm&gt;bkGHDPNK-ghNeNgeNhNR?^tZ&lt;KZKZAGHmsdCm,PkP,yhkyekm,@Qb@QhbUQ?"none"|!G%G3s[*!+GH"Grime-"*qGH"strongly ""nontransitive
</code></pre>

<p><a href="https://pyth.herokuapp.com/" rel="nofollow">Try it here</a>, or at least you could, but the online <code>eval</code> doesn't seem to like lists of lists :( If you want to try it there, manually store a list of 3 dice into a variable not used by the program and then replace all instances of <code>Q</code> with that variable. A sample initialization:</p>

<pre><code>J[[3 3 3 3 3 6)[2 2 2 5 5 5)[1 4 4 4 4 4))
</code></pre>

<p>This passes all of Martin's test cases, I haven't the heart go through all of Peter's cases :P</p>

<p>Explanation (this is gonna be a doozy)</p>

<pre><code>Lmsd^b2
</code></pre>

<p>Pretty simple, makes a function <code>y</code> that returns the sum of each Cartesian pair of values in an iterable. Equivalent to: <code>def y(b):return map(lambda d:sum(d),product(b,repeats=2))</code>. This is used to create many-sided dies that simulate throwing the regular dies twice.</p>

<pre><code>Msmsm&gt;bkGH
</code></pre>

<p>Defines a function <code>g</code> of 2 arguments that returns how many times a die beats another. Equivalent to <code>def g(G,H):return sum(map(lambda k:sum(map(lambda b:b&gt;k,G)),H)</code>.</p>

<pre><code>DPNK-ghNeNgeNhNR?^tZ&lt;KZKZ
</code></pre>

<p>Defines a funtion <code>P</code> that takes a list of two dice as its argument. This returns -1 if the first die 'loses', 0 for a tie and 1 if the first die 'wins'. Equivalent to:</p>

<pre><code>def P(N):
 K=g(N[0],N[-1]) - g(N[-1],N[0])
 return -1**(K&lt;0) if K else 0
</code></pre>

<p>The <code>AGH</code> assigns acts like a python 2-tuple assignment. Essentially <code>G,H=(result)</code></p>

<pre><code>msdCm,PkP,yhkyekm,@Qb@QhbUQ
</code></pre>

<p>Going to explain backwards through the maps. <code>m,@Qb@QhbUQ</code> iterates over b=0..2 and generates 2-tuples of dice with index b and index b+1. This gives us dice (A,B),(B,C),(C,A) (pyth automatically mods indexes by the length of the list).</p>

<p>Next, <code>m,PkP,yhkyek</code> iterates over the result of the previous map, with each dice pair being stored in k over each run. Returns <code>tuple(P(k),P(tuple(y(k[0]),y(k[-1]))))</code> for each value. That boils down to `((A beats B?, 2*A beats 2*B), (B beats C?, 2*B beats..)).</p>

<p>Finally, <code>msdC</code> sums the values of the previous map after it has been zipped. The zip causes all of the single dice 'beats' values in the first tuple, and the double dice values in the second.</p>

<pre><code>?"none"|!G%G3s[*!+GH"Grime-"*qGH"strongly ""nontransitive
</code></pre>

<p>A gross thing that prints out the results. If G is 0 or not divisible by 3, this catches bot +/- 3, (<code>|!G%G3</code>), prints <code>none</code>, otherwise prints the sum of the follwing list: <code>[not(G+H)*"Grime",(G==H)*"strongly ","nontransitive"]</code>. I think the booleans are fairly self-explanatory with regard to the definitions in the question. Do note that G cannot be zero here, as that is caught by the previous check.</p>
</div>
<div id="pu8" class="pu"><h2>JavaScript - 276 bytes</h2>



<pre class="lang-javascript prettyprint-override"><code>function(l){r=function(i){return l[i][Math.random()*6|0]};p=q=0;for(i=0;j=(i+1)%3,i&lt;3;++i)for(k=0;k&lt;1e5;++k){p+=(r(i)&gt;r(j))-(r(i)&lt;r(j));q+=(r(i)+r(i)&gt;r(j)+r(j))-(r(i)+r(i)&lt;r(j)+r(j))}alert((a=Math.abs)(p)&gt;5e3?((a(q)&gt;5e3?p*q&gt;0?'strongly ':'Grime-':'')+'nontransitive'):'none')}
</code></pre>

<p>I'm not really good in probability, so to be sure of my results, I prefer to just throw the dice hundreds of thousands times.</p>

<p>The expression evaluates to a function, that should be called with only one argument: an array of three arrays of integers. <a href="http://jsfiddle.net/Blackhole/gg90hxxv/" rel="nofollow">Check the Fiddle</a> to be able to run the code by yourself.</p>

<p>Here is the ungolfed version:</p>

<pre class="lang-javascript prettyprint-override"><code>function (diceList) {
    var getRandomValue = function (idDie) {
        return diceList[idDie][Math.floor(Math.random() * 6)];
    };

    var probabilitySimpleThrow = 0;
    var probabilityDoubleThrow = 0;

    for (var idDieA = 0; idDieA &lt; 3; ++idDieA)
    {
        var idDieB = (idDieA + 1) % 3;
        for (var idThrow = 0; idThrow &lt; 1e5; ++idThrow)
        {
            probabilitySimpleThrow += getRandomValue(idDieA) &gt; getRandomValue(idDieB);
            probabilitySimpleThrow -= getRandomValue(idDieA) &lt; getRandomValue(idDieB);

            probabilityDoubleThrow += getRandomValue(idDieA) + getRandomValue(idDieA) &gt; getRandomValue(idDieB) + getRandomValue(idDieB);
            probabilityDoubleThrow -= getRandomValue(idDieA) + getRandomValue(idDieA) &lt; getRandomValue(idDieB) + getRandomValue(idDieB);
        }
    }

    if (Math.abs(probabilitySimpleThrow) &gt; 5e3) {
        if (Math.abs(probabilityDoubleThrow) &gt; 5e3) {
            if (probabilitySimpleThrow * probabilityDoubleThrow &gt; 0) {
                var result = 'strongly ';
            }
            else {
                var result = 'Grime-';
            }
        }
        else {
            var result = '';
        }

        result += 'nontransitive';
    }
    else {
        var result = 'none';
    }

    alert(result);
}
</code></pre>
</div>
<div id="pu9" class="pu"><h1>Python 2, 269</h1>

<p>Here's a nice little expression that evaluates to a function. It accepts three lists of integers. Passes all test cases.</p>

<pre class="lang-python prettyprint-override"><code>lambda A,B,C,w=lambda A,B:cmp(sum(cmp(a,b)for a in A for b in B),0),x=lambda A,B:cmp(sum(cmp(a+c,b+d)for a in A for b in B for c in A for d in B),0): (w(A,B)==w(B,C)==w(C,A)!=0)*((x(A,B)==x(B,C)==x(C,A))*["","strongly ","Grime-"][x(A,B)*w(A,B)]+"nontransitive")or"none"
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/44333/">44333</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




