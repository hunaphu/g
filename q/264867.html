<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::QNNN</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
  <!-- TXXX -->
<tr d-ix="0"><td>193</td><td>TypeScript's Type System</td><td>230906T000322Z</td><td><a href="https://codegolf.stackexchange.com/questions/264867/add-two-really-big-numbers/264953#264953">noodle m</a></td></tr>
<tr d-ix="1"><td>042</td><td>ISO C23 clang 16</td><td>230911T101341Z</td><td><a href="https://codegolf.stackexchange.com/questions/264867/add-two-really-big-numbers/265112#265112">Peter Co</a></td></tr>
<tr d-ix="2"><td>058</td><td>C clang</td><td>230904T090522Z</td><td><a href="https://codegolf.stackexchange.com/questions/264867/add-two-really-big-numbers/264884#264884">Noodle9</a></td></tr>
<tr d-ix="3"><td>054</td><td>C</td><td>230909T075136Z</td><td><a href="https://codegolf.stackexchange.com/questions/264867/add-two-really-big-numbers/265051#265051">Peter Co</a></td></tr>
<tr d-ix="4"><td>008</td><td>x8664 machine code</td><td>230906T031745Z</td><td><a href="https://codegolf.stackexchange.com/questions/264867/add-two-really-big-numbers/264960#264960">Peter Co</a></td></tr>
<tr d-ix="5"><td>nan</td><td></td><td>230903T234251Z</td><td><a href="https://codegolf.stackexchange.com/questions/264867/add-two-really-big-numbers/264868#264868">lyxal</a></td></tr>
<tr d-ix="6"><td>043</td><td>Factor</td><td>230904T135432Z</td><td><a href="https://codegolf.stackexchange.com/questions/264867/add-two-really-big-numbers/264890#264890">chunes</a></td></tr>
<tr d-ix="7"><td>030</td><td>R</td><td>230907T095801Z</td><td><a href="https://codegolf.stackexchange.com/questions/264867/add-two-really-big-numbers/265008#265008">Dominic </a></td></tr>
<tr d-ix="8"><td>119</td><td>Lua</td><td>230904T003926Z</td><td><a href="https://codegolf.stackexchange.com/questions/264867/add-two-really-big-numbers/264871#264871">ATaco</a></td></tr>
<tr d-ix="9"><td>063</td><td>JavaScript Node.js</td><td>230905T093036Z</td><td><a href="https://codegolf.stackexchange.com/questions/264867/add-two-really-big-numbers/264925#264925">l4m2</a></td></tr>
<tr d-ix="10"><td>049</td><td>Ruby</td><td>230904T115457Z</td><td><a href="https://codegolf.stackexchange.com/questions/264867/add-two-really-big-numbers/264887#264887">noodle m</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.typescriptlang.org/" rel="nofollow noreferrer">TypeScript</a>'s Type System, <s>211</s> 193 bytes</h1>
<pre class="lang-typescript prettyprint-override"><code>//@ts-ignore
type F&lt;A,C=[]&gt;=A extends[[...infer G,infer X],[...infer H,infer Y]]?[...X,...Y,...C]extends[1,1,1,1,1,1,1,1,1,1,...infer R]?[...F&lt;[G,H],[1]&gt;,R]:[...F&lt;[G,H],[]&gt;,[...X,...Y,...C]]:[]
</code></pre>
<p><a href="https://www.typescriptlang.org/play?#code/PTAEEEBNNAXB3A9qATgUwIYBssE9QBGAlgOagB2ArgLYFooDOoAtKAIwCcAzIbrGgwBQgkAAFYDZqXKJ0g2LgAOaUADEAPOAA0AYQC8AbQC6APj3hQaAB79ykBgYMA6F0XIAzeqADiWt55RQAA0jLWdXDy8ACT9IwIBNIyMAfnCnIK0XJ3jMlx0ja1t7AzYtUvKyyoqKrP8vACUUtI0DXyjQktMtRoAuZvVWrXawrrSMrJys-KM+o2EQUHdERH4UYQVlUABVcgwUXHUAOUsbNDsmKlp6LVAAFROipjZjUD1QYxNXu4MAIiwzkiwAAWPyMDzO9lAh0EoFAyTuMNAPW2u32RxuaVuNzYpgA3PIlCoAMqwFC3RA7Pa4AAipCIEnURPB51ADFJbhInzeTMKEKYAAMACQAbzqgVpJHpzPsiMudBQAF8RWLQPUBLAFfzEfCDJS0RL6SYblkSWSKaiaXSGWq2SY5rDkcZ8RsVABZDCKPW4cnUtAAYyI1GwR2lT2MHy+x15LIMKtUREYsFD7GMxoiAVV6uTzyMxntcPe8cTv3+5EBINCoCy7s9Fp9-sDwZtsDtiMdRmdhNABok5NNHM0ybl9Ajbws0chBkRKupQ5o8q0iNqcVVc6uKFTgnz8KFwupSr3VoYffZZfU9RMmrboB+P07m1u6sHE6YbJQHJuACFk2+OVzu0eJ7vmeiI1l69YBkGWDqC0prkl6PYMJoRqgHB5pUoh6ifnaJgmIIJj4gSD7qmwXyPmy6g-GwbAAGwABw-DcPwAAzUQATD8BEiGAsIAHrJERKjkbAbFkU+PxsVwbCsVwsmMTerF0QArHRHAACwMVxCx8QJLp3OqPBvMJlFsWpbHqaZSlqcxalqfJVE0QA7FwHDqWwbF0WpXCcdxsKgPxgn6WyaliRRLHcBwdGmTRGnqVJdHKfZzHcMxyWOWpHA0RwaVeY5Pnaf5uldsJSmhbAlHMXRXBKZVbFKTRbGpS5rlRclHFMcx6VsF53W0apZlqTVjlsI5HD5TxhWBcJNFlZRI1STRzUudRXB1c5lU5Ww9nmdJlUcGxi2rYtnBsY1Sn1eZ41+QFQA" rel="nofollow noreferrer">Try it at the TypeScript Playground!</a></p>
<p>This is a generic type <code>F</code> taking type <code>A</code> which is a tuple of two  lists of unary numbers (using unary not for the numbers themselves but for the individual digits, as allowed by OP) padded with leading zeroes (<code>[]</code>s) to the length of the output.</p>
<p>For example: <code>F&lt;[[[1],[1],[1,1,1,1,1,1],[1,1,1,1,1,1,1,1]],[[],[1],[1],[1,1]]]&gt;</code> (1168 + 0112) <code>= [[1],[1,1],[1,1,1,1,1,1,1,1],[]]</code> (1280)</p>
<h2>Explanation</h2>
<pre class="lang-typescript prettyprint-override"><code>//@ts-ignore                    Ignore any compilation errors in
type F&lt;                      // Recursive main type F
  A,                         //   A is tuple of two lists of unary digits
  C=[]                       //   C is the digit to carry, default 0
&gt;=
  // Match A to get the last and other digits of each number
  // X and Y are the current digits of each, G and H are the rest
  A extends[[...infer G,infer X],[...infer H,infer Y]]
    ?[...X,...Y,...C]extends // If it matched: Merge X,Y,C and match against
      [/* ... */,...infer R] //   ten 1s, storing what's left in R
        ?[...F&lt;[G,H],[1]&gt;,   //     If it matched, recurse with [G,H], C=[1]
          R]                 //       And append R
        :[...F&lt;[G,H],[]&gt;,    //     Otherwise, recurse with [G,H], C=[]
          [...X,...Y,...C]]  //       And append X,Y,C merged
    :[]                      // If the match failed, return the empty tuple
</code></pre>
</div>
<div id="pu1" class="pu"><h1>ISO C23 (clang 16), 42 bytes</h1>
<p><code>_BitInt(constant)</code> is a <a href="https://en.cppreference.com/w/c/23" rel="nofollow noreferrer">new C23 feature</a> for <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2709.pdf" rel="nofollow noreferrer">fixed-width integers</a>, wide or small.  Implementations can have limits (<code>BITINT_MAXWIDTH</code>) on how wide they support, but clang 16 is wide enough for the problem's stated range of [0, 10<sup>256</sup>).  log2(10^256) rounds up to 851 bits required.  960 is the largest 3-digit number that's a multiple of 64 (not required, I just chose for efficiency); you can use <code>unsigned _BitInt(999)</code> if you want.</p>

<pre class="lang-c prettyprint-override"><code>typedef _BitInt(960)T;T f(T*a,T b){*a+=b;}
</code></pre>
<p><strong>Updates the caller's <code>a</code> by reference.</strong>  Using the return value would be undefined behaviour (and in practice isn't useful even in a debug build.)</p>
<p>Works in practice with clang 16 (<a href="https://godbolt.org/#z:OYLghAFBqd5TKALEBjA9gEwKYFFMCWALugE4A0BIEAZgQDbYB2AhgLbYgDkAjF%2BTXRMiAZVQtGIHgBYBQogFUAztgAKAD24AGfgCsp5eiyagA%2BudTkVjVEQJDqzTAGF09AK5smBpwBkCTNgAcp4ARtikILIADuhKxPZMrh5eBrHxdkL%2BgSFs4ZGy1ti2iSJELKREyZ7ePFbYNplMZRVE2cFhEVFW5ZXVqXVKvW0BHXld0gCUVujupKicXEQAntHYODQA1KYAQsQAksIQAJwAbFqTACoApADMO5ebNBCXAFQs5I%2Bhk9cA7Dvva4AJh2dwAIqE7qDfmDrloAIIAekRTwk9ACwE26BoWxYmyYQgAtAA3dAETBPdxMEpCTYEJSbBQ7OlMTbOYGgkHkTahdxEFlsulEMBcBnoADWdK2RCQ2E24nojFIm0w6GwSiYIv57hUmxlctI2CIxIkcPhZotCOBtwCqA8OE2d2cQ0I6AAdEg7rgzQF%2BWwWAEID9/mbNptHupHbcwZstOpblpbscoWHkZseEDbtIAKyh8ObZZRmNxnGlsvlnHuXy%2BFObNOEnh557A07qbnLH73PNU%2BLAQIU%2BhCTGCdBFzaRr1ezanaRQvPRUi%2B5tAoGDgDumyB8qQVPFYulss2Sk8IEdQNzmZ4p3o6mu2ecRGBF9uV5vd%2BcTGBQO5EB7BD76ybIOJiTG2TzoOgnaglaMJcNM9DcNm/DeFwOjkOg3DOEeszzHK1p8OQRDaHB0ziiA2ZaIY3DSPwbDkZRKFoRhXD8EoICUURqFweQcCwCgGBsNEDARJQ1ACUJSpoMAGosNEShIOgRDkDgxIEAsABqBDYGuADyawoQRdD0EQERsRAoTEeQoQBBUyzcAR1msKQyw6aEujFJxBECRwwg6Uw9B2VxynYLywDOGibG8PwOD%2BiYkhBYQholMS6qWdg6jFHyiwEb6DSWeioSkLZrg4JZRCLnRUXTDQRjSZp2l6cw9n8IIwhiBInAyHIwjKGomhBfotyGMYZgWIYBChGxkDTOg0RNJFhIuuCfbuECkaEgA6mimybel5V4oSOm3Pw6ApaQi44FNQb1I0iSOEwLhuDUPgPe0uT5GkcQJEI/S1OQ6TfUwb2dJEgwNB5pTDL9BhFDSzTDMD4ygz0rTQ4MCOjO9XQ8NMSg4QsUjwYhyGWcx44ABynISM6bMAqCoJsEDlbukyM/gxBkGeL6TPwnE6JM0yyiwOCRNdCFcDR5B0ee5CMSd3CsexhHEdMvHICAsxENEfKiRA4nCaQQTsIs6iU9T0i0/TjPM0w4o8%2BQ6wcxdBitaICqdbIru9RolmDeQa5FdEzVE1wSGy6T3A6Xy2v8tiFNUzTdMM0zpAs4zriCQbXO3PbfMkeQQsi9QIeS9L2bh0FzGKxxKukfRVFcMdFdMQrytcariBqxA/HoJnSq6/rkn00YJhXlolEqWp2D1bp%2BnNQIDAmaQZkWUFjm2fP6/Oa57m2PP3nMEQfkBZZOCheFiqRQRMUjfFaGJRDKWRWh6WZSZlm5eLaEFUVzklYsaFyoEEqnwaqtUlAz0agZFq8h2qSC6l7FQPsBoGBHqNUwlgCpXRmnNRIC0lrRhWmtHaW1FQkL2kVHaR0TpnQuqlaaN0IYOAgE4NGDtXqYxBp9DIiQ2EAyaIjD6YNbpCBaH0J6AxGFwzESMHIXD0aowkX9IYrRBHY1xvjTqIcw5y3QtweO5t5RoPTKcN0WgzFs0ICQZU%2BFc61wLtgYWXRrpkR4OPBupdyLkzdOTIE49jhZmzL8Y40gkxAlOM3eWLErBKzzh3eA3cNbRx1lQPWvcJIRCNhwbgpsE4WyTumW4bogT8EdtY8kLtYHuykJ7eQ3t%2BpoX0HUAOslg4Nx0RHLgUctZ8ixFsXJhi7QjRMWYixEAM4ZJsZeOx7cS60SiDwN0PBgnHC0KcbM0g/HZnOL8WQuiq4xJrrM8gZEKINybvs1ucSQ4lMiXo6J1zyBnXiA4aQQA%3D%3D" rel="nofollow noreferrer"><strong>Godbolt</strong></a> shows it compiles to a sequence of  <code>add</code>/<code>adc</code> instructions for x86-64, with some wasted loads/stores).   But not GCC 13.2 or 14-trunk: <em>error: '_BitInt' argument '960' is larger than 'BITINT_MAXWIDTH' '575'</em>.  (The Godbolt link also includes a simple test caller in <code>main</code>, but AFAIK there isn't convenient support for <code>printf</code> of big <code>_BitInt</code> values, and I didn't bother writing a hexdump.)</p>
<p>C23 doesn't allow implicit-<code>int</code> return values, and <code>T</code> is a shorter type-name than explicit <code>void</code> or <code>int</code>.  But in C (unlike C++) it's <em>not</em> UB for execution to fall off the end of a non-<code>void</code> function, so we can declare it with a short type-name as the return type and still not actually <code>return </code> anything, if implicit-<code>int</code> isn't an option.  <code>void f(...)</code> would cost 3 extra bytes.  Or actually returning by value like <code>T f(T a,T b){return a+b;}</code> costs an extra 5.</p>
<p><code>typedef _BitInt(960)T;</code> is one byte shorter than <code>#define T _BitInt(960)</code>+newline.  The more readable version is 43 bytes:</p>
<pre class="lang-c prettyprint-override"><code>#define T _BitInt(960)
T f(T*a,T b){*a+=b;}
</code></pre>
<p>Related: <a href="https://stackoverflow.com/questions/61411865/how-do-you-use-clangs-new-custom-size-int-feature">https://stackoverflow.com/questions/61411865/how-do-you-use-clangs-new-custom-size-int-feature</a></p>
<hr />
<p><strong><a href="https://clang.llvm.org/docs/LanguageExtensions.html#extended-integer-types" rel="nofollow noreferrer">Clang provides <code>_BitInt</code></a> as an extension in older C modes, and in C++ mode.</strong></p>
<h1>C89 (clang 16), 40 bytes</h1>
<pre class="lang-c prettyprint-override"><code>typedef _BitInt(960)T;f(T*a,T b){*a+=b;}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=XZDBToNAEIbvfYo_NJrdSi0tlRQRDt5MeuSmxlBgYSOdbWQ3QhqfxEsvvfss3nwbtw0XnctM8s38f_75POZNRtXXI5xpq4u4IrMKHTwfjkaL6eqH6X5XFqXAy73UD6RZGHg8jQRLJ5mbYsP3k-wq3kQfw_73WFLemKLEnZWT6rpORpI0tpkkxvcjIEWHGF7ne34YAbMZ5gt_eXMm_ZmIf2XW68hiwS47Fz0_zYZaWVFZoFFUQShlDzskCYLlCe_erKdgTqPesUBeG3ptoQR0XaI121tcjOdB0z3poZPjgv3R5NbKylqzIdlh-Mgv" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>With default options (I think <code>-std=gnu11</code>), clang 16 requires <code>-Wno-implicit-int</code>, otherwise we get an error: <em>source.c:2:1: error: type specifier missing, defaults to 'int'; ISO C99 and later do not support implicit int [-Wimplicit-int]</em>.  (And yes, in clang it's an error, not a warning, even without <code>-Werror</code>.)</p>
<p>But <code>-std=gnu89</code> or <code>c89</code> is allowed &quot;for free&quot; without having to count those compiler command-line options as part of the size of the answer.  (I think?  I can't find the relevant meta Q&amp;A.) This feels like bending the rules because I'm using a very recent clang extension, but is arguably not breaking them.  It compiles to the same asm on <a href="https://godbolt.org/#z:OYLghAFBqd5TKALEBjA9gEwKYFFMCWALugE4A0BIEAZgQDbYB2AhgLbYgDkAjF%2BTXRMiAZVQtGIHgBYBQogFUAztgAKAD24AGfgCsp5eiyagA%2BudTkVjVEQJDqzTAGF09AK5smIWU4AyBEzYAHKeAEbYpCAATOQADuhKxPZMrh5ePvGJyUIBQaFsEVGx1ti2KSJELKREaZ7esqXlQpXVRHkh4ZExVlU1dRmNfe2BnYXd0QCUVujupKicXEQAnnHYODQA1KYAQsQAksIQAJwAbFqTACoApADMOzQQlwBULOSXm2GT1wDsO6/XaI7O4AETCd2BPxB1y0AEEAPTwzY0CT0QLATboGhbFibJhCAC0ADd0ARMMj3ExmkxNgQlJsFDtaTTnIDgUDyJ93ERmZtnLSiGAuPT0ABrWlbIhIbCbcT0RikTaYdDYJRMIU89wqTZSmWkbBEIkSLjTejcACs/G8XB05HQ3H5Slm8xlgNufHIRG0JumopA5q0hm40n4bBAt1uADoIzHY3HTuRrbb7Vx%2BEoQIGvTaTeQ4LAUBg2HEGJFKNRC8WFWhUEYTDxzoGcESCAsAGoEbAAdwA8mtrR66PQiJF0xAwt7yGFAtVltwPVPWKRlt2wroylmPYWOMJu0x6LPs%2BQcGF3MBnKj07x%2BDg2MZgJJD4R9eUiaqJ9h1GVuYsPYFh2bDzRMJSBnVwcAnIhSAIMMr2mGgjGAJR2y7XtmDnfhBGEMQJE4GQ5GEZQ1E0Q99FiWszAsQwCDCdNIGmdA4jsIRLwJAB1VFNjYj9INxAluyUfh0FfUgoJwWiIGmJomO8CAnAGbweHIfxRgKIoDASJJpPk9TsmkjpVO6RSpIqYZtKM7AbGk1oan0rooiM0y3HqAwlGGWzxnsyTnQWKRTQtK0JxTTZ1AADlOAlTmkWVyM2etIy0eLNggfBiDITY3R4SZ%2BCzHRJmmaUWBwKIJKDLgQ3IMMI2jOMaojBMk0E7g0wzT1vWmPNkBAWYiDibkywgCsS1IYJ2EWULwsi6K71i054vi/h1lS0SDEw0Q5Vw2RVsIjQJ1I8hOxAuJ0L8rhLUTQLuG7blep5LFgrCiKopraa4oSrQktcIshvS6JbimbK2pO8rKqjWravOw8U2azNAfIP0A1K24AshprWuzdrEA6iAC3QL6FX6waq1QZ66wbI9sGbNsOx7Pt0IEBhh1IUdx0PBcZzptmlxXNdbDprdmCIXd9wnY9T3PeVLw9G87wfW0n3XAhX0vW0Py/Yc6b/CyJyAkClzAxZbUg6DjoEBCkOp1D%2Bww%2BRsMkPCtpUHaSIMciQHMUxLCA8T6MYlIWNczBQWAJh3BC45OPY%2BUI%2B4kDOP4wThNEt86KsCyFYcWSmBcJyMkU5T8jsnTNJSMysmL3IVML8zLJMtpS%2BMlo3MrjyXMc9IFN6Np3LUzKZjmHze4As6Grtbh7omp6YtexLksIEhFQyrK0dy/LsEK7oSr9HgtEDADgf9Y5I1Oc0fj%2BrQQp%2BaJoh%2BaQ8JHqGrBanKcyxlBupugnccrSIRo4bhxsepsYAxNYpRmiAtOeZAyQrRtutKQm15DbWIrafQikDosCOrBUqw8LpcCuj1bkmItgAMmiTDE093oQE%2Bt/Bev1MoA3RkDUMPgEq3GkNEU4Pxjg8Gvpfc0YUIbJlRumGGjC4b%2Bl3twJGgjGqpmXj6Uq4CZGjzkc/PK5BhJJAcNIIAA%3D%3D%3D" rel="nofollow noreferrer">Godbolt</a>.</p>
<h1>C++ (clang 16), 43 bytes</h1>
<pre class="lang-c prettyprint-override"><code>using T=_BitInt(960);void g(T&amp;a,T&amp;b){a+=b;}
</code></pre>
<p>C++ <code>using</code> is shorter than C <code>typedef</code> or <code>#define</code>, but falling off the end of a non-void function is UB in C++, not just if the caller uses the result.  (<code>void</code> didn't exist in the early days of C, but existed from the start for C++.)</p>
<p>With <code>T</code> as the return type but no <code>return</code> statement, clang <code>-Os</code> emits zero instructions (not even <code>ret</code>) for the function.  With optimization disabled, clang emits a <code>ud2</code> (illegal instruction) at the end instead of <code>ret</code>.  (<a href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGErgDMpK4AMngMmAByPgBGmMQgAKykAA6oCoRODB7evv5BaRmOAmER0SxxCcl2mA5ZQgRMxAQ5Pn5cgbaY9sUMDU0EpVGx8Um2jc2teR1BChOD4cMVo4kAlLaoXsTI7BxeGUYA1AAqJgEAIgD6FoQAkoIQAJwAbBqrZxYAbqh46IfAEFOZmeTFIx0OMXeAHYLExrGdzjEPiYoecTBoAILojH7cLAE4I653B4vN4fcFUQHmEFg6mQlEWYiYAhbBiHOGWJEBKyo7HY3FHU4XIkEe4EJ6vd7c8EIKnA0FA570mEcqwXLk886HQ4Aeh1hy8DCwNAifziCCYnycW1I7KNh3QqEwCgYYA4BEOAHcSABrQ7hQ4pYhMOo7Q6YT6MdkegC0AHkNIcQAb0GYOOtaJxErw/BwtKRUJw3PDLIcFJttphDuYAjxSARNOn1j6khp9JxJLwWBING3c/nCxxeAoQG2G3n06Q4LAYIgUKgWCk6PFyJQ0IvlwlkAYjFxXm2sFadgA1PCYT1xlKMTh1mi0AjxEcQGKN0gxcJNACeN947%2BYxE/OMYm0Wpxzrdc2EEOMGFob8J1ILAYi8YA3DEWgR24XgsBYQxgHEeD8CZOpIww/NMFUWovAfH9yEEbpX1oPAYmDACPCwV8CGIPBu0w9YqAMYAFFPc9L2vTCZEEEQxHYKQJPkJQ1FfXQuH0XCUBLGxGJiEdIHWVAUl6DCYzmdAEWABgvA0swYkOeMzFsgB1NDHPIzimF4VBI2ILisB0iB1hqOpnAgVwpnaYIjSGcpKj0QpMgEMLYvSeKGCikYEhUwLen6SZPDaPQsvqeY0uWDLxgGRLMuKxZotGLgAorHYJAzLMc1fQdDlUAAOZ4Y2eSRDm3XDDj3AA6DRxsOCBcEIEhqzMWtVl4cctFWdYEEwJgsASfzSBbLhe3bDhO1IbsAkeUaoShLhEkkKEzEkLquC6swoWeUh%2Bw8zhh1HetG3Wac502AgUio1cIHXJd6GISJWF2brev6/5kGQEaAlGtNgnwIgfL0fhJNEcRZPx%2BSVHUeDlNIT1gxSH8Wo4bMPvazg4yo0GPVQKhOp6vqBqGo4xomxMIA8Ddofmxblv%2B%2BmTu7Z7RseLr7qhSRHgCRJax6xJ3s%2BgtvtsX6VsnQGICQSHN3B83oZQHdgD3Q7DzwE8zwvK9c1vOgH2IJ8X3gv8vxo/2AKAkCHBoiDGAIaDYNfRDkNQ2h0Jo7DcPw/NCNAvASNfcjKOo8TwgfTN4K0ljPzY3Z8047i6b4AShJd0T3d4EmpKJ6QScUMmlJAMxVKMdTLGsfQmL8vSDKyIyTLMiyrJs%2BNExjJzE5c1Q3I8ryfOdeAAu6TPgtCvLpgi9ASpilS4t6SrUmS3oz7qroeiKiqj/CwqBByhYynSgr5mvuYBj3wyg1LYTV6pHUZrrDqCNeaDVtiNZ441JrTWxnNGs9UpYTjWkdWWIBJBcAxvgrgV0nr9UVokLqTN4KDh%2BmOaWe1WxHQCG1ah%2BsjbYOLpjKBbD6FeQyM4SQQA%3D" rel="nofollow noreferrer">Godbolt</a>)</p>
<p><code>using T=_BitInt(960);T g(T&amp;a,T&amp;b){return a+b;}</code> is 46 bytes.</p>
<p>Taking both args by reference is probably better for efficiency in the caller.  In the callee, clang still saves enough call-preserved registers to load a whole arg into registers, instead of working on a couple chunks at a time.  And that's just addition; things get really hairy with division or multiplication.  (But unlike Clang 14, division is supported for big <code>_BitInt</code> types, both by small constants and by other variables.  Clang 15 dropped the max bit width to 128; Clang 16 widened it again.)</p>
</div>
<div id="pu2" class="pu"><h1><a href="http://clang.llvm.org/" rel="nofollow noreferrer">C (clang)</a>, <sup><s>73</s> <s>69</s></sup> 58 bytes</h1>

<pre class="lang-c prettyprint-override"><code>c;f(*a,*b,n){for(;n--;c/=10)a[n]=(c+=a[n]+b[n]-96)%10+48;}
</code></pre>
<p><a href="https://tio.run/##bVLLbtswELznKwgBBiRbQrh8E6p7KXrLH8RGQTFUalSRDctF3Br@9bpLPVwnqQCRy@XM7HBJX/jGtc@Xiy/rdO7yeZW32ane7tOyLYrS3y@BZu6xXS9Tv1jGYFHhUFiVzYAuhCnPl017IC9u06YZOd0R/DAxJ4fQHb65xzVZYub0kAAok@TkIWEcKHDOh4VgVjAhBRWiT1DLrWFCCWMFB2PkkDVcUsOkYpRyaxFBLet3QHNQmOIWgDOpOTXUagHJuXznpfrnhQIMbApGYqHBGCiNQgKYEXzyQqOYVTZOXA9ZVEdrAs/TW6catB0OY4FSY5niHH@wjFGJlu0bL@G4C/4Qnno3sS/M0LEVVlFmoF8IoFyAUcqYoSrGFgVBSCOZ5Ww8vdRKArfamNg1bBrTo4ASoJlllAluI4oZJbmmkxe/bbsD8d/dfo5j8D/CfnCUrI5f2epov@Afm3@75hMbHwhJ471v2qdwRBotx/AT6Ta/w7ZOp3Nm92Nifs2UZLHo0VkvNjyaa4Mcyo2Ppwety9t90oQWAa@@wyB1WfmWXP2sa9z2rmm2Po3YBYGciBscUv3uVxqROfkoMFWvPlSvR06VRxPviQGJ17v9n/Gd67rBuX/ZjVIhI8vYvCtwt0donSazpkPncSw@99OsW7V4G64vP5Cna4vC6xs79T6EXn/Mne/Olz@@btxzdyle/wI" rel="nofollow noreferrer" title="C (clang) – Try It Online">Try it online!</a></p>
<p><em>Saved 4 bytes thanks to <a href="https://codegolf.stackexchange.com/users/44718/tsh">tsh</a></em><br />
<em>Saved 11 bytes thanks to <a href="https://codegolf.stackexchange.com/users/30206/peter-cordes">Peter Cordes</a></em></p>
<p>Inputs two wide-charater strings, padded to the length of the expected output.<br />
Returns the sum in the first input string.</p>
</div>
<div id="pu3" class="pu"><h1>C, 54 bytes</h1>
<p>Binary bigint using 8 bits per <code>int</code>, in little-endian limb order.  Carry-out still fits within an <code>int</code> where we can get it with a shift.  <code>void f(int *dst, int *src, int n)</code>.  Updates the destination in place</p>
<pre><code>x;f(*a,*b,n){for(x=0;n--;*a++&amp;=255)x=*a+=x/256+*b++;}
</code></pre>
<p><a href="https://tio.run/##VZDhaoMwFIV/16cIHR2Jua5qazuauhfpZMQYu4CNRVOQia8@l7jKuvw43HP5uPfkikBUXJ/HsWMl9jn4OWjSl3WDuzRkOgiYzyl9TuMkIV1q67Rbx8mO@jmlbBiflBbVrZDo2JpC1S@fb57SBl240pig3ls4Z2RrPvgpQylCqI/AauxkehvYQgI72A/sgc4faLv6TrsqhAj2EM207K5SGFlMfB8DjqmLurIZwc52k6MNvM64tlSrvmRd4t9UZP3PnsKMWHS2cE8DSE/tukHYjVH2NuqomaKU2E8uro3tlnjJhbnx6jCHOqBVgZy86yXMZ1AZ/KVW07rBG8ZvUVb83I4/" rel="nofollow noreferrer" title="C (clang) – Try It Online">Try it online!</a></p>
<p>Iterates over the arrays, <code>a[i] += b[i] + carry_in</code>, truncating dst elements to 8 bits.  <code>x</code> = un-truncated addition result, so the carry-out is in its 9th bit.  It's non-negative since <code>int</code> is at least 16-bit, so we can do <code>x/256</code> = <code>x&gt;&gt;8</code> to get it as a 0 / 1 integer that has the right place-value for the next limb.</p>
<p>9 bits per limb would still cost the same code size (<code>&amp;=511</code> and <code>x/512</code>), but more bits would need longer constants.  I picked 8 because it's a round number, and easy to pack down to bytes to avoid the wasted space.  (Making it a plausible format for larger code-golfed programs that want to use this.)</p>
<p>On a 64-bit machine with 32-bit <code>int</code>, this supports numbers up to <code>8*(2^31-1)</code> bits wide.  That's vastly larger than the required 10^256 which only requires 851 bits.  I could have used just 4, 2 or even 1 bit per limb to make the constants even smaller.  Or 3 bits per limb (<code>&amp;=7</code> and <code>x/8</code>); it doesn't have to be a power-of-2 number of bits.  Using up 4x the amount of space seemed more reasonable than wasting 31x the amount, and more plausible for code converting to this format.</p>
<hr />
<p>Real-life code uses this technique, but with 30 bits per <code>uint32_t</code> for example in CPython, since they avoid using hand-written asm for more efficient bigint on machines that have a carry flag.  (See my <a href="https://codereview.stackexchange.com/questions/237690/bigint-class-in-c/237764#237764">codereview answer</a> discussing BigInt implementation techniques, that using base 10 is highly inefficient, although base 10^9 in 32-bit chunks is good for efficient conversion to/from decimal strings, as in <a href="https://codegolf.stackexchange.com/questions/133618/extreme-fibonacci/135618#135618">Extreme Fibonacci</a> code golf.)  Multiply uses stuff like <code>a * (uint64_t)b</code> as a widening multiply.</p>
<p>Partial-word bigint formats (not using all the bits per chunk) also allow deferring carry for SIMD implementations (<a href="https://stackoverflow.com/questions/8866973/can-long-integer-routines-benefit-from-sse">as Mysticial explains</a>), but that requires writing code that's aware of it.</p>
<p>C sucks at exposing add-with-carry or sub-with-borrow, especially carry-<em>in</em> to the same element where you want a carry-out.  No portable functions for this, so it's up to compilers to recognize some idioms, such as <code>carry = (a+b)&lt;a</code> for unsigned types.  Or there are non-portable intrinsics such as for x86, but <a href="https://stackoverflow.com/questions/33690791/producing-good-add-with-carry-code-from-clang">those often compile to poor asm</a> for more than 2 limbs, or in a loop.  But things have improved some recently, with a combination of some compilers getting better at keeping carry-out in the carry flag (instead of materializing a 0/1 integer in a register), and <a href="https://stackoverflow.com/questions/4153852/assembly-adc-add-with-carry-to-c/75759422#75759422">a way of writing portable ISO C source</a> that actually gets clang to compile to a chain of <code>adc</code> instructions on ISAs that have a carry flag.</p>
<p>This version is of course optimizing for source size, not performance or storage density.</p>
</div>
<div id="pu4" class="pu"><h1>x86-64 machine code, <s>10</s> 8 bytes</h1>
<p>A function that adds two little-endian binary Bigintegers of the same (non-zero) length, updating the destination in-place, using add-with-carry as a building block as it was designed for this.</p>
<p>It takes 2 pointer args and a count of how many 32-bit chunks, like <code>add_bignum(uint32_t *rdi_dst, uint32_t *rsi_src, size_t count_rcx)</code>.  (That matches the x86-64 SysV calling convention if you use a dummy 3rd arg to fill the EDX slot.)  The same machine code works in 32-bit mode, since <code>lodsd</code> and <code>stosd</code> work with whatever the native pointer size is.</p>
<p>It returns CF = carry-out from the top element.  (If you want that to be part of the output, zero-extend the inputs with an extra 0 element at the top, and include that in the count.)</p>
<pre><code>; NASM listing: machine code | source
               add_bignum:
 F8               clc                ; CF=0, no carry-in to the bottom.
                                     ; Peeling a first iteration using ADD would cost more bytes
               .loop:                ;do {
 AD               lodsd                ; eax = [rsi]; rsi+=4 without affecting FLAGS
 13 07            adc   eax, [rdi]
 AB               stosd                ; [rdi] = eax; rdi+=4 without affecting FLAGS
 E2 FA            loop  .loop        ; }while(--rcx);
 C3               ret   
</code></pre>
<hr />
<p>Add-with-carry (<a href="https://www.felixcloutier.com/x86/adc" rel="nofollow noreferrer"><code>adc</code></a>) chains the carry-out from the top of one chunk into the carry-in for the next chunk.  As the loop iterates, it's like one wide <a href="https://en.wikipedia.org/wiki/Adder_(electronics)#Ripple-carry_adder" rel="nofollow noreferrer">ripple-carry adder</a> over the full width of the arrays.  (With carry-lookahead or whatever optimizations exist inside the CPU's ALUs happening within each chunk to run it with single-cycle latency.  But as far as the result is concerned, it's like one long chain of full-adders, with the same hardware reused by software feeding the carry-out of the last instruction to the carry-in of the next.  Carry only propagates from low to high in both addition and subtraction.  It doesn't matter what element-size you use for it, as long as you get all the bytes of your bigints and chain the carry correctly.)</p>
<p>Bigint performance notes: the <code>loop</code> instruction is <a href="https://stackoverflow.com/questions/35742570/why-is-the-loop-instruction-slow-couldnt-intel-have-implemented-it-efficiently">slow except on recent AMD CPUs</a>, where it's actually really handy for loops that want to preserve FLAGS.  It's too bad Intel didn't make it fast. Normal bigint loops on Sandybridge and later use <code>dec ecx / jnz</code> which leaves only CF unmodified, because Sandybridge has cheap partial-flag merging instead of stalling.  And Broadwell and later don't merge at all; uops that want both parts of FLAGS just read it as 2 separate inputs, which is why <code>cmovbe</code> and <code>cmova</code> are still 2 uops while others are down to 1 uop.  So the bigint looping problem has been solved that way, <a href="https://stackoverflow.com/questions/32084204/problems-with-adc-sbb-and-inc-dec-in-tight-loops-on-some-cpus">unlike on older P6-family CPUs</a> where partial-flag stalls are a real problem.</p>
<p>Also, for performance, memory <em>source</em> <code>adc</code> is better on Intel CPUs, with a separate <code>mov</code> store.  (Fun fact: memory destination <code>adc</code> has an extra uop beyond what you'd expect because of arcane microarchitectural reasons involving lack of TLB coherency across the uops of one instruction, <a href="https://stackoverflow.com/a/32258855/224132">according to Andy Glew</a>.)</p>
<p>Also obviously using 64-bit operand-size would go twice as fast as 32-bit, or 8x as fast as bytes, for the same number of bytes.  (Instruction fetch/decode isn't the bottleneck on modern CPUs with a uop cache, so the code-size differences aren't very significant for a hot loop).  That costs an extra REX prefix on most instructions so I didn't use it in the initial version with 32-bit elements.</p>
<p><strong>TL:DR: un-golfing this code to something that performs well is more than just the obvious changes.</strong> (Especially before the last update.)  Look at the hand-written asm in GMP for production-quality example.  (e.g. <a href="https://github.com/sethtroisi/libgmp/blob/master/mpn/x86_64/coreisbr/aors_n.asm" rel="nofollow noreferrer">https://github.com/sethtroisi/libgmp/blob/master/mpn/x86_64/coreisbr/aors_n.asm</a> is the add-or-sub template for <code>adc</code> or <code>sbb</code> loops for Sandybridge-family.  It uses some <code>jrcxz</code> instead of just <code>dec/jnz</code> at the bottoms of loops, but I think the main unrolled loop uses <code>dec/jnz</code>.)</p>
<hr />
<p>A previous version of this answer used memory-destination <code>adc [edi], al</code>, having to use byte operand-size instead of dword so we could use 1-byte <code>inc</code> in 32-bit mode.  Thanks @m90 for reminding me of the standard lods / stuff / stos pattern which has the added bonus of allowing memory-source <code>adc</code>!  My comments below are about why that 1-byte version was so inefficient:</p>
<p>Normally you can use <code>scasd</code> to increment RDI by 4, as long as it's a valid pointer, but that does a compare as well as load which overwrite FLAGS, breaking the chain of carry propagation through CF.  Some shenanigans like pointing ESP at this array and using 1-byte <code>pop eax</code> then <code>adc [esi], eax</code> and a dummy <code>lodsd</code> to increment ESI might work, but would probably cost more bytes than <code>lea edi, [edi+4]</code> (and a signal handler could clobber the array).  Maybe we could expect our caller to pass one of the bigints by value on the stack.  And we'd still have to push the return address back again.</p>
<p>So <s>definitely the smallest</s> (and lowest performing) is to use 1-byte &quot;limbs&quot;, making the pointer increment a single-byte (in 32-bit mode) <code>inc</code>, which sets the other FLAGS (all of SPAZO), but not CF.  Other code can process the same bigint in larger chunks; <strong>the limb size is only relevant to the count the caller passes, not anything else about the layout.</strong></p>
</div>
<div id="pu5" class="pu"><h1>Trivial Built-in Answers</h1>
<p>For languages where bignum addition is already supported.</p>
<h2><a href="https://github.com/Adriandmen/05AB1E" rel="nofollow noreferrer">05AB1E</a>, <a href="https://github.com/JCumin/Brachylog" rel="nofollow noreferrer">Brachylog</a>, <a href="https://factorcode.org" rel="nofollow noreferrer">Factor</a>, <a href="https://www.jsoftware.com" rel="nofollow noreferrer">J</a>, <a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, <a href="http://julialang.org/" rel="nofollow noreferrer">Julia</a>, <a href="https://github.com/AlephAlpha/Nekomata" rel="nofollow noreferrer">Nekomata</a>, <a href="https://github.com/TehFlaminTaco/RProgN-2" rel="nofollow noreferrer">RProgN 2</a>, <a href="https://github.com/Vyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a>, 1 byte</h2>
<pre><code>+
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f9f@/9/IxMjSxMjE1MTAxMTLkMzc2NLSxNDIwsTYwA" rel="nofollow noreferrer" title="05AB1E – Try It Online">Try it online! (05AB1E)</a></p>
<p><a href="https://tio.run/##DcMxDkBAEAXQq@gp5s@3s/uvQhQoKCQSndMPL3nbs@7ne92HZ/aZMyoRlCiAXiqtmeqIoXPBrMmD/EPuVkq4lpw@" rel="nofollow noreferrer">Try it online! (Brachylog)</a></p>
<p><a href="https://tio.run/##DcM5CoAwEADA3lekF2QPc6w@QGxsxAcEUbRQQ9jG10cHZo@rPrks8zgNnbmiHiblTfVN@bzV9FWFntGxCAsik/UMAcS3aEgQIAg55j8KEVjrSEpdmvIB" rel="nofollow noreferrer" title="Factor – Try It Online">Try it online! (Factor)</a></p>
<p><a href="https://ato.pxeger.com/run?1=m70wa8FOJT0F9TQFWysFdR0FAwUrINbVU3AO8nFbWlqSpmuxUBtC37TS5EpNzshXMDTCBSsU0hSMTTBhBcSEBQsgNAA" rel="nofollow noreferrer">Attempt This Online! (J)</a></p>
<p><a href="https://tio.run/##DcPBDYAwDAPAgfjENknqgfigLsD0KSfd@@z9zVwzgxZKtgyI2YoV7htDI2KZJf1hMjKLPg" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online! (Jelly)</a></p>
<p><a href="https://tio.run/##yyrNyUw0rPifpmCr8F/7v0NxRn65QpqGobmxoZmxpaWxpaGhsZGpubGBhYGluYmhjpGloYGBhaWRmbExEBtaGhkZmJqaGVlqchHSSrKRuDRo/gcA" rel="nofollow noreferrer" title="Julia 1.0 – Try It Online">Try it online! (Julia)</a></p>
<p><a href="https://ato.pxeger.com/run?1=LY4xTgNADAT7e8UpLYrk9fruvG9BFAFBgwJFwmtoEgkQPa_hNzhAYVkrjcf7-vl0__i83x13H9eb7X5zc3p_OT5s83z1dri9O_yn0_cXMLMb4M0JA8lKOVKRzcMVHiMsomMuSgHPYBOVHjMKIzJHF820QlOXxdWSw9LHdLM6K9rkfQWKj3r567WFpYZFzGIogD4WLS8OdBfMUj7JGsjdRgn11_0H" rel="nofollow noreferrer">Attempt This Online! (Nekomata)</a></p>
<p><a href="https://tio.run/##DcNRCoAwDAPQA4nQJLZbTuSfjt0fqg/eXvu9n5PdR3djCCVbBsQcihkeF5pGxDRL@sNkZBb9AQ" rel="nofollow noreferrer" title="RProgN 2 – Try It Online">Try it online! (RProgN 2)</a></p>
<p><a href="https://vyxal.pythonanywhere.com/?v=2#WyIiLCIiLCIrIiwiIiwiODM1MDgyNTYyMDAzOTk5ODIwOTJcbjc0MTQzMTQxNjg5NDI0NTA3MTc5Il0=" rel="nofollow noreferrer">Try it Online! (Vyxal)</a></p>
<hr />
<h2><a href="https://www.haskell.org" rel="nofollow noreferrer">Haskell</a>, <a href="https://www.python.org" rel="nofollow noreferrer">Python</a>, <a href="https://raku.org" rel="nofollow noreferrer">Raku</a>, 3 bytes</h2>
<pre class="lang-python prettyprint-override"><code>sum
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=Nc09CsJAEEDhq0xhoaAwPzszO8WeRCwiGAwmQUxymjRpgmfyNgrB4sHrvvl9r4bHrW2XZZ3G-pTXugxTt_3n2lVNDwWer6YfYQf7Gs7kQiYREkTC6oIZwxMdOQgxB5vILwpmVDWOywFKgWSJnIORk4S6KWdTcdykv_4F" rel="nofollow noreferrer">Attempt This Online! (Haskell)</a></p>
<p><a href="https://ato.pxeger.com/run?1=JYw5DsIwEAC_k0gg7eHd9RZ-BwXQWlDkEDgFb0ljKYI_5TdBcjGaqWb9zZ_ymMa65XT7LiWf4_Zehlb7ZX49x9Ll7orGqOzOjsgkxhDBLeCJHAGikzL_QScCESW_9ykFDWjkBBTYxVQoqrBB3_a1Nh8" rel="nofollow noreferrer">Attempt This Online! (Python)</a></p>
<p><a href="https://ato.pxeger.com/run?1=m72kKDG7dMGCpaUlaboWUOqmVXFipUJxaa6GobmxoZmxpaWxpaGhsZGpubGBhYGluYmhjpGloYGBhaWRmbExEBtaGhkZmJqaGVlqQg2CmgQA" rel="nofollow noreferrer">Attempt This Online! (Raku)</a></p>
<p>Takes input as a list.</p>
<hr />
<h2><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 2 bytes</h2>
<pre><code>Ｉ⁺
</code></pre>
<p><a href="https://tio.run/##S85ILErOT8z5///9npWPGnf9/x9taG5saGZsaWlsaWhobGRqbmxgYWBpbmKoo2BkaWhgYGFpZGZsDMSGlkZGBqamZkaWsQA" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Requires input in JSON format. 4 bytes for string input:</p>
<pre><code>Ｉ⁺ＮＮ
</code></pre>
<p><a href="https://tio.run/##S85ILErOT8z5///9npWPGne937MOiP7/NzQ3NjQztrQ0tjQ0NDYyNTc2sDCwNDcxVDCyNDQwsLA0MjM2BmJDSyMjA1NTMyNLAA" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a></p>
<hr />
<h2>Java, 14 bytes</h2>
<pre><code>a-&gt;b-&gt;a.add(b)
</code></pre>
<p>I/O as <code>java.math.BigInteger</code>s.</p>
<p><a href="https://tio.run/##nZFBa@MwEIXv@RWDTzZJhEYj29K2CbQLC3vYU49tDnLiZJ06jrGULKXkt2fHqbMsJbCwAiEx873nN/LWHd10u3o9L2vnPfxwVfM@AvDBhWoJW@6KQ6hqsT40y1DtG/FtuNxfejsXforHavO9CeWm7Cb/q/hUnc9hDbOzm86L6dwJt1rFRXK@G3Gy9lDUnGwIeNxXK9hx6PgpdFWzeV64buOTfgSA9b6Lj66DUPrw1fnyS1P@giv3HiFmBsYgEVU0iRShRCK6VExqrDZ9VSurlU611Jo7mOVkrUZlNHHXkjVKZ5phQmNSJixJaXNtM9sflDNlKJVGpZmSksWskFYxmWtkleYQly/IHHPLNOaEGXNkEUmlOUnTOyErlEUpjVUZEW@0SsmUbW10GgYGeHrzodyJ/SGIlucM8XX2cQQziJK7geufxYfuoetmV0L4tq5CHMHLy/gv8tbvATfrn/JWK/5wfZaLZDI43FzFPx1w8SfD56nqJl4L17b1W@yS4VIkA34a9ft0/g0" rel="nofollow noreferrer">Try it online.</a></p>
<hr />
<h2>JavaScript (ES11), 9 bytes</h2>
<p>With BigInts as I/O.</p>

<pre class="lang-javascript prettyprint-override"><code>a=&gt;b=&gt;a+b
</code></pre>
<p><a href="https://tio.run/##DcPtDkAgFADQ16kZux8q90feJZQxK8O8fpzt7OEN93xt59PmssSafA1@nPwYmqnOJd/liN1RVpUUOkbLIiyITMYxDCCux6wVCQIMQpb5j0IExliSrHX9AA" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<hr />
<h2><a href="https://pari.math.u-bordeaux.fr" rel="nofollow noreferrer">PARI/GP</a>, 9 bytes</h2>
<pre class="lang-javascript prettyprint-override"><code>a-&gt;b-&gt;a+b
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=JVBLasUwDLyKySqhDuhnW1o0Fwmh5C1SHpQSHq-QnqWbQCmlR-plSuVkIaQZzYxAH9_rfLs-Pa_75xIev97uS68_cz9c-mF-uJz4929e15f3dgv9ENbb9fXebiNOoYmhCdtIPtVNE5aD79rKdV0M44iYNQIiTY6IEZCZndCkJnqQQiYkSUAkYi5sJkgqXJfGpiRZXMyomqIxgBWxbLVxqSLlBEopE4Cb3QBGsQi6Rfz8kQ4Fi1UxFsbsMjZEplQYtCZhJEMANcrMXmhEkDzTpqk7v7DvZ_8H" rel="nofollow noreferrer">Attempt This Online!</a></p>
<hr />
<h2><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, 8 bytes</h2>
<pre class="lang-ruby prettyprint-override"><code>proc &amp;:+
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=JY9RbsIwDIbfc4qsSAjEVsV20sRInGSbUKFBq8Sgoq20CXjbLfbCw5B2i52D28yhD5b1x9__x_7-OfSrz8u1rCq9uPbd5in8Nof9Wo_ns0Hevg6xrLb1LrZ5LNdvutrrU5InpXXqeRW3sYvLtt9s6o-HSfayy6YyKx_1Si8GpG22dTfJ9Exn0_y9bCbjebdf1glr-q7V2eiYuLPwo6Ps8pzMr7kw7TlTcVcNu1xufwBFkBgDgAoJDBDRXQcX2AaFFtmiddZYK-9QeGK2gMGSYuKAtrACEoTgZM5kDHvLBadGXgVyJqAr0BgxCm8YhfMWxGPl83u68eBZgScohCIGIHSeTEgpIDwyGBMYCyIpYETjJJSHO_4B" rel="nofollow noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu6" class="pu"><h1><a href="https://factorcode.org/" rel="nofollow noreferrer">Factor</a>, <s>39 31</s> 43 bytes</h1>
<pre><code>[ 0 -rot [ + + 10 /mod ] 2map swap suffix ]
</code></pre>
<p><a href="https://tio.run/##S0tMLskv@h8a7OnnbqWQm1iSoZCdWpSXmqNQnFpYmpqXnFqsUFCUWlJSWVCUmVeiYM3FVa1gCYS1MPp/tIKBgm5RfolCtII2EBoaKOjn5qcoxCoY5SYWKBSXg4jStLTMCoXY/8mJOTkKev8B" rel="nofollow noreferrer" title="Factor – Try It Online">Try it online!</a></p>
<p>Non-builtin counterpart to the <code>+</code> answer. Takes two reversed, padded lists of digits as input and outputs the reversed answer as a list of digits.</p>
</div>
<div id="pu7" class="pu"><h1><a href="https://www.r-project.org" rel="nofollow noreferrer">R</a>, 30 bytes</h1>
<pre class="lang-r prettyprint-override"><code>\(x,y)c(0,z&lt;-x+y)%%10+c(z&gt;9,0)
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=bc9BSsQwFAbgfU4RkMKLbTGpg4zFeADPIJbQtDWQSWfaZEjnKm7qwlMI3mNu46t14YDZvBDe__Hn7X2Yz5_G-cr3lW5qs1O20qYzfpRatsHV3vQOYmal7TvBIbJUsKE5QkxuEsFfQJQ2FyzBOyOXwEKi_EdhY9hBvF5itnGdf8WnUmCcEXJFjdsHT9VIm0NQNl836LGpfT-MtG_pL09XviRKa_kRfJtvv56x4sRq4NnpIY_p9FMoreH0eJ9xti6dn6IUxe2GTLLY3G0FJ6AcfvO_0oA2aEQLzjIN0zLxEKSlxNQqzvM6vwE" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Input as vectors of decimal digits, padded to the same length with leading zeros (or <a href="https://ato.pxeger.com/run?1=bdBdToQwEADg955iEkPSyhIpbsxKUg_gFfwhDS3YpNsqlLVwFV_wwVN4kvU0DuLDmtiXmbQzX2b69t7Nxy_jQhV8pXRt9tJWyrQm9EKJZnB1MN7RuLHC-pbnNLKUs04faEwuEp4_Ul7ajLMEc0b-AguJ8onC-mFP4_nSZrVrwxNelRzbGSFnYNzzEED2oF8GabO1Ag66Dr7rwTfwy8PKw6vBZxnAatkH8E4vmTKuhUl3viRSKfExhCbbfd7jBiOjk4jp-DNrSqeba3aX8Ye14ngbBS8ut2QUxfZqx3NCpcMv-G8hijBVKBY52yg6LhEPQVsI7FrFeV7jNw" rel="nofollow noreferrer">27 bytes</a> if the padding always contains at least one leading zero).<br />
Automatic vectorization of (most) functions in R makes this pretty easy.</p>
<hr />
<h1><a href="https://www.r-project.org" rel="nofollow noreferrer">R</a>, 41 bytes</h1>
<pre class="lang-r prettyprint-override"><code>\(x,y)c(0,z&lt;-c(y&amp;0,x)+c(x&amp;0,y))%%10+(z&gt;9)
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=bZBRToQwEIbfOUUTg5kKRLpuzEqsTx7DSJAC26S0hJa15Sq-4IOH2jN4CQd3H9zEp047833NPx-f43L8ltqVzpSiqWVfqVLITjrLBW8nXTtpNPhUcWU6loOnCaNjcwAf38YsfwVWqIzRGGsaXQpWJZr_WKidevA3K6Ya3bk9PhUMcRpFV0TqYXKksuTQ1M6MlpiWnI3kZCTv0u0NDg2VEFJ3KVJ4XbG1Q2Aw1so3FUhf6UDRKJ1Eem5GY4sIIf41uTbbHekLZgq0hjydH7MawnWeYrQaPBaB_uZJYH56oGfg2XO2udtGgW-29zuWR1BpXNF_gQH_AYHRUgGownA-CZzj_Mm1LKfzBw" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Input as vectors of decimal digits, no padding required.  Output can contain (possibly many) leading zeros.</p>
<hr />
<h1><a href="https://www.r-project.org" rel="nofollow noreferrer">R</a>, <s>90</s> 58 bytes</h1>
<pre class="lang-r prettyprint-override"><code>\(x,y,a=c(0,z&lt;-c(y&amp;0,x)+c(x&amp;0,y))%%10+(z&gt;9))a[cumsum(a)&gt;0]
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=bZBNasMwEIX3OoWgOEi1TaU0lNRUuUPX_TFCsh2BLQVbSuVcpRt30bP0DLlNx00WCXQ1j-G9jzfz-dVPxx9jfeldqStlOtmW2jTGD0KLOljljbMkZq1oXcMZiTTltK_2JCZ3CWfvhBdtzmkCmqJrwIwE8gWFDqEj8XaOtZVt_BZWBYc4RegGG7sLHi-wC34WcsD7SnnXD9jV-IzGJzT-MH4LPryTWhvbFAim-A6-ztfH4hX6jpkUirDs8JQrMi5YBsUViSBG-tc2JYfNI6XyRYVuriXphr2dCc9R8OX9Co1iuXpYczbTiYaymSYQR9LCd_67lVwbKYrpKATYT-BpOs1f" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Input as vectors of decimal digits, no padding required.  Output has no leading zeros.</p>
</div>
<div id="pu8" class="pu"><h1><a href="https://www.lua.org/" rel="nofollow noreferrer">Lua</a>, <s>121</s> 119 bytes</h1>

<pre class="lang-lua prettyprint-override"><code>load&quot;A,B=...m=math.floor o=''c=0 for i=1,#A do L=#A-i+1O=A:sub(L,L)+c+B:sub(L,L)c=O/10 o=m(O%10)..o end return m(c)..o&quot;
</code></pre>
<p><a href="https://tio.run/##PY7RaoQwEEV/ZchSVlHTmYlJnEIe3GfBb7BmlwpqitXvt/alDxfuuXDgzsdwDjFCgHNOQ1Rt@Qha6yUsw/6lX3NKG6Rwv48B4XX1KVB5ayEm6MKtraaC@tB@/ByfWVd2eTEWj38YQ/9OeNlL1r8R5loneK4Rtud@bCss2fg3qfN7m9Y9u05kirwhZ0SMEBm23mCD4mtSpWIhxEbYGXOFhBmtdSwqz6GqoHY1eRZGro1Y7yw3zhqP5y8" rel="nofollow noreferrer" title="Lua – Try It Online">Try it online!</a></p>
<h2>Ungolfed</h2>
<pre class="lang-lua prettyprint-override"><code>function add(A,B)
    floor=math.floor
    output=&quot;&quot;
    carry=0
    for i=1,#A do
        L=#A-i+1
        sumResult=A:sub(L,L)+carry+B:sub(L,L)
        carry=sumResult/10
        output=floor(sumResult%10)..output
    end
    return floor(carry)..output
end
</code></pre>
<p>Inputs must be 0 padded to equal length.</p>
</div>
<div id="pu9" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 63 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>f=(a,b,c=0)=&gt;(c-=~a.pop()+~b.pop()+2)||a+b?f(a,b,c/10|0)+c%10:a
</code></pre>
<p><a href="https://tio.run/##LZDrasJAEIX/71PkT2GXxDiXvU1L2gepUtcYpUVM0FIUxFdPN2kXljk78505sF/pJ13a8@fwvTj1u24c941O1bZqGzDNq24XzSPVQz9oUz62/4LM/Z7K7dv@j1wi3MGU7RPCcxpfNog@FmUBiKSIEZCZ53d0UWxUZEksWWfB2txHH1jEIkXLSlgiWW8zyBijy3NhAAlWvEyFg4rsIJLzBJCNmQehzAWL2WNz@LwdAgZRCNOZUmahMDD67GJBZHKBIU5bMRMkmYlCnjlfFCJwOUQ29bkbjqnttFrq1a40xaosZrE8VIX@qK7VLX9V258u/bGrj/1B7/V7XdfXdTWV29oYM/4C" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<p>no bigint</p>
</div>
<div id="pu10" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, <s>78 67 59</s> 49 bytes</h1>
<pre class="lang-ruby prettyprint-override"><code>-&gt;a,b{c=0;a.zip(b).map{s=_1+_2+c;c=s&gt;9?1:0;s%10}}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=TY_BTsMwDIbvfYpQBNq0rbLjtI03dTwIoKprMyga7dR0CNj2JFw4wJkLb8BT8DYkG0IcEsfO__22X966zeLp9WPVNjd5UVV1X7eNyN43_XKiv3EyL8aLbZnBrIie6_VgMYzui_XWZjmOcjkqZ2Vm53yBU5jZM4T9_hf87ExRrerG2MgU5a2oWrHz6S4QwseoMivTm9xulsv68WQQXjXh0P0VY7EQ2VFi16u6H4RiJMJDV7Hd2b7bCXdF5W3RWV8cnE_7Nq-HUWceTGfN3pmsN70V4enWu-ydm3v93-7SN7mO7tq6-aPCwDTVcfbX7y_ERLu2gCgDSQhIRIdcx5qVDqSSrKSKFSjl6pikxKxQakUBMLGWKlFOSah17EEmAE4VJ-wDpQFoikHLOJEAjnUEsPTKVKHDlBvg0AFSTDnAlDBxMmJEknFKoL0POkAyAmiWCZE7yFJC7Fz5uMsP" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>My first Ruby submission! This is probably a little golfable but I'm pretty happy with it considering I have almost zero Ruby experience. Suggestions are welcome!</p>
<p>Implements long addition on two lists of digits in reverse order padded to the length of the output with zeroes, and outputs a list of digits in reverse order. Explanation:</p>
<ul>
<li><p><code>-&gt;a,b{...}</code> Proc (anonymous function) taking parameters <code>a</code> and <code>b</code></p>
<ul>
<li><p><code>c=0;</code> Set the <code>c</code> (the carried digit) to 0</p>
</li>
<li><p><code>a.zip(b)</code> Zip <code>a</code> with <code>b</code> to get a list of pairs of digits</p>
</li>
<li><p><code>.map{...}</code> Map each pair of digits to</p>
<ul>
<li><p><code>s=_1+_2+c;</code> Set <code>s</code> to the sum of the two digits and the carry</p>
</li>
<li><p><code>c=s&gt;9?1:0;</code> Set <code>c</code> to 1 if <code>s</code> is greater than 9, or 0 otherwise</p>
</li>
<li><p><code>s%10</code> Return the ones place of <code>s</code> by taking it modulo 10</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
