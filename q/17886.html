<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::17886</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>326</td><td>Python3</td><td>250908T195203Z</td><td><a href="https://codegolf.stackexchange.com/questions/17886/determine-which-value-represents-which-direction-in-a-path/283590#283590">Ajax1234</a></td></tr>
<tr d-ix="1"><td>207</td><td>APL</td><td>140111T155905Z</td><td><a href="https://codegolf.stackexchange.com/questions/17886/determine-which-value-represents-which-direction-in-a-path/18248#18248">Tobia</a></td></tr>
<tr d-ix="2"><td>151</td><td>Mathematica</td><td>140109T002921Z</td><td><a href="https://codegolf.stackexchange.com/questions/17886/determine-which-value-represents-which-direction-in-a-path/18035#18035">ybeltuko</a></td></tr>
<tr d-ix="3"><td>nan</td><td></td><td>140107T224625Z</td><td><a href="https://codegolf.stackexchange.com/questions/17886/determine-which-value-represents-which-direction-in-a-path/17928#17928">Dr. beli</a></td></tr>
<tr d-ix="4"><td>nan</td><td></td><td>140108T002144Z</td><td><a href="https://codegolf.stackexchange.com/questions/17886/determine-which-value-represents-which-direction-in-a-path/17934#17934">Blau</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Python3, 326 bytes</h1>
<pre class="lang-py prettyprint-override"><code>from itertools import*
E=enumerate
def f(b):
 d={(x,y):v for x,r in E(b)for y,v in E(r)}
 q=[]
 for i in permutations({*d.values()},4):
  for j in d:t={**d};q+=[(*j,t.pop(j),dict(zip(i,[(0,1),(1,0),(0,-1),(-1,0)])),t)]
 for x,y,D,M,d in q:
  t={**d}
  if{}==t:return M
  X,Y=M[D]
  if(D:=t.pop(V:=(x+X,y+Y),0)):q+=[(*V,D,M,t)]
</code></pre>
<p><a href="https://tio.run/##bVLPS8MwFD6bv@Kxi0n3LGu7g1QCghP0MI@jUodMm2LG1mRpNjbH/vb50hW9SMnjfT/6vTSpPfgv02S31p3PtTNr0F45b8yqBb22xvmIPUrVbNfKLbxilaqh5h8iZ1DJI9/jQeQ7qI2DPTrQDTySGOABdxfoxInBRpZz1tl0YK1y661feG2alh@jKt4tVlvVcnHCcYjunMvgrHIvj1FUne42Q1nyaIk@tsbypcBKf3r@rS3XWPIRJgJ5giOqI7wJ4CaguRDoRT@bdosTnGIVkjdhTh9Ona6PJyl97pTfugamRBX4KqflZN6pfJLLy@hZLvl@WOBh@CpogsgvO5t10TTr3CYgYTAYsATS/kmozyCBcVgs7fqMUMoCNw4OyNjFm4XFwvtt2gfdQwwxU1Tv2RM8Ue3krJcLKGDGnuGBagHPVGfUP3R80VnDtXnz/mEWruItHfFV/52ljlu70p6L38up9Yp@Af5iGoXQ9vL1W3Mt6ByZdbrxvOZ/aYkQ4h86/Z/OiD7/AA" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1>APL (207)</h1>

<p>I couldn't make it shorter than Mathematica, because I couldn't reason in terms of TopologicalSort and such. Smarter people are welcome to squeeze it further.</p>

<p><strong>Golfed:</strong></p>

<pre><code>{u←∪,t←⍵⋄q r←↑(0≠+/¨r)/⊂[2]p,⍪r←{m←,⍵[u⍳t]⋄v r←⊂[1]⊃{{(↑⍴∪⍵),⊂(↑⍵)(↑⌽⍵)}n↑{3::⍬⋄i←↑⌽⍵⋄⍵,i+i⌷m}⍣n,⍵}¨⍳n←↑⍴,t⋄↑(v=n)/r}¨p←⊂[2]{1≥⍴⍵:⊃,↓⍵⋄⊃⍪/⍵,∘∇¨⍵∘~¨⍵}d←¯1 1,¯1 1×c←¯1↑⍴t⋄⊃('←→↑↓',¨u[q⍳d]),{1+(⌊⍵÷c)(c|⍵)}¨r-1}
</code></pre>

<p><strong>Ungolfed:</strong></p>

<pre><code>D←{⎕ML ⎕IO←3 1
    pmat←{1≥⍴⍵:⊃,↓⍵⋄⊃⍪/⍵,∘∇¨⍵∘~¨⍵}   ⍝ utility: permutations of the given vector
    u←∪,t←⍵                    ⍝ the 4 unique symbols in t←⍵
    n←↑⍴,t                     ⍝ number of elements in t
    d←¯1 1,¯1 1×c←¯1↑⍴t        ⍝ the four ∆i (+1, -1, +cols, -cols)
    p←⊂[2]pmat d               ⍝ list of permutations of the four ∆i
    r←{                        ⍝ for each permutation ⍵∊p (=interpretation of the 4 symbols)
        m←,⍵[u⍳t]              ⍝ (ravelled) t-shaped matrix of ∆i, using interpretation ⍵
        v r←⊂[1]⊃{             ⍝ for each starting index ⍵∊⍳n
            v←n↑{              ⍝ trail of visited cells after n steps 
                3::⍬           ⍝ if index out of bounds return empty list
                i←↑⌽⍵          ⍝ take last visited index
                ⍵,i+i⌷m        ⍝ follow the directions and add it to the list
            }⍣n,⍵
            (↑⍴∪v),⊂(↑v),↑⌽v   ⍝ number of unique cells, plus start/end indices
        }¨⍳n
        ↑(v=n)/r               ⍝ 1st couple of start/end indices to visit all cells (if any)
    }¨p
    q r←↑(0≠+/¨r)/⊂[2]p,⍪r     ⍝ select first perm. and start/end indices to visit all cells
    ⊃('←→↑↓',¨u[q⍳d]),{1+(⌊⍵÷c)(c|⍵)}¨r-1   ⍝ return char mapping and start/end indices
}
</code></pre>

<p><strong>Examples:</strong></p>

<p>(Indices start at 1)</p>

<pre><code>     D⊃'122221' '131414' '231342' '144213' '222323'
 ←  4 
 →  2 
 ↑  3 
 ↓  1 
 1  1 
 3  6 
     D⊃'@..' 'e.@' 'HH@'
 ←  . 
 →  H 
 ↑  @ 
 ↓  e 
 2  2 
 1  1 
     D⊃'XXV' 'ICV' 'XIV' 'VCC' 'XXX'
 ←  C 
 →  X 
 ↑  I 
 ↓  V 
 3  1 
 5  3 
</code></pre>
</div>
<div id="pu2" class="pu"><h1>Mathematica (151)</h1>
<pre><code>L = {{1, 2, 2, 2, 2, 1}, {1, 3, 1, 4, 1, 4}, {2, 3, 1, 3, 4, 2}, 
   {1, 4, 4, 2, 1, 3}, {2, 2, 2, 3, 2, 3}};

PathGraphQ@#~If~Print@{TopologicalSort[#]〚{1,-2}〛,r}&amp;@
Graph@Flatten@MapIndexed[#2-&gt;#2+(#/.r)&amp;,L,{2}]~Do~{r,
Thread[Union@@L-&gt;#]&amp;/@{-1,0,1}~Tuples~{4,2}}
</code></pre>
<p>It returns start point, end point, and transition rules. The first index is row, the second is column</p>
<pre><code>{{{1,1},{3,6}},{1-&gt;{1,0},2-&gt;{0,1},3-&gt;{-1,0},4-&gt;{0,-1}}}
</code></pre>
<p>Note that my code works even with <code>{-1,0,1}~Tuples~{4,2}</code>. For speeding up you can use <code>Permutations@{{1, 0}, {0, 1}, {-1, 0}, {0, -1}}</code> instead.</p>
</div>
<div id="pu3" class="pu"><h2>Mathematica 278</h2> 

<p>Spaces added for "clarity"</p>

<pre><code>k@l_ := (s = #~Join~-# &amp;@{{1, 0}, {0, 1}};
         f@r_ := Flatten[MapIndexed[#2 -&gt; #2 + (#1 /. r) &amp;, l, {2}], 1];
         g     = Subgraph[#, t = Tuples@Range@Dimensions@l] &amp; /@ 
                       Graph /@ f /@ (r = Thread[# -&gt; s] &amp; /@ Permutations[Union @@ l]);
        {t[[#]] &amp; /@ Ordering[Tr /@ IncidenceMatrix@g[[#]]][[{1, -1}]], r[[#]]} &amp; @@@ 
                                                                 Position[PathGraphQ /@ g, True])
</code></pre>

<p>Session &amp; Output:  </p>

<pre><code> l = l1 = {{1, 2, 2, 2, 2, 1}, {1, 3, 1, 4, 1, 4}, {2, 3, 1, 3, 4, 2}, 
            {1, 4, 4, 2, 1, 3}, {2, 2, 2, 3, 2, 3}}; ;
 k@l1
 {{{{1, 1}, {3, 6}}, 
    {1 -&gt; {1, 0}, 2 -&gt; {0, 1}, 3 -&gt; {-1, 0},  4 -&gt; {0, -1}}}}
</code></pre>

<p>Which is the start Vertex, End Vertex and the transition rules associated with each symbol.</p>

<p>Here is the complementary code to show the oriented graph:</p>

<pre><code>sol = sg[[Position[PathGraphQ /@ sg, True][[1, 1]]]];
Framed@Graph[
  VertexList@sol,
  EdgeList@sol,
  VertexCoordinates -&gt; VertexList@sol /. {x_, y_} :&gt; {y, -x},
  VertexLabels -&gt; MapThread[Rule, {VertexList@sol, Flatten@l}], 
  EdgeShapeFunction -&gt; GraphElementData["FilledArcArrow", "ArrowSize" -&gt; 0.03],
  ImagePadding -&gt; 20]
</code></pre>

<p><img src="https://i.sstatic.net/kipgh.png" alt="Mathematica graphics"></p>
</div>
<div id="pu4" class="pu"><h2>C#</h2>

<p>EDIT: Fixed a division and formatting. And added the helper class.</p>

<p>This is the golfed code, 807 chars </p>

<pre><code>class M{public int c,x,y,u;}
void G(string[] z){
M K;int[]x={0,0,-1,1},y={-1,1,0,0},I={0,0,0,0};
string[]T={"Up","Down","Left","Right"};
int X,Y,R,n=0,H=z.Length,W=z[0].Length;W-=W/2;var D= string.Join(" ", z).Where(c=&gt;c!=' ').Select(c=&gt;new M(){c=c,x=n%W,y=n++/W}).ToList();n=0;var S=D.GroupBy(k=&gt;k.c).ToDictionary(k=&gt;k.Key,k =&gt;n++);
for(;I[0]&lt;4;I[0]++)for(I[1]=0;I[1]&lt;4;I[1]++)for(I[2]=0;I[2]&lt;4;I[2]++)for(I[3]=0;I[3]&lt;4;I[3]++){
if ((1&lt;&lt;I[0]|1&lt;&lt;I[1]|1&lt;&lt;I[2]|1&lt;&lt;I[3])!=15)continue;
foreach (var Q in D){D.ForEach(p=&gt;p.u=-1);R=1;K=Q;j:if((X=K.x+x[n=I[S[K.c]]])&gt;=0&amp;&amp;X&lt;W&amp;&amp;(Y=K.y+y[n])&gt;=0&amp;&amp;Y&lt;H&amp;&amp;(K=D[X+Y*W]).u&lt;0){
K.u=1;if(++R==D.Count){Console.WriteLine("{4} Start({0}:{1}) End({2}:{3})",Q.x,Q.y,K.x,K.y,string.Join(", ",S.Select(k=&gt;string.Format("{1}: '{0}'",(char)k.Key,T[I[k.Value]])).ToArray()));return;}goto j;}}}
}    
</code></pre>

<p>Results for the three test cases:</p>

<blockquote>
  <p>Down: '1', Right: '2', Up: '3', Left: '4' Start(0:0) End(5:2)<br>
  Up: '@', Left: '.', Down: 'e', Right: 'H' Start(1:1) End(0:0)<br>
  Right: 'X', Down: 'V', Up: 'I', Left: 'C' Start(0:2) End(2:4)</p>
</blockquote>

<p>This is the raw code without "golf", almost 4,000 characters:</p>

<pre><code>class Program
{
    static string[] input1 =  { "1 2 2 2 2 1",
               "1 3 4 4 1 4",       
               "2 3 1 3 4 2",
               "1 4 4 2 1 3",       
               "2 2 2 3 2 3"};

    static string[] input2 =  { "@ . .",
                                "e . @",       
                                "H H @",
               };

    static string[] input3 =  { "0 0 1",
                                "0 0 1",       
                                "3 2 2",
               };

    static void Main(string[] args)
    {
        Resolve(input1);
        Resolve(input2);
        Resolve(input3);
        Console.ReadLine();
    }


    class N { public int c; public int x, y, i, u; }

    static void Resolve(string[] input)
    {
        int[] ox = { -1, 1, 0, 0 }, oy = { 0, 0, -1, 1 }, I = { 0, 0, 0, 0 };
        string[] TXT = { "Left", "Right", "Up", "Down" };
        int X, Y, R, n = 0, H = input.Length, W = input[0].Length;
        W -= W / 2;
        N K = null;
        var data = string.Join(" ", input).Where(c =&gt; c != ' ').Select(c =&gt; new N() { c = c, x = (n % W), y = (n / W), i = n++, u = -1 }).ToList();
        n = 0;
       var S = data.GroupBy(k =&gt; k.c).ToDictionary(k =&gt; k.Key, k =&gt; n++);

        for (; I[0] &lt; 4; I[0]++)
            for (I[1] = 0; I[1] &lt; 4; I[1]++)
                for (I[2] = 0; I[2] &lt; 4; I[2]++)
                    for (I[3] = 0; I[3] &lt; 4; I[3]++)
                    {
                        if (((1 &lt;&lt; I[0]) | (1 &lt;&lt; I[1]) | (1 &lt;&lt; I[2]) | (1 &lt;&lt; I[3])) != 15) continue;
                        foreach(var Q in data)
                        {
                            data.ForEach(p =&gt; p.u = -1);
                            R = 0;
                            K = Q;
                            while (K != null)
                            {
                                n = I[S[K.c]];
                                X = K.x + ox[n];
                                Y = K.y + oy[n];
                                if (X &gt;= 0 &amp;&amp; X &lt; W &amp;&amp; Y &gt;= 0 &amp;&amp; Y &lt; H)
                                {
                                    n = X + Y * W;
                                    if (data[n].u &lt; 0)
                                    {
                                         data[n].u = K.i;
                                         K = data[n];
                                        R++;
                                        if (R == data.Count - 1)
                                        {
                                            Console.WriteLine();
                                            Console.WriteLine("Start({0}:{1}) End({2}:{3})", Q.x, Q.y, K.x, K.y);
                                            Console.WriteLine(string.Join(", ", S.Select(k =&gt; string.Format("'{0}': {1}", (char)k.Key, TXT[I[k.Value]])).ToArray()));
                                            Action&lt;N&gt; Write = null;
                                            Write = (k) =&gt;
                                             {
                                                 if (k.u != -1)
                                                 {
                                                     Write(data[k.u]);
                                                 }
                                                 Console.Write(string.Format("({0}:{1}){2}", k.x, k.y, k == K ? "\n" : " =&gt; "));
                                             };

                                            Write(K);
                                            return;
                                        }
                                        continue;
                                    }
                                }
                                K = null;
                            }
                        }
                    }
        Console.WriteLine("Solution not found");
    }
 }
}
</code></pre>

<p>These are the results for the three examples:</p>

<blockquote>
  <p>Solution not found</p>
  
  <p>Start(1:1) End(0:0) '@': Up, '.': Left, 'e': Down, 'H': Right </p>
  
  <p>(1:1) => (0:1) => (0:2) => (1:2) => (2:2) => (2:1) => (2:0) => (1:0) => (0:0)</p>
  
  <p>Start(0:0) End(1:1) '0': Right, '1': Down, '3': Up, '2': Left </p>
  
  <p>(0:0) => (1:0) => (2:0) => (2:1) => (2:2) => (1:2) => (0:2) => (0:1) => (1:1)</p>
</blockquote>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/17886/">17886</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




