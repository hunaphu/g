<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::174407</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td></td><td>230723T031316Z</td><td><a href="https://codegolf.stackexchange.com/questions/174407/count-arrays-that-make-unique-sets/263197#263197">138 Aspe</a></td></tr>
<tr d-ix="1"><td>nan</td><td></td><td>181025T053632Z</td><td><a href="https://codegolf.stackexchange.com/questions/174407/count-arrays-that-make-unique-sets/174678#174678">Οurous</a></td></tr>
<tr d-ix="2"><td>014</td><td>Common Lisp SBCL</td><td>181024T204741Z</td><td><a href="https://codegolf.stackexchange.com/questions/174407/count-arrays-that-make-unique-sets/174657#174657">JRowan</a></td></tr>
<tr d-ix="3"><td>024</td><td>Rust</td><td>181021T135127Z</td><td><a href="https://codegolf.stackexchange.com/questions/174407/count-arrays-that-make-unique-sets/174414#174414">Anders K</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>C++</h1>
<p>C++ port of @Anders Kaseorg's Rust answer. <a href="https://tio.run/##hVdbc9pGFH7nV5y4Mx4pAgyOE8cImGkzzbQzecg0tC8uZRaxoLXFimhXBDfmr9c9Z3cF6GJHyVg7Ovfv3JZos@msoujp6SchoyRfcBjOhVYXSi@iIOjG41auhFyBZGuuNizigJSw1Wrphw1f8CXkQuo3lzMNk7ClNNMigiiVSkMulVhJvoBffp98gRG8h9egxL88XXoTnzQ4biETIflRT8a3PFN8Rm54h687H763AJ@LC5jEQgH@Z2hpvU4lIOs3oTjoTET3oNNCBxHUwIjt0APP28E59HYf8enhk/swHkP/nQ@PBxp9JzrShkOihQ3ixFKIv/ehJG6pVvx9k3TP/rPSV2VpR7TSVw3SH9xjpS9L0m/cY6UvG6R/do8LvCT91j0ucCedcZ1nEnZha08Jy/JIw1880mn2G1OxSwllFVOUbnjGkOL5nq2ArWEcTsZwjkff1YWVcan8GYXXm4RTJudCYkFgOmNSzTabLGVRfODGuhsMnKkYg@qFB9IyzcBjOSb@fAcDMMaOZpypD8YCh2WWrmGepkoPBmRpZk3zTiLued0sPTH8M7L2SQADwhCxIAOE7Ya/ub6@md9cL6/YddR/@@enT/jdiwnEd749mkwdvd0fTg7d2NL2rX1YAfnXry4O9Dd5AeBzYG2ofZvXIXcWGYxGMD81i30GayakRweWrSLUF7MMXuN5ezst8BRLBBqp8GpE1XdUHPEso5jPPiecYechiluB04TvWKSTB0gReVTNVzwj9fmaS939W56FVdf6hVf09zBDpP2qs4cTmxIoKzREZhFTelhwjz2l0zzxjOv9qe@w30PEdBSD1@12G13/yESCtrCMNoymR@EnMFX4/mOXCSFJ8Pbg8RFdHJv512hPwjrH7MxxTnH9jXPUBEwu4IyoZmoS18smzcvlPJdptuAZX8zWbDM8FELbVE/7pG/bh/LC0syl@Jpz7wY6cIn1WnT@sXlVvlaebEPPUSZYKLvZliU0WU7xx77o9H0zWzzjfgekH1Lvef3hUPqdvnXXtOuEihCbGF/DUaExhCBgp1hNaJQjX2kpsKqJA7spT4Qc2asTADtBC5nz0z48nUQU5S1WxpS8Ao4jAISmfsOJdBw0Ikk84uzO@QqbxW8buS6XCzr3/MpMOtSvsLEKGGIpgwiCqnsT2lXI1A9Ln8ta7pBBhPgyWu7qWsyoQD3DIQ19RjDd@Tje@35Y4zMB3yGAYgqPIxIr8@ybgCr7o9CfyxBfaO4G33WHDqwJlytNYxubI6A/Hdo/eCOoeHYQYFnGHr7guEcZJ3xhmyIgkEpC5VqdYYUUwuWclAxsUlXeIiWqisVS1@kTSNKmr7FNcKuePLuWtriWyLemhKFGxN/bUrcbsw3JosJ29W49wwpo0mW2lXD6TprE6m1QvK/XhdEf4GithFP4YRnGo9pgq2vpWKawmcXk6hbzQD2XpM1cSA6CZpJJRSzC51Co5ake8L4cIoWHWl@56Y066NgU44@dx5lifMfVh/sPNX/jILndLzlul1g0ovuCzR/AcXSJmmv6DDYvxm@LNcf1gdJ2MdyStstpWOcz84p4u0uB88@ar5QYRYR8rxyjmZNNoQndGSuOM3qBOpcsUbwyjIDjtwZBo1ZIxTPtfbcutPGakPO9//w4q69OHB1RmkutrJA9dzc5Xg/nLLqvrjlpFqUfnuwzC90a@9ziVt5i6JnbmM3X1nsaEOsqMoTe/bZrgXmmCo3agBYHVZzZWxS@C4GuLv0XcWgO1@r1S7cMVP85o@thmmuzTjkZSJeFKUH3yj/wRmNv0me4TadnFOSa6QJVba40t@5CYwBwV/qTDencIYLn17ZlocVy3Yppef0LSk1VSf0y4Dxpw1lYK4wSx9Rcv05/DPUM0njBjbhSgwHfCe1hv2L4FHxr//T0dP1ftEzYSj118FfDCH9I96/@Bw" rel="nofollow noreferrer">Try it online!</a></p>
<p><a href="https://tio.run/##nVbBcpswEL37K9Y5eCBxFNs9tBXGnfbUHnqqpxePhyFYTpQB4SJBkwZ/u7srsBtioJ3qkGGkp7fv7a61yXJtDodcC9Bmw/lzlMaxiIxMleb8c6jvv4a7MQhVjCERyRh2WRoJrffeYGCedgKW4EP@ZuYNIrxh4NOX5TdOG7iNeM61/CWCdMv5fLlwXAi1PbyEd0iwVZCEUuH28wBwxcJAmN1pvIsBOadvx2W1JKT4LqJ5sEAez@JDrUVmhg7hWCyIyPdhVp8SmzpqIchquma7MNMCOXP1Mwt3r4kULGBytjf3ra0XtEluIFfyRy6Q2pkx5r93WYJ8ZVBCnTTOlfjpuD3yj0w6T8hyIaLhakIZWnqgbKYoeesKvE0zCEEqqBAYcjiBxQIckgbXoI5JpCW3iEXZIctEIdBxcCsNprLzwjFCQRFGJ1FNAK3LApVOvMb@/oxGWqGMqRaGo2tUhFRT7wxABA9EINsJaNHlORkkRw8wauOhRS5WzgPale6fjELpE8P5lf1ffGmSZcvdY4xiBljQVkGNIjvYXFeAf65h6uJvQrtwY1sNd6cv9DKpTBrcpo9iE@hYRuLYQW3hd6k@L1FD373cmn5InPaf38v2c8rRqOqhjv6xLCkVoMACVlraS4c9XHdqJXgOXc1ACxVZzhcNbq@57eT79m6xga580J2SKsiiehF69FS46wrndcNsr6ywZmvMaJx2I6msV35Xn9dp9TEPXl@OWqvWnpDzHbSPMYbIAWVJbPbzefD/xvpNYbz@IOeBuuz/i73qQV/p0@8Oe2i2bqVjQpnsyaliu@2QUG2CJN3I7ZNT5iVc5ihvG8ZadODTLJCKRo5jsly4XU9s9bVvDJAozZU5jRB6U6b11KhOmHg0Qm2cQdNqIwKTRmROU1s10pISElaEcS5oGNutERrK7SPmMkxCPdxfXW6Ze2OLqL3tMnzWYjV0Lp75h/3FuBZ7OrX/Z3AuHqVxcCjDzQ18LFK5gSxXSqo72AiNqYpMmmk22B8Oh7e/AQ" rel="nofollow noreferrer">ref Rust code</a></p>
<pre class="lang-cpp prettyprint-override"><code>#include &lt;bits/stdc++.h&gt;
using namespace std;


typedef uint32_t T;
static const unsigned BITS = 8 * sizeof(T);


static inline uint32_t reverse_bits(uint32_t x) {
    // This is a common bitwise trick to reverse bits:
    x = ((x &amp; 0xFFFF0000u) &gt;&gt; 16) | ((x &amp; 0x0000FFFFu) &lt;&lt; 16);
    x = ((x &amp; 0xFF00FF00u) &gt;&gt; 8)  | ((x &amp; 0x00FF00FFu) &lt;&lt; 8);
    x = ((x &amp; 0xF0F0F0F0u) &gt;&gt; 4)  | ((x &amp; 0x0F0F0F0Fu) &lt;&lt; 4);
    x = ((x &amp; 0xCCCCCCCCu) &gt;&gt; 2)  | ((x &amp; 0x33333333u) &lt;&lt; 2);
    x = ((x &amp; 0xAAAAAAAAu) &gt;&gt; 1)  | ((x &amp; 0x55555555u) &lt;&lt; 1);
    return x;
}

struct VectorHash {
    size_t operator()(const vector&lt;T&gt; &amp;vec) const {
        // A simple combination hash approach
        std::size_t h = 0;
        for (auto &amp;x : vec) {
            // Combine from boost::hash_combine-like approach
            h ^= std::hash&lt;T&gt;()(x) + 0x9e3779b97f4a7c15ULL + (h &lt;&lt; 6) + (h &gt;&gt; 2);
        }
        return h;
    }
};

struct VectorEq {
    bool operator()(const vector&lt;T&gt;&amp; a, const vector&lt;T&gt;&amp; b) const {
        return a == b;
    }
};

int main(int argc, char *argv[]) {
    if (argc != 2) {
        cerr &lt;&lt; &quot;Please provide exactly one integer argument.\n&quot;;
        return 1;
    }
    unsigned n;
    try {
        n = static_cast&lt;unsigned&gt;(stoul(argv[1]));
    } catch (...) {
        cerr &lt;&lt; &quot;Failed to parse argument as integer.\n&quot;;
        return 1;
    }
    if (n == 0 || n &gt; BITS) {
        cerr &lt;&lt; &quot;n must be between 1 and &quot; &lt;&lt; BITS &lt;&lt; &quot;.\n&quot;;
        return 1;
    }

    vector&lt;unordered_map&lt;vector&lt;T&gt;, bool, VectorHash, VectorEq&gt;&gt; unique(9 - 2 + 1);
    vector&lt;T&gt; sums(n, 0);
    T max_val = (static_cast&lt;T&gt;(-1)) &gt;&gt; (BITS - n); // (1&lt;&lt;n)-1

    for (T a = 0; a &lt;= max_val; ++a) {
        T rev = reverse_bits(a) &gt;&gt; (BITS - n);
        if (a &gt; rev) {
            continue;
        }

        // sums[...] = 0 each iteration
        fill(sums.begin(), sums.end(), 0);
        for (unsigned i = 0; i &lt; n; i++) {
            T bit = 1;
            for (unsigned j = i; j &lt; n; j++) {
                bit &lt;&lt;= ((a &gt;&gt; j) &amp; 1);
                sums[j - i] |= bit;
            }
        }

        for (unsigned s = 2; s &lt;= 9; s++) {
            unsigned length = (n + (n - 1) * s);
            unsigned arraySize = length / BITS + 1;

            vector&lt;T&gt; sums_s(arraySize, 0);
            unsigned pos = 0;
            unsigned shift = 0;
            T lo = 0;
            T hi = 0;

            for (auto &amp;v : sums) {
                lo |= (v &lt;&lt; shift);
                if (BITS - shift &lt; n) {
                    hi |= (v &gt;&gt; (BITS - shift));
                }
                shift += s;

                if (shift &gt;= BITS) {
                    shift -= BITS;
                    sums_s[pos] = lo;
                    pos++;
                    lo = hi;
                    hi = 0;
                }
            }

            if (lo != 0 || hi != 0) {
                sums_s[pos] = lo;
                // pos++ only if we need to use hi
                if (hi != 0) {
                    pos++;
                    sums_s[pos - 1] = hi;
                }
            }

            auto &amp;umap = unique[s - 2];
            auto it = umap.find(sums_s);
            if (it != umap.end()) {
                it-&gt;second = false;
            } else {
                umap.insert({sums_s, true});
            }
        }
    }

    vector&lt;T&gt; counts;
    counts.push_back(static_cast&lt;T&gt;(n + 1));

    for (auto &amp;m : unique) {
        T sum_val = 0;
        for (auto &amp;kv : m) {
            if (kv.second) {
                sum_val += 1; // each true counts as 1
            }
        }
        counts.push_back(sum_val);
    }

    // Print out contents of counts in a Rust-like &quot;[..]&quot; format
    cout &lt;&lt; &quot;[&quot;;
    for (size_t i = 0; i &lt; counts.size(); i++) {
        cout &lt;&lt; counts[i];
        if (i + 1 &lt; counts.size()) {
            cout &lt;&lt; &quot;, &quot;;
        }
    }
    cout &lt;&lt; &quot;]\n&quot;;

    return 0; // process::exit(0) in Rust
}
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/Ourous/curated-clean-linux" rel="nofollow noreferrer">Clean</a></h1>

<p>Certainly not the most efficient approach, but I'm interested in seeing how well a naive by-value filter does.</p>

<p>That said, there's still a bit of improvement to be made using this method.</p>

<pre><code>module main
import StdEnv, Data.List, System.CommandLine

f l = sort (nub [sum t \\ i &lt;- inits l, t &lt;- tails i])

Start w
&#9;# ([_:args], w) = getCommandLine w
&#9;= case map toInt args of
&#9;&#9;[n] = map (flip countUniques n) [1..9]
&#9;&#9;_ = abort "Wrong number of arguments!"

countUniques 1 n = inc n
countUniques s n = length uniques
where
&#9;lists = [[s + ((i &gt;&gt; p) bitand 1) \\ p &lt;- [0..dec n]] \\ i &lt;- [0..2^n-1]]
&#9;pairs = sortBy (\(a,_) (b,_) = a &lt; b) (zip (map f lists, lists))
&#9;groups = map (snd o unzip) (groupBy (\(a,_) (b,_) = a == b) pairs)
&#9;uniques = filter (\section = case section of [a, b] = a == reverse b; [_] = True; _ = False) groups
</code></pre>

<p>Place in a file named <code>main.icl</code>, or change the top line to <code>module &lt;your_file_name_here&gt;</code>.</p>

<p>Compile with <code>clm -h 1500m -s 50m -fusion -t -IL Dynamics -IL StdEnv -IL Platform main</code>.</p>

<p>You can get the version TIO (and myself) use from the link in the heading, or a more recent one from <a href="https://clean.cs.ru.nl/Download_Clean" rel="nofollow noreferrer">here</a>.</p>
</div>
<div id="pu2" class="pu"><p><strong>Common Lisp SBCL, N = 14</strong></p>

<p>call function (goahead n s)</p>

<pre><code>    (defun sub-lists(l m &amp;optional(x 0)(y 0))
  (cond; ((and(= y (length l))(= x (length l)))nil)
        ((= y (length l))m)
        ((= x (length l))(sub-lists l m 0(1+ y)))
    (t (sub-lists l (cons(loop for a from x to (+ x y)

             when (and(nth (+ x y)l)(nth a l)(&lt; (+ x y)(length l)))
                ;   while (nth a l)
             ;while(and(&lt; (+ x y)(length l))(nth a l))
                    collect (nth a l))m) (1+ x)y))
    ))
(defun permutations(size elements)
  (if (zerop size)'(())
 (mapcan (lambda (p)
                    (map 'list (lambda (e)
                           (cons e p))
                         elements))
     (permutations (1- size) elements))))
(defun remove-reverse(l m)
  (cond ((endp l)m)
    ((member (reverse (first l))(rest l) :test #'equal)(remove-reverse (rest l)m))
    (t (remove-reverse (rest l)(cons (first l)m)))))
(defun main(n s)
  (let((l (remove-reverse (permutations n `(,s ,(1+ s)))nil)))

  (loop for x in l
     for j = (remove 'nil (sub-lists x nil))
       collect(sort (make-set(loop for y in j
        collect (apply '+ y))nil)#'&lt;)
     )
  ))
(defun remove-dups(l m n)
  (cond ((endp l)n)
        ((member (first l) (rest l) :test #'equal)(remove-dups(rest l)(cons (first l) m) n))
    ((member (first l) m :test #'equal)(remove-dups(rest l)m n))
    (t(remove-dups (rest l) m (cons (first l) n))))

  )
(defun goahead(n s)
  (loop for a from 1 to s
  collect(length (remove-dups(main n a)nil nil))))
(defun make-set (L m)
  "Returns a set from a list. Duplicate elements are removed."
  (cond ((endp L) m)
    ((member (first L) (rest L)) (make-set (rest L)m))
    ( t (make-set (rest L)(cons (first l)m)))))
</code></pre>

<p>here is the run times</p>

<pre><code>CL-USER&gt; (time (goahead 14 9))
Evaluation took:
  34.342 seconds of real time
  34.295000 seconds of total run time (34.103012 user, 0.191988 system)
  [ Run times consist of 0.263 seconds GC time, and 34.032 seconds non-GC time. ]
  99.86% CPU
  103,024,254,028 processor cycles
  1,473,099,744 bytes consed

(15 1047 4893 6864 7270 7324 7328 7328 7328)
CL-USER&gt; (time (goahead 15 9))
Evaluation took:
  138.639 seconds of real time
  138.511089 seconds of total run time (137.923824 user, 0.587265 system)
  [ Run times consist of 0.630 seconds GC time, and 137.882 seconds non-GC time. ]
  99.91% CPU
  415,915,271,830 processor cycles
  3,453,394,576 bytes consed

(16 1502 8848 13336 14418 14578 14594 14594 14594)
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.rust-lang.org/" rel="noreferrer">Rust</a>, n ≈ 24</h1>

<p>Requires nightly Rust for the convenient <code>reverse_bits</code> feature.  Compile with <code>rustc -O unique.rs</code> and run with (e.g.) <code>./unique 24</code>.</p>



<pre class="lang-rust prettyprint-override"><code>#![feature(reverse_bits)]
use std::{collections::HashMap, env, mem, process};

type T = u32;
const BITS: u32 = mem::size_of::&lt;T&gt;() as u32 * 8;

fn main() {
    let args = env::args().collect::&lt;Vec&lt;_&gt;&gt;();
    assert!(args.len() == 2);
    let n: u32 = args[1].parse().unwrap();
    assert!(n &gt; 0);
    assert!(n &lt;= BITS);
    let mut unique = (2..=9).map(|_| HashMap::new()).collect::&lt;Vec&lt;_&gt;&gt;();
    let mut sums = vec![0 as T; n as usize];
    for a in 0 as T..=!0 &gt;&gt; (BITS - n) {
        if a &lt;= a.reverse_bits() &gt;&gt; (BITS - n) {
            for v in &amp;mut sums {
                *v = 0;
            }
            for i in 0..n {
                let mut bit = 1;
                for j in i..n {
                    bit &lt;&lt;= a &gt;&gt; j &amp; 1;
                    sums[(j - i) as usize] |= bit;
                }
            }
            for s in 2..=9 {
                let mut sums_s =
                    vec![0 as T; ((n + (n - 1) * s) / BITS + 1) as usize].into_boxed_slice();
                let mut pos = 0;
                let mut shift = 0;
                let mut lo = 0;
                let mut hi = 0;
                for &amp;v in &amp;sums {
                    lo |= v &lt;&lt; shift;
                    if BITS - shift &lt; n {
                        hi |= v &gt;&gt; (BITS - shift);
                    }
                    shift += s;
                    if shift &gt;= BITS {
                        shift -= BITS;
                        sums_s[pos] = lo;
                        pos += 1;
                        lo = hi;
                        hi = 0;
                    }
                }
                if lo != 0 || hi != 0 {
                    sums_s[pos] = lo;
                    pos += 1;
                    if hi != 0 {
                        sums_s[pos] = hi;
                    }
                }
                unique[s as usize - 2]
                    .entry(sums_s)
                    .and_modify(|u| *u = false)
                    .or_insert(true);
            }
        }
    }
    let mut counts = vec![n + 1];
    counts.extend(
        unique
            .iter()
            .map(|m| m.values().map(|&amp;u| u as T).sum::&lt;T&gt;())
            .collect::&lt;Vec&lt;_&gt;&gt;(),
    );
    println!("{:?}", counts);
    process::exit(0); // Avoid running destructors.
}
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/174407/">174407</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




