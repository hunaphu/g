<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::174407</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td></td><td>230723T031316Z</td><td><a href="https://codegolf.stackexchange.com/questions/174407/count-arrays-that-make-unique-sets/263197#263197">138 Aspe</a></td></tr>
<tr d-ix="1"><td>nan</td><td></td><td>181025T053632Z</td><td><a href="https://codegolf.stackexchange.com/questions/174407/count-arrays-that-make-unique-sets/174678#174678">Οurous</a></td></tr>
<tr d-ix="2"><td>014</td><td>Common Lisp SBCL</td><td>181024T204741Z</td><td><a href="https://codegolf.stackexchange.com/questions/174407/count-arrays-that-make-unique-sets/174657#174657">JRowan</a></td></tr>
<tr d-ix="3"><td>024</td><td>Rust</td><td>181021T135127Z</td><td><a href="https://codegolf.stackexchange.com/questions/174407/count-arrays-that-make-unique-sets/174414#174414">Anders K</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>C++</h1>
<p>C++ port of @Anders Kaseorg's Rust answer. <a href="https://tio.run/##hVdbb9pIFH7nV5xmpciugQBpmwYDUrdqtSv1odqy@5Jl0WAGPIkZU8@YkG3465s9Z2a4@JLUreKRz/07tyFar1tRwuTy6ekXIaMkn3MYzIRWF0rPoyBox6NGroRcgmQrrtYs4oCUsNFo6Ic1n/MF5ELqy95UwzhsKM20iCBKpdKQSyWWks/h19/H32AI7@E1KPEvTxfe2CcNjlvIREh@1JPxDc8Un5Ib3uHr1ocfDcDn4gLGsVCA/xlaWq1SCch6LxQHnYnoDnS610EE1TdiW/TA87ZwDp3tZ3w6@OQ@jEbQfefD44FG34mOtMGAaGGNOLHsxd/7UBC3VCv@vk66Y/9Z6TdFaUe00m9qpD@6x0r3CtKX7rHSvRrpD@5xgRek37rHBe6kM67zTMI2bOwoYVkeafiLRzrNfmMqdimhrGKK0jXPGFI837MVsDGMg/EIzvHou7qwMi6VH1B4tU44ZXImJBYEpjMm1Wy9zlIWxQdurLt@35mKMahOeCAt0gw8lmPiz7fQB2PsaMaZ@mgscFhk6Qpmaap0v0@WptY0byXijlfN0hPDP0NrnwQwIAwRCzJA2K755dXV9ez6avGGXUXdt39@@YLfvZhAfOfbo8nU0dvd4eTQjS1t19iFJZA/fXdxoL/JCwCfA2tC5dusCrmzyGA4hNmpWewzWDEhPTqwbBmhvphl8BrPm5vJHk@xQKCRCq@GVH1HxRHPMor57GvCGXYeorgROE34lkU6eYAUkUfVfMkzUp@vuNTtv@VZWHatu/eK/h5miLRfdfZwYlMCZYWGyDRiSg/23CNP6TRPPON6d@I77HcQMR3F4LXb7VrXPzORoC0sozWj6bH3E5ja@/5zlwkhSfB24PERXRyZ@VdrT8Iqx@zMcE5xfc85agIm53BGVDM1ietlk@blcp7LNJvzjM@nK7YeHAqhaaqnedK3zUN5YWnmUnzPuXcNLehhve47/9i8Kl8pTzah4yhjLJTtdMMSmiyn@GNftLq@mS2ecb8F0g@p97zuYCD9Vte6a9p1TEWITYyvwXCvMYQgYKdYjWmUI990OstFooWkteCm@2XPY2VjB0FTqAg@8pZnAfYEKsr5aUeeziSK9wZrZEL@AcdhAEJT5@FsOo4ckSQecbZnfIlt4zeNXJvLOZ07fmk6HSpZ2KgFDLCoQQRB2b0xbS1k6oaFz0Utt8ggQnwZLbdVLWZooJ7BgMY/I5hufRz0XT@s8JmAbxFAMYHHIYkVeXZ1QBX9UehPL8QXmrvGd9WhA2vC5VLTAMc2CehPizYR3g1Knh0EWJaxh284@FHGCV/Y9ggIpIJQsWqnyjsIF3NSMLBOVXGfFKgqFgtdpY8hSeu@xjbBjWry7ILa4IIi3@oShhoRf29DfW/M1iSLCtvVu/UMK6BOl9lbwuk7aRKrt0bxrloXRn@AQ7YUzt4PyzAaVkZcVUvLMoX1LCZXN5gH6rkkredCchDUk0wqYhE@h0IlT9WAd8UQKTzU@srNcdRBx7oYf@48zhTjOy5B3ISo@Z6D5HbT5LhnYlGL7gs2fwLH0SVqrskz2LwYvy3WHBcJStsVcUPaepOwymfmFfG2FwLnnzVfKjGKCPleOUYzJ@tCE7o1Uhxn9Bx1LliieGkYAcdvNYJGrZCKZ9r7YV1o4oUh5zv/@XFWXaI4OqI0l1pZIXtur3O8KM5YdFdeeNKsTD882WwWuhX2ucWtuM/QM7c76y@wdzQgVmVkCL27TdsC80wVGrUBLQ6qOLO3KHwXAl1iui/iUB@u1esX7huo/mtGF8U012adcjKQLvamBN0w/8C7jb1Tn@E2nZxRkCum96hqc7m5cVcbA4C73J9sSOcOETy/si33WizXjZgU17@g1JSVVC8DzpMmnIWVwihwTMxF7PRnUccgjVfdiCvV7/Ot0B72K4ZPwTd2T09PV/9Fi4Qt1VMLfz8M8Sd19@p/" rel="nofollow noreferrer">Try it online!</a></p>
<p><a href="https://clang.llvm.org/docs/LanguageExtensions.html#id37" rel="nofollow noreferrer">Use <code>__builtin_bitreverse32</code> from clang</a>, or you can implement one.</p>
<p><a href="https://tio.run/##nVbBcpswEL37K9Y5eCBxFNs9tBXGnfbUHnqqpxePhyFYTpQB4SJBkwZ/u7srsBtioJ3qkGGkp7fv7a61yXJtDodcC9Bmw/lzlMaxiIxMleb8c6jvv4a7MQhVjCERyRh2WRoJrffeYGCedgKW4EP@ZuYNIrxh4NOX5TdOG7iNeM61/CWCdMv5fLlwXAi1PbyEd0iwVZCEUuH28wBwxcJAmN1pvIsBOadvx2W1JKT4LqJ5sEAez@JDrUVmhg7hWCyIyPdhVp8SmzpqIchquma7MNMCOXP1Mwt3r4kULGBytjf3ra0XtEluIFfyRy6Q2pkx5r93WYJ8ZVBCnTTOlfjpuD3yj0w6T8hyIaLhakIZWnqgbKYoeesKvE0zCEEqqBAYcjiBxQIckgbXoI5JpCW3iEXZIctEIdBxcCsNprLzwjFCQRFGJ1FNAK3LApVOvMb@/oxGWqGMqRaGo2tUhFRT7wxABA9EINsJaNHlORkkRw8wauOhRS5WzgPale6fjELpE8P5lf1ffGmSZcvdY4xiBljQVkGNIjvYXFeAf65h6uJvQrtwY1sNd6cv9DKpTBrcpo9iE@hYRuLYQW3hd6k@L1FD373cmn5InPaf38v2c8rRqOqhjv6xLCkVoMACVlraS4c9XHdqJXgOXc1ACxVZzhcNbq@57eT79m6xga580J2SKsiiehF69FS46wrndcNsr6ywZmvMaJx2I6msV35Xn9dp9TEPXl@OWqvWnpDzHbSPMYbIAWVJbPbzefD/xvpNYbz@IOeBuuz/i73qQV/p0@8Oe2i2bqVjQpnsyaliu@2QUG2CJN3I7ZNT5iVc5ihvG8ZadODTLJCKRo5jsly4XU9s9bVvDJAozZU5jRB6U6b11KhOmHg0Qm2cQdNqIwKTRmROU1s10pISElaEcS5oGNutERrK7SPmMkxCPdxfXW6Ze2OLqL3tMnzWYjV0Lp75h/3FuBZ7OrX/Z3AuHqVxcCjDzQ18LFK5gSxXSqo72AiNqYpMmmk22B8Oh7e/AQ" rel="nofollow noreferrer">ref Rust code</a></p>
<pre class="lang-cpp prettyprint-override"><code>#include &lt;bits/stdc++.h&gt;
using namespace std;


typedef uint32_t T;
static const unsigned BITS = 8 * sizeof(T);


static inline uint32_t reverse_bits(uint32_t x) {
    // This is a common bitwise trick to reverse bits:
    x = ((x &amp; 0xFFFF0000u) &gt;&gt; 16) | ((x &amp; 0x0000FFFFu) &lt;&lt; 16);
    x = ((x &amp; 0xFF00FF00u) &gt;&gt; 8)  | ((x &amp; 0x00FF00FFu) &lt;&lt; 8);
    x = ((x &amp; 0xF0F0F0F0u) &gt;&gt; 4)  | ((x &amp; 0x0F0F0F0Fu) &lt;&lt; 4);
    x = ((x &amp; 0xCCCCCCCCu) &gt;&gt; 2)  | ((x &amp; 0x33333333u) &lt;&lt; 2);
    x = ((x &amp; 0xAAAAAAAAu) &gt;&gt; 1)  | ((x &amp; 0x55555555u) &lt;&lt; 1);
    return x;
}

struct VectorHash {
    size_t operator()(const vector&lt;T&gt; &amp;vec) const {
        // A simple combination hash approach
        std::size_t h = 0;
        for (auto &amp;x : vec) {
            // Combine from boost::hash_combine-like approach
            h ^= std::hash&lt;T&gt;()(x) + 0x9e3779b97f4a7c15ULL + (h &lt;&lt; 6) + (h &gt;&gt; 2);
        }
        return h;
    }
};

struct VectorEq {
    bool operator()(const vector&lt;T&gt;&amp; a, const vector&lt;T&gt;&amp; b) const {
        return a == b;
    }
};

int main(int argc, char *argv[]) {
    if (argc != 2) {
        cerr &lt;&lt; &quot;Please provide exactly one integer argument.\n&quot;;
        return 1;
    }
    unsigned n;
    try {
        n = static_cast&lt;unsigned&gt;(stoul(argv[1]));
    } catch (...) {
        cerr &lt;&lt; &quot;Failed to parse argument as integer.\n&quot;;
        return 1;
    }
    if (n == 0 || n &gt; BITS) {
        cerr &lt;&lt; &quot;n must be between 1 and &quot; &lt;&lt; BITS &lt;&lt; &quot;.\n&quot;;
        return 1;
    }

    vector&lt;unordered_map&lt;vector&lt;T&gt;, bool, VectorHash, VectorEq&gt;&gt; unique(9 - 2 + 1);
    vector&lt;T&gt; sums(n, 0);
    T max_val = (static_cast&lt;T&gt;(-1)) &gt;&gt; (BITS - n); // (1&lt;&lt;n)-1

    for (T a = 0; a &lt;= max_val; ++a) {
        T rev = __builtin_bitreverse32(a) &gt;&gt; (BITS - n);
        if (a &gt; rev) {
            continue;
        }

        // sums[...] = 0 each iteration
        fill(sums.begin(), sums.end(), 0);
        for (unsigned i = 0; i &lt; n; i++) {
            T bit = 1;
            for (unsigned j = i; j &lt; n; j++) {
                bit &lt;&lt;= ((a &gt;&gt; j) &amp; 1);
                sums[j - i] |= bit;
            }
        }

        for (unsigned s = 2; s &lt;= 9; s++) {
            unsigned length = (n + (n - 1) * s);
            unsigned arraySize = length / BITS + 1;

            vector&lt;T&gt; sums_s(arraySize, 0);
            unsigned pos = 0;
            unsigned shift = 0;
            T lo = 0;
            T hi = 0;

            for (auto &amp;v : sums) {
                lo |= (v &lt;&lt; shift);
                if (BITS - shift &lt; n) {
                    hi |= (v &gt;&gt; (BITS - shift));
                }
                shift += s;

                if (shift &gt;= BITS) {
                    shift -= BITS;
                    sums_s[pos] = lo;
                    pos++;
                    lo = hi;
                    hi = 0;
                }
            }

            if (lo != 0 || hi != 0) {
                sums_s[pos] = lo;
                // pos++ only if we need to use hi
                if (hi != 0) {
                    pos++;
                    sums_s[pos - 1] = hi;
                }
            }

            auto &amp;umap = unique[s - 2];
            auto it = umap.find(sums_s);
            if (it != umap.end()) {
                it-&gt;second = false;
            } else {
                umap.insert({sums_s, true});
            }
        }
    }

    vector&lt;T&gt; counts;
    counts.push_back(static_cast&lt;T&gt;(n + 1));

    for (auto &amp;m : unique) {
        T sum_val = 0;
        for (auto &amp;kv : m) {
            if (kv.second) {
                sum_val += 1; // each true counts as 1
            }
        }
        counts.push_back(sum_val);
    }

    // Print out contents of counts in a Rust-like &quot;[..]&quot; format
    cout &lt;&lt; &quot;[&quot;;
    for (size_t i = 0; i &lt; counts.size(); i++) {
        cout &lt;&lt; counts[i];
        if (i + 1 &lt; counts.size()) {
            cout &lt;&lt; &quot;, &quot;;
        }
    }
    cout &lt;&lt; &quot;]\n&quot;;

    return 0; // process::exit(0) in Rust
}
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/Ourous/curated-clean-linux" rel="nofollow noreferrer">Clean</a></h1>

<p>Certainly not the most efficient approach, but I'm interested in seeing how well a naive by-value filter does.</p>

<p>That said, there's still a bit of improvement to be made using this method.</p>

<pre><code>module main
import StdEnv, Data.List, System.CommandLine

f l = sort (nub [sum t \\ i &lt;- inits l, t &lt;- tails i])

Start w
&#9;# ([_:args], w) = getCommandLine w
&#9;= case map toInt args of
&#9;&#9;[n] = map (flip countUniques n) [1..9]
&#9;&#9;_ = abort "Wrong number of arguments!"

countUniques 1 n = inc n
countUniques s n = length uniques
where
&#9;lists = [[s + ((i &gt;&gt; p) bitand 1) \\ p &lt;- [0..dec n]] \\ i &lt;- [0..2^n-1]]
&#9;pairs = sortBy (\(a,_) (b,_) = a &lt; b) (zip (map f lists, lists))
&#9;groups = map (snd o unzip) (groupBy (\(a,_) (b,_) = a == b) pairs)
&#9;uniques = filter (\section = case section of [a, b] = a == reverse b; [_] = True; _ = False) groups
</code></pre>

<p>Place in a file named <code>main.icl</code>, or change the top line to <code>module &lt;your_file_name_here&gt;</code>.</p>

<p>Compile with <code>clm -h 1500m -s 50m -fusion -t -IL Dynamics -IL StdEnv -IL Platform main</code>.</p>

<p>You can get the version TIO (and myself) use from the link in the heading, or a more recent one from <a href="https://clean.cs.ru.nl/Download_Clean" rel="nofollow noreferrer">here</a>.</p>
</div>
<div id="pu2" class="pu"><p><strong>Common Lisp SBCL, N = 14</strong></p>

<p>call function (goahead n s)</p>

<pre><code>    (defun sub-lists(l m &amp;optional(x 0)(y 0))
  (cond; ((and(= y (length l))(= x (length l)))nil)
        ((= y (length l))m)
        ((= x (length l))(sub-lists l m 0(1+ y)))
    (t (sub-lists l (cons(loop for a from x to (+ x y)

             when (and(nth (+ x y)l)(nth a l)(&lt; (+ x y)(length l)))
                ;   while (nth a l)
             ;while(and(&lt; (+ x y)(length l))(nth a l))
                    collect (nth a l))m) (1+ x)y))
    ))
(defun permutations(size elements)
  (if (zerop size)'(())
 (mapcan (lambda (p)
                    (map 'list (lambda (e)
                           (cons e p))
                         elements))
     (permutations (1- size) elements))))
(defun remove-reverse(l m)
  (cond ((endp l)m)
    ((member (reverse (first l))(rest l) :test #'equal)(remove-reverse (rest l)m))
    (t (remove-reverse (rest l)(cons (first l)m)))))
(defun main(n s)
  (let((l (remove-reverse (permutations n `(,s ,(1+ s)))nil)))

  (loop for x in l
     for j = (remove 'nil (sub-lists x nil))
       collect(sort (make-set(loop for y in j
        collect (apply '+ y))nil)#'&lt;)
     )
  ))
(defun remove-dups(l m n)
  (cond ((endp l)n)
        ((member (first l) (rest l) :test #'equal)(remove-dups(rest l)(cons (first l) m) n))
    ((member (first l) m :test #'equal)(remove-dups(rest l)m n))
    (t(remove-dups (rest l) m (cons (first l) n))))

  )
(defun goahead(n s)
  (loop for a from 1 to s
  collect(length (remove-dups(main n a)nil nil))))
(defun make-set (L m)
  "Returns a set from a list. Duplicate elements are removed."
  (cond ((endp L) m)
    ((member (first L) (rest L)) (make-set (rest L)m))
    ( t (make-set (rest L)(cons (first l)m)))))
</code></pre>

<p>here is the run times</p>

<pre><code>CL-USER&gt; (time (goahead 14 9))
Evaluation took:
  34.342 seconds of real time
  34.295000 seconds of total run time (34.103012 user, 0.191988 system)
  [ Run times consist of 0.263 seconds GC time, and 34.032 seconds non-GC time. ]
  99.86% CPU
  103,024,254,028 processor cycles
  1,473,099,744 bytes consed

(15 1047 4893 6864 7270 7324 7328 7328 7328)
CL-USER&gt; (time (goahead 15 9))
Evaluation took:
  138.639 seconds of real time
  138.511089 seconds of total run time (137.923824 user, 0.587265 system)
  [ Run times consist of 0.630 seconds GC time, and 137.882 seconds non-GC time. ]
  99.91% CPU
  415,915,271,830 processor cycles
  3,453,394,576 bytes consed

(16 1502 8848 13336 14418 14578 14594 14594 14594)
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.rust-lang.org/" rel="noreferrer">Rust</a>, n ≈ 24</h1>

<p>Requires nightly Rust for the convenient <code>reverse_bits</code> feature.  Compile with <code>rustc -O unique.rs</code> and run with (e.g.) <code>./unique 24</code>.</p>



<pre class="lang-rust prettyprint-override"><code>#![feature(reverse_bits)]
use std::{collections::HashMap, env, mem, process};

type T = u32;
const BITS: u32 = mem::size_of::&lt;T&gt;() as u32 * 8;

fn main() {
    let args = env::args().collect::&lt;Vec&lt;_&gt;&gt;();
    assert!(args.len() == 2);
    let n: u32 = args[1].parse().unwrap();
    assert!(n &gt; 0);
    assert!(n &lt;= BITS);
    let mut unique = (2..=9).map(|_| HashMap::new()).collect::&lt;Vec&lt;_&gt;&gt;();
    let mut sums = vec![0 as T; n as usize];
    for a in 0 as T..=!0 &gt;&gt; (BITS - n) {
        if a &lt;= a.reverse_bits() &gt;&gt; (BITS - n) {
            for v in &amp;mut sums {
                *v = 0;
            }
            for i in 0..n {
                let mut bit = 1;
                for j in i..n {
                    bit &lt;&lt;= a &gt;&gt; j &amp; 1;
                    sums[(j - i) as usize] |= bit;
                }
            }
            for s in 2..=9 {
                let mut sums_s =
                    vec![0 as T; ((n + (n - 1) * s) / BITS + 1) as usize].into_boxed_slice();
                let mut pos = 0;
                let mut shift = 0;
                let mut lo = 0;
                let mut hi = 0;
                for &amp;v in &amp;sums {
                    lo |= v &lt;&lt; shift;
                    if BITS - shift &lt; n {
                        hi |= v &gt;&gt; (BITS - shift);
                    }
                    shift += s;
                    if shift &gt;= BITS {
                        shift -= BITS;
                        sums_s[pos] = lo;
                        pos += 1;
                        lo = hi;
                        hi = 0;
                    }
                }
                if lo != 0 || hi != 0 {
                    sums_s[pos] = lo;
                    pos += 1;
                    if hi != 0 {
                        sums_s[pos] = hi;
                    }
                }
                unique[s as usize - 2]
                    .entry(sums_s)
                    .and_modify(|u| *u = false)
                    .or_insert(true);
            }
        }
    }
    let mut counts = vec![n + 1];
    counts.extend(
        unique
            .iter()
            .map(|m| m.values().map(|&amp;u| u as T).sum::&lt;T&gt;())
            .collect::&lt;Vec&lt;_&gt;&gt;(),
    );
    println!("{:?}", counts);
    process::exit(0); // Avoid running destructors.
}
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/174407/">174407</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




