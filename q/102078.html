<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::QNNN</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
  <!-- TXXX -->
<tr d-ix="0"><td>417</td><td>Python3</td><td>241019T145637Z</td><td><a href="https://codegolf.stackexchange.com/questions/102078/help-me-untangle-these-wires/276202#276202">Ajax1234</a></td></tr>
<tr d-ix="1"><td>173</td><td>Befunge</td><td>161206T231342Z</td><td><a href="https://codegolf.stackexchange.com/questions/102078/help-me-untangle-these-wires/102392#102392">James Ho</a></td></tr>
<tr d-ix="2"><td>178</td><td>JavaScript ES6</td><td>161204T190920Z</td><td><a href="https://codegolf.stackexchange.com/questions/102078/help-me-untangle-these-wires/102122#102122">Neil</a></td></tr>
<tr d-ix="3"><td>241</td><td>Python 2</td><td>161205T105825Z</td><td><a href="https://codegolf.stackexchange.com/questions/102078/help-me-untangle-these-wires/102175#102175">TFeld</a></td></tr>
<tr d-ix="4"><td>025</td><td>Pyth</td><td>161204T054309Z</td><td><a href="https://codegolf.stackexchange.com/questions/102078/help-me-untangle-these-wires/102079#102079">Maltysen</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Python3, 417 bytes</h1>
<pre class="lang-py prettyprint-override"><code>from itertools import*
E=enumerate
def f(w):
 C=0
 D={i:(C:=C+1)if'|'==a else 0 for i,a in E(w[0])}
 B=[[*i]for i in zip(*w[::-1])]
 for I,j in E(B):
  for a,b in groupby(E(j),key=lambda x:x[1].lower()):
   if'x'==a:
    u=[*b];v=sum([-1,1][t=='X']for _,t in u)
    for A,_ in u:B[I][A]=' '
    if v:B[I][u[-1][0]]=v
 return'\n'.join(f'{D[i-1]} {D[i+1]} '+['L','R'][a==1]for j in zip(*B) for i,a in E(j)if a in[1,-1])
</code></pre>
<p><a href="https://tio.run/##jVLLbtswEDyXX7HwhaQsG1LsAIEKHmLHhwBFDz0FYAlDhqmUriwKFOVHk3y7Q1KNH0FRGDosOTszu1puvbe/dDW6q83hUBi9BmWlsVqXDah1rY2N0IzJql1Lk1uJlrKAgmxphmDKEgQP7EVlZJqxaT@lqsCvmLEcZNlISKDQBlScg6pgRrY8EfQNwYRxHikRcj7zR9Uk2vIsG6SCChREj/GqE018oQDl8cJDz0a39WJPZmRF499yz8p8vVjmsMt2PBXDUm@lITSowLWz8@2EC7SMRwvxdcOadk34II1TwS1j@AmHXuax9f4tDWSP3MfzgGQT/ij4vWAYcEiqAjYd2Dof4f5LsA0CI21rKvyzwsOVVhUp8MsDV47wBv7Q9wfc5/gbjvEPLHjOWBpKr45jmNDLma3cSMGfeRr78RyaBBj0ej30CuFD8AQh@hvswMWAHPOe26SXopPAUb2oM3GngIfocwE/L3BhenNuij6qdj10Am9xjgTZ6EPWXccnFxRKdu38Nx69bj@LPwvOyH5xrZ4vdG6WpHEL8qV7L7jcxkKVbv/Jd13JGJphU5fKEv@m1O0mqo2qLCnIySihlP6F8QBH44T@g5ReQ7q5hjS6hjS@hnTrSId3" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1>Befunge, 173 bytes</h1>

<p>Input is read from stdin in the exact format given in the challenge description, although it's crucial that every line be the correct length and the final line must include a newline (i.e. not just EOF at the end of that line). </p>

<pre><code>$1&gt;&gt;05p~$~:55+-#v_
$_^#`"N":+1g50$&lt;&gt;:2+3%1-05g6g+0v&gt;!#:v#
vg50-1*2p51:-1_^#:&lt;*2!!-*84p6g5&lt;
 +#,.#$"R"\#\-#+5&lt;^g51$_:0`6*\25g\v@_:#!.#:1#,
&gt;+::25p6g\48*\6p48 *-:!^!:--1*2`0:&lt;
</code></pre>

<p><a href="http://befunge.tryitonline.net/#code=JDE-PjA1cH4kfjo1NSstI3ZfCiRfXiNgIk4iOisxZzUwJDw-OjIrMyUxLTA1ZzZnKzB2PiEjOnYjCnZnNTAtMSoycDUxOi0xX14jOjwqMiEhLSo4NHA2ZzU8CiArIywuIyQiUiJcI1wtIys1PF5nNTEkXzowYDYqXDI1Z1x2QF86IyEuIzoxIywKPis6OjI1cDZnXDQ4Klw2cDQ4ICotOiFeITotLTEqMmAwOjw&amp;input=fCB8IHwKIFggIHwKfCAgeCAKfCB8IHwKfCAgWCAKfCAgeCAKfCB8IHwK" rel="nofollow noreferrer">Try it online!</a></p>

<p>The basic idea for this solution is that we have an "array" keeping track of the twist counts for each wire. So every time we encounter a twist in one direction we increment the count for the associated wire, while a twist in the other direction will decrement the count.</p>

<p>At the same time as we process the twist for a particular wire, we also look at the twist count for the wires to the left and right of it. If either of them are non-zero, we need to "flush" those twists onto the stack, since it will no longer be possible for them to be unravelled by later twists in the opposite direction.</p>

<p>After the last line of input, the input stream returns EOF repeatedly, and these EOF characters are interpreted as twists in every wire, at least for the purposes of flushing. This forces the program to flush any outstanding counts in the array, but it will not generate any new twist counts.</p>

<p>Once we've finished processing the input, all the commands for untangling the wires will now be on the stack. This means we can simply pop them off in reverse order to output the instructions needed to untangle the wires from the bottom up.</p>
</div>
<div id="pu2" class="pu"><h2>JavaScript (ES6), 178 bytes</h2>

<pre><code>f=([t,...a],r=[])=&gt;a[0]?t.replace(/x/gi,(c,i)=&gt;(c=c&lt;'x'?'R':'L',i=++i/2,r.reduce((f,[j,,d],n)=&gt;f||i&lt;j+2&amp;&amp;j&lt;i+2&amp;&amp;(j-i|c==d||r.splice(n,1)&amp;&amp;2),0)&lt;2?r=[[i,i+1,c],...r]:r))&amp;&amp;f(a,r):r
</code></pre>

<p>Takes input as an array of strings representing lines and returns an array of arrays of values e.g. <code>[[2, 3, "R"], [3, 4, "L"], [1, 2, "R"]]</code>. The reverse ordering helps with the eliminations.</p>
</div>
<div id="pu3" class="pu"><h2>Python 2, <s>244</s> 241 bytes</h2>

<pre class="lang-python prettyprint-override"><code>m=[]
for l in input():
 for i in range(len(l)):
  c=l[i];a=i/2+1;L,R=[a,a+1,'LR'[c&gt;'v']],[a,a+1,'RL'[c&gt;'v']];x=m.index(L)if L in m else-1;M=zip(*m[:x+1])
  if c in'xX':
   if x&gt;=0and(a in M[1]or a+1in M[0])&lt;1:del m[x]
   else:m=[R]+m
print m
</code></pre>

<p>Takes input as list of strings</p>

<p><strong>Example:</strong></p>

<p>Input: <code>['| | | |', ' X  | |', '| |  x ', '|  X  |', ' x  | |']</code></p>

<p>Output: <code>[[1, 2, 'L'], [2, 3, 'R'], [3, 4, 'L'], [1, 2, 'R']]</code></p>

<p>Edit:
Fixed for case:</p>

<p>Input: <code>['| | |', ' X  |', ' X  |', ' x  |', '|  X', ' X  |', ' x  |', ' x  |', '| | |']</code></p>

<p>Output: <code>[[1, 2, 'L'], [2, 3, 'R'], [1, 2, 'R']]</code></p>
</div>
<div id="pu4" class="pu"><h1>Pyth - <s>26</s> 25 bytes</h1>
<p>Very straightforward, maybe I can golf the filtering.</p>
<pre><code>fhhT_m+hB/xrdZ\x2@&quot;RL&quot;}\x
</code></pre>
<p><a href="http://pyth.herokuapp.com/?code=fhhT_m%2BhB%2FxrdZ%5Cx2%40%22RL%22%7D%5Cx&amp;input=%5B%27%7C+%7C+%7C+%7C%27%2C+%27+X++%7C+%7C%27%2C+%27%7C+%7C++x+%27%2C+%27%7C++X++%7C%27%2C+%27%7C+%7C+%7C+%7C%27%5D&amp;debug=0" rel="noreferrer">Try it online here</a>.</p>
</div>
