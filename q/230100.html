<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::230100</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td>You can save bytes for some fractional exponents using the fraction characters</td><td>241024T005217Z</td><td><a href="https://codegolf.stackexchange.com/questions/230100/tips-for-code-golfing-in-desmos/276297#276297">Lucenapo</a></td></tr>
<tr d-ix="1"><td>nan</td><td>This is mainly a \$\LaTeX\$ trick that can save some bytes. This tip can likely apply to other languages that use \$\LaTeX\$.</td><td>210620T201021Z</td><td><a href="https://codegolf.stackexchange.com/questions/230100/tips-for-code-golfing-in-desmos/230104#230104">Aiden Ch</a></td></tr>
<tr d-ix="2"><td>nan</td><td></td><td>220720T121407Z</td><td><a href="https://codegolf.stackexchange.com/questions/230100/tips-for-code-golfing-in-desmos/250125#250125">fad</a></td></tr>
<tr d-ix="3"><td>nan</td><td></td><td>211101T163428Z</td><td><a href="https://codegolf.stackexchange.com/questions/230100/tips-for-code-golfing-in-desmos/236800#236800">thejonym</a></td></tr>
<tr d-ix="4"><td>nan</td><td></td><td>220308T052837Z</td><td><a href="https://codegolf.stackexchange.com/questions/230100/tips-for-code-golfing-in-desmos/243834#243834">Aiden Ch</a></td></tr>
<tr d-ix="5"><td>nan</td><td></td><td>220223T041733Z</td><td><a href="https://codegolf.stackexchange.com/questions/230100/tips-for-code-golfing-in-desmos/243270#243270">Aiden Ch</a></td></tr>
<tr d-ix="6"><td>nan</td><td></td><td>220219T082844Z</td><td><a href="https://codegolf.stackexchange.com/questions/230100/tips-for-code-golfing-in-desmos/243072#243072">Aiden Ch</a></td></tr>
<tr d-ix="7"><td>nan</td><td></td><td>220205T011848Z</td><td><a href="https://codegolf.stackexchange.com/questions/230100/tips-for-code-golfing-in-desmos/242377#242377">Aiden Ch</a></td></tr>
<tr d-ix="8"><td>nan</td><td></td><td>211222T062546Z</td><td><a href="https://codegolf.stackexchange.com/questions/230100/tips-for-code-golfing-in-desmos/240021#240021">Aiden Ch</a></td></tr>
<tr d-ix="9"><td>209</td><td>When constructing a list with ...</td><td>210629T231038Z</td><td><a href="https://codegolf.stackexchange.com/questions/230100/tips-for-code-golfing-in-desmos/230734#230734">Aiden Ch</a></td></tr>
<tr d-ix="10"><td>nan</td><td></td><td>210620T195730Z</td><td><a href="https://codegolf.stackexchange.com/questions/230100/tips-for-code-golfing-in-desmos/230101#230101">Aiden Ch</a></td></tr>
<tr d-ix="11"><td>nan</td><td></td><td>210621T062508Z</td><td><a href="https://codegolf.stackexchange.com/questions/230100/tips-for-code-golfing-in-desmos/230143#230143">fireflam</a></td></tr>
<tr d-ix="12"><td>nan</td><td>You can use function parameters to assign variable values outside of that function</td><td>210620T205059Z</td><td><a href="https://codegolf.stackexchange.com/questions/230100/tips-for-code-golfing-in-desmos/230106#230106">Aiden Ch</a></td></tr>
<tr d-ix="13"><td>nan</td><td></td><td>210620T201917Z</td><td><a href="https://codegolf.stackexchange.com/questions/230100/tips-for-code-golfing-in-desmos/230105#230105">user</a></td></tr>
<tr d-ix="14"><td>nan</td><td>For functions that use \operatorname{function name}</td><td>210620T200209Z</td><td><a href="https://codegolf.stackexchange.com/questions/230100/tips-for-code-golfing-in-desmos/230103#230103">Aiden Ch</a></td></tr>
<tr d-ix="15"><td>nan</td><td></td><td>210620T200030Z</td><td><a href="https://codegolf.stackexchange.com/questions/230100/tips-for-code-golfing-in-desmos/230102#230102">emanresu</a></td></tr>
</table>
<div id="pu0" class="pu"><p>You can save bytes for some fractional exponents using the fraction characters:</p>
<p><code>5^½</code> is <a href="https://tio.run/##K6gsycjPM/7/3zTu0N7//wE" rel="nofollow noreferrer">4 bytes</a> whch is better than <code>5^{.5}</code> which is <a href="https://tio.run/##K6gsycjPM/7/3zSuWs@09v9/AA" rel="nofollow noreferrer">6 bytes</a>.</p>
<p>They give the same number in Desmos.</p>
<p>This also works for fractions <code>¼</code> and <code>¾</code>.</p>
</div>
<div id="pu1" class="pu"><p>(This is mainly a <span class="math-container">\$\LaTeX\$</span> trick that can save some bytes. This tip can likely apply to other languages that use <span class="math-container">\$\LaTeX\$</span>.)</p>
<p>When dealing with exponents(e.g. <code>x^{2}</code>) or other operators that require the usage of brackets(e.g. <code>\sqrt{5}</code>), you can take out the brackets that are automatically there if there is only one digit/character in the exponent. So, <code>x^{2}</code> can be written as <code>x^2</code>. Likewise, <code>\sqrt{5}</code> can be shortened to <code>\sqrt5</code>.</p>
<p>Note that you cannot take out these brackets if there is more than one digit. For example, <code>x^{10}</code> is not the same as <code>x^10</code>.</p>
<hr />
<p>This exponent trick can even work in summations, where it uses the same notation when indicating the stopping value.</p>
<p>For example, instead of writing...</p>
<pre><code>\sum_{k=0}^{n}k^{3}
</code></pre>

<p>...it can be written as:</p>
<pre><code>\sum_{k=0}^nk^3
</code></pre>
<hr />
<p>Because if this trick, it is better if you can find a way to maximize the amount of one digit exponential terms in your code, to eliminate the brackets.</p>
<p>For example, it is actually more byte efficient to write <code>a^xa^y</code> (6 bytes) instead of <code>a^{x+y}</code> (7 bytes).</p>
</div>
<div id="pu2" class="pu"><h1>Regressions</h1>
<p>A regression can be used to solve an equation and can be shorter than explicitly typing out the expression for its solution.</p>
<p>For example, the golden ratio can be calculated in 6 bytes, <code>aa-a~1</code>, with the result being stored in <code>a</code>, which is shorter than the 11-byte equivalent <code>5^{.5}.5+.5</code>.</p>
</div>
<div id="pu3" class="pu"><h3>Change <code>\prod</code> to <code>∏</code> and <code>\sum</code> to <code>∑</code></h3>
<p><code>\prod</code> can be replaced with <code>∏</code>, saving 2 bytes, and <code>\sum</code> with <code>∑</code> to save 1 byte. Important to note that these are not capital pi <code>Π</code> or capital sigma <code>Σ</code>, but their own distinct characters.</p>
<p>Similarly, <code>\to</code> can be replaced with <code>→</code>, but this loses a byte to <code>-&gt;</code>. in either case (<code>→</code> or <code>-&gt;</code>), you can omit the next <code>\</code> from a function.</p>
<p>Example: <code>x\to\join(x,y)</code> =&gt; <code>x-&gt;join(x,y)</code> saves 2 bytes.</p>
<p>(special thanks to <a href="https://codegolf.stackexchange.com/users/96039/aiden-chow">@Aiden Chow</a> for the correction about <code>-&gt;</code>)</p>
</div>
<div id="pu4" class="pu"><h1>Removing <code>\left</code>'s and <code>\right</code>'s from piecewise expressions</h1>
<p>(A clarification of this <a href="https://codegolf.stackexchange.com/a/230101/96039">tip</a> that's been edited to oblivion)</p>
<p>When using a piecewise expression, you may have noticed that if you took out the <code>\left</code> and <code>\right</code> from a piecewise expression, it doesn't work. So, for example, the following doesn't work when directly pasted into Desmos:</p>
<pre><code>\{x&lt;0:x,x^3\}
</code></pre>
<p>But if you include the <code>\left</code> and <code>\right</code>, it does work:</p>
<pre><code>\left\{x&lt;0:x,x^3\right\}
</code></pre>
<p>To fix this issue, you can add a newline in front of the expression that includes the piecewise. In our case, the code to paste into Desmos is:</p>
<pre><code>
\{x&lt;0:x,x^3\}
</code></pre>
<p>Even though the actual expression doesn't render properly, the graph of the piecewise expression should still show. Note that the piecewise expression will be fragile, which means that while you have selected the expression, most button presses (including buttons like <kbd>Ctrl</kbd>) will break the code.</p>
<hr />
<p>The downside of doing this trick is that every built-in function with the expression that includes the piecewise is not recognized by the Desmos parser. That means that you have to add a <code>\</code> in front of every built-in function to force Desmos to recognize it as a built-in function, adding one byte per built-in. For example, the following code won't work:</p>
<pre><code>
f(l)=min(\{l=0:l.max,l\})
</code></pre>
<p>But the following code does work:</p>
<pre><code>
f(l)=\min(\{l=0:l.\max,l\})
</code></pre>
<p>As a result, if you use too many built-in functions in the same expression as a piecewise expression, you should consider another approach that doesn't involve any piecewise expressions.</p>
<p>For example, consider the following code (it doesn't do anything useful, but it has a whole bunch of built-in functions):</p>
<p>(64 bytes)</p>
<pre><code>
f(l)=\{\sort([1...l.\max+1],\join(l,2,3,l.\mean))=l.\median,0\}
</code></pre>
<p>It can be shortened by doing the following:</p>
<p>(60 bytes)</p>
<pre><code>f(l)=0^{(sort([1...l.max+1],join(l,2,3,l.mean))-l.median)^2}
</code></pre>
<hr />
<p>Overall, code in the form:</p>
<pre><code>
\{a=b,0\}
</code></pre>
<p>which includes <span class="math-container">\$k\$</span> built-in functions, can be shortened to:</p>
<pre><code>0^{(a-b)^2}
</code></pre>
<p>given that <span class="math-container">\$k\ge2\$</span>. It will save <span class="math-container">\$k-1\$</span> bytes.</p>
<p>Similarly, code in the form:</p>
<pre><code>
\{a=b:0,1\}
</code></pre>
<p>which includes <span class="math-container">\$k\$</span> built-in functions, can be shortened to:</p>
<pre><code>1-0^{(a-b)^2}
</code></pre>
<p>given that <span class="math-container">\$k\ge2\$</span>. It will save <span class="math-container">\$k-1\$</span> bytes.</p>
<p>These are just two common examples. Techniques will vary based on what you are trying to do.</p>
<hr />
<p>Because of this, code that includes piecewise expressions usually will have to be pasted in one expression at a time. This is because if you paste the entire code at once, expressions that don't have a piecewise expression in them will still have to include <code>\</code>'s in front of every built-in function in order to work. If you instead paste in the expressions that include piecewise expressions separately, you can avoid this issue.</p>
<p>For example, consider the following code:</p>
<pre><code>L=l.length
f(l)=\{\sort([1...L],l)&lt;L/2,0\}
</code></pre>
<p>If you paste this entire code into Desmos all at once, it will not work, because it expects a <code>\</code> in front of <code>length</code>.</p>
<p>But if you first paste in:</p>
<pre><code>L=l.length
</code></pre>
<p>Then paste in:</p>
<pre><code>
f(l)=\{\sort([1...L],l)&lt;L/2,0\}
</code></pre>
<p>The code will work.</p>
</div>
<div id="pu5" class="pu"><h1>Counting the number of digits of a number</h1>
<p>The number of digits of a non-negative integer <code>n</code> is:</p>
<p>(19 bytes)</p>
<pre><code>floor(log(n+0^n))+1
</code></pre>
<p>This works because when Desmos calculates a number to the power of zero, it will automatically convert the entire exponential term to 1. We use this to our advantage with <code>0^n</code>, which returns 1 for <code>n=0</code> (because any number to the power of 0 is calculated as 1, even though the base is 0), and returns 0 for any positive integer.</p>
<p>If <code>n</code> is guaranteed to be a positive integer (<code>n</code> can't be zero), then the formula becomes:</p>
<p>(13 bytes)</p>
<pre><code>floor(logn)+1
</code></pre>
<p>If you need to find the number of digits of any integer <code>n</code>, then the formula is:</p>
<p>(28 bytes)</p>
<pre><code>k=abs(n)
floor(log(k+0^k))+1
</code></pre>
<p><sup>^ (Could probably be shorter but I can't see it at the moment)</sup></p>
</div>
<div id="pu6" class="pu"><h1>Use the dot calls of built-in functions</h1>
<p>For most list built-ins that don't require any arguments, they can be called using dot calls instead.</p>
<p>Let's say that the built-in function is called <code>f</code>, and the list is <code>L</code>. You can then use a dot call to use the function like <code>L.f</code> (3 bytes) instead of <code>f(L)</code> (4 bytes), which saves 1 byte. For example, instead of using <code>mean(L)</code>, you can instead use <code>L.mean</code> for -1 bytes.</p>
<p>Here is some <a href="https://www.desmos.com/calculator/9pgqulab1u" rel="nofollow noreferrer">examples</a> of dot calls being used on a list, and you can find a full list of the built-in functions that allow for dot calls <a href="https://www.desmos.com/calculator/rlr1sstwye" rel="nofollow noreferrer">here</a> (Find the folder that is named &quot;Functions that allow dot call&quot;). Note that the full list does put parentheses <code>()</code> after the dot call (like <code>L.mean()</code>), but that can be taken out (<code>L.mean</code> works).</p>
</div>
<div id="pu7" class="pu"><p>Here's a cool piecewise trick.</p>
<p>When writing piecewise expressions in the form <code>\{(condition):1,n\}</code> for some value <code>n</code>, you can actually replace them with <code>\{(condition),n\}</code>, saving 2 bytes. I'm not aware of the full details on why this works, but the premise is that with any piecewise in the form <code>\{(condition)\}</code>, like <code>\{x&gt;0\}</code>, if the <code>(condition)</code> is true, then it will return 1, otherwise, it will return <code>undefined</code> (if you are wondering why these values, it is because piecewise expressions are also used in domain/range restrictions). Notice how there is no <code>true</code> or <code>false</code> output in these type of piecewise experssions. This is because 1 and <code>undefined</code> are the &quot;default&quot; values when the <code>true</code> and/or <code>false</code> output is omitted. When writing <code>\{(condition),n\}</code>, you are omitting the <code>true</code> output, which means that it will default to 1, so it is essentially the same as <code>\{(condition):1,n\}</code>.</p>
</div>
<div id="pu8" class="pu"><h3>List comprehension tips</h3>
<p>If you are unaware, a new feature has been released in Desmos a few months ago: <a href="https://twitter.com/Desmos/status/1451211022115561476" rel="nofollow noreferrer">list comprehensions</a></p>
<p>They are similar to Python list comprehensions, where you can essentially use loops to construct lists. This functionality now allows us to be able to emulate nested for loops in Desmos, which was previously much harder to do.</p>
<p>List comprehensions follow the below form:</p>
<pre><code>[(expression in terms of var1, ... ,varN) for var1 = (list1), var2 = (list2), ... , varN = (listN)]
</code></pre>
<p>This will construct a list by looping through each <code>var1, var2, ... , varN</code> in a nested fashion.</p>
<p>There are some golfs you can do to save bytes in list comprehensions.</p>
<p>Let's take a simple list comprehension below:</p>
<pre><code>\left[\left(a,b\right)\operatorname{for}a=\left[1...10\right],b=\left[1...10\right]\right]
</code></pre>
<p>Like any other function, you can simply take out the <code>\operatorname</code> from the <code>for</code> and it will still work. So all in all, you have something like this:</p>
<pre><code>[(a,b)fora=[1...10],b=[1...10]]
</code></pre>
<p>Even though the <code>for</code> and <code>a</code> are together, Desmos will still be able to distinguish between them.</p>
<hr />
<p>A quirk with list comprehensions (and nested for loops in general) is that you will actually get different lists based on the order of each list. Here's an example to illustrate my point (obviously not golfed completely for readability):</p>
<pre><code>[a+b for a = [1,2,3], b = [2,4,6]] --&gt; [3,4,5,5,6,7,7,8,9]
[a+b for a = [2,4,6], b = [1,2,3]] --&gt; [3,5,7,4,6,8,5,7,9]
</code></pre>
<p>(<a href="https://www.desmos.com/calculator/er964mmn4n" rel="nofollow noreferrer">Graph</a>)</p>
<p>Generally, a list comprehension is generated following the pseudocode below (using the general list comprehension form that I mentioned earlier):</p>
<pre><code>SET result to empty list

FOR each varN in (listN)
    .
     .
      .
    FOR each var2 in (list2)
        FOR each var1 in (list1)
            ADD (expression in terms of var1, ... , varN) to the end of result
        END FOR
    END FOR
      .
     .
    .
END FOR

PRINT result
</code></pre>
<p>A certain ordering of the lists can potentially save a few bytes over another if a code golf challenge requires the list output to be ordered in a certain way.</p>
</div>
<div id="pu9" class="pu"><p>When constructing a list with <code>...</code>, commas can usually be eliminated. For example, one might write <code>[0,...,9]</code> if they did not know about this, but you can actually save 2 bytes by writing <code>[0...9]</code> instead.</p>
<p>In cases where you want to specify the second element(to set your own common difference), the comma is only required between the first and second element. For example, instead of <code>[0,2,...,50]</code>, you can write <code>[0,2...50]</code> instead.</p>
<p>Basically, you can replace <code>,...,</code> with <code>...</code> to save 2 bytes.</p>
</div>
<div id="pu10" class="pu"><h3>Edit #2:</h3>
<p>(Referring to the example in the first edit)</p>
<p>Apparently you can add a <code>\</code> at the beginning of the function to make it work(see <a href="https://codegolf.stackexchange.com/questions/230100/tips-for-code-golfing-in-desmos#comment528244_230101">this comment</a>), which I did not know as well. I guess that invalidates this tip, again.</p>
<h3>Edit:</h3>
<p>In <a href="https://codegolf.stackexchange.com/questions/230100/tips-for-code-golfing-in-desmos/230101#comment528123_230101">fireflame241's comment</a>, he brought to my attention that it is not required to have the <code>\left</code> and <code>\right</code> accompanying the bracket pairs. This is true for most cases. But after some testing, there are some cases where taking out the <code>\left</code> and <code>\right</code> does break the code. Specifically, if you are using any function(e.g. <code>total</code> or <code>max</code>) in addition to these brackets, the function will not work(see example below).</p>
<p>Example:</p>
<p>Suppose you want to compare the corresponding elements of two lists, <code>a</code> and <code>b</code>, and see how many of those corresponding elements are the same. That is, something like <code>a=[1,2,3,4]</code> and <code>b=[2,2,3,5]</code> will output <code>2</code>(the second and third elements of each list are the same).</p>
<p>Here's what someone might do, after learning that you can take out the <code>\left</code> and <code>\right</code>:</p>
<pre><code>total(\{a=b:1,0\})
</code></pre>
<p>In theory, this should work perfectly fine, but in reality, Desmos gives an error and it doesn't work. I'm pretty sure it's because it considers <code>l</code> to be a function, and <code>t</code>, <code>o</code>, and <code>a</code> to be variables in this situation. <code>l</code>, <code>o</code>, and <code>t</code> are not defined, so it gives an error saying so.</p>
<p>In cases like this, it would be better to do:</p>
<pre><code>total(1-sign(a-b)^2)
</code></pre>
<p>as suggested by the tip below.</p>
<hr />
<p>First tip to start it off.</p>
<p>When doing comparisons in your code, most of the times, it is better to try not to use brackets <code>{ }</code> in your code, because they always require a <code>\left</code> and a <code>\right</code> to go with them, which increases byte count unnecessarily. Instead, we can utilize the <code>sign</code> function.</p>
<p>Consider a naive implementation that returns <code>0</code> if <code>a=b</code>, and returns <code>1</code> otherwise:
<br>(22 bytes)</p>
<pre><code>\left\{a=b:0,1\right\}
</code></pre>
<p>Instead of doing this, we can save 9 bytes by doing a little math instead:
<br>(11 bytes)</p>
<pre><code>sign(a-b)^2
</code></pre>
<p>This works because <code>sign(x)</code> returns <code>-1</code> if <code>x</code> is negative, <code>0</code> if <code>x=0</code>, and <code>1</code> otherwise. <code>a-b</code> is <code>0</code> only when <code>a=b</code>, so <code>sign(a-b)</code> would be <code>0</code> only when <code>a=b</code>. If <code>a</code> does not equal <code>b</code>, it returns either <code>-1</code> or <code>1</code>. The <code>^2</code> is just to convert the <code>-1</code> to a <code>1</code>.</p>
<p>Even if we wanted to return <code>1</code> if <code>a=b</code> and <code>0</code> otherwise, we can still save 9 bytes by doing <code>1-sign(a-b)^2</code> instead of <code>\left\{a=b:1,0\right\}</code>.</p>
</div>
<div id="pu11" class="pu"><h2>Parentheses are not always required for trig functions</h2>
<p>For example, <code>tan35.6x=0</code> is valid and treated as <code>tan(35.6x)=0</code>.</p>
<p>Similarly, <code>tan^23x</code> is treated as <code>tan^{2}(3x)</code>.</p>
</div>
<div id="pu12" class="pu"><p>You can use function parameters to assign variable values outside of that function, even though it throws an error. Using this, we can save bytes when we repeat expressions inside of functions.</p>
<p>For example, look at this code:</p>
<p>(45 bytes)</p>
<pre><code>f(a)=sort(a)[1]+sort(a)[length(a)]-sort(a)[2]
</code></pre>
<p>There is a lot of <code>sort(a)</code>'s in that code, maybe we can shorten it?</p>
<p>Here is what many people might try to do to shorten this:</p>
<p>(49 bytes)</p>
<pre><code>b(a)=sort(a)
f(a)=b(a)[1]+b(a)[length(a)]-b(a)[2]
</code></pre>
<p>It seems like making a function just for <code>sort(a)</code> should have helped, but in reality this is actually 4 bytes longer than the initial code.</p>
<p>What can we do then? Well, the following code will do it:</p>
<p>(37 bytes)</p>
<pre><code>b=sort(a)
f(a)=b[1]+b[length(a)]-b[2]
</code></pre>
<p><code>b</code> is using a function parameter <code>a</code> in declaring it, and Desmos is throwing an error because it seemingly doesn't understand this, but at the end, it still works somehow, so it is valid.</p>
</div>
<div id="pu13" class="pu"><h1>Logical negation</h1>
<p>If you want to swap numbers that represent falsy and truthy values, you can use <code>0^x</code>, where <code>x</code> is the value that needs to be logically negated. To make it work for negative numbers, you can use the absolute value (<code>0^{abs(x)}</code>), suggested by Aiden Chow.</p>
</div>
<div id="pu14" class="pu"><p>For functions that use <code>\operatorname{(function name)}</code>, you can simply take out the entire <code>\operatorname</code> part and use the <code>(function name)</code>. For example, instead of <code>\operatorname{total}</code>, you can simply write <code>total</code>.</p>
</div>
<div id="pu15" class="pu"><h1>You can use /</h1>
<p>Pasting in <code>x/5</code> or <code>8/3</code> will give the same result as typing it, just not properly formatted - so in some cases, you don't need the bulky <code>\frac{x}{y}</code>.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/230100/">230100</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




