<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::81165</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>354</td><td>C GCC</td><td>230725T154610Z</td><td><a href="https://codegolf.stackexchange.com/questions/81165/jam-dont-add-like-that/263325#263325">matteo_c</a></td></tr>
<tr d-ix="1"><td>147</td><td>Ruby</td><td>160604T070223Z</td><td><a href="https://codegolf.stackexchange.com/questions/81165/jam-dont-add-like-that/81245#81245">Value In</a></td></tr>
<tr d-ix="2"><td>496</td><td>Scala 3</td><td>230730T062340Z</td><td><a href="https://codegolf.stackexchange.com/questions/81165/jam-dont-add-like-that/263522#263522">138 Aspe</a></td></tr>
<tr d-ix="3"><td>022</td><td>Jelly</td><td>210318T001039Z</td><td><a href="https://codegolf.stackexchange.com/questions/81165/jam-dont-add-like-that/220832#220832">caird co</a></td></tr>
<tr d-ix="4"><td>044</td><td>APL</td><td>160603T183827Z</td><td><a href="https://codegolf.stackexchange.com/questions/81165/jam-dont-add-like-that/81201#81201">marinus</a></td></tr>
<tr d-ix="5"><td>113</td><td>Julia</td><td>160605T040046Z</td><td><a href="https://codegolf.stackexchange.com/questions/81165/jam-dont-add-like-that/82291#82291">Dennis</a></td></tr>
<tr d-ix="6"><td>181</td><td>Python 2.7</td><td>160603T014004Z</td><td><a href="https://codegolf.stackexchange.com/questions/81165/jam-dont-add-like-that/81166#81166">Blue</a></td></tr>
<tr d-ix="7"><td>746</td><td>Java</td><td>160606T025440Z</td><td><a href="https://codegolf.stackexchange.com/questions/81165/jam-dont-add-like-that/82331#82331">Value In</a></td></tr>
<tr d-ix="8"><td>136</td><td>Python 2</td><td>160605T010729Z</td><td><a href="https://codegolf.stackexchange.com/questions/81165/jam-dont-add-like-that/81292#81292">Dennis</a></td></tr>
<tr d-ix="9"><td>042</td><td>Pyth</td><td>160605T215112Z</td><td><a href="https://codegolf.stackexchange.com/questions/81165/jam-dont-add-like-that/82326#82326">isaacg</a></td></tr>
<tr d-ix="10"><td>152</td><td>JavaScript ES6</td><td>160603T124502Z</td><td><a href="https://codegolf.stackexchange.com/questions/81165/jam-dont-add-like-that/81180#81180">Neil</a></td></tr>
<tr d-ix="11"><td>150</td><td>Haskell</td><td>160603T160544Z</td><td><a href="https://codegolf.stackexchange.com/questions/81165/jam-dont-add-like-that/81194#81194">Lynn</a></td></tr>
<tr d-ix="12"><td>122</td><td>Mathematica</td><td>160603T132116Z</td><td><a href="https://codegolf.stackexchange.com/questions/81165/jam-dont-add-like-that/81184#81184">Martin E</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://gcc.gnu.org" rel="nofollow noreferrer">C (GCC)</a>, <s>377</s> 354 bytes</h1>
<p><em>-23 bytes thanks to <a href="https://codegolf.stackexchange.com/users/52904/ceilingcat">@ceilingcat</a></em></p>
<pre class="lang-c prettyprint-override"><code>d(w,r,i,x)S w;{for(r=i=0;w.v&amp;&amp;i&lt;w.n;r=x&gt;r?x:r)x=d(w.v[i++]);return!!w.v+r;}s(S*z,S x,S y){int e=d(x),f=d(y);if(e-f){S X=e&lt;f?x:y,Y=e&lt;f?y:x;for(z-&gt;v=calloc(e=z-&gt;n=Y.n,16);e--;)s(z-&gt;v+e,X,Y.v[e]);}else if(e+f){z-&gt;v=malloc(x.n+y.n&lt;&lt;4);for(e=0;e&lt;x.n|e&lt;y.n;++e)e&gt;=x.n|e&gt;=y.n?z-&gt;v[e]=(e&lt;x.n?x:y).v[e],0:s(z-&gt;v+e,x.v[e],y.v[e]);z-&gt;n=e;}else z-&gt;n=x.n+y.n,z-&gt;v=0;}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=jVVLktpIEI1ZOeAU2US4rUICS9DTMUEh-gLesXEHJiZ6UMlWDC0ISdAqejjJbHrjQ80cwydwZlZJSBh_FiBVfl6-fJVV-vfz6s-Pq9XLf16htypSMeRFtlsVMH_udpK0gFR2O5UJ-nvZPcJcft4V8eCP_3_7K3KevMxLvFLM4Uk-x5vMycIk9OXTcH99nUyfhqnMwnKW3ZWTTJQhxg_3i8R1l0Jmqthl6dUVWtxMHnNn3j94cyjxp8Uz1VYYXwovxocWMokdNYjF8xzeh2oaI6L27vlNT0pJpQ-D2T5cPazXm5WjQlyl4f0w9YJbIdVgIEXOEa7y3nv3SEMhiaNa5woI2kVoBng0AOUwdfUwnU5vBIMr7EpN0fqPmqJduq4SahayYRai5Y6yETR0OIz4Ca7i-ZO6cmks2pZnjsqy4IUt6zEVXx6t1K--oPq5YUbS5MlBCcA9IjOEYEmTGfrs3cTOXAjaPUTCCB9fjeSQ4y52u_tNEkGapEnhEIgHvN0MiikppqSt7Cpl_4splm0qOJUitxn-O6tNmvMw5YJmLAbHJGAR0e1UHDk2dnqvo54HBI4wZiIz28x2V6w-PWTOm8UbahP3CFgaGj9IppQjwXUTptfJwA0tAa4n0CFb9thJ4CrkWjCAAO4AK_dgAr0eRR4bFZdc0TJFBBi1e1yn511a3oZALpr0P6TnaEGNFqlt8ekXFSNNOMfq8xNBeOso1tQgRCsJGdEzQ6Q7eplAZPq3haKaIs9DvnukaTh4UPMsG--ayzGxsq6GpxoiXS811aW-KATZw_U1u6lBJmvGFEuUtDsuaDMQVe9Mr4kQUdVOx7b5Dgtx4izkTGyLlxNeEczbtzzK628DtQksbeC-IvKOy7O8Vm8jOCnNENhCMtW15ujvkFJ8DyTcCD_1SfdW_imrb3ME1uk75YV4_YP4Bn5Lq9NebWkbSpiS4igMqSIbft32axID_bUQemv34nze2NEYuFb3W5NoqR3rYXp8SFIHpxzPh70A7MeHrrQJvI4-pHQfNO63Lm0eTdYi8GAx8mC8xOfNcin5cixPN1Egat44oGNambliTX0PmgFkQsDRKcrahA3-jiewyA2YkUVuBo8qmBu-C-ylUdYLbJyPBrK3PVcHp2qZTs9isQiIik8tj-n_Bpe_08utv-T-9cX-teVvV00uxmRtl5ptuaqAwP9hBCnpX0YP2uq0XBX6uIneCBhRw5ddY9Lh5NK21K3f1Fv_VG9t9Kb77UxIHmecZBzkJuShjh-dJzgH5Et3Y7-dMeKUisbmbyzP30zz6X95Mc-v" rel="nofollow noreferrer">Attempt This Online!</a>
(footer contains main, non-golfed functions, and other useful functions)</p>
<p>Assumes that ragged arrays are represented with the following struct:</p>
<pre class="lang-c prettyprint-override"><code>typedef struct S{
    int n;
    struct S *v;
} S;
</code></pre>
<p>where</p>
<ul>
<li>if <code>x</code> is an integer, <code>x.n</code> is its value, and <code>x.v</code> is set to <code>NULL</code>;</li>
<li>if <code>x</code> is a ragged array, <code>x.n</code> is its length, and <code>x.v</code> is the array containing the sub-elements.</li>
</ul>
<p>Possible improvement: write a function that computes the sum in-place instead of allocating a new ragged array.</p>
<hr />
<p>Thanks to <a href="https://codegolf.stackexchange.com/users/103854/zoomlogo">@zoomlogo</a> for pointing to this old interesting challenge in this <a href="https://codegolf.meta.stackexchange.com/a/24189/73593">bounty</a></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, <s>143</s> <s>145</s> <s>148</s> <s>149</s> 147 bytes</h1>
<p>Ruby has all these little quirks in how <code>zip</code> works with different-length arrays and <code>map</code> with multi-argument functions, making this pretty fun to golf down.</p>
<p>The function has to be explicitly declared as a <code>proc</code> because <code>-&gt;</code> declares a <code>lambda</code>, which has strict argument checking that won't splat arguments passed in through <code>Array#map</code>.</p>
<pre class="lang-ruby prettyprint-override"><code>d=-&gt;a{-~(a.map(&amp;d).max||0)rescue 0}
f=proc{|x,y|d[x]&lt;d[y]?y.map{f[x,_1]}:d[x]&gt;d[y]?x.map{f[_1,y]}:d[x]&lt;1?x+(y||0):[*x.zip(y).map(&amp;f),*y[x.size..]]}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=fZJBToNAFIajS07xFsZAO9AZdGGa0l7AG7xMSC2DklQl0CpTwEu4dNOFHkpP4xsK0WIrC8jkff__vUl4e8_WN3q7_VivYvfq8zUK3Om8dF_suXc_T-3zyKFvUVXcyVS-WCvgtRUHafa4KKuC6SrCQk4i1HKmTaCMsWChkPXYDKbNoGgHoWC6HUzErBja2tSOcVB4myS1tbMzxg4baCy8PNkoz5Oyble7fr5Llgpu1Sq3gNRMQQBnoZeny2Rlj3AYyFFTUaqn-RJCUVuQEWI20tKCFDIGWRAoSz1Eu87t1-kJhyFwOP4EwC10BQPOwBWSaKR3n0HeARY2DO8ze3BL_eMlqqs62tRCKMl9nCTIECgJpWv4DC4MLA7ICRWECGLExT6O4u-NWrxB-jAJfS7lHvy73My7xE-4WfNAQWtC35cd1WSQQmjOl1L2g52QPNLo0JhNgzkIE_Kb1O5X-AY" rel="nofollow noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.scala-lang.org/" rel="nofollow noreferrer">Scala 3</a>, 496 bytes</h1>
<p>Port of <a href="https://codegolf.stackexchange.com/a/81245/110802">@Value Ink's Ruby anwer</a> in Scala.</p>
<hr />
<p>Golfed version. <a href="https://ato.pxeger.com/run?1=fVJBTsMwEBTXvMJHr5pGLXBAEY7EgQMSqBKIU1VFTuK0htSExCC7VV6ChHqBGw-CV_AENnFaCQT44HHWM7OTTZ5e65QX_GDzdpfciFSTCy4VWb886Hx49LH3-cgLkoUnyrLoTGm2TnktSBFeiftpPGPReFAES17SDBDMpNTyTgVzoSfVaVELOoKOH7No1HiZyElOTWvm23aHzpdm1ICfUQuw5DpdrL1WQ7mfgMwJP05YZANen6lac5WKST51zWddYzT0Y4Dvmgg15j9N7Nte02ZDC_uttwnxXTEj7oBOA7stOxe8cQe89HBAXV9G0WERLKWiJqjlSvi2A_BdnZsfdWilZMVMoPktZodgJUtqt0_QRaU5iSHQD2UhMvBWgwGVee_DWAJOeynnC02TIQeBQyeYjQI4qt1R7d_U3SBM07gP__5M2q-1xH-B8mpeh-SkqridXulKqvkMQnKtpCaMrD2Cq8SqLhQO9lzWmo590uF-jwc9HgKu_jwebUmjtvqbzRB9kDXeSRyv8RrPpdxsHH4B" rel="nofollow noreferrer">Attmept this online!</a></p>
<p>496 bytes, it can be golfed much more.</p>
<pre class="lang-scala prettyprint-override"><code>val d:Any=&gt;Int={case l:Seq[_]=&gt;1+l.map(d).maxOption.getOrElse(0)case _=&gt;0}
def f(x:Any,y:Any):Any=(d(x),d(y))match{
case(a,b)if a&lt;b=&gt;y.asInstanceOf[Seq[_]].map(f(x,_))
case(a,b)if a&gt;b=&gt;x.asInstanceOf[Seq[_]].map(f(_,y))
case _=&gt;(x,y)match{
case(x:Int,y:Int)=&gt;x+y
case(x:Seq[_],y:Seq[_])=&gt;
val(a,b)=(math.min(x.size,y.size),math.max(x.size,y.size))
val z=x.take(a).zip(y.take(a)).map((f _).tupled)
z++(if(x.size==b)x.takeRight(b-a)else Seq())++(if(y.size==b)y.takeRight(b-a)else Seq())
case _=&gt;x}}
</code></pre>
<p>Ungolfed version. <a href="https://ato.pxeger.com/run?1=lVRNi9swEL30lF8xRw1JTNLtoSxNoIcWAltSWgpdQgiqLSdqba2xlSJtyS_pZS_tj-qv6Uge7zpZNrA5ZOTRmzdPTx-__zapLOTF3d2fvc3Hr_-9eH_z7btKLXyQ2sCvAcBPWUCmKru7hLfGw2wOC2NhFucAUtkocJdwpRu72qzD9BSG4JJSViKWIQ3dsrL6xiRbZZf1u6JRYoIP5ZtQNaHvw4D-MpVDvjdpKBAuNh2BjxFZArTMwuGolSY8IpTSpru-LJE5mvcIOofMwRsah04-kc3CNFaaVC3zFStfR8WqUKUKy5v3NIyA04hPks-Z3D2TnHO0Qjx1JDT2x8vqepMti1gUI8bG5Lo_BXH7CORxADOs3dtSmytlyFRqtEvoS7ik0beKimLEY7R0fbR0Z9G3uvoo63BaXGLlDyXaZpjQhPBHKYwWic4Y2GBi91WhsmPGWpV0MLXZBt6vRKxzVgCzGatD7vZJb3dWsOIxLxRpM8md4IY4Q33dUvtH1P651J0Hw-Gp-NPMdX_74hFwMXPoX42AF7LeNnQX6lr61WdbU_2a7sYXox8uZkVZW5h7Q0WUNR218l5yvOD4CunH4-mkA01C9gzbmOgIPL2vbOGHwWHQPif8qnSvy38" rel="nofollow noreferrer">Attmpt this online!</a></p>
<pre class="lang-scala prettyprint-override"><code>object Main {
  val depth: Any =&gt; Int = {
    case x: List[_] =&gt; 1 + x.map(depth).maxOption.getOrElse(0)
    case _ =&gt; 0
  }

  def function(x: Any, y: Any): Any = (depth(x), depth(y)) match {
    case (dx, dy) if dx &lt; dy =&gt; y.asInstanceOf[List[_]].map(element =&gt; function(x, element))
    case (dx, dy) if dx &gt; dy =&gt; x.asInstanceOf[List[_]].map(element =&gt; function(element, y))
    case _ =&gt; (x, y) match {
      case (x: Int, y: Int) =&gt; x + y
      case (x: List[_], y: List[_]) =&gt;
        val minLen = math.min(x.size, y.size)
        val maxLen = math.max(x.size, y.size)
        val zipPart = x.take(minLen).zip(y.take(minLen)).map((function _).tupled)
        val remainingPartX = if(x.size == maxLen) x.takeRight(maxLen - minLen) else List()
        val remainingPartY = if(y.size == maxLen) y.takeRight(maxLen - minLen) else List()
        zipPart ++ remainingPartX ++ remainingPartY
      case _ =&gt; x
    }
  }

  def main(args: Array[String]): Unit = {
    println(function(List(1, List(2, List(3, List(4)))), List(10, List(20))))
    println(function(List(-1, 0, 1), List(1)))
  }
}
</code></pre>
</div>
<div id="pu3" class="pu"><h1 id="jelly-24-22-bytes-mnzo"><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, <s>24</s> 22 bytes</h1>
<pre><code>ß&quot;+ŒḊ?çⱮç€&lt;/ɼ?,ŒḊ€©Eɗ?
</code></pre>
<p><a href="https://tio.run/##y0rNyan8///wfCXto5Me7uiyP7z80cZ1QKJpjY3@yT32OmBRIO/QSteT0@3///8fbaijEG2ko2AcC6RNYmP/R0dHGxroKBgZgASMQaQJkGsKYpgZxAIA" rel="nofollow noreferrer">Try it online!</a> or <a href="https://tio.run/##fZKxTsMwEIb3PIUFLKiuYjupl1Jl6sQTIMsjC@oLsDIyspSNsaqEkLoViYmIoY8BL2L@O8dJIE0zXGzf9/93ufjudrW6D/Uu1C9nk6@n7/1jVW9@dm8ID69X@eGjknyK3ed2eVhXYZLLepOL@fJCIPP@jMzlNcJNCC5zTkvhjBSFx7v0FHGmpDCK1gXFEtsZLawi4FwsGILSaIZafekb0lnytUhYzlhY@8zBiLLjD3krdDWFHPCU/bUfaLgHlRgIiFN@3DsKGvJkD0wmyxOOHZgsx@g4sAjEiTcD00cbYZymq4Hp4q8E/@ZIlVbC1H8B/WGo@rLYUq8IMUnUM2g@amjSVnTG@AR218kV8ToNxF1h1IvXjTogF0ZJZ1iY@V8" rel="nofollow noreferrer" title="Jelly – Try It Online">see all test cases</a></p>
<p>This technically violates</p>
<blockquote>
<p>To prevent boring and unbeatable solutions, if a language has this exact operation as a built-in, you may not use that language.</p>
</blockquote>
<p>However, this is by no means a boring or unbeatable solution. The only time <code>+</code> is used here is to add two flat integers. The rest of it is recursion to get to that point.</p>
<p>This is a full program which takes the two lists are arguments, and outputs the result.</p>
<h2 id="how-it-works-c4uu">How it works</h2>
<pre><code>ß&quot;+ŒḊ?çⱮç€&lt;/ɼ?,ŒḊ€©Eɗ? - Main link f(A, B). Takes A on the left and B on the right
                     ? - If:
                    ɗ  -   Condition:
              ,        -     [A, B]
               ŒḊ€     -     Depth of each
                  ©    -     (Save in register, R)
                   E   -     Both depths are equal?
                           Then:
     ?                 -     If:
   ŒḊ                  -       Condition: depth of A is non-zero
ß&quot;                     -       Then: Run f(A, B) on each subarray in A, B
  +                    -       Else: Return A+B
                           Else:
             ?         -     If:
          &lt;/ɼ          -       Condition: depth of A is less than that of B
      çⱮ               -       Then: Over each element b of B, yield f(A, b)
        ç€             -       Else: Over each element a of A, yield f(a, B)
</code></pre>
<p>We (ab)use <code>ç</code> in order to get <code>Ɱ</code> to work, as <code>ßⱮ</code> will error due to a bug in setting the arity of <code>ß</code> during execution. <code>ç</code> technically calls the link above explicitly as a dyad, but in a full program with only one link, this wraps around to call the same link.</p>
</div>
<div id="pu4" class="pu"><h1>APL, 44 <a href="https://codegolf.meta.stackexchange.com/a/9429/43319">bytes</a></h1>

<pre><code>{1=≡⍺⍵:⍺+⍵⋄=/∆←|≡¨⍺⍵:⊃∇¨/↓↑⍺⍵⋄&lt;/∆:⍺∘∇¨⍵⋄⍵∇⍺}
</code></pre>

<p>APL's <code>+</code> distributes over arrays as well, but in a different enough manner that this can't really be used. However, there is a built-in depth function (<code>≡</code>).</p>

<p>Explanation:</p>

<ul>
<li><code>1=≡⍺⍵:⍺+⍵</code>: if the depths of <code>⍺</code> <code>⍵</code> are both zero (and therefore the depth of <code>⍺ ⍵</code> is 1), add them.</li>
<li><code>∆←|≡¨⍺⍵</code>: take the absolute of the depth of both <code>⍺</code> and <code>⍵</code> and store them in <code>∆</code>. (<code>≡</code> gives a negative value if not all elements have the same depth.)</li>
<li><code>=/∆</code>: if they have the same depth:

<ul>
<li><code>↓↑⍺⍵</code>: pad the shortest array with zeroes to match the longer array</li>
<li><code>⊃∇¨/</code>: distribute the function over both arrays</li>
</ul></li>
<li><code>&lt;/∆</code>: if the depth of <code>⍺</code> is less than that of <code>⍵</code>:

<ul>
<li><code>⍺∘∇¨⍵</code>: bind <code>⍺</code> and then map over <code>⍵</code></li>
</ul></li>
<li><code>⍵∇⍺</code>: if nothing else (so <code>⍵</code> is deeper than <code>⍺</code>), swap the arguments and try again.</li>
</ul>
</div>
<div id="pu5" class="pu"><h1>Julia, 113 bytes</h1>



<pre class="lang-julia prettyprint-override"><code>~=endof;!t=0t!=0&amp;&amp;1+maximum(!,[t;0])
x::Array+y::Array=(!x,~x)&gt;(!y,~y)?y+x:!x&lt;!y?map(t-&gt;x+t,y):~x&lt;~y?[x;0]+y:x.+y
</code></pre>

<p><a href="http://julia.tryitonline.net/#code=fj1lbmRvZjshdD0wdCE9MCYmMSttYXhpbXVtKCEsW3Q7MF0pCng6OkFycmF5K3k6OkFycmF5PSgheCx-eCk-KCF5LH55KT95K3g6IXg8IXk_bWFwKHQtPngrdCx5KTp-eDx-eT9beDswXSt5OnguK3kKCmZvciByZXN1bHQgaW4gKAogICAgMCArIDAsCiAgICBBbnlbLTEsIDAsIC0xXSArIEFueVsxXSwKICAgIEFueVtdICsgQW55WzBdLAogICAgQW55W10gKyAwLAogICAgQW55W10gKyBBbnlbXSwKICAgIEFueVtBbnlbXSwgMF0gKyBBbnlbXSwKICAgIEFueVsxLCAyLCAzXSArIDEwLAogICAgQW55WzEsIDIsIDNdICsgQW55WzEwXSwKICAgIEFueVsxLCAyLCAzXSArIEFueVsxMCwgQW55WzIwXV0sCiAgICBBbnlbMSwgMiwgMywgQW55W11dICsgQW55WzEwLCBBbnlbMjBdXSwKICAgIEFueVsxLCBBbnlbMiwgQW55WzMsIEFueVs0XV1dXSArIEFueVsxMCwgQW55WzIwXV0KKQogICAgcHJpbnRsbihyZXN1bHQpCmVuZA&amp;input=" rel="nofollow">Try it online!</a></p>

<h3>How it works</h3>

<pre class="lang-julia prettyprint-override"><code>~=endof
</code></pre>

<p>creates a 1-byte alias for <strong>endof</strong>, which returns the length of an array.</p>

<pre class="lang-julia prettyprint-override"><code>!t=0t!=0&amp;&amp;1+maximum(!,[t;0])
</code></pre>

<p>defines a depth function. The depth of <strong>t</strong> is zero if and only if <strong>0t == 0</strong>. If not, <strong>t</strong> is an array, and its depth is calculated as the incremented maximum of the depths of its elements and <strong>0</strong>. <code>[t;0]</code> appends a <strong>0</strong> to the array <strong>t</strong>, thus avoiding the need to special-case the empty array.</p>

<p>Julia's built-in sum <strong>+</strong> already behaves like Jelly's sum if either (or both) of its arguments is an integer. However, the sum of two arrays (<strong>+</strong>) requires arrays of the same shape, and even the vectorized sum (<strong>.+</strong>) required arrays that can be broadcast to a common shape.</p>

<p>We redefine <strong>+</strong> for a pair of arrays via</p>

<pre class="lang-julia prettyprint-override"><code>x::Array+y::Array=(!x,~x)&gt;(!y,~y)?y+x:!x&lt;!y?map(t-&gt;x+t,y):~x&lt;~y?[x;0]+y:x.+y
</code></pre>

<p>This does not affect the definition of <strong>+</strong> for integer/integer, array/integer or integer/array arguments.</p>

<p><code>(!x,~x)&gt;(!y,~y)</code> lexicographically compares the pairs of depths and lengths of both <strong>x</strong> and <strong>y</strong>. If <strong>x</strong>'s depth exceeds <strong>y</strong>'s, or if their depth match and <strong>x</strong>'s length exceeds <strong>y</strong>'s, <code>y+x</code> recursively calls <strong>+</strong> with swapped arguments.</p>

<p>Otherwise, <code>!x&lt;!y</code> tests if <strong>x</strong>'s depth is lower than <strong>y</strong>'s. If it is, <code>map(t-&gt;x+t,y)</code> maps <strong>x + &middot;</strong> over <strong>y</strong>.</p>

<p>If the depths match, <code>~x&lt;~y</code> tests if <strong>x</strong> is shorter than <strong>y</strong>. If it is, <code>[x;0]+y</code> recursively calls <strong>+</strong> after appending a <strong>0</strong> to the left argument.</p>

<p>Finally, if both depths and lengths are identical, <code>x.+y</code> maps <strong>+</strong> over all elements of <strong>x</strong> and the corresponding elements of <strong>y</strong>.</p>
</div>
<div id="pu6" class="pu"><h1>Python 2.7, <s>261</s> <s>209</s> <s>202</s> <s>198</s> <s>191</s> <s>185</s> <s>197</s> 181 bytes</h1>
<p>FGITW trivial solution</p>
<p>EDIT: Of course @Dennis beats it</p>
<p>Thanks to @LeakyNun for saving 57 bytes with tips on lambda expressions, and 2 bytes from unneeded brackets.</p>
<p>Thanks to @Adnan for 4 bytes due to suggestion to use <code>type</code> instead of <code>isinstance</code></p>
<p>Thanks to @Lynn for 7 bytes with <code>-~</code> and <code>map</code></p>
<p>Thanks to @FryAmTheEggman for <code>z&gt;=[]</code> instead of <code>type</code></p>
<p>+12 bytes to convert lambda to if else and fix a major bug</p>
<p>-16 bytes thanks to @Kevin Lau - not Kenny</p>
<p><a href="https://repl.it/CYLV/1" rel="nofollow noreferrer">Try it online</a></p>
<pre><code>d=lambda z:z==[]or z&gt;[]and-~max(map(d,z))
p=lambda x,y:p(y,x)if d(x)&gt;d(y)else(x+y if d(x)&lt;1 else[p(a,b)for a,b in zip(x,y)]+x[len(y):]+y[len(x):])if d(x)==d(y)else[p(a,x)for a in y]
</code></pre>
</div>
<div id="pu7" class="pu"><h1>Java, <s>802</s> <s>794</s> <s>754</s> 746 bytes</h1>
<p>I decided to take up @Dennis♦ for the challenge to operate on strings &quot;as a last resort&quot; because it was probably &quot;too complicated&quot;. Also, in the worst language to golf on.</p>
<p>Arrays in the input are comma-separated, surrounded with square brackets, and without whitespace.</p>
<p><a href="https://repl.it/CYdx/5" rel="nofollow noreferrer">Full program with functions wrapped into a class and with test cases</a></p>
<pre><code>import java.util.*;
List&lt;String&gt;p(String s){List r=new ArrayList&lt;String&gt;();String p=&quot;&quot;;int l=0;for(char c:s.substring(1,s.length()-1).toCharArray()){l+=c=='['?1:c==']'?-1:0;if(c==','&amp;&amp;l&lt;1){r.add(p);p=&quot;&quot;;}else p+=c;}if(p!=&quot;&quot;)r.add(p);return r;}
int d(String s){int l=0;if(s.contains(&quot;[&quot;)){for(String c:p(s))l=d(c)&gt;l?d(c):l;l++;}return l;}
String f(String x,String y){int i=0;String r=&quot;&quot;;if(d(x)&lt;1&amp;&amp;d(y)&lt;1)r+=Integer.valueOf(x)+Integer.valueOf(y);else{r=&quot;[&quot;;if(d(x)&lt;d(y))for(String k:p(y))r+=(i++&lt;1?&quot;&quot;:&quot;,&quot;)+f(x,k);else if(d(x)&gt;d(y))for(String k:p(x))r+=(i++&lt;1?&quot;&quot;:&quot;,&quot;)+f(k,y);else for(;i&lt;p(x).size()||i&lt;p(y).size();i++)r+=(i&lt;1?&quot;&quot;:&quot;,&quot;)+(i&lt;p(x).size()&amp;&amp;i&lt;p(y).size()?f(p(x).get(i),p(y).get(i)):i&lt;p(x).size()?p(x).get(i):p(y).get(i));r+=&quot;]&quot;;}return r;}
</code></pre>
<p>I might port this to C++ later since it's the other language I know that doesn't support ragged arrays, since I'm <s>pretty sure</s> almost certain it'll be shorter than this answer. This was mostly a proof of concept but any golfing tips would still be appreciated!</p>
<p><em>-31 bytes from @user902383 suggesting using a foreach over a converted character array, and then I saved a little more from rearranging the if blocks in the final part.</em></p>
</div>
<div id="pu8" class="pu"><h1>Python 2, <s>145</s> 136 bytes</h1>



<pre class="lang-python prettyprint-override"><code>d=lambda t:t&gt;{}and-~max(map(d,t+[0]))
s=lambda x,y:s(y,x)if d(y)&lt;d(x)else map(s,(x,[x]*len(y))[d(x)&lt;d(y)],y)if d(y)else(x or 0)+(y or 0)
</code></pre>

<p>Test it on <a href="http://ideone.com/qynvcd" rel="nofollow">Ideone</a>.</p>

<h3>How it works</h3>

<p>In Python 2, all integers are less than all dictionaries, but all lists are greater. <strong>d</strong> recursively computes the depth of <strong>t</strong> by returning <strong>0</strong> for integers or the incremented maximum of the depths of its elements and <strong>0</strong>. <code>t+[0]</code> avoids special-casing the empty list.</p>

<p><strong>s</strong> recursively computes the Jelly sum of <strong>x</strong> and <strong>y</strong>.</p>

<p>If <strong>y</strong>'s depth exceeds <strong>x</strong>'s, <code>s(y,x)</code> calls <strong>s</strong> with swapped arguments, making sure that <strong>d(x) &leq; d(y)</strong>.</p>

<p>If <strong>y</strong> has positive depth, <code>map(s,(x,[x]*len(y))[d(x)&lt;d(y)],y)</code> does the following.</p>

<ul>
<li><p>If the <strong>x</strong>'s and <strong>y</strong>'s depths match, it executes <code>map(s,x,y)</code>, mapping <strong>s</strong> over all elements of <strong>x</strong> and the corresponding elements of <strong>y</strong>.</p>

<p>In the case of lists of different lengths, <strong>map</strong> will pass <strong>None</strong> as left or right argument for missing elements in the shorter list.</p></li>
<li><p>If <strong>x</strong>'s depth is lower than <strong>y</strong>'s, it executes <code>map(s,[x]*len(y),y)</code>, mapping <strong>s(x, &middot; )</strong> over <strong>y</strong>.</p></li>
</ul>

<p>If <strong>y</strong> (and, therefore, <strong>x</strong>) has depth <strong>0</strong>, <code>(x or 0)+(y or 0)</code> replaces falsy arguments (<strong>None</strong> or <strong>0</strong>) with zeroes and returns the sum of the resulting integers.</p>
</div>
<div id="pu9" class="pu"><h1>Pyth, 42 bytes</h1>

<pre><code>L?sIb0heSyM+b0M?qFyMJ,GH?yGgM.tJ0+GHgLFyDJ
</code></pre>

<p><a href="https://pyth.herokuapp.com/?code=L%3FsIb0heSyM%2Bb0M%3FqFyMJ%2CGH%3FyGgM.tJ0%2BGHgLFyDJgF.Q&amp;test_suite=1&amp;test_suite_input=0%0A0%0A%5B-1%2C+0%2C+-1%5D%0A%5B1%5D%0A%5B%5D%0A%5B0%5D%0A%5B%5D%0A0%0A%5B%5D%0A%5B%5D%0A%5B%5B%5D%2C+0%5D%0A%5B%5D%0A%5B1%2C+2%2C+3%5D%0A10%0A%5B1%2C+2%2C+3%5D%0A%5B10%5D%0A%5B1%2C+2%2C+3%5D%0A%5B10%2C+%5B20%5D%5D%0A%5B1%2C+2%2C+3%2C+%5B%5D%5D%0A%5B10%2C+%5B20%5D%5D%0A%5B1%2C+%5B2%2C+%5B3%2C+%5B4%5D%5D%5D%5D%0A%5B10%2C+%5B20%5D%5D%0A%5B1%2C+%5B2%2C+3%5D%2C+%5B4%5D%5D%0A%5B%5B%5B10%2C+20%5D%2C+%5B30%5D%2C+40%2C+50%5D%2C+60%5D&amp;debug=0&amp;input_size=2" rel="nofollow">Test suite</a></p>

<p>The last 4 bytes simply run the function on the input.</p>

<pre><code>L?sIb0heSyM+b0M?qFyMJ,GH?yGgM.tJ0+GHgLFyDJ

L?sIb0heSyM+b0
                  Define y(b), a helper function to calculate the depth.
 ?                Ternary:
  sIb             If b is invariant under the s function, which is only the case
                  if s is an int.
     0            The depth is 0.
           +b0    Add a 0 on to b. This handles the edge case where b is [].
         yM       Map each to their depth
       eS         Take the max.
      h           Add one.

M?qFyMJ,GH?yGgM.tJ0+GHgLFyDJ
M                               Define g(G, H), which calculates the Jelly +.
 ?                              Ternary:
       ,GH                      Form [G, H].
      J                         Save it to J.
    yM                          Map each to its depth.
  qF                            Check if they are equal.
          ?yG                   If so, check if the depth is nonzero.
               .tJ0             If so, transpose J, pairing each element of each
                                argument with the corresponding element of the
                                other. Pad with zeroes.
             gM                 Map each to its Jelly +.
                   +GH          If the depths are zero, return the normal sum.
                         yDJ    If the depths are different, order J by depth.
                      gLF       Apply the function which left-maps the Jelly +
                                function to the two values. The first is
                                treated as a constant, while the second varies
                                over elements over the second values.
</code></pre>
</div>
<div id="pu10" class="pu"><h2>JavaScript (ES6), 152 bytes</h2>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>f=(a,b,g=a=&gt;a.map?1+Math.max(0,...a.map(g)):0)=&gt;g(a)&lt;g(b)?f(b,a):g(b)&lt;g(a)?a.map(e=&gt;f(e,b)):g(a)?a.length&lt;b.length?f(b,a):a.map((e,i)=&gt;f(e,b[i]||0)):a+b
;t=(x,y,z)=&gt;o.textContent+=`
${JSON.stringify(x)}
${JSON.stringify(y)}
${JSON.stringify(z)}
${JSON.stringify(f(x,y))}
`;`
0 + 0                           = 0
[-1, 0, -1] + [1]               = [0, 0, -1]
[] + [0]                        = [0]
[] + 0                          = []
[] + []                         = []
[[], 0] + []                    = [[], []]
[1, 2, 3] + 10                  = [11, 12, 13]
[1, 2, 3] + [10]                = [11, 2, 3]
[1, 2, 3] + [10, [20]]          = [[11, 12, 13], [21, 2, 3]]
[1, 2, 3, []] + [10, [20]]      = [11, [22], 3, []]
[1, [2, [3, [4]]]] + [10, [20]] = [[11, [21]], [[12, [22]], [13, [24]]]]`.slice(1).split`
`.map(l=&gt;t(...l.split(/ [+=] /).map(a=&gt;JSON.parse(a))));</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;pre id=o&gt;&lt;/pre&gt;</code></pre>
</div>
</div>
</p>
</div>
<div id="pu11" class="pu"><h1>Haskell, 150 bytes</h1>

<pre><code>data L=S Int|V{v::[L]}
d(V z)=1+maximum(d&lt;$&gt;S 0:z);d _=0
S x!S y=S$x+y
x!y|d x&lt;d y=V$(x!)&lt;$&gt;v y|d x&gt;d y=y!x|1&lt;2=V$v x#v y
(x:a)#(y:b)=x!y:a#b;a#b=a++b
</code></pre>

<h2>Explanation</h2>

<p>The first line defines an algebraic data type <code>L</code>, which is either a <code>S</code>calar (containing an <code>Int</code>) or a <code>V</code>ector (containing a list of <code>L</code>s, accessed using a record getter <code>v</code>, which is a partial function <code>L → [L]</code>.)</p>

<p>The second line defines the <strong>depth</strong> function: the depth of a <code>V</code>ector is one plus its maximum depth. I prepend <code>S 0</code> to the values in the vector, so that <code>depth [] == 1 + maximum [depth (S 0)] == 1</code>. The depth of “anything else” (a scalar) is <code>0</code>.</p>

<p>The third line defines the base case for <code>!</code> (the addition function): the sum of scalars is simply a scalar.</p>

<p>The fifth line defines a variant of <code>zipWith (!)</code> that just picks elements from the longest list when one of them is empty.</p>

<p>The fourth line is split in three cases:</p>

<pre><code>x!y | d x&lt;d y = V$(x!)&lt;$&gt;v y
    | d x&gt;d y = y!x
    | True    = V$v x#v y
</code></pre>

<ul>
<li><p>If the depth of <code>x</code> is strictly less than the depth of <code>y</code>, map <code>(x!)</code> over the elements of <code>y</code>. (The use of <code>v</code> is guaranteed to be valid, as <code>d(y) ≥ 1</code>.)</p></li>
<li><p>If the depth of <code>x</code> is strictly greater, flip the arguments and restart.</p></li>
<li><p>If their depths are equal, zip the arguments together with <code>(!)</code>. (The use of <code>v</code> is guaranteed to be valid, as the case <code>d(x) = d(y) = 0</code> was handled as a base case.)</p></li>
</ul>

<h2>Test cases</h2>

<pre><code>instance Show L where
  show (S x) = show x
  show (V x) = show x

lArg = V [S 1, V [S 2, V [S 3, V [S 4]]]]
rArg = V [S 10, V [S 20]]
</code></pre>

<p>Then <code>show (lArg ! rArg) == "[[11,[21]],[[12,[22]],[13,[24]]]]"</code>. </p>
</div>
<div id="pu12" class="pu"><h2>Mathematica, 122 bytes</h2>

<pre><code>d=Depth
x_~f~y_/;d@x&gt;d@y:=y~f~x
x_~f~y_/;d@x&lt;d@y:=x~f~#&amp;/@y
x_List~f~y_:=MapThread[f,{x,y}~PadRight~Automatic]
x_~f~y_=x+y
</code></pre>

<p>Defines a recursive function <code>f</code> which computes the sum. Making use of Mathematica's pattern matching, this function is made up of four separate definitions:</p>

<pre><code>x_~f~y_/;d@x&gt;d@y:=y~f~x
</code></pre>

<p>If the depth of <code>x</code> is greater than that of <code>y</code>, swap the arguments so that we only have to handle distribution in one direction (which we can do, since addition is commutative).</p>

<pre><code>x_~f~y_/;d@x&lt;d@y:=x~f~#&amp;/@y
</code></pre>

<p>If the depth of <code>x</code> is less thann that of <code>y</code>, replace each value <code>#</code> in <code>y</code> with <code>f[x,#]</code>, which takes care of the distribution for arguments of unequal depth.</p>

<pre><code>x_List~f~y_:=MapThread[f,{x,y}~PadRight~Automatic]
</code></pre>

<p>Otherwise, if one argument is a list (which implies that the other also is a list, since we know they have the same depth), we put both arguments in a list, pad them to the same length with <code>PadRight[..., Automatic]</code> (which simply fills up a ragged array with zeros to make it rectangular), and then use <code>MapThread</code> to apply <code>f</code> to corresponding pairs from the two lists.</p>

<p>And finally, the base case:</p>

<pre><code>x_~f~y_=x+y
</code></pre>

<p>If none of the other patterns match, we must be trying to add two numbers, so we just do that.</p>
</div>
<!-- TYYY -->

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/81165/">81165</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




