<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::73426</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>095</td><td>AWK</td><td>241105T164131Z</td><td><a href="https://codegolf.stackexchange.com/questions/73426/the-holy-numbers/276528#276528">xrs</a></td></tr>
<tr d-ix="1"><td>058</td><td>Perl 5 ap</td><td>201208T163953Z</td><td><a href="https://codegolf.stackexchange.com/questions/73426/the-holy-numbers/216104#216104">Xcali</a></td></tr>
<tr d-ix="2"><td>022</td><td>Jelly</td><td>201127T113046Z</td><td><a href="https://codegolf.stackexchange.com/questions/73426/the-holy-numbers/215686#215686">caird co</a></td></tr>
<tr d-ix="3"><td>039</td><td>MATL</td><td>160218T001601Z</td><td><a href="https://codegolf.stackexchange.com/questions/73426/the-holy-numbers/73447#73447">Luis Men</a></td></tr>
<tr d-ix="4"><td>140</td><td>Lua</td><td>160218T085906Z</td><td><a href="https://codegolf.stackexchange.com/questions/73426/the-holy-numbers/73464#73464">Katenkyo</a></td></tr>
<tr d-ix="5"><td>nan</td><td></td><td>160219T224923Z</td><td><a href="https://codegolf.stackexchange.com/questions/73426/the-holy-numbers/73633#73633">Sumeet</a></td></tr>
<tr d-ix="6"><td>034</td><td>CJam</td><td>160217T215449Z</td><td><a href="https://codegolf.stackexchange.com/questions/73426/the-holy-numbers/73437#73437">Martin E</a></td></tr>
<tr d-ix="7"><td>169</td><td>Lua</td><td>160219T173534Z</td><td><a href="https://codegolf.stackexchange.com/questions/73426/the-holy-numbers/73610#73610">DavisDud</a></td></tr>
<tr d-ix="8"><td>096</td><td>PowerShell</td><td>160217T210652Z</td><td><a href="https://codegolf.stackexchange.com/questions/73426/the-holy-numbers/73432#73432">AdmBorkB</a></td></tr>
<tr d-ix="9"><td>094</td><td>Haskell</td><td>160219T001613Z</td><td><a href="https://codegolf.stackexchange.com/questions/73426/the-holy-numbers/73532#73532">Michael </a></td></tr>
<tr d-ix="10"><td>096</td><td>Python 2</td><td>160219T013050Z</td><td><a href="https://codegolf.stackexchange.com/questions/73426/the-holy-numbers/73537#73537">xnor</a></td></tr>
<tr d-ix="11"><td>067</td><td>Bash + GNU utilities</td><td>160217T215124Z</td><td><a href="https://codegolf.stackexchange.com/questions/73426/the-holy-numbers/73436#73436">Digital </a></td></tr>
<tr d-ix="12"><td>229</td><td>Oracle SQL 11.2</td><td>160218T152211Z</td><td><a href="https://codegolf.stackexchange.com/questions/73426/the-holy-numbers/73475#73475">Jeto</a></td></tr>
<tr d-ix="13"><td>087</td><td>JavaScript ES6</td><td>160218T145740Z</td><td><a href="https://codegolf.stackexchange.com/questions/73426/the-holy-numbers/73473#73473">edc65</a></td></tr>
<tr d-ix="14"><td>110</td><td>JavaScript ES6</td><td>160218T011433Z</td><td><a href="https://codegolf.stackexchange.com/questions/73426/the-holy-numbers/73454#73454">Neil</a></td></tr>
<tr d-ix="15"><td>168</td><td>C# 6</td><td>160218T134330Z</td><td><a href="https://codegolf.stackexchange.com/questions/73426/the-holy-numbers/73471#73471">Paulo C&</a></td></tr>
<tr d-ix="16"><td>107</td><td>R</td><td>160218T104656Z</td><td><a href="https://codegolf.stackexchange.com/questions/73426/the-holy-numbers/73467#73467">plannapu</a></td></tr>
<tr d-ix="17"><td>082</td><td>Ruby</td><td>160217T210710Z</td><td><a href="https://codegolf.stackexchange.com/questions/73426/the-holy-numbers/73433#73433">Doorknob</a></td></tr>
<tr d-ix="18"><td>191</td><td>JavaScript ES6</td><td>160217T231506Z</td><td><a href="https://codegolf.stackexchange.com/questions/73426/the-holy-numbers/73444#73444">Conor O&</a></td></tr>
<tr d-ix="19"><td>103</td><td>Python 3</td><td>160217T202825Z</td><td><a href="https://codegolf.stackexchange.com/questions/73426/the-holy-numbers/73428#73428">Morgan T</a></td></tr>
<tr d-ix="20"><td>032</td><td>Pyth</td><td>160217T202819Z</td><td><a href="https://codegolf.stackexchange.com/questions/73426/the-holy-numbers/73427#73427">Blue</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.gnu.org/software/gawk/manual/gawk.html" rel="nofollow noreferrer">AWK</a>, 95 bytes</h1>
<pre><code>{for(j=i=0;j!=$1;i++){a=i;i~/[12357]/||gsub(/[469]/,X,a)+2*gsub(/[80]/,X,a)&gt;=$2&amp;&amp;++j}print i-1}
</code></pre>
<p>TIO doesn't work, but...</p>
<p><a href="https://tio.run/##SyzP/v@/Oi2/SCPLNtPWwDpL0VbF0DpTW1uzOtE20zqzTj/a0MjY1DxWv6Ymvbg0SUM/2sTMMlZfJ0InUVPbSAsqZmEAFbKzVTFSU9PWzqotKMrMK1HI1DWs/f/fSMHo/7/8gpLM/Lzi/wA" rel="nofollow noreferrer" title="AWK – Try It Online">Try it online!</a></p>
<pre><code>{for(j=i=0;j!=$1;i++)  # j counts number of hits up to n
{a=i;                  # tmp
i~/[12357]/||          # unholy numbers
gsub(/[469]/,X,a)+     # gsub returns number of matches/subs
2*gsub(/[80]/,X,a)     # 2 points per match
&gt;=$2&amp;&amp;++j}             # if &gt;= h, add hit
print i-1}             # overshoot
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.perl.org/" rel="nofollow noreferrer">Perl 5</a> <code>-ap</code>, 58 bytes</h1>

<pre class="lang-perl prettyprint-override"><code>$_=0;$n=&lt;&gt;;$_++while/[12357]/||y/64980//+y/80//&lt;&quot;@F&quot;||--$n
</code></pre>
<p><a href="https://tio.run/##K0gtyjH9/18l3tbAWiXP1sbOWiVeW7s8IzMnVT/a0MjY1DxWv6amUt/MxNLCQF9fu1IfRNkoObgp1dTo6qrk/f9vxGXyL7@gJDM/r/i/bmJBDgA" rel="nofollow noreferrer" title="Perl 5 – Try It Online">Try it online!</a></p>
<p>Input is on two lines with <code>h</code> on the first and <code>n</code> on the second.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, <s>23</s> 22 bytes</h1>
<pre><code>“J,1’D=þD§S×ẠƊ
0Ç&lt;Cɗ#Ṫ
</code></pre>
<p><a href="https://tio.run/##ATIAzf9qZWxsef//4oCcSiwx4oCZRD3DvkTCp1PDl@G6oMaKCjDDhzxDyZcj4bmq////Mv8yNQ" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<h2>How it works</h2>
<pre><code>0Ç&lt;Cɗ#Ṫ - Main link. Takes h on the left and n on the right
    ɗ   - Group the previous 3 links into a dyad f(k, h):
 Ç      -   Call the helper link on k
  &lt;     -   Less than h?
   C    -   Complement; 0 -&gt; 1, 1 -&gt; 0
0    #  - Count up k = 0, 1, 2, ... until n k's return true under f(k, h)
      Ṫ - Take the last k

“J,1’D=þD§S×ẠƊ - Helper link. Takes an integer k on the left
        D      - Digits of k
“J,1’          - Compressed integer 4698800
     D         - Converted to digits
       þ       - Outer product with:
      =        -   Equality
         §     - Sum of each row
             Ɗ - Group the previous 3 links into a monad g(s) over the sums:
          S    -   Sum
            Ạ  -   All are non-zero?
           ×   -   Product
                 This calculates the holiness of k, which is 0 if k isn't holy
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://esolangs.org/wiki/MATL" rel="nofollow noreferrer">MATL</a>, 39 <s>40</s> bytes</h1>
<pre><code>x~q`QtV4688900V!=stA*s2G&lt;?T}N1G=?F1$}tT
</code></pre>
<p>Inputs are <code>n</code> and <code>h</code> in that order.</p>
<p><a href="http://matl.tryitonline.net/#code=eH5xYFF0VjQ2ODg5MDBWIT1zdEEqczJHPD9UfU4xRz0_RjEkfXRU&amp;input=MjUKMg" rel="nofollow noreferrer"><strong>Try it online!</strong></a></p>
<p>We need to keep track of two numbers: current candidate number (to check its holiness) and amount of numbers found that are holy enough. The first is the top od the stack, and the latter is kept as the number of elements in the stack. When the program finishes, only the top needs to displayed.</p>
<pre><code>x~q          % implicitly take two inputs. Delete one and transform the other into -1
`            % do...while loop
  Q          %   add 1 to current candidate number
  tV         %   duplicate and convert to string
  4688900V!  %   column char array of '4', '6' etc. Note '8' and '0' are repeated 
  =          %   compare all combinations. Gives 2D array
  s          %   sum of each column: holiness of each digit of candidate number
  tA*        %   are all digits holy? Multiply by that
  s          %   sum of holiness of all digits, provided they are all holy
  2G&lt;        %   is that less than second input (h)?
  ?          %   if so: current candidate not valid. We'll try the next
    T        %     push true to be used as loop condition: next iteration
  }          %   else: current candidate valid
    N1G=     %     does stack size equal first input (n)?
    ?        %     if so: we're done
      F1$    %       push false to exit loop. Spec 1 input, to display only top
    }        %     else: make a copy of this number
      tT     %       duplicate number. Push true to continue with next iteration
             %     implicit end if 
             %   implicit end if 
             % implicit end do...while. If top of stack is truthy: next iteration
             % implicit display
</code></pre>
</div>
<div id="pu4" class="pu"><h2>Lua, <s>155</s> <s>141</s> 140 Bytes</h2>

<p>Takes both inputs by command-line argument(first argument is n, then h)</p>

<p><strong>Edit: Thanks to @DavisDude, who helped me shaving 14 bytes off and reminded me I didn't have to print all the holy numbers up to n, but only the nth.</strong></p>



<pre class="lang-lua prettyprint-override"><code>a={}x=0while(#a&lt;arg[1])do b,c=(x..""):gsub("[08]","")e,d=b:gsub("[469]","")a[#a+1],x=c*2+d&gt;=arg[2]and #e&lt;1 and x or nil,x+1 end print(a[#a])
</code></pre>

<h3>Ungolfed and explanations</h3>

<pre class="lang-lua prettyprint-override"><code>x,a=0,{}                      -- initialise a counter, and the array which 
                              -- contains the holy numbers found
while(#a&lt;arg[1])              -- iterate while we found less holy numbers than n
do
  b,c=(x..""):gsub("[08]","") -- replace [08] by "", b=the new string
                              -- c=the number of subsitution
  e,d=b:gsub("[469]","")      -- same thing for [469]
  a[#a+1]=c*2+d&gt;=arg[2]       -- insert the number into a if:nb[08]*2+nb[469]&gt;h
             and #e&lt;1         -- and e is empty (no unholy numbers)
             and x or nil
      x=x+1                   -- increment x
end
print(a[#a])                  -- print the last element of a
</code></pre>
</div>
<div id="pu5" class="pu"><p><strong>Swift</strong></p>

<pre><code>func f(n: Int, h: Int) {
    var m = 0
    let a = [1,2,3,5,7]
    for j in 0..&lt;Int.max {
        var c = 0
        for i in (j.description.characters.map{(String($0) as NSString).integerValue}) {
            c += (a.contains(i)) ? 0 : (i == 8 || i == 0) ? 2 :1
        }
        if c &gt;= h { m += 1; if m &gt;= n {print(j); break}}
    }
}
</code></pre>
</div>
<div id="pu6" class="pu"><h2>CJam, <s>36</s> 34 bytes</h2>

<p><em>Thanks to aditsu for saving 2 bytes.</em></p>

<pre><code>Wq~:X;{{)_Ab39643Zbf=_:*g*1bX&lt;}g}*
</code></pre>

<p><a href="http://cjam.aditsu.net/#code=Wq~%3AX%3B%7B%7B)_s9886400sfe%3D_%3A*gf*%3A%2BX%3C%7Dg%7D*&amp;input=25%202" rel="nofollow">Test it here.</a></p>
</div>
<div id="pu7" class="pu"><h1>Lua, 169 bytes</h1>

<pre><code>function a(n,h)H=0N=0I=-1while N&lt;n do I=I+'1'H=0 if not I:find('[12357]') then _,b=I:gsub('[469]',1)_,c=I:gsub('[08]',1)H=b+2*c end N=H&gt;=h and N+1 or N end print(I) end
</code></pre>

<p>Ungolfed:</p>

<pre><code>function a(n,h) -- nth term, holiness
    H=0N=0I=-1 -- Really ugly, but hey, it works. Set up 3 vars
    while N&lt;n do -- While nth term is lower than desired term
        I=''..I+1 -- Convert number to string (can't coerce since it will become a float)
        if not I:find('[12357]') then -- If the number doesn't have those numbers
            _,b=I:gsub('[469]',1) -- _ is the new string, b is the number of changes
            _,c=I:gsub('[08]',1) -- Same as above. Use 1 to replace to save chars
            H=b+2*c -- Increase holiness appropriately
        end
        N=H&gt;=h and N+1 or N -- If current holiness &gt;= desired holiness, increment N
    end 
    print(I) -- Once the loop ends, print the current term
end
</code></pre>
</div>
<div id="pu8" class="pu"><h2>PowerShell, <s>163</s> <s>150</s> <s>141</s> <s>101</s> <s>98</s> 96 bytes</h2>
<pre><code>param($n,$h)for(--$i;$n){if(++$i-notmatch&quot;[12357]&quot;-and($i-replace&quot;8|0&quot;,11).Length-ge$h){$n--}}$i
</code></pre>
<p>Takes input, then loops until <code>$n</code> is zero. We initially setting <code>$i=-1</code> by using a pre-processing trick, which works because <code>$i</code>, having not previously been declared, is <code>$null</code>. Then we <code>--</code> it, which causes PowerShell to evaluate it as <code>$i = $null - 1</code>, which is <code>$i=-1</code>.</p>
<p>Each loop we increment <code>$i</code> and then execute a lengthy <code>if</code> statement. The first part of the conditional verifies that <code>$i</code> doesn't have any of <code>12357</code> in it by using the <a href="https://technet.microsoft.com/en-us/library/hh847759(v=wps.620).aspx" rel="nofollow noreferrer"><code>-notmatch</code> operator</a>, to filter out the unholy numbers.</p>
<p>The second part of the conditional checks the quantity of holes in <code>$i</code>. It uses the <code>-replace</code> operator to replace each <code>8</code> or <code>0</code> with <code>11</code>, and then compares whether the length is &gt;= <code>$h</code>. We don't need to worry about stripping out the unholy numbers, since that's in the first part of the conditional, and the single-holed numbers are the same length as <code>1</code> anyway, so we don't need to replace them, either.</p>
<p>If that is still truthy, we decrement <code>$n</code> (as that means we've found another number that satisfies input requirements). Thus when the <code>for</code> condition is recalculated to check if <code>$n</code> is zero, that means we've found the <em>nth</em> one, so we exit the <code>for</code> loop, output <code>$i</code> and terminate.</p>
<p><sub>Edit -- saved 13 bytes by using an array instead of string for <code>$l</code> and changing how <code>$n</code> is decremented/checked</sub><br />
<sub>Edit 2 -- saved an additional 9 bytes by checking for <code>$n</code> in the <code>for</code> conditional and moving the output outside the loop</sub><br />
<sub>Edit 3 -- saved a whopping 40 more bytes by radically changing how we calculate the holes</sub><br />
<sub>Edit 4 -- saved an additional 3 bytes by moving the <code>++</code> to be a pre-increment on the first part of the conditional</sub><br />
<sub>Edit 5 -- saved another 2 bytes thanks to <a href="https://codegolf.stackexchange.com/users/571/tessellatingheckler">TessellatingHeckler</a></sub></p>
</div>
<div id="pu9" class="pu"><h1>Haskell, 94 bytes</h1>
<p><code>c</code> is the holiness of a digit, <code>v</code> the holiness of a number, <code>n!h</code> does the rest.</p>
<pre><code>c=([2,0,0,0,1,0,1,0,2,1]!!)
v n|n&gt;9=c(mod n 10)+v(div n 10)|1&lt;2=c n
n!h=[i|i&lt;-[0..],v i&lt;=h]!!n
</code></pre>
<p>Note: I think this is the only answer without the characters <code>4,6,8</code>.</p>
</div>
<div id="pu10" class="pu"><h2>Python 2, 96 bytes</h2>
<pre class="lang-python prettyprint-override"><code>f=lambda n,h,k=0,s=&quot;0046889&quot;:-0**n or-~f(n-(sum(map(s.count,`k`))&gt;=h&lt;set(str(k))&lt;=set(s)),h,k+1)
</code></pre>
<p>The holyness condition on <code>k</code> is checked by</p>
<ul>
<li><code>sum(map(s.count,`k`))&gt;=h</code>, which counts the number of holes by summing the counts for each character in <code>s=&quot;0046889&quot;</code>, where <code>0</code> and <code>8</code> appear twice.</li>
<li><code>set(str(k))&lt;=set(s))</code>, which checks that the numbers are all holy. <code>str</code> is used rather than backticks to avoid the suffix <code>L</code> for longs.</li>
</ul>
<p>These are chained into a single equality using the Python 2 fact that numbers are smaller than sets.</p>
<p>The function is defined recursively to count up numbers <code>k</code>, decreasing the counter <code>n</code> each time a holy number of hit unless it hits <code>0</code>. It could then return the <code>k</code> that triggered this, but it's shorter to keep the count recursively by adding <code>1</code> each time, though an off-by-one requires a base count of <code>-1</code> to fix.</p>
</div>
<div id="pu11" class="pu"><h1>Bash + GNU utilities, 67</h1>

<ul>
<li>20 bytes saved thanks to @TobySpeight!</li>
</ul>



<pre class="lang-bash prettyprint-override"><code>seq 0 NaN|sed -r "h;/[12357]/d;s/8|0/&amp;&amp;/g;/^.{$1}/!d;x"|sed $2!d\;q
</code></pre>

<ul>
<li><code>seq</code> simply generates integers starting from <code>0</code> upwards</li>
<li><code>sed -r</code>:

<ul>
<li><code>h</code> copy the input line to the hold space</li>
<li><code>/12357/d</code> delete unholy numbers</li>
<li><code>s/8|0/&amp;&amp;/g</code> replace doubly holy digits with twice themselves. Thus singly holy digits are counted once and doubly holy digits are counted twice.</li>
<li><code>/^.{$1}/!d</code> If not matching at least <code>$1</code> holes, delete and continue to the next line</li>
<li><code>x</code> bring original number back to the pattern space</li>
<li>implicit print</li>
</ul></li>
<li><code>sed</code>

<ul>
<li><code>$2!d</code> on any lines before line <code>$2</code>, delete and continue to the next line</li>
<li><code>q</code> must be at line <code>$2</code> - quit (and implicit print)</li>
</ul></li>
</ul>

<p><a href="https://ideone.com/zYgdbk" rel="nofollow">Ideone.</a></p>
</div>
<div id="pu12" class="pu"><h1>Oracle SQL 11.2, 229 bytes</h1>
<pre><code>WITH v(c,p,i,j,n)AS(SELECT 0,-1,0,0,0 FROM DUAL UNION ALL SELECT c+1,c,REGEXP_COUNT(c||'','[4,6,9]'),REGEXP_COUNT(c,'[8,0]'),n+DECODE(LENGTH(p),i+j,DECODE(SIGN(i+j*2-:h),-1,0,1),0)FROM v WHERE p&lt;c AND n&lt;:n)SELECT MAX(p)-1 FROM v;
</code></pre>
<p>Un-golfed</p>
<pre><code>:h -&gt; required min holy value
:n -&gt; nth number 

curv   -&gt; current number
precv  -&gt; previous number
prech1 -&gt; number of holy 1 letters in previous number 
prech2 -&gt; number of holy 2 letters in previous number
n      -&gt; how many numbers with at least the required holy value 

WITH v(curv,precv,prech1,prech2,n)AS 
(
  SELECT 0 curv, -1 precv, 0 prech1, 0 prech2, 0 n FROM DUAL     -- Start with 0
  UNION ALL
  SELECT curv+1,   -- Next number
         curv,     -- Current Number 
         REGEXP_COUNT(curv||'','[4,6,9]'),  -- number of holy 1 letters
         REGEXP_COUNT(curv,'[8,0]'),        -- number of holy 2 letters
         n+DECODE(LENGTH(precv),prech1+prech2,DECODE(SIGN(prech1+prech2*2-:h),-1,0,1),0) -- Is the previous number holy enough ?
  FROM   v 
  WHERE  precv&lt;curv   -- Needed to trick oracle cycle detection 
         AND n&lt;:n     -- Until clause
)
SELECT MAX(precv)-1 FROM v 
</code></pre>
</div>
<div id="pu13" class="pu"><h1>JavaScript (ES6), 87</h1>

<pre class="lang-js prettyprint-override"><code>(n,h)=&gt;eval("for(i=0;[...i+''].map(d=&gt;r-=~!(d%8),r=0),/[12357]/.test(i)|r&lt;h||--n;)++i")
</code></pre>

<p><strong>Less golfed</strong></p>

<pre class="lang-js prettyprint-override"><code>f=(n,h)=&gt;{
  for (i=0;
    // this is the loop condition
    /[12357]/.test(i) // go on if not holy
    ||([...i+''].map(d=&gt;r-=~!(d%8),r=0),r&lt;h) // go on if not holy enough
    ||--n; // ok, found one! go on if we need to find more
  )
    ++i; // loop body - using eval this is the returned value
  return i; // not using eval, an explicit return is needed
}  
</code></pre>

<p><strong>Test</strong></p>

<p><div class="snippet" data-lang="js" data-hide="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>f=(n,h)=&gt;eval("for(i=0;[...i+''].map(d=&gt;r-=~!(d%8),r=0),/[12357]/.test(i)|r&lt;h||--n;)++i")

function test() {
  var a,b
  [a,b]=I.value.match(/\d+/g)
  R.textContent = f(a,b)
}

test()</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>N, H: &lt;input id=I value="25 2" oninput="test()"&gt; &gt;&gt;
&lt;span id=R&gt;&lt;/span&gt;</code></pre>
</div>
</div>
</p>
</div>
<div id="pu14" class="pu"><h2>JavaScript (ES6), 110 bytes</h2>

<pre><code>f=(n,h,r=[],i=0)=&gt;r.length&lt;n?f(n,h,/[12357]/.test(i)|[...''+i].reduce((t,c)=&gt;t+1+!(c%8),0)&lt;h?r:[...r,i],i+1):r
</code></pre>

<p>Tail recursive solution that accumulates holy numbers in an array.</p>

<p>Out of interest, not requiring the number to be wholly(!) holy makes the holiness count more awkward, but it still saves 10% overall:</p>

<pre><code>f=(n,h,r=[],i=0)=&gt;r.length&lt;n?f(n,h,[...''+i].reduce((t,c)=&gt;+"2000101021"[c]+t,0)&lt;h?r:[...r,i],i+1):r
</code></pre>
</div>
<div id="pu15" class="pu"><p><strong>C# 6, 168 bytes</strong></p>

<pre><code>(n,h)=&gt;{for(int i=0;i&lt;=int.MaxValue;i++){string d=$"{i}";if(d.Any(y=&gt;"12357".Contains(y)))continue;n-=d.Sum(y=&gt;y=='0'||y=='8'?2:1)&gt;=h?1:0;if(n==0)return i;}return -1;}
</code></pre>

<p>This is a Lambda Expression of type Func&lt; int, int, int>.
This code is otimized for min size (not performatic).</p>

<p>Below, the beautified code in method declaration (with more performance):</p>

<pre><code>    int GetHolyNumber(int n, int h)
    {
        for (int i = 0; i &lt;= int.MaxValue; i++)
        {
            string d = $"{i}";
            char[] cs = "12357".ToArray();
            if (d.Any(y =&gt; cs.Contains(y))) continue;

            n -= d.Sum(y =&gt; y == '0' || y == '8' ? 2 : 1) &gt;= h ? 1 : 0;

            if (n == 0)
                return i;
        }
        return -1;
    }
</code></pre>
</div>
<div id="pu16" class="pu"><h1>R, <s>109</s> 107 bytes</h1>
<pre><code>f=function(n,h){m=-1;while(n){m=m+1;if(!grepl(&quot;[12357]&quot;,m))if(nchar(gsub(&quot;([08])&quot;,&quot;\\1\\1&quot;,m))&gt;=h)n=n-1};m}
</code></pre>
<p>With new lines and indentations:</p>
<pre class="lang-r prettyprint-override"><code>f=function(n,h){
    m=-1
    while(n){
        m=m+1
        if(!grepl(&quot;[12357]&quot;,m))
            if(nchar(gsub(&quot;([08])&quot;,&quot;\\1\\1&quot;,m))&gt;=h)
                n=n-1
    }
    m
}
</code></pre>
<p>Usage:</p>
<pre><code>&gt; f(4,3)
[1] 68
&gt; f(4,2)
[1] 44
&gt; f(6,2)
[1] 48
&gt; f(10,2)
[1] 66
</code></pre>
</div>
<div id="pu17" class="pu"><h2>Ruby, <s>109</s> <s>105</s> <s>95</s> 82 bytes</h2>



<pre class="lang-ruby prettyprint-override"><code>-&gt;n,h{(?0..?9*99).select{|x|x.count('469')+2*x.count('80')&gt;=h&amp;&amp;/[12357]/!~x}[n-1]}
</code></pre>

<p>This is the terrible "calculate from 0 to 99999999999..." approach that happens to be 13 bytes shorter than its lazy counterpart. However, this version is unlikely to finish before the heat death of the universe. Worth 13 bytes, anyway ¯\_(ツ)_/¯</p>

<p>You can test it for smaller values by changing <code>?9*99</code> to, say, <code>'99999'</code>.</p>

<p>Here's the old version (95 bytes, with lazy evaluation, which runs near-instantly rather than near-never):</p>

<pre class="lang-ruby prettyprint-override"><code>-&gt;n,h{(?0..?9*99).lazy.select{|x|x.count('469')+2*x.count('80')&gt;=h&amp;&amp;/[12357]/!~x}.first(n)[-1]}
</code></pre>



<pre class="lang-ruby prettyprint-override"><code>-&gt;n,h{
(?0..?9*99)  # range '0' (string) to '9' repeated 99 times, way more than 2**64
.lazy        # make the range lazy, so we can call `select' on it
.select{|x|  # choose only elements such that...
 x.count('469')+2*x.count('80')  # naive holiness calculation
 &gt;=h         # is at least h
 &amp;&amp;/[12357]/!~x                  # naive "is holy" calculation
}
.first(n)    # take the first n elements that satisfy the condition
[-1]         # choose the last one from this array
}
</code></pre>
</div>
<div id="pu18" class="pu"><h1>JavaScript ES6, 191 bytes</h1>

<p>Sure, this isn't the most efficient way. But you know me, I love generators &lt;3</p>

<pre><code>H=(x,o=x+"")=&gt;(F=/^[46890]+$/).test(o)&amp;&amp;[...o].map(y=&gt;d+=(F.test(y)+/8|0/.test(y)),d=0)&amp;&amp;d;(n,h)=&gt;(a=(function*(h){q=0;while(1){if(H(q)&gt;=h)yield q;q++}})(h),eval("a.next().value;".repeat(n)))
</code></pre>

<p>Slightly ungolfed:</p>

<pre><code>H = (x, o = x + "") =&gt; (F = /^[46890]+$/).test(o) &amp;&amp; [...o].map(y =&gt; d += (F.test(y) + /8|0/.test(y)), d = 0) &amp;&amp; d;
Q = (n, h) =&gt; (a = (function*(h) {
    q = 0;
    while (1) {
        if (H(q) &gt;= h) yield q;
        q++
    }
})(h), eval("a.next().value;".repeat(n)))
</code></pre>
</div>
<div id="pu19" class="pu"><h1>Python 3, 103</h1>

<pre class="lang-py prettyprint-override"><code>lambda n,h,l='4698080':[y for y in range(2**64-1)if(sum(l.count(x)-(x not in l)for x in str(y))&gt;=h)][n]
</code></pre>
<p>Here's a solution that uses a more memory efficient approach, but otherwise uses the same algorithm if you want to test it.</p>
<pre class="lang-py prettyprint-override"><code>l='4689080'
def f(n,h):
 c=i=0
 while i&lt;n:
  if sum(l.count(x)-(x not in l)for x in str(c))&gt;=h:u=c;i+=1
  c+=1
 return u
</code></pre>
<p>Test cases:</p>
<pre class="lang-py prettyprint-override"><code>assert f(3, 1) == 6
assert f(4, 2) == 44
</code></pre>
</div>
<div id="pu20" class="pu"><h2>Pyth, 32 bytes</h2>
<pre><code>e.fg*g.{`46890J`Z++lJ/J`8/J`0QE0
</code></pre>
<p>Explanation</p>
<pre><code>                                 - autoassign Q = eval(input())
 .f                           E0 -  first eval(input()) terms of func V starting Z=0

     g.{`46890J`Z                -    Are all the digits in Z in &quot;46890&quot;?
               `Z                -      str(Z)
              J                  -     autoassign J = ^
     g                           -    is_subset(V,^)
      .{`46890                   -     set(&quot;46890&quot;)

    *                            -   ^*V (Only return non-zero if only contains holy numbers)

                 ++lJ/J`8/J`0    -    Get the holiness of the number
                   lJ            -      len(J)
                  +              -     ^+V
                     /J`8        -      J.count(&quot;8&quot;) 
                 +               -    ^+V
                         /J`0    -     J.count(&quot;0&quot;)
   g                         Q   -  ^&gt;=Q (Is the holiness great enough)
e                                - ^[-1]
</code></pre>
<p><a href="http://pyth.herokuapp.com/?code=e.fg*g.%7B%6046890J%60Z%2B%2BlJ%2FJ%608%2FJ%600QE0&amp;input=1%0A3&amp;debug=1" rel="nofollow noreferrer">Try it here</a></p>
<p>Takes input in the form <code>h \n n</code></p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/73426/">73426</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




