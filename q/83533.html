<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::83533</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>029</td><td>APLNARS</td><td>250117T100837Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/277718#277718">Rosario</a></td></tr>
<tr d-ix="1"><td>004</td><td>Nekomata</td><td>230916T002517Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/265273#265273">alephalp</a></td></tr>
<tr d-ix="2"><td>003</td><td>Thunno 2 L</td><td>230729T165709Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/263510#263510">The Thon</a></td></tr>
<tr d-ix="3"><td>041</td><td>SageMath</td><td>230415T063815Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/260107#260107">138 Aspe</a></td></tr>
<tr d-ix="4"><td>076</td><td>><> Fish</td><td>230415T055033Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/260105#260105">mousetai</a></td></tr>
<tr d-ix="5"><td>034</td><td>Arturo</td><td>230414T210146Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/260094#260094">chunes</a></td></tr>
<tr d-ix="6"><td>131</td><td>Regex ECMAScript</td><td>190222T175037Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/180255#180255">Grimmy</a></td></tr>
<tr d-ix="7"><td>022</td><td>Julia 1.x</td><td>160622T082907Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83547#83547">Glen O</a></td></tr>
<tr d-ix="8"><td>005</td><td>Vyxal s</td><td>210623T032400Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/230346#230346">Wasif</a></td></tr>
<tr d-ix="9"><td>007</td><td>Husk</td><td>201022T183543Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/213968#213968">Dominic </a></td></tr>
<tr d-ix="10"><td>016</td><td>Brachylog v2</td><td>201022T145319Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/213954#213954">Unrelate</a></td></tr>
<tr d-ix="11"><td>042</td><td>JavaScript Node.js</td><td>200726T031012Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/207601#207601">user2027</a></td></tr>
<tr d-ix="12"><td>002</td><td>Japt mx</td><td>191204T225151Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/196649#196649">Shaggy</a></td></tr>
<tr d-ix="13"><td>065</td><td>C gcc</td><td>190225T003445Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/180336#180336">ceilingc</a></td></tr>
<tr d-ix="14"><td>019</td><td>TI84 BASIC</td><td>190224T201156Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/180315#180315">SuperJed</a></td></tr>
<tr d-ix="15"><td>024</td><td>Pari/GP</td><td>190224T035303Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/180296#180296">alephalp</a></td></tr>
<tr d-ix="16"><td>005</td><td>Japt mx</td><td>190223T000455Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/180268#180268">Oliver</a></td></tr>
<tr d-ix="17"><td>053</td><td>JavaScript ES6</td><td>190222T230627Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/180267#180267">Arnauld</a></td></tr>
<tr d-ix="18"><td>044</td><td>Python 2</td><td>171014T144246Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/145316#145316">Dennis</a></td></tr>
<tr d-ix="19"><td>009</td><td>J</td><td>160622T100712Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83554#83554">miles</a></td></tr>
<tr d-ix="20"><td>044</td><td>Python 2</td><td>160623T072600Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83636#83636">xnor</a></td></tr>
<tr d-ix="21"><td>144</td><td>Batch</td><td>160622T094015Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83552#83552">Neil</a></td></tr>
<tr d-ix="22"><td>050</td><td>Factor</td><td>160624T013731Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83737#83737">cat</a></td></tr>
<tr d-ix="23"><td>030</td><td>Haskell</td><td>160622T122210Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83560#83560">sudee</a></td></tr>
<tr d-ix="24"><td>032</td><td>Ruby</td><td>160623T183532Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83712#83712">Redouane</a></td></tr>
<tr d-ix="25"><td>028</td><td>Haskell</td><td>160623T071458Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83634#83634">xnor</a></td></tr>
<tr d-ix="26"><td>057</td><td>Python 2</td><td>160622T163753Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83581#83581">Dennis</a></td></tr>
<tr d-ix="27"><td>007</td><td>APL</td><td>160623T002236Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83624#83624">Alex A.</a></td></tr>
<tr d-ix="28"><td>021</td><td>MATLAB / Octave</td><td>160623T002138Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83623#83623">Suever</a></td></tr>
<tr d-ix="29"><td>058</td><td>Python >=3.5</td><td>160622T073749Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83541#83541">jqkul</a></td></tr>
<tr d-ix="30"><td>056</td><td>Hoon</td><td>160622T181311Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83588#83588">RenderSe</a></td></tr>
<tr d-ix="31"><td>058</td><td>Common Lisp</td><td>160622T142558Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83569#83569">WarWeasl</a></td></tr>
<tr d-ix="32"><td>072</td><td>PowerShell v2+</td><td>160622T132902Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83562#83562">AdmBorkB</a></td></tr>
<tr d-ix="33"><td>007</td><td>05AB1E</td><td>160622T122005Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83559#83559">Emigna</a></td></tr>
<tr d-ix="34"><td>029</td><td>Retina</td><td>160622T093020Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83550#83550">Leaky Nu</a></td></tr>
<tr d-ix="35"><td>022</td><td>Mathematica</td><td>160622T072010Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83538#83538">Martin E</a></td></tr>
<tr d-ix="36"><td>067</td><td>JavaScript ES6</td><td>160622T082556Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83546#83546">Neil</a></td></tr>
<tr d-ix="37"><td>005</td><td>Pyke</td><td>160622T081300Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83545#83545">Blue</a></td></tr>
<tr d-ix="38"><td>011</td><td>Actually</td><td>160622T071838Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83537#83537">Leaky Nu</a></td></tr>
<tr d-ix="39"><td>004</td><td>Jelly</td><td>160622T075625Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83543#83543">Leaky Nu</a></td></tr>
<tr d-ix="40"><td>006</td><td>Pyth</td><td>160622T065614Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83534#83534">Leaky Nu</a></td></tr>
<tr d-ix="41"><td>007</td><td>MATL</td><td>160622T074916Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83542#83542">David</a></td></tr>
<tr d-ix="42"><td>011</td><td>J</td><td>160622T070858Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83535#83535">Leaky Nu</a></td></tr>
<tr d-ix="43"><td>025</td><td>Brachylog</td><td>160622T072928Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83540#83540">Fatalize</a></td></tr>
<tr d-ix="44"><td>022</td><td>Perl 6</td><td>160622T071817Z</td><td><a href="https://codegolf.stackexchange.com/questions/83533/calculate-eulers-totient-function/83536#83536">Brad Gil</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>APL(NARS), 29 chars</h1>
<pre><code>{×/(v-1)×(v←↑¨k)*¯1+≢¨k←⊂⍨π⍵}
</code></pre>
<p>It would factor the argument ⍵ in one array of factors where each appear the time the exponent.
Than using one partition of itself (⊂⍨) it would find the each exponent (≢¨k), each prime (↑¨k)
would apply the formula</p>
<pre><code>  phi(p1^a1 × p2^a2 × ...× pn^an)=(p1-1)×p1^(a1-1)×(p2-1)×p2^(a2-1)× ...×(pn-1)×pn^(an-1)
</code></pre>
<p>test:</p>
<pre><code>  {×/(v-1)×(v←↑¨k)*¯1+≢¨k←⊂⍨π⍵}¨1 2 3 8 9 26 44 105
┌8──────────────────┐
│ 1 1 2 4 6 12 20 48│
└~──────────────────┘
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/AlephAlpha/Nekomata" rel="nofollow noreferrer">Nekomata</a>, 4 bytes</h1>
<pre><code>RG1Ĉ
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m70iLzU7PzexJHFZtJJurlLsgqWlJWm6FkuD3A2PdCwpTkouhoos2GzIZcRlzGXBZcllZMZlYsJlaGAKkQIA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<pre><code>RG1Ĉ
R       Range from 1 to input
 G      GCD
  1Ĉ    Count 1s
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/Thunno/Thunno2" rel="nofollow noreferrer">Thunno 2</a> <code>L</code>, 3 <a href="https://github.com/Thunno/Thunno2/blob/main/docs/codepage.md" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>æĠḅ
</code></pre>
<p><a href="https://Not-Thonnu.github.io/run#aGVhZGVyPSZjb2RlPSVDMyVBNiVDNCVBMCVFMSVCOCU4NSZmb290ZXI9JmlucHV0PTEwNSZmbGFncz1M" rel="nofollow noreferrer">Try it online!</a></p>
<h4>Explanation</h4>
<pre class="lang-python prettyprint-override"><code>æĠḅ  # Implicit input
æ    # Filter by:
 Ġ   #  GCD with input
  ḅ  #  Equals one?
     # Length of list
     # Implicit output
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.sagemath.org/" rel="nofollow noreferrer">SageMath</a>, 41 bytes</h1>
<p><a href="https://sagecell.sagemath.org/?z=eJwVyEsOQDAUBdC5xB5ujN5LStRQsBExqE-lCZcU-8cZHt9ubh9nB9bXs8s6zRIMtangj4iAwN4WBQdNkz_4BaLjuog1sKXVOk3wOWPgLTTI8i4z8ELVFwwoGZY=&amp;lang=sage&amp;interacts=eJyLjgUAARUAuQ==" rel="nofollow noreferrer">Run it on SageMathCell!</a></p>
<pre><code>f=lambda n:sum(gcd(i,n)&lt;2 for i in[1..n])
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://esolangs.org/wiki/Fish" rel="nofollow noreferrer">&gt;&lt;&gt; (Fish)</a>, 76 bytes</h1>
<pre><code>0i::?v~~n;
v&amp;~$1\:&amp;:&amp;:&amp;%?v$:&amp;:&amp;%?
/~v?:-2&amp;      &lt;
r \1+\20.
1.   \6
\+r1-20.
</code></pre>
<p><a href="https://mousetail.github.io/Fish/#eyJ0ZXh0IjoiMGk6Oj92fn5uO1xudiZ+JDFcXDomOiY6JiU/diQ6JjomJT9cbi9+dj86LTImICAgICAgPFxuciBcXDErXFwyMC5cbjEuICAgXFw2XG5cXCtyMS0yMC4iLCJpbnB1dCI6IjgiLCJzdGFjayI6IiIsInN0YWNrX2Zvcm1hdCI6Im51bWJlcnMiLCJpbnB1dF9mb3JtYXQiOiJudW1iZXJzIn0=" rel="nofollow noreferrer">Try it</a></p>
</div>
<div id="pu5" class="pu"><h1><a href="https://arturo-lang.io" rel="nofollow noreferrer">Arturo</a>, 34 bytes</h1>
<pre class="lang-arturo prettyprint-override"><code>$-&gt;n[enumerate..1n'x-&gt;2&gt;gcd@[x,n]]
</code></pre>
<p><a href="http://arturo-lang.io/playground?YvInU3" rel="nofollow noreferrer">Try it</a></p>
</div>
<div id="pu6" class="pu"><h1>Regex (ECMAScript), 131 bytes</h1>
<p><em>At least -12 bytes thanks to Deadcode (in chat)</em></p>
<pre><code>(?=((xx+)(?=\2+$)|x+)+)(?=((x*?)(?=\1*$)(?=(\4xx+?)(\5*(?!(xx+)\7+$)\5)?$)(?=((x*)(?=\5\9*$)x)(\8*)$)x*(?=(?=\5$)\1|\5\10)x)+)\10|x
</code></pre>
<p><a href="https://tio.run/##TY5BT4MwGIb/CiNL@D4YbCxj6rBw8rCLBz2Kh4Z1pVoKKXXDib8dO5Il3t6@z/vk6wc90a7UojVh14oD03WjPtn3qIliZ@eF8ae@BbiQbOmPkBOAvg/QhmIdzHGweXrZ2s@nOvbnU1Fs7NBWReJDPpus4s4qRYL5/KZMRlI8WKe303sfbfCv8NrbcTxYHK8stXq8GvrRX14wMs2r0UJxwKiTomSwXYQbxPRcCckAJNGMHqRQDBBnRH1JiT@cyKhrpTDghR6m4gigCI8kU9xUmK2HQXTP9BkEaanu2F4Z4G@rd8QbYP@ByuI83l0xmko3Z3evTlSKg6Op4mznuIFMj42GVDwSloogQHuwJm7vRpq1jBoQGNXUlBVoxLJRXSNZJBsOYuF4YeYtnNpev30v/R3jcJ1s/wA" rel="nofollow noreferrer">Try it online!</a></p>
<p>Output is the length of the match.</p>
<p>ECMAScript regexes make it extremely hard to count anything. Any backref defined outside a loop will be constant during the loop, any backref defined inside a loop will be reset when looping. Thus, the only way to carry state across loop iterations is using the current match position. That’s a single integer, and it can only decrease (well, the position increases, but the length of the tail decreases, and that’s what we can do math to).</p>
<p>Given those restrictions, simply counting coprime numbers seems impossible. Instead, we use <a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function#Euler%27s_product_formula" rel="nofollow noreferrer">Euler’s formula</a> to compute the totient.</p>
<p>Here’s how it looks like in pseudocode:</p>
<pre><code>N = input
Z = largest prime factor of N
P = 0

do:
   P = smallest number &gt; P that’s a prime factor of N
   N = N - (N / P)
while P != Z

return N
</code></pre>
<p>There are two dubious things about this.</p>
<p>First, we don’t save the input, only the current product, so how can we get to the prime factors of the input? The trick is that (N - (N / P)) has the same prime factors &gt; P as N. It may gain new prime factors &lt; P, but we ignore those anyway. Note that this only works because we iterate over the prime factors from smallest to greatest, going the other way would fail.</p>
<p>Second, we have to remember two numbers across loop iterations (P and N, Z doesn’t count since it’s constant), and I just said that was impossible! Thankfully, we can swizzle those two numbers in a single one. Note that, at the start of the loop, N will always be a multiple of Z, while P will always be less than Z. Thus, we can just remember N + P, and extract P with a modulo.</p>
<p>Here’s the slightly more detailed pseudo-code:</p>
<pre><code>N = input
Z = largest prime factor of N

do:
   P = N % Z
   N = N - P
   P = smallest number &gt; P that’s a prime factor of N
   N = N - (N / P) + P
while P != Z

return N - Z
</code></pre>
<p>And here’s the commented regex:</p>
<pre><code># \1 = largest prime factor of N
# Computed by repeatedly dividing N by its smallest factor
(?= ( (xx+) (?=\2+$) | x+ )+ )

(?=
        # Main loop!
        (
                # \4 = N % \1, N -= \4
                (x*?) (?=\1*$)

                # \5 = next prime factor of N
                (?= (\4xx+?) (\5* (?!(xx+)\7+$) \5)? $ )

                # \8 = N / \5, \9 = \8 - 1, \10 = N - \8
                (?= ((x*) (?=\5\9*$) x) (\8*) $ )

                x*
                (?=
                        # if \5 = \1, break.
                        (?=\5$) \1
                |
                        # else, N = (\5 - 1) + (N - B)
                        \5\10
                )
                x
        )+
) \10
</code></pre>
<p>And as a bonus…</p>
<h2>Regex <code>🐝</code> (ECMAScript 2018, number of matches), 23 bytes</h2>
<pre><code>x(?&lt;!^\1*(?=\1*$)(x+x))
</code></pre>
<p><a href="https://tio.run/##DY3BCoJAFEV/5SWB76U@ctGmMmnRD9TSDIdpGC1TGYcawX@32dwDhwP3Jb5ilKYZbNL1T7UYyOCq9MUNeLOm6TQb8asWh/lx9binG8wzv2tCFzmipeKxbaTCNE5SiiHUIR0KZj4bIybcbYnfahqRSv6IAR1kJ5B9N/at4rbXXkQQ7iH0wMAFbNSghEVHPreyRkMwz1CUxK3qtK394x8" rel="nofollow noreferrer">Try it online!</a></p>
<p>Output is the number of matches. ECMAScript 2018 introduces variable-length look-behind (evaluated right-to-left), which makes it possible to simply count all numbers coprime with the input.</p>
<p>It turns out this is independently the same method used by <a href="https://codegolf.stackexchange.com/a/83550/17216">Leaky Nun's Retina solution</a>, and the regex is even the same length (<a href="https://tio.run/##DcrBCoJAEIDhV5kk2JnUIQ9dKpMOvUAd1WixZbVMZXepFXx38/TDx/@SX2kr0wwu7vqnmg2kcFX64ge8OdN0mo38PWbMVuh9SEWyWWN2TO9FEhL5@cG2bSqFSRQnFIHQgg45M5@NkSPutsRvNVqkkj9yQA/pCaq@s32ruO31AiGIPYglGPiAjRqUdOhp2V1VoyGYJshL4lZ12tVE8x8" rel="nofollow noreferrer">and interchangeable</a>). I'm leaving it here because it may be of interest that this method works in ECMAScript 2018 (and not just .NET).</p>
<pre><code>                        # Implicitly iterate from the input to 0
x                       # Don’t match 0
 (?&lt;!                 ) # Match iff there is no...
                 (x+x)  # integer &gt;= 2...
         (?=\1*$)       # that divides the current number...
     ^\1*               # and also divides the input
</code></pre>
</div>
<div id="pu7" class="pu"><h1>Julia 1.x, 22 bytes</h1>
<pre><code>!n=sum(gcd.(1:n,n).&lt;2)
</code></pre>
<p>This is the same as the old solution, but using newer features of the language, as the original solution dates back to something like Julia 0.4. This solution uses function broadcasting to achieve the result more efficiently.</p>
<hr />
<h1>Julia, 25 bytes</h1>
<pre><code>!n=sum(i-&gt;gcd(i,n)&lt;2,1:n)
</code></pre>
<p>It's simple - the <code>sum</code> function allows you to give it a function to apply before summing - basically the equivalent of running <code>map</code> and then <code>sum</code>. This directly counts the number of relatively prime numbers less than <code>n</code>.</p>
</div>
<div id="pu8" class="pu"><h1><a href="https://github.com/Lyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a> <code>s</code>, 5 bytes</h1>
<pre><code>ɾ$ġ1=
</code></pre>
<p><a href="https://lyxal.pythonanywhere.com?flags=s&amp;code=%C9%BE%24%C4%A11%3D&amp;inputs=8&amp;header=&amp;footer=" rel="nofollow noreferrer">Try it Online!</a></p>
<p>No totient builtin</p>
<p>Inclusive range, swap with input, gcd, equal to 1, sum</p>
</div>
<div id="pu9" class="pu"><h1><a href="https://github.com/barbuz/Husk" rel="nofollow noreferrer">Husk</a>, 7 bytes</h1>
<pre><code>ṁo=1⌋¹ḣ
</code></pre>
<p><a href="https://tio.run/##yygtzv6f@6ip8eGOxYYGBv8f7mzMtzV81NN9aCdQ5P9/AA" rel="nofollow noreferrer" title="Husk – Try It Online">Try it online!</a></p>
<pre><code>ṁo=1⌋¹ḣ
ṁ     ḣ     # sum of function applied to 1..input
 o          # join 2 functions:
    ⌋¹      # greatest common divisor with input
  =1        # equals 1
</code></pre>
</div>
<div id="pu10" class="pu"><h1><a href="https://github.com/JCumin/Brachylog" rel="nofollow noreferrer">Brachylog v2</a>, 16 bytes</h1>
<pre><code>{&gt;ℕ≜;?ḋˢ{⊇ᵛ!}Ė}ᶜ
</code></pre>
<p><a href="https://tio.run/##AVgAp/9icmFjaHlsb2cy/3t3IiAtPiAidz/ihrDigoLhuol94bWQ/3s@4oSV4omcOz/huIvLonviiofhtZshfcSWfeG2nP//WzEsMiwzLDgsOSwyNiw0NCwxMDVd" rel="nofollow noreferrer" title="Brachylog – Try It Online">Try it online!</a></p>
<pre><code>{             }ᶜ    Count the number of possible ways that:
  ℕ≜                some non-negative integer
 &gt;                  less than the input
    ;?              and the input
      ḋˢ            have prime factorizations
        {⊇ᵛ!}       the largest shared subset of which
             Ė      is empty.
</code></pre>
<h1><a href="https://github.com/JCumin/Brachylog" rel="nofollow noreferrer">Brachylog v2</a>, 16 bytes</h1>
<pre><code>⟨⟦₅zg⟩{ḋˢ⊇ᵛ!Ė}ˢl
</code></pre>
<p><a href="https://tio.run/##AVsApP9icmFjaHlsb2cy/3t3IiAtPiAidz/ihrDigoLhuol94bWQ/@KfqOKfpuKChXpn4p@pe@G4i8ui4oqH4bWbIcSWfcuibP//WzEsMiwzLDgsOSwyNiw0NCwxMDVd" rel="nofollow noreferrer" title="Brachylog – Try It Online">Try it online!</a></p>
<pre><code>   z                Cycling zip
 ⟦₅                 the range from 0 to one less than the input
⟨   g⟩              with a list containing only the input.
      {      }ˢ     Map where possible over the pairs:
       ḋˢ           the prime factorizations'
         ⊇ᵛ!        largest shared subset
            Ė       is empty.
               l    For how many pairs did it succeed?
</code></pre>
<p>A nuance that my explanations fail to capture is that <code>ḋ</code> fails given an input of 1, so if <code>ḋˢ</code> is given a list containing 1, the 1 is essentially discarded and ignored--so the <code>⊇ᵛ!</code> (which is really &quot;find any common subset, then discard all of this predicate's choice points&quot;, hence the braces in the first solution) of the remaining single number is its entire prime factorization, decidedly not empty, unless the list was nothing but 1s in which case everything is empty.</p>
</div>
<div id="pu11" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 42 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>n=&gt;(g=k=&gt;k&amp;&amp;((k/n|0)*k%n&gt;n-2)+g(k-1))(n*n)
</code></pre>
<p><a href="https://tio.run/##dc1LDoIwFIXhuavoRHKLqX1YCQ7avRCERktuCRBH7r3SxA5s4vR8yfmf3atb@@UxbwzDfYijiWgsOOON9VUF4Dm@Ba39ES0yRU8OPJOUAtZIYx9wDdNwnoKDEfaZEMI5kYdfUP/gkkEV0GbQBdwyNGWjSZIa5ZfWX1GiECmuO6VKGz8" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<p>Direct port of <a href="https://codegolf.stackexchange.com/a/145316/69850">Dennis' solution</a> (<em>&lt;- also see the explanation in that answer</em>) to JavaScript.</p>
<p>Alternatives:</p>
<pre class="lang-javascript prettyprint-override"><code>n=&gt;(g=k=&gt;k&amp;&amp;g(k-1)+!(~((k/n|0)*k)%n))(n*n)
n=&gt;(g=k=&gt;k&amp;&amp;g(k-1)+!(((k/n|0)*k-1)%n))(n*n)
n=&gt;(g=k=&gt;k&amp;&amp;g(k-1)+!((k/n|0)*k%n-n+1))(n*n)
f=(n,k=0)=&gt;k&lt;n*n&amp;&amp;((k/n|0)*k%n&gt;n-2)+f(n,k+1)
</code></pre>
</div>
<div id="pu12" class="pu"><h1><a href="https://github.com/ETHproductions/japt" rel="nofollow noreferrer">Japt</a> <a href="https://codegolf.meta.stackexchange.com/a/14339/"><code>-mx</code></a>, 2 <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>jN
</code></pre>
<p><a href="https://petershaggynoble.github.io/Japt-Interpreter/?v=1.4.6&amp;flags=LW14&amp;code=ak4&amp;input=MTA1" rel="nofollow noreferrer">Try it here</a></p>
</div>
<div id="pu13" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C (gcc)</a>, <s>67</s> 65 bytes</h1>



<pre class="lang-c prettyprint-override"><code>f(x,a,b,y,z){for(z=y=x;a=y--;z-=b&gt;1)for(b=x;a^=b^=a^=b%=a;);x=z;}
</code></pre>

<p><a href="https://tio.run/##bcyxCsIwEIDh3ccoFO4gAaMVlON8klJIIpEORikdkpQ@e0pmb/mHb/i9fntfa4CkrHIqq4Jb@C5QOHMiy1lrKprd02Bj13BiN3Frz5aQEhfa68fOEXA7/ZY5rgG6/jXGTgUwiPSHFwmvEt4lfIjPQdJBVHO@Nd7rAQ" rel="nofollow noreferrer" title="C (gcc) – Try It Online">Try it online!</a></p>

<p>Edit: Removed temp variable.</p>

<p>Edit2: -1 thanks to <a href="https://codegolf.stackexchange.com/questions/77270/greatest-common-divisor/152046#152046">@HowChen</a></p>

<p>Slightly less golfed</p>

<pre class="lang-c prettyprint-override"><code>f(x,a,b,y,z){
  // counts y NOT coprime with x and subtract
  for(z=y=x;a=y--;z-=b&gt;1)
    // compute GCD
    for(b=x;a^=b^=a^=b%=a;);
  x=z;
}
</code></pre>
</div>
<div id="pu14" class="pu"><h1>TI-84 BASIC, 19 bytes</h1>

<pre><code>Prompt A:sum(seq(1=gcd(A,B),B,1,A
</code></pre>
</div>
<div id="pu15" class="pu"><h1><a href="http://pari.math.u-bordeaux.fr/" rel="nofollow noreferrer">Pari/GP</a>, 24 bytes</h1>

<pre><code>n-&gt;sum(i=1,n,gcd(i,n)&lt;2)
</code></pre>

<p><a href="https://tio.run/##DcoxCoAwDEDRqwSnBBJonW3vIkpLBmOJev7Y5Q@PP3ZX6SMaFAiT@nwXasls3I8TlY22laLdjjaPzJBTYhiu9k5ZQOpMQyOi@AE" rel="nofollow noreferrer" title="Pari/GP – Try It Online">Try it online!</a></p>
</div>
<div id="pu16" class="pu"><h1>Japt <code>-mx</code>, <s>7</s> 5 bytes</h1>
<pre><code>yN ¥1
</code></pre>
<p><a href="https://ethproductions.github.io/japt/?v=1.4.6&amp;code=eU4gpTE=&amp;input=MTA1Ci1teA==" rel="nofollow noreferrer">Run it online</a></p>
<p>-2 bytes thanks to <a href="https://codegolf.stackexchange.com/users/58974/shaggy">Shaggy</a></p>
</div>
<div id="pu17" class="pu"><h1>JavaScript (ES6), 53 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>f=(n,k=n)=&gt;k--&amp;&amp;(C=(a,b)=&gt;b?C(b,a%b):a&lt;2)(n,k)+f(n,k)
</code></pre>
<p><a href="https://tio.run/##dc3BDsIgDIDhu0/BxaWN4AbiMo3oYU8CcxjdAsYZXx@HkYMknprma/rf9EtP3eN6fzLnz30IVoGjg3KojgNjRQGtAk3NvJpTC4bqpcG9PgiMZ7iynxE67yY/9uvRX8ACRySElCXhi18Q/2CTQGTQJJAZ7BLUeaOOEhv5Lym/IqpMeLWdKVaa8AY" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
</div>
<div id="pu18" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>, 44 bytes</h1>

<pre class="lang-python prettyprint-override"><code>lambda n:sum(k/n*k%n&gt;n-2for k in range(n*n))
</code></pre>
<p>This uses the same method to identify coprimes as <a href="https://codegolf.stackexchange.com/a/104681/12012">my answer to “Coprimes up to N”</a>.</p>
<p><a href="https://tio.run/##FcyxDoIwGEXhWZ/iLg2F/EYpaJQEnsSlplZJ5UIqDj59tdvJN5zluz5nmuTR45pedro5C3bvz6TDnlVQHLgzfo4IGIlo@bhrVizLlJEZdS0wgkZwFlz@fRK0raA@HMtuu1niyBWFahz6Acq4AgqaAq/z5gc" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>
</div>
<div id="pu19" class="pu"><h1>J, 9 bytes</h1>

<pre><code>(-~:)&amp;.q:
</code></pre>

<p>This is based on the Jsoftware's <a href="http://code.jsoftware.com/wiki/Essays/Totient_Function" rel="noreferrer">essay</a> on totient functions.</p>

<p>Given <em>n</em> = <em>p</em><sub>1</sub><sup><em>e</em><sub>1</sub></sup> ∙ <em>p</em><sub>2</sub><sup><em>e</em><sub>2</sub></sup> ∙∙∙ <em>p</em><sub><em>k</em></sub><sup><em>e</em><sub><em>k</em></sub></sup> where <em>p</em><sub><em>k</em></sub> is a prime factor of <em>n</em>, the totient function φ(<em>n</em>) = φ(<em>p</em><sub>1</sub><sup><em>e</em><sub>1</sub></sup>) ∙ φ(<em>p</em><sub>2</sub><sup><em>e</em><sub>2</sub></sup>) ∙∙∙ φ(<em>p</em><sub><em>k</em></sub><sup><em>e</em><sub><em>k</em></sub></sup>) = (<em>p</em><sub>1</sub> - 1) <em>p</em><sub>1</sub><sup><em>e</em><sub>1</sub> - 1</sup> ∙ (<em>p</em><sub>2</sub> - 1) <em>p</em><sub>2</sub><sup><em>e</em><sub>2</sub> - 1</sup> ∙∙∙ (<em>p</em><sub><em>k</em></sub> - 1) <em>p</em><sub><em>k</em></sub><sup><em>e</em><sub><em>k</em></sub> - 1</sup>.</p>

<h2>Usage</h2>

<pre><code>   f =: (-~:)&amp;.q:
   (,.f"0) 1 2 3 8 9 26 44 105
  1  1
  2  1
  3  2
  8  4
  9  6
 26 12
 44 20
105 48
   f 12345
6576
</code></pre>

<h2>Explanation</h2>

<pre><code>(-~:)&amp;.q:  Input: integer n
       q:  Prime decomposition. Get the prime factors whose product is n
(   )&amp;     Operate on them
  ~:         Nub-sieve. Create a mask where 1 is the first occurrence
             of a unique value and 0 elsewhere
 -           Subtract elementwise between the prime factors and the mask
     &amp;.q:  Perform the inverse of prime decomposition (Product of the values)
</code></pre>
</div>
<div id="pu20" class="pu"><h2>Python 2, 44 bytes</h2>

<pre class="lang-python prettyprint-override"><code>f=lambda n,d=1:d/n or-f(d)*(n%d&lt;1)-~f(n,d+1)
</code></pre>
<p>Less golfed:</p>
<pre class="lang-python prettyprint-override"><code>f=lambda n:n-sum(f(d)for d in range(1,n)if n%d&lt;1)
</code></pre>
<p>Uses the formula that the Euler totients of the divisors of <code>n</code> have a sum of <code>n</code>:</p>
<p><a href="https://i.sstatic.net/k7xiE.png" rel="noreferrer"><img src="https://i.sstatic.net/k7xiE.png" alt="enter image description here" /></a></p>
<p>The value of <code>ϕ(n)</code> can then be recursively computed as <code>n</code> minus the sum over nontrivial divisors. Effectively, this is doing <a href="https://en.wikipedia.org/wiki/M%C3%B6bius_inversion_formula" rel="noreferrer">Möbius inversion</a> on the identity function. I used the same method in a <a href="https://codegolf.stackexchange.com/a/70024/20260">golf to compute the Möbius function</a>.</p>
<p>Thanks to Dennis for saving 1 byte with a better base case, spreading the initial value of <code>+n</code> into <code>+1</code> for each of the <code>n</code> loops, done as <code>-~</code>.</p>
</div>
<div id="pu21" class="pu"><h2>Batch, <s>151</s> <s>145</s> 144 bytes</h2>

<pre><code>@echo off
set t=
for /l %%i in (1,1,%1)do call:g %1 %%i
echo %t%
exit/b
:g
set/ag=%1%%%2
if not %g%==0 call:g %2 %g%
if %2%==1 set/at+=1
</code></pre>

<p>Edit: Saved 4 bytes by removing unnecessary spaces. Saved 1 byte by using <code>+=</code>. Saved 1 byte by clearing <code>t</code> as <code>+=</code> will interpret that as <code>0</code> anyway. Saved 1 byte thanks to @EʀɪᴋᴛʜᴇGᴏʟғᴇʀ.</p>
</div>
<div id="pu22" class="pu"><h1>Factor, 50 bytes</h1>
<pre><code>[ dup iota swap '[ _ gcd nip 1 = ] filter length ]
</code></pre>
<p>Makes a range (<em>iota</em>) <strong>n</strong>, and <em>curries</em> <strong>n</strong> into a function which gets <strong>gcd x n</strong> for all values of <strong>0 &lt;= x &lt;= n</strong>, tests if the result is <strong>1</strong>. <em>Filter</em> the original range on whether the result of <strong>gcd x n</strong> was <strong>1</strong>, and take its <em>length</em>.</p>
</div>
<div id="pu23" class="pu"><h1>Haskell, <s>31</s> 30 bytes</h1>

<pre><code>\n-&gt;sum[1|x&lt;-[1..n],gcd n x&lt;2]
</code></pre>

<p><em>1 byte saved, thanks to @Damien.</em></p>

<p>Selects values with gcd = 1, maps each to 1, then takes the sum. </p>
</div>
<div id="pu24" class="pu"><h1>Ruby, 32 bytes</h1>

<pre><code>-&gt;n{(1..n).count{|i|i.gcd(n)&lt;2}}
</code></pre>

<p>a lambda that takes an integer n, and returns the counts of how many integers in the range (1..n) are coprime with n.</p>
</div>
<div id="pu25" class="pu"><h2>Haskell, 28 bytes</h2>
<pre class="lang-haskell prettyprint-override"><code>f n=sum[1|1&lt;-gcd n&lt;$&gt;[1..n]]
</code></pre>
<p>Uses Haskell's <a href="https://codegolf.stackexchange.com/a/83103/20260">pattern matching of constants</a>. The tricks here are fairly standard for golfing, but I'll explain to a general audience.</p>
<p>The expression <code>gcd n&lt;$&gt;[1..n]</code> maps <code>gcd n</code> onto <code>[1..n]</code>. In other words, it computes the <code>gcd</code> with <code>n</code> of each number from <code>1</code> to <code>n</code>:</p>
<pre><code>[gcd n i|i&lt;-[1..n]]
</code></pre>
<p>From here, the desired output is the number of <code>1</code> entries, but Haskell lacks a <code>count</code> function. The idiomatic way to <code>filter</code> to keep only <code>1</code>'s, and take the resulting <code>length</code>, which is much is too long for golfing.</p>
<p>Instead, the <code>filter</code> is simulated by a list comprehension <code>[1|1&lt;-l]</code> with the resulting list <code>l</code>. Usually, list comprehensions bind values onto variable like in <code>[x*x|x&lt;-l]</code>, but Haskell allows a pattern to be matched against, in this case the constant <code>1</code>.</p>
<p>So, <code>[1|1&lt;-l]</code> generating a <code>1</code> on each match of <code>1</code>, effectively extracting just the <code>1</code>'s of the original list. Calling <code>sum</code> on it gives its length.</p>
</div>
<div id="pu26" class="pu"><h1>Python 2, 57 bytes</h1>



<pre class="lang-python prettyprint-override"><code>f=lambda n,k=1,m=1:n*(k&gt;n)or f(n-(n%k&lt;m%k)*n/k,k+1,m*k*k)
</code></pre>

<p>Test it on <a href="http://ideone.com/RhBbpO" rel="nofollow noreferrer">Ideone</a>.</p>

<h3>Background</h3>

<p>By <a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function#Euler.27s_product_formula" rel="nofollow noreferrer">Euler's product formula</a>,</p>

<p><img src="https://i.sstatic.net/0Adtc.png" alt="Euler&#39;s product formula"></p>

<p>where <strong>&phi;</strong> denotes Euler's totient function and <strong>p</strong> varies only over prime numbers.</p>

<p>To identify primes, we use a corollary of <a href="https://en.wikipedia.org/wiki/Wilson%27s_theorem" rel="nofollow noreferrer">Wilson's theorem</a>:</p>

<p><img src="https://i.sstatic.net/ordYr.png" alt="corollary of Wilson&#39;s theorem"></p>

<h3>How it works</h3>

<p>At all times, the variable <strong>m</strong> will be equal to the square of the factorial of <strong>k - 1</strong>. In fact, we named arguments default to <strong>k = 1</strong> and <strong>m = 0!<sup>2</sup> = 1</strong>.</p>

<p>As long as <strong>k &leq; n</strong>, <code>n*(k&gt;n)</code> evaluates to <strong>0</strong> and the code following <code>or</code> gets executed.</p>

<p>Recall that <code>m%k</code> will yield <strong>1</strong> if <strong>m</strong> is prime and <strong>0</strong> if not. This means that <code>x%k&lt;m%k</code> will yield <strong>True</strong> if and only if both <strong>k</strong> is a prime number and <strong>x</strong> is divisible by <strong>k</strong>.</p>

<p>In this case, <code>(n%k&lt;m%k)*n/k</code> yields <strong>n / k</strong>, and subtracting it from <strong>n</strong> replaces its previous value with <strong>n(1 - 1/k)</strong>, as in Euler's product formula. Otherwise, <code>(n%k&lt;m%k)*n/k</code> yields <strong>0</strong> and <strong>n</strong> remains unchanged.</p>

<p>After computing the above, we increment <strong>k</strong> and multiply <strong>m</strong> by the "old" value of <strong>k<sup>2</sup></strong>, thus maintaining the desired relation between <strong>k</strong> and <strong>m</strong>, then call <strong>f</strong> recursively with the updated arguments.</p>

<p>Once <strong>k</strong> exceeds <strong>n</strong>, <code>n*(k&gt;n)</code> evaluates to <strong>n</strong>, which is returned by the function.</p>
</div>
<div id="pu27" class="pu"><h1>APL, 7 bytes</h1>

<pre><code>+/1=⊢∨⍳
</code></pre>

<p>This is a monadic function train that takes an integer on the right. The approach here is the obvious one: sum (<code>+/</code>) the number of times the GCD of the input and the numbers from 1 to the input (<code>⊢∨⍳</code>) is equal to 1 (<code>1=</code>).</p>

<p><a href="http://tryapl.org/?a=f%20%u2190%20+/1%3D%u22A2%u2228%u2373%20%u22C4%20f%20105&amp;run" rel="nofollow">Try it here</a></p>
</div>
<div id="pu28" class="pu"><h1>MATLAB / Octave, 21 bytes</h1>
<pre><code>@(n)sum(gcd(n,1:n)&lt;2)
</code></pre>
<p>Creates an anonymous function named <code>ans</code> which can be called with the integer <code>n</code> as the only input: <code>ans(n)</code></p>
<p><a href="http://ideone.com/yghvhv" rel="nofollow noreferrer"><strong>Online Demo</strong></a></p>
</div>
<div id="pu29" class="pu"><h1>Python >=3.5, <s>76</s> <s>64</s> 58 bytes</h1>

<p><em>Thanks to LeakyNun for golfing off 12 (!) bytes.</em></p>

<p><em>Thanks to Sp3000 for golfing off 6 bytes.</em></p>

<pre><code>import math
lambda n:sum(math.gcd(n,x)&lt;2for x in range(n))
</code></pre>

<p>I love how readable Python is. This makes sense, even through the golfedness.</p>
</div>
<div id="pu30" class="pu"><h2><a href="https://github.com/urbit/urbit" rel="nofollow noreferrer">Hoon</a>, 56 bytes</h2>
<pre><code>|=
a/@
(lent (skim (gulf 1 a) |=(@ =(1 d:(egcd +&lt; a)))))
</code></pre>
<p>Measure the length of the list [1...a] after keeping all the elements where GCD(i, a) == 1</p>
</div>
<div id="pu31" class="pu"><p><strong>Common Lisp, 58 bytes</strong></p>

<pre><code>(defun o(x)(loop for i from 1 to x if (=(gcd x i)1)sum 1))
</code></pre>

<p>This is a simple loop which counts up 1 to the given n and increments the sum if gcd = 1. I use the function name o since t is the true boolean value. Not nearly the shortest but fairly simple.</p>
</div>
<div id="pu32" class="pu"><h2>PowerShell v2+, 72 bytes</h2>

<pre><code>param($n)1..$n|%{$a=$_;$b=$n;while($b){$a,$b=$b,($a%$b)};$o+=!($a-1)};$o
</code></pre>

<p>PowerShell doesn't have a GCD function available to it, so I had to roll my own.</p>

<p>This takes input <code>$n</code>, then ranges from <code>1</code> to <code>$n</code> and pipes those into a loop <code>|%{...}</code>. Each iteration we set two helper variables <code>$a</code> and <code>$b</code> and then execute a GCD <code>while</code> loop. Each iteration we're checking that <code>$b</code> is still non-zero, and then saving <code>$a%$b</code> to <code>$b</code> and the previous value of <code>$b</code> to <code>$a</code> for the next loop. We then accumulate whether <code>$a</code> is equal to <code>1</code> in our output variable <code>$o</code>. Once the for loop is done, we place <code>$o</code> on the pipeline and output is implicit.</p>

<p>As an example of how the <code>while</code> loop works, consider <code>$n=20</code> and we're on <code>$_=8</code>. The first check has <code>$b=20</code>, so we enter the loop. We first calculate <code>$a%$b</code> or <code>8%20 = 8</code>, which gets set to <code>$b</code> at the same time that <code>20</code> gets set to <code>$a</code>. Check <code>8=0</code>, and we enter the second iteration. We then calculate <code>20%8 = 4</code> and set that to <code>$b</code>, then set <code>$a</code> to <code>8</code>. Check <code>4=0</code>, and we enter the third iteration. We calculate <code>8%4 = 0</code> and set that to <code>$b</code>, then set <code>$a</code> to <code>4</code>. Check <code>0=0</code> and we exit the loop, so the <em>GCD(8,20)</em> is <code>$a = 4</code>. Thus, <code>!($a-1) = !(4-1) = !(3) = 0</code> so <code>$o += 0</code> and we don't count that one.</p>
</div>
<div id="pu33" class="pu"><h2>05AB1E, 7 bytes</h2>
<pre><code>Lvy¹¿i¼
</code></pre>
<p><strong>Explained</strong></p>
<pre><code>Lv        # for each x in range(1,n)
  y¹¿     # GCD(x,n)
     i¼   # if true (1), increase counter
          # implicitly display counter
</code></pre>
<p><a href="http://05ab1e.tryitonline.net/#code=THZ5wrnCv2nCvA&amp;input=MTA1" rel="nofollow noreferrer">Try it online</a></p>
</div>
<div id="pu34" class="pu"><h1>Retina, <s>36</s> 29 bytes</h1>
<p>7 bytes thanks to Martin Ender.</p>
<pre><code>.+
$*
(?!(11+)\1*$(?&lt;=^\1+)).
</code></pre>
<p><a href="http://retina.tryitonline.net/#code=LisKJCoKKD8hKDExKylcMSokKD88PV5cMSspKS4&amp;input=MTA1" rel="nofollow noreferrer">Try it online!</a></p>
<h2>Explanation</h2>
<p>There are two stages (commands).</p>
<h3>First stage</h3>
<pre><code>.+
$*
</code></pre>
<p>It is a simple regex substitution, converting the input to that many ones.</p>
<p>For example, <code>5</code> would be converted to <code>11111</code>.</p>
<h3>Second stage</h3>
<pre><code>(?!(11+)\1*$(?&lt;=^\1+)).
</code></pre>
<p>This regex tries to match the positions which satisfy the condition (co-prime with input), and then return the number of matches.</p>
</div>
<div id="pu35" class="pu"><h2>Mathematica, <s>27</s> 22 bytes</h2>

<pre><code>Range@#~GCD~#~Count~1&amp;
</code></pre>

<p>An unnamed function that takes and returns an integer.</p>

<p>Not much to explain here, except that <code>@</code> is prefix notation for function calls and <code>~...~</code> is (left-associative) infix notation, so the above is the same as:</p>

<pre><code>Count[GCD[Range[#], #], 1] &amp;
</code></pre>
</div>
<div id="pu36" class="pu"><h2>JavaScript (ES6), 67 bytes</h2>

<pre><code>f=n=&gt;[...Array(n)].reduce(r=&gt;r+=g(n,++i)&lt;2,i=0,g=(a,b)=&gt;b?g(b,a%b):a)
</code></pre>
</div>
<div id="pu37" class="pu"><h2>Pyke, 5 bytes</h2>
<pre><code>m.H1/
</code></pre>
<p><a href="http://pyke.catbus.co.uk/?code=m.H1%2F&amp;input=105&amp;warnings=0" rel="noreferrer">Try it here!</a></p>
<pre><code>count(map(gcd, range(input)), 1)
</code></pre>
</div>
<div id="pu38" class="pu"><h1>Actually, 11 bytes</h1>

<pre><code>;╗R`╜g`M1@c
</code></pre>

<p><a href="http://actually.tryitonline.net/#code=O-KVl1Jg4pWcZ2BNMUBj&amp;input=NDQ" rel="nofollow">Try it online!</a></p>

<h3>Explanation</h3>

<pre><code>;╗R`╜g`M1@c   register stack             remarks

                       44
;                      44 44
 ╗            44       44
  R           44       [1 2 3 .. 44]
       M      44       10                for example
    ╜         44       10 44
     g        44       2
              44       [1 2 1 .. 44]     gcd of each with register
        1     44       [1 2 1 .. 44] 1
         @    44       1 [1 2 1 .. 44]
          c   44       20                count
</code></pre>

<h2>With built-in</h2>

<pre><code>▒
</code></pre>

<p><a href="http://actually.tryitonline.net/#code=4paS&amp;input=NDQ" rel="nofollow">Try it online!</a></p>
</div>
<div id="pu39" class="pu"><h1>Jelly, 4 bytes</h1>

<pre><code>Rgċ1
</code></pre>

<p><a href="http://jelly.tryitonline.net/#code=UmfEizE&amp;input=&amp;args=NDQ">Try it online!</a></p>

<h3>Explanation</h3>

<pre><code>Rgċ1   Main monadic chain. Argument: z

R      Yield [1 2 3 .. z].
 g     gcd (of each) (with z).
  ċ1   Count the number of occurrences of 1.
</code></pre>

<h2>With built-in</h2>

<pre><code>ÆṪ
</code></pre>

<p><a href="http://jelly.tryitonline.net/#code=w4bhuao&amp;input=&amp;args=NDQ">Try it online!</a></p>

<h3>Explanation</h3>

<pre><code>ÆṪ   Main monadic chain. Argument: z

ÆṪ   Totient of z.
</code></pre>
</div>
<div id="pu40" class="pu"><h1>Pyth, 6 bytes</h1>
<pre><code>smq1iQ
</code></pre>
<p><a href="http://pyth.herokuapp.com/?code=smq1iQ&amp;input=44&amp;debug=0" rel="nofollow noreferrer">Try it online!</a></p>
<pre><code>/iLQQ1
</code></pre>
<p><a href="http://pyth.herokuapp.com/?code=%2FiLQQ1&amp;input=44&amp;debug=0" rel="nofollow noreferrer">Try it online!</a></p>
<h2>Explanation</h2>
<pre><code>smq1iQ     input as Q
smq1iQdQ   implicitly fill variables

 m     Q   for d in [0 1 2 3 .. Q-1]:
    iQd        gcd of Q and d
  q1           equals 1? (1 if yes, 0 if no)
s          sum of the results


/iLQQ1     input as Q

 iLQQ      gcd of each in [0 1 2 3 .. Q-1] with Q
/    1     count the number of occurrences of 1
</code></pre>
</div>
<div id="pu41" class="pu"><h1>MATL, 7 bytes</h1>

<pre><code>t:Zd1=s
</code></pre>

<p>You can <a href="http://matl.tryitonline.net/#code=dDpaZDE9cw&amp;input=MTA1">TryItOnline</a>. Simplest idea, make a vector 1 to N, and taken gcd of each element with N (<code>Zd</code> does gcd). Then, find which elements are equal to 1, and sum the vector to get the answer.</p>
</div>
<div id="pu42" class="pu"><h1>J, 11 bytes</h1>

<pre><code>+/@(1=+.)i.
</code></pre>

<h2>Usage</h2>

<pre><code>&gt;&gt; f =: +/@(1=+.)i.
&gt;&gt; f 44
&lt;&lt; 20
</code></pre>

<p>where <code>&gt;&gt;</code> is STDIN and <code>&lt;&lt;</code> is STDOUT.</p>

<h2>Explanation</h2>

<pre><code>+/ @ ( 1 = +. ) i.
               │
   ┌───────────┴┐
 +/@(1=+.)      i.
   │
 ┌─┼──┐
+/ @ 1=+.
    ┌─┼─┐
    1 = +.

&gt;&gt; (i.) 44            NB. generate range
&lt;&lt; 0 1 2 3 4 ... 43
&gt;&gt; (+.i.) 44          NB. calculate gcd of each with input
&lt;&lt; 44 1 2 1 4 ... 1
&gt;&gt; ((1=+.)i.) 44      NB. then test if each is one (1 if yes, 0 if no)
&lt;&lt; 0 1 0 1 0 ... 1
&gt;&gt; (+/@(1=+.)i.) 44   NB. sum of all the tests
&lt;&lt; 20
</code></pre>
</div>
<div id="pu43" class="pu"><h1><a href="https://github.com/JCumin/Brachylog" rel="nofollow">Brachylog</a>, 25 bytes</h1>

<pre><code>:{:1e.$pdL,?$pd:LcCdC}fl.
</code></pre>

<h3>Explanation</h3>

<p>Brachylog has no GCD built-in yet, so we check that the two numbers have no prime factors in common.</p>

<ul>
<li><p>Main predicate:</p>

<pre><code>:{...}fl.             Find all variables which satisfy predicate 1 when given to it as
                      output and with Input as input.
                      Unify the Output with the length of the resulting list
</code></pre></li>
<li><p>Predicate 1:</p>

<pre><code>:1e.                  Unify Output with a number between Input and 1
    $pdL              L is the list of prime factors of Output with no duplicates
        ,
         ?$pd:LcC     C is the concatenation of the list of prime factors of Input with
                      no duplicates and of L
                 dC   C with duplicates removed is still C
</code></pre></li>
</ul>
</div>
<div id="pu44" class="pu"><h1><a href="http://perl6.org" rel="nofollow">Perl 6</a>, <s> 26 24 </s> 22 bytes</h1>



<pre class="lang-perl6 prettyprint-override"><code><s>{[+] (^$^n Xgcd $n) X== 1}
{+grep 2&gt;*,(^$_ Xgcd$_)}</s>
{[+] 2 X&gt;(^$_ Xgcd$_)}</code></pre>

<h3>Explanation:</h3>

<pre class="lang-perl6 prettyprint-override"><code>{
  [+] # reduce using &amp;infix:&lt;+&gt;
    2
    X[&gt;] # crossed compared using &amp;infix:«&gt;»
    (
      ^$_    # up to the input ( excludes input )
      X[gcd] # crossed using &amp;infix:&lt;gcd&gt;
      $_     # the input
    )
}
</code></pre>

<h3>Example:</h3>

<pre class="lang-perl6 prettyprint-override"><code>#! /usr/bin/env perl6
use v6.c;

my &amp;φ = {[+] 2 X&gt;(^$_ Xgcd$_)};

say φ(1) # 1
say φ(2) # 1
say φ(3) # 2
say φ(8) # 4
say φ(9) # 6
say φ(26) # 12
say φ(44) # 20
say φ(105) # 48

say φ 12345 # 6576
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/83533/">83533</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




