<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::QNNN</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
  <!-- TXXX -->
<tr d-ix="0"><td>110</td><td>Pascal</td><td>230907T120000Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/265012#265012">Kai Burg</a></td></tr>
<tr d-ix="1"><td>096</td><td>Python 3.11</td><td>230906T195504Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/264996#264996">Oliver</a></td></tr>
<tr d-ix="2"><td>016</td><td>K ngn/k</td><td>230906T022706Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/264957#264957">Bubbler</a></td></tr>
<tr d-ix="3"><td>013</td><td>Jelly</td><td>210928T033146Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/235779#235779">Bubbler</a></td></tr>
<tr d-ix="4"><td>030</td><td>UGL</td><td>160420T143556Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/78107#78107">Leaky Nu</a></td></tr>
<tr d-ix="5"><td>015</td><td>Pyth</td><td>160420T143906Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/78108#78108">Leaky Nu</a></td></tr>
<tr d-ix="6"><td>012</td><td>Japt</td><td>210713T115410Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/231295#231295">Shaggy</a></td></tr>
<tr d-ix="7"><td>5614</td><td>MMIX</td><td>210429T152350Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/224672#224672">NoLonger</a></td></tr>
<tr d-ix="8"><td>049</td><td>Python 3</td><td>210428T092741Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/224583#224583">SegFault</a></td></tr>
<tr d-ix="9"><td>017</td><td>Jelly</td><td>210427T213658Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/224560#224560">caird co</a></td></tr>
<tr d-ix="10"><td>061</td><td>Ral</td><td>200419T131522Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/203671#203671">Endenite</a></td></tr>
<tr d-ix="11"><td>053</td><td>Io</td><td>200326T050149Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/201736#201736">user9206</a></td></tr>
<tr d-ix="12"><td>053</td><td>Erlang escript</td><td>200326T045741Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/201735#201735">user9206</a></td></tr>
<tr d-ix="13"><td>022</td><td>APL Dyalog Unicode</td><td>200323T022029Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/201554#201554">Bubbler</a></td></tr>
<tr d-ix="14"><td>047</td><td>Haskell</td><td>200322T182623Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/201529#201529">MLavrent</a></td></tr>
<tr d-ix="15"><td>081</td><td>Verilog Icarus Verilog</td><td>200321T154903Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/201472#201472">Zirconiu</a></td></tr>
<tr d-ix="16"><td>036</td><td>C gcc</td><td>200319T151310Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/201372#201372">S.S. Ann</a></td></tr>
<tr d-ix="17"><td>067</td><td>Tcl</td><td>171021T005221Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/145901#145901">sergiol</a></td></tr>
<tr d-ix="18"><td>090</td><td>brainfuck</td><td>180323T111430Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/160049#160049">Jo King</a></td></tr>
<tr d-ix="19"><td>052</td><td>R</td><td>141022T204759Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/40190#40190">MickyT</a></td></tr>
<tr d-ix="20"><td>035</td><td>Haskell</td><td>141022T135507Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/40172#40172">proud ha</a></td></tr>
<tr d-ix="21"><td>085</td><td>Ceylon</td><td>151122T131810Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/64502#64502">Paŭlo Eb</a></td></tr>
<tr d-ix="22"><td>274</td><td>Java</td><td>160617T212926Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/83204#83204">The SE I</a></td></tr>
<tr d-ix="23"><td>nan</td><td>Binary lambda calculus</td><td>160628T002240Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/83924#83924">Anders K</a></td></tr>
<tr d-ix="24"><td>028</td><td>Julia</td><td>160531T225450Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/81033#81033">Dennis</a></td></tr>
<tr d-ix="25"><td>026</td><td>J</td><td>141022T140457Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/40174#40174">algorith</a></td></tr>
<tr d-ix="26"><td>040</td><td>Coq</td><td>160315T042323Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/75568#75568">Anders K</a></td></tr>
<tr d-ix="27"><td>083</td><td>Mouse2002</td><td>151215T012251Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/66633#66633">cat</a></td></tr>
<tr d-ix="28"><td>122</td><td>Go</td><td>151121T031731Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/64440#64440">cat</a></td></tr>
<tr d-ix="29"><td>070</td><td>Tiny Lisp</td><td>151122T141557Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/64503#64503">Paŭlo Eb</a></td></tr>
<tr d-ix="30"><td>034</td><td>Javascript ES6</td><td>141025T093010Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/40317#40317">kitcar20</a></td></tr>
<tr d-ix="31"><td>4436</td><td>Haskell</td><td>141022T221321Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/40193#40193">FireFly</a></td></tr>
<tr d-ix="32"><td>034</td><td>Javascript with lambdas</td><td>141022T222444Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/40194#40194">Qwertiy</a></td></tr>
<tr d-ix="33"><td>065</td><td>Ruby</td><td>141022T182229Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/40185#40185">britisht</a></td></tr>
<tr d-ix="34"><td>019</td><td>Pyth</td><td>141022T165315Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/40182#40182">isaacg</a></td></tr>
<tr d-ix="35"><td>031</td><td>APL</td><td>141022T141707Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/40175#40175">Shujal</a></td></tr>
<tr d-ix="36"><td>030</td><td>GolfScript</td><td>141022T122238Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/40169#40169">Peter Ta</a></td></tr>
<tr d-ix="37"><td>069</td><td>Haskell</td><td>141022T120542Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/40167#40167">SophR</a></td></tr>
<tr d-ix="38"><td>046</td><td>Mathematica</td><td>141022T100202Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/40159#40159">Martin E</a></td></tr>
<tr d-ix="39"><td>050</td><td>J</td><td>141022T084845Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/40153#40153">jpjacobs</a></td></tr>
<tr d-ix="40"><td>045</td><td>Python 2.7.8</td><td>141022T073432Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/40151#40151">Falko</a></td></tr>
<tr d-ix="41"><td>034</td><td>JavaScript ES6</td><td>141022T071531Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/40149#40149">core1024</a></td></tr>
<tr d-ix="42"><td>034</td><td>JavaScript</td><td>141022T071439Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/40148#40148">Optimize</a></td></tr>
<tr d-ix="43"><td>041</td><td>C</td><td>141022T051445Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/40144#40144">feersum</a></td></tr>
<tr d-ix="44"><td>067</td><td>Racket</td><td>141022T050121Z</td><td><a href="https://codegolf.stackexchange.com/questions/40141/the-ackermann-function/40143#40143">Matthew </a></td></tr>
</table>
<div id="pu0" class="pu"><h2>Pascal, 110 B</h2>
<p>To prevent death-by-boredom victims, the <a href="https://RosettaCode.org/wiki/Ackermann_function#Pascal" rel="nofollow noreferrer">boilerplate recursive definition</a> has been omitted.
Using the boilerplate recursive definition as reference, you can <em>save 1 byte</em> in code length by doing the following:</p>
<ul>
<li><em>Presume</em> the <code>m = 0</code> case the default case.
Do not wrap it in an <code>if</code> statement, just calculate <code>A ≔ n + 1</code> (and possibly <em>overwrite</em> this value).</li>
<li>This necessitates a different expression for the <code>m ≠ 0 ∧ n = 0</code> situation.
The following code uses sets: <code>[n] − [m] = [0]</code>.
It means, take the <code>integer</code> set consisting of the single element <code>n</code>, remove from it all elements found in the second set (<code>[m]</code>) and compare the resulting <code>set</code> value against the set <code>[0]</code>.</li>
<li>The fallback can be phrased as <code>n × m &gt; 0</code>.
Recall that any product is zero as soon as at least one factor is zero.
Phrasing the fallback like this is necessary, because there are no <code>else</code> clauses.</li>
</ul>
<pre class="lang-pascal prettyprint-override"><code>function A(m,n:integer):integer;begin
A:=n+1;if[n]-[m]=[0]then A:=A(m-1,1);if n*m&gt;0 then A:=A(m-1,A(m,n-1))end
</code></pre>
<p>NB:
The limits of <code>integer</code> are implementation-defined.
For example, the <a href="https://www.GNU-Pascal.de/" rel="nofollow noreferrer">GNU Pascal Compiler</a> implementation will require the <code>‑‑setlimit=8189</code> parameter (or larger) to work correctly for <span class="math-container">\$m \leq 3\$</span>, <span class="math-container">\$n \leq 10\$</span> test cases (beside the fact of having sufficient memory).</p>
</div>
<div id="pu1" class="pu"><h1>Python 3.11, 96 bytes</h1>
<pre class="lang-python prettyprint-override"><code>def a(m,n):
    if m==0:return n+1
    elif n==0:return a(m-1,1)
    else:return a(m-1,a(m,n-1))
</code></pre>
<p>Ungolfed:</p>
<pre class="lang-python prettyprint-override"><code>def a(m, n):
    if m == 0:
        return n + 1
    elif n == 0:
        return a(m-1, 1)
    else:
        return a(m-1, a(m, n-1))
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://codeberg.org/ngn/k" rel="nofollow noreferrer">K (ngn/k)</a>, 16 bytes</h1>
<pre><code>{x/[;1]1+}/[;1+]
</code></pre>
<p><a href="https://ngn.codeberg.page/k#eJxLs6qu0I+2Now11K4F0dqxXFxp0Qax6oqGhkCGIYxhBGMYgxkAj2QNVg==" rel="nofollow noreferrer">Try it online!</a></p>
<p>Same structure as my K answer for <a href="https://codegolf.stackexchange.com/a/264876/78410">fast growing hierarchy</a>, and happens to be the same length too. Can compute f(0..3)(0..10) in a couple seconds.</p>
<p>Again uses &quot;<code>A(m+1,n)</code> is <code>A(m,?)</code> applied <code>n+1</code> times to 1.&quot;</p>
<pre><code>{x/[;1]1+}/[;1+]    input: m, returns function that takes n
{        }/[;1+]    iterate m times on the function 1+ (increment):
       1+             create a function that increments n and then
 x/[;1]               run `x/[n+1;1]` == `(n+1)x/1`
                      == iterate function x n+1 times to 1
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 13 bytes</h1>
<pre><code>+‘ð;x’ß@ƒ1ðỊ?
</code></pre>
<p><a href="https://tio.run/##AS8A0P9qZWxsef//K@KAmMOwO3jigJnDn0DGkjHDsOG7ij//M8W7w6fDvjEwxbvCpFpH/w" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p>Again uses <a href="https://codegolf.stackexchange.com/a/40172/78410">proud haskeller's approach</a>: <code>A(m+1,n)</code> is <code>A(m,?)</code> applied <code>n+1</code> times to 1.</p>
<p>The base case should've been simply <code>A(0,n) = n+1</code>, but unfortunately it (the code at the bottom) times out badly, so I had to use <code>A(m,n) = m+n+1 if m &lt;= 1</code> instead.</p>
<h3>How it works</h3>
<pre><code>+‘ð;x’ß@ƒ1ðỊ?    Dyadic link. Left = m, Right = n
AAðBBBBBBBðC?    If C, do A; otherwise, do B
           Ị     If m &lt;= 1...
+‘               Return m+n+1
   ;x’ß@ƒ1       Otherwise do this:
   ;x            Concatenate m to n copies of m (which gives n+1 copies of m)
     ’           Decrement each number (n+1 copies of m-1)
        ƒ1       Reduce with seed 1...
      ß@         This function, args swapped (since new m is on the right side)
</code></pre>
<hr />
<h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 12 bytes, times out on A(3,9)</h1>
<pre><code>;x’ß@ƒ1ð‘}ḷ?
</code></pre>
<p><a href="https://tio.run/##ASwA0/9qZWxsef//O3jigJnDn0DGkjHDsOKAmH3huLc//zPFu8Onw741xbvCpFpH/w" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
</div>
<div id="pu4" class="pu"><h1 id="ugl-31-30-bytes-b0in"><a href="https://github.com/schas002/Unipants-Golfing-Language" rel="nofollow noreferrer">UGL</a>, <s>31</s> 30 bytes</h1>
<pre><code>iiRuldr%l%lR$d%rd:u%d:%+uRu:ro
</code></pre>
<p>Input separated by newlines.</p>
<p><a href="http://schas002.github.io/Unipants-Golfing-Language/?code=aWlSdWxkciVsJWxSJGQlcmQ6dSVkOiUrdVJ1OnJv&amp;input=Mgo1" rel="nofollow noreferrer">Try it online!</a></p>
<p>(It has been implemented as a standard example in the interpreter.)</p>
</div>
<div id="pu5" class="pu"><h1 id="pyth-15-bytes-sc5p">Pyth, 15 bytes</h1>
<pre><code>M?GgtG?HgGtH1hH
</code></pre>
<p><a href="http://pyth.herokuapp.com/?code=M%3FGgtG%3FHgGtH1hHg3T&amp;debug=0" rel="nofollow noreferrer">Try it online!</a> (sample usage of the function <code>g3T</code> added, which means <code>g(3,10)</code>)</p>
</div>
<div id="pu6" class="pu"><h1 id="japt-12-bytes-0p6u"><a href="https://github.com/ETHproductions/japt" rel="nofollow noreferrer">Japt</a>, 12 <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>?ßUÉ!V´ªß:VÄ
</code></pre>
<p><a href="https://petershaggynoble.github.io/Japt-Interpreter/?v=1.4.6&amp;code=P99VySFWtKrfOlbE&amp;input=MywxMA" rel="nofollow noreferrer">Try it</a></p>
<pre><code>?ßUÉ!V´ªß:VÄ     :Implicit input of integers U=m &amp; V=n
?                :If U is not 0
 ß               :Recursive call with arguments
  UÉ             :  U-1 and
    !V´          :  Logical NOT of postfix decremented V
       ª         :  Logical OR with
        ß        :  Recursive call with arguments U and the now decremented V
         :VÄ     :Else return V+1
</code></pre>
</div>
<div id="pu7" class="pu"><h1>MMIX, 56 bytes (14 instructions)</h1>
<pre><code>5A000003 23000101 F8010000 27000001 5A010003 E3010001 F1FFFFFA
FE020004 23040001 27050101 FB03FFF6 F6040002 C9010003 F1FFFFF3
</code></pre>
<h1>Disassembly and explanation</h1>
<pre><code>ack PBNZ  $0,0F     // if(!m) {
    ADDU  $0,$1,1   //   m = n + 1
    POP   1,0       //   return m }
0H  SUBU  $0,$0,1   // m = m - 1
    PBNZ  $1,0F     // if(!n) {
    SETL  $1,1      //   n = 1
    JMP   ack       //   return ack(m,n) }
0H  GET   $2,rJ     // x = retaddr (to avoid trampling)
    ADDU  $4,$0,1   // m' = m + 1
    SUBU  $5,$1,1   // n' = n - 1
    PUSHJ $3,ack    // a = ack(m',n')
    PUT   rJ,$2     // retaddr = x
    SET   $1,$3     // n = a
    JMP   ack       // return ack(m,n)
</code></pre>
<p>There's hefty use here of tail recursion optimization, not that that'll help much (four words of stack are used here for every time we don't tail recurse, and the stack segment only holds <span class="math-container">\$2^{58}\$</span> words).</p>
</div>
<div id="pu8" class="pu"><h1><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python 3</a>, <s>58</s> 49 bytes</h1>

<pre class="lang-python prettyprint-override"><code>a=lambda m,n:m and a(m-1,n and a(m,n-1)or 1)or-~n
</code></pre>
<p><a href="https://tio.run/##K6gsycjPM/7/P9E2JzE3KSVRIVcnzypXITEvRSFRI1fXUCcPxtbJ0zXUzC9SABG6dXn/C4oy80o0EjWMdRTMNDX/AwA" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
<p>I didn't see a Python 3 answer (there was a Python 2), so I decided to fix that and put my own answer in here. (-(43+21) thanks to caird, -9 thanks to HN)</p>
</div>
<div id="pu9" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 17 bytes</h1>
<pre><code>’çç’}¥ɗ’ç1Ɗṛ?‘}ḷ?
</code></pre>
<p><a href="https://tio.run/##y0rNyan8//9Rw8zDyw8vB1K1h5aenA7mGh7rerhztv2jhhm1D3dst////7/xfxMA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p>Requires a higher recursion limit for <span class="math-container">\$A(3, 10)\$</span> than the Jelly interpreter has, but finishes within 1 minute when I adjust the limit locally</p>
<p>Full program, due to some bugs with <code>ß</code>.</p>
<h2>How it works</h2>
<pre><code>’çç’}¥ɗ’ç1Ɗṛ?‘}ḷ? - Main link A(m, n). Takes m on the left and n on the right
                ? - If:
               ḷ  -   Condition: m is non-zero
                  -   Then:
            ?     -     If:
           ṛ      -       Condition: n in non-zero
      ɗ           -       Then:
’                 -         m-1
     ¥            -         Group the previous 2 links into a dyad f(m, n):
   ’}             -           n-1
  ç               -           A(m, n-1)
 ç                -         A(m-1, A(m, n-1)
          Ɗ       -       Else:
       ’          -         m-1
        ç1        -         A(m-1, 1)
              }   -   Else:
             ‘    -     n+1
</code></pre>
</div>
<div id="pu10" class="pu"><h1><a href="https://esolangs.org/wiki/Ral" rel="nofollow noreferrer">Ral</a>, <s>81</s> 61 bytes</h1>

<pre><code>,,/:11+-111:++:+:++:+:+?/0=:1/-/1/10*-0*1:+?+0=11:+?1++/1:+?.
</code></pre>

<p><a href="https://tio.run/##VVFBb4MgGL3zK750B1FQIb2xMbNjT22W3YxZqGJKopZo221Z9tsdtDbay8fHe@97PMD@nA7Hbj0@wRu8qwZMd9K97bWrUB97@Nhs0UY2qt1XSjgSm86eTzgM0XZC4SJs75lLiCpdQ3/ucBkKBCU1dKCtzMurU@m8famvXcA4iUUaSZpkn0FBGc0L@vuHwM62Q6Ks1V3lnWF3DzEk9mhx6HwG0M2ggSH4OphGg3lp9HQ2GFpJQzgtc1P4bQ3V7dRAWOzTVu4KN1zKgHh0h0Oyw0s4nuD4ERaBUNJBzxarW5m51HF071m6UOwXimiebnNVOFT5l2mnyyyU8q70Ot/MFPXJNg@pkkBs8WPQLPBPAWqa9bDrXpkwslXfmFGXHPn/Wq1WI6Wp4O5TOOeCEEGmkqVMCp7GKU85i2IWOTYjTHpVxglJ/ZqMziEc14izfw" rel="nofollow noreferrer">Try it online!</a></p>

<p><strong>Commented</strong></p>

<pre><code>Code                     Stack after        Description
,,                       0, m, n              Input m and n
                                            Loop:
/:11+-111:++:+:++:+:+?   r, n, m              Jump to SmallM if m &lt; 2
/0=:1/-/1/10*-           r, m-1, 1, m, n-1    Perform [m, n] =&gt; [m-1, 1, m, n-1]
0*1:+?                   r, m-1, 1, m, n-1    Jump to Loop if n&gt;0
+0=                      r, m-1, 1            Remove the last two elements
11:+?                    r, m-1, 1            Jump to Loop
                                            SmallM:
1++                      n+m+1, r             Perform [m, n] =&gt; [n+m+1]
/1:+?                    n+m+1                Jump to Loop if r&gt;0
.                                             Print n+m+1
</code></pre>

<p><strong>Explanation</strong></p>

<p>Because there are no built in function calls (or recursion) in Ral, we need to simulate the stack frame. One way to do that is as follows:</p>

<ol>
<li>Start with the stack [m, n]</li>
<li>Repeatedly apply the following rules, until a single element remains:

<ul>
<li>[..., 0, n] => [..., n+1]</li>
<li>[..., m, 0] => [..., m-1, 1]</li>
<li>[..., m, n] => [..., m-1, m, n-1]</li>
</ul></li>
<li>Print the remaining element</li>
</ol>

<p>However, since there is no way to know the current length of the stack in Ral, an additional flag is stored to test if the recursion should continue, resulting in the following rules:</p>

<ul>
<li>[..., 0, 0, n] => Print n+1 and exit</li>
<li>[..., 1, 0, n] => [..., n+1]</li>
<li>[..., m, 0] => [..., m-1, 1]</li>
<li>[..., m, n] => [..., m-1, 1, m, n-1]</li>
</ul>
</div>
<div id="pu11" class="pu"><h1><a href="http://iolanguage.org/" rel="nofollow noreferrer">Io</a>, 53 bytes</h1>

<p>Yet another recursion solution.</p>

<pre><code>a :=method(m,n,if(m&lt;1,n+1,a(m-1,if(n&lt;1,1,a(m,n-1)))))
</code></pre>

<p><a href="https://tio.run/##y8z//z9Rwco2N7UkIz9FI1cnTyczTSPXxlAnT9tQJ1EjV9cQJJAHFABzdfJ0DTVB4H@ihrGOiaZCQVFmXklO3n8A" rel="nofollow noreferrer" title="Io – Try It Online">Try it online!</a></p>
</div>
<div id="pu12" class="pu"><h1><a href="http://erlang.org/doc/man/escript.html" rel="nofollow noreferrer">Erlang (escript)</a>, 53 bytes</h1>

<p>I tried to put the pattern matching in an if statement; turns out that makes the program longer...</p>



<pre class="lang-erlang prettyprint-override"><code>a(0,N)-&gt;N+1;a(M,0)-&gt;a(M-1,1);a(M,N)-&gt;a(M-1,a(M,N-1)).
</code></pre>

<p><a href="https://tio.run/##XY3BCgIhEIbvPsV0WFDSRalTC75BnrpFxLDZJmwa6tLjm@uhIBj@f@Y7fGPjjH4SNo3RvXIhBankhglttmpAeuSy7rWF4oo1YL6gXUIx1pcOTkv0CcKSIT9wDZegzhz8ZOOGdPAv/nlGTBYMhDtIodVwbbyZrb@xnpAnOk/PFwZCgwuHd3TZUqQ7vl9/fwA" rel="nofollow noreferrer" title="Erlang (escript) – Try It Online">Try it online!</a></p>
</div>
<div id="pu13" class="pu"><h1><a href="https://www.dyalog.com/" rel="nofollow noreferrer">APL (Dyalog Unicode)</a>, 22 bytes</h1>



<pre class="lang-apl prettyprint-override"><code>{0=⍺:1+⍵⋄1∇⍣(⍵+1)⍨⍺-1}
</code></pre>

<p><a href="https://tio.run/##SyzI0U2pTMzJT///v9rA9lHvLitD7Ue9Wx91txg@6mh/1LtYA8jTNtR81LsCKKlrWPs/7VHbhEe9fY/6pnr6P@pqPrTe@FHbRCAvOMgZSIZ4eAb/N1RIUzDhMgaShgYA" rel="nofollow noreferrer" title="APL (Dyalog Unicode) – Try It Online">Try it online!</a></p>

<p>A port of <a href="https://codegolf.stackexchange.com/a/40172/78410">proud haskeller's Haskell answer</a>. Uses the fact that <code>Ack(m,n)</code> is equal to <code>Ack(m-1,?)</code> applied <code>n+1</code> times to <code>1</code>.</p>

<h3>How it works</h3>

<pre class="lang-apl prettyprint-override"><code>{0=⍺:1+⍵⋄1∇⍣(⍵+1)⍨⍺-1}
{                    }  ⍝ ⍺←m, ⍵←n
 0=⍺:1+⍵⋄               ⍝ If m = 0, return 1 + n
          ∇      ⍨⍺-1   ⍝ Apply (m-1)∇ (∇ is recursive call)
           ⍣(⍵+1)       ⍝ n+1 times
         1              ⍝ to the initial value 1
</code></pre>
</div>
<div id="pu14" class="pu"><h1>Haskell, 47 bytes</h1>

<pre><code>a 0 n=n+1
a m 0=a(m-1)1
a m n=a(m-1)(a m (n-1))
</code></pre>

<p>(Run using <code>ghci &lt;filename&gt;</code>)
Almost directly copies from the problem definition (thank you pattern matching!).</p>
</div>
<div id="pu15" class="pu"><h1><a href="http://iverilog.icarus.com/" rel="nofollow noreferrer">Verilog (Icarus Verilog)</a>, 81 bytes</h1>

<p>Based on the <a href="https://codegolf.stackexchange.com/a/201372/62493">C answer</a>. Verilog is not really intended for this kind of thing - Yosys crashes on this - but it's possible with Icarus.</p>

<pre><code>function automatic[15:0]a;input[15:0]m,n;a=(m==0)?n+1:(n==0)?a(m-1,1):a(m-1,a(m,n-1));endfunction
</code></pre>

<p>Testbench:</p>

<pre><code>module test();

function automatic[31:0]a;input[31:0]m,n;a=m?a(m-1,n?a(m,n-1):1):n+1;endfunction

initial begin
    $display("%d", a(3,10));
end

endmodule
</code></pre>

<p>Icarus is really not intended for this kind of constant abuse, though:</p>

<pre><code>$ time ./a.out
 8189

real    0m55.422s
user    0m55.375s
sys     0m0.063s
</code></pre>
</div>
<div id="pu16" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C (gcc)</a>, 36 bytes</h1>



<pre class="lang-c prettyprint-override"><code>A(m,n){m=m?A(m-1,n?A(m,n-1):1):n+1;}
</code></pre>

<p>Naive strategy with a little bit of optimization.</p>

<p><a href="https://tio.run/##TY7BCsIwDIbvfYowEVrWisWbWx2@hxdpnRZsOub0MvbsNa0g@wnJnz/fIVbdrU3pzINEMQcTOrJKS@xKpLQ4UmGtmyVtPNrn292gfU3Ox93jxJjHCcLVI/9E7wSbGZD6OPJyAAP7hkZr4ECzrkW5rxn8MZgZnc0ayhpGwnpeBbN1ErD0/BugIH/BSkJe/qFo2JK@" rel="nofollow noreferrer" title="C (gcc) – Try It Online">Try it online!</a></p>
</div>
<div id="pu17" class="pu"><h1><a href="http://tcl.tk/" rel="nofollow noreferrer">Tcl</a>, 67 bytes</h1>

<pre><code>proc tcl::mathfunc::A m\ n {expr {$m?A($m-1,$n?A($m,$n-1):1):$n+1}}
</code></pre>

<p><a href="https://tio.run/##PY/BaoQwEIbP@hQ/kkOXum2kp4YNxXfYm@tB0mwbMGNIIhQkz26jazsMzMB888/8UY2roai9g9dq9sFMNBprIpaEd8756vykENUohB3i930mJUQLewNh0T/OY2H2o31i9tzUjPYu13NzEjkZPTcprfcpY0FHWPC0LVzkW66GlIfNTVn8E/Qg6CIb/ofQjhTb@IpuP9qF6A19wQ4OS2WN8lPQaqLPAKc9THY0xOylyj4Sumisfui3h8Dx56lPff/a8D1e@hsOlXzOzTGgsjJzIMmoRitZW2PTkuxalUUq0/oL" rel="nofollow noreferrer" title="Tcl – Try It Online">Try it online!</a></p>

<hr>

<p><s></p>

<h1><a href="http://tcl.tk/" rel="nofollow noreferrer">Tcl</a>, 77 bytes</h1>

<pre><code>proc A m\ n {expr {$m?[A [expr $m-1] [expr {$n?[A $m [expr $n-1]]:1}]]:$n+1}}
</code></pre>

<p><a href="https://tio.run/##PY/BasMwEETP9lcMRre6jUxPLRHF/5Cb40NQ1SLIroWkQMHo252141QHacW8nd3J9rp4zi4GRGdvMfmJr558xlzwobVeQpwsetAZjNn9hYhZ0dfQY9g@il67ca9nxaug6KmxaONnV@RS/NKVsvxMgiWXQdBldTqad3k92wiSoq7@CX4QfDSdfiK8IdUqn/YhQ8rR8y/oEjA35G2ckrMTfycEF@El2yVLqkYSFQzZk3v4S4JtV8WjLHjo9HbexjP2fhkUbjmhIaOoBRvFLXqj@hari1Gnpq5KXZY7" rel="nofollow noreferrer" title="Tcl – Try It Online">Try it online!</a></p>

<p></s></p>

<p>In the online compiler it fails to run due to time-out, but in a local Tcl interpreter it runs well. I profiled of each root call to <code>A</code> function, to see how much time the calculation took for each pair <code>{m,n}</code> subject to be tested:</p>

<pre><code>m=0, n=0, A=1, time=3.5e-5 seconds
m=0, n=1, A=2, time=2e-6 seconds
m=0, n=2, A=3, time=8e-6 seconds
m=0, n=3, A=4, time=1e-6 seconds
m=0, n=4, A=5, time=2e-6 seconds
m=0, n=5, A=6, time=1e-6 seconds
m=0, n=6, A=7, time=1e-6 seconds
m=0, n=7, A=8, time=1e-6 seconds
m=0, n=8, A=9, time=1e-6 seconds
m=0, n=9, A=10, time=0.0 seconds
m=0, n=10, A=11, time=1e-6 seconds
m=1, n=0, A=2, time=4e-6 seconds
m=1, n=1, A=3, time=6e-6 seconds
m=1, n=2, A=4, time=1e-5 seconds
m=1, n=3, A=5, time=1.2e-5 seconds
m=1, n=4, A=6, time=1.5e-5 seconds
m=1, n=5, A=7, time=2e-5 seconds
m=1, n=6, A=8, time=2e-5 seconds
m=1, n=7, A=9, time=2.6e-5 seconds
m=1, n=8, A=10, time=3e-5 seconds
m=1, n=9, A=11, time=3e-5 seconds
m=1, n=10, A=12, time=3.3e-5 seconds
m=2, n=0, A=3, time=8e-6 seconds
m=2, n=1, A=5, time=2.2e-5 seconds
m=2, n=2, A=7, time=3.9e-5 seconds
m=2, n=3, A=9, time=6.3e-5 seconds
m=2, n=4, A=11, time=9.1e-5 seconds
m=2, n=5, A=13, time=0.000124 seconds
m=2, n=6, A=15, time=0.000163 seconds
m=2, n=7, A=17, time=0.000213 seconds
m=2, n=8, A=19, time=0.000262 seconds
m=2, n=9, A=21, time=0.000316 seconds
m=2, n=10, A=23, time=0.000377 seconds
m=3, n=0, A=5, time=2.2e-5 seconds
m=3, n=1, A=13, time=0.000145 seconds
m=3, n=2, A=29, time=0.000745 seconds
m=3, n=3, A=61, time=0.003345 seconds
m=3, n=4, A=125, time=0.015048 seconds
m=3, n=5, A=253, time=0.059836 seconds
m=3, n=6, A=509, time=0.241431 seconds
m=3, n=7, A=1021, time=0.971836 seconds
m=3, n=8, A=2045, time=3.908884 seconds
m=3, n=9, A=4093, time=15.926341 seconds
m=3, n=10, A=8189, time=63.734713 seconds
</code></pre>

<p>It fails for the last pair <code>{m,n}={3,10}</code>, as it takes a very little more than one minute.</p>

<p>For higher values of <code>m</code>, it will be needed to increase the <code>recursionlimit</code> value.</p>

<hr>

<p>I coult get it shorter to 65 bytes, but it will not meet the question's requirement "Your function must be able to find the value of A(m,n) for m ≤ 3 and n ≤ 10 in less than a minute.". Without the <code>{}</code> it will timeout on TIO and not do the demo of the last two entries.</p>

<h1><a href="http://tcl.tk/" rel="nofollow noreferrer">Tcl</a>, 65 bytes</h1>

<pre><code>proc tcl::mathfunc::A m\ n {expr $m?A($m-1,$n?A($m,$n-1):1):$n+1}
</code></pre>

<p><a href="https://tio.run/##PY/BasMwEETP8VcMRoeGOq1MTzURxf@Qm@ODUZVW4F0LSYaC0be7iuN2WdiFfczsRD2ulqPxDt7o2Qc78WjJRiwJ71LK1flJI@qxaWiI37eZddO0oCsYi/lxHoI@2idBp7oSvG15nupjk1vwc53W2@SxBBNBkAmLoLN6y9Oy9qC8FId/gh8En1Ut/xDekMP9fEG3WXYhestfoMFhKclqPwWjJ/4McMbD5jxDzEnKnCKhi5bMQ7/dBfY3j33q@9dabvXSX7GrZDs3x4CSVObASnCFVom2wl1LiUtZHFKR1l8" rel="nofollow noreferrer" title="Tcl – Try It Online">Try it online!</a></p>
</div>
<div id="pu18" class="pu"><h1><a href="https://github.com/TryItOnline/brainfuck" rel="nofollow noreferrer">brainfuck</a>, 90 bytes</h1>

<pre><code>&gt;&gt;&gt;&gt;+&gt;,&gt;,&lt;&lt;[&gt;[&gt;[-[-&gt;&gt;&gt;+&lt;&lt;&lt;]&lt;[-&gt;+&gt;&gt;+&lt;&lt;&lt;]&gt;-[-&lt;+&gt;]&gt;+&gt;&gt;&gt;&gt;&gt;]&lt;[-&gt;+&gt;&gt;]]&lt;[&gt;&gt;+[-&lt;&lt;&lt;+&gt;&gt;&gt;]&lt;&lt;-]&lt;&lt;&lt;]&gt;&gt;.
</code></pre>

<p><a href="https://copy.sh/brainfuck/?c=Pj4-Pis-LD4sPDwKWwogID4KICBbCiAgICA-CiAgICBbCiAgICAgIC1bLT4-Pis8PDxdCiAgICAgIDxbLT4rPj4rPDw8XQogICAgICA-LVstPCs-XT4rPj4-Pj4KICAgIF0KICAgIDwKICAgIFsKICAgICAgLT4rPj4KICAgIF0KICBdCiAgPAogIFsKICAgID4-K1stPDw8Kz4-Pl08PC0KICBdCiAgPDw8Cl0KPj4uCg$$" rel="nofollow noreferrer">Try it online!</a></p>

<p>Assumes an implementation with arbitrary sized cell size, with IO as numbers. -6 bytes if you don't mind using negative cells.</p>

<p>Finishes in about 30 seconds for 3,8 in the linked interpreter, provided you tick the correct settings. Type inputted numbers prepended with <code>\</code>s, e.g. <code>3,9</code> is <code>\3\9</code>.</p>
</div>
<div id="pu19" class="pu"><h2>R - <s>54</s> 52</h2>

<p>I've used this as an excuse to try and get my head around R, so this is probably really badly done:)</p>

<pre><code>a=function(m,n)"if"(m,a(m-1,"if"(n,a(m,n-1),1)),n+1)
</code></pre>

<p>Example run</p>

<pre><code>&gt; a(3,8)
[1] 2045
</code></pre>

<p>I get a stack overflow for anything beyond that</p>

<h2>T-SQL- 222</h2>

<p>I thought I would try to get T-SQL to do it as well.  Used a different method because recursion isn't that nice in SQL.  Anything over 4,2 bombs it.</p>

<pre><code>DECLARE @m INT=4,@n INT=1;WITH R AS(SELECT 2 C, 1 X UNION ALL   SELECT POWER(2,C),X+1FROM R)SELECT IIF(@m=0,@n+1,IIF(@m=1,@n+2,IIF(@m=2,2*@n+3,IIF(@m=3,POWER(2,@n+3)-3,IIF(@m=4,(SELECT TOP(1)C FROM R WHERE x= @n+3)-3,-1)))))
</code></pre>
</div>
<div id="pu20" class="pu"><h1>Haskell, 35</h1>
<pre><code>0%n=1+n
m%n=iterate((m-1)%)1!!(n+1)
</code></pre>
<p>this defines the operator function <code>%</code>.</p>
<p>this works by noticing that <code>m%n</code> (where <code>a</code> is the ackerman function) for nonzero <code>m</code> is <code>(m-1)%</code> applied <code>n+1</code> times to <code>1</code>. for example, <code>3%2</code> is defined as <code>2%(3%1)</code> which is <code>2%(2%(3%0))</code>, and this is <code>2%(2%(2%1))</code></p>
</div>
<div id="pu21" class="pu"><h2>Ceylon, <s>88</s> <s>87</s> 85</h2>

<pre class="lang-ceylon prettyprint-override"><code>alias I=&gt;Integer;I a(I m,I n)=&gt;m&lt;1then n+1else(n&lt;1then a(m-1,1)else a(m-1,a(m,n-1)));
</code></pre>

<p>This is a straightforward implementation. Formatted:</p>

<pre class="lang-ceylon prettyprint-override"><code>alias I =&gt; Integer;
I a(I m, I n) =&gt;
        m &lt; 1
        then n + 1
        else (n &lt; 1
            then a(m - 1, 1)
            else a(m - 1, a(m, n - 1)));
</code></pre>

<p>The alias saves just one byte, without it (with writing <code>Integer</code> instead of <code>I</code>) we would get to 86 bytes. Another two bytes can be saved by replacing <code>== 0</code> by <code>&lt; 1</code> twice.</p>

<p>With the default settings of <code>ceylon run</code>, it will work up to <code>A(3,12) = 32765</code> (and <code>A(4,0) = 13</code>), but <code>A(3,13)</code> (and therefore also <code>A(4,1)</code>) will throw a stack overflow error. (<code>A(3,12)</code> takes about 5 seconds, <code>A(3,11)</code> about 3 on my computer.)</p>

<p>Using <code>ceylon run-js</code> (i.e. running the result of compiling to JavaScript on node.js) is a lot slower (needs 1 min 19 s for <code>A(3,10)</code>), and breaks already for <code>A(3, 11)</code> with a »Maximum call stack size exceeded« (using default settings) after running for 1 min 30 s.</p>

<hr>

<h2>Ceylon without recursion, 228</h2>

<p>As a bonus, here is a non-recursive version (longer, of course, but immune to stack overflows – might get an out-of-memory error at some point).</p>

<pre class="lang-ceylon prettyprint-override"><code>import ceylon.collection{A=ArrayList}Integer a(Integer[2]r){value s=A{*r};value p=s.addAll;while(true){if(exists m=s.pop()){if(exists n=s.pop()){if(n&lt;1){p([m+1]);}else if(m&lt;1){p([n-1,1]);}else{p([n-1,n,m-1]);}}else{return m;}}}}
</code></pre>

<p>Formatted:</p>

<pre class="lang-ceylon prettyprint-override"><code>import ceylon.collection {
    A=ArrayList
}

Integer a(Integer[2] r) {
    value s = A { *r };
    value p = s.addAll;
    while (true) {
        if (exists m = s.pop()) {
            if (exists n = s.pop()) {
                if (n &lt; 1) {
                    p([m + 1]);
                } else if (m &lt; 1) {
                    p([n - 1, 1]);
                } else {
                    p([n - 1, n, m - 1]);
                }
            } else {
                // stack is empty
                return m;
            }
        }
    }
}
</code></pre>

<p>It is quite slower on my computer than the recursive version: <code>A(3,11)</code> takes 9.5 seconds, <code>A(3,12)</code> takes 34 seconds, <code>A(3,13)</code> takes 2:08 minutes, <code>A(3,14)</code> takes 8:25 minutes. (I originally had a version using lazy iterables instead of the tuples I now have, which was even much slower, with the same size).</p>

<p>A bit faster (21 seconds for <code>A(3,12)</code>) (but also one byte longer) is a version using <code>s.push</code> instead of <code>s.addAll</code>, but that needed to be called several times to add multiple numbers, as it takes just a single Integer each. Using a LinkedList instead of an ArrayList is a lot slower.</p>
</div>
<div id="pu22" class="pu"><h1>Java, 274 bytes</h1>

<pre><code>import java.math.*;class a{BigInteger A(BigInteger b,BigInteger B){if(b.equals(BigInteger.ZERO))return B.add(BigInteger.ONE);if(B.equals(BigInteger.ZERO))return A(b.subtract(BigInteger.ONE),BigInteger.ONE);return A(b.subtract(BigInteger.ONE),A(b,B.subtract(BigInteger.ONE)));}}
</code></pre>

<p>It calculates <code>A(3,10)</code> in a few seconds, and given infinite memory and stack space, it can calculate any combination of <code>b</code> and <code>B</code> as long as the result is below 2<sup>2147483647</sup>-1.</p>
</div>
<div id="pu23" class="pu"><h1><a href="https://tromp.github.io/cl/cl.html" rel="noreferrer">Binary lambda calculus</a>, 54 bits = 6.75 bytes</h1>

<p>Hexdump:</p>

<pre><code>00000000: 1607 2d88 072f 68                        ..-../h
</code></pre>

<p>Binary:</p>

<pre><code>000101100000011100101101100010000000011100101111011010
</code></pre>

<p>This is λ<em>m</em>. <em>m</em> (λ<em>g</em>. λ<em>n</em>. <em>g</em> (<em>n</em> <em>g</em> 1)) (λ<em>n</em>. λ<em>f</em>. λ<em>x</em>. <em>f</em> (<em>n</em> <em>f</em> <em>x</em>)), where all numbers are represented as <a href="https://en.wikipedia.org/wiki/Church_encoding#Church_numerals" rel="noreferrer">Church numerals</a>.</p>
</div>
<div id="pu24" class="pu"><h1>Julia, <s>34</s> <s>31</s> 28 bytes</h1>

<pre class="lang-julia prettyprint-override"><code>m\n=m&gt;0?~-m\(n&lt;1||m\~-n):n+1
</code></pre>
<p>This is a named anonymous function. It is a straightforward implementation of the recursive definition, abusing Julia's ability to <a href="https://codegolf.stackexchange.com/a/81028">redefine operators</a>.</p>
<p><a href="http://julia.tryitonline.net/#code=bVxuPW0-MD9-LW1cKG48MXx8bVx-LW4pOm4rMQoKcHJpbnQoM1wxMCk&amp;input=" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu25" class="pu"><h1>J - 26 char</h1>

<pre><code>($:^:(&lt;:@[`]`1:)^:(0&lt;[)&gt;:)
</code></pre>

<p>There is an alternate, more functional definition of Ackermann:</p>

<pre><code>Ack 0 n = n+1
Ack m n = Iter (Ack (m-1)) n
Iter f 0 = f 1
Iter f n = f (Iter f (n-1))
</code></pre>

<p>It so happens that <code>Iter</code> is very easy to write in J, because J has a way of passing in the <code>m-1</code> to <code>Ack</code> and also to define the initial value of <code>Iter</code> to be 1. Explained by explosion:</p>

<pre><code>(                      &gt;:)  NB. increment n
                ^:(0&lt;[)     NB. if m=0, do nothing to n+1; else:
   ^:                       NB. iterate...
($:                      )  NB.   self ($: is recursion)
     (&lt;:@[     )            NB.   with left arg m-1
          `]                NB.   n+1 times
            `1:             NB.   starting on 1
</code></pre>

<p>This relies on what J calls the gerund form of <code>^:</code>&mdash;basically a way to have more control over all the bounds in a tacit (point-free) fashion.</p>

<p>At the REPL:</p>

<pre><code>   3 ($:^:(&lt;:@[`]`1:)^:(0&lt;[)&gt;:) 3
61
   ack =: ($:^:(&lt;:@[`]`1:)^:(0&lt;[)&gt;:)
   (i.4) ack"0 table (i.11)
+-----+------------------------------------------+
|ack"0|0  1  2  3   4   5   6    7    8    9   10|
+-----+------------------------------------------+
|0    |1  2  3  4   5   6   7    8    9   10   11|
|1    |2  3  4  5   6   7   8    9   10   11   12|
|2    |3  5  7  9  11  13  15   17   19   21   23|
|3    |5 13 29 61 125 253 509 1021 2045 4093 8189|
+-----+------------------------------------------+
   6!:2 '3 ($:^:(&lt;:@[`]`1:)^:(0&lt;[)&gt;:) 10'  NB. snugly fits in a minute
58.5831
</code></pre>

<p>We need to define <code>ack</code> by name to be able to put it in a table, because <code>$:</code> is a horrible, ugly beast and lashes out at anyone who attempts to understand it. It is self-reference, where self is defined as the largest verb phrase containing it. <code>table</code> is an adverb and so would love to become part of the verb phrase if you give it the chance, so you have to trap <code>$:</code> in a named definition to use it.</p>

<hr>

<h3>Edit: 24 char?</h3>

<p>Years later, I found a solution which is two characters shorter.</p>

<pre><code>(0&amp;&lt;~(&lt;:@#~$:/@,1:^:)&gt;:)
</code></pre>

<p>It's a lot slower, though: <code>3 ack 8</code> takes over a minute on my machine. This is because (1) I use a fold <code>/</code> instead of iteration, so J probably has to remember more things than usual, and (2) while <code>0&amp;&lt;~</code> performs the same calculation as <code>(0&lt;[)</code>, it actually gets executed <code>n+1</code> times <em>before taking the recursive step</em> when invoking <code>m ack n</code>&mdash;<code>0&amp;&lt;</code> happens to be idempotent, so it doesn't ruin the calculation, but <code>n</code> gets big fast and <code>ack</code> is highly recursive.</p>

<p>I am doubtful that a more powerful machine could push the new code under a minute, because this is a computer where the old code can find <code>3 ack 10</code> in less than 15 seconds.</p>
</div>
<div id="pu26" class="pu"><h1>Coq, 40</h1>

<pre><code>nat_rec _ S(fun _ b n=&gt;nat_iter(S n)b 1)
</code></pre>

<p>This is a function of type <code>nat -&gt; nat -&gt; nat</code>.  Since Coq only allows the construction of total functions, it also serves as a formal proof that the Ackermann recurrence is well-founded.</p>

<p>Demo:</p>

<pre><code>Welcome to Coq 8.4pl6 (November 2015)

Coq &lt; Compute nat_rec _ S(fun _ b n=&gt;nat_iter(S n)b 1) 3 10.
     = 8189
     : nat
</code></pre>

<p>Note: Coq 8.5, released after this challenge, renamed <code>nat_iter</code> to <code>Nat.iter</code>.</p>
</div>
<div id="pu27" class="pu"><h1><a href="https://github.com/catb0t/mouse15" rel="nofollow noreferrer">Mouse-2002</a>, <s>99</s> 83 bytes</h1>
<pre><code>$Y1%j:j.0=m:2%k:k.0=n:m.n.&gt;[k.1+!|m.n.&lt;[#Y,j.1-,1;|m.n.*0=[#Y,j.1-,#Y,j.,k.1+;;]]]@
</code></pre>
</div>
<div id="pu28" class="pu"><h1>Go, <s>260</s> <s>243</s> <s>240</s> 122 bytes</h1>

<p>I didn't see that the question allowed anon funcs.</p>

<p>far from competitive but i'm learning this language and i wanted to test it out.
</p>

<pre><code>func (m,n int)int{r:=0
switch{case m==0&&n!=0:r=n+1
case m!=0&&n==0:r=a(m-1,1)
case m!=0&&n!=0:r=a(m-1,a(m,n-1))}
return r}</code></pre>

<p>use it like <code>go run ack.go</code> and then supply two numbers, <code>m</code> and <code>n</code>. if m>4 or n>30, execution time may be in excess of half a minute.</p>

<p>for <code>m=3 n=11</code>:
</p>

<pre><code>$ time go run ack
16381
real    0m1.434s
user    0m1.432s
sys     0m0.004s
</code></pre>

<p><em>edit</em>: saved total 17 bytes by switching to <code>switch</code> over <code>if/else</code> and dot-imports</p>
</div>
<div id="pu29" class="pu"><h1><a href="https://codegolf.stackexchange.com/q/62886/2338">Tiny Lisp</a>, 70  (out of competition)</h1>

<p>This runs out of competition, as the language is newer than the question, and it also doesn't succeed to run the <code>(A 3 10)</code> as required in the question, due to a stack overflow.</p>

<p><code>(d A(q((m n)(i m(i n(A(s m 1)(A m(s n 1)))(A(s m 1)1))(s n(s 0 1))))))</code></p>

<p>This defines a function <code>A</code> which calculates the Ackermann function.
Formatted:</p>

<pre><code>(d A
   (q( (m n)
       (i m
          (i n
             (A (s m 1)
                (A m
                   (s n 1)
                 )
              ) 
             (A (s m 1)
                1
              )
           )
          (s n
             (s 0 1)
           )
        )
    ) )
 )
</code></pre>

<p>We are using all builtin macros (<code>d</code> (define) and <code>q</code> (quote) and <code>i</code> (if)) and one builtin function (<code>s</code> – subtract) here.</p>

<p><code>i</code> executes its true part when the condition is a number > 0 (and otherwise the false part), so we don't have to do an explicit comparison here.</p>

<p><code>s</code> is the only arithmetic operation available, we use it for the <code>n-1</code>/<code>m-1</code>, as well as as <code>(s n (s 0 1))</code> for <code>n+1</code>.</p>

<p>Tiny lisp is using tail recursion optimization, but this only helps for the outer <code>A</code> call in the result, not for the <code>A(m, n-1)</code> call which is used for the parameters.</p>

<p>With <a href="https://codegolf.stackexchange.com/a/63352/2338">my tiny lisp implementation</a> in Ceylon on the JVM, it works up to <code>(A 3 5) = 253</code>, but it seems to break down when trying to calculate <code>(A 2 125)</code> directly (which should give the same result). If calculating that after <code>(A 3 4) = 125</code>, the JVM seems to got to optimize the functions enough to inline some intermediate function calls in my interpreter, allowing more recursion depth. Strange.</p>

<p>The <a href="https://gist.github.com/dloscutoff/254267bce8cb09f009ad" rel="nofollow noreferrer">reference implementation</a> gets up to <code>(A 3 5) = 253</code> and also <code>(A 2 163) = 329</code>, but doesn't succeed <code>(A 2 164)</code>, and therefore even less <code>(A 3 6) = (A 2 253)</code>.</p>
</div>
<div id="pu30" class="pu"><h1>Javascript ES6 (34)</h1>

<pre class="lang-js prettyprint-override"><code>a=(m,n)=&gt;m?a(m-1,n?a(m,n-1):1):n+1
</code></pre>

<h3>Implementation:</h3>

<p><div class="snippet" data-lang="js" data-hide="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>a=(m,n)=&gt;m?a(m-1,n?a(m,n-1):1):n+1</code></pre>
<pre class="snippet-code-css lang-css prettyprint-override"><code>td[colspan="2"] input{width: 100%;}</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;m=&lt;/td&gt;&lt;td&gt;&lt;input id="m" type="number" value="0" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;n=&lt;/td&gt;&lt;td&gt;&lt;input id="n" type="number" value="0" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan="2"&gt;&lt;input type="button" value="Calculate!" onclick="document.getElementById('out').value=a(document.getElementById('m').value, document.getElementById('n').value)" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan="2"&gt;&lt;input id="out" disabled="disabled" type="text" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</code></pre>
</div>
</div>
</p>
</div>
<div id="pu31" class="pu"><h2>Haskell, <s>48</s> 44 chars (36 for the list)</h2>



<p>While not as short as the other Haskell solution, this one is notable because it expresses the Ackermann function as an infinite list, which I think is kinda neat.  The result is an infinite list (of infinite lists) such that at position <em>[m,n]</em> it holds the value <em>A(m,n)</em>.</p>

<p>The infinite list itself:</p>

<pre class="lang-hs prettyprint-override"><code>iterate(tail.(`iterate`1).(!!))[1..]
</code></pre>

<p>As a function (to comply with the specification):</p>

<pre class="lang-hs prettyprint-override"><code>i=iterate;m%n=i(tail.(`i`1).(!!))[1..]!!m!!n
</code></pre>

<hr>

<p>The formulation was derived by observing that the general/common case for the Ackermann function is to use the value to the left as an index in the row above.  The base case for this recursion (i.e. the leftmost column of a row, i.e. <em>A(m,0)</em>) is to use the second left-most value in the row above.  The base case for <em>that</em> recursion is the <em>A(0,n) = n+1</em> case, i.e. the first row is <code>[1..]</code>.</p>

<p>Thus, we get</p>

<pre class="lang-hs prettyprint-override"><code>let a0 = [1..]
let a1 = tail $ iterate (a0 !!) 1  -- 'tail' because iterate starts by applying
let a2 = tail $ iterate (a1 !!) 1  -- the function 0 times
-- etc
</code></pre>

<p>Then we simply add another level of iteration based on that pattern, and do some <a href="http://en.wikipedia.org/wiki/Tacit_programming" rel="nofollow">pointless</a> juggling.</p>
</div>
<div id="pu32" class="pu"><h2>Javascript with lambdas, 34</h2>

<pre><code>A=(m,n)=&gt;m?A(m-1,n?A(m,n-1):1):n+1
</code></pre>

<p>A tipical answer, can't make anything shorter.</p>
</div>
<div id="pu33" class="pu"><h1>Ruby, 65</h1>

<pre class="lang-ruby prettyprint-override"><code>h,a={},-&gt;m,n{h[[m,n]]||=m&lt;1?(n+1):(n&lt;1?a[m-1,1]:a[m-1,a[m,n-1]])}
</code></pre>

<h2>Explanation</h2>

<p>This is a pretty straightforward translation of the algorithm given in the problem description.</p>

<ul>
<li>Input is taken as the arguments to a lambda. Two <code>Integer</code>s are expected.</li>
<li>For speed and avoiding stack-overflow errors, answers are memoized in the <code>Hash</code> <code>h</code>. The <code>||=</code> operator is used to calculate a value that wasn't previously calculated.</li>
</ul>

<p><code>a[3,10]</code> is calculated in ~0.1 sec on my machine.</p>

<p>Here's an ungolfed version</p>

<pre class="lang-ruby prettyprint-override"><code>h = {}
a = lambda do |m,n|
  h[[m,n]] ||= if m &lt; 1 
    n + 1
  elsif n &lt; 1
    a[m-1,1]
  else
    a[m-1,a[m,n-1]]
  end
end
</code></pre>
</div>
<div id="pu34" class="pu"><h1><a href="https://github.com/isaacg1/pyth">Pyth</a>, 19</h1>

<pre><code>DaGHR?atG?aGtHH1GhH
</code></pre>

<p>Defines <code>a</code>, which works as the Ackermann function. Note that this requires a higher recursion depth than the official pyth compiler allowed up until today to compute <code>a 3 10</code>, so I increased the recursion depth. This is not a change to the language, just to the compiler.</p>

<h3>Test:</h3>

<pre><code>$ time pyth -c "DaGHR?atG?aGtHH1GhH           ;a 3 10"
8189

real    0m0.092s
user    0m0.088s
sys     0m0.000s
</code></pre>

<h3>Explanation:</h3>

<pre><code>DaGH                     def a(G,H):
    R                    return
    ?          G                (if G:
     atG                              (a(G-1,
        ?    H                               (if H:
         aGtH                                      a(G,H-1)
              1                               else:1)
                hH               else:H+1)
</code></pre>

<p>Essentially, it first conditions on the truth value of <code>G</code> whether to recurse or return H+1. If it is recursing, the first argument is always G-1, and it conditions on the truth value of <code>H</code> whether to use <code>a(G,H-1)</code> as the second argument, or to use <code>1</code> as the second argument.</p>
</div>
<div id="pu35" class="pu"><h2>APL, 31</h2>

<pre><code>{⍺=0:⍵+1⋄⍵=0:1∇⍨⍺-1⋄(⍺-1)∇⍺∇⍵-1}
</code></pre>

<p>Pretty straightforward. Uses the ⍨ character once to save one byte by reversing arguments. Takes m as the left argument and n as the right argument.</p>

<p><a href="http://tryapl.org/" rel="nofollow">TryAPL.org</a></p>
</div>
<div id="pu36" class="pu"><h2>GolfScript (30)</h2>

<pre><code>{1$1&gt;{1\){1$(\A}*\;}{+)}if}:A;
</code></pre>

<p><a href="http://golfscript.apphb.com/?c=ezEkMT57MVwpezEkKFxBfSpcO317Kyl9aWZ9OkE7CgozIDEwIEE%3D">Online demo</a></p>

<p>Without the <code>1&gt;</code> (which special-cases <code>A(1, n)</code>) it takes 9 minutes to compute <code>A(3, 10)</code> on the computer I've tested it on. With that special case it's fast enough that the online demo takes less than 10 seconds.</p>

<p>Note that this <em>isn't</em> a naïve translation of the definition. The recursion depth is bounded by <code>m</code>.</p>

<h3>Dissection</h3>

<pre><code>{             # Function boilerplate
  1$          # Get a copy of m: stack holds m n m
  1&gt;{         # (Optimisation): if m is greater than 1
    1         #   Take this as the value of A(m, -1)
    \){       #   Repeat n+1 times:
              #     Stack: m A(m, i-1)
      1$(\    #     Stack: m m-1 A(m, i-1)
      A       #     Stack: m A(m, i)
    }*
    \;        #   Lose that unwanted copy of m
  }{          # Else
    +)        #   A(m in {0, 1}, n) = m + n + 1
  }if
}:A;          # Function boilerplate
</code></pre>
</div>
<div id="pu37" class="pu"><h1>Haskell: <s>81</s> 69 bytes</h1>

<pre><code>a::Int-&gt;Int-&gt;Int
a 0 n=n+1
a m 0=a (m-1) 1
a m n=a (m-1) a m (n-1)
</code></pre>

<p><code>a 3 10</code> takes about 45 seconds.</p>
</div>
<div id="pu38" class="pu"><h2>Mathematica, 46 bytes</h2>

<pre><code>0~a~n_:=n+1
m_~a~n_:=a[m-1,If[n&lt;1,1,a[m,n-1]]]
</code></pre>

<p>Takes pretty much exactly a minute for <code>a[3,10]</code>. Note that Mathematica's default recursion limit is too small for <code>a[3,8]</code> and beyond (at least on my machine), but that can be fixed by configuring</p>

<pre><code>$RecursionLimit = Infinity
</code></pre>
</div>
<div id="pu39" class="pu"><h2>J : 50</h2>

<pre><code>&gt;:@]`(1$:~&lt;:@[)`(&lt;:@[$:[$:_1+])@.(0&gt;.[:&lt;:@#.,&amp;*)M.
</code></pre>

<p>Returns in a fraction of a second for 0...3 vs 0 ... 10:</p>

<pre><code>   A=:&gt;:@]`(1$:~&lt;:@[)`(&lt;:@[$:[$:_1+])@.(0&gt;.[:&lt;:@#.,&amp;*)M.
   timespacex 'res=:(i.4) A"0 table (i.11)'
0.0336829 3.54035e6
   res
┌───┬──────────────────────────────────────────┐
│A"0│0  1  2  3   4   5   6    7    8    9   10│
├───┼──────────────────────────────────────────┤
│0  │1  2  3  4   5   6   7    8    9   10   11│
│1  │2  3  4  5   6   7   8    9   10   11   12│
│2  │3  5  7  9  11  13  15   17   19   21   23│
│3  │5 13 29 61 125 253 509 1021 2045 4093 8189│
└───┴──────────────────────────────────────────┘
</code></pre>

<p>PS: the "0 serves to make A work on each single element, instead of gobbling up the left and right array, and generating length errors. But it's not needed for eg. 9 = 2 A 3 .</p>
</div>
<div id="pu40" class="pu"><h1>Python 2.7.8 - <s>80, 54, 48, 46</s> 45</h1>

<pre><code>A=lambda m,n:m and A(m-1,n&lt;1or A(m,n-1))or-~n
</code></pre>

<p>(Credits to xnor!)</p>

<p>More readable, but with 1 more character:</p>

<pre><code>A=lambda m,n:n+(m&lt;1or A(m-1,n&lt;1or A(m,n-1))-n)
</code></pre>

<p>Not that I had to set <code>sys.setrecursionlimit(10000)</code> in order to get a result for <code>A(3,10)</code>. Further golfing using logical indexing did not work due to the dramatically growing recursion depth.</p>
</div>
<div id="pu41" class="pu"><h1>JavaScript (ES6) - 34</h1>

<pre class="lang-js prettyprint-override"><code>A=(m,n)=&gt;m?A(m-1,!n||A(m,n-1)):n+1
</code></pre>

<p>And a test:</p>

<pre class="lang-js prettyprint-override"><code>&gt; A=(m,n)=&gt;m?A(m-1,!n||A(m,n-1)):n+1;s=new Date().getTime();console.log(A(3,10),(new Date().getTime() - s)/1000)
8189 16.441
</code></pre>
</div>
<div id="pu42" class="pu"><h2>JavaScript, ES6, <s>41</s> 34 bytes</h2>

<pre><code>f=(m,n)=&gt;m?f(m-1,!n||f(m,n-1)):n+1
</code></pre>

<p>Run this in a latest Firefox Console and it will create a function called <code>f</code> which you can call with different values of <code>m</code> and <code>n</code> like</p>

<pre><code>f(3,2) // returns 29
</code></pre>

<p>OR</p>

<p>try the code below in a latest Firefox</p>

<p><div class="snippet" data-lang="js" data-hide="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>f=(m,n)=&gt;m?f(m-1,!n||f(m,n-1)):n+1

B.onclick=_=&gt;alert(f(+M.value, +N.value))</code></pre>
<pre class="snippet-code-css lang-css prettyprint-override"><code>#M,#N{max-width:15px;border: 1px solid;border-width:0 0 1px 0}</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;div&gt;f(&lt;input id=M /&gt;,&lt;input id=N /&gt;)&lt;/div&gt;&lt;br&gt;&lt;button id=B&gt;Evaluate&lt;/button&gt;</code></pre>
</div>
</div>
</p>
</div>
<div id="pu43" class="pu"><h1>C - 41 bytes</h1>
<p>Nothing to it--the small limits mean that all the required values can be calculated in less than 1 second by naively following the function definition.</p>
<pre><code>A(m,n){return!m?n+1:A(m-1,n?A(m,n-1):1);}


int main()
{
    int m,n;
    for(m = 0; m &lt;= 3; m++)
    for(n = 0; n &lt;= 10; n++)
    printf(&quot;%d %d %d\n&quot;, m,n,A(m,n));
    return 0;
}
</code></pre>
</div>
<div id="pu44" class="pu"><h1>Racket 67</h1>

<pre><code>(define(a m n)(if(= m 0)(+ n 1)(a(- m 1)(if(= n 0)1(a m(- n 1))))))
</code></pre>
</div>
<!-- TYYY -->

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/QNNN/">QNNN</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




