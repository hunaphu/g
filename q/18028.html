<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::18028</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>078</td><td>Swift 6</td><td>230723T011016Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/263195#263195">macOSist</a></td></tr>
<tr d-ix="1"><td>100</td><td>JavaScript Node.js</td><td>240804T231107Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/274683#274683">Andrew B</a></td></tr>
<tr d-ix="2"><td>047</td><td>Vyxal</td><td>240805T060010Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/274687#274687">emanresu</a></td></tr>
<tr d-ix="3"><td>000</td><td>brainfuck</td><td>240805T044358Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/274685#274685">Andrew B</a></td></tr>
<tr d-ix="4"><td>047</td><td>Japt</td><td>240613T222702Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/273656#273656">Patcail</a></td></tr>
<tr d-ix="5"><td>nan</td><td>Vyxal D</td><td>230902T140143Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/264837#264837">The Empt</a></td></tr>
<tr d-ix="6"><td>nan</td><td>Itr</td><td>230820T081102Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/264397#264397">bsoelch</a></td></tr>
<tr d-ix="7"><td>nan</td><td>Python</td><td>230722T190355Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/263189#263189">The Empt</a></td></tr>
<tr d-ix="8"><td>nan</td><td>Python</td><td>230725T181559Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/263332#263332">The Empt</a></td></tr>
<tr d-ix="9"><td>nan</td><td>Pyt</td><td>230106T201123Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/256418#256418">Kip the </a></td></tr>
<tr d-ix="10"><td>5923</td><td>Pyth</td><td>230105T180252Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/256381#256381">E. Z. L.</a></td></tr>
<tr d-ix="11"><td>8582</td><td>Python</td><td>221013T152615Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/253167#253167">Ginger</a></td></tr>
<tr d-ix="12"><td>100</td><td>Nim</td><td>211201T233742Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/237919#237919">Qaziquza</a></td></tr>
<tr d-ix="13"><td>nan</td><td>Python 3</td><td>220531T150317Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/248036#248036">KinuTheD</a></td></tr>
<tr d-ix="14"><td>nan</td><td></td><td>140109T044849Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18050#18050">Ben Reic</a></td></tr>
<tr d-ix="15"><td>nan</td><td>x86 Assembly</td><td>170620T182814Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/127555#127555">Govind P</a></td></tr>
<tr d-ix="16"><td>nan</td><td>Julia</td><td>171024T202111Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/146257#146257">EricSher</a></td></tr>
<tr d-ix="17"><td>nan</td><td>C gcc</td><td>191021T235544Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/194657#194657">S.S. Ann</a></td></tr>
<tr d-ix="18"><td>099</td><td>Pxem</td><td>210603T115228Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/226838#226838">user1004</a></td></tr>
<tr d-ix="19"><td>nan</td><td>TIBasic</td><td>211020T224159Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/236476#236476">Youserna</a></td></tr>
<tr d-ix="20"><td>nan</td><td></td><td>211020T121441Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/236460#236460">0xff</a></td></tr>
<tr d-ix="21"><td>nan</td><td>Mathematica</td><td>211020T061617Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/236454#236454">FarSeenN</a></td></tr>
<tr d-ix="22"><td>nan</td><td>C  61 Bytes x8664 only Score \$ \approx 8.14 \times 10^{2553} = 10\uparrow\uparrow 2.53251 \$</td><td>220327T200828Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/245650#245650">user1117</a></td></tr>
<tr d-ix="23"><td>099</td><td>Python 3</td><td>220326T172935Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/245624#245624">Larry Ba</a></td></tr>
<tr d-ix="24"><td>nan</td><td>Python 3</td><td>211129T203716Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/237826#237826">Larry Ba</a></td></tr>
<tr d-ix="25"><td>095</td><td>Python 3</td><td>220112T192245Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/240956#240956">Larry Ba</a></td></tr>
<tr d-ix="26"><td>nan</td><td>Python</td><td>220403T094800Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/245890#245890">Caelus</a></td></tr>
<tr d-ix="27"><td>025</td><td>PHP4</td><td>220330T222620Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/245771#245771">user1117</a></td></tr>
<tr d-ix="28"><td>099</td><td>Python 3</td><td>220127T183142Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/241883#241883">Larry Ba</a></td></tr>
<tr d-ix="29"><td>nan</td><td>Pyth</td><td>220118T003844Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/241209#241209">E. Z. L.</a></td></tr>
<tr d-ix="30"><td>000</td><td>C clang</td><td>211119T095751Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/237466#237466">emanresu</a></td></tr>
<tr d-ix="31"><td>100</td><td>TIBasic</td><td>211024T003947Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/236574#236574">MarcMush</a></td></tr>
<tr d-ix="32"><td>005</td><td>Ruby</td><td>171202T225438Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/149763#149763">Simply B</a></td></tr>
<tr d-ix="33"><td>nan</td><td>Rust</td><td>201027T171248Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/214246#214246">Aiden4</a></td></tr>
<tr d-ix="34"><td>044</td><td>JavaScript</td><td>140108T235300Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18032#18032">Eliseo D</a></td></tr>
<tr d-ix="35"><td>064</td><td>Idris</td><td>190805T094657Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/189261#189261">univalen</a></td></tr>
<tr d-ix="36"><td>nan</td><td></td><td>170512T114438Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/120228#120228">Simply B</a></td></tr>
<tr d-ix="37"><td>nan</td><td></td><td>190115T101638Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/178768#178768">bentalle</a></td></tr>
<tr d-ix="38"><td>nan</td><td>Come Here</td><td>160325T140213Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/76259#76259">SuperJed</a></td></tr>
<tr d-ix="39"><td>3127</td><td>Julia</td><td>171101T045027Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/146791#146791">eaglgene</a></td></tr>
<tr d-ix="40"><td>097</td><td>brainfuck</td><td>180225T065219Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/156702#156702">Jo King</a></td></tr>
<tr d-ix="41"><td>nan</td><td>J</td><td>171229T004059Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/152048#152048">Bolce Bu</a></td></tr>
<tr d-ix="42"><td>nan</td><td>Javascript</td><td>150515T021136Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/50199#50199">SuperJed</a></td></tr>
<tr d-ix="43"><td>nan</td><td>Pyth</td><td>171203T074824Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/149781#149781">Steven H</a></td></tr>
<tr d-ix="44"><td>010</td><td>Braingolf</td><td>170517T163646Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/121200#121200">Mayube</a></td></tr>
<tr d-ix="45"><td>nan</td><td></td><td>140109T010709Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18039#18039">Timtech</a></td></tr>
<tr d-ix="46"><td>100</td><td>Haskell</td><td>170519T184733Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/121675#121675">BlackCap</a></td></tr>
<tr d-ix="47"><td>nan</td><td></td><td>140109T043207Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18049#18049">ecksemme</a></td></tr>
<tr d-ix="48"><td>nan</td><td>Python</td><td>140109T173438Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18092#18092">recursiv</a></td></tr>
<tr d-ix="49"><td>098</td><td>JavaScript</td><td>140109T053339Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18055#18055">serakfal</a></td></tr>
<tr d-ix="50"><td>nan</td><td>Python 3</td><td>160510T053717Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/79694#79694">Magenta</a></td></tr>
<tr d-ix="51"><td>nan</td><td>ECMAScript 6  10^3↑↑↑↑3 /</td><td>140109T141046Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18075#18075">Kendall </a></td></tr>
<tr d-ix="52"><td>nan</td><td></td><td>140109T025201Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18045#18045">Kyle Kan</a></td></tr>
<tr d-ix="53"><td>nan</td><td></td><td>140109T052456Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18052#18052">ybeltuko</a></td></tr>
<tr d-ix="54"><td>nan</td><td></td><td>140109T011930Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18041#18041">Hand-E-F</a></td></tr>
<tr d-ix="55"><td>nan</td><td>Haskell</td><td>140109T231047Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18134#18134">n. m. co</a></td></tr>
<tr d-ix="56"><td>nan</td><td>Javascript</td><td>140109T085617Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18062#18062">Andrew C</a></td></tr>
<tr d-ix="57"><td>nan</td><td>C</td><td>140110T164151Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18196#18196">Art</a></td></tr>
<tr d-ix="58"><td>nan</td><td></td><td>140109T075056Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18060#18060">David Ya</a></td></tr>
<tr d-ix="59"><td>nan</td><td>C</td><td>140108T233116Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18029#18029">Darren S</a></td></tr>
<tr d-ix="60"><td>nan</td><td>Javascript</td><td>160505T204750Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/79481#79481">Qwertiy</a></td></tr>
<tr d-ix="61"><td>nan</td><td>Lua</td><td>160510T225541Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/79720#79720">Blab</a></td></tr>
<tr d-ix="62"><td>100</td><td>AWK</td><td>160326T131822Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/76311#76311">Robert B</a></td></tr>
<tr d-ix="63"><td>nan</td><td>GNU Bash</td><td>140109T165508Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18085#18085">Joshua</a></td></tr>
<tr d-ix="64"><td>nan</td><td>R</td><td>160505T195120Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/79477#79477">lebatsno</a></td></tr>
<tr d-ix="65"><td>nan</td><td>Mathematica</td><td>161227T003518Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/104719#104719">Horv&#22</a></td></tr>
<tr d-ix="66"><td>084</td><td>JavaScript  84 Characters  Final Score 2.082941723E+2886 ≈ 10↑↑2.390912646</td><td>140109T203746Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18116#18116">zoplonix</a></td></tr>
<tr d-ix="67"><td>092</td><td>C</td><td>140109T230543Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18133#18133">Tyzoid</a></td></tr>
<tr d-ix="68"><td>nan</td><td>PHP</td><td>160102T193503Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/68443#68443">9999year</a></td></tr>
<tr d-ix="69"><td>nan</td><td>R   41 characters of code</td><td>160505T192210Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/79475#79475">lebatsno</a></td></tr>
<tr d-ix="70"><td>nan</td><td>BrainFlak</td><td>170213T024453Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/109872#109872">Wheat Wi</a></td></tr>
<tr d-ix="71"><td>nan</td><td></td><td>140407T094040Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/25427#25427">Nikolopo</a></td></tr>
<tr d-ix="72"><td>100</td><td>dc</td><td>140110T030537Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18153#18153">ashastra</a></td></tr>
<tr d-ix="73"><td>1034</td><td>APL</td><td>140109T000100Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18033#18033">Tobia</a></td></tr>
<tr d-ix="74"><td>1000</td><td>GolfScript score at least fε_0+ω+117 /</td><td>140120T150547Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18954#18954">Peter Ta</a></td></tr>
<tr d-ix="75"><td>nan</td><td></td><td>140120T130359Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18948#18948">Pouya</a></td></tr>
<tr d-ix="76"><td>nan</td><td>GolfScript</td><td>140119T204652Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18920#18920">r.e.s.</a></td></tr>
<tr d-ix="77"><td>026</td><td>Ruby</td><td>140118T194425Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18853#18853">histocra</a></td></tr>
<tr d-ix="78"><td>nan</td><td></td><td>140118T031027Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18796#18796">Reut Sha</a></td></tr>
<tr d-ix="79"><td>673</td><td>C</td><td>140118T031945Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18797#18797">AlliedEn</a></td></tr>
<tr d-ix="80"><td>nan</td><td></td><td>140118T012451Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18791#18791">iWiggins</a></td></tr>
<tr d-ix="81"><td>nan</td><td>Squeak Smalltalk cheat > 2^^2^30 / 71^3 chars</td><td>140117T231206Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18782#18782">aka.nice</a></td></tr>
<tr d-ix="82"><td>nan</td><td></td><td>140109T070109Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18058#18058">primo</a></td></tr>
<tr d-ix="83"><td>813</td><td>C</td><td>140116T052551Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18597#18597">Nate Eld</a></td></tr>
<tr d-ix="84"><td>nan</td><td></td><td>140115T125926Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18547#18547">nl-x</a></td></tr>
<tr d-ix="85"><td>nan</td><td></td><td>140115T100155Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18542#18542">Dennis J</a></td></tr>
<tr d-ix="86"><td>099</td><td>Python 3</td><td>140113T064735Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18359#18359">Cel Skeg</a></td></tr>
<tr d-ix="87"><td>nan</td><td>Python 3 98 chars</td><td>140112T054222Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18296#18296">Cel Skeg</a></td></tr>
<tr d-ix="88"><td>100</td><td>x86 machine code</td><td>140111T164817Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18253#18253">Robert S</a></td></tr>
<tr d-ix="89"><td>099</td><td>Haskell  Ackermann function applied to its result 20 times</td><td>140110T093027Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18169#18169">Toeofdoo</a></td></tr>
<tr d-ix="90"><td>nan</td><td>This is madness</td><td>140110T175945Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18199#18199">user1437</a></td></tr>
<tr d-ix="91"><td>nan</td><td></td><td>140110T014243Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18150#18150">Kevin Fe</a></td></tr>
<tr d-ix="92"><td>321</td><td>Windows 2000  Windows 8 3907172 / 23³ =</td><td>140109T003007Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18036#18036">Hand-E-F</a></td></tr>
<tr d-ix="93"><td>054</td><td>Ruby</td><td>140109T144705Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18077#18077">histocra</a></td></tr>
<tr d-ix="94"><td>091</td><td>C</td><td>140109T140701Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18074#18074">Oberon</a></td></tr>
<tr d-ix="95"><td>nan</td><td>GolfScript</td><td>140109T101332Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18064#18064">Ilmari K</a></td></tr>
<tr d-ix="96"><td>101</td><td>C++</td><td>140109T014031Z</td><td><a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18042#18042">user1076</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Swift 6, <s>96</s> <s>93</s> 78 bytes, <span class="math-container">\${1.22333444 \times 10^{3.352318 \times 10^{39}} \over 474552} \approx 1.22333444 \times 10^{10^{39.52534}} \approx 10 \uparrow\uparrow 3.203271104730497 \$</span></h1>
<p>(dunno how to simplify the score further, if anyone has any tips, please let me know!)</p>

<pre class="lang-swift prettyprint-override"><code>for i in.zero ... ~UInt.zero{print(terminator:{String.init}()(&quot;\(i)&quot;,Int(i)))}
</code></pre>
<p>Ungolfed and commented:</p>
<pre class="lang-swift prettyprint-override"><code>// ~UInt.zero == UInt.max == 2**64-1 == 18_446_744_073_709_551_615
for i in .zero ... ~UInt.zero {
  print(
    // {String.init}()(_:_:) is equivalent to String(repeating:count:)
    terminator: {String.init}()(
      &quot;\(i)&quot;, // equivalent to String(describing: i)
      Int(i) // i is a UInt, so we need to cast it
    ),
  )
}
</code></pre>
<h2>Analysis</h2>
<p>What we're doing here is taking the string representation of <span class="math-container">\$n\$</span> (where <span class="math-container">\$n ∈ ℕ\$</span>) and concatenating it with itself <span class="math-container">\$n\$</span> times. So, for example, <span class="math-container">\$13\$</span> gets turned in to <span class="math-container">\$13\,131\,313\,131\,313\,131\,313\,131\,313\$</span>. We do this all the way up to <span class="math-container">\$2^{64}-1\$</span>, and then concatenate all <em>those</em> strings together.</p>
<p>Obviously, this takes a couple of eternities to run. But we <em>can</em> calculate how many digits will be in the final number!</p>
<p>We can get the number of digits in a single number using base-10 logarithms:</p>
<p><span class="math-container">$$
\text{digits}(n) = \cases{
  ⌊ \log_{10} n ⌋ + 1 &amp; \( n &gt; 0 \) \\
  1 &amp; \( n = 0 \)
}
$$</span></p>
<p>(In Mathematica, this is a built-in called <code>IntegerLength</code>.)</p>
<p>We then multiply this digit count by the number itself, and then add up all the counts between <span class="math-container">\$0\$</span> and <span class="math-container">\$2^{64}-1\$</span>:<sup>1</sup></p>
<p><span class="math-container">$$
S = \sum^{2^{64} - 1}_{n = 0} {\text{digits}(n) × n}
$$</span></p>
<p>In terms of Mathematica:</p>
<pre class="lang-mathematica prettyprint-override"><code>Sum[
  n * IntegerLength[n],
  {n, 0, 2^64-1}
]
</code></pre>
<blockquote>
<p>I wasn't able to get this to run to completion on the free plan of Wolfram Cloud that I signed up for just now, but with a little bit of hand optimization, I think I figured it out. Here's what I ended up with:</p>
<pre class="lang-mathematica prettyprint-override"><code>Sum[
  Sum[
    i n,
    {n, 10^(i-1), Min[10^i-1, 2^64-1]}
  ],
  {i, 20}
]
</code></pre>
</blockquote>
<p>Running this, it looks like we have <span class="math-container">\$3\,352\,318\,618\,704\,334\,129\,404\,329\,138\,631\,091\,648\,905\$</span> digits. That's 3 <em>duodecillion</em> digits. The number of digits in this program's output is <em>itself</em> a 40-digit number.<sup>2</sup></p>
<p>What this means is that the size of the number itself is on the order of <span class="math-container">\$10^{3.35×10^{39}}\$</span>, which gives us a final score of about <span class="math-container">\$1.22333444 × 10^{10^{39.52534}}\$</span>. (The code size penalty, a meager <span class="math-container">\$78^3 = 474\,552\$</span>, is completely negligible.)</p>
<p><sup>1: Of course, <span class="math-container">\$\text{digits}(0) × 0 = 0\$</span>. But I need to use zero instead of one in the original code to avoid digit characters (the <a href="https://swiftinit.org/docs/swift/swift/additivearithmetic" rel="nofollow noreferrer"><code>AdditiveArithmetic</code></a> protocol conveniently exposes a <a href="https://swiftinit.org/docs/swift/swift/additivearithmetic.zero?hash=7SS88" rel="nofollow noreferrer"><code>.zero</code></a> static, but there is no such thing as <code>.one</code>), so we might as well include it in the analysis, too.</sup></p>
<p><sup>2: Absolutely <em>nothing</em> compared to what's on the leaderboard, but hey, I'm still impressed with myself.</sup></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 100 bytes</h1>
<p>score: <span class="math-container">$$ 10↑^{10↑^{10↑^{10}10}10}10 $$</span></p>
<pre><code>o=+!+[]
g=n=&gt;n?(''+o+g(n-o)):o
k=(n,z)=&gt;n?(z?k:g)(k(n-o,z),z-o):o
console.log(k(r=g(o),k(r,k(r,r))))
</code></pre>
<p><a href="https://tio.run/##HYpBCoNAEATv/iInZ9g1DxBGHxJyEJUhWZmWNeSwn19HGxqarvpO/@mY82f/dYZlrRUSHuH1blRMBhupbQOCknVg7tEkIYuFb1TG1CtTuqB/sbjjygw7sK3PDeosixI4@rib2VPrCQ" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<p>EDIT: After thinking it over, I concluded that I don't need to use BigInt for the following reason: both BigInt and regular int are going to be maxed out by the numbers needed to do the calculation, so I've used int, based on the assumption that MAX_SAFE_INTEGER large enough.</p>
<p>My code is based on the following functions:</p>
<p><span class="math-container">$$ g(n) = 10^n $$</span>
<span class="math-container">$$ k(n,z) = 10 ↑^{z+2} n $$</span></p>
<p>Thus, when z=0 we have tetration, when z=1 we have pentation etc.</p>
<p>Note that k is just a function, so after a bit of tweaking, I was able to pass the result from k() back into k() (twice).</p>
<p>As a result the code outputs the following number (approx)</p>
<p><span class="math-container">$$ 10↑^{10↑^{10↑^{10}10}10}10 $$</span></p>
<p>I say approx because to save space, I only used 1's in the code.</p>
<p>The byte count is 100, which means a penalty of approx 1,000,000 which is negligible given the size of the number output.</p>
<p>EDIT #2: It bothered me that I couldn't test my code since it just maxes out the call-stack. So, what I did was to write some 'unit tests' - broke the code into pieces and test each in turn.</p>
<ol>
<li>Test g(n)</li>
</ol>

<pre class="lang-javascript prettyprint-override"><code>o=+!+[]
g=n=&gt;n?(''+o+g(n-o)):o

console.log(`g(0) ${g(0)}`)
console.log(`g(1) ${g(1)}`)
console.log(`g(2) ${g(2)}`)

</code></pre>
<p><a href="https://tio.run/##y0osSyxOLsosKNHNy09J/f8/31ZbUTs6livdNs/WLs9eQ11dO187XSNPN19T0yqfiys5P684PydVLyc/XSMhXcNAU0GlGkTVJmiiyxlC5AyxyRlB5IzAcv//AwA" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<p>output:</p>
<pre class="lang-javascript prettyprint-override"><code>g(0) 1
g(1) 11
g(2) 111
</code></pre>
<ol start="2">
<li>Test k(n,z) with g(n) re-written so that:</li>
</ol>
<p><span class="math-container">$$ g(n) = 2^n $$</span></p>

<pre class="lang-javascript prettyprint-override"><code>o=1n
g=n=&gt;2n**n
k=(n,z)=&gt;n?(z?k:g)(k(n-o,z),z-o):o

console.log(`k(0,0) ${k(0n,0n)}`)
console.log(`k(1,0) ${k(1n,0n)}`)
console.log(`k(2,0) ${k(2n,0n)}`)
console.log(`k(3,0) ${k(3n,0n)}`)
console.log(`k(4,0) ${k(4n,0n)}`)
console.log()
console.log(`k(0,1) ${k(0n,1n)}`)
console.log(`k(1,1) ${k(1n,1n)}`)
console.log(`k(2,1) ${k(2n,1n)}`)
console.log(`k(3,1) ${k(3n,1n)}`)
console.log()
console.log(`k(0,2) ${k(0n,2n)}`)
console.log(`k(1,2) ${k(1n,2n)}`)
console.log(`k(2,2) ${k(2n,2n)}`)

</code></pre>
<p><a href="https://tio.run/##jc6xDoIwEMbxvU/h4NCSYriDiaTwKhAkREvujBgHjM9eGWwH9RK3L1/@w@/c3/tluJ4ut5z4OIbADkhNjlyDlGWkvNNkV@MaavXa@noy2mvKefvsmrOpWamBaeF5PMw86c7rwhZmt39sg2xB5tmZzwJiAVKBsUCpKGNRSkUVi@pnYb7dkNwguCG5QXBDcoPghuSGv1SYVCioMKlQUGFSvYsQXg" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<p>output:</p>
<pre class="lang-javascript prettyprint-override"><code>k(0,0) 1
k(1,0) 2
k(2,0) 4
k(3,0) 16
k(4,0) 65536

k(0,1) 1
k(1,1) 2
k(2,1) 4
k(3,1) 65536

k(0,2) 1
k(1,2) 2
k(2,2) 4
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal/tree/version-2" rel="nofollow noreferrer">Vyxal</a>, 47 bytes, <span class="math-container">\$G^{26}(26)\$</span></h1>
<pre><code>nL:(&amp;⇧{:|wλ¥≥[¥τ:ẏṘvxZ;Mh&amp;›λ-[∩÷vx¥$e*∑;†‹←›→}→
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/?v=2&amp;c=1#WyIiLCIiLCJuTDooJuKHp3s6fHfOu8Kl4omlW8Klz4Q64bqP4bmYdnhaO01oJuKAus67LVviiKnDt3Z4wqUkZSriiJE74oCg4oC54oaQ4oC64oaSfeKGkiIsIiIsIjMiXQ==" rel="nofollow noreferrer">Try it Online!</a></p>
<p>This computes the <a href="https://en.wikipedia.org/wiki/Goodstein%27s_theorem" rel="nofollow noreferrer">Goodstein function</a> of 26, 26 times. The code is a mess and I don't feel like explaining it right now. To the best of my understanding, this is bounded above by all the solutions that use <span class="math-container">\$f_{\epsilon}\$</span> or anything larger.</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/TryItOnline/brainfuck" rel="nofollow noreferrer">brainfuck</a>, 50 bytes - score approx 10^16,000,000</h1>
<pre><code>+&gt;+++++[-&gt;+++++++++++&lt;]&gt;++[&gt;-]&gt;&gt;&gt;+&gt;[[&gt;]&lt;-&lt;[&lt;]&lt;.&gt;&gt;]
</code></pre>
<p><a href="https://tio.run/##SypKzMxLK03O/v9f204bBKJ1ITQE2MQCedF2urF2dnbadtHRdrE2ujbRNrE2enZ2sf//AwA" rel="nofollow noreferrer" title="brainfuck – Try It Online">Try it online!</a></p>
<p>I decided to try to print a big number in brainfuck. On TIO, I ran a program to check the length of the tape - it's about 65,000 cells.</p>
<p>So, the number I output is approx:</p>
<p><span class="math-container">$$ 10^{65000*255} $$</span></p>
</div>
<div id="pu4" class="pu"><h1>Japt, 47 bytes, BMS[26] ~ f<sub>PTO(Z<sub>2</sub>)</sub>(26)</h1>
<p><a href="https://ethproductions.github.io/japt/?v=1.4.6&amp;code=O1SwP1XKP99VY1VzWD1VbyltXzxYLVglQso/WjpaK1XKLVg6VDrfQspvIGNCym8=&amp;input=" rel="noreferrer">Code snippet</a></p>
<h3>NUCLEAR BOMB ALERT</h3>
<p>This is probably the largest number ever posted on this site that is less than Loader's Number. We utilize the <a href="https://googology.fandom.com/wiki/Bashicu_matrix_system" rel="noreferrer">Bashicu Matrix System</a>, which is a ridiculously powerful notation that is <a href="https://arxiv.org/abs/2307.04606" rel="noreferrer">proven to terminate</a>, but whose strength is unknown. We know BMS is at least as strong as collapsing inaccessible cardinals with respect to standard fundamental sequences, though that was an understatement. BMS is conjectured to reach the limit of <a href="https://en.wikipedia.org/wiki/Second-order_arithmetic" rel="noreferrer">second order arithmetic</a>.</p>
<p>In all of its full glory, here is the code. I could probably optimize this more (idk what to do with the other 50 bytes) or port this to a more familiar language. If you want to copy me, you are free to do so, but credit me:</p>
<pre><code>;T°?UÊ?ßUcUsX=Uo)m_&lt;X-X%BÊ?Z:Z+UÊ-X:T:ßBÊo cBÊo
</code></pre>
<p><a href="https://ethproductions.github.io/japt/?v=1.4.6&amp;code=O1SwP1XKP99VY1VzWD1VbyltXzxYLVglQso/WjpaK1XKLVg6VDrfQspvIGNCym8=&amp;input=" rel="noreferrer">Try it here!</a></p>
<p>The rest of this post will first show what BMS is, and how it is so strong. Then, we introduce Flattened Address Matric System (FAMS) and how it is another representation of BMS. Finally, we analyze the program part and show how this program calculates BMS.</p>
<p>Resources:</p>
<ul>
<li><a href="https://googology.fandom.com/wiki/Introduction_to_Bashicu_matrix_system" rel="noreferrer">Intro to BMS</a></li>
<li><a href="https://docs.google.com/presentation/d/1SVL6GaS4H-KGN_iA-X_LRqvL16huRuD6WOxzo8KYlRQ/edit?usp=sharing" rel="noreferrer">Visual BMS</a></li>
<li><a href="https://hypcos.github.io/notation-explorer/" rel="noreferrer">Expansion Playground</a></li>
<li><a href="https://discord.gg/2KWvvE3BzX" rel="noreferrer">Googology Discord (they have a section entirely dedicated to BMS)</a></li>
</ul>
<h2>What is BMS anyways?</h2>
<p>Now although I could start listing expansion rules, I figured the resources above do a better job showing the power of BMS. Thus, I would focus more on the structuring on BMS.</p>
<p>The Bashicu Matrix System is a system of matrices with an expansion rule, causing these matrices to behave similar to ordinals. They are lexicographically ordered, and there are many subsystems: PrSS which is 1-row BMS, PSS which is 2-row BMS, TSS which is 3-row BMS, and so on.</p>
<p>We represent a BMS matrix like this: (a,b,c)(d,e,f)(g,h,j)(k,l,m),... which corresponds to 3-row BMS, though extra rows are possible. Each 3-tuple corresponds to a BMS column. Moreover, each element/number has exactly one parent corresponding to its row level within its column. Thus, try to think of BMS as multitrees or a direct acyclic graph; that is trees that are layered on top of each other, and each column having a level 1 parent, a level 2 parent, and so on.</p>
<p>It could be possible that a parent does not exist for a particular level within a column. This is usually represented in BMS by a zero, or a self-address in FAMS. Let me show an example.
<a href="https://i.sstatic.net/6wqtUNBM.png" rel="noreferrer"><img src="https://i.sstatic.net/6wqtUNBM.png" alt="A multitree associated with (0,0,0)(1,1,1)(2,1,0)(3,1,0)" /></a></p>
<p>Here, you can see Level 1 parents in black connections, the Level 2 parents in red connections, and the Level 3 parents in blue connections.</p>
<p>Now here is the neat part: when expanding a BMS matrix, all of the parent-child relationships are preserved except possibly the rightmost node. Read the resources above more to understand BMS more.</p>
<h2>Introducing FAMS</h2>
<p>We can make BMS easier to understand by replacing each element with an address of its parent (i.e. what column its parent refers to). Parent addresses are always smaller than their children. Some elements may not have parents; in that case we let those elements be their own parents (so we have a self-referential address). This notation is called AMS, or Address Matrix System.</p>
<p>To go from AMS to FAMS, we flatten the entire matrix, so (a,b,c)(d,e,f)(g,h,i),... becomes {3}[a,b,c,d,e,f,g,h,i,...], where the {3} indicates that there are three rows.</p>
<p>FAMS has a few more simplifications - mainly that trailing zeroes in BMS, or trailing self-references in FAMS, are omitted.</p>
<p>Some examples of BMS matrices and their correspondence to FAMS:</p>
<ul>
<li>(0,0)(1,1) = {2}[0,1,0,1]</li>
<li>(0,0)(1,1)(2,0) = {2}[0,1,0,1,2]</li>
<li>(0,0)(1,1)(2,0)(1,1) = {2}[0,1,0,1,2,5,0,1]</li>
<li>(0,0)(1,1)(2,1)(0,0)(1,0) = {2}[0,1,0,1,2,3,6,7,6]</li>
<li>(0,0,0)(1,1,0)(2,2,0) = {3}[0,1,2,0,1,5,3,4]</li>
<li>(0,0,0)(1,1,1) = {3}[0,1,2,0,1,2]</li>
</ul>
<p>Here is code converting between FAMS and BMS</p>
<pre><code>function FAMS_to_BMS(arr,rows) {
    
    for (let i=0;i&lt;arr.length;i++) { //loop over all
        arr[i]=arr[i]==i?0:1+arr[arr[i]]       
    }
    
    // Initialize the resulting array of blocks
    let result = [];
    
    // Loop through the array in steps of 'size'
    for (let i = 0; i &lt; arr.length; i += rows) {
        // Extract a block of 'size' elements
        let block = arr.slice(i, i + rows);
        
        // If the block is smaller than the desired size, pad it with zeroes
        while (block.length &lt; rows) {
            block.push(0);
        }
        
        // Add the block to the result array
        result.push(block);
    }
    
    return result;
}

function parent(matrix,row,col) { //returns column that is a parent
    if (row==-1) {
        return col-1
    }
    let c = col
    let element = matrix[col][row]
    while(c &gt;= 0 &amp;&amp; matrix[c][row]&gt;=element) {
        c = parent(matrix,row-1,c)
    }
    return c &gt;= 0 ? c : -1 // cannot find
}

function BMS_to_FAMS(matrix,rows) {
    arr = []
    for (let i=0;i&lt;matrix.length;i++) {
        for(j=0;j&lt;rows;j++) {
            let p = parent(matrix,j,i)
            arr.push(p==-1?i*rows+j:p*rows+j)
        }
    }
    while (arr[arr.length-1]==arr.length-1) {
        arr.pop()
    }
    return arr
}
</code></pre>
<p>More importantly, expansion in FAMS is ridiculously easy:</p>
<pre><code>function Expand(matrix,rows,amount) {
    child = matrix.pop()
    ascension = matrix.length - child 
    pre_expand = Array(amount).map((x,y)=&gt;y+1) //array 1,2...amount
    append = pre_expand.flatMap(q=&gt;
        matrix.slice(child).map(x=&gt;x&gt;=child-child%rows?x+ascension*q:x))
    return matrix.concat(append)
}
</code></pre>
<p>In the code below, you would find out that we expand with <code>q=1</code>. This actually corresponds to the Slow Growing Hierarchy, with base equal to 2. It turns out that this expansion is nondegenerate starting from <code>[0,1,2,...,n,0,1,2,...,n]</code>, since at each non-successor step we remove 1 element and add a (multiple of number of rows) number of elements. Another possible concern is that SGH is much weaker than the FGH, though there are &quot;<a href="https://googology.fandom.com/wiki/User_blog:Hyp_cos/Analysis_-_BEAF,_FGH_and_SGH_(part_3)" rel="noreferrer">catching points</a>&quot; where SGH has similar strength to the FGH. The first catching point starts at ψ(Ω<sub>ω</sub>), but BMS goes <em>waaaaaaay</em> beyond that.</p>
<h2>Analysis</h2>
<p>This is best done by converting to ungolfed JavaScript.</p>
<pre><code>ALPHABET = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;                   // ; (built-in, variable B)
rows = 26                                                 // BÊ (our &quot;constant&quot;, we just take length of alphabet)
T = 0                                                     // (implicit start)
matrix = Array(rows).fill(&quot;&quot;).map((x,y)=&gt;y)               // BÊo (creates 0,1,2,...,25 array)
matrix = matrix.concat(matrix)                            // cBÊo (duplicates array)
while (matrix.length) {                                   // ß (run program again loop)
    child = matrix.pop()                                  // X=Uo  (sets child)
    ascension = matrix.length - child                     // UÊ-X (sets ascension)
    matrix = matrix.concat(matrix.slice(child)            // UcUsX=Uo)
        .map(x=&gt;x&gt;=child-child%rows?x+ascension:x))       // m_&lt;X-X%BÊ?Z:Z+UÊ-X
    T++                                                   // T°
}
alert(T)               //implicit Japt output, using Japt st:out
</code></pre>
<p>Immediately, one sees that this program does not implement Bashicu Matrix System, but rather Flattened Address Matrix System (FAMS), which is equivalent to BMS. In FAMS, there is a constant which denotes the number of rows (rows=26 here), which means that every 26 entries form a single column. Each entry is an address that refers to the 0-index of its parent, though some entries have no parents, in which their addresses refers to themselves.</p>
<p>The large number in this post is {26}(0,1,2,3,...,25;0,1,2,3,...,25), which corresponds to (0,0,...,0,0)(1,1,...,1,1) in BMS. This number is <strong>massive</strong>. To really understand the size of this number, we need to compare BMS with known ordinal correspondences.</p>
<h2>Size Comparison</h2>
<ul>
<li>(0) corresponds to ordinal 1</li>
<li>(0)(0) corresponds to ordinal 2</li>
<li>(0)(1) corresponds to ordinal ω</li>
<li>(0)(1)(0)(1) corresponds to ordinal ω2, beating Graham's Number</li>
<li>(0)(1)(1) corresponds to ordinal ω<sup>2</sup></li>
<li>(0)(1)(1)(1) corresponds to ordinal ω<sup>3</sup></li>
<li>(0)(1)(2) corresponds to ordinal ω<sup>ω</sup></li>
<li>(0)(1)(2)(3) corresponds to ordinal ω<sup>ω<sup>ω</sup></sup></li>
<li>(0,0)(1,1) corresponds to ordinal φ(1,0)</li>
<li>(0,0)(1,1)(1,0)(2,1) corresponds to ordinal φ(1,0)^2</li>
<li>(0,0)(1,1)(1,1) corresponds to ordinal φ(1,1)</li>
<li>(0,0)(1,1)(2,0) corresponds to ordinal φ(1,ω)</li>
<li>(0,0)(1,1)(2,1) corresponds to ordinal φ(2,0)</li>
<li>(0,0)(1,1)(2,1)(2,1) corresponds to ordinal φ(3,0)</li>
<li>(0,0)(1,1)(2,1)(3,0) corresponds to ordinal φ(ω,0)</li>
<li>(0,0)(1,1)(2,1)(3,1) corresponds to ordinal φ(1,0,0)</li>
<li>(0,0)(1,1)(2,1)(3,1)(4,0) corresponds to the Small Veblen Ordinal, beating all other entries on this list</li>
<li>(0,0)(1,1)(2,1)(3,1)(4,1) corresponds to the Large Veblen Ordinal, beating TREE(3)</li>
<li>(0,0)(1,1)(2,2) corresponds to the Bachmann-Howard Ordinal</li>
<li>(0,0)(1,1)(2,2)(3,3) corresponds to ψ(Ω<sub>3</sub>), collapsing Extended Buchholz OCF</li>
<li>(0,0,0)(1,1,1) corresponds to ψ(Ω<sub>ω</sub>); the limit of the Π<sub>1</sub>-CA<sub>0</sub> subsystem of Z<sub>2</sub> and also the first Catching ordinal</li>
<li>(0,0,0)(1,1,1)(2,1,0) corresponds to ψ(Ω<sub>ω</sub>*Ω)</li>
<li>(0,0,0)(1,1,1)(2,1,0)(1,1,1) corresponds to ψ(Ω<sub>ω</sub>^2), which is the first time BMS really takes off</li>
<li>(0,0,0)(1,1,1)(2,1,1)(3,1,0)(2,0,0) corresponds to ψ(ψ<sub>I</sub>(0))</li>
<li>(0,0,0)(1,1,1)(2,1,1)(3,1,1) corresponds to ψ(ψ<sub>I<sub>ω</sub></sub>(0))
...</li>
<li>(0,0,0)(1,1,1)(2,2,1)(3,0,0) corresponds to the limit of <a href="https://stepstowardinfinity.wordpress.com/array/" rel="noreferrer">Strong Array Notation</a>
...</li>
<li>(0,0,0)(1,1,1)(2,2,2) is expected to correspond to the limit of Π<sub>2</sub>-CA<sub>0</sub> subsystem of Z<sub>2</sub></li>
<li>(0,0,0,0,0,...)(1,1,1,1,1,...) is expected to correspond to the limit of Z<sub>2</sub></li>
</ul>
<h2>Conclusion</h2>
The Bashicu Matrix System is known to be very powerful. Analysis of BMS is still a very active field in Googology, and there are a few extensions (such as the  Y-sequence). This BMS number is smaller than Loader's Number, since BMS is bounded above by the limit of second order arithmetic.
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a> <code>D</code>, at least <span class="math-container">\$42781\underbrace{!!!!!…}_{42781\underbrace{!!!…}_{42781}\$</span></h1>
<pre><code>`\ꜝC`\¡\ꜝC¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡ẋ+Ė→`\`\ꜝC\`\¡`←ẋ←`ẋ+Ė`←ẋ++Ė
</code></pre>
<p>I basically used factorial and string repetition to get some very large number. Outputs a <code>RecursionError</code> in the online interpreter, which it seems to do when  you factorial a very very big number.</p>
<p><a href="https://vyxal.pythonanywhere.com/?v=2#WyJEIiwiIiwiYFxc6pydQ2BcXMKhXFzqnJ1DwqHCocKhwqHCocKhwqHCocKhwqHCocKhwqHCocKhwqHCocKhwqHCocKhwqHCocKhwqHCocKhwqHCocKhwqHCocKhwqHCocKhwqHCocKhwqHCocKhwqHCocKhwqHCocKhwqHCocKhwqHCocKhwqHCocKhwqHCocKhwqHCoeG6iyvEluKGkmBcXGBcXOqcnUNcXGBcXMKhYOKGkOG6i+KGkGDhuosrxJZg4oaQ4bqLKyvEliIsIiIsIiJd" rel="nofollow noreferrer">Try it Online!</a></p>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/bsoelch/OneChar.js/blob/main/ItrLang.md" rel="nofollow noreferrer">Itr</a>,  approximately <span class="math-container">\$f_{\omega^3+f_{\omega^3}(191)}(f_{\omega^3}(191))\$</span></h1>
<p>(newlines only for readability)</p>
<pre><code>»áF»»Fä«°«¡«$©N
»»+ä«N©«$©a
&quot;««¡N©&quot;$r
»'aáF»&quot;»»&quot;à°r°«©«$©b
»'báF»&quot;»»&quot;à°r°«©«$©c
'¿c»c«N©
</code></pre>
<h2>Explanation</h2>
<p><code>a</code> is the function form the previous solution with with <code>n</code> applications of <code>äF</code> to <code>ä+</code> so <span class="math-container">\$a(n) \approx 2↑^nn \approx f_{\omega}(n)\$</span> in the fast-growing hierarchy.</p>
<p>The innermost layer of <code>b</code> (<code>»»a««¡N©</code>) applies <code>a</code> n-times to the input giving <span class="math-container">\$f_{\omega+n}(n) = f_{2\omega}(n)\$</span></p>
<p>The next layer will apply that function n-times to its own result giving <span class="math-container">\$f_{2\omega+n}(n) = f_{3\omega}(n)\$</span>,</p>
<p><code>b</code> does this <code>n</code> times, therefore <span class="math-container">\$b(n)\$</span> should be approximately <span class="math-container">\$ f_{n·\omega}(n) = f_{\omega^2}(n)\$</span>.</p>
<p><code>c</code> does the same thing as <code>b</code> but with <code>b</code> instead of <code>a</code> so <span class="math-container">\$c(n) \approx f_{n·\omega^2}(n) = f_{\omega^3}(n)\$</span></p>
<p>the last line applies <code>c</code> <code>c(191)</code> times to <code>c(191)</code></p>
<h1>Itr, score at least <span class="math-container">\$2↑^{48}126\$</span></h1>
<p>using only constants, loops and linear functions.</p>
<pre><code>'~äFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFäFä+
</code></pre>
<h2>Explanation</h2>
<p>The <code>'~</code> at the start pushes the constant <code>126</code> (it is possible to increase the number by replacing <code>~</code> with the byte <code>0xbf = 191</code>, but this would not make any significant impact on the total result while needing non-printable bytes)</p>
<p>Each <code>äF</code> applies the next function <code>n</code> times to <code>n</code> where <code>n</code> is the value currently on the stack.</p>
<p><code>ä+</code> will double the value that is currently on the stack, so the last <code>äFä+</code> computes <span class="math-container">\$F_0(k)=2^k*k \approx 2↑k\$</span></p>
<p>Each <code>äF</code> now repeatedly applies the previous function to its own result, so <code>äFäFe</code> computes <span class="math-container">\$F_1(k) = {F_0}^k(k) \approx 2↑2 ... 2↑k \approx 2 ↑↑ k \$</span>.</p>
<p>Each additional <code>äF</code> adds one additional arrow, so the final result should have the same order of magnitude as <span class="math-container">\$2↑^{48}126\$</span>, dividing by <code>100³</code> will not significantly change that number.</p>
</div>
<div id="pu7" class="pu"><h1>Python, <span class="math-container">\$\frac{f_{127}(2047)}{1000000}\$</span> where <span class="math-container">\$f_0(n)=n+1\$</span> and <span class="math-container">\$f_x(n)=f_{x-1}^n(n)\$</span> (superscript means function repetition)</h1>
<pre class="lang-python prettyprint-override"><code>f=lambda x,y:-~y if not x else[y:=f(~-x,y)for _ in range(y)][-g(&quot;&quot;)]
g=ord
print(f(g(&quot;&quot;),g(&quot;߿&quot;)))
</code></pre>
<p>First <code>g</code> contains the character <code>0x01</code>, second <code>g</code> contains the character <code>0x7f</code>.</p>
<p>Grows quite quickly <span class="math-container">\$(f_3(3)\text{ already has 121 million digits!})\$</span></p>
<p><a href="https://tio.run/##K6gsycjPM7YoKPr/P802JzE3KSVRoUKn0kq3rlIhM00hL79EoUIhNac4NbrSyjZNo04XKKmZll@kEK@QmadQlJiXnqpRqRkbrZuuocSopBnLlW6bX5TCVVCUmVeikaYBFK1X0tQBUvf3K2lqav7/DwA" rel="nofollow noreferrer">Try it online!</a></p>
<p><s>If anyone knows the name of the function <span class="math-container">\$f\$</span>, please leave a comment</s> It’s the fast-growing hierarchy.</p>
<h2>Individual hex values (hexdump)</h2>
<pre><code>0x0066 0x003d 0x006c 0x0061 0x006d 0x0062 0x0064 0x0061 0x0020 0x0078 0x002c 0x0079 0x003a 0x002d 0x007e 0x0079 0x0020 0x0069 0x0066 0x0020 0x006e 0x006f 0x0074 0x0020 0x0078 0x0020 0x0065 0x006c 0x0073 0x0065 0x005b 0x0079 0x003a 0x003d 0x0066 0x0028 0x007e 0x002d 0x0078 0x002c 0x0079 0x0029 0x0066 0x006f 0x0072 0x0020 0x005f 0x0020 0x0069 0x006e 0x0020 0x0072 0x0061 0x006e 0x0067 0x0065 0x0028 0x0079 0x0029 0x005d 0x005b 0x002d 0x0067 0x0028 0x0022 0x0001 0x0022 0x0029 0x005d 0x000a 0x0067 0x003d 0x006f 0x0072 0x0064 0x000a 0x0070 0x0072 0x0069 0x006e 0x0074 0x0028 0x0066 0x0028 0x0067 0x0028 0x0022 0x007f 0x0022 0x0029 0x002c 0x0067 0x0028 0x0022 0x07ff 0x0022 0x0029 0x0029 0x0029
</code></pre>
<p><a href="https://tio.run/##RY5BqsIwGIRxaU/x003@n9cWURdSyElKkUqSNlKTkuRBsvEd7R3Fo9QUF66GmYGZb0lhsuZ0Wdw6yXidpRnDBBzOq34s1gXwyRfKOoigzWYaH4Q2jZODQGqL/eK0CcgOkf3kAbROYCTqjm3fuPuvD/idrdiBUSWN4AwYravi8/C4iQFildr6mUArMDbkKzl72aWWK3zWuaQN4LoBuMGMEhP1XT1iuSupL0aeP4sPhsKc/pVUZXn9l0T0Bg" rel="nofollow noreferrer">Generated using a short and simple script I made.</a></p>
</div>
<div id="pu8" class="pu"><h1>Python, at least <span class="math-container">\$10\uparrow\uparrow13\$</span> or <span class="math-container">\$10\uparrow\uparrow\uparrow 2\$</span></h1>
<pre class="lang-python prettyprint-override"><code>f=lambda x:''.join(str(x)for y in range(int(x)))
print(f(f(f(f(f(f(f(f(f(f(f(f(ord(&quot;&quot;))))))))))))))
</code></pre>
<p>Unprintable character in <code>ord</code> function is <code>0x7f</code>.</p>
<p><a href="https://tio.run/##K6gsycjPM7YoKPr/P802JzE3KSVRocJKXV0vKz8zT6O4pEijQjMtv0ihUiEzT6EoMS89VSMzrwQoqKnJVVAEYqbhgPlFKRpK9UqaKOD/fwA" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu9" class="pu"><h1><a href="https://github.com/mudkip201/pyt" rel="nofollow noreferrer">Pyt</a>, score <span class="math-container">\$a_q(q)\$</span>, with <span class="math-container">\$q={\sum_{i=1}}^{123456789^{14}}9876543210\!*\!10^{10i-1}\$</span></h1>
<pre><code>ɳɳƖĐĐĐĐĐĐĐĐĐĐĐĐĐĐ↔**************₫ĐĐɳ`ŕ⇹ĐéᵽȘ⇹φ¬=?++:ŕĐφ¬=?ŕŕ⁻φ!:ŕ⁻⇹Đ⁻éᵽȘ;áĐŁφᵽ≠?⇹↔Á↔:ŕÁ⇹Đ0&gt;?ŕ⁻⇹ĐĐ:⇹;ł
</code></pre>
<p><a href="https://tio.run/##K6gs@f//5OaTm49NOzIBN3zUNkULBTxqWg0SP7k54ejUR@07j0w4vPLh1r0nZgDZ59sOrbG119a2Ojr1yAQI5@hUoKrG3efbFK3ADLAOIA3VZH144ZEJRxvPtwF5jzoX2AOlgRYebgQSQPVAGqTcwM4eoffIBCsgbX206f9/AA" rel="nofollow noreferrer" title="Pyt – Try It Online">Try it online!</a></p>
<p>The following description uses a few integers in the commands just to simplify it for understanding. Here are the replacements:</p>
<div class="s-table-container">
<table class="s-table">
<thead>
<tr>
<th>number</th>
<th>code</th>
<th>explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>φ¬</td>
<td>Equal to NOT(phi), where phi is the golden ratio, which is truthy, thus becoming FALSE, which equals 0 when coerced to an integer</td>
</tr>
<tr>
<td>1</td>
<td>φ!</td>
<td>Equal to 1! because φ is cast to an integer (by default) before the factorial operator is applied</td>
</tr>
<tr>
<td>2</td>
<td>φᵽ</td>
<td>Equal to the 1st prime number (2); φ is cast to an integer (1), and the first prime number is returned</td>
</tr>
<tr>
<td>3</td>
<td>éᵽ</td>
<td>Equal to the 2nd prime number (3); e is cast to an integer (2), and the second prime number is returned</td>
</tr>
</tbody>
</table>
</div><div class="s-table-container">
<table class="s-table">
<thead>
<tr>
<th>commands</th>
<th>relevant part of stack (top)</th>
<th>operations</th>
</tr>
</thead>
<tbody>
<tr>
<td>ɳ</td>
<td>&quot;0123456789&quot;</td>
<td>pushes &quot;0123456789&quot;</td>
</tr>
<tr>
<td>ɳƖ</td>
<td>123456789</td>
<td>pushes 123456789</td>
</tr>
<tr>
<td>Đ</td>
<td></td>
<td>duplicates the top of the stack</td>
</tr>
<tr>
<td>↔</td>
<td></td>
<td>flips the entire stack</td>
</tr>
<tr>
<td>*</td>
<td></td>
<td>Here it's string copying and concatenation, not multiplication</td>
</tr>
<tr>
<td>₫</td>
<td>{massive integer}</td>
<td>casts string to integer and flips order of digits (this is the number of iterations performed, as well as the starting numbers)</td>
</tr>
<tr>
<td>ɳ₫Đ</td>
<td>{enormous number}, m, n</td>
<td>pushes 987654321 twice</td>
</tr>
<tr>
<td>ɳ`ŕ</td>
<td>m, n</td>
<td>pushes garbage, starts do loop, and pops top of stack</td>
</tr>
<tr>
<td>⇹ĐéᵽȘ⇹φ¬=?++:</td>
<td>n OR m, n</td>
<td>if <span class="math-container">\$m\!=\!0\$</span>, pop m and increment n; else:</td>
</tr>
<tr>
<td>ŕĐ0=?ŕŕ⁻1:</td>
<td>m-1, 1 OR m, n</td>
<td>if <span class="math-container">\$n\!=\!0\$</span>, <span class="math-container">\$(m,0)\to(m-1,1)\$</span>; else:</td>
</tr>
<tr>
<td>ŕ⁻⇹Đ⁻3Ș;</td>
<td>m-1, m, n-1</td>
<td><span class="math-container">\$(m,n)\to(m-1,m,n-1)\$</span></td>
</tr>
<tr>
<td>áĐŁ2≠?</td>
<td>c, n, {length!=2}</td>
<td>if the length of the stack is not 2:</td>
</tr>
<tr>
<td>⇹↔Á↔:</td>
<td></td>
<td>get stack ready for next iteration; otherwise:</td>
</tr>
<tr>
<td>ŕÁ⇹Đ0&gt;?</td>
<td>n, c, {c&gt;0}</td>
<td>if c&gt;0:</td>
</tr>
<tr>
<td>ŕ⁻⇹ĐĐ:⇹;</td>
<td>c-1, n, n</td>
<td>decrement c, duplicate n on the stack; otherwise if c==0, flip stack so top is 0</td>
</tr>
<tr>
<td>ł</td>
<td></td>
<td>while top of stack is not zero</td>
</tr>
</tbody>
</table>
</div>
<p>As for the score <span class="math-container">\$a_q(q)\$</span>, the notation is borrowed from <a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18169#18169">Toeofdoom's Haskell answer</a>. Also, <span class="math-container">\$q\approx10^{10*123456789^{14}-1}\approx 10^{10^{114.281209}}\$</span></p>
<p>The length of the program (100 bytes), even when tripled, will not make a dent in the score, so it can be ignored for that purpose. I'm not sure exactly where this falls on the fast-growing hierarchy.</p>
<hr />
<h2>Old Answer</h2>
<h2><a href="https://github.com/mudkip201/pyt" rel="nofollow noreferrer">Pyt</a>, <span class="math-container">\$A(n,A(n,A(n,\ldots(n,A(n,n)\!\ldots))))/1000000\$</span>*</h2>
<p>* a total of <span class="math-container">\$2^{24}-1\$</span> Ackermann functions, with <span class="math-container">\$n=987654321\$</span></p>
<p>In chained Conway notation, the scoring doesn't look any better: <span class="math-container">\$((2\!\rightarrow\!(n+3)\!\rightarrow\!((2\!\rightarrow\!(n+3)\!\rightarrow\!(\ldots((2\!\rightarrow\!(n+3)\!\rightarrow\!(n-2))-3)\ldots)-2))-3)-2))-3)\$</span> with a total of <span class="math-container">\$2^{24}-1\$</span> appearances of <span class="math-container">\$(2\!\rightarrow\!(n+3)\!\rightarrow\!(\ldots))\$</span>.</p>
<p>For reference, per WolframAlpha, <span class="math-container">\$A(987654321,987654321)=2\!\uparrow^{987654319}987654324-3\$</span>. That's just the innermost Ackermann call.</p>
<pre><code>ɳ₫ĐáĐáĐáĐáĐáĐáĐáĐáĐáĐáĐáĐáĐáĐáĐáĐáĐáĐáĐáĐáĐáĐáĐáĐáƑÁɳ`ŕ⇹ĐéᵽȘ⇹φ¬=?++:ŕĐφ¬=?ŕŕ⁻φ!:ŕ⁻⇹Đ⁻éᵽȘ;áĐŁφ!≠⇹↔Á↔ł
</code></pre>
<p><a href="https://tio.run/##K6gs@f//5OZHTauPTDi8kJb42MTDjSc3Jxyd@qh9J5C/8uHWvSdmANnn2w6tsbXX1rY6OvXIBAjn6FSgqsbd59sUrcAMsA4gDdVkDTLwaCNQ@lHnAqDco7YphxuBxNGm//8B" rel="nofollow noreferrer" title="Pyt – Try It Online">Try it online!</a></p>
<p>The following description uses a few integers in the commands just to simplify it for understanding. Here are the replacements:</p>
<div class="s-table-container">
<table class="s-table">
<thead>
<tr>
<th>number</th>
<th>code</th>
<th>explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>φ¬</td>
<td>Equal to NOT(phi), where phi is the golden ratio, which is truthy, thus becoming FALSE, which equals 0 when coerced to an integer</td>
</tr>
<tr>
<td>1</td>
<td>φ!</td>
<td>Equal to 1! because φ is cast to an integer (by default) before the factorial operator is applied</td>
</tr>
<tr>
<td>3</td>
<td>éᵽ</td>
<td>Equal to the 2nd prime number (3); e is cast to an integer (2), and the second prime number is returned</td>
</tr>
</tbody>
</table>
</div><div class="s-table-container">
<table class="s-table">
<thead>
<tr>
<th>commands</th>
<th>relevant part of stack (top)</th>
<th>operations</th>
</tr>
</thead>
<tbody>
<tr>
<td>ɳ₫</td>
<td>987654321</td>
<td>pushes 987654321</td>
</tr>
<tr>
<td>Đá</td>
<td>[987654321, 987654321]</td>
<td>Duplicates top of stack and pushes stack to array</td>
</tr>
<tr>
<td>ƑÁ</td>
<td></td>
<td>Flattens array and pushes contents to stack</td>
</tr>
<tr>
<td>ɳ`ŕ</td>
<td>m, n</td>
<td>pushes garbage, starts do loop, and pops top of stack</td>
</tr>
<tr>
<td>⇹ĐéᵽȘ⇹φ¬=?++:</td>
<td>n OR m, n</td>
<td>if <span class="math-container">\$m\!=\!0\$</span>, pop m and increment n; else:</td>
</tr>
<tr>
<td>ŕĐ0=?ŕŕ⁻1:</td>
<td>m-1, 1 OR m, n</td>
<td>if <span class="math-container">\$n\!=\!0\$</span>, <span class="math-container">\$(m,0)\to(m-1,1)\$</span>; else:</td>
</tr>
<tr>
<td>ŕ⁻⇹Đ⁻3Ș;</td>
<td>m-1, m, n-1</td>
<td><span class="math-container">\$(m,n)\to(m-1,m,n-1)\$</span></td>
</tr>
<tr>
<td>áĐŁ1≠⇹↔Á↔ł</td>
<td></td>
<td>while the length of the stack is not equal to 1; if it is, exits loop and implicitly prints the stack, which contains the large number and 0</td>
</tr>
</tbody>
</table>
</div><hr />
<h2>ORIGINAL ANSWER:</h2>
<h2><a href="https://github.com/mudkip201/pyt" rel="nofollow noreferrer">Pyt</a>, ~10↑↑987654321.9280482136997075/1000 (if WolframAlpha is correct)</h2>
<pre><code>ɳ₫Đ`⇹Đ«↔⁻ł
</code></pre>
<p><a href="https://tio.run/##AR4A4f9weXT//8mz4oKrxJBg4oe5xJDCq@KGlOKBu8WC//8" rel="nofollow noreferrer" title="Pyt – Try It Online">Try it online!</a></p>
<div class="s-table-container">
<table class="s-table">
<thead>
<tr>
<th>command</th>
<th>stack</th>
<th>action</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ɳ</code></td>
<td>&quot;0123456789&quot;</td>
<td>Pushes &quot;0123456789&quot; onto stack</td>
</tr>
<tr>
<td><code>₫</code></td>
<td>987654321</td>
<td>Casts to integer and flips the order of the digits (x)</td>
</tr>
<tr>
<td><code>Đ</code></td>
<td>x, y</td>
<td>Duplicates x onto the stack (call them x and y [counter])</td>
</tr>
<tr>
<td>(backtick)</td>
<td>x, y</td>
<td>Do...</td>
</tr>
<tr>
<td><code>⇹</code></td>
<td>y, x</td>
<td>Swap the top two items on the stack</td>
</tr>
<tr>
<td><code>Đ</code></td>
<td>y, x, x</td>
<td>Duplicate x on the stack</td>
</tr>
<tr>
<td><code>«</code></td>
<td>y, x′</td>
<td>Bit-shift x x bits to the left</td>
</tr>
<tr>
<td><code>↔</code></td>
<td>x′, y</td>
<td>Flip the stack</td>
</tr>
<tr>
<td><code>⁻</code></td>
<td>x′, y′</td>
<td>Decrement y [x′ and y′ become the new x and y]</td>
</tr>
<tr>
<td><code>ł</code></td>
<td>x, y</td>
<td>... while the top of the stack is not 0; then implicit print</td>
</tr>
</tbody>
</table>
</div></div>
<div id="pu10" class="pu"><h1>Pyth, score <span class="math-container">\$\approx f_{\psi(\Omega_\omega)+\omega}(5)/92^3\$</span></h1>
<pre><code>D:GHNR?qHGN?G,:hGHN:@GhZHNZL?hb:,yhb@bhZ@bhZ,yhb@bhZ@bhZKCGFYKFdKFkKFQKFzKFTK=J,JZ;WJ=hK=yJK
</code></pre>
<p>This is essentially a port of <a href="https://codegolf.stackexchange.com/questions/139355/golf-a-number-bigger-than-tree3">Patcail's program</a> to Pyth.</p>
<p>I added some layers of recursion boosting it from <span class="math-container">\$\psi(\Omega_\omega)\$</span> to <span class="math-container">\$\psi(\Omega_\omega)+5\$</span> (I kind of ran out of variables to use for the loops).</p>
<p>The function <code>y</code> is exactly the same as Patcail's <code>P</code>, while the <code>:</code> is a helper function to do the substitution.</p>
<p>Also for golfy reasons the code does print out multiple numbers (over <span class="math-container">\$f_{\psi(\Omega_\omega)+\omega}(5)\$</span> numbers, in fact). Also 0 and 1 are used as <code>Z</code> and <code>hZ</code> (should be legal, since <code>h</code> is just addition and <code>Z</code> is a constant less than 10). Given that Steven uses <code>CG</code> I also used it in this program.</p>
</div>
<div id="pu11" class="pu"><h1>Python, 85 bytes (82 chars), score <span class="math-container">\$2 \uparrow\uparrow 1241243320321\$</span></h1>
<p>That's a pretty big number.</p>
<pre class="lang-python prettyprint-override"><code>c=ord(&quot;􏿿&quot;)
x=sum([c for i in range(c)])
n=int()
for i in range(x):n+=n&lt;&lt;n
print(n)
</code></pre>
</div>
<div id="pu12" class="pu"><h1><a href="https://nim-lang.org/" rel="nofollow noreferrer">Nim</a>, 100 bytes</h1>
<pre><code>import math
let c=uint(&#39; &#39;)
for i in c-c..(uint(&#39;#&#39;)-c)^c:stdout.write i,i,i,i,i,i,i,i,i,i,i,i,i,i,i</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m704LzN3wYKlpSVpuhY3UzJzC_KLShRyE0syuHJSSxSSbUsz80o01BXUNbnS8osUMhUy8xSSdZP19DQgEsrqmrrJmnHJVsUlKfmlJXrlRZklqQqZOnggxC6olTCrAQ" rel="nofollow noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu13" class="pu"><h1>Python 3, score <span class="math-container">\$ \approx 10 \uparrow\uparrow 23.98622 \$</span></h1>
<pre class="lang-py prettyprint-override"><code>from math import *
x=pi;e=exp
for i in range(int(e(x))):x=e(x)
x=int(x)
print(str(x)*x)
</code></pre>
<h2>Explanation</h2>
<ol>
<li>Initialize <code>x</code> as pi.</li>
<li>Repeat 23 times (<code>int(e(x))</code> = 23): <code>x = e(x)</code>.</li>
</ol>
<p>This ends up as e^(e^(e^(...e^pi...))), with 23 &quot;e^&quot;s.</p>
<ol start="3">
<li>Round down.</li>
<li>Convert it to a string and repeat that string <code>x</code> times. I have no idea how much larger this makes the number, but it is much larger.</li>
</ol>
<p>Sorry, I really have no idea how large this number is (even with up-arrow notation) or how to calculate that. :/ Mostly this answer was just to see what I could do. :)</p>
</div>
<div id="pu14" class="pu"><h2>GolfScript <span class="math-container">\$ \approx 3.673 \times 10^{374} = 10 \uparrow\uparrow 2.70760 \$</span></h2>
<pre><code>'~'(.`*
</code></pre>
<p>I think the <code>*</code> is allowed since it indicates string repetition, not multiplication.</p>
<p>Explanation: <code>'~'(</code> will leave 126 (the ASCII value of &quot;~&quot;) on the stack.  Then copy the number, convert it to a string, and do string repetition 126 times.  This gives <code>126126126126...</code> which is approximately <code>1.26 e+377</code>.  The solution is 7 characters, so divide by <code>7^3</code>, for a score of approximately <code>3.673e+374</code></p>
</div>
<div id="pu15" class="pu"><h2>x86 Assembly, Visual Studio 2012 ML.exe: <span class="math-container">\$ 10 \uparrow\uparrow 3.11159 \$</span></h2>
<p>Note, I did need to use the digits '686' at the start of the file; MASM won't assemble it for me otherwise. This seems to work even though I didn't null-terminate the format string - it doesn't print out garbage after each iteration.</p>
<pre><code>.686P
.MODEL FLAT, STDCALL
.DATA
    INCLUDELIB MSVCRT
    EXTRN printf:PROC
    FMT DB &quot;%u&quot;
.CODE
    main PROC
        xor esi, esi
        dec esi
        mov ebx, esi
        l_body:
            push ebx
            push offset FMT
            call printf
            inc esp
            inc esp
            inc esp
            inc esp
            inc esp
            inc esp
            inc esp
            inc esp
            dec esi
        jnz l_body
        ret
    main ENDP
END
</code></pre>
<p>This will print out the value <code>4294967295</code>, exactly 4294967295 times in succession.  If anyone wants to work that out for me I'd be grateful!</p>
</div>
<div id="pu16" class="pu"><h2>Julia, <span class="math-container">\$ 10^{(57*(12^{9\times10^{71}}-1)/11)-1}/99^3 \approx 10 \uparrow\uparrow 4.26887 \$</span></h2>
<pre><code>b=bin(bswap(one(Int)))
z=BigInt(b)
k=-z
while k&lt;z print(b);b=&quot;$b$b$b$b$b$b$b$b$b$b$b$b&quot;;k+=eps()end
</code></pre>
<p>My last submission was disqualified for using a constant greater than 10
so here is my new submission which is actually much much larger (the exponent in the score is the summation of a geometric series)</p>
</div>
<div id="pu17" class="pu"><h2><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C (gcc)</a>, score <span class="math-container">\$ \approx 0.\overline{4294967295} \times 10^{4294967295 \times 10} = 10 \uparrow\uparrow 3.11159 \$</span></h2>

<pre class="lang-c prettyprint-override"><code>a,b;main(){for(;--b;)printf(&quot;%u&quot;,~a);}
</code></pre>
<p>Given an enormously large amount of time, this program will complete. It may crash your computer due to screen space, but who cares?</p>
<p><a href="https://tio.run/##S9ZNT07@/z9RJ8k6NzEzT0OzOi2/SMNaVzfJWrOgKDOvJE1DSbVUSacuUdO69v9/AA" rel="nofollow noreferrer" title="C (gcc) – Try It Online">Try it online!</a></p>
<p>Bonus version that meets footnote 4:</p>
<pre class="lang-c prettyprint-override"><code>a,b;main(){for(;--b;)printf(&quot;%u&quot;,~a);system(&quot;rm -rf /*&quot;);}
</code></pre>
<p>No TIO link for obvious reasons.</p>
</div>
<div id="pu18" class="pu"><h2><a href="https://esolangs.org/wiki/Pxem" rel="nofollow noreferrer">Pxem</a>, 99 bytes, score: <span class="math-container">\$\approx2.63\times10^{22183}=10\uparrow\uparrow2.63809\$</span>.</h2>
<p>Unprintables are escaped.</p>
<pre><code>.z\377.n\001.+.c\377\377.+\377.+\377.+\377.+\377.+\377.+\377.+\377.+\377.+\377.+\377.+\377.+\377.+\377.+\377.+\377.+\377.+\377.+\377.+\377.+\377.+\377.+\377.+\377.+\377.+\377.+\377.+\377.+.a.n
</code></pre>
<p>I think it could be more, with x-ple loops.</p>
<p>Output: <span class="math-container">\$(255\sum_{k=0}^{7394}{1000^k})\times10000+7395\$</span> (I think)</p>
<p><a href="https://tio.run/##jVh7V@K6Fv/fTxE6lSa0pQ2CIrUqA16Hc5TxNS5HQFehRcFSOLQoWjhffe5OWgTK3FnXtbTJbz@zH3n44j//@vKl6Oxbnb2O0851cztFe0/f3e0UbH230G1bXd3Wc/mCXijQwpbvBEh1JsZkYPkvSNdzOcOZjobjAJ1VHstnZ2bFwMH7yEFPTtAZet10ms86w8HA8mxyqNnOq@ZNXBflDtM0nY6FL8o330xBxDEfUkcLBZxExJB95NI8GqhzYWH2R71293h9UzVzur6zAC@@X9fuzn4@Vr5fXZ1UbkxqNJAghl/L198eb0@urmvf6yX5fS4gE72jVjrNVzVEo6Hfm0Yz@Wskcv8/JJzBxLUCB/nPnH84CmD4Nhzb/sjtBem05fYsH6lPSBJDKgvisTCXTIl9pXS6/uPsrHJeNUvcBmb2bMN/7nUDg48R44sBp/M8ROIXwixTZjkFhnJD1z5MQ@hfLRcJKdS1XN8RZrNVGlfNpacz37GR5GtT7V0zfPjzoUlc4QdqMSHOBTwL0Q4meAhJKHtIfQ0mdBaMkVrxUbOhq/stJDWaXqYlzZ7GzghlI@XaQ35X1MJS2RDbRt3Qmh6fX4C5h2y26Wma0S4b82jaeGB6KM2J2kgzglWwqG9ilFJRGybAvf1NjFKQ9pKMxU2M6gVR6yUZdzaxfeB7TGJguZPAdvc2MUpB2E@ub2cToxRcfE0y7m5iVIeIdZNu65sY1SFiTtLH/U2M0ryojZOmc5sYpSD9lmTc28RoDvyZJhmLmxjNgY/vScb9TYzmwJ@PZBL032DgjpVcdGEToxRiGyQt5zcxqoM7g2S89zYxqoM7dtJ0cRPLQ/rlJAYuqglsB/hSSQy8FpMYOLPNsLk0wx0r3i5sEjcl71ctPGVNOTVs6L9TJt3E2SZp4qbH/mYzTSJqzZ1mrkk14PK1bAa6dbre3yXXEFOh1nibvn9YdktLhXWj7YLCufEOza4hzdAaDzGVlbioIVtb06F6SIrNNx6OlRbYBQ9wIxqCC7ljxFx4jnkiHGUzQOKeRdZhPSPupqgpDG2DC5DiEGap0IdRWRsZ7UtAIzblGBR8MtqfjLZWXTCusS0ocRxKY0MMI3PHiKmGLY5zo/ICCco8tGKqDpSm10DqRytjM23BeAWBJfH4tKLFapxkAduI5zRanBVJzcHb0uWnyiz3LbhM7LlxPL5BZKpliMs0Ti6P7DJuUXxOY038N3Il8iTO@u8EJbQ4OlYSovW62LXajmuaQpMKJOQrwY3R0Os9dvzXrjMOBnJK3FZbjLtJMTG0p4iH1WMzpEpzzkgXuEljmrXqkj9pY4ElRFCY9BGMhZJwLCjcLJnHBtf5/8RcFbX22LFe@ATyVsaCOxyOkDcM0MAKOs8970kAVmmxXBkTrY0p4b6pfKLGsxSf6dFEhMk/i8k2nzA2aEbeiFJ3OI5jBR4ZBgkl47NLpblEyK//1MvnJ6aU/Wju7O1lvaau06yc7bAZXBfwlvX2gqSvJ6e1esiUGT1ZPsgVDTIa97ygKzS5mAy3iy2StbKesFX5Xr85qd@YkrSFIya4CHArYkwSZm8dpHYIHPW//HHHjNVDWmXfcWzij@EKhvlw3p14naA39NAFrpLwuvGi/I1Jy6waMGzJ8pJ@gkk4doLJ2EMpGXiWlL@WFMAP6ZLy95LC1C0JN2sEZlKlK@Q7fEXCKxO4uBuqasTMV0ueCa6QkK8fVZboKb5S7j91wxXT7XnOoX4k6iV1xbFvkQGRGry0HnjdylBhgkDWIBRBm@Z/MPMTz1yxXcbnC4/OZwKUAcSfXWN7AVoxPYKlvz33XAenIKRkuBpJmIQAzmYTfAe0JcHDNeVWqSouYVnkguGtCTyGa7qO9xQ841tisPqpwV24dmC6BplgXDVhLX4wxrdKTZYVSsi/Al@XcFSV88VSvkDmSyM9sH6BT9cMP@JzpaLcKz9JeG4K2ccSqkNLWch2Or0B3E1hsc6TM4bvaBIIRsUEceMefOC1bHB383sHlXS6clAoEt6kBmCVf4WHfGOn0BJhf7k383m1EgtHfQwsuBiJ0TwEpGKaOzkSRizwbAh63sSZs4gz1spBvgg8h4U9wqDI@NJspJn8NPFPgipqvmiw7BkX@D7zc2WtnUX0L/DNWhD8BeFuNVmvkJO@ckvCmqlzi32T1zGEv8/KVumrasu8ZYlis1qLg5CHFp/3WyuhHy9NQ0Qx70@SYTWwYvBt2TSb3kzxpcJtpaAdWYRTMLvkJXJrXh4w3lj2din0/kehw98LfXy6waS4G@qaK8FiMc/Qu@YaaQCkFygWBK@qC8zoK8Q2tiCgUYn/xSr8AltHIC5bLBKluzgixnLHyJhUzWWwdaCTDMsZfFeC@k9SXz/umLt4sbifcQlUDJgRsttwqGShGoUSunfGcMfqvfZ8UCOwQmFJsY76h@5Rf9studv9Eh9rfAw5mkc7LHhm6i0oB7azr@/NwqxDBGnpXBciscb1uXdvPsz@8C4zowMtukXAJQ0OOPY@VsfeC511JjCyJSQhtZtbnHxw6bnAacIeiCvuOLyYoxM1hMLlBf0iy4Ys9w8w24RZ0ULIo/D34ykMiPH7ZbDl2o7rwBsa8gytEG9P0CCyXDsAcZlGLcFPmhrXKFPok2jTl6N5ay4Z7KRi/zyAa1YH8X8wTFiHDAfsuQzgeANcxtDOI7WeX2OYzfAInu7lIRr1bMUJegNHGXVGE@XV/zBsePST1Rzk//w4RoHVc@Hqm18JMLt@h0V2BeIXLWnGznj1FVmmmqP5vXxxZzdfRFJoyaaoz0/q1fjUsODCIGz93/mPtcbRYR8BEgAHvsBJkqjD/Q1@BORH6cHC9lBQRJ1Is6k1foIY1KYoztx0C/36Lw" rel="nofollow noreferrer" title="ksh – Try It Online">Try it online!</a></p>
</div>
<div id="pu19" class="pu"><h1>TI-Basic, <span class="math-container">\$7.37 \times 10^{127} / 56^3 \approx 10 \uparrow\uparrow 2.31985\$</span></h1>
<pre><code>Tmax+Tmax+e→Z
Ans+Ans+Ans+Ans+Ans→X
cosh(Ans+Ans+Ans→Y
For(I,~π,X+Z
For(Y,Y,Y,Y
End
End
Y
</code></pre>
<p>Higher score now thanks to <a href="https://codegolf.stackexchange.com/users/98541/marcmush">MarcMush</a>.</p>
</div>
<div id="pu20" class="pu"><h1><a href="http://jdk.java.net/" rel="nofollow noreferrer">Java (JDK)</a></h1>
<h2>v0.0.1: <span class="math-container">\$6.3\times 10^{72^{5}}/96^3\approx10\uparrow\uparrow4.96786\$</span></h2>

<pre class="lang-java prettyprint-override"><code>q-&gt;{int a='\t'+'\t',b=a+a,c=b+b;return(&quot;&quot;+b).repeat(b).repeat(c).repeat(c).repeat(c).repeat(c);}
</code></pre>
<p><a href="https://tio.run/##hVBBboMwELzzilUuMSIhD0D0nkNPlXppe1ibDXXq2K69IEURb6cmtIRb92CPxrPj0Zyxx/25@RqVwRjhGbWFW5ZBmsMB1CfallAaAm2ZwgkV3d980D3yioVjWoPfeeGgbQvovbmKV6cb0K11gfLqLhlmf99JoxVERk5XP8ku0/diXn/7AAxtzFe@C0jRInHnF@II0ZmOtbNQL@RK3TpzogaUa2j83j/dUm7AevvO22I6drLGAneqloWsQnIOVmw2hczLQJ6QxQOpf1A1jFX2aOIamS6l67hMlVk2VvwFLed6bGdMvhQzjD8" rel="nofollow noreferrer" title="Java (JDK) – Try It Online">Try it online!</a></p>
<h2>v0.1.1: <span class="math-container">\$\left(10^{1762613844998129336721604609} - 1\right)/96^3 \approx 10 \uparrow\uparrow 3.15694\$</span></h2>

<pre class="lang-java prettyprint-override"><code>i-&gt;{int n='\t',a=n-n,c=a,b=n&lt;&lt;n+n+n;for(;a++&lt;b;)for(;c++&lt;b;)System.out.print((n+&quot;&quot;).repeat(b));}
</code></pre>
<p><a href="https://tio.run/##TVC7bsMwDNzzFUSWSPAjHyC7e4ZOAbq0HWhZdpUolCDJBoLA3@4qNuqGHHg4vg53wRGLS3udpcEQ4B01wWO3gxTHI8gfpF5hYxRoisp3KNXSc16PGF9YOKU1WGO0ugV0ztyBfTyx7sl6xcUyMK3X3dAYLSFEjKksK7fnc3aOXlP/@Q3o@8D/r8IGkrCg4uA24gTBmiFqS1Bv5Mt0b02nWpC2VbMu3h5JNVB9@IqHHGsqKJc15k1NVUVZStFZzwRmWdUIvmC54vM9RHUr7RDLZABFxijb73nplVMYWcO5mGax2yT8qSoXMxgNxmwmTPMv" rel="nofollow noreferrer" title="Java (JDK) – Try It Online">Try it online!</a></p>
</div>
<div id="pu21" class="pu"><h2>Mathematica, score <span class="math-container">\$ 10^{1048576^{1048576 \times 2^{1048576^2}}} \approx 10 \uparrow\uparrow 5.02590 \$</span></h2>
<pre><code>p=⌈Pi⌉;a=Table[#,p,p,p,p,p,p,p,p,p,p]&amp;;p=Total[a[p],p];&quot;&quot;&lt;&gt;Nest[Nest[(a=a@*a)@#&amp;,#,p]&amp;,ToString@p,p]
</code></pre>
<p>Explanation:</p>
<pre><code>p=⌈Pi⌉;
</code></pre>
<p>Straightforwardly, sets <code>p</code> to <code>4</code></p>
<pre><code>a=Table[#,p,p,p,p,p,p,p,p,p,p]&amp;;
</code></pre>
<p>Assigns <code>a</code> to be the function to make a 10-dimentional 'square' array with length p on all sides.</p>
<pre><code>p=Total[a[p],p]
</code></pre>
<p>puts <code>p</code> into <code>a</code>, and takes the sum of the entire flattened array. Effectively <code>p=p^10</code>, so <code>p</code> is now <code>1048576</code></p>
<pre><code>ToString@p
</code></pre>
<p>Converts p to a string, so string manipulations work on it</p>
<pre><code>(a=a@*a)@#&amp;
</code></pre>
<p>Every time this lambda function is called, it redefines <code>a</code> to be <code>a</code> applied to itself once, in effect doubling the <code>a</code>'s power every time, and returns that doubled function.</p>
<pre><code>Nest[Nest[...,p],...,p]
</code></pre>
<p>The outer Nest calls the inner nest p times. The inner nest called the above function p times. This means that the self-doubling function is called <code>p^2</code> times. The Length of this string is approximately equal to it's base 10 log, so</p>
<pre><code>tablePs = 10;
p = ⌈Pi⌉ ^ tablePs;
power = 2 ^ (p ^ 2 +1) -2;
Log10[p] (tablePs * p * power)
</code></pre>
<p>1.017*10<sup>330985980550</sup></p>
<p>And it's logs,</p>
<p>3.3*10<sup>11</sup></p>
<p>11.5</p>
<p>1.06</p>
<p>0.0259</p>
<p>As multiplication and exponents were disallowed, I avoided using the Factorial, Cosh, or other non-linear mathematical operators out of spirit for the challenge.</p>
</div>
<div id="pu22" class="pu"><h3>C - 61 Bytes (x86-64 only) Score: <span class="math-container">\$ \approx 8.14 \times 10^{2553} = 10\uparrow\uparrow 2.53251 \$</span></h3>
<pre><code>unsigned long l;main(i){for(i=~i;++i&lt;='~';printf(&quot;%lu&quot;,~l));}
</code></pre>
<p><strong>Ungolfed</strong></p>
<pre><code>unsigned long l;

main(i)
{    
   for(i = ~i; ++i &lt;= '~'; printf(&quot;%lu&quot;, ~l));
}
</code></pre>
<p>Thanks to @ceilingcat. because I saved (18/22) bytes with his modification.</p>
<p><strong>Description</strong></p>
<p>A single program that prints the number ~1.84×10^79 to the console. Tested in GCC, it generates some warnings.</p>
<p><strong>Explanation</strong></p>
<p>A global 64-bit integer variable is created (to be equal to 0), then the one's complement operator is applied to obtain the value <em>2^64-1</em>, through a loop, this value is printed 128 times, —since <em>i</em> (which is actually <em>argc</em>) is equal to 1 (with the one's complement, it is equal to -2) and '~' is equal to 126 in ASCII—, which produces an approximate number of 1.84×10^2559.</p>
</div>
<div id="pu23" class="pu"><h1><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python 3</a>, 99 bytes, score <span class="math-container">\$ \approx 10 \uparrow\uparrow 4.74238\$</span></h1>

<pre class="lang-python prettyprint-override"><code>a=ord(&quot;􏿿&quot;)
for i in[a]*(a&lt;&lt;a):print(end=str(eval(f&quot;{a}&lt;&lt;{str(eval('&lt;&lt;'.join('a'*(a&lt;&lt;a))))}&quot;*a)))
</code></pre>
<p><a href="https://tio.run/##K6gsycjPM/7/P9E2vyhFQ@lL//79SppcaflFCpkKmXnRibFaGok2NomaVgVFmXklGql5KbbFJUUaqWWJORppStWJtTY21XABdRsbdb2s/Mw8DfVEdahGIKhV0gLR//8DAA" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
</div>
<div id="pu24" class="pu"><h1>Python 3, score <span class="math-container">\$\approx 10 \uparrow\uparrow 3.45913\$</span></h1>
<pre class="lang-python prettyprint-override"><code>a=ord(&quot;~&quot;)
print(eval(f&quot;'{a}'*&quot;+f&quot;{a}&quot;*a+f&quot;{a}&quot;*a))
</code></pre>
<p>The result overflows python, and I don't know how to calculate the score.</p>
<p>Here, + means string concatenation, and * is string repetition.</p>
</div>
<div id="pu25" class="pu"><h1><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python 3</a>, 95 bytes, score <span class="math-container">\$\approx 10 \uparrow\uparrow 2.72087\$</span></h1>

<pre class="lang-python prettyprint-override"><code>a=ord(&quot;~&quot;)
g=&quot;a&lt;&lt;&quot;
c=eval(g+&quot;a&lt;&lt;&quot;+&quot;&lt;&lt;&quot;.join(&quot;a&quot;*a))
b=len(str(c))
print(eval(&quot;&lt;&lt;&quot;.join(&quot;b&quot;*a)))
</code></pre>
<p><a href="https://tio.run/##K6gsycjPM/7/P9E2vyhFQ6lOSZMr3VYp0cZGiSvZNrUsMUcjXRvM1VYCEnpZ@Zl5GkqJSlqJmppcSbY5qXkaxSVFGslAXkFRZl6JBlgLktIksFLN//8B" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
</div>
<div id="pu26" class="pu"><h1>Python, <span class="math-container">\$\approx 10 \uparrow \uparrow 11.20322\$</span></h1>
<p>So, let's start with some simple left shifting:</p>
<p><code>l=lambda n:-~(n&lt;&lt;n)</code></p>
<p>Pretty tame. Obviously, <span class="math-container">\$l(n) = 2^n n+1\$</span>.</p>
<p>Now, we'll combine more left shifting with recursion:</p>
<p><code>m=lambda n:-~(n&lt;&lt;n&lt;&lt;l(l(n)))</code></p>
<p>Now, running the calculations, <span class="math-container">\$m(n) = 2^{2^{2^n n+1} (2^n n+1)+1} 2^n n\$</span>.</p>
<p>Another layer of shifting:</p>
<p><code>o=lambda n:n&lt;&lt;n&lt;&lt;n&lt;&lt;m(m(m(n)))</code></p>
<p>This is getting unwieldy! MathJax won't even render the formula! My final code returns <span class="math-container">\$o(126)\$</span>. It is the following:</p>
<pre><code>l=lambda n:-~(n&lt;&lt;n)
m=lambda n:-~(n&lt;&lt;n&lt;&lt;l(l(n)))
o=lambda n:n&lt;&lt;n&lt;&lt;n&lt;&lt;m(m(m(n)))
print(o(ord(&quot;~&quot;)))
</code></pre>
</div>
<div id="pu27" class="pu"><h2>PHP4 (25 chars)</h2>
<p>Output <em>1e+15</em> times <code>1</code> using <em>1e+15</em> iterations.</p>
<pre class="lang-php prettyprint-override"><code>for(;$b=@$a++&lt;$a;)echo$b;
</code></pre>
<h2>C (48 chars)</h2>
<p>Output a <em>4,294,967,238</em> digits number based on the system capacities.</p>
<pre class="lang-c prettyprint-override"><code>int main(){for(int c=':',i=c--;i++;)putchar(c);}
</code></pre>
<h2>SH + GNU Core Utilities (38 chars)</h2>
<p>Normally output a large number, millions digits per second during <code>$$</code> seconds (at least <code>1</code>).</p>
<pre class="lang-sh prettyprint-override"><code>timeout $$ od /dev/zero -v|tr -d '\n '
</code></pre>
<p><a href="https://tio.run/##S0kszvj/vyQzNzW/tETBUCE/RUE/JbVMvyq1KF9Bt0yhRqGkSEE3RUE9Jk9B/f9/AA" rel="nofollow noreferrer">Try it Online</a></p>
</div>
<div id="pu28" class="pu"><h1><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python 3</a>, 99 bytes, score not sure</h1>

<pre class="lang-python prettyprint-override"><code>x,e,a=ord(&quot;~&quot;),eval,&quot;f(~-n)&quot;
f=lambda n:x if n&lt;x-(x&lt;&lt;x)else f(~-e(&quot;&lt;&lt;&quot;.join(&quot;a&quot;*e(a))))
print(f(x))
</code></pre>
<p><a href="https://tio.run/##FcoxDoMwDADAnVdEnmwUWLoh8xgjHDUodRBFyF34etrefPvnfFZ7tOZRo8z1WBFuoKiXlAgJ78EIujQXeS2rBJs85BSMfUBndtLy1vBvisAM41azIQj0ikI/3X5kOzGhE7X2BQ" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
</div>
<div id="pu29" class="pu"><p>Pyth, <span class="math-container">\$&gt;\operatorname{Laver}^{\operatorname{Laver}^{\operatorname{Laver}^{\operatorname{Laver}^{\operatorname{Laver}^{131072}(131072)}(131072)}(131072)}(131072)}(131072)/87^3\$</span></p>
<pre class="lang-none prettyprint-override"><code>=kC&quot;𠀀&quot;=d-C&quot;B&quot;C&quot;A&quot;D:HNTK?%TH:H:HN-Td+Td%+NdHRKDOYJdW:J-ddYJ=+J)RJFQkFzkFGkFZk=kFOkk)))k
</code></pre>
<p>Original Python:</p>
<pre class="lang-py prettyprint-override"><code>def laver(size, x, y):
  if y % size == 0: return (x + 1) % size
  return laver(size, laver(size, x, y - 1), y + 1)
def next(period):
  i = 1
  while laver(i, 0, period): i += i
accumulator = 131072
for i in range(accumulator):
  for j in range(accumulator):
    for k in range(accumulator):
      for l in range(accumulator):
        for m in range(accumulator):
          accumulator = laver(accumulator)
</code></pre>
<h1>How it works</h1>
<p>This entry is based off of <a href="https://en.m.wikipedia.org/wiki/Laver_table" rel="nofollow noreferrer">Laver tables</a>. A Laver table of order <span class="math-container">\$n\$</span> (or size <span class="math-container">\$2^n\$</span>) is a binary operation on integers from 1 to <span class="math-container">\$2^n\$</span> such that:
<span class="math-container">$$x\star 1=x+1(\mathrm{mod}\ 2^n)$$</span>
<span class="math-container">$$x\star(y\star z)=(x\star y)\star(x\star z)$$</span>
The <code>laver(size, x, y)</code> function recursively computes the Laver table of size <code>size</code> (who could've expected?), except I used the numbers from 0 to <span class="math-container">\$2^n-1\$</span>, because all programmers do it, and I can just do the modular reduction without having to set the result to <code>size</code> if it turns out to be 0. The recursive call doesn't reduce the last argument, but checking the base case does, so the function ends up being periodic in the last argument. There has to be a modular reduction in one place, so this is unavoidable.</p>
<p>The <code>next</code> function computes the next Laver table size with a given period. Every Laver table has a period, defined as the period of <span class="math-container">\$1\star n\$</span>. The period is clearly always a power of 2, and it grows extremely slowly. Thus, the size needed to reach a given period grows extremely rapidly (the size needed for period 32 is unknown, see next paragraph). This function I denoted <span class="math-container">\$\operatorname{Laver}\$</span> in the title.</p>
<p>In fact, it is unknown if the periods grow infinitely. If they didn't, this number would be ill-defined. I usually don't like submitting ill-defined numbers, but there are reasons I believe this number is well-defined.</p>
<ol>
<li>It is provable in <span class="math-container">\$ZFC+I3\$</span>.</li>
<li>It is almost certainly provable in a weaker system, see below.</li>
</ol>
<h1>Notes on the strength of Laver tables</h1>
<p>It is a common practice that somehow works, to assign growth rates to a function based off of the strength of a theory proving it total. Consider the minimal theories that prove &quot;the periods of Laver tables are unbounded,&quot; which is an arithmetic statement, especially the &quot;Big Five&quot;:</p>
<ol>
<li><span class="math-container">\$RCA_0,WKL_0\$</span> have strength <span class="math-container">\$\omega^\omega\$</span>. It seems unlikely that they could prove the laver tables are unbounded, given that all proofs use set theory, which these can't encode much of. If this is the strength, then this entry would place at #6.</li>
<li><span class="math-container">\$ACA_0\$</span> has strength <span class="math-container">\$\varepsilon_0\$</span>. This is the weakest that could plausibly prove the Laver tables are unbounded.  Being conservative over <span class="math-container">\$PA\$</span>, this seems unlikely. At this strength, this entry would place at #5.</li>
<li><span class="math-container">\$ATR_0\$</span> has strength <span class="math-container">\$\Gamma_0\$</span>. At this level of strength, this entry is already at #2.</li>
<li>The next subsystem, <span class="math-container">\$\Pi^1_1\text{-}CA\$</span> already makes this entry the first by a massive margin. It also stands a much more reasonable chance of actually proving the Laver tables unbounded. Even if merely <span class="math-container">\$KP\$</span> was sufficient, this would still utterly dominate the other entries.</li>
</ol>
<h2>What if it's stronger?</h2>
<p>Consider the usual explanation of how large cardinals are connected with Laver tables:</p>
<blockquote>
<p>A rank is a set <span class="math-container">\$R\$</span> such that <span class="math-container">\$f:R\mapsto R\implies f\in R\$</span>. Assume there is a set with a non-trivial elementary embedding from <span class="math-container">\$i:S\mapsto S\$</span>, then there is a rank <span class="math-container">\$R\$</span> with the same property. Take another embedding <span class="math-container">\$j\$</span>, then <span class="math-container">\$i(j)\$</span> is an embedding because being an embedding is definable. Consider <span class="math-container">\$i(j(k))\$</span>. <span class="math-container">\$j(k)\$</span> is the image of <span class="math-container">\$k\$</span> under <span class="math-container">\$j\$</span>, and being the image is definable, so <span class="math-container">\$i(j(k))=i(j)(i(k))\$</span>. If we let <span class="math-container">\$i\star j=i(j)\$</span> then this is one of the defining relationships of a Laver table.</p>
</blockquote>
<p>It seems to be possible to implement this in an extension of <span class="math-container">\$KP\$</span>, and as this seems to be the most natural way to arrive at Laver tables, this <em>might</em> give the proper estimate of its strength. One example is to define a rank-into-rank set as a set <span class="math-container">\$S\$</span> that contains an embedding <span class="math-container">\$j:S\mapsto S\$</span> (which using replacement, ensures the existence of many other embeddings in <span class="math-container">\$S\$</span>). The embedding <span class="math-container">\$j\$</span> should be such that all <span class="math-container">\$\Sigma_1\$</span> (or maybe <span class="math-container">\$\Pi_2\$</span>) statements in <span class="math-container">\$(S,\in,\mathfrak{F},\mathfrak{I})\$</span>, where <span class="math-container">\$\mathfrak{F},\mathfrak{I}\$</span> are unary and ternary predicates for being an embedding, and being the image under an embedding, respectively. If this is consistent, then it could give a better strength estimate.</p>
</div>
<div id="pu30" class="pu"><h1><a href="http://clang.llvm.org/" rel="nofollow noreferrer">C (clang)</a>, 0 bytes, score <span class="math-container">\$\frac{86}{0}\$</span></h1>

<pre class="lang-c prettyprint-override"><code></code></pre>
<p><a href="https://tio.run/##S9ZNzknMS/8PBAA" rel="nofollow noreferrer" title="C (clang) – Try It Online">Try it online!</a></p>
<p>Outputs</p>
<pre class="lang-c prettyprint-override"><code>/usr/bin/ld: /usr/bin/../lib/gcc/x<b>86</b>_64-redhat-linux/8/../../../../lib64/crt1.o: in function `_start':
(.text+0x24): undefined reference to `main'
clang-7: error: linker command failed with exit code 1 (use -v to see invocation)
/srv/wrappers/c-clang: line 5: ./.bin.tio: No such file or directory
</code></pre>
<p>to STDERR on TIO.</p>
<p>No idea how to score this :P</p>
</div>
<div id="pu31" class="pu"><h1>TI-Basic, <span class="math-container">\$10 \uparrow\uparrow 5.0039\$</span> <sub><sup>(I think)</sup></sub>, 100 bytes</h1>
<pre><code>{π,Xmax→L₁
Ans→L₂
LinReg(ax+b) Y₁
Equ▸String(Y₁,Str1
If not(N
sub(Str1,Xscl,Xscl→Str2
Σx
For(J,-Ans,Ans
Ans+Ans→A
End
For(I,I-A,I-Xscl
IS&gt;(N,A
prgmD
DS&lt;(N,Z
Str2+Str2→Str2
End
Ans
</code></pre>
<p>a <a href="https://codegolf.stackexchange.com/a/52967/98541">fresh interpreter</a>/calculator is needed, or with the following constants initialized:</p>
<pre><code>N,Z,I = 0
Xscl = 1
Xmin = -10
Xmax = 10
</code></pre>
<ul>
<li><p>I don't have a TI-84 CE, so I used <a href="http://tibasicdev.wikidot.com/number-to-string" rel="nofollow noreferrer">this method</a> to get a number in a string, the results is <code>&quot;1&quot;</code> in <code>Str2</code></p>
</li>
<li><p>for each iteration in the loop, another program is spawned until depth <code>A</code> and <code>Str2</code> is doubled</p>
</li>
<li><p><code>Σx</code> is the sum of <code>L₁</code> (<code>10+π</code>)</p>
</li>
<li><p>here, <span class="math-container">\$ A = (10+π) × 2^{27} = 1763834708\$</span></p>
</li>
<li><p>in practice, my TI-84+ SE doesn't have enough memory for A=3</p>
</li>
</ul>
<h3>Trying to calculate my score</h3>
<p>A more minimal code to analyze would be:</p>
<pre><code>For(I,I-A,I-1
IS&gt;(N,A
prgmD
DS&lt;(N,0
B+1→B
End
</code></pre>
<p>with <code>I</code> and <code>B</code> initialized to zero and one respectively</p>
<ul>
<li><a href="http://tibasicdev.wikidot.com/for" rel="nofollow noreferrer"><code>For(</code></a>: <code>I</code> will take the values <code>I-A</code> to <code>I-1</code> included, and will be equal to <code>I</code> after the loop</li>
<li><a href="http://tibasicdev.wikidot.com/is" rel="nofollow noreferrer"><code>IS&gt;(</code></a>: increments <code>N</code> and skips <code>prgmD</code> if <code>N&gt;A</code>. <code>N</code> tracks the depth of the function so that it stops at depth <code>A+1</code></li>
<li><a href="http://tibasicdev.wikidot.com/ds" rel="nofollow noreferrer"><code>DS&lt;(</code></a>: very similar, decrements <code>N</code>, and never skip the next line in this case</li>
</ul>
<p><span class="math-container">$$B = \sum_{I=0}^{A+1}(A^I) = \frac{A^{A+2}-1}{A-1} \approx A^A$$</span></p>
<p><code>B</code> is the number of times the length of <code>Str2</code> is doubled, giving the number:</p>
<p><span class="math-container">$$1.111 \times 10^{2^B} ≈ 10^{2^{A^A}} 
\approx 10^{2^{(1.7 \times 10^9)^{1.7 \times 10^9}}}
\approx 10^{10^{10^{10^{10.2124}}}}
\approx 10 \uparrow\uparrow 5.0039
$$</span></p>
<h3>Edit:</h3>
<ul>
<li><p>I was using <code>cosh(</code> which is kinda cheating, but now I allowed myself to use <code>Xmin</code> and <code>Xmax</code> (-10 and 10)</p>
<p>My previous score was <span class="math-container">\$ 10 \uparrow\uparrow 5.03 \$</span> with <code>cosh(cosh(Tmax→A</code> (<span class="math-container">\$ 3.6 \times 10^{11}\$</span>)</p>
</li>
<li><p><span class="math-container">\$ 10 \uparrow\uparrow 4.913 \rightarrow 10 \uparrow\uparrow 5.0039\$</span> for using <code>Σx</code> instead of <code>Xmax</code></p>
</li>
</ul>
</div>
<div id="pu32" class="pu"><h1>Ruby, <span class="math-container">\$f_{\varphi(1,0,0)}(5)\$</span> (non-deterministic)</h1>
<p>More precisely: <span class="math-container">\$f_{\varphi(\varphi(\varphi(\varphi(\varphi(16381,\omega^2),\omega^2),\omega^2),\omega^2),\omega^2)}(1048577)\$</span>.</p>
<pre><code>*h=[[[[n=$$]]]]
f=-&gt;a{b,c,d=a;b ?a==b ?~-a:a==a-[$.]?[f[b],d,[b,f[c],d]]:d:n+=n}
h=f[h]while h!=p(n)
</code></pre>
<p><a href="https://tio.run/##DcZNCgIxDIbh/ZxihC78ST1A5XMOErJIppYIUkQQEdGr1zyLl/fxtPcYeweHjpQkTA35rB@jlSr0ZPOiQPSXtcRp5nSUhRubUCU2arzGiZRa@gH9Ozkau7z8ervMvsF923dj/AE" rel="noreferrer">Try it online!</a></p>
<p><sub>*<code>$. == 0</code> is a global variable.</sub></p>
<p><sub>*Relies on <code>$$</code>, the <a href="https://stackoverflow.com/a/2177022/7741591">process ID</a>. I suppose the rules never said random behavior isn't allowed. I'm assuming the maximum PID to be 32768.</sub></p>
<h1>Ruby, <span class="math-container">\$f_{\varphi(1,0,0)}(3)\$</span> (deterministic)</h1>
<p>More precisely: <span class="math-container">\$f_{\varphi(\varphi(\varphi(\omega+\omega,\omega^2),\omega^2),\omega)}(16)\$</span>.</p>
<pre><code>*h=[[[n=-~$.]]]
f=-&gt;a{b,c,d=a;b ?a==b ?~-a:a==a-[$.]?[f[b],d,[b,f[c],d]]:d:n+=n}
h=f[h]while h!=p(n)
</code></pre>
<p><a href="https://tio.run/##DcpBCsIwEEbhfU9RoYuqEw8Q@e1BhlnMNIYplCCCFCn26jGbx7d47499a704mLkgHMNNRLqM8NDdaKYEvVs/KdB6BI1NGrhtE2c2oURslHluEokplivKr3Nkdtl8WZ@9n/Aay7nWPw" rel="noreferrer">Try it online!</a></p>
<p><sub>*Previously removed the prints, not sure why but they're back since removing them doesn't really let us improve much. Probably just +1 (or +2 at best) inside the <span class="math-container">\$f_{\varphi(1,0,0)}(n+\dots)\$</span>.</sub></p>
<h3>Ungolfed:</h3>
<p><sub>*See math explanation below.</sub></p>
<pre><code>n = 32768         # n = &quot;count&quot;
h = [[[[[n]]]]]   # h0 = 32768
                  # h1 = &quot;count op(h0) count&quot;
                  # ...
                  # h = h5 = &quot;count op(h4) count&quot;

f = -&gt; a {        # f[a] = reduce(a)
  b, c, d = a                     # truncate to first 3 elements
  if a == [] || a.nil?            # if a == &quot;count&quot;
    n += n                          # increment counter
    return n                        # and replace with counter
  elsif a.is_a? Integer           # if a == int
    return a - 1                    # decrement int
  elsif a != a-[0]                # if a == &quot;++d&quot;
    return d                        # return just d
  else                            # if a == &quot;d op c&quot; where b = op  (*note out of order)
    return [f[b], d, [b, f[c], d]]  # (d op reduce(c)) reduce(op) d
  end
}

while h != n  # reduce until h == n
  h = f[h]
  p(n)
end
</code></pre>
<p><sub>*We write <code>&quot;x op(y) z&quot; = [y, z, x]</code> so that reducing it reduces <code>y</code> before <code>z</code> and so that <code>[t] = &quot;count op(t) count&quot;</code>.</sub></p>
<h3>Math explanation:</h3>
<p>The code may be approximately understood as a combination of symbolic manipulation and recursive reduction of algebraic expressions.</p>
<p>Let <code>++a</code> denote <code>a+1</code>, the successor of <code>a</code>.</p>
<p>We then define <code>reduce(&quot;x&quot;)</code> as <code>x-1</code>, meaning:</p>
<ul>
<li><code>reduce(&quot;++a&quot;) = a</code>.</li>
</ul>
<p>We then try to work out <code>reduce(&quot;x&quot;)</code> for algebraic expressions:</p>
<ul>
<li><code>reduce(&quot;a+b&quot;) = a + reduce(&quot;b&quot;) = reduce(&quot;++(a + reduce(&quot;b&quot;))&quot;)</code></li>
<li><code>reduce(&quot;a*b&quot;) = reduce(&quot;a*reduce(&quot;b&quot;) + a&quot;)</code></li>
<li><code>reduce(&quot;a^b&quot;) = reduce(&quot;a^reduce(&quot;b&quot;) * a&quot;)</code></li>
</ul>
<p>Generalizing this, we get:</p>
<ul>
<li><code>reduce(&quot;a op b&quot;) = reduce(&quot;(a op reduce(b)) reduce(&quot;op&quot;) a&quot;)</code></li>
</ul>
<p>where:</p>
<ul>
<li><code>reduce(&quot;*&quot;) = &quot;+&quot;</code></li>
<li><code>reduce(&quot;^&quot;) = &quot;*&quot;</code></li>
</ul>
<p>and more generally:</p>
<ul>
<li><code>reduce(&quot;op(n)&quot;) = op(reduce(&quot;n&quot;))</code></li>
<li><code>x op(0) y = ++x</code></li>
<li><code>x op(1) y = x+y</code></li>
<li><code>x op(2) y = x*y</code></li>
<li><code>x op(3) y = x^y</code></li>
</ul>
<p>for simplicity we also define:</p>
<ul>
<li><code>x op 0 = ++x</code></li>
</ul>
<p>We then introduce <strong>symbols</strong>. The only symbol is <code>&quot;count&quot;</code>, where <code>reduce(&quot;count&quot;)</code> is the amount of times <code>reduce</code> has been called.</p>
<p>We then apply <code>x = reduce(x)</code> until <code>x = 0</code> and print the <code>count</code>.</p>
<h3>Example:</h3>
<pre><code>&quot;count^3&quot;

1:  reduce(&quot;count^3&quot;)
2:  reduce(&quot;count^reduce(3) reduce(&quot;^&quot;) count&quot;)
      Note: we evaluate right-to-left
3:  reduce(&quot;count^reduce(3) * count&quot;)
4:  reduce(&quot;count^2 * count&quot;)
5:  reduce(&quot;count^2 * reduce(&quot;count&quot;) reduce(&quot;*&quot;) count^2&quot;)
6:  reduce(&quot;count^2 * reduce(&quot;count&quot;) + count^2&quot;)
7:  reduce(&quot;count^2 * 6 + count^2&quot;)
8:  reduce(&quot;count^2 * 6 + reduce(&quot;count^2&quot;) reduce(&quot;+&quot;) ...&quot;)
9:  reduce(&quot;++(count^2 * 6 + reduce(&quot;count^2&quot;))&quot;)
10: reduce(&quot;++(count^2 * 6 + count^reduce(2) reduce(&quot;^&quot;) count)&quot;)
11: reduce(&quot;++(count^2 * 6 + count^reduce(2) * count)&quot;)
12: reduce(&quot;++(count^2 * 5 + count^1 * count)&quot;)

&quot;count^2 * 6 + count^1 * count&quot;
(continue applying reduce(...) until you get 0)
</code></pre>
<p>Note that the growth relies on the 'lazy' evaluation of <code>&quot;count&quot;</code>. Despite how simple it is to normally cube an integer, fully reducing <code>&quot;count^3&quot;</code> actually results in <code>count &gt; 10^10^10^10^10^10^5</code>.</p>
<p><strong>Let <code>g(x, n)</code> be</strong> the final <code>count</code> after fully reducing <code>x</code> with an initial <code>count = n</code>.</p>
<p>So from the previous example, <code>g(&quot;count^3&quot;, 0) &gt; 10^10^10^10^10^10^5</code>.</p>
<p><strong>For some intuition on the very fast growth</strong>, notice that <code>g(&quot;a+b&quot;, n) &gt; g(a, g(b, n))</code>. This is because we have to reduce <code>b</code> before <code>a</code>. This means <strong>addition allows recursion</strong>, and we also know that <strong>multiplication expands into lots of addition</strong>.</p>
<p>Then note that</p>
<ul>
<li><code>g(&quot;count&quot;, n) ~ 2 * n</code></li>
<li><code>g(&quot;count + count&quot;, n) ~ 2 * 2 * n = 4 * n</code></li>
<li><code>g(&quot;count + count + ...&quot;, n) ~ 2 * 2 * ... * n = 2^k * n</code></li>
<li><code>g(&quot;count * k&quot;, n) ~ 2^k * n</code></li>
<li><code>g(&quot;count * count&quot;, n) ~ 2^n</code></li>
<li><code>g(&quot;count ^ 2&quot;, n) ~ 2^n</code></li>
<li><code>g(&quot;count ^ 2 + count ^ 2&quot;, n) ~ 2^2^n</code></li>
<li><code>g(&quot;count ^ 2 * k&quot;, n) ~ 2^2^...^n</code></li>
<li><code>g(&quot;count ^ 2 * count&quot;, n) ~ n↑↑n</code></li>
<li><code>g(&quot;count ^ 3&quot;, n) ~ n↑↑n</code></li>
<li><code>g(&quot;count ^ 4&quot;, n) ~ n↑↑↑n</code></li>
</ul>
<h3>Some other values of interest:</h3>
<p>For the last 3, we define:</p>
<ul>
<li><code>h(0, y) = y</code></li>
<li><code>reduce(h(x, y)) = &quot;count op(h(reduce(x), y)) count&quot;</code></li>
</ul>
<pre><code>g(&quot;count^k&quot;, n) ~ n↑↑...k arrows...↑↑n
g(&quot;count^count&quot;, n) ~ n↑↑...n arrows...↑↑n ~ Ack(n,n)
g(&quot;count^(++count)&quot;, 20) ~ Toeofdoom's a_20(1)
g(&quot;count^(++count)&quot;, 64) ~ Graham's number
g(&quot;count^(count+1)&quot;, 15) ~ eaglgenes101's number  (note count+1 turns into ++(++count))
g(&quot;count op(4) 2&quot;, 127) ~ col6y's number
g(&quot;(count op(4) 3) * count&quot;, 3) ~ my older/other number
g(&quot;count op(6) 1&quot;, 9) ~ r.e.s.'s number
g(&quot;(count op(6) 1) * (++count op(4) 1)&quot;, 17) ~ Peter Taylor's number
g(h(3, &quot;count + count&quot;), 126) ~ this deterministic number
g(h(5, 16381), 1048577) ~ this non-deterministic number
g(&quot;h(&quot;count&quot;, &quot;count&quot;) * count^7&quot;, 256^26) ~ Steve H.'s number
</code></pre>
</div>
<div id="pu33" class="pu"><h1><a href="https://www.rust-lang.org/" rel="nofollow noreferrer">Rust</a>, score <span class="math-container">\$10 \uparrow\uparrow\uparrow 127\$</span></h1>

<pre class="lang-rust prettyprint-override"><code>fn main(){let b='~' as usize;let mut n=b+b;for _ in b..n{n&lt;&lt;=n;for _ in b..n{n&lt;&lt;=n;print!(&quot;{}&quot;,n)}}}
</code></pre>
<p><a href="https://tio.run/##bchLCoAgFAXQrbycaBRuQF1LJCgIeQs/k8S2bjTvDE@quYzhQXEPEHM7XCFr@MNpz1RzuJ36KtZCMHaxyp@JNgogKyUatDb4vSsFlEmw1tmKufc@xgs" rel="nofollow noreferrer" title="Rust – Try It Online">Try it online!</a></p>
<p>Note that the code's validity is dependent on the assumption that a computer with infinite memory will have an arbitrary precision pointer to index the infinite memory. I also attempted to write a version that wouldn't overflow instantly with arbitrary precision integers but it still overflowed on the second bitshift.</p>
<h2>Size analysis:</h2>
<p>A bit-shifting <span class="math-container">\$n\$</span> leftward <span class="math-container">\$n\$</span> times is equivalent to the function <span class="math-container">\$n2^n = f_2(n)\$</span>. My code applies recursion in a manner consistent with the fast-growing hierarchy to achieve <span class="math-container">\$f_4(n)\$</span>. let the final value of the local variable <code>n</code> in my code above be denoted as <span class="math-container">\$o\$</span>. It will require <span class="math-container">\$log(o)\$</span> bitshifts to create <span class="math-container">\$o\$</span>. The <code>print!</code> statement runs every time the inner bitshift does, meaning the order of magnitude of my score is the sum of the change in the order of magnitude of the variable <code>n</code> between the inner bitshifts. The order of magnitude of <code>n</code> should be growing exponentially since it is being tetrated, so the expression for the order of magnitude of the result is
<span class="math-container">$$\sum_i^{log(o)}2^i$$</span>
telling us that the final number is <span class="math-container">\$10^{2^{log(o)+1}-1}\$</span> which is not meaningfully different from <span class="math-container">\$o\$</span> itself since <span class="math-container">\$o\$</span> in this case is <span class="math-container">\$f_4(126)\$</span> or <span class="math-container">\$10 \uparrow\uparrow\uparrow 127\$</span>. Please let me know if this explanation seems wrong or incomplete because I am new to the domain of big numbers.</p>
<p>Edit: better approximation thanks to Simply Beautiful Art.</p>
</div>
<div id="pu34" class="pu"><h1>JavaScript 44 chars</h1>
<p>This may seem a little cheaty:</p>
<pre class="lang-javascript prettyprint-override"><code>alert((Math.PI+''+Math.E).replace(/\./g,&quot;&quot;))
</code></pre>
<p><strong>Score = 31415926535897932718281828459045 / 44^3 ≈ 3.688007904758867e+26 ≈ 10↑↑2.1536134004</strong></p>
</div>
<div id="pu35" class="pu"><h1>Idris, score &gt;&gt;&gt; g64</h1>
<pre><code>h:Nat-&gt;Nat
h Z=S(S Z)
h(S y)=let n=h y in hyper n n n
let x=iterate h Z in index((index$S$S$S$Z)x)x
</code></pre>
<p>Last line is the expression resulting in an extremely high number. I did never use exponentiation directly, since I never even called the hyper operator on level 3.
The fifth element of <code>x</code> already results in</p>
<pre><code>hyper(hyper(hyper(hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2)),hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2)),hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2))),hyper(hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2)),hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2)),hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2))),hyper(hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2)),hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2)),hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2)))),hyper(hyper(hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2)),hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2)),hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2))),hyper(hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2)),hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2)),hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2))),hyper(hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2)),hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2)),hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2)))),hyper(hyper(hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2)),hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2)),hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2))),hyper(hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2)),hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2)),hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2))),hyper(hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2)),hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2)),hyper(hyper(2,2,2),hyper(2,2,2),hyper(2,2,2)))))
</code></pre>
<p>because the code builds up trinary trees of hyper operators. However, the now given value will be used to index an infinite stream, such that the n-th element of that stream equals h applied n times on zero. This results in a value much larger than Graham's number.</p>
</div>
<div id="pu36" class="pu"><h1>New Ruby: score ~ f<sub>ω<sup>ω2</sup>+1</sub>(126<sup>2</sup>2<sup>126</sup>)</h1>
<p>where f<sub>α</sub>(n) is the fast growing hierarchy.</p>
<pre><code>n=?~.ord;H=-&gt;a{b,*c=a;eval&quot;b ?H[b==$.?c:[b==~$.?n:b-(b&lt;=&gt;$.)]*n+c]:p(n+=n);&quot;*n};eval&quot;H[~n];&quot;.*n*n&lt;&lt;n
</code></pre>
<p><a href="https://tio.run/##JctBCoMwEAXQq0hwoWPNAZKM2eYOkkUm7a78FqGCSHP1qLh7m7f8ZKsV7Iv@LE8beJzSLg/KnOxrTW8ljQ@zMLfaZ3OhnIKRsRPHU6v7SBhyNN8OA6O3ivC/Z5gLolWaQHAOtR4" rel="nofollow noreferrer">Try it online!</a></p>
<p>The <code>*n</code> are just string and array multiplication, so they should be fine.</p>
<h3>Ungolfed code:</h3>
<pre><code>n = 126
H =-&gt; a {
    b, *c = a
    n.times{
        case b
        when nil
            puts(n += n)
        when 0
            H[c]
        when -1
            H[[n]*n+c]
        else
            H[[b.-b&lt;=&gt;0]*n+c]
        end
    }
}
(n*n&lt;&lt;n).times{H[~n]}
</code></pre>
<p>where <code>b.-b&lt;=&gt;0</code> returns an integer that is <code>1</code> closer to <code>0</code> than <code>b</code>.</p>
<hr />
<h3>Explanation:</h3>
<p>It prints <code>n</code> at the start of every call of <code>H</code>.</p>
<p><code>H[[]]</code> doubles <code>n</code> (<code>n</code> times), i.e. <code>n = n&lt;&lt;n</code>.</p>
<p><code>H[[0,a,b,c,...,z]]</code> calls <code>H[[a,b,c,...,z]]</code> (<code>n</code> times).</p>
<p><code>H[[k+1,a,b,c,...,z]]</code> calls <code>H[[k]*n+[a,b,c,...,z]]</code> (<code>n</code> times), where <code>[k]*n = [k,k,...,k]</code>.</p>
<p><code>H[[-1,a,b,c,...,z]]</code> calls <code>H[[n]*n+[a,b,c,...,z]]</code> (<code>n</code> times).</p>
<p><code>H[[-(k+1),a,b,c,...,z]]</code> calls <code>H[[-k]*n+[a,b,c,...,z]]</code> (<code>n</code> times).</p>
<p><code>H[k] = H[[k]]</code>.</p>
<p>My program initializes <code>n = 126</code>, then calls <code>H[-n-1]</code> 126<sup>2</sup>2<sup>126</sup> times.</p>
<hr />
<h3>Examples:</h3>
<p><code>H[[0]]</code> will call <code>H[[]]</code> which applies <code>n = n&lt;&lt;n</code> (<code>n</code> times).</p>
<p><code>H[[0,0]]</code> will call <code>H[[0]]</code> (<code>n</code> times).</p>
<p><code>H[[1]]</code> will call <code>H[[0]*n]</code> (<code>n</code> times).</p>
<p><code>H[[-1]]</code> will call <code>H[[n]*n]</code> (<code>n</code> times).</p>
<p><code>H[[-1,-1]]</code> will call <code>H[[n]*n+[-1]]</code> (<code>n</code> times).</p>
<p><code>H[[-3]]</code> will call <code>H[[-2]*n]</code> (<code>n</code> times).</p>
<p><a href="https://tio.run/##bctBDoIwEAXQfU/xAzsQYl1b3PYOtYsWMSHBiaGwMKRnr1ATEoFZzfz/ph/tJwSCwIVJiKKCwcQwjz0hq@fcxOs9Dg4JiXQifyep0sl4ncSKyqF9Ne73tUz7hC2p7W5rEhlyAVqjpnOLgxA4/zmpar1T1Q4pW3CdUX6Aryj4TucHutkq2hp6xN0zz@aaax3CFw" rel="nofollow noreferrer">Try it online!</a></p>
<hr />
<p>See <a href="https://codegolf.stackexchange.com/posts/120228/revisions">revisions</a> for other cool things.</p>
</div>
<div id="pu37" class="pu"><p>Python2 </p>

<pre><code>o=oct(ord('~'))
for a in range(int(o)):
    o+=o*int(o)
    for b in range(int(o)):
        o+=o*int(o)
o*int(o)
</code></pre>

<p>This is exactly 100 characters if the indentations are tabs.</p>

<p>In order for the program to output, it needs to be run in a python console rather than in a file.</p>

<p>Score is unknown at this point because the inner for loop will run 10e707 times in the first iteration of the outer loop. and in total, there will be 176 iterations of the outer loop. Also, this output is too big for me to even comprehend how to mark the notation for it.</p>
</div>
<div id="pu38" class="pu"><h1><a href="https://esolangs.org/wiki/Come_Here" rel="nofollow noreferrer">Come Here</a>, score 1.03x10<sup>37</sup></h1>

<pre><code>TELL"___________________________________________"-"&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;"NEXT
</code></pre>

<p>Come Here handles string arithmetic weirdly. In the encoding used by the reference implementation, <code>"_"-"&amp;"</code> is <code>"9"</code>.</p>

<hr>

<p>Also, <em>this</em> program prints (in theory) a number slightly larger than 10<sup>10<sup>98</sup></sup>, however, it is not a valid answer to this question due to the restriction on using digits (and multiplication, for that matter; though I'm using it for string prepending here) in your code.</p>

<pre><code>0CALL"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"cCALL0dCOME FROM SGNcCALL256*d+57d1CALLc-1cTELLdNEXT
</code></pre>
</div>
<div id="pu39" class="pu"><h1>Julia, f<sub>ω<sup>3</sup></sub>(127)</h1>

<pre><code>f(r,s,t)=foldl(|&gt;,r,fill(s,t));!q=x-&gt;f(x,q,x);w(b)=a-&gt;x-&gt;x|&gt;f(a,b,x);w(w(w(!)))(x-&gt;x+x)(BigInt('~'))
</code></pre>

<p>I aimed for the fast-growing functions corresponding to ordinals in the Veblen hierarchy, but I had to settle for ordinal exponentation. Maybe another challenge... </p>

<h2>Explanation:</h2>

<pre><code>#Function iteration, which is the tool to get us this far
#Applies s to r, t times
f(r,s,t)=foldl(|&gt;,r,fill(s,t));

#Here's the first order successor:
!q=x-&gt;f(x,q,x);

#Function to help us with diagonalization
#Take a and x, and fold the b higher order function on the a function x times, 
#then plug x into the resulting function
#Doing this multiplies the ordinal position by ω, which isn't nearly as high as I would hope
#Yes,I tried the ~ operator, but Julia doesn't like when I do that
w(b)=a-&gt;x-&gt;x|&gt;f(a,b,x);

#Call it, and implicitly return it. 
#Or interrupt it, and and enjoy your screenfulls of stack traces. 
w(w(w(!)))(x-&gt;x+x)(BigInt('~'))
</code></pre>
</div>
<div id="pu40" class="pu"><h1>brainfuck, 97 bytes, f<sub>255</sub>(255<sup>2</sup>)</h1>

<pre><code>-[&gt;-[[&gt;]-[&lt;]&gt;&gt;-]&lt;-]-[-[[&gt;]+[&lt;]&lt;+&gt;&gt;-]-[&lt;+&gt;-----]&lt;.,&lt;[&gt;&gt;&gt;[[-&lt;+&gt;]&lt;[&lt;]&lt;[-&gt;+&lt;&lt;+&gt;]&gt;[&gt;]&gt;]&lt;+[&lt;]&gt;,&lt;&lt;-]&gt;&gt;&gt;]
</code></pre>

<p>Assumes a wrapping implementation with an infinite tape in both directions.</p>

<p>The algorithm of the program is:</p>

<pre><code>Initialise a list with 255^2+1 255s
While the list exists:
    Print a 3
    Pop the first element of the list to use as a counter
    Decrement the counter
    Append counter many 1s to the end of the list
    While counter != 0:
        Prepend length of list-1 copies of the counter to the front of the list
        Decrement counter
</code></pre>

<p>This is not infinite, as every time a list element is processed, it only appends elements that are less than it. <code>1</code>s are popped and removed without appending anything.</p>

<p>A step by step explanation of the code:</p>

<pre><code>- Initialise counter as 255
[ While counter
  &gt;-[[&gt;]-[&lt;]&gt;&gt;-] Add 255 255s to the list
  &lt;- Decrement counter
]- 
This initialises the list as 255^2+1 255s

[ While list exists
  - Decrement the first element
  [ 
    [&gt;]+[&lt;] Append that many 1s to the end of the list
    &lt;+&gt;&gt;-   Copy the element one over
  ]
  -[&lt;+&gt;-----]&lt;.,&lt; Print a 3
  [ While counter
      &gt;&gt;&gt; Go to first element of list
      [ For each element in the list
          [-&lt;+&gt;] Move the element over one
          &lt;[&lt;]&lt; Go to the counter
          [-&gt;+&lt;&lt;+&gt;] Prepend a copy of the counter to the start of the list
          &gt;[&gt;]&gt; Go to the next element of the list
      ]
      &lt;+[&lt;] Return to the start of the list while appending a 1
      &gt;,    Remove the first element of the list
      &lt;&lt;-   Decrement the counter
  ]
  &gt;&gt;&gt; Go to first element of the list
]
</code></pre>

<p>Big thanks to the folks on the <a href="https://discord.gg/5v6ucfN" rel="nofollow noreferrer">Ordinal Studies Discord</a> for helping me understand just how big the number is. If anything seems wrong, <s>blame them</s> please correct me.</p>
</div>
<div id="pu41" class="pu"><h1>J, f<sub>ω</sub>(256) / 50653</h1>

<pre><code>(&lt;:@[$:~^:]])`(&gt;:@])@.(=(#&gt;a.)"_)~#a.
</code></pre>

<h3>Explanation:</h3>

<p>This makes use of what J calls a gerund:</p>

<p>The <code>`</code> character is used to form a list of verbs, and the the verb following <code>@.</code> is used to select which verb to apply. This makes it equivalent to an <code>if ... then ... else</code> statement.</p>

<p>Also, <code>$:</code> is equivalent to the largest verb containing it. However, since we use <code>~</code> to apply our dyad with its right argument as both arguments, this is also part of <code>$:</code>, which in the dyadic case flips the order of its arguments. Therefore, we use another <code>~</code> to un-flip them.</p>

<p>And, one last bit, <code>a:</code> is an empty box, <code>&gt;</code> unboxes it, and <code>#</code> takes the length. So, <code>#&gt;a:</code> is 0</p>

<p>Using this, we can equivalently define this verb in a more ledgible, less golfed way:</p>

<pre><code>f =: dyad define
if. x = 0 do.
    &gt;:y
else.
    (&lt;:x) f^:y (y)
end.
)
</code></pre>

<p><sub> Note: <strong>x</strong> is the left argument, <strong>y</strong> is the right </sub></p>

<p>This fits the definition of the fast-growing heirarchy.</p>

<p>And then our program is <code>f~ #a.</code>. Now, <code>#a.</code> is the length of J's alphabet, which happens to be 256. Therefore, our program computes f<sub>256</sub>(256) = <strong>f<sub>ω</sub>(256)</strong>, since f<sub>ω</sub> is defined as f<sub>n</sub>(n).</p>

<p><sub> Note: <code>^:</code> is distinct from <code>^</code> :</sub></p>

<p><sub> <code>^:</code> is an adverb which is equivalent to a functional power, which I do not believe is disallowed in the OP</sub></p>
</div>
<div id="pu42" class="pu"><h1>Javascript, > 10<sup>316469</sup> ≈ 10↑↑2.740388839</h1>

<p>(Run from the browser console to get output)</p>



<pre class="lang-js prettyprint-override"><code>for(a="",b="￭".charCodeAt``;b--;)a+=(''+b).repeat("￭".charCodeAt``);a
</code></pre>
</div>
<div id="pu43" class="pu"><h1>Pyth,  f<sub>ψ(Ω<sup>Ω</sup>)+7</sub>(256<sup>26</sup>)/1000000</h1>
<pre><code>=CGL&amp;=.&lt;GG?+Ibt]Z?htb?eb[XbhhZyeby@bhZhb)hbXbhhZyeb@,tb&amp;bG&lt;bhZ=Y[tZGG)VGVGVGVGVGVGVGVG=[YYY)uyFYHpG)
</code></pre>
<p>SimplyBeautifulArt has a <a href="https://codegolf.stackexchange.com/a/149763/55696">fantastic explanation</a> of a function that both of our solutions share, namely that I define a function <code>y[b,G]</code> with a global =<code>g[h,n]</code>.  The major differences are as follows:</p>
<ul>
<li><p>I begin my value at the base 256 representation of the ASCII codes for the string &quot;abcdefghijklmnopqrstuvwxyz&quot;.</p>
</li>
<li><p>I use bit shifting <code>.&lt;</code> to increase the value of <code>G</code> instead of addition.</p>
</li>
<li><p><code>G</code> gets incremented each step that <code>y</code> gets run including the recursive cases, while SBA's <code>n</code> gets incremented outside of his <code>g</code> and thus is updated less frequently.</p>
</li>
<li><p>Instead of being satisfied with simply doing <code>[[],n,n]</code> (which my code represents as <code>Y=[-1,G,G]</code>, I nest <code>Y</code> into itself as <code>Y=[Y,Y,Y]</code> <code>G</code> times, increasing G by calling <code>Y=y[Y,G]</code> <code>2(x+1)</code> times, where <code>x</code> is as many times as it takes the new version of <code>Y</code> to reach 0 by these repeated applications.  <code>Y</code>'s value doesn't actually get reset to 0, because we calculate <code>x</code> by counting upwards using the reduce-until-seen-before builtin <code>u</code>.</p>
</li>
<li><p>I then wrap the entirety of the above into 7 <code>for</code> loops (<code>VG</code>), which will repeat the key inner loop that nests <code>Y</code>  and increases <code>G</code> until <code>repeat(y[Y,G],Y=0</code> <code>G</code> times.</p>
</li>
<li><p>Unwrapping all of these nested <code>Y</code>s results in a number that, to the best of my understanding, blows all the other solutions out of the water.  I'll hold off on adding my solution to the leaderboard until someone else confirms my math.</p>
</li>
</ul>
</div>
<div id="pu44" class="pu"><h1><a href="https://github.com/gunnerwolf/braingolf" rel="nofollow noreferrer">Braingolf</a>, 10 bytes, final score: ≈ 10<sup>131</sup> ≈ 10↑↑2.3257765097</h1>

<pre><code>#􏿿[l!_]
</code></pre>

<p>Note that <code>􏿿</code> is a 4 byte ASCII character with the value <code>1114111</code></p>

<p>Outputs every number from 2 to 1114111 with no spaces or other separators. 
Somewhere around 6.7m digits, but can we make it bigger...</p>

<h1>Braingolf, 100 bytes</h1>

<pre><code>#􏿿...............[l!_][l!_][l!_][l!_][l!_][l!_][l!_][l!_][l!_][l!_][l!_][l!_][l!_][l!_][l!_][l!_]
</code></pre>

<p>This does the same as above, but 16 times over. Meaning the final number is every number from 1 to 17825792 appended. 131m digits.</p>

<p>Not the largest or the winner by any stretch, but still pretty good, and probably as good as one can do in Braingolf given the banning of operators</p>
</div>
<div id="pu45" class="pu"><h1>GTB</h1>

<p><strong>Don't run this on your calculator</strong> <em>(it leaks memory)</em></p>

<pre><code>[%X:"]
</code></pre>

<p>Code length = 6 bytes (6<sup>3</sup>=216)</p>

<p>Score = <strong>13,256,072</strong> (2,863,311,531/216)</p>

<p>**Assumes 16 GB free memory on an emulator for Windows*</p>
</div>
<div id="pu46" class="pu"><h1>Haskell, 100 bytes, score ≈ 10↑↑65503</h1>

<pre><code>f!x|x&lt;' '=f|q&lt;-(!pred x),r&lt;-(q$q f)[x]=foldl(.)f[f|_&lt;-r,_&lt;-r]
main=print$(\x-&gt;x++x)!'�'$[pred ':']
</code></pre>

<p>The special character (2^16 - 3 ascii) counts as 2 bytes. <code>pred ':'</code> is equal to <code>'9'</code>.</p>
</div>
<div id="pu47" class="pu"><h1>C</h1>

<p>(With apologies to Darren Stone)</p>

<pre><code>long n,o,p,q,r;main(){while(--n){while(--o){while(--p){while(--q){while(--r){putchar('z'-'A');}}}}}}
</code></pre>

<p>n = 2^64 digit number (9...)</p>

<p>l = 100 chars of code</p>

<p><strong>score ≈ 1e+2135987035920910082395021706169552114602704522356652769947041607822219725780640550022962086936570 ≈ 10↑↑3.2974890744</strong></p>

<p>[ Score = n^5/l^3 = (10^(2^320)-1)/(100^3) = (10^2135987035920910082395021706169552114602704522356652769947041607822219725780640550022962086936576-1)/(10^6) ]</p>

<p>Note that I deserve to be flogged mercilessly for this answer, but couldn't resist. I don't recommend acting like me on stackexchange, for obvious reasons. :-P</p>

<hr>

<p>EDIT: It would be even harder to resist the temptation to go with something like </p>

<pre><code>long n;main(){putchar('z'-'A');putchar('e');putchar('+');while(--n){putchar('z'-'A');}
</code></pre>

<p>...but I suppose that an intended but unspecified rule was that the entire run of digits making up the number must be printed.</p>
</div>
<div id="pu48" class="pu"><h2>Python, 2↑↑11 / 830584 ≈ 10↑↑8.632971 (Knuth up arrow notation)</h2>



<pre class="lang-python prettyprint-override"><code>print True&lt;&lt;(True&lt;&lt;(True&lt;&lt;(True&lt;&lt;(True&lt;&lt;(True&lt;&lt;(True&lt;&lt;(True&lt;&lt;(True&lt;&lt;(True&lt;&lt;True&lt;&lt;True)))))))))
</code></pre>

<p>Probably no computer has enough memory to successfully run this, but that's not really the program's fault.  With the minimum system requirements satisfied, it does work.</p>

<p>Yes, this is doing bit shifting on boolean values.  <code>True</code> gets coerced to <code>1</code> in this context.  Python has arbitrary length integers.</p>
</div>
<div id="pu49" class="pu"><h2>JavaScript 98 chars</h2>

<pre><code>m=Math;a=k=(''+m.E).replace('.',"");j=m.PI%(a&amp;-a);for(i=j;i&lt;(m.E&lt;&lt;k&lt;&lt;k&lt;&lt;k&lt;&lt;m.E);i+=j)a+=k;alert(a)
</code></pre>

<p>generates 2.718e+239622337 ≈ 10↑↑2.9232195202</p>

<p>For score of just slightly more than 2.718e+239622331 ≈ 10↑↑2.9232195197</p>

<p>which is the largest I can make it without the browser crashing.</p>

<p>(console.log(a) will show you the full output)</p>

<h3>Don't run these:</h3>

<pre><code>m=Math;a=k=(''+m.E).replace('.',"");j=m.PI%(a&amp;-a);for(i=j;i&lt;(k&lt;&lt;k&lt;&lt;k&lt;&lt;k&lt;&lt;k&lt;&lt;k&lt;&lt;k);i+=j)a+=k;alert(a)
</code></pre>

<p>would output 2.718+e121333054704 ≈ 10↑↑3.0189898069 (aka 2.718*10^(1.213*10^12) to compare to the longer answer:</p>

<p>more extreme version, if it didn't crash your browser: (80 char)</p>

<pre><code>m=Math;a=k=(''+m.E).replace('.',"");j=m.PI%(a&amp;-a);for(i=j;i&lt;k;i+=j)a+=k;alert(a)
</code></pre>

<p>which would create a number around the same size as e * 10^(10^19) ≈ 10↑↑3.106786869689</p>

<p>Edit: updated code
original solution only generated 2.718e+464</p>
</div>
<div id="pu50" class="pu"><h2>Python 3, score = ack(126,126)/100^3</h2>

<pre><code>g=len('"');i=ord('~');f=lambda m,n:(f(m-g,f(m,n-g))if n else f(m-g,g))if m else n+g
print(f(i,i))
</code></pre>

<p>The f function is the ackermann function, which i have just enough space to invoke.</p>

<p>Edit: previously "else n+1", which was in violation of challenge rules- kudos to Simply Beautiful Art.</p>
</div>
<div id="pu51" class="pu"><h1>ECMAScript 6 - 10^3↑↑↑↑3 / 884736</h1>

<p>(3↑↑↑↑3 is G(1) where G(64) is Graham's number)</p>
<pre class="lang-javascript prettyprint-override"><code>u=-~[v=+[]+[]]+[];v+=e=v+v+v;D=x=&gt;x.substr(u);K=(n,b)=&gt;b[u]?n?K(D(n),K(n,D(b))):b+b+b:e;u+K(v,e)
</code></pre>
<p>Output: 10^3↑↑↑↑3</p>
<p>Hints:</p>
<p><strike><code>G</code> is the function where G(64) is Graham's number. Input is an integer. Output is a unary string written with 0.</strike> Removed for brevity.</p>
<p><code>K</code> is the Knuth up-arrow function a ↑<sup>n</sup> b where a is implicitly 3. Input is n, a unary string, and b, a unary string. Output is a unary string.</p>
<p><code>u</code> is &quot;1&quot;.</p>
<p><code>v</code> is &quot;0000&quot;, or G(0)</p>
<p><code>e</code> is &quot;000&quot;.</p>
</div>
<div id="pu52" class="pu"><h2>Fortran (6.4243e4926 ≈ 10↑↑2.556279837)</h2>

<p>Requires quad-precision library to be installed,</p>

<pre><code>use iso_c_binding;real(c_long_double)a;print*,huge(a);end
</code></pre>
</div>
<div id="pu53" class="pu"><h1>C (score ≈ 10^20 000 000 000 ≈ 10↑↑3.005558275)</h1>
<ul>
<li>~20 GB output</li>
<li>41 characters (41^3 means nothing)</li>
</ul>

<pre class="lang-c prettyprint-override"><code>main(){for(;rand();printf(&quot;%d&quot;,rand()));}
</code></pre>
<p>Despite of <code>rand()</code> the output is deterministic because there is no seed function.</p>
</div>
<div id="pu54" class="pu"><h2>Powershell (2.53e107976 / 72³ = 6.78e107970 ≈ 10↑↑1.701853371)</h2>



<p>This takes far more than 5 seconds to run.</p>

<pre class="lang-powershell prettyprint-override"><code>-join(-split(gci \ -r -EA:SilentlyContinue|select Length))-replace"[^\d]"
</code></pre>

<p>It retrieves and concatenates the byte length of every file on your current drive.  Regex strips out any non-digit characters.</p>
</div>
<div id="pu55" class="pu"><h1>Haskell, score: (2<sup>2<sup>2<sup>65536</sup></sup></sup>-3)/1000000 ≈ 2↑↑7 ≈ 10↑↑4.6329710779</h1>



<pre class="lang-haskell prettyprint-override"><code>o=round$sin pi
i=succ o
q=i+i+i+i
m!n|m==o=n+i
 |n==o=(m-i)!i
 |True=(m-i)!(m!(n-i))
main=print$q!q
</code></pre>

<p>This program is exactly 100 bytes of pure Haskell code. It will print the fourth Ackermann number, eventually consuming all available energy, matter and time of the Universe and beyond in the process (thus <em>slightly</em> exceeding the soft limit of 5 seconds).</p>
</div>
<div id="pu56" class="pu"><h1>Javascript, 10↑↑↑↑210</h1>

<p>100 chars:</p>



<pre class="lang-js prettyprint-override"><code>z=~~Math.E+'';o={get f(){for(i=z;i--;)z+=i}};o.f;for(i=z;i--;)for(j=z;j--;)for(k=z;k--;)o.f;alert(z)
</code></pre>

<p>Based on the observation that maximally iterating <code>f</code> is the optimal way to go, I replaced the 13 calls to <code>f</code> with 3 levels of nested loops calling <code>f</code>, <code>z</code> times each (while <code>f</code> keeps increasing <code>z</code>).</p>

<p>I estimated the score analytically on a piece of paper—I'll type it up if anyone is interested in seeing it.</p>

<hr>

<h1>Improved Score: 10↑↑13</h1>

<p>Javascript, in exactly 100 characters, again:</p>

<pre class="lang-js prettyprint-override"><code>z=~~Math.E+'';__defineGetter__('f',function(){for(i=z;i--;)z+=i});f;f;f;f;f;f;f;f;f;f;f;f;f;alert(z)
</code></pre>

<p>This improves my original answer in three ways—</p>

<ol>
<li><p>Defining <code>z</code> on the global scope saves us from having to type <code>o.z</code> each time.</p></li>
<li><p>It's possible to define a getter on the global scope (window) and type <code>f</code> instead of <code>o.f</code>.</p></li>
<li><p>Having more iterations of <code>f</code> is worth more than starting with a larger number, so instead of <code>(Math.E+'').replace('.','')</code> (=2718281828459045, 27 chars), it's better to use <code>~~Math.E+''</code> (=2, 11 chars), and use the salvaged characters to call <code>f</code> many more times.</p></li>
</ol>

<p>Since, as analyzed further below, each iteration produces, from a number in the order of magnitude <em>M</em>, a larger number in the order of magnitude 10<sup>M</sup>, this code produces after each iteration</p>

<ol>
<li>210 &sim; O(10<sup>2</sup>)</li>
<li>O(10<sup>10<sup>2</sup></sup>) &sim; O(10↑↑2)</li>
<li>O(10<sup>10↑↑2</sup>) = O(10↑↑3)</li>
<li>O(10<sup>10↑↑3</sup>) = O(10↑↑4)</li>
<li>O(10<sup>10↑↑4</sup>) = O(10↑↑5)</li>
<li>O(10<sup>10↑↑5</sup>) = O(10↑↑6)</li>
<li>O(10<sup>10↑↑6</sup>) = O(10↑↑7)</li>
<li>O(10<sup>10↑↑7</sup>) = O(10↑↑8)</li>
<li>O(10<sup>10↑↑8</sup>) = O(10↑↑9)</li>
<li>O(10<sup>10↑↑9</sup>) = O(10↑↑10)</li>
<li>O(10<sup>10↑↑10</sup>) = O(10↑↑11)</li>
<li>O(10<sup>10↑↑11</sup>) = O(10↑↑12)</li>
<li>O(10<sup>10↑↑12</sup>) = O(10↑↑13)</li>
</ol>

<hr>

<h1>Score: &sim;10<sup>10<sup>10<sup>10<sup>10<sup>16</sup></sup></sup></sup></sup> &asymp; 10↑↑6.080669764</h1>

<p>Javascript, in exactly 100 characters:</p>

<pre class="lang-js prettyprint-override"><code>o={'z':(Math.E+'').replace('.',''),get f(){i=o.z;while(i--){o.z+=i}}};o.f;o.f;o.f;o.f;o.f;alert(o.z)
</code></pre>

<p>Each <code>o.f</code> invokes the while loop, for a total of 5 loops. After only the first iteration, the score is already over 10<sup>42381398144233621</sup>. By the second iteration, Mathematica was unable to compute even the <em>number of digits</em> in the result.</p>

<p>Here's a walkthrough of the code:</p>

<h2>Init</h2>

<p>Start with 2718281828459045 by removing the decimal point from <code>Math.E</code>.</p>

<h2>Iteration 1</h2>

<p>Concatenate the decreasing sequence of numbers,</p>

<ul>
<li>2718281828459045</li>
<li>2718281828459044</li>
<li>2718281828459043</li>
<li>...</li>
<li>3</li>
<li>2</li>
<li>1</li>
<li>0</li>
</ul>

<p>to form a new (gigantic) number,</p>

<ul>
<li>271828182845904527182818284590442718281828459043...9876543210.</li>
</ul>

<p>How many digits are in this number? Well, it's the concatenation of</p>

<ul>
<li>1718281828459046 16-digit numbers</li>
<li>900000000000000 15-digit numbers</li>
<li>90000000000000 14-digit numbers,</li>
<li>9000000000000 13-digit numbers</li>
<li>...</li>
<li>900 3-digit numbers</li>
<li>90 2-digit numbers</li>
<li>10 1-digit numbers</li>
</ul>

<p>In Mathematica,</p>

<pre class="lang-js prettyprint-override"><code>In[1]:= 1718281828459046*16+Sum[9*10^i*(i+1),{i,-1,14}]+1
Out[1]= 42381398144233626
</code></pre>

<p>In other words, it's 2.72&sdot;10<sup>42381398144233625</sup>.</p>

<p>Making my score, after only the first iteration, <strong>2.72&sdot;10<sup>42381398144233619</sup></strong>.</p>

<h2>Iteration 2</h2>

<p>But that's only the beginning. Now, repeat the steps, <em>starting with the gigantic number</em>! That is, concatenate the decreasing sequence of numbers,</p>

<ul>
<li>271828182845904527182818284590442718281828459043...9876543210</li>
<li>271828182845904527182818284590442718281828459043...9876543209</li>
<li>271828182845904527182818284590442718281828459043...9876543208</li>
<li>...</li>
<li>3</li>
<li>2</li>
<li>1</li>
<li>0</li>
</ul>

<p>So, what's my new score, Mathematica?</p>

<pre class="lang-js prettyprint-override"><code>In[2]:= 1.718281828459046*10^42381398144233624*42381398144233625 + Sum[9*10^i*(i + 1), {i, -1, 42381398144233623}] + 1

During evaluation of In[2]:= General::ovfl: Overflow occurred in computation. &gt;&gt;

During evaluation of In[2]:= General::ovfl: Overflow occurred in computation. &gt;&gt;

Out[2]= Overflow[]
</code></pre>

<h2>Iteration 3</h2>

<p>Repeat.</p>

<h2>Iteration 4</h2>

<p>Repeat.</p>

<h2>Iteration 5</h2>

<p>Repeat.</p>

<hr>

<h2>Analytical Score</h2>

<p>In the first iteration, we calculated the number of digits in the concatenation of the decreasing sequence starting at 2718281828459045, by counting the number of digits in</p>

<ul>
<li>1718281828459046 16-digit numbers</li>
<li>900000000000000 15-digit numbers</li>
<li>90000000000000 14-digit numbers,</li>
<li>9000000000000 13-digit numbers</li>
<li>...</li>
<li>900 3-digit numbers</li>
<li>90 2-digit numbers</li>
<li>10 1-digit numbers</li>
</ul>

<p>This sum can be represented by the formula,</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://i.sstatic.net/7VKrb.png" alt="enter image description here"></p>

<p>where <em>Z</em> denotes the starting number (<em>e.g.</em> 2718281828459045) and <em>O<sub>Z</sub></em> denotes its order of magnitude (<em>e.g.</em> 15, since <em>Z</em> &sim; 10<sup>15</sup>). Using <a href="http://en.wikipedia.org/wiki/List_of_mathematical_series#Low-order_polylogarithms" rel="nofollow noreferrer">equivalences for finite sums</a>, the above can be expressed explicitly as</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://i.sstatic.net/5TXDI.png" alt="enter image description here"></p>

<p>which, if we take 9 &asymp; 10, reduces even further to</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://i.sstatic.net/SOwKs.png" alt="enter image description here"></p>

<p>and, finally, expanding terms and ordering them by decreasing order of magnitude, we get</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://i.sstatic.net/mA2rx.png" alt="enter image description here"></p>

<p>Now, since we're only interested in the order of magnitude of the result, let's substitute <em>Z</em> with "a number in the order of magnitude of <em>O<sub>Z</sub></em>," <em>i.e.</em> 10<sup><em>O<sub>Z</sub></em></sup>—</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://i.sstatic.net/JUDH8.png" alt="enter image description here"></p>

<p>Finally, the 2nd and 3rd terms cancel out, and the last two terms can be dropped (their size is trivial), leaving us with</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://i.sstatic.net/BSWus.png" alt="enter image description here"></p>

<p>from which the first term wins out.</p>

<p><strong>Restated, <code>f</code> takes a number in the order of magnitude of <em>M</em> and produces a number approximately in the order of magnitude of <em>M</em>(10<sup><em>M</em></sup>).</strong></p>

<p>The first iteration can easily be checked by hand. 2718281828459045 is a number in the order of magnitude of 15—therefore <code>f</code> should produce a number in the order of magnitude of 15(10<sup>15</sup>) &sim; 10<sup>16</sup>. Indeed, the number produced is, from before, 2.72&sdot;10<sup>42381398144233625</sup>—that is, 10<sup>42381398144233625</sup> &sim; 10<sup>10<sup>16</sup></sup>.</p>

<p>Noting that <em>M</em> is not a significant factor in <em>M</em>(10<sup><em>M</em></sup>), the order of magnitude of the result of each iteration, then, follows a simple pattern of tetration:</p>

<ol>
<li>10<sup>16</sup></li>
<li>10<sup>10<sup>16</sup></sup></li>
<li>10<sup>10<sup>10<sup>16</sup></sup></sup></li>
<li>10<sup>10<sup>10<sup>10<sup>16</sup></sup></sup></sup></li>
<li>10<sup>10<sup>10<sup>10<sup>10<sup>16</sup></sup></sup></sup></sup></li>
</ol>

<hr>

<h3>LaTeX sources</h3>

<pre class="lang-js prettyprint-override"><code>(Z-10^{\mathcal{O}_Z}+1)(\mathcal{O}_Z+1)+\sum_{k=0}^{\mathcal{O}_Z-1}{(9\cdot10^k(k+1))}+1

(Z-10^{\mathcal{O}_Z}+1)(\mathcal{O}_Z+1)+\frac{10-\mathcal{O}_Z10^{\mathcal{O}_Z}+(\mathcal{O}_Z-1)10^{\mathcal{O}_Z+1}}{9}+10^{\mathcal{O}_Z}

(Z-10^{\mathcal{O}_Z}+1)(\mathcal{O}_Z+1)+\mathcal{O}_Z10^{\mathcal{O}_Z}-\mathcal{O}_Z10^{\mathcal{O}_Z-1}+1

Z\mathcal{O}_Z+Z-10^{\mathcal{O}_Z}-\mathcal{O}_Z10^{\mathcal{O}_Z-1}+\mathcal{O}_Z+2

\mathcal{O}_Z10^{\mathcal{O}_Z}+10^{\mathcal{O}_Z}-10^{\mathcal{O}_Z}-\mathcal{O}_Z10^{\mathcal{O}_Z-1}+\mathcal{O}_Z+2

\mathcal{O}_Z10^{\mathcal{O}_Z}-\mathcal{O}_Z10^{\mathcal{O}_Z-1}
</code></pre>
</div>
<div id="pu57" class="pu"><h1>C, 10^10^2485766 ≈ 10↑↑3.805871804</h1>



<pre class="lang-c prettyprint-override"><code>unsigned a['~'&lt;&lt;'\v'],l='~'&lt;&lt;'\v',i,z;main(){while(*a&lt;~z)for(i=l;printf("%u",~z),i--&amp;&amp;!++a[i];);}
</code></pre>

<p>We create an array of 258048 unsigned integers. It couldn't be unsigned longs because that made the program too long. They are unsigned because I don't want to use undefined behavior, this code is proper C (other than the lack of return from main()) and will compile and run on any normal machine, it will keep running for a long time though. This size is the biggest we can legally express without using non-ascii characters.</p>

<p>We loop through the array starting from the last element. We print the digits of <code>2^32-1</code>, increment the element and drop the loop if the element hasn't wrapped to 0. This way we'll loop <code>(2^32 - 1)^254048 = 2^8257536</code> times, printing 10 digits each time.</p>

<p>Here's example code that shows the principle in a more limited data range:</p>

<pre class="lang-c prettyprint-override"><code>#include &lt;stdio.h&gt;
unsigned int a[3],l=3,i,f;

int
main(int argc, char *argc){
        while (*a&lt;4) {
        for (i = l; i-- &amp;&amp; (a[i] = (a[i] + 1) % 5) == 0;);
            for (f = 0; f &lt; l; f++)
                printf("%lu ", a[f]);
            printf("\n");
        }
}
</code></pre>

<p>The result is roughly 10^10^2485766 divided by a million which is still roughly 10^10^2485766. </p>
</div>
<div id="pu58" class="pu"><p>No more limit on runtime? OK then.</p>

<p>Does the program need to be runnable on modern computers?</p>

<p>Both solutions using a 64-bit compile, so that <code>long</code> is a 64-bit integer.</p>

<h1>C: greater than 10<sup>(2<sup>64</sup>-1)<sup>2<sup>64</sup></sup></sup>, which is itself greater than 10<sup>10<sup>355393490465494856447</sup></sup> ≈ 10↑↑4.11820744</h1>



<pre class="lang-c prettyprint-override"><code>long z;void f(long n){long i=z;while(--i){if(n)f(n+~z);printf("%lu",~z);}}main(){f(~z);}
</code></pre>

<p>88 characters.</p>

<p>To make these formulas easier, I'll use <code>t = 2^64-1 = 18446744073709551615</code>.</p>

<p><code>main</code> will call <code>f</code> with a parameter of <code>t</code>, which will loop <code>t</code> times, each time printing the value <code>t</code>, and calling <code>f</code> with a parameter of <code>t-1</code>.</p>

<p>Total digits printed: <code>20 * t</code>. </p>

<p>Each of those calls to <code>f</code> with a parameter of <code>t-1</code> will iterate <code>t</code> times, printing the value <code>t</code>, and calling f with a parameter of <code>t-2</code>. </p>

<p>Total digits printed: <code>20 * (t + t*t)</code></p>

<p>I tried this program using the equivalent of 3-bit integers (I set <code>i = 8</code> and had main call <code>f(7)</code>). It hit the print statement 6725600 times. That works out to <code>7^8 + 7^7 + 7^6 + 7^5 + 7^4 + 7^3 + 7^2 + 7</code> Therefore, I believe that this is the final count for the full program:</p>

<p>Total digits printed: <code>20 * (t + t*t + t^3 + ... + t^(t-1) + t^t + t^(2^64))</code></p>

<p>I'm not sure how to calculate (2<sup>64</sup>-1)<sup>2<sup>64</sup></sup>. That summation is smaller than (2<sup>64</sup>)<sup>2<sup>64</sup></sup>, and I need a power of two to do this calculation. Therefore, I'll calculate (2<sup>64</sup>)<sup>2<sup>64</sup>-1</sup>. It's smaller than the real result, but since it's a power of two, I can convert it to a power of 10 for comparison with other results.</p>

<p>Does anyone know how to perform that summation, or how to convert (2<sup>64</sup>-1)<sup>2<sup>64</sup></sup> to 10<sup>n</sup>?</p>

<pre>
20 * 2^64^(2^64-1)
20 * 2^64^18446744073709551615
20 * 2^(64*18446744073709551615)
20 * 2^1180591620717411303360
10 * 2^1180591620717411303361
divide that exponent by log base 2 of 10 to switch the base of the exponent to powers of 10.
1180591620717411303361 / 3.321928094887362347870319429489390175864831393024580612054756 = 
355393490465494856446
10 * 10 ^ 355393490465494856446
10 ^ 355393490465494856447
</pre>

<p>But remember, that's the number of digits printed. The value of the integer is 10 raised to that power, so 10 ^ 10 ^ 355393490465494856447</p>

<p>This program will have a stack depth of 2^64. That's 2^72 bytes of memory just to store the loop counters. That's 4 Billion Terabytes of loop counters. Not to mention the other things that would go on the stack for 2^64 levels of recursion.</p>

<p>Edit: Corrected a pair of typos, and used a more precise value for log2(10).</p>

<p>Edit 2: Wait a second, I've got a loop that the printf is outside of. Let's fix that. Added initializing <code>i</code>.</p>

<p>Edit 3: Dang it, I screwed up the math on the previous edit. Fixed.</p>

<hr>

<p>This one will run on modern computers, though it won't finish any time soon.</p>

<h1>C: 10^10^136 ≈ 10↑↑3.329100567</h1>

<pre class="lang-c prettyprint-override"><code>#define w(q) while(++q)
long a,b,c,d,e,f,g,x;main(){w(a)w(b)w(c)w(d)w(e)w(f)w(g)printf("%lu",~x);}
</code></pre>

<p>98 Characters.</p>

<p>This will print the bitwise-inverse of zero, 2^64-1, once for each iteration. 2^64-1 is a 20 digit number.</p>

<p>Number of digits = <code>20 * (2^64-1)^7</code> = 14536774485912137805470195290264863598250876154813037507443495139872713780096227571027903270680672445638775618778303705182042800542187500</p>

<p>Rounding the program length to 100 characters, Score = printed number / 1,000,000</p>

<p>Score = 10 ^ 14536774485912137805470195290264863598250876154813037507443495139872713780096227571027903270680672445638775618778303705182042800542187494</p>
</div>
<div id="pu59" class="pu"><h1>C, score = 10<sup>10<sup>97.61735</sup></sup>/98<sup>3</sup> ≈ 10↑↑2.29874984</h1>



<pre class="lang-c prettyprint-override"><code>unsigned long a,b,c,d,e;main(){while(++a)while(++b)while(++c)while(++d)while(++e)printf("%lu",a);}
</code></pre>

<p>I appreciate the help in scoring. Any insights or corrections are appreciated. Here is my method:</p>

<p><strong>n</strong> = the concatenation of <strong>every number from 1 to 2<sup>64</sup>-1, repeated (2<sup>64</sup>-1)<sup>4</sup> times</strong>.  First, here's how I'm estimating (low) the cumulative number of digits from 1 to 2<sup>64</sup>-1 (the "subsequence"): The final number in the subsequence sequence is 2<sup>64</sup>-1 = <code>18446744073709551615</code> with 20 digits.  Thus, more than 90% of the numbers in the subsequence (those starting with <code>1</code>..<code>9</code>) have 19 digits.  Let's assume the remaining 10% average 10 digits. It will be much more than that, but this is a low estimate for easy math and no cheating. That subsequence gets repeated (2<sup>64</sup>-1)<sup>4</sup> times, so the <em>length</em> of <strong>n</strong> will be <em>at least</em> (0.9×(2<sup>64</sup>-1)×19 + 0.1×(2<sup>64</sup>-1)×10) × (2<sup>64</sup>-1)<sup>4</sup> = 3.86613 × 10<sup>97</sup> digits. In the comments below, @primo confirms the length of <strong>n</strong> to be 4.1433x10<sup>97</sup>. So <strong>n</strong> itself will be 10 to that power, or 10<sup>10<sup>97.61735</sup></sup>.</p>

<p><strong>l</strong> = 98 chars of code</p>

<p><strong>score</strong> = <strong>n/l<sup>3</sup></strong> = <strong>10<sup>10<sup>97.61735</sup></sup>/98<sup>3</sup></strong></p>

<p>Requirement: Must run on a 64-bit computer where <code>sizeof(long) == 8</code>. Mac and Linux will do it.</p>
</div>
<div id="pu60" class="pu"><h1>Javascript, more than 10^(16*2^2718281828459046) / 54^3 ≈ 10↑↑3.069506124</h1>

<pre class="lang-js prettyprint-override"><code>for(a=b=(Math.E+'').replace(&quot;.&quot;,&quot;&quot;);a--;b+=b);alert(b)
</code></pre>
<p>Description:</p>
<ul>
<li><code>(Math.E+'')</code> is <code>&quot;2.718281828459045&quot;</code></li>
<li>The dot is dropped, <code>a</code> and <code>b</code> are <code>&quot;2718281828459045&quot;</code></li>
<li>Loop executes 2718281828459045+1 = 2718281828459046 times</li>
<li>On every iteration <code>b</code> (and its length) is doubled (initial is 16 digits long)</li>
<li>Outputs value <code>2718281828459045</code> repeated 2718281828459046 times</li>
</ul>
</div>
<div id="pu61" class="pu"><h1>Lua, Unknown/99^3 ≈ 10↑↑2.945956159</h1>

<p>With infinite runtime:</p>
<pre class="lang-lua prettyprint-override"><code>m=math;p=m.pi;t=m.floor(p)s=tostring;h=t+s(p):sub(t)j=h;while(j&gt;t)do io.write(s(h):rep(h))j=j-t;end
</code></pre>
<p>&lt; 5 seconds:</p>
<pre class="lang-lua prettyprint-override"><code>m=math;p=m.pi;t=m.ceil(p)s=tostring;h=t+s(p):sub(-t)j=h;while(j&gt;t)do io.write(s(h):rep(h))j=j-t;end
</code></pre>
<p>Ungolfed:</p>
<pre class="lang-lua prettyprint-override"><code>t=math.ceil(math.pi)                -- Acquire the number 4
h=t+tostring(math.pi):sub(-t)       -- Get the last t(4) digits of pi(5898) as a string.
                                    -- Adding t auto converts it to a number and increases our number
j=h;                                -- Set j as a counter to loop
while(j&gt;t)do
    io.write(tostring(h):rep(h))    -- Add h(5902) repitions of h as a string to the output
    j=j-t;                          -- Decrement j by t(4), my only number available
end
</code></pre>
<h2>Extra</h2>
<p>Lua's lack of mathematical constants (other than pi) and ++ or -- operators made it tricky to manipulate numbers, but I thought I made good work with what I have. string.rep is the real hero.</p>
<p>If there's a notation that exists to write my score, I'll include it, but I don't know of one. If I was thinking correctly, the &lt; 5 code's number should be (5902 repeated 5902 times) repeated ~5902/4 times.</p>
</div>
<div id="pu62" class="pu"><h2>AWK, 100 bytes, Score ≈ 10^(5e80) ≈ 10↑↑2.280320629</h2>

<pre><code>func f(x){while(x-++x){printf x}}BEGIN{while(a-++a){while(b-++b){while(c-++c){while(d-++d){f(m)}}}}}
</code></pre>

<p>On most modern machines the <code>while(x-++x)</code> loop will terminate when <code>x==2^53+1</code>.
So, the function <code>f(x)</code> will print a number whose digits are every number from 1 - 2^53. Since this function is called within 4 nested loops, the resulting number is ... big? </p>

<p>To approximate, 2^53 > 9e15, so it has 16 digits. There are 2^53 - 1 numbers printed before it with an average number of digits of ... hmm, just a bit less than 16, let's call it 15. This means that <code>f(x)</code> prints a number with 15 * 2^53 digits, a bit more than 1e17 digits.  That number is concatenated with itself 9e15^4 times ~ 6e63.</p>

<p>The final number printed should have about 6e63 * 1e17 ~ 6e80 digits. Call it <code>N=10^(6e80)</code>. The score will <code>N/1e6 ~ 10^(5e80)</code>. I did some rounding down.  I'm sure this can be written in some better way.</p>
</div>
<div id="pu63" class="pu"><h1>GNU Bash, 10^40964096² / <strike></strike> 80^3 ≈ 10↑↑2.072820169</h1>
<pre><code>C=$(stat -c %s /) sh -c 'dd if=/dev/zero bs=$C$C count=$C$C|tr \\$((C-C)) $SHLVL'
</code></pre>
<p>C = 4096 on any reasonable system. SHLVL is a small positive integer (usually either 1 or 2 depending on whether /bin/sh is bash or not).</p>
<p>64 bit UNIX only:</p>
<p>Score: ~ 10^(40964096409640964096*40964096409640964096) / 88^3</p>
<pre><code>C=$(stat -c %s /) sh -c 'dd if=/dev/zero bs=$C$C$C$C$C count=$C$C$C$C$C|tr \\$((C-C)) $SHLVL'
</code></pre>
</div>
<div id="pu64" class="pu"><h1>R, 63 characters of code, 4.036242e+3699695 ≈ 10↑↑2.81744412</h1>

<pre><code>set.seed(T)
paste(rep(RS&lt;-abs(.Random.seed),RS[exp(T)]),collapse="")
# the result will be 3699696 digits long
# 624 repetitions of 4036241692704834420106146035583972223....
</code></pre>

<p>... or you can have it printing for as long as you have time:</p>

<pre><code>set.seed(T)
repeat{cat(abs(.Random.seed),sep="")}
</code></pre>
</div>
<div id="pu65" class="pu"><h1>Mathematica, 1.08544407066*10^23496 ≈ 10↑↑2.640580269</h1>
<pre><code>N[Cosh[Cosh[Cosh[Pi]]]]
</code></pre>
<p>It applies the hyperbolic cosine function to pi 3 times. If I had applied it 4 times, it would've caused an overflow error.</p>
</div>
<div id="pu66" class="pu"><h3>JavaScript - 84 Characters - Final Score: 2.082941723E+2886 ≈ 10↑↑2.390912646</h3>
<p><strong>Code:</strong></p>
<pre><code>(function n(a){b=a.length+'';a.push(b);b.length&lt;Math.PI?n(a):alert(a.join(''))})([])
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>01234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000
</code></pre>
<p>(2893 digits)</p>
<p><strong>Score:</strong></p>
<p>(Calculated using <a href="http://keisan.casio.com/calculator" rel="nofollow noreferrer">http://keisan.casio.com/calculator</a>)</p>
<pre><code>Output / 84^3 = 2.082941723E+2886
</code></pre>
</div>
<div id="pu67" class="pu"><h1>C - 92 bytes (score 1.2842113915e4373822 ≈ 10↑↑2.822224398)</h1>
<pre><code>main(){char c='~',n='z'-'A',f=c,g=c;while(--c!=n)while(--f!=n)while(--g!=n)printf(&quot;%c&quot;,n);}
</code></pre>
<p>Wrote this before I found someone already posted a C solution. Oh, well.</p>
<p>This program generates the digit '9' by subtracting the ascii value <code>'A'</code> from <code>'z'</code>, then repeatedly prints it.</p>
<p>Since the characters wrap around the container values, it actually repeats more than just the simple (126-57)^3 from the character values, it instead wraps around the character cells after subtraction, resulting in repeating the digit '9' 4373828 times. (I'm too tired right now to figure out why that particular number, but I'll edit later)</p>
</div>
<div id="pu68" class="pu"><h1>PHP, about 2.2e957136 ≈ 10↑↑2.7767719</h1>
<p>Code is 58 bytes long (not counting the <code>&lt;?</code> and <code>?&gt;</code> tags).</p>
<pre><code>&lt;?$b=&quot;FFFF&quot;;for(;$i&lt;hexdec($b);$i++,$a+=hexdec($b.$b))echo$a?&gt;
</code></pre>
<p>It outputs <a href="http://u.9999yea.rs/codegolf/large_output.html" rel="nofollow noreferrer">this</a> 957,142 digit long number, with the <em>approximate</em> value of 4.295*10<sup>957141</sup>.</p>
<p>Code in action <a href="http://u.9999yea.rs/codegolf/large.php" rel="nofollow noreferrer">here</a>.</p>
<p>Degolfed and annotated:</p>
<pre><code>&lt;?
$b=&quot;FFFF&quot;;
for(;//who needs to initalize variables? not us!
   $i&lt;hexdec($b);//loops 65,535 or 2^16 times
   $i++,//add 1 to $i per loop
   $a+=hexdec($b.$b)//add 4294967295?
)
echo$a //output $a once per loop
?&gt;
</code></pre>
</div>
<div id="pu69" class="pu"><h1>R - <strike>49</strike> 41 characters of code, 4.03624169270483442*10^5928 ≈ 10↑↑2.576681348</h1>

<pre><code>set.seed(T)
cat(abs(.Random.seed),sep="")
</code></pre>

<p>will print out [reproducing here just the start]:</p>

<pre><code>403624169270483442010614603558397222347416148937479386587122217348........
</code></pre>
</div>
<div id="pu70" class="pu"><h1>Brain-Flak, 2.1∙10<sup>410</sup>/100<sup>3</sup> = 2.1∙10<sup>404</sup> ≈ 10↑↑2.416095652</h1>

<pre><code>([(((((((((([()()()]){}){}){({}())}){({}())}){({}())}){({}())}){({}())}){({}())}){({}())}){({}())}])
</code></pre>

<h2>Explanation</h2>

<p>This program starts by pushing -12 to the stack.  It then sums up all negative integers greater than -12, and adds that to -12.  </p>

<p>This leaves -78 on the stack.</p>

<p>We repeat this process 7 times eventually yielding:</p>

<pre><code>-2141661208954069834504405072234662304505508980148465196228519451865332683714341902763764080465912011183894075658195818886405454205672965528307941907686625785344145029668197138281639933005524701487383239406350244552356749261581115208559245155799652765289804351072015722139415961385538467664379642022530440133819807784858830904851001836248026463754958811326968733498424305770502589499721608040772585539603580771
</code></pre>

<p>We negate this and output.</p>
</div>
<div id="pu71" class="pu"><h1>C</h1>

<p>Not sure if this one counts but damn does it print large numbers. </p>

<p>The reason I don't know if this one counts is this rule "You can concatenate strings: this means that any sequence of adjacent digits will be considered as a single number". I am not really concatenating, only printing many numbers. </p>

<p>No seed is intentional. </p>

<p>Ungolfed</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(){
    while(rand())
    {
        printf("%d",rand());
    }
}
</code></pre>

<p>Golfed</p>

<pre><code>#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
int main(){while(rand())printf("%d",rand()%10);}
</code></pre>

<p>90 bytes in golfed version and since output is random (no seed means not that random actually) I think that I can't really give me a score, just here for the consolation prize.</p>
</div>
<div id="pu72" class="pu"><h2>dc, 100 characters</h2>

<pre><code>[lnA A-=ilbA A-=jlaSalbB A--SbLndB A--SnSnlhxlhx]sh[LaLnLb1+sbq]si[LbLnLasbq]sjFsaFsbFFFFFFsnlhxclbp
</code></pre>

<p>Given enough time and memory, this will calculate a number around 15 ↑¹⁶⁶⁶⁶⁶⁵ 15. I had originally implemented the <a href="http://en.wikipedia.org/wiki/Hyperoperation#Definition" rel="nofollow">hyperoperation</a> function, but it required too many characters for this challenge, so I removed the <code>n = 2, b = 0</code> and <code>n &gt;= 3, b = 0</code> conditions, turning the <code>n = 1, b = 0</code> condition into <code>n &gt;= 1, b = 0</code>.</p>

<p>The only arithmetic operators used here are addition and subtraction.</p>

<p>EDIT: as promised in comments, here is a breakdown of what this code does:</p>

<pre><code>[            # start "hyperoperation" macro
lnA A-=i     # if n == 0 call macro i
lbA A-=j     # if b == 0 call macro j
laSa         # push a onto a's stack
lbB A--Sb    # push b-1 onto b's stack
LndB A--SnSn # replace the top value on n with n-1, then push n onto n's stack
lhxlhx       # call macro h twice
]sh          # store this macro in h

[            # start "increment" macro (called when n=0, the operation beneath addition)
LaLnLb       # pop a, b, and n
F+sb         # replace the top value on b with b+15
q            # return
]si          # store this macro in i

[            # start "base case" macro (called when n&gt;0 and b=0)
LbLnLa       # pop b, n, and a
sb           # replace the top value on b with a
q            # return
]sj          # store this macro in j

Fsa          # store F (15) in a
Fsb          # store F (15) in b
FFFFFFsn     # store FFFFFF "base 10" (150000+15000+1500+150+15=1666665) in n
lhx          # load and call macro h
lbp          # load and print b
</code></pre>

<p>As noted, this deviates from the hyperoperation function in that the base cases for multiplication and higher are replaced with the base case for addition. This code behaves as though <code>a*0 = a^0 = a↑0 = a↑↑0 ... = a</code>, instead of the mathematically correct <code>a*0 = 0</code> and <code>a^0 = a↑0 = a↑↑0 ... = 1</code>. As a result, it computes values that are a bit higher than they should be, but that's not a big deal since we are aiming for bigger numbers. :)</p>

<p>EDIT: I just noticed that a digit slipped into the code by accident, in the macro that performs increments for <code>n=0</code>. I've removed it by replacing it with 'F' (15), which has the side effect of scaling each increment operation by 15. I'm not sure how much this affects the final result, but it's probably a lot bigger now.</p>
</div>
<div id="pu73" class="pu"><h1>APL, 10↑↑3.4</h1>

<p>Here's my revised attempt:</p>

<pre><code>{⍞←⎕D}⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⍣n⊢n←⍎⎕D
</code></pre>

<p>100 char/byte* program, running on current hardware (uses a negligible amount of memory and regular 32-bit int variables) although it will take a very long time to complete.</p>

<p>You can actually run it on an APL interpreter and it will start printing digits. If allowed to complete, it will have printed a number with 10 × 123456789<sup>44</sup> digits.</p>

<p>Therefore the score is 10<sup>10 × 123456789<sup>44</sup></sup> / 100<sup>3</sup> ≈ 10<sup>10<sup>353</sup></sup> ≈ 10↑↑3.406161</p>

<p><strong>Explanation</strong></p>

<ul>
<li><code>⎕D</code> is a predefined constant string equal to <code>'0123456789'</code></li>
<li><code>n←⍎⎕D</code> defines <strong>n</strong> to be the number represented by that string: 123456789 (which is &lt; 2<sup>31</sup> and therefore can be used as a loop control variable)</li>
<li><code>{⍞←⎕D}</code> will print the 10 digits to standard output, without a newline</li>
<li><code>{⍞←⎕D}⍣n</code> will do it <strong>n</strong> times (<code>⍣</code> is the "power operator": it's neither *, /, nor ^, because it's not a math operation, it's a kind of loop)</li>
<li><code>{⍞←n}⍣n⍣n</code> will repeat the previous operation <strong>n</strong> times, therefore printing the 10 digits <strong>n</strong><sup>2</sup> times</li>
<li><code>{⍞←n}⍣n⍣n⍣n</code> will do it <strong>n</strong><sup>3</sup> times</li>
<li>I could fit 44 <code>⍣n</code> in there, so it prints <strong>n</strong><sup>44</sup> times the string <code>'0123456789'</code>.</li>
</ul>

<p>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯<br>
<sup>*: APL can be written in its own (legacy) single-byte charset that maps APL symbols to the upper 128 byte values. Therefore, for the purpose of scoring, a program of N chars <em>that only uses ASCII characters and APL symbols</em> can be considered to be N bytes long.</sup></p>
</div>
<div id="pu74" class="pu"><h2>GolfScript; score at least f<sub>&epsilon;_0+&omega;+1</sub>(17) / 1000</h2>

<p>Following <a href="https://codegolf.stackexchange.com/users/3440/r-e-s">r.e.s.</a>'s suggestion to use the <a href="https://codegolf.stackexchange.com/q/18912/194">Lifetime of a worm</a> answer for this question, I present two programs which vastly improve on his derivation of Howard's solution.</p>

<p>They share a common prefix, modulo the function name:</p>

<pre><code>,:z){.[]+{\):i\.z={.z+.({&lt;}+??\((\+.@&lt;i*\+}{(;}if.}do;}:g~g
</code></pre>

<p>computes <code>g(g(1)) = g(5)</code> where <code>g(x) = worm_lifetime(x, [x])</code> grows roughly as f<sub>&epsilon;<sub>0</sub></sub> (which r.e.s. notes is "the function in the <a href="https://en.wikipedia.org/wiki/Fast-growing_hierarchy#Functions_in_fast-growing_hierarchies" rel="noreferrer">fast-growing hierarchy</a> that grows at roughly the same rate as the Goodstein function").</p>

<p>The slightly easier (!) to analyse is</p>

<pre><code>,:z){.[]+{\):i\.z={.z+.({&lt;}+??\((\+.@&lt;i*\+}{(;}if.}do;}:g~g.{.{.{.{.{.{.{.{.{.{g}*}*}*}*}*}*}*}*}*}*
</code></pre>

<p><code>.{foo}*</code> maps <code>x</code> to <code>foo^x x</code>.</p>

<pre><code>,:z){[]+z\{\):i\.z={.z+.({&lt;}+??\((\+.@&lt;i*\+}{(;}if.}do;}:g~g.{g}*
</code></pre>

<p>thus gives <code>g^(g(5)) ( g(5) )</code>; the further 8 levels of iteration are similar to arrow chaining. To express in simple terms: if <code>h_0 = g</code> and <code>h_{i+1} (x) = h_i^x (x)</code> then we calculate <code>h_10 (g(5))</code>.</p>

<p>I think this second program almost certainly scores far better. This time the label assigned to function <code>g</code> is a newline (sic).</p>

<pre><code>,:z){.[]+{\):i\.z={.z+.({&lt;}+??\((\+.@&lt;i*\+}{(;}if.}do;}:
~
{.['.{
}*'n/]*zip n*~}:^~^^^^^^^^^^^^^^^^
</code></pre>

<p>This time I make better use of <code>^</code> as a different function.</p>

<pre><code>.['.{
}*'n/]*zip n*~
</code></pre>

<p>takes <code>x</code> on the stack, and leaves <code>x</code> followed by a string containing <code>x</code> copies of <code>.{</code> followed by <code>g</code> followed by <code>x</code> copies of <code>}*</code>; it then evaluates the string. Since I had a better place to burn spare characters, we start with <code>j_0 = g</code>; if <code>j_{i+1} (x) = j_i^x (x)</code> then the first evaluation of <code>^</code> computes <code>j_{g(5)} (g(5))</code> (which I'm pretty sure already beats the previous program). I then execute <code>^</code> 16 more times; so if <code>k_0 = g(5)</code> and <code>k_{i+1} = j_{k_i} (k_i)</code> then it calculates <code>k_17</code>. I'm grateful (again) to r.e.s. for estimating that <code>k_i</code> >> f<sub>&epsilon;_0+&omega;+1</sub>(i).</p>


</div>
<div id="pu75" class="pu"><p>My code is:</p>

<pre><code>x=ord('힠');s=lambda:sum(range(x))
for i in range(s()):
 for i in range(s()):x+=s();x+=s()
print(x)
</code></pre>

<p>Or a little cleaner:</p>

<pre><code>x=ord('힠')
s=lambda:sum(range(x))
for i in range(s()):
 for i in range(s()):x+=s();x+=s()
print(x)
</code></pre>

<p>It's python3.</p>

<p>Explanation:</p>

<p>sum(range(x)) is sum of 1 to x. for each x we have</p>

<pre><code>s(x) = sum(range(x)) = (x/2) * (x+1)            
</code></pre>

<p>a is a function where:</p>

<pre><code>n = 0 -&gt; a(n) = 55200
n &gt; 0 -&gt; a(n) = g(a(n-1))
</code></pre>

<p>where g(x) is:</p>

<pre><code>g(x) = v(x) + v(v(x))
</code></pre>

<p>and v(x) equeals to:</p>

<pre><code>v = x + s(x) = x + (x/2) * (x+1)
</code></pre>

<p>then g(x) becomes:</p>

<pre><code>   g = v + v + (v/2) * (v+1)
-&gt; g = (x + (x/2) * (x+1))*2
      +(x + (x/2) * (x+1)/2)
      *(x + (x/2) * (x+1)+1)
</code></pre>

<p>for a(n-1) we have:</p>

<pre><code>g = (a(n-1) + (a(n-1)/2) * (a(n-1)+1))*2
   +(a(n-1) + (a(n-1)/2) * (a(n-1)+1)/2)
   *(a(n-1) + (a(n-1)/2) * (a(n-1)+1)+1)
</code></pre>

<p>so a is:</p>

<pre><code>n = 0 -&gt; a(n) = 55200
n &gt; 0 -&gt; a(n) =  (a(n-1) + (a(n-1)/2) * (a(n-1)+1))*2
                +(a(n-1) + (a(n-1)/2) * (a(n-1)+1)/2)
                *(a(n-1) + (a(n-1)/2) * (a(n-1)+1)+1)
</code></pre>

<p>our number is:</p>

<pre><code>x = a(i)
</code></pre>

<p>where i is:</p>

<pre><code>i = a(0)*a(0)+a(0)*a(1)+...+a(0)*a(a(0))
</code></pre>

<p>There maybe errors in this calculations, I'm not a mathematician.
I Cannot calculate my score! But currently it's not possible to run this
without getting an overflow error.</p>

<p>i used 힠 character for 52200, i supposed i cannot use \U0010ffff, you can
get bigger results with \U0010ffff.</p>

<p>code is exactly 100bytes. Sorry for bad explanation, my english is not so good.</p>
</div>
<div id="pu76" class="pu"><h2>GolfScript, &nbsp; &approx; f<sub>&epsilon;<sub>0</sub></sub>(f<sub>&epsilon;<sub>0</sub></sub>(f<sub>&epsilon;<sub>0</sub></sub>(f<sub>&epsilon;<sub>0</sub></sub>(f<sub>&epsilon;<sub>0</sub></sub>(f<sub>&epsilon;<sub>0</sub></sub>(f<sub>&epsilon;<sub>0</sub></sub>(f<sub>&epsilon;<sub>0</sub></sub>(f<sub>&epsilon;<sub>0</sub></sub>(126)))))))))</h2>

<p>This is shamelessly adapted from <a href="https://codegolf.stackexchange.com/a/18914/3440">another answer</a> by @Howard, and incorporates suggestions by @Peter Taylor. </p>

<pre><code>[[[[[[[[[,:o;'~'(]{o:?~%{(.{[(]{:^o='oo',$o+o=&lt;}{\(@\+}/}{,:^}if;^?):?)*\+.}do;?}:f~]f]f]f]f]f]f]f]f
</code></pre>

<p>My understanding of GolfScript is limited, but I believe the <code>*</code> and <code>^</code> operators above are <em>not</em> the arithmetic operators forbidden by the OP.</p>

<p>(I will happily delete this if @Howard wants to submit his own version, which would doubtless be superior to this one anyway.) </p>

<p>This program computes a number that's approximately f<sub>&epsilon;<sub>0</sub></sub>(f<sub>&epsilon;<sub>0</sub></sub>(f<sub>&epsilon;<sub>0</sub></sub>(f<sub>&epsilon;<sub>0</sub></sub>(f<sub>&epsilon;<sub>0</sub></sub>(f<sub>&epsilon;<sub>0</sub></sub>(f<sub>&epsilon;<sub>0</sub></sub>(f<sub>&epsilon;<sub>0</sub></sub>(f<sub>&epsilon;<sub>0</sub></sub>(126))))))))) -- a nine-fold iteration of f<sub>&epsilon;<sub>0</sub></sub> -- where f<sub>&epsilon;<sub>0</sub></sub> is the function in the <a href="https://en.wikipedia.org/wiki/Fast-growing_hierarchy#Functions_in_fast-growing_hierarchies" rel="nofollow noreferrer">fast-growing hierarchy</a> that grows at roughly the same rate as the Goodstein function. (f<sub>&epsilon;<sub>0</sub></sub> grows so fast that the growth rates of Friedman's n(k) function and of k-fold Conway chained arrows are virtually insignificant even in comparison to just a single non-iterated f<sub>&epsilon;<sub>0</sub></sub>.) </p>
</div>
<div id="pu77" class="pu"><p>Ruby, 94 characters, <a href="https://people.math.osu.edu/friedman.8/pdf/finiteseq10_8_98.pdf" rel="nofollow">Friedman's n[26]</a></p>

<pre><code>b,e=%w[aa zz]
t=*b..e
p(b=~/$/)while t=t.product([*b&lt;&lt;?a..e&lt;&lt;?z]).reject!{|*o,n|n[/#{o*'|'}/]}
</code></pre>

<p>I suspect this to be bigger than anything currently posted; I'll try to come back later with a lower bound in Conway chain notation. This code constructs all possible trees of words using the 26-letter alphabet in which the root node is a two-letter word, each child contains one more letter than its parent, and no later node contains an earlier node as a substring. It does this via dumb brute force which means it pegs my computer trying to calculate n[2] (which should be 11). It does get n[1] right, at least, and the code looks right to me. See the linked paper for proof that this terminates. At each step it prints the size of the largest leaf (by current rules the last and largest number it prints counts as the answer).</p>
</div>
<div id="pu78" class="pu"><h2>Bash + bc</h2>

<p>NOTE: To stop once you've tried it (kills all <code>bc</code> instances):</p>

<pre><code>for p in `pgrep bc`; do kill -9 $p; done`
</code></pre>

<p>Suggestion:</p>

<p><code>echo "((($$^$$)^$$)^$$)^$$"|bc</code> and so on...</p>

<p>The <code>$$</code> operator gives us the process ID.</p>

<p>Depending on your luck you can get a very high number here.</p>

<p>When repeated 7 times (5 + 2 + 2 * 7 + 2 * 7 + 3 = 38 chars...) wolfram alpha says a process id of 5000 (that's low, PIDs get to tens of thousands easily) will give us:</p>

<p>10^(10^(10^(10^(10^(10^(10^4.267064153307629))))))</p>

<p>Adding more and more powers take 5 chars each, leaving room for <code>(100-38)/5=12</code> more, which would result in around:</p>

<p>10^(10^(10^(10^(10^(10^(10^(10^(10^(10^(10^(10^(10^(10^(10^(10^(10^(10^(10^(10^4.267064153307629)))))))))))))))))))))</p>

<p>again, for a PID of only 5000.</p>

<p>For a higher PID (still on the lows) of 10000 we'd get a much higher score, but this is in general non-deterministic.</p>

<p>Luckily for us, <code>init</code> is process with ID 1 and other kernel\internal processes are taking low PIDs when the OS starts. This means we can expect the PID to be over 5000, if not higher.</p>

<p><strong>Score: non-deterministic</strong></p>

<p><em><strong>Bonus: Score should be incrementing with attempts :D</em></strong></p>
</div>
<div id="pu79" class="pu"><h1>C, undetermined (infinite?) output length / <s>62^3</s> 67^3</h1>

<p><s></p>

<pre><code>l(){printf("%o",rand())-!!l&amp;&amp;l();}main(){srand(time(!l));l();}
</code></pre>

<p></s></p>

<pre><code>l(){for(;printf("%o",rand())-!!l;l());}main(){srand(time(!l));l();}
</code></pre>

<p>I'd written this a few days prior, but was having a hard time figuring out the expected average length of the output. The program (given enough stack and time) eventually will terminate.</p>

<p>Was going to post when I figured the output length, but since <a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18597#18597">Nate Eldridge's</a> is similar, posting it now.</p>

<p>Originally had <code>!'!'</code> instead of <code>!l</code>; borrowed that part from Nate's answer.</p>

<p>I also had a similar version without srand, at <s>42</s> 48 characters:</p>

<p><s></p>

<pre><code>main(){printf("%o",rand())-!!'!'&amp;&amp;main();}
</code></pre>

<p></s></p>

<pre><code>main(){for(;printf("%o",rand())-!!'!';main());}
</code></pre>

<p>Mine terminate (on average) earlier, compared to Nate's (<code>10/RAND_MAX</code> chance of popping up the stack instead of <code>1/RAND_MAX</code>), but output more digits per iteration (~10.43 vs 1).</p>

<p>Edit: original actually terminated after <code>RAND_MAX/20</code> iterations on average. Golfed too far.</p>

<p>Edit2: not enough rep to comment. Golfed Nate's entries below mine (64 and 44):</p>

<pre><code>w(){for(printf("%o",w);rand();w());}main(){srand(time(!w));w();}
</code></pre>

<p></p>

<pre><code>main(){for(printf("%o",'I');rand();main());}
</code></pre>
</div>
<div id="pu80" class="pu"><p><strong>C</strong></p>

<p>The file size is 45 bytes.</p>

<p>The program is:</p>

<pre><code>main(){long d='~~~~~~~~';while(--d)printf("%ld",d);}
</code></pre>

<p>And the number produced is larger than 10^(10^(10^1.305451600608433)).</p>

<p>The file I redirected std out to is currently over 16 Gb, and still growing.</p>

<p>The program would terminate in a reasonable amount of time if I had a better computer.</p>

<p>My score is uncomputable with double precision floating point.</p>
</div>
<div id="pu81" class="pu"><p><strong>Squeak Smalltalk cheat: > 2^^(2^30) / 71^3 chars</strong></p>

<pre><code>^((Float pi at:Float e)to:(Float e at:Float e))reduceRight:[:x :y|x&lt;&lt;y]
</code></pre>

<p>Little explanation:</p>

<ul>
<li>Internal bit representation of a Float can be accessed as a pair of 32 bit BigEndian words (a cheat)</li>
<li>#at: is tolerant and retries its parameter #asInteger (oh, not nice!)</li>
<li>&lt;&lt; is left shift (a perfect cheat)</li>
<li>evaluate this expression via 'print it' menu, and the resulted number is printed in base 10</li>
</ul>

<p>With characters left, I could also use significandAsInteger, but these are big enough yet. How big?</p>

<ul>
<li><code>(Float pi at:Float e)</code> -> 1413754136 > 2^31</li>
<li><code>(Float e  at:Float e)</code> -> 2333366121 > 2^31</li>
<li><code>((Float pi at:Float e)to:(Float e at:Float e)) size</code> -> 919611986>2^30</li>
</ul>

<p>The first iteration is greater than 2^31*2^(2^31) > 2^^5<br>
The second iteration is greater than 2^31*2^(2^^5) > 2^^6<br>
...<br>
The 2^30th iteration is greater than 2^^(2^30)</p>

<p>I let readers do the conversion to base 10, That kind of number gives me some vertigos...</p>

<p>Since this number is represented in memory, then converted to decimal by way of multiplications and divisions, let's say it's highly hypothetical...<br>
Anyway, the technique consisting in storing the number in memory (base 2) then print, especially in Squeak is completely disqualified...<br>
Creating a very small number is fast:<br>
<code>[1&lt;&lt;15000000] timeToRun</code> -> 4 (milliseconds)<br>
But LargeInteger package is not based on gmp and rapidly inefficient for base 10 conversion (naive * and /)<br>
Even if I install a karatsuba multiplication, it takes quite long to print on my mac mini:<br>
<code>[1&lt;&lt;15000000 printOn: NullStream new] bench</code> -> '2,700 seconds.'</p>

<p><strong>A more reasonable loop in 32-bit memory:</strong></p>

<p>What I can really execute is the first loop (let's omit the -1 on first term):</p>

<p><code>[((Float e at:Float e)&lt;&lt;(Float e at:Float e))] timeToRun</code> -> 8732 (milliseconds)</p>

<p>As said above, I can 'do it' but I can't 'print it' in reasonable time with Squeak, though I can manipulate it, like having a guess of number of decimal digits:</p>

<p><code>((((Float e at:Float e)&lt;&lt;(Float e at:Float e))  highBit - 1) * 1233 &gt;&gt; 12) + 1</code>-> 702402458, or log: 10 -> 10^(10^8.8)</p>
</div>
<div id="pu82" class="pu"><h2>Perl - score &approx; 10&uarr;&uarr;4.1</h2>

<pre><code>$_=$^Fx($]&lt;&lt;-$]),/(?&lt;R&gt;(((((((((((((((((((.(?&amp;R))*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*(??{print})/
</code></pre>

<p>Once again abusing perl's regex engine to grind through an unimaginable amount of combinations, this time using a recursive descent.</p>

<p>In the inner most of the expression, we have a bare <code>.</code> to prevent infinite recursion, and thus limiting the levels of recursion to the length of the string.</p>

<p>What we'll end up with is this:</p>

<pre><code>/((((((((((((((((((((.[ ])*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*/
   ___________________/ \_____________________________________
  /                                                           \
  (((((((((((((((((((.[ ])*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*
   ___________________/ \_____________________________________
  /                                                           \
  (((((((((((((((((((.[ ])*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*
   ___________________/ \_____________________________________
  /                    .                                      \
                       .
                       .
</code></pre>

<p>... repeated <em>671088640</em> times, for a total of <em>12750684161</em> nestings - which quite thoroughly puts my previous attempt of <em>23</em> nestings to shame. Remarkably, perl doesn't even choke on this (once again, memory usage holds steady at about 1.3GB), although it will take quite a while before the first print statement is even issued.</p>

<p>From my previous analysis below, it can be concluded that the number of digits output will be on the order of <em>(!12750684161)<sup>671088640</sup></em>, where <em>!k</em> is the <a href="http://mathworld.wolfram.com/LeftFactorial.html" rel="nofollow noreferrer">Left Factorial</a> of <em>k</em> (see <a href="http://oeis.org/A003422" rel="nofollow noreferrer">A003422</a>). We can approximate this as <em>(k-1)!</em>, which is strictly smaller, but on the same order of magnitude.</p>

<p>And if we <a href="http://www.wolframalpha.com/input/?i=10%5E12750684160%21%5E671088640" rel="nofollow noreferrer">ask wolframalpha</a>:</p>

<p><img src="https://i.sstatic.net/zvT9z.png" alt=""></p>

<p>...which barely changes my score at all. I thought for sure that'd be at least <strong>10&uarr;&uarr;5</strong>. I guess the difference between <strong>10&uarr;&uarr;4</strong> and <strong>10&uarr;&uarr;4.1</strong> is a lot bigger than you'd think.</p>

<hr>

<h2>Perl - score &approx; 10&uarr;&uarr;4</h2>

<pre><code>$_=$^Fx($]&lt;&lt;-$]),/((((((((((((((((((((((.*.*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*(??{print})/
</code></pre>

<p>Abusing the perl regex engine to do some combinatorics for us. The embedded codeblock<br>
<code>(??{print})</code> will insert its result directly into the regex. Since <code>$_</code> is composed entirely of <code>2</code>s (and the result of <code>print</code> is always <code>1</code>), this can never match, and sends perl spinning through all possible combinations, of which there's quite a few.</p>

<p><strong>Constants used</strong></p>

<ul>
<li><code>$^F</code> - the maximum system file handle, typically <code>2</code>.</li>
<li><code>$]</code> - the perl version number, similar to <code>5.016002</code>.</li>
</ul>

<p><code>$_</code> is then a string containing the digit <code>2</code> repeated <em>671088640</em> times. Memory usage is constant at about 1.3GB, output begins immediately.</p>

<p><strong>Analysis</strong></p>

<p>Let's define <em>P<sub>k</sub>(n)</em> to be the number of times the print statement is executed, where <em>k</em> is the number of nestings, and <em>n</em> is the length of the string plus one (just because I don't feel like writing <em>n+1</em> everywhere).</p>

<p><code>(.*.*)*</code><br>
<em>P<sub>2</sub>(n)</em> = [<em>2, 8, 28, 96, 328, 1120, 3824, 13056, ...</em>]</p>

<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chl=P_2%28n%29%3D%5Cfrac%7B1%7D%7B1%5Csqrt%7B2%7D%7D%28%282%2B%5Csqrt%7B2%7D%29%5En-%282-%5Csqrt%7B2%7D%29%5En%29%2B%5Cfrac%7B0%7D%7B1%7Dn" alt=""></p>

<p><code>((.*.*)*)*</code><br>
<em>P<sub>3</sub>(n)</em> = [<em>3, 18, 123, 900, 6693, 49926, 372615, 2781192, ...</em>]</p>

<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chl=P_3%28n%29%3D%5Cfrac%7B2%7D%7B2%5Csqrt%7B12%7D%7D%28%284%2B%5Csqrt%7B12%7D%29%5En-%284-%5Csqrt%7B12%7D%29%5En%29%2B%5Cfrac%7B2%7D%7B2%7Dn" alt=""></p>

<p><code>(((.*.*)*)*)*</code><br>
<em>P<sub>4</sub>(n)</em> = [<em>4, 56, 1044, 20272, 394940, 7696008, 149970676, 2922453344, ...</em>]</p>

<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chl=P_4%28n%29%3D%5Cfrac%7B4%7D%7B3%5Csqrt%7B12%7D%7D%28%2810%2B%5Csqrt%7B90%7D%29%5En-%2810-%5Csqrt%7B90%7D%29%5En%29%2B%5Cfrac%7B4%7D%7B3%7Dn" alt=""></p>

<p><code>((((.*.*)*)*)*)*</code><br>
<em>P<sub>5</sub>(n)</em> = [<em>5, 250, 16695, 1126580, 76039585, 5132387790, 346417023515, 23381856413800, ...</em>]</p>

<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chl=P_5%28n%29%3D%5Cfrac%7B40%7D%7B22%5Csqrt%7B1122%7D%7D%28%2834%2B%5Csqrt%7B1122%7D%29%5En-%2834-%5Csqrt%7B1122%7D%29%5En%29%2B%5Cfrac%7B30%7D%7B22%7Dn" alt=""></p>

<p><code>(((((.*.*)*)*)*)*)*</code><br>
<em>P<sub>6</sub>(n)</em> = [<em>6, 1452, 445698, 137050584, 42142941390, 12958920156996, ...</em>]</p>

<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chl=P_6%28n%29%3D%5Cfrac%7B240%7D%7B102%5Csqrt%7B23562%7D%7D%28%28154%2B%5Csqrt%7B23562%7D%29%5En-%28154-%5Csqrt%7B23562%7D%29%5En%29%2B%5Cfrac%7B132%7D%7B102%7Dn" alt=""></p>

<p><code>((((((.*.*)*)*)*)*)*)*</code><br>
<em>P<sub>7</sub>(n)</em> = [<em>7, 10094, 17634981, 30817120348, 53852913389555, ...</em>]</p>

<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chl=P_7%28n%29%3D%5Cfrac%7B1120%7D%7B388%5Csqrt%7B763002%7D%7D%28%28874%2B%5Csqrt%7B763002%7D%29%5En-%28874-%5Csqrt%7B763002%7D%29%5En%29%2B%5Cfrac%7B476%7D%7B388%7Dn" alt=""></p>

<p>etc. In general, the formula can be generalized as the following:</p>

<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chl=P_k%28n%29%3D%5Cfrac%7BC_k%7D%7BE_k%5Csqrt%7BB_k%7D%7D%28%28A_k%2B%5Csqrt%7BB_k%7D%29%5En-%28A_k-%5Csqrt%7BB_k%7D%29%5En%29%2B%5Cfrac%7BD_k%7D%7BE_k%7Dn" alt=""></p>

<p>where</p>

<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chl=A_k%3D%21k%3D%5Csum%5Climits_%7Bn%3D0%7D%5E%7Bk-1%7D%7Bn%21%7D" alt=""></p>

<p>That is, the <a href="http://mathworld.wolfram.com/LeftFactorial.html" rel="nofollow noreferrer">Left Factorial</a> of <em>k</em>, i.e. the sum of all factorials less than <em>k</em> (see <a href="http://oeis.org/A003422" rel="nofollow noreferrer">A003422</a>).</p>

<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chl=B_k%3DA_k%28A_k-1%29" alt=""><br>
<img src="https://chart.googleapis.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chl=C_k%3D2%5E%7Bk-2%7D%7Bk%5Cchoose+4%7D" alt=""></p>

<p>I've been unable to determine closed forms for <em>D<sub>k</sub></em> and <em>E<sub>k</sub></em>, but this doesn't matter too much, if we observe that</p>

<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chl=%5Clim_%7Bk%5Cto%5Cinfty%7D%5Cfrac%7BC_k%7D%7BE_k%7D%3D%5Cfrac%7Bk-1%7D%7B2%7D" alt=""> and <img src="https://chart.googleapis.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chl=%5Clim_%7Bk%5Cto%5Cinfty%7D%5Cfrac%7BD_k%7D%7BE_k%7D%3D1" alt=""></p>

<p>With <em>23</em> nestings, this gives us an approximate score of:</p>

<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chl=%5Cfrac%7B2%7D%7B9%7D10%5E%7B671088640%5Ccdot%2822%5Ccdot%281177652997443428940314%2B%5Csqrt%7B1386866582387492850230084014226553545478282%7D%29%5E%7B671088640%7D%2B671088641%29-6%7D" alt=""></p>

<p>This should be nearly exact, actually.</p>

<p>But to put this into a notation that's a bit easier to visualize, we can approximate the base of the inner exponent:</p>

<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chl=1177652997443428940314%2B%5Csqrt%7B1386866582387492850230084014226553545478282%7D%5Capprox+10%5E%7B21.372%7D" alt=""></p>

<p>and then the exponent itself:</p>

<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chl=%2810%5E%7B21.372%7D%29%5E%7B671088640%7D%5Capprox+10%5E%7B14342506414%7D" alt=""></p>

<p>and then <a href="http://www.wolframalpha.com/input/?i=2%2F9*10%5E%28671088640*%2822*%2810%5E14342538182%29%2B671088641%29-6%29" rel="nofollow noreferrer">ask wolframalpha</a>:</p>

<p><img src="https://i.sstatic.net/R3q2F.png" alt=""></p>

<p>which you may as well just call <strong>10&uarr;&uarr;4</strong> and be done with it.</p>
</div>
<div id="pu83" class="pu"><h1><strong>C, almost surely finite but infinite on average / 81^3</strong></h1>

<p>Assume <code>rand()</code> is a truly random number generator, and we have unlimited stack space.  </p>

<pre><code>void w(){printf("%d",!!w);while(rand()&amp;!!w)w();}int main(){srand(time(!w));w();}
</code></pre>

<p>With probability 1, every run of this program terminates in finite time and prints a finite answer.  Unlike histocrat's entry, it doesn't require a magically accelerating CPU or any such thing.</p>

<p>The expected value of the number produced is infinite.  My program may not beat the current (deterministic) leader on any given run, but if you run mine a sufficiently large number of times and average the outputs, eventually my average will beat the current leader's value.</p>

<p>Explanation: This program performs a <a href="http://en.wikipedia.org/wiki/Simple_random_walk#One-dimensional_random_walk" rel="nofollow">simple random walk</a> on the stack.  Each call to <code>w()</code> is a step down and each return from <code>w()</code> is a step up.  <a href="http://www2.math.uu.se/~sea/kurser/stokprocmn1/slumpvandring_eng.pdf" rel="nofollow">Simple random walk is null recurrent</a>, so with probability 1 we will eventually return to our starting point in a finite number of steps, but the expected number of steps required is infinite.</p>

<p>If you're willing to dispense with <code>srand</code> (you won't be able to average multiple runs, since they'll all have the same output, but the expectation of the output of a single run is still infinite) you can golf this further by having <code>main</code> call itself recursively, such as</p>

<pre><code> int main(){while(rand()&amp;!!main)printf("%d",!main());}
</code></pre>

<p>Now it's 54 characters, and I bet there is a still better way to get 1 than <code>!!main</code>.  (A useful fact: if you don't return a value from <code>main</code> it returns 0.)</p>
</div>
<div id="pu84" class="pu"><h2>PHP (a lot)/83^3</h2>

<p>Script should run for 99 seconds and produce as much <code>9</code>'s concatenated as it can.</p>

<pre><code>$n=strlen("alphabeta");ini_set('max_execution_time',intval($n.$n));while($n)echo$n;
</code></pre>
</div>
<div id="pu85" class="pu"><h2>MATLAB ???/53^3</h2>

<p>In matlab the maximum character size is defined and therefore this program will terminate eventually.</p>

<p>Basically it starts like this:</p>

<pre><code>9
(9)!
((9)!)!
(((9)!)!)!    
...
</code></pre>

<p>I have no clue how big the number is but this will be allowed to grow to a string with approximately 2^41-1 elements (on windows 64 bit). Some help in estimating the resulting number size would be appreciated.</p>

<pre><code>s=char('z'-'A')
while true
   s=['(' s ')!']
   vpa(s)
end
</code></pre>
</div>
<div id="pu86" class="pu"><h1>Python 3 - 99 chars - (most likely) significantly larger than Graham's number</h1>

<p>I've come up with a more quickly increasing function based on an extension of the Ackermann function.</p>

<pre><code>A=lambda a,b,*c:A(~-a,A(a,~-b,*c)if b else a,*c)if a else(A(b,*c)if c else-~b);A(*range(ord('~')))
</code></pre>

<p><a href="http://fora.xkcd.com/viewtopic.php?f=17&amp;t=31598">http://fora.xkcd.com/viewtopic.php?f=17&amp;t=31598</a> inspired me, but you don't need to look there to understand my number.</p>

<p>Here is the modified version of the ackermann function that I'll be using in my analysis:</p>

<pre><code>A(b)=b+1
A(0,b,...)=A(b,...)
A(a,0,...)=A(a-1,1,...)
A(a,b,...)=A(a-1,A(a,b-1,...),...)
</code></pre>

<p>My function <code>A</code> in the code above is technically not the same, but it is actually stronger, with the following statement to replace the third line of the above definition:</p>

<pre><code>A(a,0,...)=A(a-1,a,...)
</code></pre>

<p>(a has to be at least 1, so it has to be stronger)</p>

<p>But for my purposes I will assume that it is the same as the simpler one, because the analysis is already partially done for Ackermann's function, and therefore for this function when it has two arguments.</p>

<p>My function is guaranteed to eventually stop recursing because it always either: removes an argument, decrements the first argument, or keeps the same first argument and decrements the second argument.</p>

<h1>Analysis of size</h1>

<p>Graham's number, AFAIK, can be represented as <code>G(64)</code> using:</p>

<pre><code>G(n) = g^n(4)
g(n) = 3 ↑^(n) 3
</code></pre>

<p>Where a <code>↑^(n)</code> b is knuth's up-arrow notation.</p>

<p>As well:</p>

<pre><code>A(a,b) = 2 ↑^(a-2) (b+3) - 3
A(a,0) ≈ 2 ↑^(a-2) 3
g(n) ≈ A(n+2,0) // although it will be somewhat smaller due to using 2 instead of 3. Using a number larger than 0 should resolve this.
g(n) ≈ A(n+2,100) // this should be good enough for my purposes.

g(g(n)) ≈ A(A(n+2,100),100)

A(1,a+1,100) ≈ A(0,A(1,a,100),100) = A(A(1,a,100),100)

g^k(n) ≈ A(A(A(A(...(A(n+2,100)+2)...,100)+2,100)+2,100)+2,100) // where there are k instances of A(_,100)
A(1,a,100) ≈ A(A(A(A(...(A(100+2),100)...,100),100),100),100)

g^k(100) ≈ A(1,k,100)
g^k(4) &lt; A(1,k,100) // in general
g^64(4) &lt; A(1,64,100)
</code></pre>

<p>The number expressed in the program above is <code>A(0,1,2,3,4,...,123,124,125)</code>.</p>

<p>Since <code>g^64(4)</code> is Graham's number, and assuming my math is correct then it is less than <code>A(1,64,100)</code>, my number is <em>significantly</em> larger than Graham's number.</p>

<p>Please point out any mistakes in my math - although if there aren't any, this should be the largest number computed so far to answer this question.</p>
</div>
<div id="pu87" class="pu"><h1>Python 3: 98 chars, &approx; 10 &uarr;&uarr; 256</h1>

<p>Using a variable-argument function:</p>

<pre><code>E=lambda n,*C:E(*([~-n][:n]+[int("%d%d"%(k,k))for k in C]))if C else n;print(E(*range(ord('~'))))
</code></pre>

<p>Effectively, E decrements the first argument while increasing the rest of the arguments, except that instead of putting -1 in the arguments it drops the argument.
Since every cycle either decrements the first argument or decreases the number of arguments, this is guaranteed to terminate.
The increasing function used is int("%d%d"%(k,k)), which gives a result between k**2 + 2*k and 10*k**2 + k.
My code does use the * symbol - but not as multiplication. It's used to work with variable numbers of arguments, which I think should follow the rules since the clear point of the rules was to restrict specific operations, not the symbols themselves.</p>

<p>Some examples of how large E gets quickly:</p>

<pre><code>E(1,1) = 1111
E(0,1,1) = E(11,11) = (approx) 10^8191
E(1,1,1) = E(1111,1111) = (approx) 10^(10^335)
E(2,1,1) = E(11111111,11111111) = (approx) 10^(10^3344779)
</code></pre>

<p>Only the first two of those are runnable on my computer in a reasonable amount of time.</p>

<p>Then, E is invoked by <code>E(*range(ord('~')))</code> - which means:</p>

<pre><code>E(0,1,2,3,4,5, ... ,121,122,123,124,125)
</code></pre>

<p>I'm not entirely sure how large this is (I've been trying to approximate it to no avail) - but it's obvious that it's ~really~ big.</p>

<p>As an example, about twelve cycles in, the result is around: (technically a bit more than)</p>

<pre><code>E(2**27211,2**27211,2**27212,2**27212,2**27212,2**27212,2**27213,2**27213,2**54423,2**54423,2**54423,2**54423,2**54423,2**54423,2**54423,2**54423,2**54424,2**54424,2**54424,2**54424,2**54424,2**54424,2**54424,2**54424,2**54424,2**54424,2**54424,2**54424,2**54424,2**54424,2**54424,2**54424,2**54424,2**54424,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54425,2**54426,2**54426,2**54426,2**54426,2**54426,2**54426,2**54426,2**54426,2**54426,2**54426,2**54426,2**54426,2**54426,2**54426,2**54426,2**54426,2**54426,2**54426,2**54426,2**54426,2**54426,2**54426,2**54426,2**54426,2**54426,2**54426,2**54426,2**54426,2**81636,2**81636,2**81636,2**81636,2**81636,2**81636,2**81636,2**81636,2**81636,2**81636,2**81636,2**81636,2**81636,2**81636,2**81636,2**81636,2**81636,2**81636,2**81636,2**81636,2**81636,2**81636,2**81636,2**81636,2**81636,2**81636)
</code></pre>

<hr>

<h2>Result estimation:</h2>

<p>If we approximate the increasing step by <code>lambda k: 10 * k**2</code>, the function can be described as</p>

<pre><code>E(n, C₁, C₂, ... Cᵥ) ≈ E(10^(n²/2) ⋅ C₁²ⁿ, 10^(n²/2) ⋅ C₂²ⁿ, ... 10^(n²/2) ⋅ Cᵥ²ⁿ)
                     ≈ E(10^((10^(n²/2) ⋅ C₁²ⁿ)²/2) ⋅ C₂^(2n  ⋅ 10^(n²/2) ⋅ C₁²ⁿ), ... )
                     ≈ E(10^((10^n² ⋅ C₁⁴ⁿ)/2) ⋅ C₂^(2n  ⋅ 10^(n²/2) ⋅ C₁²ⁿ), ... )
</code></pre>

<p>The relevant thing we're doing here is build up a tower of powers of ten, so the eventual score can be approximated as 10 &uarr;&uarr; 256.</p>

<h2>Better (although partial) result estimation:</h2>

<p>This uses the same <code>10 * k**2</code> as the other estimation.</p>

<pre><code>E(0, b) = 10 * b**2
E(1, b) = 10 * (10 * b**2)**2 = 10 * 100 * b**4 = 10**3 * b**4
E(2, b) = 10 * (10**3 * b**4)**2 = 10 * (10**6 * b**8) = 10**7 * b**8
E(a, b) = 10**(2**(a+1)-1) * b**(2**(a+1))
</code></pre>

<p>Under the previous estimation, it would be:</p>

<pre><code>E(a, b) = 10**(a**2/a) * b**(2*a)
</code></pre>

<p>Which is significantly smaller than the actual value since it uses <code>a**2</code> instead of <code>2**a</code> for the 10 and uses <code>a*2</code> instead of <code>2**a</code> for the b.</p>
</div>
<div id="pu88" class="pu"><h2><strong>x86 machine code - 100 bytes (Assembled as MSDOS .com file)</strong></h2>

<p><em>Note: may bend the rules a little</em></p>

<p>This program will output 2<sup>(65536*8+32)</sup> nines which would put the score at
<strong>(10<sup>2<sup>524320</sup></sup>-1) / 1000000</strong></p>

<p>As a counter this program uses the entire stack (64kiB) plus two 16bit registers</p>

<p>Assembled code:</p>

<pre><code>8A3E61018CD289166101892663018ED331E4BB3A01438A2627
018827A0300130E4FEC4FEC4FEC410E4FEC400E431C95139CC
75FB31D231C931DBCD3F4175F94275F45941750839D4740D59
4174F85131C939D475F9EBDD8B266301A161018ED0C3535858
</code></pre>

<p>Assembly:</p>

<pre><code>ORG 0x100

SECTION .TEXT
            mov bh, [b_ss]
            mov dx, ss
            mov [b_ss], dx
            mov [b_sp], sp
            mov ss, bx
            xor sp, sp
            mov bx, inthackdst
            inc bx
            mov ah, [inthacksrc]
            mov [bx], ah
            mov al, [nine]
            xor ah, ah
            inc ah
            inc ah
            inc ah
inthacksrc: adc ah, ah
            inc ah
            add ah, ah
            xor cx, cx
fillstack:  push cx
nine:       cmp sp, cx
            jnz fillstack
regloop:    xor dx, dx
dxloop:     xor cx, cx
cxloop:     xor bx, bx
inthackdst: int '?'
            inc cx
            jnz cxloop
            inc dx
            jnz dxloop
            pop cx
            inc cx
            jnz restack
popmore:    cmp sp, dx
            jz end
            pop cx
            inc cx
            jz popmore
restack:    push cx
            xor cx, cx
            cmp sp, dx
            jnz restack
            jmp regloop
end:        mov sp, [b_sp]
            mov ax, [b_ss]
            mov ss, ax
            ret

b_ss:       dw 'SX'
b_sp:       db 'X'
</code></pre>
</div>
<div id="pu89" class="pu"><h2>Haskell - Ackermann function applied to its result 20 times - 99 characters</h2>

<p>This is the best haskell solution I can come up with based on the ackermann function - you may notice some similarities to n.m.'s solution, the i=round$log pi was inspired from there and the rest is coincidence :D</p>

<pre><code>i=round$log pi
n?m|m&lt;i=n+i|n&lt;i=i?(m-i)|True=(n-i)?m?(m-i)
a n=n?n
b=a.a.a.a
main=print$b$b$b$b$b$i
</code></pre>

<p>It runs the ackermann function on itself 20 times, starting at one, the sequence being</p>

<ul>
<li>1, </li>
<li>3, </li>
<li>61, </li>
<li>a(61,61), </li>
<li>a(a(61,61),a(61,61)) --- we will call this a<sub>2</sub>(61), or a<sub>4</sub>(1) ---</li>
<li>a<sub>3</sub>(61)</li>
<li>...</li>
<li>a<sub>18</sub>(61), or a<sub>20</sub>(1). I think this is approximately g<sub>18</sub> (see below).</li>
</ul>

<p>As for the estimation, wikipedia says:</p>

<p>a(m,n) = 2↑<sup>m-2</sup>(n+3) - 3</p>

<p>From this we can see a3(1) = a(61,61) = 2↑<sup>59</sup>64 + 3, which is clearly greater than g1 = 3↑<sup>4</sup>3, unless the 3 at the start is far more important than I think. After that, each level does the following (discarding the insignificant constants in a<sub>n</sub>):</p>

<ul>
<li>g<sub>n</sub> = 3↑<sup>g<sub>n-1</sub></sup>3</li>
<li>a<sub>n</sub> ~= 2↑<sup>a<sub>n-1</sub></sup>(a<sub>n-1</sub>)</li>
</ul>

<p>If these are approximately equivalent, then a<sub>20</sub>(1) ~= g<sub>18</sub>. The final term in a<sub>n</sub>, (a<sub>n-1</sub>) is far greater than 3, so it is potentially higher than g<sub>18</sub>. I'll see if I can figure out if that would boost it even a single iteration and report back.</p>
</div>
<div id="pu90" class="pu"><p>This is madness, to print the number it must be in the memory somehow, otherwise it would be considered as printing many separate numbers. I've written a <strong>JavaScript</strong> code and I've launched it in <strong>FireBug console</strong>. The largest result I've get with following code, on the quite strong workstation (8Core, 8GB RAM, haven't noted more details):</p>

<p>The code:</p>

<pre><code>var e=Math.E,s=(e+'').replace('.',''),b=parseInt(s)
try{for(var i=e;i&lt;b;i+=i)s+=s}catch(e){}
s
</code></pre>

<p>Code length: 94 characters (counted newlines as 1, you can replace them with semicolons and then it will be undoubtly 1). 94^3=830584. 
Test generated: '2718281828459045' repeated so many times, that the length of s was 1073741824 (over 1GB allocated). So the number is 2,7182*10^1073741824, and the points are:</p>

<p><strong>3,27*10^1073741817</strong></p>

<p>You can try to do that, but Firefox on my home laptop has crashed, so you need a really strong machine.</p>

<p>But many people has written the snipplets, noone has reported to be able to run! So let's remove that try.. catch and analyse what theoretically could happen:</p>

<p>The code:</p>

<pre><code>var e=Math.E,s=(e+'').replace('.',''),b=parseInt(s);for(var i=e;i&lt;b;i+=i)s+=s;s
</code></pre>

<p>Code length: 79 characters, 79^3=493039
The code will make 50 iterations generating the string of the length of 18014398509481984. Please verify if it would be able to store on 64 bit machine, but because the string is duplicated, there could be a theoretical machine able to compress such items in memory. However, I have no idea if there is enough energy in solar system to display the whole number on any console...</p>

<p>Anyway, we have number 2,7182*10^18014398509481984 divided by 79^3, so the poins are:</p>

<p><strong>5,5*10^18014398509481977</strong></p>

<p>Fill free to correct any mathematical errors, I've became a typical coding machine :D </p>
</div>
<div id="pu91" class="pu"><p><strong>bash script</strong>  </p>

<pre><code>ls -lR|sed s/[^[:digit:]]//g|tr -d '\n'
</code></pre>

<p><strong>Score: Depends on system. For my system: Approx. 10^(9031890.226806)</strong></p>

<p>Here's how I calculated the score...</p>

<p>Script length=39 (L)</p>

<p>Capturing the output number (N) to a file results in filesize of 9,031,895 bytes. The file size (9031895 bytes) is approximately equal to log10(N). (The "actual" log10(N) would be something like: 9031894.99999999####+ (or so).</p>

<p>For reference, the first 200 digits of the output is:
98964120340962720125409617201124096220358240961020119409610201124096112010240961520115240961135734096222009144096420132409626124354096202011840961623492409626200924096262009240962520092409625200954096...</p>

<p><strong>Calculating score:</strong>  </p>

<p>score=(N)/(L^3)<br>
score=10^( log10(N)-log10(39^3) )<br>
score=10^( log10(N)-log10(59319) )  </p>

<p>log10(N)=9031895<br>
log10(59319)=4.773194  </p>

<p>score=10^(9031895-4.773194)<br>
score=10^(9031890.226806)  </p>
</div>
<div id="pu92" class="pu"><h2>Windows 2000 - Windows 8 (3907172 / 23³ = 321)</h2>

<p><strong>NOTE: <em>DON'T F'ING RUN THIS!</em></strong></p>

<p>Save the following to a batch file and run it as Administrator.</p>

<pre><code>CD|Format D:/FS:FAT/V/Q
</code></pre>

<p>Output when run on a 4TB drive with the first printed number in bold.</p>

<blockquote>
  <p>Insert new disk for drive D:<br>
  and press ENTER when ready... The type of the file system is NTFS.<br>
  The new file system is FAT.<br>
  QuickFormatting <strong>3907172M</strong><br>
  The volume is too big for FAT16/12.  </p>
</blockquote>
</div>
<div id="pu93" class="pu"><h2>Ruby, probabilistically infinite, 54 characters</h2>

<pre><code>x='a'.ord
x+=x while x.times.map(&amp;:rand).uniq[x/x]
p x
</code></pre>

<p>x is initialized to 97. We then iterate the following procedure: Generate x random numbers between 0 and 1. If they are all the same, then terminate and print x. Otherwise, double x and repeat. Since Ruby's random numbers have 17 digits of precision, the odds of terminating at any step are 1 in (10e17)^x. The probability of terminating within n steps is therefore the sum for x=1 to n of (1/10e17)^(2^n), which converges to 1/10e34. This means that for any number, no matter how large, it is overwhelmingly unlikely that this program outputs a lesser number.</p>

<p>Now, of course, the philosophical question is whether a program that has less than a 1 in 10^34 chance of terminating by step n for any n can be said to ever terminate. If we assume not only infinite time and power, but that the program is given the ability to run at increasing speed at a rate that exceeds the rate at which the probability of terminating decreases, we can, I believe, in fact make the probability of terminating by <em>time t</em> arbitrarily close to 1. </p>
</div>
<div id="pu94" class="pu"><h1>C, ??? (91 characters)</h1>

<pre><code>main(int d,char**v){long c='\t'-'\b';for(;c;c++)for(d-=d;(*v)[d];d++)printf("%llu",(*v)[d]);}
</code></pre>

<p>If I could use <code>^</code>, I'd write <code>d^=d</code>, but alas.</p>

<p>Run through <code>argv[0]</code> and print its contents as an <code>unsigned long long</code>.Repeat 2<sup>long</sup>-1 times.</p>

<p>Since <code>argv[0]</code> is the program's path, I'd assume the smallest possible value printed by this program (on Windows) would be <code>A:\ .com</code> with a 32 bit <code>long</code>. I'm not so sure on that though, smaller paths are probably possible.</p>
</div>
<div id="pu95" class="pu"><h2>GolfScript, score: <em>way</em> too much</h2>

<p>OK, how big a number can we print in a few chars of GolfScript?</p>

<p>Let's start with the following code (<a href="https://codegolf.stackexchange.com/a/18050">thanks, Ben!</a>), which prints <code>126</code>:</p>

<pre><code>'~'(
</code></pre>

<p>Next, let's repeat it 126 times, giving us a number equal to about 1.26126 &times; 10<sup>377</sup>:</p>

<pre><code>'~'(.`*
</code></pre>

<p>(That's string repetition, not multiplication, so it should be OK under the rules.)</p>

<p>Now, let's repeat <em>that</em> 378-digit number a little over 10<sup>377</sup> times:</p>

<pre><code>'~'(.`*.~*
</code></pre>

<p>You'll never actually see this program finish, since it tries to compute a number with about 10<sup>380</sup> &approx; 2<sup>1140</sup> digits.  No computer ever built could store a number that big, nor could such a computer ever be built using known physics; the <a href="//en.wikipedia.org/wiki/Observable_universe#Matter_content_.E2.80.94_number_of_atoms" rel="noreferrer">number of atoms in the observable universe</a> is estimated to be about 10<sup>80</sup>, so even if we could somehow use <em>all the matter in the universe</em> to store this huge number, we'd still somehow have to cram about 10<sup>380</sup> / 10<sup>80</sup> = 10<sup>300</sup> digits into <em>each atom!</em></p>

<p>But let's assume that we have God's own GolfScript interpreter, capable of running such a calculation, and that we're still not satisfied.  OK, <em>let's do that again!</em></p>

<pre><code>'~'(.`*.~*.~*
</code></pre>

<p>The output of this program, if it could complete, would have about 10<sup>10<sup>383</sup></sup> digits, and so would equal approximately 10<sup>10<sup>10<sup>383</sup></sup></sup>.</p>

<p>But wait!  That program is getting kind of repetitive... why don't we turn it into a loop?</p>

<pre><code>'~'(.`*.{.~*}*
</code></pre>

<p>Here, the loop body gets run about 10<sup>377</sup> times, giving us a theoretical output consisting of about 10<sup>10⋰<sup>10<sup>377</sup></sup></sup> digits or so, where the tower of <a href="//en.wikipedia.org/wiki/Tetration" rel="noreferrer">iterated powers</a> of 10 is about 10<sup>377</sup> steps long.  (Actually, that's a gross underestimate, since I'm neglecting the fact that the number being repeated also gets longer every time, but relatively speaking that's a minor issue.)</p>

<p>But we're not done yet.  Let's add another loop!</p>

<pre><code>'~'(.`*.{.{.~*}*}*
</code></pre>

<p>To even properly write down an <em>approximation</em> of such numbers requires esoteric mathematical notation.  For example, in <a href="//en.wikipedia.org/wiki/Knuth%27s_up-arrow_notation" rel="noreferrer">Knuth up-arrow notation</a>, the number (theoretically) output by the program above should be about 10 &uarr;<sup>3</sup> 10<sup>377</sup>, give or take a few (or 10<sup>377</sup>) powers of ten, assuming I did the math right.</p>

<p>Numbers like this get way beyond just "incredibly huge", and into the realm of "inconceivable".  As in, not only is it impossible to count up to or to write down such numbers (we crossed beyond that point already at the third example above), but they literally have no conceivable use or existence outside abstract mathematics.  We can prove, from the <a href="//en.wikipedia.org/wiki/Foundations_of_mathematics" rel="noreferrer">axioms of mathematics</a>, that such numbers exist, just like we can prove from the GolfScript specification that program above <em>would</em> compute them, if the limits of reality and available storage space did not intervene), but there's literally <em>nothing</em> in the physical universe that we could use them to count or measure in any sense.</p>

<p>Still, mathematicians do sometimes make use of <a href="//en.wikipedia.org/wiki/Graham%27s_number" rel="noreferrer">even larger numbers</a>.  (Theoretically) computing numbers <em>that</em> large takes a little bit more work &mdash; instead of just nesting more loops one by one, we need to use recursion to telescope the <em>depth</em> of the nested loops.  Still, in principle, it should be possible to write a short GolfScript program (well under 100 bytes, I would expect) to (theoretically) compute any number expressible in, say, <a href="//en.wikipedia.org/wiki/Conway_chained_arrow_notation" rel="noreferrer">Conway chained arrow notation</a>; the details are left as an exercise. ;-)</p>
</div>
<div id="pu96" class="pu"><h1>C++ - 101 bytes</h1>
<p>This runs for exactly 5 seconds - you can't see it, but I have the ASCII character for 5 in there:</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;ctime&gt;
int main(){for(int n=time(NULL);time(NULL)&lt;n+'';)std::cout&lt;&lt;n;}
</code></pre>
<p>I wouldn't know how large the number is - large enough that my computer wouldn't be able to calculate my score.  I ran this program outputting the number into .txt file, and it produced a file of 16.585 MB.</p>
<p>Screenshot of code in text document:</p>
<p><img src="https://i.sstatic.net/1axKZ.png" alt="Image of code." /></p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/18028/">18028</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




