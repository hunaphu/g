<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::49042</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>149</td><td>Swift 5.9</td><td>240316T191211Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/271879#271879">macOSist</a></td></tr>
<tr d-ix="1"><td>021</td><td>Pip l</td><td>210622T033712Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/230256#230256">DLosc</a></td></tr>
<tr d-ix="2"><td>029</td><td>K ngn/k</td><td>210622T002440Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/230244#230244">coltim</a></td></tr>
<tr d-ix="3"><td>096</td><td>Haskell</td><td>210621T174312Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/230225#230225">Lynn</a></td></tr>
<tr d-ix="4"><td>027</td><td>Vyxal j</td><td>210621T093104Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/230180#230180">emanresu</a></td></tr>
<tr d-ix="5"><td>011</td><td>05AB1E</td><td>210126T133220Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/218033#218033">Kevin Cr</a></td></tr>
<tr d-ix="6"><td>015</td><td>Jelly</td><td>210126T101808Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/218013#218013">Unrelate</a></td></tr>
<tr d-ix="7"><td>096</td><td>C</td><td>180426T075915Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/163427#163427">Christop</a></td></tr>
<tr d-ix="8"><td>065</td><td>Retina</td><td>181125T114839Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/176522#176522">Neil</a></td></tr>
<tr d-ix="9"><td>338</td><td>BrainFlak</td><td>181124T185911Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/176503#176503">Wheat Wi</a></td></tr>
<tr d-ix="10"><td>101</td><td>VIM</td><td>180703T142137Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/167782#167782">JoshM</a></td></tr>
<tr d-ix="11"><td>013</td><td>Japt</td><td>180607T194223Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/166489#166489">Shaggy</a></td></tr>
<tr d-ix="12"><td>017</td><td>Japt Rx</td><td>180528T080357Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/165502#165502">Bubbler</a></td></tr>
<tr d-ix="13"><td>114</td><td>Haskell</td><td>180426T065654Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/163420#163420">Angs</a></td></tr>
<tr d-ix="14"><td>107</td><td>Haskell</td><td>180426T093147Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/163430#163430">Laikoni</a></td></tr>
<tr d-ix="15"><td>071</td><td>JavaScript Node.js</td><td>180426T033108Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/163417#163417">l4m2</a></td></tr>
<tr d-ix="16"><td>012</td><td>Charcoal</td><td>180426T051228Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/163418#163418">ASCII-on</a></td></tr>
<tr d-ix="17"><td>015</td><td>CJam</td><td>150701T162940Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/52487#52487">Dennis</a></td></tr>
<tr d-ix="18"><td>041</td><td>MATL</td><td>151222T235903Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/67449#67449">Luis Men</a></td></tr>
<tr d-ix="19"><td>117</td><td>C</td><td>150421T112323Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49091#49091">MarcDefi</a></td></tr>
<tr d-ix="20"><td>055</td><td>TIBASIC</td><td>150421T032104Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49078#49078">user3932</a></td></tr>
<tr d-ix="21"><td>028</td><td>J</td><td>150420T193528Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49063#49063">FUZxxl</a></td></tr>
<tr d-ix="22"><td>424</td><td>Batch</td><td>150422T021502Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49119#49119">unclemea</a></td></tr>
<tr d-ix="23"><td>335</td><td>Batch</td><td>150425T140421Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49196#49196">ankh-mor</a></td></tr>
<tr d-ix="24"><td>049</td><td>C</td><td>150422T164128Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49136#49136">CL-</a></td></tr>
<tr d-ix="25"><td>154</td><td>Haskell</td><td>150425T101843Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49191#49191">d8d0d65b</a></td></tr>
<tr d-ix="26"><td>195</td><td>C#</td><td>150425T093339Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49190#49190">Jeremy M</a></td></tr>
<tr d-ix="27"><td>nan</td><td>x86 machine code</td><td>150420T233933Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49071#49071">Matteo I</a></td></tr>
<tr d-ix="28"><td>166</td><td>Python 2</td><td>150422T155259Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49131#49131">Def</a></td></tr>
<tr d-ix="29"><td>097</td><td>Javascript/ES6</td><td>150421T020832Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49076#49076">Dendrobi</a></td></tr>
<tr d-ix="30"><td>nan</td><td>Retina + Bash</td><td>150422T010710Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49118#49118">user2272</a></td></tr>
<tr d-ix="31"><td>222</td><td>Java</td><td>150420T201241Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49065#49065">TNT</a></td></tr>
<tr d-ix="32"><td>127</td><td>R</td><td>150420T150912Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49051#49051">plannapu</a></td></tr>
<tr d-ix="33"><td>nan</td><td></td><td>150421T235325Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49115#49115">user2272</a></td></tr>
<tr d-ix="34"><td>094</td><td>Lex</td><td>150422T071643Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49126#49126">rici</a></td></tr>
<tr d-ix="35"><td>076</td><td>Perl</td><td>150421T113434Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49092#49092">alyx-bre</a></td></tr>
<tr d-ix="36"><td>196</td><td>C#</td><td>150421T084954Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49087#49087">VisualMe</a></td></tr>
<tr d-ix="37"><td>079</td><td>Perl</td><td>150421T063330Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49083#49083">Helios</a></td></tr>
<tr d-ix="38"><td>214</td><td>Java</td><td>150421T072648Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49085#49085">ArturoTe</a></td></tr>
<tr d-ix="39"><td>114</td><td>Ruby</td><td>150420T145143Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49048#49048">rorlork</a></td></tr>
<tr d-ix="40"><td>227</td><td>Haskell</td><td>150421T034743Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49079#49079">Jeremy L</a></td></tr>
<tr d-ix="41"><td>092</td><td>Python 2</td><td>150421T031754Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49077#49077">xnor</a></td></tr>
<tr d-ix="42"><td>115</td><td>Python 2</td><td>150420T153158Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49055#49055">Sp3000</a></td></tr>
<tr d-ix="43"><td>031</td><td>Pyth</td><td>150420T142906Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49046#49046">isaacg</a></td></tr>
<tr d-ix="44"><td>177</td><td>IDL 8.4</td><td>150420T235921Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49072#49072">sirperci</a></td></tr>
<tr d-ix="45"><td>053</td><td>Pip</td><td>150420T185747Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49062#49062">DLosc</a></td></tr>
<tr d-ix="46"><td>046</td><td>J</td><td>150420T175157Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49059#49059">ɐɔıʇǝɥʇu</a></td></tr>
<tr d-ix="47"><td>085</td><td>Octave</td><td>150420T225552Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49069#49069">pawel.bo</a></td></tr>
<tr d-ix="48"><td>135</td><td>GNU Bash + coreutils + indent</td><td>150420T163413Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49057#49057">Digital </a></td></tr>
<tr d-ix="49"><td>036</td><td>CJam</td><td>150420T141453Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49044#49044">Optimize</a></td></tr>
<tr d-ix="50"><td>150</td><td>C</td><td>150420T143447Z</td><td><a href="https://codegolf.stackexchange.com/questions/49042/telescopic-parentheses/49047#49047">BrainSte</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Swift 5.9, 149 bytes</h1>

<pre class="lang-swift prettyprint-override"><code>var c=0,d=[0],t={i in(i+&quot;&quot;,d=i.map{$0&lt;&quot;)&quot; ?(c,c+=1).0:(c-=1,c).1},{(0...d.max()!).map{e in.init(zip(i,d).map{$0.1==e ?$0.0:&quot; &quot;})}.joined}()(&quot;\n&quot;)).2}
</code></pre>
<p>I love it when I can shove everything into a single line of code (i.e. without using semicolons; I prefer to use newlines instead since they don't incur a byte penalty in Swift). <code>map(_:)</code> FTW! (Although, to be fair, tuple shenanigans make this relatively easy too...)</p>
<p>Here's the original, with an explanation (<a href="https://www.jdoodle.com/ia/Ysd" rel="nofollow noreferrer">and a JDoodle link</a>):</p>
<pre class="lang-swift prettyprint-override"><code>func telescope(_ input: String) -&gt; String {
    // As an example, we'll pretend that `input` is
    // this string: &quot;((()())()(()(())()))&quot;
    
    // MARK: - Depth Calculation

    var currentDepth = 0
    let depths = input.map { character in
        switch character {
        // This is essentially equivalent to `currentDepth++`,
        // if that operator still existed in Swift (remember,
        // that one returns the value *before* incrementing).
        case &quot;(&quot;: (currentDepth, currentDepth += 1).0
        
        // Likewise, this would be the same as `--currentDepth`
        // (the one that returns the value *after* decrementing).
        case &quot;)&quot;: (currentDepth -= 1, currentDepth).1
        
        // If it isn't a parenthesis, we have some invalid input.
        default: fatalError(&quot;wtf?!?! that ain't a valid string!&quot;)
        }
    }
    
    // Now, for our example, `depths` is:
    // [0, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 3, 3, 2, 2, 2, 1, 0]
    // (note that a depth of 0 is the topmost/outermost level)
    
    // Here's an alternative representation:
    // ((()())()(()(())()))
    // 01222211112223322210
    
    // MARK: - Tier Generation
    
    let depthRange = 0...depths.max()!
    let tiers = depthRange.map { depth in
        let inputWithDepths = zip(input, depths)
        let charactersOnThisTier = inputWithDepths.map { (character, otherDepth) in
            // If this character is on this tier, show it; otherwise, add a space.
            otherDepth == depth ? character : &quot; &quot;
        }
        return charactersOnThisTier
    }
    
    // MARK: - Joining
    
    let joinedTiers = tiers.map { String($0) }.joined(separator: &quot;\n&quot;)
    return joinedTiers
}
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/dloscutoff/pip" rel="nofollow noreferrer">Pip</a> <code>-l</code>, <s>23</s> <s>22</s> 21 bytes</h1>
<pre><code>ZJ:sX{%Aa?DiUi-1}._Ma
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m724ILNgWbSSbo5S7IKlpSVpuhZbo7ysiiOqVR0T7V0yQzN1DWv14n0TIXJQJbuilTQ0NEFIUxNEAylNEFcTbggA" rel="nofollow noreferrer">Attempt This Online!</a> Or, here's a 25-byte equivalent in Pip Classic: <a href="https://tio.run/##K8gs@P@/OKLaMVHVyF5XN1NbO1PXsFYv3jcxysWq@P///7o5/zU0NEFIUxNEAylNEFcTAA" rel="nofollow noreferrer" title="Pip – Try It Online">Try it online!</a></p>
<h3>Reminiscence</h3>
<p>Pip, old chap, how far we've come.</p>
<p><a href="https://codegolf.stackexchange.com/a/49062/16766">This clunky 53-byter</a> was my first Pip answer on this site, over six years ago. I'd like to leave that answer untouched as a historical artifact, so I'm posting my modern Pip solution here separately. It's pretty clear that the two are different languages anyway. The old solution doesn't even work in modern Pip (though it still does on the TIO version).</p>
<h3>Explanation</h3>
<pre class="lang-lisp prettyprint-override"><code>ZJ:sX{%Aa?DiUi-1}._Ma
                      ; s is space; i is 0; a is command-line arg (implicit)
                   Ma ; Map this function to each character in the argument:
     { Aa       }     ;   The ASCII code of the character
      %               ;   Mod 2
         ?            ;   Is that truthy (1, close paren) or falsey (0, open paren)?
          Di          ;    If truthy, decrement i and return it
            Ui        ;    If falsey, increment i
              -1      ;    and return i-1 (i.e. the previous value of i)
   sX                 ;   Make a string of that many spaces
                 ._   ;   Concatenate the parenthesis to it
ZJ:                   ; Zip the list of strings to transpose it, padding to
                      ; a rectangle using spaces
                      ; Autoprint (implicit), each sublist on its own line (-l flag)
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://codeberg.org/ngn/k" rel="nofollow noreferrer">K (ngn/k)</a>, 29 bytes</h1>
<pre><code>{+(|/i)$(-i:m-+\m-~m:2!x)$'x}
</code></pre>
<p><a href="https://ngn.bitbucket.io/k#eJxLs6rW1qjRz9RU0dDNtMrV1Y7J1a3LtTJSrNBUUa+o5eLiSlNQ0tBU4kpQMLBSUFKC8IFAEwjQRDVBohApMAtTlyZYWAOqEtkEAIy4GVY=" rel="nofollow noreferrer">Try it online!</a></p>
<ul>
<li><code>(...)$'x</code> left-pad each character of the input by the corresponding number of spaces
<ul>
<li><code>m:2!x</code> take the input string mod 2 and store in <code>m</code>; translates <code>&quot;(&quot;</code> into <code>0</code> and <code>&quot;)&quot;</code> into <code>1</code></li>
<li><code>m-~m</code> convert <code>0</code>s to <code>-1</code>s (leaving <code>1</code>s as-is)</li>
<li><code>i:m-+\</code> calculate the &quot;depth&quot; of each character, storing in <code>i</code></li>
<li><code>-i</code> negate to left-pad (positive numbers will right-pad)</li>
</ul>
</li>
<li><code>+(|/i)$</code> right-pad each string with spaces to the same length, then transpose the result</li>
</ul>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, 96 bytes</h1>

<pre class="lang-hs prettyprint-override"><code>f s=fst$span(any(&gt;' '))[do
c:d&lt;-scanr(:)[]s
max&quot; &quot;[c|sum[1|')'&lt;-d]-sum[1|'('&lt;-c:d]==i]|i&lt;-[0..]]
</code></pre>
<p><a href="https://tio.run/##LYxBCsIwEEX3PcUQCsksUnRbGk@gK5chiyGxWGxi6LSg0LvHFIQPj7d4/0n8esxzKSOwGXltOVNSlL7qIkEi2vBufB8GzZ7Sonq0jptIHwHC@p23aM@7RDno4PTfVLWaOGMmt0@Dtqeuc65EmhIYqH8AkfIN8rbe1@WaoIURhFJ4DPFgBR6KovwA" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/Lyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a> <code>j</code>, 27 bytes</h1>
<pre><code>ƛC∷&amp;-¥n꘍nC₂&amp;+;:vLG£ƛ¥↲;ÞTv∑
</code></pre>
<p><a href="http://lyxal.pythonanywhere.com?flags=j&amp;code=%C6%9BC%E2%88%B7%26-%C2%A5n%EA%98%8DnC%E2%82%82%26%2B%3B%3AvLG%C2%A3%C6%9B%C2%A5%E2%86%B2%3B%C3%9ETv%E2%88%91&amp;inputs=%27%28%28%29%28%28%29%28%29%29%28%29%28%28%28%29%29%29%29%28%28%29%29%27&amp;header=&amp;footer=" rel="nofollow noreferrer">Try it Online!</a></p>
<p>A mess that I'm proud of. Thanks to lyxal for fixing a bug.</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, <s>14</s> 11 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>2IDÇÉü+&gt;4αΛ
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f/fyNPlcPvhzsN7tO1Mzm08N/v/fw0NDU0NTSDSACMQWxPK0gCzoZJgDpAFAA" rel="nofollow noreferrer">Try it online.</a></p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>2        # Push 2
I        # Push the input-string
D        # Create a copy of the input-string,
 Ç       # and convert it to a list of codepoint integers: &quot;)&quot;→41; &quot;(&quot;→40
  É      # Check for each if it's odd: &quot;)&quot;→1; &quot;(&quot;→0
   ü     # For each overlapping pair:
    +    #  Add them together: &quot;((&quot;→0; &quot;()&quot;→1; &quot;)(&quot;→1; &quot;))&quot;→2
     &gt;   # Increase each by 1: &quot;((&quot;→1; &quot;()&quot;→2; &quot;)(&quot;→2; &quot;))&quot;→3
      4α # Take the absolute difference with 4: &quot;((&quot;→3; &quot;()&quot;→2; &quot;)(&quot;→2; &quot;))&quot;→1
Λ        # Use the Canvas builtin with the given three arguments:
         #  - Directions: the list of 123 we created, for ↗→↘ respectively
         #  - What to draw: the third remaining copy of the input-string
         #  - Line-lengths per step: the 2
</code></pre>
<p>Here a step-by-step explanation of the output for input <code>(()(()())()((())))(())</code>:</p>
<p>Preparation step: the overlapping pairs are <code>[&quot;((&quot;,&quot;()&quot;,&quot;)(&quot;,&quot;((&quot;,&quot;()&quot;,&quot;)(&quot;,&quot;()&quot;,&quot;))&quot;,&quot;)(&quot;,&quot;()&quot;,&quot;)(&quot;,&quot;((&quot;,&quot;((&quot;,&quot;()&quot;,&quot;))&quot;,&quot;))&quot;,&quot;))&quot;,&quot;)(&quot;,&quot;((&quot;,&quot;()&quot;,&quot;))&quot;]</code>, which are mapped with <code>DÇÉü+&gt;4α</code> to <code>[3,2,2,3,2,2,2,1,2,2,2,3,3,2,1,1,1,2,3,2,1]</code>, which indicate the directions <code>[↘,→,→,↘,→,→,→,↗,→,→,→,↘,↘,→,↗,↗,↗,→,↘,→,↗]</code>:</p>
<pre class="lang-python prettyprint-override"><code>7   0   1
  ↖ ↑ ↗
6 ← X → 2
  ↙ ↓ ↘
5   4   3 
</code></pre>
<p>When we use the Canvas builtin, it then draws like this:</p>
<p>Step 1: draw <code>2</code> characters (<code>((</code>) in direction <code>3</code> (<code>↘</code>):</p>
<pre class="lang-python prettyprint-override"><code>(
 (
</code></pre>
<p>Step 2: draw <code>2-1</code> characters (<code>)</code>) in direction <code>2</code> (<code>→</code>):</p>
<pre class="lang-python prettyprint-override"><code>(
 ()
</code></pre>
<p>Step 3: draw <code>2-1</code> characters (<code>(</code>) in direction <code>2</code> (<code>→</code>):</p>
<pre class="lang-python prettyprint-override"><code>(
 ()(
</code></pre>
<p>Step 4: draw <code>2-1</code> characters (<code>(</code>) in direction <code>3</code> (<code>↘</code>):</p>
<pre class="lang-python prettyprint-override"><code>(
 ()(
    (
</code></pre>
<p>Etc.</p>
<p>For an in-depth explanation of the Canvas builtin I can refer to <a href="https://codegolf.stackexchange.com/a/175520/52210">this 05AB1E tip of mine.</a></p>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 15 bytes</h1>
<pre><code>OḂ-*Ä+ƲṬ€z0ao⁶Y
</code></pre>
<p><a href="https://tio.run/##y0rNyan8/9//4Y4mXa3DLdrHNj3cueZR05oqg8T8R43bIv///6@koaEJQpqaIBpIaYK4mkoA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p>Went through <a href="https://tio.run/##y0rNyan8/99fV8vQTvtwy7FND3euedS0psogMf9R47bI////K2loaIKQpiaIBlKaIK6mEgA" rel="nofollow noreferrer">quite</a> <a href="https://tio.run/##y0rNyan8/19X63CL9sMdTVz@h9sf7lzzqGlNlUFi/qPGbZH///9X0tDQBCFNTRANpDRBXE0lAA" rel="nofollow noreferrer">a</a> <a href="https://tio.run/##y0rNyan8/99fV@twi7b/wx1NKg93rnnUtKbKIDH/UeO2yP///ytpaGiCkKYmiAZSmiCuphIA" rel="nofollow noreferrer">few</a> 16-byters before arriving at this...</p>
<pre><code>O                  Codepoints
 Ḃ                 mod 2. ('(' -&gt; 0, ')' -&gt; 1)
    Ä              Cumulative sums of
  -*               -1 to the power of each,
     +Ʋ            plus the corresponding original residues.
       Ṭ€          For each, an array with 1 at that index and 0 elsewhere.
         z0        Zip filling with zeroes,
           a       replace ones with corresponding elements of the input string,
            o⁶     replace zeroes with spaces,
              Y    join on newlines.
</code></pre>
</div>
<div id="pu7" class="pu"><h1>C, <s>94</s> <s>99</s> <s>97</s> 96</h1>

<pre><code>i,j,k,l;f(char*s){for(l=0;!i--;l-=puts(""))for(j=0;k=s[j++];putchar((k&amp;1?--l:l++)?32:k))i&amp;=l&lt;2;}
</code></pre>

<p>Pure C version that doesn't use the consoles escape codes. Ungolfed:</p>

<pre><code>i,j,k,l;                 // stop,iterator,current char,level
f(char*s){
  for(l=0;               // reset level
      !i--;              // stop ? return : stop = 1;
      l-=puts(""))      // new line + next level
    for(j=0;
        k=s[j++];        // for each char
        putchar(
          (k&amp;1?--l:l++)  // char == 41 ? prev level : next level
          ?32:k))        // only print brackets at level 0
      i&amp;=l&lt;2;            // if level &gt; 1 then don't stop
}
</code></pre>

<p><a href="https://tio.run/##jY7BDoIwEETvfkXlQHaFJoKeqIQPEQ@kES2tSCieCN@OLcWD6IE9befNbIfTG@fjKMIqlKFiJfB70e409uWzBZXu2VZQyhRNm1enwfMQLagMkKk@V0FwYYbYEID0o4xSlaggwOwQJxJR@Kk6xWwYRd2RRyFqwH5DSNOadwkeL/SVRElu5LzOaw@ZgUYHdOvH59AyGNugGTTzHZ/FNUcO0@/W70LTtmyzxGsOH107nAIw3/jT9Mdg4TC@AQ" rel="nofollow noreferrer" title="C (gcc) – Try It Online">Try it online!</a></p>

<p>Changelog:</p>

<ul>
<li><em>+5 Byte</em> Temporary fix to match rules</li>
<li><em>-2 Byte</em> Switch <code>!i++</code> to <code>!i--</code> drops the need to reset <code>i</code></li>
<li><em>-1 Byte</em> Switch <code>puts(""),--l</code> to <code>l-=puts("")</code> Thanks to @ceilingcat</li>
</ul>
</div>
<div id="pu8" class="pu"><h1><a href="https://github.com/m-ender/retina/wiki/The-Language" rel="nofollow noreferrer">Retina</a>, 65 bytes</h1>

<pre><code>./\S/{*\`\(((?&lt;-2&gt;(\()*\))*)\)
($.1* )
\(((?&lt;-2&gt;(\()*\))*)\)
 $1 
</code></pre>

<p><a href="https://tio.run/##K0otycxLNPyvquGe8F9PPyZYv1orJiFGQ0PD3kbXyE4jRkNTK0ZTU0szRpNLQ0XPUEtBkwu7rIKKocL//xpAZUCgCQRcGpogBoQHZoHlNMEsDagkUAoA" rel="nofollow noreferrer" title="Retina – Try It Online">Try it online!</a> Note: Trailing space. Link includes test cases. Explanation:</p>

<pre><code>.
</code></pre>

<p>Don't print the spaces left over at the end.</p>

<pre><code>/\S/{
</code></pre>

<p>Repeat until there are only spaces left.</p>

<pre><code>*\`
</code></pre>

<p>Print the result of this substitution without changing the current value.</p>

<pre><code>\(((?&lt;-2&gt;(\()*\))*)\)
($.1* )
</code></pre>

<p>Match pairs of balanced parentheses and replace their content with a run of spaces of the same length.</p>

<pre><code>\(((?&lt;-2&gt;(\()*\))*)\)
 $1 
</code></pre>

<p>Match balanced parentheses and replace the outer pairs with spaces.</p>

<p>For <a href="https://github.com/m-ender/retina/wiki/The-Language/a950ad7d925ec9316e3e2fb2cf5d49fd15d23e3d" rel="nofollow noreferrer">Retina 0.8.2</a> you have the choice of this 60 byte code:</p>

<pre><code>{*`\(((?&lt;-2&gt;(\()*\))*)\)
($.1$* )
\(((?&lt;-2&gt;(\()*\))*)\)
 $1 
</code></pre>

<p><a href="https://tio.run/##K0otycxL/K@q4Z7wv1orIUZDQ8PeRtfITiNGQ1MrRlNTSzNGk0tDRc9QRUtBkwu7tIKKocL//xpAdUCgCQRcGpogBoQHZoHlNMEsDagkUAoA" rel="nofollow noreferrer" title="Retina 0.8.2 – Try It Online">Try it online!</a> Note: Trailing space. Link includes test cases. Explanation: The differences are as follows:</p>

<ul>
<li>Retina 0.8.2 doesn't have a while loop, only a convergence loop. However, this ends up printing blank lines while waiting for the loop to converge.</li>
<li>Retina 0.8.2 uses <code>*</code> for much the same effect as <code>.*\</code>.</li>
<li>Retina 0.8.2 uses <code>$*</code> instead of <code>*</code> in the replacement.</li>
</ul>

<p>Alternatively, if the blank lines are a problem, you can use this 92 byte code:</p>

<pre><code>{`.+$
$&amp;¶$&amp;
\(((?&lt;-2&gt;(\()*\))*)\)(?=.*¶.*$)
($.1$* )
\(((?&lt;-2&gt;(\()*\))*)\)(?=.*$)
 $1&#32;
¶ +$

</code></pre>

<p><a href="https://tio.run/##fYwxDsIwEAT7e4WLw9o9FEumBlLyCRehSJEmBaLjX36AP2YOQ81Wc5rde6zPbb/3A25Lfy3pqKKxVY1SAMzn6XRFAa2QxkLMl2StJlMKNGW1wD9NbwXNQVoN/rh3@MpDj4Af@F6DhuMg/KSrNw" rel="nofollow noreferrer" title="Retina 0.8.2 – Try It Online">Try it online!</a> Link includes test cases. Explanation:</p>

<pre><code>{`
</code></pre>

<p>Repeat until the value converges.</p>

<pre><code>.+$
$&amp;¶$&amp;
</code></pre>

<p>Duplicate the last line.</p>

<pre><code>\(((?&lt;-2&gt;(\()*\))*)\)(?=.*¶.*$)
($.1$* )
</code></pre>

<p>Match pairs of balanced parentheses on what used to be the last line and replace their content with a run of spaces of the same length.</p>

<pre><code>\(((?&lt;-2&gt;(\()*\))*)\)(?=.*$)
 $1 
</code></pre>

<p>Match pairs of balanced parentheses on the last line and replace the outer pairs with spaces.</p>

<pre><code>¶ +$

</code></pre>

<p>Delete the last line if it's only spaces. This allows the loop to terminate.</p>
</div>
<div id="pu9" class="pu"><h1><a href="https://github.com/Flakheads/BrainHack" rel="nofollow noreferrer">Brain-Flak</a>, 338 bytes</h1>

<pre><code>([]){(({})[()]&lt;([{}][])([][()]){({}[()]&lt;(({}&lt;(({})(())){({}[()]&lt;([{}]())&gt;)}&gt;{})&lt;({}{})((){[()](&lt;{}&lt;&gt;((((()()()()){}){}){})&lt;&gt;&gt;)}{}){{}(({})&lt;&gt;)(&lt;&gt;)}{}(({})(())){({}[()]&lt;([{}])&gt;)}{}&gt;{}&lt;({}&lt;(([])&lt;{{}({}&lt;&gt;)&lt;&gt;([])}{}&lt;&gt;&gt;)&lt;&gt;&gt;)&lt;&gt;{({}[()]&lt;({}&lt;&gt;)&lt;&gt;&gt;)}{}&lt;&gt;&gt;)&gt;)}{}{}&lt;&gt;((()()()()()){})&lt;&gt;&gt;)}{}{{}}&lt;&gt;{{}{}(({})[((((()()()){}())){}{}){}]())}{}{({}&lt;&gt;)&lt;&gt;}&lt;&gt;
</code></pre>

<p><a href="https://tio.run/##dU85DgMhDPzLVp4iP7As5R2IYpMmUaQt0lq8nYwNaLcJl8wceHh89/fx2p@f3qVUuIg3FEFVKd4qIcJxJ@VtECzygAhwwcNAxNCMpBIfGg9alC6TGBgTZMdSoydKb/muGkQT@tcGyVoEyTDMqeGOHrTHvUVtGPt0T4UtPosZDddoU8NXSbqvMOX8AlWZLKPn10O/OvDsvW9THELurd/uPw" rel="nofollow noreferrer" title="Brain-Flak (BrainHack) – Try It Online">Try it online!</a></p>

<h2>Idea</h2>

<p>The idea for this program is that we make a number of passes over the string.  Each time we make a pass we keep track of a counter, we decrement the counter if we encounter a <code>(</code> and increment it if we encounter a <code>)</code>.  If <code>(</code> brings it to -1 we copy it to the offstack and if <code>)</code> brings it to zero we copy it to the offstack.  Otherwise we just copy a space.  We do this as many times as the length of the string starting the counter at 0 the first time and decreasing it each loop.  This way we catch the different layers in order.  When we are done we just trim characters until we reach a <code>)</code>.</p>
</div>
<div id="pu10" class="pu"><h1>VIM, 101 bytes</h1>

<p><code>↵</code> = Enter</p>

<pre><code>qwlmto&lt;esc&gt;`t@wq@w:s/()/(*)/g↵:set ve=all↵:set nows:↵set nosol↵qqvi)ygvr jPk/(↵@qq@qjjdGqeGl?*↵&lt;C-V&gt;ggoGr|@eq@e:%s/|//↵
</code></pre>
</div>
<div id="pu11" class="pu"><h1>Japt, 13 bytes</h1>
<pre><code>y_ùZ&lt;')?°T:T´
</code></pre>
<p><a href="https://ethproductions.github.io/japt/?v=2.0a0&amp;code=eV/5WjwnKT+wVDpUtA==&amp;input=IigoKCkoKSkoKSgoKSgoKSkoKSkpIg==" rel="nofollow noreferrer">Try it</a></p>
<hr />
<h2>Explanation</h2>
<pre><code>y_                :Transpose, pass each column Z through a function and transpose back
   Z&lt;')           :  Is Z less than &quot;)&quot;, i.e., is Z equal to &quot;(&quot;?
       ?          :  If so
        °T        :   Prefix increment variable T (initially 0)
          :       :  Else
           T´     :   Postfix decrement T
  ù               :  Left pad Z with spaces to length T
</code></pre>
</div>
<div id="pu12" class="pu"><h1><a href="https://github.com/ETHproductions/japt" rel="nofollow noreferrer">Japt</a> <code>-Rx</code>, 17 bytes</h1>

<pre><code>¬£®¥'(?Y´:°Y ?S:Z
</code></pre>

<p><a href="https://ethproductions.github.io/japt/?v=2.0a0&amp;code=rKOupScoP1m0OrBZID9TOlo=&amp;input=LVJ4CiIoKSgoKSkoKCgpKSkoKCkpKCki" rel="nofollow noreferrer">Try it online!</a></p>

<h3>Unpacked &amp; How it works</h3>

<pre><code>Uq mXYZ{UmZ{Z=='(?Y--:++Y ?S:Z

Uq      Convert the input string into array of chars
mXYZ{   Map with the function...
          Here, Y (index) is used as the desired level of "telescoping"
UmZ{      Map on the original input string with the function...
Z=='(?      If this char is "("...
Y--:          Decrement Y
++Y           Otherwise, increment Y
?           If Y is nonzero (i.e. this char is *not* at desired level)...
S:            Replace with a space
Z             Otherwise, use the char as-is

Flags:
-R      Join the resulting array with newline
-x      Trim the resulting string on both ends
</code></pre>

<p>Ported from <a href="https://codegolf.stackexchange.com/a/163417/78410">@l4m2's JS solution</a>. It actually fits into Japt's built-ins quite nicely, and trailing whitespaces can be conveniently removed with the use of <code>-x</code> flag.</p>
</div>
<div id="pu13" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, <s>117</s> 114 bytes</h1>



<pre class="lang-hs prettyprint-override"><code>f(y:b)|a&lt;-sum[1|y=='(']=a:map(+(2*a-1))(f b)
f[]=[]
p s=[[last$' ':[a|b==i]|(b,a)&lt;-zip(f s)s]|i&lt;-[1..maximum$f s]]
</code></pre>

<p><a href="https://tio.run/##HY1BCsIwEEX3PcUghcyoKdRl6ZzCZchiAi0GmxJMA1Zy91iFv3g8HvyHpOe0LLXOuA@Oiow65WD6sjMrVJZlCBLxgrez6J4IZ3DUzMaysU2ExMYskrZWgRqMFMfsbUF3FRr1x8cjT5Rs8aM2fdcFefuQQ3tYa2sQvwIDxrzdt1eX18WvUyJoIcIJEQmPP8L/fkyn@gU" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
</div>
<div id="pu14" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, 107 bytes</h1>



<pre class="lang-hs prettyprint-override"><code>h#('(':s)=h:(h+1)#s
h#(_:s)|k&lt;-h-1=k:k#s
_#_=[]
g s=[do(c,i)&lt;-zip s$0#s;max" "[c|i==h]|h&lt;-[0..maximum$0#s]]
</code></pre>

<p><a href="https://tio.run/##FcpBCoMwEIXhfU8xGMEJbUS31jlJCBKsmCEmLY1CKd49TeH9m4/nbPLLtuXsBDbYDEmSG9BdeynSpdhU5PSjcqonP/iCk5hIm8sKifTjifON5ai@/IJUdyLdg/1UUOn5ZCJnTjcq3bVtUQ5H@D@MycFyBAKO@/K28w41HHHjuCRoYc2IKMukLP0A" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>

<p>Based on <a href="https://codegolf.stackexchange.com/a/49191/56433">d8d0d65b3f7cf42's Haskell answer</a>.</p>
</div>
<div id="pu15" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 71 bytes</h1>



<pre class="lang-javascript prettyprint-override"><code>x=&gt;[...x].map((_,n,s)=&gt;s.map(c=&gt;(c=='('?n--:++n)?' ':c).join``).join`
`
</code></pre>

<p><a href="https://tio.run/##LYdBCoNADEX3PUV3SdDJASwZd16iFGeYSlFsIk4p3n60Unif998UvzGndVw@Tu05lE7KJv7OzNuD33FB7GutM4nPZybxxwQQWnWuqSqlFq7QJOLJRg3h70sot2SabR54thd2CIhISAd48vsERGUH" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>

<h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 85 bytes, just enough lines</h1>



<pre class="lang-javascript prettyprint-override"><code>x=&gt;[...x].map((_,n,s)=&gt;(Q=s.map(c=&gt;(c=='('?n--:++n)?' ':c).join``)&lt;1?'':Q+`
`).join``
</code></pre>

<p><a href="https://tio.run/##NcixCsIwEIDh3adwuzvSHrhGr9m6dxYxIRZpqZfSiPTtYy0I//Dxj@ETclyG@V1revSllbJKc2Xm9cavMCPeK60ySYOd5P3EzVEEEJzWtTVGycERbCQe06De0@XkAGxn/MH/XznHpDlNPU/piS0CIhLSFu79TEBUvg" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
</div>
<div id="pu16" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 12 bytes</h1>

<pre><code>ＦＳ¿⁼(ι↘(«Ｍ↑)
</code></pre>

<p><a href="https://tio.run/##TU27DoMwDJzJV1hMtgQ/QNd26FCpatUPQIhHJEQoBDpU/fY0dgLiFp/vzueqK6fKlL1zjZkAr8O42Ked9NAikUp0A3h5L2U/Y4ppBprF5O59i8XZfIaHbjubgTfppJK6n2v4@sTNrDUWr5HFGE9JIj/nkFy@9i7XDj3Iw0tMwiaM2CNhGE3O5YavEQSkQBiBAmYETAD9BG70SvCF0eaFpKQURMgm2MqP2B8h7W54SuEwPqND47H2Dw" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a></p>

<h3>Explanation</h3>

<pre><code>ＦＳ             For each character in next input as string
    ¿⁼(ι         If character is "("
        ↘(       Print "(" down and to the right - this is equivalent to printing "(" and moving down
          «Ｍ↑)  Else move up and print ")"
</code></pre>
</div>
<div id="pu17" class="pu"><h1>CJam, <s>17</s> <s>16</s> 15 bytes</h1>

<pre><code>0000000: 72 3a 69 22 28 0b 20 9b 41 29 22 53 2f 66 3d     r:i"(. .A)"S/f=
</code></pre>

<p>The above is a reversible xxd dump, since the source code contains the unprintable characters VT (0x0b) and CSI (0x9b).</p>

<p>Like <a href="https://codegolf.stackexchange.com/a/49118">this answer</a>, it uses <a href="https://en.wikipedia.org/wiki/ANSI_escape_code" rel="noreferrer">ANSI escape sequences</a>, but it also uses vertical tabs and it prints the control characters directly to avoid using <strong>printf</strong>.</p>

<p>This requires a supporting video text terminal, which includes most non-Windows terminal emulators.</p>

<h3>Test run</h3>

<p>We have to set the shell variable <em>LANG</em> and the terminal emulator's encoding to ISO 8859-1. The former is achieved by executing</p>

<pre><code>$ LANGsave="$LANG"
$ LANG=en_US
</code></pre>

<p>Also, before executing the actual code, we'll disable the prompt and clear the screen.</p>

<pre><code>$ PS1save="$PS1"
$ unset PS1
$ clear
</code></pre>

<p>This makes sure the output is shown properly.</p>

<pre><code>echo -n '()(())((()))(())()' | cjam &lt;(base64 -d &lt;&lt;&lt; cjppIigLIJtBKSJTL2Y9)
()(  )(    )(  )()
   ()  (  )  ()
        ()
</code></pre>

<p>To restore <em>LANG</em> and the prompt, execute this:</p>

<pre><code>$ LANG="$LANGsave"
$ PS1="$PS1save"
</code></pre>

<h3>How it works</h3>

<p>We insert a vertical tab after each <strong>(</strong> to move the cursor down and the byte sequence <strong>9b 41</strong> (<code>"\x9bA"</code>) before each <strong>)</strong> to move the cursor up.</p>

<pre><code>r         e# Read a whitespace-separated token from STDIN.
:i        e# Replace each character by its code point.
          e#   '(' -&gt; 40, ')' -&gt; 41
"(. .A)"  e# Push the string "(\v \x9bA)".
S/        e# Split at spaces into ["(\v" "\x9bA)"].
f=        e# Select the corresponding chunks.
          e# Since arrays wrap around in CJam, ["(\v" "\x9bA)"]40= and 
          e# ["(\v" "\x9bA)"]41= select the first and second chunk, respectively.
</code></pre>
</div>
<div id="pu18" class="pu"><h1>MATL, <s>42</s> 41 bytes</h1>

<p>Uses <a href="https://github.com/lmendo/MATL/releases" rel="nofollow">current version (4.0.0)</a> of the <a href="https://esolangs.org/wiki/MATL" rel="nofollow">language</a>, which is <em>newer</em> than this challenge (but the challenge was so attractive...)</p>

<pre><code>j32-t8=2*1-TTo3X53$X+ZSYsP0hP1+wtn:wZ?32+c
</code></pre>

<p><em>EDIT (May 20, 2016): <a href="http://matl.tryitonline.net/#code=ajMyLXQ4PTIqMS1UVG8zWDUzJFkrWlNZc1AwaFAxK3d0bjp3Wj8zMitj&amp;input=KCkoKCkpKCgoKSkpKCgpKSgp" rel="nofollow">Try it online!</a> with <code>X+</code> replaced by <code>Y+</code>, according to version 18.0.0 of the language.</em></p>

<h3>Example</h3>

<pre><code>&gt;&gt; matl j32-t8=2*1-TTo3X53$X+ZSYs0wh1+wtn:wZ?32+c
&gt; ()(())((()))(())()
()(  )(    )(  )()
   ()  (  )  ()   
        ()      
</code></pre>

<h3>Explanation</h3>

<p>The general idea is to use <a href="https://en.wikipedia.org/wiki/Convolution" rel="nofollow">convolution</a> to analyze pairs of consecutive symbols. There are four possible pairs:</p>

<ul>
<li><code>((</code>: the second symbol should be on a lower line than the first</li>
<li><code>))</code>: the second symbol should be on a higher line than the first</li>
<li><code>()</code> or <code>)(</code>: the second symbol should be on the same line as the first</li>
</ul>

<p>When analyzing each pair, the line of the first symbol is already known, and the analysis tells the line of the second. Then the nex pair is analyzed, obtained by advancing one symbol, that is, with overlapping.</p>

<pre><code>j           % input string                                     
32          % ASCII code of space character
-           % subtraction. Will give 8 or 9 for '(' and ')'
t8=         % 1 for '(' symbols, 0 for ')'
2*1-        % convert into 1 / -1
TTo         % array [1 1] (for convolution)
3X5         % 'valid' flag for convolution
3$          % specify three inputs for convolution
X+          % convolution                                      
ZS          % sign function            
Ys          % cumulative sum                                   
0wh         % prepend a 0
1+          % add 1. This gives line number of each symbol
wtn:w       % Vector [1 2 ... n] where n is string length. Rearrange
Z?          % create (sparse) matrix with three inputs: row, col, val
32+c        % add space code and convert to chat
</code></pre>
</div>
<div id="pu19" class="pu"><h1>C, <strike>118</strike> 117 Bytes</h1>

<p>Another answer in C, but mine is shorter.</p>

<pre><code>c;d;main(m,v)int**v;{while(d++&lt;m){char*p=v[1];while(*p)c+=*p==40,putchar(c-d?*p:32),m=c&gt;m?c:m,c-=*p++==41;puts("");}}
</code></pre>

<p>Ungolfed version:</p>

<pre><code>c; /* current depth */
d; /* depth to print in current row */
main(m,v)int**v;{
    while(d++&lt;m) {
        char*p=v[1];
        while(*p){
            c+=*p==40;           /* 40 = '(' */
            putchar(c-d?*p:32); /* 32 = ' ' (space) */
            m=c&gt;m?c:m;           /* search maximum depth */
            c-=*p++==41;         /* 41 = ')' */
        }
        puts("");
    }
}
</code></pre>

<p>And it works!</p>

<pre><code>% ./telescope '()(())((()))(())()'
()(  )(    )(  )()
   ()  (  )  ()
        ()
% ./telescope '((()())()(()(())()))'
(                  )
 (    )()(        )
  ()()    ()(  )()
             ()
</code></pre>
</div>
<div id="pu20" class="pu"><h1>TI-BASIC, <s>69 60 56</s> 55 bytes</h1>

<p>This is for the TI-83+/84+ family of calculators, although it was written on an 84+ C Silver Edition.</p>

<p>The program shows up as larger on-calc due to VAT+size info being included. Also, there are more than 56 characters here; the reason it's 56 bytes is because all commands that are more than one character are compressed down to tokens that are either one or two bytes in size.</p>

<pre><code>Input Str1
1→B
For(A,1,length(Str1
sub(Str1,A,1→Str2
Ans="(
Output(B+Ans,A,Str2
B-1+2Ans→B
End
</code></pre>

<p>Shaved off another byte thanks to <a href="http://stackexchange.com/users/5456847/thomas-kwa">thomas-kwa</a>! (also from him was the jump from 60 to 56.)</p>
</div>
<div id="pu21" class="pu"><h2>J, <s>32</s> 28 bytes</h2>

<p>This was a fun one.</p>

<pre><code>0|:')(('&amp;(i.-&lt;:@+/\@i:){."0]
</code></pre>

<h3>Explanation</h3>

<p>This is how this solution works, including an explanation of how it has been golfed.</p>

<pre><code>   NB. Let a be a test case
   a =. '((()())()(()(())()))'

   NB. level alterations
   _1 + ').(' i. a
1 1 1 _1 1 _1 _1 1 _1 1 1 _1 1 1 _1 _1 1 _1 _1 _1

   NB. absolute levels
   +/\ _1 + ').(' i. a
1 2 3 2 3 2 1 2 1 2 3 2 3 4 3 2 3 2 1 0

   NB. adjusted levels
   (+/\ _1 + ').(' i. a) - ')(' i. a
0 1 2 2 2 2 1 1 1 1 2 2 2 3 3 2 2 2 1 0

   NB. take level from end of each item of a and transpose
   |: a {."0~ _1 - (+/\ _1 + ').(' i. a) - ')(' i. a
(                  )
 (    )()(        ) 
  ()()    ()(  )()  
             ()     

   NB. code as a tacit verb
   [: |: ] {."0~ _1 - ([: +/\ _1 + ').(' i. ]) - ')(' i. ]

   NB. subtractions pulled into the prefix insert
   [: |: ] {."0~ (')(' i. ]) - [: &lt;:@+/\ ').(' i. ]

   NB. i: instead of i. so we can use the same string constant
   [: |: ] {."0~ (')((' i. ]) - [: &lt;:@+/\ ')((' i: ]

   NB. get rid of the caps
   0 |: ] {."0~ (')((' i. ]) - ')((' &lt;:@+/\@i: ]

   NB. join the two usages of ')((' into a single dyadic phrase
   0 |: ] {."0~ ')((' (i. - &lt;:@+/\@i:) ]

   NB. bond ')((' and flip arguments to {."0
   0 |: ')(('&amp;(i. - &lt;:@+/\@i:) {."0 ]
</code></pre>
</div>
<div id="pu22" class="pu"><h1>Batch, 424 bytes</h1>
<pre><code>@echo off
setLocal enableDelayedExpansion
set s=%1
set a=1
:c
if defined s (set/ac+=1
set &quot;z=&quot;
if &quot;%s:~0,1%&quot;==&quot;(&quot; (set &quot;1=(&quot;)else (set/aa-=1
set &quot;1=)&quot;)
for %%a in (!a!)do for /f usebackq %%b in (`powershell &quot;'!l%%a!'&quot;.Length`)do (set/ay=!c!-%%b
for /l %%a in (1,1,!y!)do set z= !z!
set &quot;l%%a=!l%%a!!z!!1!&quot;)
if &quot;%s:~0,1%&quot;==&quot;(&quot; set/aa+=1
if !a! GTR !l! set/al=!a!-1
set &quot;s=%s:~1%&quot;
goto c)
for /l %%a in (1,1,!l!)do echo !l%%a!
</code></pre>
<h2>Un-golfed:</h2>
<pre><code>@echo off
setLocal enableDelayedExpansion

set s=%1
set a=1
set c=0
set l=0

:c
if defined s (
    set /a c+=1
    set &quot;z=&quot;
    if &quot;%s:~0,1%&quot;==&quot;(&quot; (
        set &quot;1=(&quot;
    ) else (
        set /a a-=1
        set &quot;1=)&quot;
    )
    for %%a in (!a!) do for /f usebackq %%b in (`powershell &quot;'!l%%a!'&quot;.Length`) do (
        set /a y=!c!-%%b
        for /l %%a in (1,1,!y!) do set z= !z!
        set &quot;l%%a=!l%%a!!z!!1!&quot;
    )
    if &quot;%s:~0,1%&quot;==&quot;(&quot; set /a a+=1
    if !a! GTR !l! set /a l=!a!-1
    set &quot;s=%s:~1%&quot;
    goto c
)

for /l %%a in (1,1,!l!) do echo !l%%a!
</code></pre>
<p>Example:</p>
<pre><code>h:\&gt;par.bat (((())())(()))
 (            )
  (      )(  )
   (  )()  ()
    ()
</code></pre>
</div>
<div id="pu23" class="pu"><h1>Batch, <s>356</s> 335 bytes</h1>

<p>I know that there already exists a Batch solution for this challenge, but this one is golfed significantly more and seems to take a different approach. Most importantly, the other batch solution contains at least one powershell command; this solution does not.</p>

<pre><code>@echo off
setlocal enabledelayedexpansion
set p=%1
set p=%p:(="(",%
set p=%p:)=")",%
set c=0
for %%a in (%p%)do (if ")"==%%a set/ac-=1
set d=!d!,!c!%%~a
if "("==%%a set/ac+=1&amp;if !c! GTR !m! set m=!c!)
set/am-=1
for /l %%a in (0,1,!m!)do (for %%b in (!d!)do (set t=%%b
if "%%a"=="!t:~0,-1!" (cd|set/p=!t:~-1!)else (cd|set/p=. ))
echo.)
</code></pre>

<p>There is a  backspace character (<code>U+0008</code>) on the second to last line following the dot (line 12, column 57). This isn't visible in the code posted here but is included in the byte count.</p>
</div>
<div id="pu24" class="pu"><h1>C, <s>58 53 52 51</s> 49 bytes</h1>

<p>Makes use of ANSI escape sequences to move the cursor position.</p>

<pre><code>f(char*s){while(*s)printf(*s++&amp;1?"\e[A)":"(\v");}
</code></pre>

<p>If not using gcc or another compiler that supports <code>\e</code> then it can be replaced with <code>\x1B</code> for a total of 2 extra bytes. <code>\e[A</code> moves the cursor up one row and <code>\e[B</code> moves the cursor down one row. It's not necessary to use <code>\e[B</code> to move down one row as it's two bytes shorter to use the ASCII vertical tab character <code>0xB</code> or <code>\v</code>.</p>

<p>The input string is assumed, from the question, to consist of only (balanced) parentheses, so checking the parity of the character, with <code>&amp;1</code>, is enough to distinguish between <code>(</code> and <code>)</code>.</p>
</div>
<div id="pu25" class="pu"><h1>Haskell, 154 bytes</h1>

<pre><code>f h('(':s)=h:f(h+1)s;f h(')':s)=(h-1):f(h-1)s;f _ _=[]
main=interact$ \s-&gt;unlines[[if i==h then c else ' '|(c,i)&lt;-zip s l]|let l=f 0 s,h&lt;-[0..maximum l]]
</code></pre>

<p>same idea as the other Haskell solution, but somewhat shorter. - Usage:</p>

<pre><code>echo  '(((())())(()))' | runghc Golf.hs
</code></pre>
</div>
<div id="pu26" class="pu"><h1>C#, 195 bytes</h1>

<p>First try at golf - yell if I did something wrong.</p>

<p>Alternative C# version using SetCursorPosition and working left to right taking the input as a commandline arg.</p>

<pre><code>using System;class P{static void Main(string[] a){Action&lt;int,int&gt;p=Console.SetCursorPosition;int r=0,c=0;foreach(var x in a[0]){r+=x==')'?-1:0;p(c,r);Console.Write(x);r+=x=='('?1:0;p(c,r);c++;}}}
</code></pre>

<p>I thought it would be fun to adjust the write position based on the open/close paren and not full lines.  Close paren moves the position up before writing; open paren moves it down after writing.  Actioning SetCursorPosition saves five bytes.  Moving the cursor to the next line after the output would take quite a bit extra.</p>

<pre><code>using System;
class P
{
    static void Main(string[] a)
    {
        Action&lt;int, int&gt; p = Console.SetCursorPosition;
        int r = 0, c = 0;
        foreach (var x in a[0])
        {            
            r += x == ')' ? -1 : 0;
            p(c, r);
            Console.Write(x);
            r += x == '(' ? 1 : 0;
            p(c, r);
            c++;
        }
    }
}
</code></pre>
</div>
<div id="pu27" class="pu"><h1>x86 machine code, <del>39</del> <del>34</del> <del>33</del> <del>30</del> 29 bytes</h1>

<pre><code>00000000  68 c3 b8 07 31 ff be 82  00 b3 a0 ad 4e 3c 28 7c  |h...1.......N&lt;(||
00000010  f0 77 05 ab 01 df eb f3  29 df ab eb ee           |.w......)....|
0000001d
</code></pre>

<p>x86 assembly for DOS, with some tricks:</p>

<pre><code>    org 100h

section .text

start:
    ; point the segment ES to video memory
    ; (c3 is chosen so that it doubles as a "ret")
    push 0b8c3h
    pop es
    ; di: output pointer to video memory
    xor di,di
    ; si: input pointer from the command line
    mov si,82h
    ; one row=160 bytes (assume bh=0, as should be)
    mov bl,160
lop:
    ; read &amp; increment si (assume direction flag clean)
    ; we read a whole word, so that later we have something nonzero to
    ; put into character attributes
    lodsw
    ; we read 2 bytes, go back 1
    dec si
    ; check what we read
    cmp al,'('
    ; less than `(`: we got the final `\n` - quit
    ; (we jump mid-instruction to get a c3 i.e. a ret)
    jl start+1
    ; more than `(`: assume we got a `)`
    ja closed
    ; write a whole word (char+attrs), so we end
    ; one position on the right
    stosw
    ; move down
    add di,bx
    ; rinse &amp; repeat
    jmp lop
closed:
    ; move up
    sub di,bx
    ; as above
    stosw
    jmp lop
</code></pre>

<p><em>Limitations</em>:</p>

<ul>
<li>it always prints starting at the bottom of the screen, without erasing first; a <code>cls</code> before running is almost mandatory;</li>
<li>the colors are ugly; that's the consequence of recycling the next character as color attributes to save two bytes here and there;</li>
<li>the code assumes <code>bh=0</code> and the direction flag clear on start, both undocumented; OTOH, <code>bx</code> is explicitly set to zero in all DOS variants I saw (DosBox, MS-DOS 2, FreeDOS), and everywhere I tested the flags were already OK.</li>
</ul>

<p><img src="https://i.stack.imgur.com/hwpmW.png" alt="enter image description here"></p>
</div>
<div id="pu28" class="pu"><h1>Python 2, 166 bytes</h1>
<p>Not much to be said:</p>
<pre class="lang-py prettyprint-override"><code>m,c,l=list(input()),0,[]
for j in m:c+=1if j=='('else-1;l+=[c-1if j=='('else c]
for i in range(max(l)+1):
 t,p='',0
 for q in m:t+=q if l[p]==i else' ';p+=1
 print t
</code></pre>
</div>
<div id="pu29" class="pu"><h1>Javascript/ES6, 97 chars</h1>

<pre><code>f=s=&gt;{for(n in s){m=o=d='';for(c of s)o+=n==(c&lt;')'?d++:--d)?c:' ',m=m&lt;d?d:m;n&lt;m&amp;&amp;console.log(o)}}
</code></pre>

<h2>Usage</h2>

<pre><code>f("(()(()())()((())))(())")
</code></pre>

<h2>Explanation</h2>

<pre><code>fn=str=&gt;{                          // accepts string of parenthesis
  for(line in str){                // repeat process n times where n = str.length
    max=output=depth='';           // max: max depth, output: what to print, depth: current depth
    for(char of str)               // iterate over chars of str
      output+=
        line==(char&lt;')'?depth++:--depth)? // update depth, if line is equal to current depth
        char:' ',                  // append either '(', ')', or ' '
        max=max&lt;depth?depth:max;   // update max depth
    line&lt;max&amp;&amp;console.log(output)  // print if current line is less than max depth
  }
}
</code></pre>
</div>
<div id="pu30" class="pu"><h1>Retina + Bash, 27 bytes (14 + 10 + 3 = 27)</h1>

<p>This makes use of ANSI Escapes:</p>

<pre><code>\(
(\e[B
\)
\e[A)
</code></pre>

<p>Equivalent to <code>sed -e "s/(/(\\\e[B/g;s/)/\\\e[A)/g"</code>.
The <code>\e[B</code> escape code means move cursor down one row, and the <code>\e[A</code> means move cursor up one row, so this solution simply inserts those codes after and before the start and end of each nested pair of parentheses. Input is passed through STDIN.</p>

<p>You'll have to call it as <code>printf $(Retina ...)</code> to see the output correctly.</p>

<h2>Output</h2>

<pre><code>(((())))
(\e[B(\e[B(\e[B(\e[B\e[A)\e[A)\e[A)\e[A)
^C
amans:~ a$ printf "(\e[B(\e[B(\e[B(\e[B\e[A)\e[A)\e[A)\e[A)"
(      )amans:~ a$ 
 (    )
  (  )
   ()

((()())()(()(())()))
(\e[B(\e[B(\e[B\e[A)(\e[B\e[A)\e[A)(\e[B\e[A)(\e[B(\e[B\e[A)(\e[B(\e[B\e[A)\e[A)(\e[B\e[A)\e[A)\e[A)
^C
amans:~ a$ printf "(\e[B(\e[B(\e[B\e[A)(\e[B\e[A)\e[A)(\e[B\e[A)(\e[B(\e[B\e[A)(\e[B(\e[B\e[A)\e[A)(\e[B\e[A)\e[A)\e[A)"
(                  )amans:~ a$ 
 (    )()(        )
  ()()    ()(  )()
             ()
</code></pre>
</div>
<div id="pu31" class="pu"><h1>Java, <strike>232</strike> <strike>226</strike> <strike>224</strike> 222 bytes</h1>
<p>Golfed version:</p>

<pre class="lang-java prettyprint-override"><code>int i,j,k,l,m,a[];void f(String s){a=new int[s.length()];j=a.length;for(k=0;k&lt;j;){a[k]=s.charAt(k++)&lt;41?i++:--i;m=m&lt;i?i:m;}for(k=0;k&lt;m;k++)for(l=0;l&lt;j;)System.out.print(k==a[l++]?i++%2&lt;1?'(':l==j?&quot;)\n&quot;:')':l==j?'\n':' ');}
</code></pre>
<p>Long version:</p>
<pre class="lang-java prettyprint-override"><code>int i, j, k, l, m, a[];
void f(String s) {
    a = new int[s.length()];
    j = a.length;
    for (k = 0; k &lt; j;) {
        a[k] = s.charAt(k++) &lt; 41 ? i++ : --i;
        m = m &lt; i ? i : m;
    }
    for (k = 0; k &lt; m; k++)
        for (l = 0; l &lt; j;)
            System.out.print(k == a[l++] ? (i++ % 2 &lt; 1 ? '(' : (l == j ? &quot;)\n&quot; : ')')) : (l == j ? '\n':' '));
}
</code></pre>
<p>The input string is analyzed first, looking for &quot;(&quot; and &quot;)&quot; to add/subtract a counter and store its value determining how far down the parentheses should go in an array while also keeping track of how deep the deepest one goes. Then the array is analyzed; the parentheses with lesser values are printed first, and will continue printing line by line until the maximum is reached.</p>
<p>I'll probably find ways to golf this further later.</p>
</div>
<div id="pu32" class="pu"><h1>R, <s>151</s> 127 characters</h1>
<pre><code>S=strsplit(scan(,&quot;&quot;),&quot;&quot;)[[1]];C=cumsum;D=c(C(S==&quot;(&quot;),0)-c(0,C(S==&quot;)&quot;));for(j in 1:max(D)){X=S;X[D!=j]=' ';cat(X,sep='',fill=T)}
</code></pre>
<p>With indents and newlines:</p>
<pre class="lang-r prettyprint-override"><code>S=strsplit(scan(,&quot;&quot;),&quot;&quot;)[[1]]
C=cumsum
D=c(C(S==&quot;(&quot;),0)-c(0,C(S==&quot;)&quot;))
for(j in 1:max(D)){
    X=S
    X[D!=j]=' '
    cat(X,sep='',fill=T)
    }
</code></pre>
<p>Usage:</p>
<pre><code>&gt; S=strsplit(scan(,&quot;&quot;),&quot;&quot;)[[1]];C=cumsum;D=c(C(S==&quot;(&quot;),0)-c(0,C(S==&quot;)&quot;));for(j in 1:max(D)){X=S;X[D!=j]=' ';cat(X,sep='',fill=T)}
1: ()(())((()))(())()
2: 
Read 1 item
()(  )(    )(  )()
   ()  (  )  ()   
        ()        
&gt; S=strsplit(scan(,&quot;&quot;),&quot;&quot;)[[1]];C=cumsum;D=c(C(S==&quot;(&quot;),0)-c(0,C(S==&quot;)&quot;));for(j in 1:max(D)){X=S;X[D!=j]=' ';cat(X,sep='',fill=T)}
1: ((()())()(()(())()))
2: 
Read 1 item
(                  )
 (    )()(        ) 
  ()()    ()(  )()  
             ()     
</code></pre>
<p>It reads the string as stdin, splits it as a vector of single characters, computes the cumulative sum of <code>(</code> and <code>)</code>, substracts the former with the latter (with a lag) thus computing the &quot;level&quot; of each parentheses. It then prints to stdout, for each level, either the corresponding parentheses or a space.</p>
<p>Thanks to @MickyT for helping me shortening it considerably!</p>
</div>
<div id="pu33" class="pu"><h1>cheating :( <s> Retina + TeX, N bytes</s> cheating :(</h1>

<p>This only works if you render(?) the output using MathJax or some other TeX, which is currently disabled for this SE :(</p>

<pre><code>\(
({
\)
})
\{\(
_{(
</code></pre>

<p>Each line should be in a different file, but you can test it by using <code>Retina -e "\(" -e "({" -e "\)" -e "})" -e "\{\(" -e "_{("</code> (or the equivalent sed command <code>sed -e "s/(/({/g;s/)/})/g;s/{(/_{(/g"</code>). Input is passed through STDIN.</p>

<p>This works by enclosing the contents of each pair of parentheses in braces, and then subscripting all the items inside them.</p>

<h2>Output</h2>

<pre><code>(((())))
(_{(_{(_{({})})})})

()(())((()))(())()
({})(_{({})})(_{(_{({})})})(_{({})})({})

((()())()(()(())()))
(_{(_{({})({})})({})(_{({})(_{({})})({})})})
</code></pre>

<p><img src="https://i.stack.imgur.com/inv2p.png" alt="TeX Output"></p>
</div>
<div id="pu34" class="pu"><h1>Lex, 94 bytes</h1>

<p>Depends on Linux console codes. With gcc, you can cut out four bytes by replacing both instances of <code>\33</code> with an actual escape character.</p>

<pre><code>%%
 int p[2]={0};
\( printf("(\33D");++p[!*p];
\) printf("\33M)");--*p;
\n while(p[1]--)ECHO;
</code></pre>

<p>To compile and run:</p>

<pre><code>$ flex -o telescopic.c telescopic.l
$ gcc -o telecopic telescopic.c -lfl
$ ./telescopic
(()(()())()((())))(())
(                )(  )
 ()(    )()(    )  ()
    ()()    (  )
             ()
--- type ctrl-D ---
</code></pre>
</div>
<div id="pu35" class="pu"><h1>Perl, 76 bytes</h1>

<pre><code>$a[/\(/?$l++:--$l][$i++]=$_ for split//,&lt;&gt;;print map{$_||' '}@$_,"\n"for@a
</code></pre>

<p>No <code>use strict</code> here :)</p>
</div>
<div id="pu36" class="pu"><h1>C#, 196 bytes</h1>

<p>Very simple complete program that takes input via STDIN, and outputs to STDOUT. I should like to get rid of the <code>S.Length</code>, but haven't found a way that pays.</p>

<pre class="lang-c# prettyprint-override"><code>using Q=System.Console;class P{static void Main(){var S=Q.ReadLine();for(int i=0,c;++i&lt;S.Length;){var r="";c=0;foreach(var k in S)r+=(c+=81-k*2)+k-40==i?k:' ';if(r.Contains("("))Q.WriteLine(r);}}}
</code></pre>

<p>It simply iterates over the input a number of times (input length - 1), keeping track of the parentheses "depth", and comparing it to the current iteration count (<code>i</code>) - if they match, then it adds the current parenthesis to a string, to be printed at the end of the iteration. Because more iterations may be done than necessary, it only prints the iteration result (<code>r</code>) if it contains a parenthesis.</p>

<pre class="lang-c# prettyprint-override"><code>using Q=System.Console;

class P
{
    static void Main()
    {
        var S=Q.ReadLine(); // read input

        for(int i=0,c;
            ++i&lt;S.Length; // can't be more than S.Length - 1 lines of output
            )
        {
            var r=""; // reset result
            c=0; // current paren depth
            foreach(var k in S) // for each char in input
                r+= // append something...
                    (c+=81-k*2) // move c
                    +k-40==i? // check if we should output the current char
                        k:
                        ' '; // otherwise a space
            if(r.Contains("(")) // only print if there is some content
                Q.WriteLine(r);
        }
    }
}
</code></pre>
</div>
<div id="pu37" class="pu"><h1>Perl, <s>91</s> <s>89</s> <s>88</s> <s>84</s> <s>80</s> 79 bytes</h1>

<pre><code>$t=&lt;&gt;;{$_=$t;s/\((?{$l++})|.(?{--$l})/$^R==$c?$&amp;:$"/ge;print,++$c,redo if/\S/}
</code></pre>

<ul>
<li>$t is the input string.</li>
<li>$c is the depth we want to print on the current line.</li>
<li>$l is the depth we are at after encountering a paren.</li>
<li>$l is updated in <a href="http://perldoc.perl.org/perlre.html#(%3F%7B-code-%7D)" rel="nofollow">regex embedded code blocks</a>.</li>
<li>$^R is the result of the most recent code block.</li>
</ul>
</div>
<div id="pu38" class="pu"><h1>Java, <s>233</s> 214 bytes</h1>

<pre><code>void f(String s){int p,x,d,l=s.length();char c,m[]=new char[l*l];java.util.Arrays.fill(m,' ');p=x=0;while(x&lt;l){d=(c=s.charAt(x))==40?p++:--p;m[d*l+x++]=c;}for(x=0;x&lt;l*l;x++)System.out.print((x%l==0?"\n":"")+m[x]);}
</code></pre>

<p>Indented:</p>

<pre><code>void f(String s){
    int p, x, d, l = s.length();
    char c, m[] = new char[l * l];
    java.util.Arrays.fill(m, ' ');
    p = x = 0;
    while (x &lt; l){
        d = (c = s.charAt(x)) == 40
                ? p++
                : --p;
        m[d * l + x++] = c;
    }
    for (x = 0; x &lt; l * l; x++)
        System.out.print((x % l == 0 ? "\n" : "") + m[x]);
}
</code></pre>

<p>I guess the final loop could be shortened, but I'll leave it as an exercise to the reader. ;-)</p>

<hr>

<p>Old, 233 bytes answer:</p>

<pre><code>void f(String s){int y=s.length(),x=0;char[][]m=new char[y][y];for(char[]q:m)java.util.Arrays.fill(q,' ');y=0;for(char c:s.toCharArray())if(c=='(')m[y++][x++]=c;else m[--y][x++]=c;for(char[]q:m)System.out.println(String.valueOf(q));}
</code></pre>

<p>Indented:</p>

<pre><code>static void f(String s) {
    int y = s.length(), x = 0;
    char[][] m = new char[y][y];
    for(char[] q : m)
        java.util.Arrays.fill(q, ' ');
    y = 0;
    for(char c : s.toCharArray())
        if(c == '(')
            m[y++][x++] = c;
        else
            m[--y][x++] = c;
    for(char[] q : m)
        System.out.println(String.valueOf(q));
}
</code></pre>
</div>
<div id="pu39" class="pu"><h1>Ruby, <s>119</s> <s>115</s> 114</h1>

<pre><code>-&gt;s{r=[""]*s.size
d=0
s.chars.map{|l|r.map!{|s|s+" "}
b=l&gt;"("?1:0
d-=b
r[d][-1]=l
d+=1-b}.max.times{|i|puts r[i]}}
</code></pre>

<p>Explanation:</p>

<pre><code>-&gt;s{r=[""]*s.size  # Take an array of strings big enough
d=0                # This will contain the current depth
s.chars.map{|l|r.map!{|s|s+" "}  # Add a new space to every array
b=l&gt;"("?1:0       # Inc/Dec value of the depth
d-=b               # Decrement depth if we are at a closing paren
r[d][-1]=l         # Set the corresponding space to the actual open/close paren
d+=1-b             # Increment the depth if we are at a opening paren
}.max.times{|i|puts r[i]}}  # Print only the lines up to the max depth
</code></pre>
</div>
<div id="pu40" class="pu"><h1>Haskell, 227 bytes</h1>

<pre><code>n _ []=[]
n h ('(':r)=('(',h):n(h+1)r
n d (')':r)=let h=d-1 in(')',h):n h r
m n []=n
m n ((_,h):r)=m(max h n)r
p s=let v=n 0 s;h=m 0 v;in map(\d-&gt;map(\(b,l)-&gt;if l==d then b else ' ')v)[0..h]
main=fmap p getLine&gt;&gt;=mapM_ putStrLn
</code></pre>
</div>
<div id="pu41" class="pu"><h1>Python 2, 92</h1>

<pre class="lang-python prettyprint-override"><code>def f(s,i=0,z=''):
 for x in s:b=x&gt;'(';z+=[' ',x][i==b];i-=2*b-1
 if'('in z:print z;f(s,i-1)
</code></pre>

<p>Prints line by line. For a given line number <code>i</code> (actually, its negation), goes through the input string <code>s</code>, and makes a new string <code>z</code> that only contains the characters of <code>s</code> at depth <code>i</code>. This is done by incrementing or decrementing <code>i</code> to track the current depth, and adding the current characters when <code>i</code> is <code>0</code> adjusted for paren type, and otherwise adding a space.</p>

<p>Then, prints and recurses to the next <code>i</code> unless the current line was all spaces. Note that since the parens are balanced, the <code>i</code> after a loop is the same as at the start.</p>

<p>Python 3 would be same except for a character for <code>print(z)</code>.</p>
</div>
<div id="pu42" class="pu"><h1>Python 2, 115 bytes</h1>

<pre class="lang-py prettyprint-override"><code>def f(L,n=0,O=()):
 for c in L:n-=c&gt;&quot;(&quot;;O+=&quot; &quot;*n+c,;n+=c&lt;&quot;)&quot;
 for r in map(None,*O):print&quot;&quot;.join(c or&quot; &quot;for c in r)
</code></pre>
<p>Call like <code>f(&quot;((()())()(()(())()))&quot;)</code>, and output is to STDOUT.</p>
<h2>Explanation</h2>
<p>We start with <code>n = 0</code>. For each char in the input line:</p>
<ul>
<li>If the char is <code>(</code>, we prepend <code>n</code> spaces then increment <code>n</code></li>
<li>If the char is <code>)</code>, we decrement <code>n</code> then prepend <code>n</code> spaces</li>
</ul>
<p>The result is then zipped and printed. Note that Python's <code>zip</code> zips to match the length of the <em>shortest</em> element, e.g.</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; zip([1, 2], [3, 4], [5, 6, 7])
[(1, 3, 5), (2, 4, 6)]
</code></pre>
<p>Usually one would use <code>itertools.zip_longest</code> (<code>izip_longest</code>) if they wanted <code>zip</code> to pad to the length of the <em>longest</em> element.</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; list(itertools.izip_longest([1, 2], [3, 4], [5, 6, 7]))
[(1, 3, 5), (2, 4, 6), (None, None, 7)]
</code></pre>
<p>But in Python 2, this behaviour can be simulated by mapping <code>None</code>:</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; map(None, [1, 2], [3, 4], [5, 6, 7])
[(1, 3, 5), (2, 4, 6), (None, None, 7)]
</code></pre>
<hr />
<h2>Python 3, 115 bytes</h2>
<pre class="lang-py prettyprint-override"><code>L,d,*O=input(),0
for i,c in enumerate(L):b=c&gt;&quot;(&quot;;O+=&quot;&quot;,;O[d-b]=O[d-b].ljust(i)+c;d-=b*2-1
for l in O:l and print(l)
</code></pre>
<p>No zipping, just padding appropriately with <code>ljust</code>. This one seems to have some golfing potential.</p>
</div>
<div id="pu43" class="pu"><h1>Pyth, 31 bytes</h1>

<pre><code>VzJs.e?YqN-/&lt;zk\(/&lt;zhk\)dzI-JdJ
</code></pre>

<p><a href="https://pyth.herokuapp.com/?code=VzJs.e%3FYqN-%2F%3Czk%5C(%2F%3Czhk%5C)dzI-JdJ&amp;input=(()(()())()((())))(())&amp;debug=0" rel="nofollow">Try it online.</a></p>

<p><code>-/&lt;zk\(/&lt;zhk\)</code>: Finds the appropriate level for the current character position.</p>

<p><code>?YqN-/&lt;zk\(/&lt;zhk\)d</code>: A space if the appropriate level is not the current level, current character otherwise.</p>

<p><code>Js.e?YqN-/&lt;zk\(/&lt;zhk\)dz</code>: Generate the string, save it to <code>J</code>.</p>

<p><code>I-JdJ</code>: If <code>J</code> is not all spaces, print it out.</p>

<p><code>Vz</code>: Loop <code>z</code> times.</p>
</div>
<div id="pu44" class="pu"><h1>IDL 8.4, <s>173</s> 177 bytes</h1>

<p>This is similar enough to the formatter challenge that I had half a solution already. IDL is still a terrible golfing language, but I'm pretty happy with how this worked out.</p>

<pre><code>read,(p='')&amp;a=[0:strlen(p)-1]&amp;c=strmid(p,a,1)&amp;e=c.map(lambda(x,d:'('eq x:d++:d---1)))&amp;print,[0:max(e)].map(lambda(x,y,z:y.reduce(lambda(t,u,v,w,:t+(w eq v?u:' ')),x,z),c,a))&amp;end
</code></pre>

<p>Un-golfed:</p>

<pre><code>read,(p='') ;read a string from input
a=[0:strlen(p)-1] ;index array to the input
c=strmid(p,a,1) ;split the input into an array of 1-char substrings
e=c.map(lambda(x,d:'('eq x:d++:d---1))) ;for each substring, increment depth if ( and decrement otherwise, saving depth each time
print,[0:max(e)].map(lambda(x,y,z:y.reduce(lambda(t,u,v,w,:t+(w eq v?u:' ')),x,z),c,a)) ;print an array of strings, each one including the parens in that depth level.
end ;end the script
</code></pre>
</div>
<div id="pu45" class="pu"><h1>Pip, 53 bytes</h1>

<p><a href="https://github.com/dloscutoff/pip"><strong>Pip</strong></a> is a code-golf language of my invention. The first version was published on Saturday, so I can officially take it for a spin! The solution below isn't terribly competitive as golfing languages go, but that's partly because I haven't implemented things like zip and max yet.</p>

<pre><code>z:{aEQ'(?++v--v+1}MaW(o:{z@++v=i?as}Ma)RMs{Pov:-1++i}
</code></pre>

<p>Expects the string of parentheses as a command-line argument.</p>

<p>"Ungolfed" version:</p>

<pre><code>z:{
   a EQ '( ?
    ++v
    --v+1
  } M a
W (o:{
      z @ ++v = i ?
       a
       s
     } M a
  ) RM s
{
 P o
 v:-1
 ++i
}
</code></pre>

<p><strong>Explanation:</strong></p>

<p>Unlike most golfing languages, Pip is imperative with infix operators, so the syntax is somewhat closer to C and its derivatives. It also borrows ideas from functional and array-based programming. See the repository for further documentation.</p>

<p>The program first generates a list of depths (storing it in <code>z</code>) by mapping a function to the input string <code>a</code>. The global variable <code>v</code> tracks the current level. (Variables <code>a-g</code> in Pip are function-local variables, but <code>h-z</code> are global. <code>v</code> is handy because it's preinitialized to -1.)</p>

<p>Next, we use a <code>W</code>hile loop to generate and print each line, until the line generated would consist of all spaces. <code>v</code> is now used for columns, and <code>i</code> for rows. The <code>{z@++v=i?as}</code> function, repeatedly mapped to the original input string, tests whether the current line <code>i</code> matches the line the current parenthesis is supposed to be on (as stored in the <code>z</code> list). If so, use the parenthesis (<code>a</code>); if not, use <code>s</code> (preinitialized to space). The end result is that on each iteration, <code>o</code> gets assigned a list of characters equivalent to the next line of the output.</p>

<p>To test whether we should continue looping, we check if <code>o</code> with all the spaces <code>RM</code>'d is empty. If not, print it (which by default concatenates everything together as in CJam), reset the column number to -1, and increment the row number.</p>

<p>(Fun fact: I had a 51-byte solution at first... which didn't work because it turned up a bug in the interpreter.)</p>
</div>
<div id="pu46" class="pu"><h1>J, 46</h1>
<p>Not as great as the other 'golfing languages', but in my defence: J is terrible with strings.</p>
<pre><code>[:|:(((,~(' '#~]))&quot;0)(0,2%~[:+/\2+/\1-'(('i.]))~
</code></pre>
<p>Takes the string as input for a function. There's also probably a better way to do it in J.</p>
<h2>Usage:</h2>
<pre><code>   f=:[:|:(((,~(' '#~]))&quot;0)(0,2%~[:+/\2+/\1-'(('i.]))~
   f '(()(()())()((())))(())'
(                )(  )
 ()(    )()(    )  () 
    ()()    (  )      
             ()       
</code></pre>
</div>
<div id="pu47" class="pu"><h1>Octave, 85 chars</h1>
<pre><code>function r=p(s)i=j=0;for b=s k=b==40;k&amp;&amp;++j;t(j,++i)=9-k;k||--j;r=char(t+32);end;end
</code></pre>
<p>It's an optimization of the naïve approach, which is actually pretty natural for Matlab and Octave:</p>
<pre><code>function r=p(s)
i=j=1;
for b=s
 if b=='(' t(++j,i++)='(' else t(j--,i++)=')' end; end; t(~t)=' '; r=char(t);
end;
</code></pre>
<p>The table <code>t</code>  may even not yet exist, and we may assign to any element right away, and it reshapes to the smallest dimension that is required for this element to exist which is quite convenient.</p>
</div>
<div id="pu48" class="pu"><h1>GNU Bash + coreutils + indent, 135</h1>
<pre><code>eval paste &quot;`tr '()' {}|indent -nut -i1 -nbap|sed 's/.*/&lt;(fold -1&lt;&lt;&lt;&quot;&amp;&quot;)/'|tr '
' \ `&quot;|expand -t2|sed 'y/{}/()/;s/\(.\) /\1/g;s/ \+$//'
</code></pre>
<p>Input/output via STDIN/STDOUT:</p>
<pre><code>$ ./telescopic.sh &lt;&lt;&lt; &quot;(()(()())()((())))(())&quot;
(                )(  )
 ()(    )()(    )  ()
    ()()    (  )
             ()
$ 
</code></pre>
<p><code>indent</code> does most of the heavy lifting, but needs to work with braces instead of parens.  The rest is <a href="https://codegolf.stackexchange.com/questions/17305/transpose-a-page-of-text/24501#24501">modification of this answer</a> to transpose the output of <code>indent</code>.</p>
</div>
<div id="pu49" class="pu"><h1>CJam, <s>43 41</s> 36 bytes</h1>

<p>Not too golfed (I think), but here goes my first attempt:</p>

<pre><code>l:L,{)L&lt;)_')=@~zS*\+}%_$0=,f{Se]}zN*
</code></pre>

<p><strong>How it works</strong></p>

<p>I am using the very handy fact that <code>)</code> and <code>(</code> in CJam mean increment and decrement respectively. Thus, I simply evaluate the brackets to get the depth.</p>

<pre><code>l:L,{)L&lt;)_')=@~zS*\+}%_$0=,f{Se]}zN*
l:L,{                    }%                "Store input line in L and iterate over [0,L)";
     )L&lt;                                   "substr(L, 0, iterator + 1)";
        )                                  "Slice off the last character to stack";
         _')=                              "Put 0 on stack if the sliced character is (,
                                            else 1 if sliced character is )";
             @~                            "bring forth the remaining
                                            brackets after slicing and evaluate them";
               zS*                         "Stack has negative depth number, take absolute
                                            value and get that many spaces";
                  \+                       "Prepend to the sliced character";
                      _$0=,                "Get the maximum depth of brackets";
                           f{Se]}          "Pad enough spaces after each string to match
                                            the length of each part";
                                 zN*       "Transpose and join with new lines";
</code></pre>

<p><a href="http://cjam.aditsu.net/#code=l%3AL%2C%7B)L%3C)_&#39;)%3D%40~zS*%5C%2B%7D%25_%240%3D%2Cf%7BSe%5D%7DzN*&amp;input=(()(()())()((())))(())" rel="nofollow">Try it online here</a></p>
</div>
<div id="pu50" class="pu"><h1>C, 150 bytes</h1>

<pre class="lang-c prettyprint-override"><code>t;f(char*c){char l=strlen(c)+1,o[l*l],*A=o,m=0;for(t=1;t&lt;l*l;t++)o[t-1]=t%l?32:10;for(t=-1;*c;c++)A++[l*(*c-41?++t&gt;m?m=t:t:t--)]=*c;A[m*l]=0;puts(o);}
</code></pre>
<p>This was <em>crazy</em> fun to golf. I'm still not convinced I'm done with it.</p>
<p>We define a single function, <code>f</code>, that takes the string as input and outputs to stdout.</p>
<p>Let's go through the code, line by line:</p>
<pre class="lang-c prettyprint-override"><code>/* t will represent the current depth of a parentheses. It must be an int. */
t;
f(char*c){
    //Our variables:
    char l=strlen(c)+1,    //The length of each row of output, including newlines
         o[l*l],           //The output string. It's way larger than it needs to be.
         *A=o,             //We need another pointer to keep track of things.
         m=0;              //The maximum depth recorded thus far.

    for(t=1;t&lt;l*l;t++)     //For each character in our output...
        o[t-1]=t%l?32:10;  //If it's at the end of a line, make it '\n'. Else, ' '.
    for(t=-1;*c;c++)       //While we have an input string...
        //Perhaps a personal record for ugliest warning-less line...
        A++[l*(*c-41?++t&gt;m?m=t:t:t--)]=*c;
    /* 
        A breakdown:
        A++        --&gt; Go to the next *column* of output, after writing. 
                   --&gt; There will only ever be one parentheses per output column.
        [l*(...)]  --&gt; A[l*X] is the character in the current column at depth X.
        (*c-41?    --&gt; If the character is a '('...    
        ++t&gt;m?     --&gt; Increment t *before* we write it. If this is a new highest depth
        m=t:       --&gt; Set m to t, and set the whole expression to t.
        t:         --&gt; If it's not a new highest depth, don't set m.
        t--)       --&gt; If the character was a ')', decrement t *after* we write it.
        =*c        --&gt; Write our output character to whatever the input read.
    */    
    
    A[m*l]=0; //The last character of the maximum-depth line should be null terminated.
    puts(o);  //Output!
}
</code></pre>
<p>I'll answer any questions you may have!</p>
<p>Try a test program <a href="http://ideone.com/v5nyZ5" rel="noreferrer">online</a>!</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/49042/">49042</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




