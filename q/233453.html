<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::233453</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>340</td><td>Python3</td><td>250824T175339Z</td><td><a href="https://codegolf.stackexchange.com/questions/233453/parse-a-lambda-for-correctness/283310#283310">Ajax1234</a></td></tr>
<tr d-ix="1"><td>116</td><td>Curry PAKCS</td><td>210910T192934Z</td><td><a href="https://codegolf.stackexchange.com/questions/233453/parse-a-lambda-for-correctness/235242#235242">Wheat Wi</a></td></tr>
<tr d-ix="2"><td>318</td><td>Tiny Lisp</td><td>210901T145150Z</td><td><a href="https://codegolf.stackexchange.com/questions/233453/parse-a-lambda-for-correctness/233925#233925">Paŭlo Eb</a></td></tr>
<tr d-ix="3"><td>293</td><td>Scala</td><td>210817T143215Z</td><td><a href="https://codegolf.stackexchange.com/questions/233453/parse-a-lambda-for-correctness/233488#233488">user</a></td></tr>
<tr d-ix="4"><td>086</td><td>Perl 5 p</td><td>210817T002522Z</td><td><a href="https://codegolf.stackexchange.com/questions/233453/parse-a-lambda-for-correctness/233465#233465">Anders K</a></td></tr>
<tr d-ix="5"><td>123</td><td>Raku Perl 6 p</td><td>210817T030801Z</td><td><a href="https://codegolf.stackexchange.com/questions/233453/parse-a-lambda-for-correctness/233468#233468">Silvio M</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Python3, 340 bytes</h1>
<pre class="lang-py prettyprint-override"><code>import re
def P(e,c):
 K=[]
 if'var'==e[0]:K+=[e[1]in c]
 if'abs'==e[0]:K+=['['!=str(e[1])[0]and e[1]not in c and P(e[2],c+[e[1]])]
 if'app'==e[0]:K+=[P(e[1],c)and P(e[2],c)]
 return any(K)
def f(s):
 try:return s[0]=='('and P(eval(re.sub('\s|\w+|\(|\)',lambda x:{' ':',','(':'[',')':']'}.get(V:=x.group(),f'&quot;{V}&quot;'),s)),[])
 except:return 0
</code></pre>
<p><a href="https://tio.run/##fZLLbqMwFIbX46c4w8bnNEyUTLuokPwEkUZZdUNYQGJa1ACWbTKgps@esUlgSHrBEuf@@bdl1dmXurp/VPp0KkpVawtasp3MYY0y3FLEYCXihEGR80OquRAyXiTRaiZiGS@TooLtuZhmZlrkMf8pjNXou8hl02oH3q9qC34KfMLtEf9Owu2shyV0QSk1Ra17htMynfCtWtpGVw7U4Yp6zTkar9jqLroUjaMIwZFfhg/pHrWcmyZDvjHHzd/ZcYPHDfFwn5bZLoU2euPAIx66hc7GzpKzCX@fP0uLT5Fo58@6bhRSmPPg7ek94BQaojBOiIFst1LZYfvFyYCAIAgYuguCFtBdIrSsGT5GRFclIubODze525hhWZbw0pRlY@iK3dH/@HrG5z8jj0hf6KPXS9b/Xl10g@xGM5CH@sjyJzbLz47@kTWR5/O@4GX26ZZG50p/mk260oxGZ7iqbxrO6lheayj8U8yLvZUa/9SVDMHMjdoX1j2OipN7Sz@ULiqLORZu7uzzX/zuYUFfAZbfEE7/AA" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.informatik.uni-kiel.de/%7Epakcs/" rel="nofollow noreferrer">Curry (PAKCS)</a>, 116 bytes</h1>
<pre class="lang-haskell prettyprint-override"><code>p&quot;(var &quot;a x|elem a x=0
p&quot;(app &quot;(a++' ':b)x=a#x+b#x
p&quot;(abs &quot;(a++' ':b)x|all(&gt;'@')a=b#(a:x)
(#)(k++n++&quot;)&quot;)=p k n
(#[])
</code></pre>
<p><a href="https://tio.run/##VU7BCsIwFLv3K0IrrI@ieB5UvHrSu3h43cYYm7V0Tirs3@foTuaQhOSQVFOM333gvhqXJUj94QjJSHMzNE@sxh7FGnMIWNmYAkXpKFlWyTiVcufGv27mYdCn4lwQW6c0l4mEVqR7Y7wxkiTZgB5etFar@4OWJ3ceZYlbbIapbg6XKzSJnFrULwGE2Pk3dmixzTGyOORj@TTTpo5WyEX8AA" rel="nofollow noreferrer" title="Curry (PAKCS) – Try It Online">Try it online!</a></p>
<p><code>g</code> returns <code>0</code> if there is a match and fails to find a match if there is none.</p>
<h2>Explanation</h2>
<p>This looks and sort of works like a Haskell answer might.  However Curry's pattern matches are way more powerful than Haskell's because it has a trick up it's sleeve.  As well as a functional programming language Curry is a logical language.  It has non-determinism.</p>
<p>In Haskell a pattern either matches or it doesn't.  In Curry a pattern can match a string multiple ways and it will follow through each to find the one you meant.  So</p>
<pre><code>p(&quot;(app &quot;++a++' ':b++&quot;)&quot;)
</code></pre>
<p>Will cold potentially match many things.  For example</p>
<pre><code>p&quot;(app (var x) (var y))&quot;
</code></pre>
<p>can break that apart at any space in the string.
Curry will match all of them and attempt to run them.  All the bad ones will fail later down the line.</p>
</div>
<div id="pu2" class="pu"><h2><a href="https://codegolf.stackexchange.com/q/62886/2338">Tiny Lisp</a>, 318</h2>
<pre class="lang-lisp prettyprint-override"><code>(d C(q((E L)(i(e L())0(i(e E(h L))1(C E(t L)))))))(d H(q((le li)(i(e()li)(e le 0)(H(s le 1)(t li))))))(d I(q((L X)(i(e(q abs)(h L))(i(H 3 L)(i(C(h(t L))X)0(I(h(t(t L)))(c(h(t L))X)))0)(i(e(q var)(h L))(i(H 2 L)(i(C(h(t L))X)1 0)0)(i(e(q app)(h L))(i(H 3 L)(i(I(h(t L))X)(I(h(t(t L)))X)0)0)0))))))(d V(q(()(L)(I L()))))
</code></pre>
<p>This defines a macro <code>V</code> (for verify) which can be applied to a list, and will check whether it is of the proper form as defined in the question.</p>
<p>This can't do any checks on a lexical level, as Tiny Lisp has no string input (and not even a string type). Therefore it is running out of competition</p>
<p>Here are some test cases:</p>
<pre><code>------examples-from-question-----
((V (abs x (abs y (var x))))  ––→  1)
((V (app (abs x (var x)) (var x)))  ––→  0)
((V (abs x (abs x (var x))))  ––→  0)
----examples-from-TIO----
((V (var x))  ––→  0)
((V (abs vv (var vv)))  ––→  1)
((V (abs xy (var fg)))  ––→  0)
((V (abs x (abs y (var x))))  ––→  1)
((V (app (abs x (var x)) (var x)))  ––→  0)
((V (abs x (app (var x) (var x))))  ––→  1)
((V (app (abs x (app (var x) (var x))) (abs y (app (var y) (var y)))))  ––→  1)
((V (abs x (abs x (var x))))  ––→  0)
((V (abs x (abs y (abs y (var x)))))  ––→  0)
((V (abs (var)))  ––→  0)
---reject---------
((V uuuuuuuuu)  ––→  0)
((V (mmm hummus))  ––→  0)
((V (abs x (var y)))  ––→  0)
((V (abs x (abs x (var x))))  ––→  0)
((V (app (abs x (var x)) (var x)))  ––→  0)
((V (abs (var k) (var (vark k))))  ––→  0)
((V (abs x (abs y (abs y (var x)))))  ––→  0)
((V (abs x (var x)))  ––→  1)
--------accept--------
((V (abs x (var x)))  ––→  1)
((V (abs x (abs y (var x))))  ––→  1)
((V (abs xx (app (var xx) (var xx))))  ––→  1)
((V (app (abs ab (app (var ab) (var ab))) (abs ab (app (var ab) (var ab)))))  ––→  1)
</code></pre>
<p>The last &quot;reject&quot; case (with the missing space) is accepted, as we are parsing this as a tiny lisp list, not as a lambda.
The test cases with unbalanced parentheses can't even be run.</p>
<p>Here is the code formatted, and with some comments (I've extended the reference implementation of Tiny Lisp to include Python-style line comments).
(The comments all start with <code>#!</code> because that can be handled by my automated whitespace-and-comment-remover made for Ceylon.)</p>
<pre><code>#! tinylisp.py

#! Parse a lambda for correctness. 
#! Question: https://codegolf.stackexchange.com/q/233453/2338
#! My answer: https://codegolf.stackexchange.com/a/233925/2338

#! checks whether some element is contained in a list.
(d C #! for &quot;contains&quot;
   (q ((E L) #! E = the element to be checked
             #! L = the list in which the element is searched
       (i (e L ())
          0
          (i (e E (h L))
             1
             (C E (t L))
          )
       )
      )
   )
)

#! checks whether a list has a specified length.
#! len = expected length
#! list = list to check
(d H #! for has-length
   (q ((le li) #! le = the asserted length
               #! li = the list to check
       (i (e () li)
          (e le 0)
          (H (s le 1) (t li))
       )
      )
   )
)

#! This is the main working force here.
#! I (for &quot;is-valid&quot;) checks (recursively) whether a lambda expression is valid
#! in a given context of defined variable names.
(d I
   (q ((L X)
       #! L = candidate for a lambda function,
       #! X (context) = list of defined variable names
       (i (e (q abs) (h L))
          (i (H 3 L)
             (i (C (h (t L)) X)
                0
                (I (h (t (t L))) (c (h (t L)) X)))
             0)
          (i (e (q var) (h L))
             (i (H 2 L) 
                (i (C (h (t L)) X)
                   1
                   0)
                0
             )
             (i (e (q app) (h L))
                (i (H 3 L)
                   (i (I (h (t L)) X)
                      (I (h (t (t L))) X)
                      0)
                   0)
                0
             )
          )
       )
      )
   )
)

#! V (for &quot;verify&quot;) is the entry point to call from the outside.
#! `(V (...))` returns 1 when it's a valid lambda expression, 0 when it is not.
(d V
   (q (()
       (L)
       (I L ())
      )
   )
)
</code></pre>
</div>
<div id="pu3" class="pu"><h1>Scala, 293 bytes</h1>
<p>The function that does all the work:</p>
<pre class="lang-scala prettyprint-override"><code>def f(s:Any,c:Set[Any]=Set()):Option[Any]=s match{case
s&quot;(var $v)$r&quot;=&gt;Option.when(c(v))(r)case
s&quot;(abs $v $r&quot;=&gt;if(!c(v)&amp;v.matches(&quot;[a-z]+&quot;))f(r,c+v).collect{case s&quot;)$r&quot;=&gt;r}else None case
s&quot;(app $o&quot;=&gt;f(o,c).collect{case s&quot; $r&quot;=&gt;f(r,c)}.flatten.collect{case s&quot;)$r&quot;=&gt;r}case
_=&gt;None}
</code></pre>
<p>This one simply turns an <code>Option</code> into a <code>Boolean</code>.</p>
<pre class="lang-scala prettyprint-override"><code>f(_)==Some(&quot;&quot;)
</code></pre>
<p><a href="https://scastie.scala-lang.org/rKZTRkezR8ihidaHyjdUbQ" rel="nofollow noreferrer">Try it in Scastie!</a></p>
<p>Ungolfed:</p>
<pre class="lang-scala prettyprint-override"><code>//sexpr is the string to parse, ctx is the context (a Set[String] in reality)
//If valid, it will return a Some containing the rest of the string, otherwise a None
def f(sexpr: Any, ctx: Set[Any] = Set()): Option[Any] = sexpr match {
  case s&quot;(var $varName)$rest&quot; =&gt;
    //Check if varName is defined, and only then return the rest
    Option.when(ctx.contains(varName))(rest)
  case s&quot;(abs $varName $rest&quot; =&gt;
    //Make sure varName isn't already defined and that it's a valid name
    if (!ctx.contains(varName) &amp;&amp; varName.matches(&quot;[a-z]+&quot;))
      //If so, parse the rest, adding varName to the context
      f(rest, ctx + varName)
        .collect { case s&quot;)$rest&quot; =&gt; rest } //Ensure there's a matching `)`
    else None //If the name is invalid, so is the expression
  case s&quot;(app $first&quot; =&gt;
    //Try parsing the first argument
    f(first, c)
      //Ensure there's a space after it and parse the rest
      .collect { case s&quot; $rest&quot; =&gt; f(rest, ctx) }
      .flatten //Turn the Option[Option[String]] into an Option[String]
      .collect { case s&quot;)$rest&quot; =&gt; rest } //Ensure there's a matching `)`
  case _ =&gt; None //If it's not a var, abs, or app, it's invalid
}
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://www.perl.org/" rel="noreferrer">Perl 5</a> <code>-p</code>, 86 bytes</h1>
<p>Who said this can’t be solved with a regex? ☺</p>

<pre class="lang-perl prettyprint-override"><code>$_=reverse=~/^(\)(((\w+) (?=([^)]|(?1))* \4 ))rav|(?1) ((?!(?3))\w+ sb|(?1) pp)a)\()$/
</code></pre>
<p><a href="https://tio.run/##hcrBCsIwEIThV1mhhxlFiqjHkAcxVjaQgyB2SSS9iI9uLBa8eptv@C3l27G17uJyqimX5F79gEAAYdpQ4B1OA89P@B25lnAQMmv9WgC/gt@TcyslLqcZlQHs@tagZgKNRTTKgqp5Bn@D/BvwPdrjOt5L29oH" rel="noreferrer" title="Perl 5 – Try It Online">Try it online!</a></p>
<p>Outputs <code>1</code> for acceptance or the empty string for rejection. To get around restrictions on lookbehind, I reverse the input and use lookahead instead.</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/nxadm/rakudo-pkg" rel="noreferrer">Raku (Perl 6)</a> <code>-p</code>, 123 bytes</h1>

<pre class="lang-perl6 prettyprint-override"><code>my %v;my$r=rx[&quot;(abs &quot;(\w+)&lt;!{%v{$0}++}&gt;\s&lt;~~&gt;{--%v{$0}}&quot;)&quot;|&quot;(app &quot;&lt;~~&gt;\s&lt;~~&gt;&quot;)&quot;|&quot;(var &quot;(\w+)&lt;?{%v{$0}}&gt;&quot;)&quot;];$_=so m/^^$r$$/
</code></pre>
<p><a href="https://tio.run/##K0gtyjH7/z@3UkG1zDq3UqXItqgiWkkjMalYQUkjplxb00axWrWsWsWgVlu71i6m2Kauzq5aVxciVKukqVQDVFxQoKAEkoBIQwTLEotgJthDTagFScVaq8TbFucr5OrHxakUqajo//8PNgBsZWKSAoQD0p2YpAlnaGoSVKDJ9S@/oCQzP6/4v24BAA" rel="noreferrer" title="Perl 6 – Try It Online">Try it online!</a></p>
<p>First time golfing in Raku (this seemed like an apt challenge to give it a spin), so there's probably room for improvement. It's a simple parse of the text, using the <code>%v</code> hash to keep track of existing variables.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/233453/">233453</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




