<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::32383</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>102</td><td>PowerShell</td><td>210322T184051Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/221083#221083">mazzy</a></td></tr>
<tr d-ix="1"><td>174</td><td>PowerShell</td><td>210322T164413Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/221077#221077">Wasif</a></td></tr>
<tr d-ix="2"><td>164</td><td>C</td><td>140624T215925Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/32463#32463">Level Ri</a></td></tr>
<tr d-ix="3"><td>027</td><td>Jelly</td><td>201224T221256Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/216865#216865">xigoi</a></td></tr>
<tr d-ix="4"><td>nan</td><td>GolfScript</td><td>140624T125005Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/32421#32421">Ilmari K</a></td></tr>
<tr d-ix="5"><td>099</td><td>Python 2</td><td>140624T172819Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/32437#32437">Cees Tim</a></td></tr>
<tr d-ix="6"><td>nan</td><td></td><td>200430T013712Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/204175#204175">Bambelem</a></td></tr>
<tr d-ix="7"><td>138</td><td>APLNARS</td><td>181004T162308Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/173364#173364">user5898</a></td></tr>
<tr d-ix="8"><td>208</td><td>Bash</td><td>181002T232320Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/173253#173253">Michael </a></td></tr>
<tr d-ix="9"><td>258</td><td>Bash</td><td>140624T045309Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/32395#32395">Riot</a></td></tr>
<tr d-ix="10"><td>260</td><td>Java 7</td><td>160916T070107Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/93431#93431">Kevin Cr</a></td></tr>
<tr d-ix="11"><td>036</td><td>CJam</td><td>141207T083741Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/42232#42232">Optimize</a></td></tr>
<tr d-ix="12"><td>110</td><td>TSQL 2012</td><td>140701T215600Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/32801#32801">Michael </a></td></tr>
<tr d-ix="13"><td>056</td><td>J  56 26? char</td><td>140701T211655Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/32798#32798">algorith</a></td></tr>
<tr d-ix="14"><td>114</td><td>JavaScript</td><td>140625T135706Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/32518#32518">thomaux</a></td></tr>
<tr d-ix="15"><td>083</td><td>J</td><td>140629T164500Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/32729#32729">jpjacobs</a></td></tr>
<tr d-ix="16"><td>119</td><td>Dart</td><td>140624T100701Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/32414#32414">lrn</a></td></tr>
<tr d-ix="17"><td>nan</td><td>Bash</td><td>140625T150752Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/32526#32526">user1640</a></td></tr>
<tr d-ix="18"><td>084</td><td>Ruby</td><td>140625T090520Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/32502#32502">Ventero</a></td></tr>
<tr d-ix="19"><td>085</td><td>Ruby 2.0</td><td>140624T062645Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/32401#32401">Paul Pre</a></td></tr>
<tr d-ix="20"><td>169</td><td>Haskell</td><td>140624T062542Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/32400#32400">YawarRaz</a></td></tr>
<tr d-ix="21"><td>097</td><td>J</td><td>140624T154315Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/32434#32434">seequ</a></td></tr>
<tr d-ix="22"><td>146</td><td>Haskell</td><td>140624T142418Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/32430#32430">ARRG</a></td></tr>
<tr d-ix="23"><td>084</td><td>Mathematica</td><td>140624T104724Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/32416#32416">alephalp</a></td></tr>
<tr d-ix="24"><td>375</td><td>Befunge 93</td><td>140624T085532Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/32411#32411">AndoDaan</a></td></tr>
<tr d-ix="25"><td>214</td><td>Python 2</td><td>140624T030823Z</td><td><a href="https://codegolf.stackexchange.com/questions/32383/determine-win-in-tic-tac-toe/32388#32388">undergro</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/TryItOnline/TioSetup/wiki/Powershell" rel="nofollow noreferrer">PowerShell</a>, <s>120</s> <s>116</s> <s>118</s> <s>112</s> <s>106</s> 102 bytes</h1>
<p>The more compact pattern inspired by <a href="https://codegolf.stackexchange.com/a/32502/80745">Ventero</a></p>
<p>Fixed to follow the rule 6.</p>

<pre class="lang-powershell prettyprint-override"><code>@(switch -r($args){($x='^(...)*111|^..1.1.1|1..(1|.1.)..1'){'win'}($x-replace1,0){'lose'}.{'cat'}})[0]
</code></pre>
<p><a href="https://tio.run/##RZDRTsMgFIbveYqTiAKmJeVmd0safQCNu1w20zF0M2grtOmSlmevHFo3uCHf//OdQFP3xvmTsXaiH7CGYSq578@tPkHuOK3cpxcDp5c123MppXhUSo17KRXuUUnJ1RiPIhImBtaff1iI9dyZxlbaqKyI1NbesCAHpquWhSC2xW4KhJSckIyzolC4VcEySAKBVCUYM6RJkHBCmCFG3VKOGPlVAXfgOmtgRYiAEe5hIBAXPdSVO2ZAzaUxujXH@GT6PkfO@M62ETzEn5iLKdi@bp4739bfL4eveGdXzipcm05r49GxXM7N7819rb39m5faNXjCIchv0wIJ0x8" rel="nofollow noreferrer" title="PowerShell – Try It Online">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/TryItOnline/TioSetup/wiki/Powershell" rel="nofollow noreferrer">PowerShell</a>, 174 bytes</h1>

<pre class="lang-powershell prettyprint-override"><code>param($a,$b,$c,$d,$e,$f,$g,$h,$i)@(&quot;$a$b$c&quot;,&quot;$a$d$g&quot;,&quot;$a$e$i&quot;,&quot;$b$e$h&quot;,&quot;$c$e$g&quot;,&quot;$c$f$i&quot;,&quot;$d$e$f&quot;,&quot;$g$h$i&quot;)|%{if($_-eq'XXX'){'win';exit}elseif($_-eq'OOO'){'lose';exit}};'cat'
</code></pre>
<p><a href="https://tio.run/##RclbCoMwEIXhvcgpUZiuwJfuIK95KzFOLpBWq4IF69rTpJaWYeDj/OOw8jR7jjGlUU/6VkMTOoIh9AQmWIIjeEJoLnUFjQ6mooIe7gAjFHQZvsBkuAP2SH1ebIGDz0vzOm3B1rie@SGUUqLZxBruouVnWHaOM/@qlLLUOMz8zXsrjF5ESkl@Tv3/DQ" rel="nofollow noreferrer" title="PowerShell – Try It Online">Try it online!</a></p>
<p>Trivial solution.</p>
<p>Takes 9 parameters for each key in board.</p>
</div>
<div id="pu2" class="pu"><h1>C, 164 bytes</h1>
<p>It's midnight here and <strong>I haven't done any testing</strong>, but I'll post the concept anyway. I'll get back to it tomorrow.</p>
<p>User inputs two octal numbers (I wanted to use binary but as far as I know C only supports octal):</p>
<p><code>a</code> represents the centre square, 1 for an X, 0 for an O</p>
<p><code>b</code> is a nine-digit number representing the perimeter squares, circling round the board starting in one corner and finishing in the same corner (with repeat of that corner only), 1 for an X, 0 for an O.</p>
<p><strong>There are two possible ways to win:</strong></p>
<ol>
<li><p>centre square is X (<code>a</code>=1) and two opposite squares are also X (<code>b&amp;b*4096</code> is nonzero)</p>
</li>
<li><p>three adjacent perimeter squares are X (<code>b/8 &amp; b &amp; b*8</code> is nonzero.) This is only a valid win if the middle square is an edge square, not a corner square, therefore it is necessary to apply the mask <code>m</code> also, to avoid the corner square cases.</p>
</li>
</ol>
<p><strong>Losing is detected using the variable c, which is the inverse of b.</strong></p>
<pre><code>int a,b,c,m=010101010;
main(){
    scanf(&quot;%o%o&quot;,a,b);c=b^0111111111;
    printf(&quot;%s&quot;,(a&amp;&amp;b&amp;b*4096)|(b/8&amp;b&amp;b*8&amp;m)?&quot;win&quot;:((!a&amp;&amp;c&amp;c*4096)|(c/8&amp;c&amp;c*8)?&quot;lose&quot;:&quot;cat&quot;));
}
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 27 bytes</h1>
<pre><code>ŒD,ŒdḢ€;;ZEƇFṀị“ẏż“¡ṇ⁽“Zƙċ»
</code></pre>
<p><a href="https://tio.run/##y0rNyan8///oJBedo5NSHu5Y9KhpjbV1lOuxdreHOxse7u5@1DDn4a7@o3uA9KGFD3e2P2rcC2RGHZt5pPvQ7v///0dHG@kY6RjG6gBpQx0jIG0IpmMB" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p>Input is a list of lists of ints: 0 = nothing, 1 = circle, 2 = cross.</p>
<h2>Explanation</h2>
<pre><code>ŒD,ŒdḢ€;;ZEƇFṀị“ẏż“¡ṇ⁽“Zƙċ»   Main monadic link
ŒD                            Diagonals
  ,                           Pair with
   Œd                           Antidiagonals
     Ḣ€                       Head (first item) of each
                              [the main diagonal and antidiagonal]
       ;                      Join with the input
        ;                     Join with the input
         Z                      zipped (transposed)
                              [the diagonals, rows and columns]
           Ƈ                  Filter by
          E                     All elements equal?
            F                 Flatten
             Ṁ                Maximum
              ị               Index into (1-indexed)
               “ẏż“¡ṇ⁽“Zƙċ»     [&quot;lose&quot;, &quot;win&quot;, &quot;cat&quot;]
</code></pre>
</div>
<div id="pu4" class="pu"><h2>GolfScript, 63 + 27 = 90 bytes</h2>
<p>I originally submitted the following 27-byte entry that exploited a loophole in the rules (as written at the time of submission) allowing a redundant input encoding:</p>
<pre><code>70&amp;.{~&quot;win&quot;&quot;lose&quot;if}&quot;cat&quot;if
</code></pre>
<p>The input format for this entry is a string consisting of eight octal digits, each (redundantly) encoding three consecutive board squares:</p>
<ul>
<li>The first three digits each encode a single row of the board, from top down and left to right.</li>
<li>The following three digits each encode a single column of the board, from left to right and top down.</li>
<li>The final two digits each encode one of the diagonals (first from top left to bottom right, then from bottom left to top right).</li>
</ul>
<p>To encode a sequence (row / column / diagonal) of three squares as an octal digit, replace every <code>x</code> in the sequence with a 1 and every <code>o</code> with a 0, and interpret the resulting sequence of ones and zeros as a binary number between 0 and 7 inclusive.</p>
<p>This input format is quite redundant (all board positions are encoded at least twice, with the center position encoded four times), but it <em>does</em> unambiguously represent any possible state of a completely filled tic-tac-toe board, and does not <em>directly</em> encode the winner into the input.</p>
<p>The input may, optionally, contain spaces or other delimiters between digits.  In fact, all the program <em>really</em> cares about is whether or not the input string contains the digits <code>7</code> or <code>0</code>.</p>
<p>For example, the example board:</p>
<pre><code>|x|x|o|
|x|o|x|
|o|o|x|
</code></pre>
<p>may be represented by the input:</p>
<pre><code>651 643 50
</code></pre>
<p>To make testing the program above easier, I also provided a 63-byte GolfScript program to convert an ASCII art board layout, as shown above, into an input string suitable for this program:</p>
<pre><code>.&quot;XOxo&quot;--[{1&amp;!}/]:a[3/.zip&quot;048642&quot;{15&amp;a=}%3/]{{2base&quot;&quot;+}%}%&quot; &quot;*
</code></pre>
<p>This converter ignores any characters other than <code>x</code> and <code>o</code>, in either case, in its input.  It produces a single digit string (complete with space delimiters as shown above) suitable for feeding into the win-determining program above, so <strong>the concatenation of these two programs can be used to determine the winner directly from the ASCII art board</strong>, and thus still qualifies as a valid entry under the current challenge rules:</p>
<pre><code>.&quot;XOxo&quot;--[{1&amp;!}/]:a[3/.zip&quot;048642&quot;{15&amp;a=}%3/]{{2base&quot;&quot;+}%}%&quot; &quot;*70&amp;.{~&quot;win&quot;&quot;lose&quot;if}&quot;cat&quot;if
</code></pre>
<p><a href="https://tio.run/##S8/PSStOLsosKPn/X08pwr8iX0lXN7raUE2xVj/WKjHaWF@vKrNAycDEwszESKna0FQt0bZW1Vg/trraKCmxOFVJSbtWtVZVSUFJy9xATa@6Tqk8M09JKScfKJWZVquUnFgCpP//r6kAwvwaLjBZAaTzwTQA" rel="nofollow noreferrer" title="GolfScript – Try It Online">Try it online!</a></p>
<p>Of course, the input format converted is not particularly well optimized and the combined program could easily be golfed further.  However, rather than attempting to re-golf a six-year-old solution, I prefer to just keep it as close to its originally submitted form as current rules permit.</p>
<p>Ps. Here's a reverse converter, just to demonstrate that the redundant input format for the 27-byte version indeed does unambiguously represent the board:</p>
<pre><code>.56,48&gt;-- 3&lt;{2base-3&gt;{&quot;ox&quot;=}%n}%&quot;|&quot;.@@*+);
</code></pre>
</div>
<div id="pu5" class="pu"><h1>Python 2, 99 bytes</h1>
<p>Similar to <a href="https://codegolf.stackexchange.com/a/32401/4999">the Ruby answer</a>:</p>
<pre class="lang-python prettyprint-override"><code>def t(b):print['win'if w&amp;b==w else'lose'if w&amp;~b==w else'cat'for w in 448,56,7,292,146,73,273,84][0]
</code></pre>
<p>The input is the binary format described in the question: <code>1</code> for X, <code>0</code> for O, left-to-right, top-to-bottom. For example, <code>0b101001110</code> represents</p>
<pre><code>XOX
OOX
XXO
</code></pre>
<p>which leads to output: <code>cat</code></p>
</div>
<div id="pu6" class="pu"><h1>Python3 - 188 w. different approaches to evaluation</h1>
<p>Found the subject yesterday on Reddit and was fascinated. It was a simple code just to determine victory. Same night I made up my own version. Today i found this codegolf thread. [EDIT: 'blabla'] I am amazed about the different answers and possibilities within the other languages! Nice!</p>
<h3>188 Python3 Code</h3>
<p>EDIT: Now Meeting Requirements 1-5</p>
<p>Input-Style: Player p=0/1 and board b=(1,1,1,0,1,0,1,0,1)</p>
<pre><code>def t(b,p):
    s,c,l,w=0,&quot;cat&quot;,&quot;loose&quot;,&quot;win&quot;
    for i in 1,2,3,4:
        u=2*i-1  
        a=i*i-5*i+3
        if b[4]==b[4+i]==b[4-i]:
            if p==b[4]:s+=1
            else:s-=1            
        if b[u]==b[u+a]==b[u-a]:
            if p==b[u]:s+=1
            else:s-=1
    if s&gt;0:c=w
    if s&lt;0:c=l
    return c
</code></pre>
<h2>Victory Check Codes</h2>
<h3>103 Python3 - 'Square-Function'</h3>
<p>EDIT1: nicer with &quot;a==b==c==p&quot; instead of &quot;a+b+c==3*p&quot;</p>
<pre><code>def t(b,p):
    for i in 1,2,3,4:
        u=2*i-1  
        a=i*i-5*i+3   
        if b[4]==b[4+i]==b[4-i]==p or b[u]==b[u+a]==b[u-a]==p:return True
</code></pre>
<p>Explanation: Term for a based on f(u=1)=f(u=7)=1 f(u=3)=f(u=5)=3</p>
<h3>113 Python3 - 'Magic Square'</h3>
<p>Input just with board: Player is „1“, Oponent „0“</p>
<pre><code>def t(b):
    n=[x*y for x,y in zip(b,(2,9,4,7,5,3,6,1,8))]
    if 15 in [x+y+z for x in n for y in n if x!=y for z in n if z!=x and z!=y]:return True
</code></pre>
<p>Explanation: Sum has to be 15 in Magic Square</p>
<h3>119 Python3 - 'Oneliner'</h3>
<p>inspired by Reddit Solution from user 'Xelf'</p>
<pre><code>def t(b,p):
    if 3*p in [b[x]+b[y]+b[z] for x,y,z in [(0,1,2),(3,4,5),(6,7,8),(0,3,6),(1,4,7),(2,5,8),(0,4,8),(2,4,6)]]:return True
</code></pre>
<hr />
<p>@Ad Hoc Garf Hunter Thank You for the Feedback! Though i am a bit embarassed and sorry i don´t even know what 'stdin' is about. Just want to contribute some ideas and learn. Thank you for the comment on assignment and whitespaces! I just corrected it.
EDIT: Hope to meet the rules now. I understand i could make spaces instead of tabs, but that just looks nasty.</p>
</div>
<div id="pu7" class="pu"><h1>APL(NARS), 69 chars, 138 bytes</h1>
<pre><code>{w←3 3⍴⍵⋄x←(+/1 1⍉⊖w),(+/1 1⍉w),(+⌿w),+/w⋄3∊x:'win'⋄0∊x:'lose'⋄'cat'}
</code></pre>
<p>The input should be one 3x3 matrix or one linear array of 9 element that can be only 1 (for X) and 0 (for O), the result will be &quot;cat&quot; if nobody wins, &quot;lose&quot; if O wins, &quot;win&quot; if X wins. There is no check for one invalid board or input is one array has less than 9 element or more or check each element &lt;2.</p>
<p>As a comment: it would convert the input in a 3x3 matrix, and build one array named &quot;x&quot; where elements are the sum each row column and diagonal.</p>
<p>Some test see example showed from others:</p>
<pre><code>  f←{w←3 3⍴⍵⋄x←(+/1 1⍉⊖w),(+/1 1⍉w),(+⌿w),+/w⋄3∊x:'win'⋄0∊x:'lose'⋄'cat'}
  f 1 2 3
win
  f 0 0 0
lose
  f 1 0 1  1 0 1  1 0 1
win
  f 0 1 1  1 0 0  1 1 1
win
  f 0 0 1  1 0 1  1 1 0
lose
  f 1 1 0  0 1 1  1 0 0
cat
  f 1 1 0  0 1 0  0 0 1
win
  f 1 1 0  1 0 1  0 0 1
lose
</code></pre>
</div>
<div id="pu8" class="pu"><h1>Bash: 208 chars</h1>

<pre><code>y(){ tr '01' '10'&lt;&lt;&lt;$@;}
f(){ x=$[($1&amp;$2&amp;$3)|($1&amp;$5&amp;$9)|($1&amp;$4&amp;$7)|($2&amp;$5&amp;$8)|($3&amp;$5&amp;$7)|($3&amp;$6&amp;$9)|($4&amp;$5&amp;$6)|($7&amp;$8&amp;$9)]; }
f $@;w=$x
f $(y $@)
([ $x -eq 1 ]&amp;&amp;echo lose)||([ $w -eq 1 ]&amp;&amp;echo win)||echo cat
</code></pre>

<p>To execute <code>bash tictactoe.sh 0 1 0 1 0 1 1 0 1</code></p>

<p>Inspired by <a href="https://codegolf.stackexchange.com/a/32395/23764">this answer</a>.</p>
</div>
<div id="pu9" class="pu"><h1>Bash: <s>283</s> <s>262</s> 258</h1>
<p>Featuring a relatively friendly interface.</p>

<pre class="lang-bash prettyprint-override"><code>t(){ sed 's/X/true/g;s/O/false/g'&lt;&lt;&lt;$@;}
y(){ t $(sed 's/X/Q/g;s/O/X/g;s/Q/O/g'&lt;&lt;&lt;$@);}
f(){($1&amp;&amp;$2&amp;&amp;$3)||($1&amp;&amp;$5&amp;&amp;$9)||($1&amp;&amp;$4&amp;&amp;$7)||($2&amp;&amp;$5&amp;&amp;$8)||($3&amp;&amp;$5&amp;&amp;$7)||($3&amp;&amp;$6&amp;&amp;$9)||($4&amp;&amp;$5&amp;&amp;$6)||($7&amp;&amp;$8&amp;&amp;$9)}
f $(t $@)&amp;&amp;echo win||(f $(y $@)&amp;&amp;echo lose)||echo cat
</code></pre>
<p>To execute <code>bash tictactoe.sh O X O X O X X O X</code></p>
<p>Note: the list of 9 positions is a standard matrix representation.  It doesn't matter if the board is represented as column major or row major, read from left to right or top to bottom - games of noughts and crosses (or tic tac toe if you insist) are symmetrical, so input order should be irrelevant to the result in every correct implementation, as long as input is linear.</p>
<p>Edit: Thanks to h.j.k for shorter function syntax suggestion.</p>
</div>
<div id="pu10" class="pu"><h1>Java 7, 260 bytes</h1>
<pre><code>String c(int[]s){int a[]=new int[8],x=0,y;for(;x&lt;3;x++){for(y=0;y&lt;3;a[x]+=s[x*3+y++]);for(y=0;y&lt;3;a[x+3]+=s[y++%3]);}for(x=0;x&lt;9;y=s[x],a[6]+=x%4&lt;1?y:0;a[7]+=x%2&lt;1&amp;x&gt;0&amp;x++&lt;8?y:0);x=0;for(int i:a)if(i&gt;2)return&quot;win&quot;;for(int i:a)if(i&lt;1)return&quot;loose&quot;;return&quot;cat&quot;;}
</code></pre>
<p><strong>Ungolfed &amp; test cases:</strong></p>
<p><a href="https://ideone.com/ARfs4J" rel="nofollow noreferrer">Try it here.</a></p>
<pre><code>class M{
  static String c(int[] s){
    int a[] = new int[8],
        x = 0,
        y;
    for(; x &lt; 3; x++){
      for(y = 0; y &lt; 3; a[x] += s[x * 3 + y++]);
      for (y = 0; y &lt; 3; a[x + 3] += s[y++ % 3]);
    }
    for(x = 0; x &lt; 9; y = s[x],
                      a[6] += x % 4 &lt; 1
                               ? y
                               : 0,
                      a[7] += x % 2 &lt; 1 &amp; x &gt; 0 &amp; x++ &lt; 8
                               ? y
                               : 0);
    x = 0;
    for(int i : a){
      if(i &gt; 2){
        return &quot;win&quot;;
      }
    }
    for(int i : a){
      if(i &lt; 1){
        return &quot;loose&quot;;
      }
    }
    return &quot;cat&quot;;
  }

  public static void main(String[] a){
    /*  xxo
        xox
        oox  */
    System.out.println(c(new int[]{ 1, 1, 0, 1, 0, 1, 0, 0, 1 }));
    /*  xxx
        ooo
        xxx  */
    System.out.println(c(new int[]{ 1, 1, 1, 0, 0, 0, 1, 1, 1 }));
    /*  xxo
        oox
        xox  */
    System.out.println(c(new int[]{ 1, 1, 0, 0, 0, 1, 1, 0, 1 }));
  }
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>loose
win
cat
</code></pre>
</div>
<div id="pu11" class="pu"><h1>CJam, <s>39 38</s> 36 characters</h1>
<pre><code>&quot;ᔔꉚ굌궽渒䗠脯뗠㰍㔚귇籾〳㎪䬔⹴쪳儏⃒ꈯ琉&quot;2G#b129b:c~
</code></pre>
<p>This is a base converted code for</p>
<pre><code>q3/_z__Wf%s4%\s4%]`:Q3'o*#&quot;win&quot;{Q'x3*#&quot;lose&quot;&quot;cat&quot;?}?
</code></pre>
<p>which is 52 characters long.</p>
<p>The input is simply the string representation of the board starting from top left, going row by row. For example:</p>
<pre><code>oxooxooox
</code></pre>
<p>which results in a <code>win</code> output. Or</p>
<pre><code>oxooxoxox
</code></pre>
<p>which results in a <code>cat</code> output, etc.</p>
<p>The code simply does the following three things:</p>
<ul>
<li><code>q3/_</code> - Split the string into parts of 3, i.e. per row</li>
<li><code>_z</code> - Copy the per row array and transpose into per column array.</li>
<li><code>__Wf%s4%</code> - Reverse each row and get the left to right diagonal. This is the secondary diagonal of the board.</li>
<li><code>\s4%</code> - Get the main diagonal of the board</li>
<li><code>]`</code> - Wrap everything in array and stringify the array.</li>
</ul>
<p>Now we have all possible groups of 3 from the board. We simply check for existence of &quot;ooo&quot; and &quot;xxx&quot; to determine the result.</p>
<p><a href="http://cjam.aditsu.net/" rel="nofollow noreferrer">Try it online here</a></p>
</div>
<div id="pu12" class="pu"><h1>T-SQL (2012),110</h1>
<p><code>select max(iif(@&amp;m=0,'lose',iif(@&amp;m=m,'win','cat')))from(VALUES(292),(146),(73),(448),(56),(7),(273),(84))z(m)</code></p>
<p>Input is a hex number. This is pretty much a translation of the ruby solution into T-SQL pretty nice and neat.</p>
</div>
<div id="pu13" class="pu"><h1>J - 56 (26?) char</h1>

<p>Input is given a 3x3 matrix of nine characters, because J can support that as a datatype, LOL.</p>

<pre><code>(win`lose`cat{::~xxx`ooo&lt;./@i.&lt;"1,&lt;"1@|:,2 7{&lt;/.,&lt;/.@|.)
</code></pre>

<p>Examples:</p>

<pre><code>   NB. 4 equivalent ways to input the example board
   (3 3 $ 'xxoxoxoox') ; (_3 ]\ 'xxoxoxoox') ; ('xxo','xox',:'oox') ; (];._1 '|xxo|xox|oox')
+---+---+---+---+
|xxo|xxo|xxo|xxo|
|xox|xox|xox|xox|
|oox|oox|oox|oox|
+---+---+---+---+
   (win`lose`cat{::~xxx`ooo&lt;./@i.&lt;"1,&lt;"1@|:,2 7{&lt;/.,&lt;/.@|.) 3 3 $ 'xxoxoxoox'
lose
   wlc =: (win`lose`cat{::~xxx`ooo&lt;./@i.&lt;"1,&lt;"1@|:,2 7{&lt;/.,&lt;/.@|.)
   wlc (3 3 $ 'xoxoxooxo')
cat
   wlc (3 3 $ 'xxxoooxxx')
win
</code></pre>

<p>If we are allowed the Golfscriptish encoding of octal digits redundantly representing the state of each row, column, and diagonal, then it's just 26 characters:</p>

<pre><code>   win`lose`cat{::~7 0&lt;./@i.] 6 5 1 6 4 3 5 0
lose
   f=:win`lose`cat{::~7 0&lt;./@i.]
   f  7 0 7 5 5 5 5 5
win
</code></pre>
</div>
<div id="pu14" class="pu"><h2>JavaScript, <s>133</s>, 114 characters</h2>

<pre><code>r = '/(1){3}|(1.{3}){2}1|(1.{4}){2}1|(1\|.1.\|1)/';alert(i.match(r)?'WIN':i.match(r.replace(/1/g,0))?'LOSS':'CAT')
</code></pre>

<p>The input <code>i</code> is a simple string with delimiters for the rows, i.e. <code>100|001|100</code></p>

<p>Edit: updated my method to replace the 1s in the regex with zeroes to check for the loss case.</p>
</div>
<div id="pu15" class="pu"><h2>J : 83</h2>

<pre><code>(;:'lose cat win'){::~&gt;:*(-&amp;(+/@:(*./"1)@;@(;((&lt;0 1)&amp;|:&amp;.&gt;@(;|.)(,&lt;)|:)))-.)3 3$'x'=
</code></pre>

<p>Usage: just append a string of x's and o's and watch the magic work. eg. 'xxxoooxxx'.</p>

<p>The inner verb <code>(+/@:(*./"1)@;@(;((&lt;0 1)&amp;|:&amp;.&gt;@(;|.)(,&lt;)|:)))</code> basically boxes together the original binary matrix, with the transpose boxed together with the 2 diagonals.
These results are razed together ; row sums are taken to determine wins, and then summed. further I'll call this verb <code>Inner</code>.</p>

<p>For finding the winner, the difference of the scores between the normal and inversed binary matrices is taken by the hook <code>(-&amp;Inner -.)</code>.</p>

<p>The rest of the code simply makes the outputs, and selects the right one.</p>
</div>
<div id="pu16" class="pu"><h2>Dart - 119</h2>



<p>(See <a href="http://dartlang.org/" rel="nofollow">dartlang.org</a>).</p>

<p>Original version using RegExp: 151 chars.</p>

<pre class="lang-dart prettyprint-override"><code>main(b,{w:"cat",i,p,z}){
 for(p in["olose","xwin"])
   for(i in[0,2,3,4])
     if(b[0].contains(new RegExp('${z=p[0]}(${'.'*i}$z){2}')))
       w=p.substring(1);
  print(w);
}
</code></pre>

<p>Input on the command line is 11 characters, e.g., "xxx|ooo|xxx". Any non-xo character can be used as delimiter.</p>

<p>Leading whitespace and newlines should be omitted before counting characters, but I cut away the internal whitespace where possible.
I wish there was a smaller way to make the substring.</p>

<p>Recusive bit-base version: 119 chars.
Input must be a 9-bit number with 1s representing 'x' and 0s representing 'o'.</p>

<pre class="lang-dart prettyprint-override"><code>main(n){
  n=int.parse(n[0]);
  z(b,r)=&gt;b&gt;0?b&amp;n==b&amp;511?"win":z(b&gt;&gt;9,n&amp;b==0?"lose":r):r;
  print(z(0x9224893c01c01e2254,"cat"));
}
</code></pre>
</div>
<div id="pu17" class="pu"><h1>Bash, <del>107</del> 103</h1>

<p>Generates and runs a sed script.</p>

<p>I/O format: <code>oxo-oox-xoo</code> outputs <code>lose</code> (use a <code>-</code> to separate rows). Input on stdin.
Requires GNU sed for the <code>c</code> command.</p>

<p>I've interpreted rule 5 as "if both win and lose are possible, choose win".</p>

<h2>Main Code</h2>

<p>This is the actual answer.</p>

<p>Nothing interesting really. It defines <code>$b</code> as <code>/cwin</code> to save characters, then defines the win condition part of the script, then uses <code>sed y/x/o/\;s$b/close/</code> to convert <code>x</code> to <code>o</code> and <code>cwin</code> to <code>close</code> (thereby generating the lose conditions). It then sends the two things and <code>ccat</code> (which will output <code>cat</code> if no win/lose condition is matched) to sed.</p>

<pre class="lang-bsh prettyprint-override"><code>b=/cwin
v="/xxx$b
/x...x...x$b
/x..-.x.-..x$b
/x-.x.-x$b"
sed "$v
`sed y/x/o/\;s$b/close/&lt;&lt;&lt;"$v"`
ccat"
</code></pre>

<h2>Generated Code</h2>

<p>This is the sed script generated and run by the Bash script.</p>

<p>In the regexes, <code>.</code> matches any character and after them <code>cTEXT</code> prints TEXT and exits if the regex is matched.</p>

<p>This can run as a standalone sed script. It's 125 characters long, you can count it as another solution.</p>

<pre><code>/xxx/cwin
/x...x...x/cwin
/x..-.x.-..x/cwin
/x-.x.-x/cwin
/ooo/close
/o...o...o/close
/o..-.o.-..o/close
/o-.o.-o/close
ccat
</code></pre>
</div>
<div id="pu18" class="pu"><h2>Ruby, 84 characters</h2>

<pre><code>$&gt;&lt;&lt;(gets.tr("01","10")[r=/0..(0|.0.)..0|000(...)*$|^..0.0.0/]?:win:~r ?:lose: :cat)
</code></pre>

<p>Simple, RegExp based solution. The input format is a 9-digit binary string, e.g. <code>110101001</code> for the example board given in the question.</p>

<h2>Ruby, 78 characters</h2>

<pre><code>$&gt;&lt;&lt;(gets.tr("ox","xo")[r=/o...(o|.o.)...o|ooo|o_.o._o/]?:win:~r ?:lose: :cat)
</code></pre>

<p>Input format: <code>xxo_xox_oox</code></p>
</div>
<div id="pu19" class="pu"><h2>Ruby 2.0, 85 characters</h2>

<p>Here's a simple bitmask-based solution in Ruby:</p>

<pre class="lang-ruby prettyprint-override"><code>d=gets.hex
$&gt;&lt;&lt;[292,146,73,448,56,7,273,84].map{|m|d&amp;m&lt;1?:lose:d&amp;m&lt;m ?:cat: :win}.max
</code></pre>

<p>The board is represented as a hex number, made up of nine bits corresponding to the nine squares.  1 is an <code>X</code>, 0 is an <code>O</code>.  This is just like the <code>0x1a9</code> example in the question, though the <code>0x</code> is optional!</p>

<p>There's probably a better way to do the bitmasks then just hardcoding a big list.  I'll happily take suggestions.</p>

<p>See it running <a href="http://ideone.com/91YLmq" rel="nofollow">on Ideone here</a>.</p>
</div>
<div id="pu20" class="pu"><h1>Haskell, 169</h1>

<pre><code>main=interact$(\x-&gt;last$"cat":[b|(a,b)&lt;-[("ooo","lose"),("xxx","win")],any(==a)x]).(\x-&gt;x++(foldr(zipWith(:))(repeat[])x)++map(zipWith(!!)x)[[0..],[2,1,0]]).take 3.lines
</code></pre>

<p>Input format: "X" is represented only by <code>x</code>, "O" only by <code>o</code>. Within each row, characters are simultaneous without spaces, etc. Rows are separated by new lines.</p>

<p>Generates all possible rows/columns/diagonals, then filters <code>[("ooo","lose"),("xxx","win")]</code> by their existence on the board, then selects the second word in the tuple, so we know which players won. We prepend <code>"cat"</code> so that we can take the last element of the list as our winner. If both players won, <code>"win"</code> will be last (list comprehensions maintain order). Since <code>"cat"</code> is always first, if a winner exists, it will be chosen, but otherwise a last element still exists as prepending <code>"cat"</code> guarantees nonemptyness.</p>

<p>EDIT: Shaved 3 characters by changing last list comprehension to <code>map</code>.</p>
</div>
<div id="pu21" class="pu"><h2>J - 97 bytes</h2>

<p>Well, the simplest approach available. The input is taken as <code>111222333</code>, where the numbers represent rows. Read left-to-right. Player is <code>x</code> and enemy is <code>o</code>. Empty squares can be anything except <code>x</code> or <code>o</code>.</p>

<pre><code>f=:(cat`lose&gt;@{~'ooo'&amp;c)`('win'"_)@.('xxx'&amp;c=:+./@(r,(r|:),((r=:-:"1)(0 4 8&amp;{,:2 4 6&amp;{)@,))3 3&amp;$)
</code></pre>

<p>Examples: (NB. is a comment)</p>

<pre><code>   f 'xoxxoxxox' NB. Victory from first and last column.
win
   f 'oxxxooxxx' NB. Victory from last row.
win
   f 'ooxxoxxxo' NB. The example case, lost to a diagonal.
lose
   f 'xxooxxxoo' NB. Nobody won.
cat
   f 'xoo xx ox' NB. Victory from diagonal.
win
</code></pre>

<h3>Ungolfed code an explanation</h3>

<pre><code>row   =: -:"1                        Checks if victory can be achieved from any row.
col   =: -:"1 |:                     Checks if victory can be achieved from any column.
diag  =: -:"1 (0 4 8&amp;{ ,: 2 4 6&amp;{)@, Checks if victory can be achieved from diagonals.
check =: +./@(row,col,diag) 3 3&amp;$    Checks all of the above and OR's them.

f     =: (cat`lose &gt;@{~ 'ooo'&amp;check)`('win'"_)@.('xxx'&amp;check)
Check if you have won ........................@.('xxx'&amp;check)
 If yes, return 'win' .............. ('win'"_)
 If not                   (cat`lose &gt;@{~ 'ooo'&amp;check)
  Check if enemy won ................... 'ooo'&amp;check
   If yes, return 'lose'   ---`lose &gt;@{~
   If not, return 'cat'    cat`---- &gt;@{~
</code></pre>
</div>
<div id="pu22" class="pu"><h2>Haskell, 146 chars</h2>

<blockquote>
  <p>To make things interesting, you get to determine your input structure for the state- which you must then explain.</p>
</blockquote>

<p>OK :). My representation of a board is one of those 126 characters</p>

<blockquote>
  <p>ĻŃŇŉŊœŗřŚşšŢťŦŨųŷŹźſƁƂƅƆƈƏƑƒƕƖƘƝƞƠƤƳƷƹƺƿǁǂǅǆǈǏǑǒǕǖǘǝǞǠǤǯǱǲǵǶǸǽǾȀȄȍȎȐȔȜȳȷȹȺȿɁɂɅɆɈɏɑɒɕɖɘɝɞɠɤɯɱɲɵɶɸɽɾʀʄʍʎʐʔʜʯʱʲʵʶʸʽʾˀ˄ˍˎː˔˜˭ˮ˰˴˼̌</p>
</blockquote>

<p>Here's the solution in 146 chars :</p>

<pre><code>main=interact$(\x-&gt;case(head x)of h|elem h "ĻŃœťŦŨųŷŹƁƂƅƈƕƠƤƳƿǂǆǞǤǵǾȀȳȿɁɅɑɒɘɝɠɤɵɽʀʐʽʾː˭ˮ˰˴˼̌"-&gt;"lose";h|elem h "ƏƝƞƹǁǈǑǝȍȺɆɈɶɾʎʸ"-&gt;"cat";h-&gt;"win")
</code></pre>

<p>And here's how it works, as an haskell script :</p>

<pre><code>import Data.List (subsequences, (\\))
import Data.Char (chr)

-- A set of indexes [0-8] describing where on the board pieces of a single color have been played
-- For example the board "OxO;Oxx;xxO" is indexes [0,2,3,8]
type Play = [Int]

-- There are 126 filled tic tac toe boards when X plays first.
--      (This is a combination of 4 OHs among 9 places : binomial(9 4) = 126)
-- perms returns a list of all such possible boards (represented by the index of their OHs).
perms = filter (\x -&gt; 4 == length x) $ subsequences [0..8]

-- We now create an encoding for plays that brings them down to a single char.
-- The index list can be seen as an 9 bit binary word [0,2,3,8] -&gt; '100001101'
-- This, in turn is the integer 269. The possible boards give integers between 15 and 480.
-- Let's call those PlayInts
type PlayInt = Int

permToInt [] = 0
permToInt (x:xs) = (2 ^ x) + permToInt xs 

-- Since the characters in the range 15-480 are not all printable. We offset the chars by 300, this gives the range 
-- ĻŃŇŉŊœŗřŚşšŢťŦŨųŷŹźſƁƂƅƆƈƏƑƒƕƖƘƝƞƠƤƳƷƹƺƿǁǂǅǆǈǏǑǒǕǖǘǝǞǠǤǯǱǲǵǶǸǽǾȀȄȍȎȐȔȜȳȷȹȺȿɁɂɅɆɈɏɑɒɕɖɘɝɞɠɤɯɱɲɵɶɸɽɾʀʄʍʎʐʔʜʯʱʲʵʶʸʽʾˀ˄ˍˎː˔˜˭ˮ˰˴˼̌
-- Of all distinct, printable characters
uOffset = 300

-- Transform a PlayInt to its Char representation
pIntToUnicode i = chr $ i + uOffset

-- Helper function to convert a board in a more user friendly representation to its Char
-- This accepts a representation in the form "xooxxxoxo"
convertBoard s = let play = map snd $ filter (\(c, i) -&gt; c == 'o') $ (zip s [0..]) :: Play 
    in pIntToUnicode $ permToInt play

--
-- Now let's cook some data for our final result
--  

-- All boards as chars
allUnicode = let allInts = map permToInt perms 
    in map pIntToUnicode allInts

-- Now let's determine which boards give which outcome.

-- These are all lines, columns, and diags that give a win when filled
wins = [
        [0,1,2],[3,4,5],[6,7,8], -- lines
        [0,3,6],[1,4,7],[2,5,8], -- columns
        [0,4,8],[2,4,6] -- diagonals
    ]

isWin :: Play -&gt; Bool   
isWin ps = let triplets = filter (\x -&gt; 3 == length x) $ subsequences ps -- extract all triplets in the 4 or 5 moves played
    in any (\t -&gt; t `elem` wins) triplets -- And check if any is a win line

-- These are OH wins
oWins = filter isWin perms
-- EX wins when the complement board wins
xWins = filter (isWin . complement) perms
    where complement ps = [0..9] \\ ps
-- And it's stalemate otherwise
cWins = (perms \\ oWins) \\ xWins

-- Write the cooked data to files
cookData = let toString = map (pIntToUnicode . permToInt) in do
  writeFile "all.txt" allUnicode
  writeFile "cWins.txt" $ toString cWins
  writeFile "oWins.txt" $ toString oWins
  writeFile "xWins.txt" $ toString xWins

-- Now we know that there are 48 OH-wins, 16 stalemates, and 62 EX wins (they have more because they play 5 times instead of 4).
-- Finding the solution is just checking to which set an input board belongs to (ungolfed :)
main = interact $ \x -&gt; case (head x) of -- Only consider the first input char
    h | elem h "ĻŃœťŦŨųŷŹƁƂƅƈƕƠƤƳƿǂǆǞǤǵǾȀȳȿɁɅɑɒɘɝɠɤɵɽʀʐʽʾː˭ˮ˰˴˼̌" -&gt; "lose" -- This string is == oWins
    h | elem h "ƏƝƞƹǁǈǑǝȍȺɆɈɶɾʎʸ" -&gt; "cat" -- And this one == cWins
    h -&gt; "win"
</code></pre>
</div>
<div id="pu23" class="pu"><h1>Mathematica, 84 chars</h1>
<pre><code>a=Input[];Which[Max@#&gt;2,win,Min@#&lt;1,lose,1&gt;0,cat]&amp;@{Tr@a,Tr@Reverse@a,Tr/@a,Total@a}
</code></pre>
<p>Input format: <code>{{1, 1, 0}, {1, 0, 1}, {0, 0, 1}}</code></p>
</div>
<div id="pu24" class="pu"><h1>Befunge 93 - 375</h1>
<p>Takes a binary string as input.</p>
<pre><code>99&gt;~\1-:!!|&gt;v  
&gt;0v&gt;v&gt;v   &gt;^$&gt;v
^+ + +    0&lt;:p:
&gt;#+#+#+    ^246
^+ + +    0&lt;265
&gt;#+#+#+    ^pp6
^+ + +    0&lt;2++
 #+#+#+     55p
   0 0      552
  &gt;^&gt;^&gt;0v   +46
v+ + +  &lt;   ppp
&gt;0 + + + v  444
   v!!-3:&lt;&lt; 246
  v_&quot;ni&quot;v   ppp
  0v&quot; w&quot;&lt;   :+:
  \&gt;,,,,@   266
  -&gt;,,,@    555
  !^&quot;cat&quot;_^ 645
  !&gt;:9-! ^  +:+
  &gt;|        p:p
   &gt;&quot;eso&quot;v  6p6
 @,,,,&quot;l&quot;&lt;  246
            p2p
            &gt;^ 
  v       &lt;^  &lt;
</code></pre>
<p>Reads the string. Bruteforce writes it (the right most vertical strip) as a matrix in between the</p>
<pre><code>^+ + + 
&gt;#+#+#+
^+ + + 
&gt;#+#+#+
^+ + + 
 #+#+#+
</code></pre>
<p>adding lattice (idk). Determins the sum of the columns, rows, and two diagnals. Compares those values to 3 (&quot;win&quot;) or 0 (&quot;lose&quot;), else if all the values equal 1  or 2 then draw (&quot;cat&quot;).</p>
</div>
<div id="pu25" class="pu"><h1>Python 2 - 214 bytes</h1>

<pre><code>b=eval(raw_input())
s=map(sum,b)
w,l='win','lose'
e="if min(s)&lt;1:print l;a\nif max(s)&gt;2:print w;a"
exec e+'\ns=map(sum,zip(*b))\n'+e
m=b[1][1]
for i in 0,2:
 if m==b[0][i]==b[2][abs(i-2)]:print[l,w][m];a
print'cat'
</code></pre>

<p>I'm sure there are improvements to be made.</p>

<p>To run:</p>

<pre><code>python2 tictactoe.py &lt;&lt;&lt; '[[1,1,1],[1,0,1],[0,1,0]]'
</code></pre>

<p>which represents this board:</p>

<pre><code>X|X|X
-----
X|O|X
-----
0|X|0
</code></pre>

<p>Exits with a <code>NameError</code> exception in every case except <code>cat</code>.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/32383/">32383</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




