<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::12420</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>026</td><td>Jelly</td><td>160801T194831Z</td><td><a href="https://codegolf.stackexchange.com/questions/12420/too-fast-too-fourier-fft-code-golf/87321#87321">miles</a></td></tr>
<tr d-ix="1"><td>116</td><td>APLNARS</td><td>191019T053752Z</td><td><a href="https://codegolf.stackexchange.com/questions/12420/too-fast-too-fourier-fft-code-golf/194472#194472">user5898</a></td></tr>
<tr d-ix="2"><td>100</td><td>Octave</td><td>191018T055028Z</td><td><a href="https://codegolf.stackexchange.com/questions/12420/too-fast-too-fourier-fft-code-golf/194445#194445">ceilingc</a></td></tr>
<tr d-ix="3"><td>183</td><td>C gcc</td><td>170910T104159Z</td><td><a href="https://codegolf.stackexchange.com/questions/12420/too-fast-too-fourier-fft-code-golf/142321#142321">ceilingc</a></td></tr>
<tr d-ix="4"><td>150</td><td>Python</td><td>130830T232017Z</td><td><a href="https://codegolf.stackexchange.com/questions/12420/too-fast-too-fourier-fft-code-golf/12428#12428">jakevdp</a></td></tr>
<tr d-ix="5"><td>095</td><td>R</td><td>130904T121308Z</td><td><a href="https://codegolf.stackexchange.com/questions/12420/too-fast-too-fourier-fft-code-golf/12462#12462">plannapu</a></td></tr>
<tr d-ix="6"><td>179</td><td>Axiom</td><td>170811T225056Z</td><td><a href="https://codegolf.stackexchange.com/questions/12420/too-fast-too-fourier-fft-code-golf/138663#138663">user5898</a></td></tr>
<tr d-ix="7"><td>093</td><td>Matlab</td><td>150307T224850Z</td><td><a href="https://codegolf.stackexchange.com/questions/12420/too-fast-too-fourier-fft-code-golf/47538#47538">flawr</a></td></tr>
<tr d-ix="8"><td>113</td><td>Python 3</td><td>140414T195627Z</td><td><a href="https://codegolf.stackexchange.com/questions/12420/too-fast-too-fourier-fft-code-golf/25846#25846">Nayuki</a></td></tr>
<tr d-ix="9"><td>037</td><td>J</td><td>130906T181734Z</td><td><a href="https://codegolf.stackexchange.com/questions/12420/too-fast-too-fourier-fft-code-golf/12475#12475">miles</a></td></tr>
<tr d-ix="10"><td>076</td><td>Pari/GP</td><td>130831T115103Z</td><td><a href="https://codegolf.stackexchange.com/questions/12420/too-fast-too-fourier-fft-code-golf/12438#12438">P̲̳x͓L̳</a></td></tr>
<tr d-ix="11"><td>095</td><td>Mathematica</td><td>130831T011724Z</td><td><a href="https://codegolf.stackexchange.com/questions/12420/too-fast-too-fourier-fft-code-golf/12429#12429">miles</a></td></tr>
<tr d-ix="12"><td>259</td><td>C</td><td>140415T104522Z</td><td><a href="https://codegolf.stackexchange.com/questions/12420/too-fast-too-fourier-fft-code-golf/25858#25858">sanaris</a></td></tr>
<tr d-ix="13"><td>134</td><td>Python</td><td>130908T183229Z</td><td><a href="https://codegolf.stackexchange.com/questions/12420/too-fast-too-fourier-fft-code-golf/12485#12485">boothby</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Jelly, <s>31</s> <s>30</s> <s>28</s> 26 <a href="https://github.com/DennisMitchell/jelly/wiki/Code-page" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>LḶ÷$N-*×,N$+ḷF
s2Zß€ç/µ¹Ṗ?
</code></pre>
<p>This uses the Cooley-Tukey radix-2 recursive algorithm. For an un-golfed version, see my <a href="https://codegolf.stackexchange.com/a/12429/6710">answer</a> in Mathematica.</p>
<p><a href="http://jelly.tryitonline.net/#code=TOG4tsO3JE4tKsOXLE4kK-G4t0YKczJaw5_igqzDpy_CtcK54bmWPw&amp;input=&amp;args=WzEsIDIsIDMsIDRd" rel="nofollow noreferrer">Try it online</a> or <a href="http://jelly.tryitonline.net/#code=TOG4tsO3JE4tKsOXLE4kK-G4t0YKczJaw5_igqzDpy_CtcK54bmWPwrDh8WS4bmYJOKCrGrigbc&amp;input=&amp;args=W1sxLCAxLCAxLCAxXSwKIFsxLCAyLCAzLCA0XSwKIFs1LjI0NjI2LCAzLjkwNzQ2LCAzLjcyMzM1LCA1Ljc0NDI5LCA0Ljc5ODMsIDguMzQxNzEsIDQuNDY3ODUsIDAuNzYwMTM5XV0" rel="nofollow noreferrer">Verify multiple test cases</a>.</p>
<h2>Explanation</h2>
<pre><code>LḶ÷$N-*×,N$+ḷF  Helper link. Input: lists A and B
L               Get the length of A
   $            Operate on that length
 Ḷ                Make a range [0, 1, ..., length-1]
  ÷               Divide each by length
    N           Negate each
     -          The constant -1
      *         Compute -1^(x) for each x in that range
       ×        Multiply elementwise between that range and B, call it B'  
          $     Operate on that B'
         N        Negate each
        ,         Make a list [B', -B']
            ḷ   Get A
           +    Add vectorized, [B', -B'] + A = [A+B', A-B']
             F  Flatten that and return

s2Zß€ç/µ¹Ṗ?  Main link. Input: list X
         Ṗ   Curtail - Make a copy of X with the last value removed
          ?  If that list is truthy (empty lists are falsey)
       µ       Parse to the left as a monad
s2             Split X into sublists of length 2
  Z            Transpose them to get [even-index, odd-index]
   ß€          Call the main link recursively on each sublist
     ç/        Call the helper link as a dyad on the sublists and return
             Else
        ¹      Identity function on X and return
</code></pre>
</div>
<div id="pu1" class="pu"><h1>APL(NARS), 58 chars, 116 bytes</h1>
<pre><code>{1≥k←≢⍵:⍵⋄(∇⍵[y∼⍨⍳k])(+,-)(∇⍵[y←2×⍳t])×0J1*t÷⍨2-2×⍳t←⌊k÷2}
</code></pre>
<p>test</p>
<pre><code>  f←{1≥k←≢⍵:⍵⋄(∇⍵[y∼⍨⍳k])(+,-)(∇⍵[y←2×⍳t])×0J1*t÷⍨2-2×⍳t←⌊k÷2}
  f 1 1 1 1
4J0 0J0 0J0 0J0 
  f 1 2 3 4
10J0 ¯2J2 ¯2J0 ¯2J¯2 
  f 1J1 2 ¯2J1  9
10J2 3J7 ¯12J2 3J¯7 
  f 5.24626,3.90746,3.72335,5.74429,4.7983,8.34171,4.46785,0.760139
36.989359J0 ¯6.211855215J0.3556612739 1.85336J¯5.744741 7.107775215J¯1.133338726 ¯0.517839J0 
  7.107775215J1.133338726 1.85336J5.744741 ¯6.211855215J¯0.3556612739 
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.gnu.org/software/octave/" rel="nofollow noreferrer">Octave</a>, <s>109 103 101</s> 100 bytes</h1>



<pre class="lang-matlab prettyprint-override"><code>f(f=@(f)@(x,n=rows(x)){@(d=f(f)(x(k=2:2:n)).*i.^((k*2-4)/n)')[d+(c=f(f)(x(k-1)));c-d],x}{1+(n&lt;2)}())
</code></pre>

<p><a href="https://tio.run/##TY3BCsIwGIPvPkVv@7N1da3zMi30PUYF2SzIoAMVLYw9ey0diAS@QBLIPLyu71t0WggRHTltyMFQ4F4/5s@TArAYGnWqQIEmrTrVeUCUd3EhmkpVt9h7FOjHiobfrpYATkM9Wh7WRVbkzworAemkt9glHjeTrPmXLbaUs4YzlXnIbHku4xc" rel="nofollow noreferrer" title="Octave – Try It Online">Try it online!</a></p>

<p>Ooooo do my eyes bleed from this <s>recursive</s> accursed lambda. Large parts of this were lifted from @flawr's answer.</p>

<pre class="lang-matlab prettyprint-override"><code>f(                                          % lambda function
  f=@(f)                                    % defined in its own argument list, 
                                            % accepts itself as parameter (for recursion)
    @(x,n=rows(x)){                         % calls another lambda,
                                            % 2nd parameter is just to define a variable
      @(d=f(f)(x(k=2:2:n)).*i.^((k*2-4)/n)')% 1/4 of FFT (argument just defines a variable)
        [d+(c=f(f)(x(k-1)));                % 2/4 of FFT
         c-d                                % 4/4 of FFT
        ],                                  % This is in a @()[] to inhibit evaluation
                                            % unless actually called
      x                                     % FFT of length 1
    }{1+(n&lt;2)}                              % if len(x)==1, return x
                                            % else return [d+c;c-d]
  ()                                        % this is probably important too
)
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C (gcc)</a>, <s>188 186 184</s> 183 bytes</h1>



<pre class="lang-c prettyprint-override"><code>#define d(a,b,c)f(a,b,c,1,0)
f(a,b,c,n,k)_Complex*a,*b;{_Complex z[c];*b=*a;if(n&lt;c)for(f(a,z,c,n*2),f(a+n,z+n,c,n*2);k&lt;c;k+=n*2)b[k+c&gt;&gt;1]=z[k]*2-(b[k/2]=z[k]+z[k+n]/cpow(1i,2.*k/c));}
</code></pre>

<p><a href="https://tio.run/##rVDBasMwDL33K0RHwY7dNUnDKLjuZZ@RmWG7cTFJnNB0bKT015fZzVo22NihO0jPT5b0JOn5TuthuNsWxroCtkhSRTU2I9KExnhyIY6W@PmxqduqeIskjRQ7Xij0uRYsUjySzBrk1r5Fs0ehsg@VUYqpJ8TR3tsYYOVas5Lw8FZ5SfRmkwje56WI0jnykUU6UuIdcWKh2@YVJZam91G50Biz03DVl3kSCza5cjVy6w5QS@sQPk7AJ8WC@8zg0uCWgifMf4RZIeRa4BAzD2vIPBACGEIlQLv3/wbBdGbIzFiYUtD7QlZI5lZgT2wtdyMBHHqevLUvhw5Np2e@RSApKAoZvlVSfZVUP0k@uVH0c1m/Z8zO2yfsvHrqIRN86eFB8Cyk1kXdFQcUJowpdLYvGgPq11lX/3ce@H6f1c2af98nXOc0vGtTyV03zKv6Aw" rel="nofollow noreferrer" title="C (gcc) – Try It Online">Try it online!</a></p>

<p>Slightly golfed less</p>

<pre class="lang-c prettyprint-override"><code>#define d(a,b,c)f(a,b,c,1,0)
f(a,b,c,n,k)_Complex*a,*b;{
  _Complex z[c];
  *b=*a;
  if(n&lt;c)
    for(f(a,z,c,n*2),f(a+n,z+n,c,n*2);k&lt;c;k+=n*2)
      b[k+c&gt;&gt;1]=z[k]*2-(b[k/2]=z[k]+z[k+n]/cpow(1i,2.*k/c));
}
</code></pre>
</div>
<div id="pu4" class="pu"><h1>Python, <strike>166</strike> <strike>151</strike> 150 characters</h1>
<p>This uses the radix-2 Cooley-Tukey FFT algorithm</p>
<pre><code>from math import*
def F(x):N=len(x);t=N&lt;2or(F(x[::2]),F(x[1::2]));return N&lt;2and x or[
a+s*b/e**(2j*pi*n/N)for s in[1,-1]for(n,a,b)in zip(range(N),*t)]
</code></pre>
<p>Testing the result</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; x = np.random.random(512)
&gt;&gt;&gt; np.allclose(F(x), np.fft.fft(x))
True
</code></pre>
</div>
<div id="pu5" class="pu"><h3>R: <strike>142</strike> <s>133</s> <s>99</s> 95 bytes</h3>

<p>Thanks to <a href="https://codegolf.stackexchange.com/users/67312">@Giuseppe</a> for helping me shaving down <s>32</s> 36 bytes!</p>

<pre><code>f=function(x,n=sum(x|1),y=1:(n/2)*2)`if`(n&gt;1,f(x[-y])+c(b&lt;-f(x[y]),-b)*exp(-2i*(y/2-1)*pi/n),x)
</code></pre>

<p>An additional trick here is to use the main function default arguments to instantiate some variables.<br>
Usage is still the same:</p>

<pre><code>x = c(1,1,1,1)
f(x)
[1] 4+0i 0+0i 0+0i 0+0i
</code></pre>

<p><strong>4-year old version at 133 bytes:</strong></p>

<pre><code>f=function(x){n=length(x);if(n&gt;1){a=Recall(x[seq(1,n,2)]);b=Recall(x[seq(2,n,2)]);t=exp(-2i*(1:(n/2)-1)*pi/n);c(a+b*t,a-b*t)}else{x}}
</code></pre>

<p>With indentations:</p>

<pre><code>f=function(x){
    n=length(x)
    if(n&gt;1){
        a=Recall(x[seq(1,n,2)])
        b=Recall(x[seq(2,n,2)])
        t=exp(-2i*(1:(n/2)-1)*pi/n)
        c(a+b*t,a-b*t)
        }else{x}
    }
</code></pre>

<p>It uses also Cooley-Tukey algorithm. The only tricks here are the use of function <code>Recall</code> that allows recursivity and the use of R vectorization that shorten greatly the actual computation.</p>

<p>Usage:</p>

<pre><code>x = c(1,1,1,1)
f(x)
[1] 4+0i 0+0i 0+0i 0+0i
</code></pre>
</div>
<div id="pu6" class="pu"><h1>Axiom, <s> 259</s>, <s>193</s>, <s>181</s>, 179 bytes</h1>
<pre><code>L(g,n,f)==&gt;[g for i in 1..n|f]
h(a)==(n:=#a;n=1=&gt;a;c:=h(L(a.i,n,odd? i));d:=h(L(a.i,n,even? i));n:=n/2;t:=1&gt;0;v:=L(d.i*%i^(-2*(i-1)/n),n,t);append(L(c.i+v.i,n,t),L(c.i-v.i,n,t)))
</code></pre>
<p>Even if h(a) could pass all the test and would be ok as entry for this 'competition'
one has to call h() or hlp() thru fft() below, for <em>checking arguments</em>.
I don't know if this software can be ok because i only had seen what other wrote, and search
the way it could run in Axiom for return some possible right result. Below ungolfed code with few comments:</p>
<pre><code>-- L(g,n,f)==&gt;[g for i in 1..n|f]
-- this macro L, build one List from other list, where in g, there is the generic element of index i
-- (as a.i, or a.i*b.i or a.i*4), n build 1..n that is the range of i, f is the condition 
-- for insert the element in the list result.

hlp(a)==
    n:=#a;n=1=&gt;a
    -- L(a.i,n,odd? i)  it means build a list getting &quot;even indices i of a.i as starting from index 0&quot; [so even is odd and odd is even]
    -- L(a.i,n,even? i) it means build a list getting &quot;odd  indices i of a.i as starting from index 0&quot;
    c:=hlp(L(a.i,n,odd? i));d:=hlp(L(a.i,n,even? i))
    n:=n/2;t:=1&gt;0
    v:=L(d.i*%i^(-2*(i-1)/n),n,t)
    append(L(c.i+v.i,n,t),L(c.i-v.i,n,t))

-- Return Fast Fourier transform of list a, in the case #a=2^n
fft(a)==(n:=#a;n=0 or gcd(n,2^30)~=n=&gt;[];hlp(a))

(5) -&gt; h([1,1,1,1])
   (5)  [4,0,0,0]
                                    Type: List Expression Complex Integer
(6) -&gt; h([1,2,3,4])
   (6)  [10,- 2 + 2%i,- 2,- 2 - 2%i]
                                    Type: List Expression Complex Integer
(7) -&gt; h([5.24626,3.90746,3.72335,5.74429,4.7983,8.34171,4.46785,0.760139])
   (7)
   [36.989359, - 6.2118552150 341603904 + 0.3556612739 187363298 %i,
    1.85336 - 5.744741 %i, 7.1077752150 341603904 - 1.1333387260 812636702 %i,
    - 0.517839, 7.1077752150 341603904 + 1.1333387260 812636702 %i,
    1.85336 + 5.744741 %i,
    - 6.2118552150 341603904 - 0.3556612739 187363298 %i]
                                      Type: List Expression Complex Float
(8) -&gt; h([%i+1,2,%i-2,9])
   (8)  [10 + 2%i,3 + 7%i,- 12 + 2%i,3 - 7%i]
                                    Type: List Expression Complex Integer
</code></pre>
<p>in the few i had seen h() or fft() would return exact solution, but if the simplification
is not good as in:</p>
<pre><code>(13) -&gt; h([1,2,3,4,5,6,7,8])
   (13)
                    +--+                                   +--+
        (- 4 + 4%i)\|%i  - 4 + 4%i             (- 4 - 4%i)\|%i  - 4 + 4%i
   [36, --------------------------, - 4 + 4%i, --------------------------, - 4,
                    +--+                                   +--+
                   \|%i                                   \|%i
            +--+                                   +--+
    (- 4 + 4%i)\|%i  + 4 - 4%i             (- 4 - 4%i)\|%i  + 4 - 4%i
    --------------------------, - 4 - 4%i, --------------------------]
                +--+                                   +--+
               \|%i                                   \|%i
                                    Type: List Expression Complex Integer
</code></pre>
<p>than it is enought change the type of only one element of list, as in below writing 8. (Float)
for find the approximate solution:</p>
<pre><code>(14) -&gt; h([1,2,3,4,5,6,7,8.])
   (14)
   [36.0, - 4.0000000000 000000001 + 9.6568542494 923801953 %i, - 4.0 + 4.0 %i,
    - 4.0 + 1.6568542494 92380195 %i, - 4.0, - 4.0 - 1.6568542494 92380195 %i,
    - 4.0 - 4.0 %i, - 4.0 - 9.6568542494 923801953 %i]
                                      Type: List Expression Complex Float
</code></pre>
<p>I wrote it, seen all other answers because in the link, the page it was too much difficult so I don't know if this code can be right. I'm not one fft expert so all this can (it is probable) be wrong.</p>
</div>
<div id="pu7" class="pu"><h1>Matlab, <s>128</s> <s>118</s> <s>107</s> <s>102</s> <s>101</s> <s>94</s> 93 bytes</h1>

<p>EDIT6: thanks @algmyr for another byte!</p>

<pre><code>function Y=f(Y);
n=numel(Y);
k=2:2:n;
if k;
   c=f(Y(k-1));
   d=f(Y(k)).*i.^(2*(2-k)/n);
   Y=[c+d;c-d];
end
</code></pre>

<p>EDIT5: Still getting shorter:) thanks to @sanchises</p>

<pre><code>function Y=f(Y)
n=numel(Y);
k=2:2:n;
if k;
   c=f(Y(k-1));
   d=f(Y(k)).*(-1).^((2-k)/n);
   Y=[c+d;c-d];
end
</code></pre>

<p>EDIT4: Yay, -1 character more (could aslo have done without the <code>k</code>):</p>

<pre><code>function Y=f(Y)
n=numel(Y);
if n&gt;1;
   k=2:2:n;
   c=f(Y(k-1));
   d=f(Y(k)).*(-1).^((k/2-1)*2/n)';
   Y=[c+d;c-d];
end
</code></pre>

<p>EDIT2/3: Thanks for @sanchises for further improvements!</p>

<pre><code>function Y=f(Y)
n=numel(Y);  
if n&gt;1;
   c=f(Y(1:2:n));
   d=f(Y(2:2:n)).*(-1).^(-(0:n/2-1)*2/n).';
   Y=[c+d;c-d]; 
end
</code></pre>

<p>EDIT: Could make some improvements, and noticed that the scaling constant is not required.</p>

<p>This is the expanded version, character count is valid if you remove the newlines/spaces. (Works only for column vectors.)</p>

<pre><code>function y=f(Y)
n=numel(Y);  
y=Y;
if n&gt;1;
   c=f(Y(1:2:n));
   d=f(Y(2:2:n));
   n=n/2;
   d=d.*exp(-pi*i*(0:n-1)/n).';
   y=[c+d;c-d]; 
end
</code></pre>
</div>
<div id="pu8" class="pu"><h2>Python 3: <strike>140</strike> <strike>134</strike> 113 characters</h2>

<p>Short version - short and sweet, fits in a tweet (with thanks to <a href="https://codegolf.stackexchange.com/users/6710/miles">miles</a>):</p>



<pre class="lang-python prettyprint-override"><code>from math import*
def f(v):
 n=len(v)
 if n&lt;2:return v
 a,b=f(v[::2])*2,f(v[1::2])*2;return[a[i]+b[i]/1j**(i*4/n)for i in range(n)]
</code></pre>

<p>(In Python 2, <code>/</code> is truncating division when both sides are integers. So we replace <code>(i*4/n)</code> by <code>(i*4.0/n)</code>, which bumps the length to 115 chars.)</p>

<p>Long version - more clarity into the internals of the classic Cooley-Tukey FFT:</p>

<pre class="lang-python prettyprint-override"><code>import cmath
def transform_radix2(vector):
    n = len(vector)
    if n &lt;= 1:  # Base case
        return vector
    elif n % 2 != 0:
        raise ValueError("Length is not a power of 2")
    else:
        k = n // 2
        even = transform_radix2(vector[0 : : 2])
        odd  = transform_radix2(vector[1 : : 2])
        return [even[i % k] + odd[i % k] * cmath.exp(i * -2j * cmath.pi / n) for i in range(n)]
</code></pre>
</div>
<div id="pu9" class="pu"><h1>J, 37 bytes</h1>

<pre><code>_2&amp;(0((+,-)]%_1^i.@#%#)&amp;$:/@|:]\)~1&lt;#
</code></pre>

<p>An improvement after a few years. Still uses the Cooley-Tukey FFT algorithm.</p>

<p>Saved 4 bytes using <em>e</em><sup><em>πi</em></sup> = -1, thanks to @<a href="https://codegolf.stackexchange.com/users/48934/leaky-nun">Leaky Nun</a>.</p>

<p><a href="https://tio.run/##HYu7DoJAFAV7vuJE5BXxuu9lN2qwsrewEimMRG0saCjEX1/BnEwmU5xX6LHzYJgIrUhzluercl00ScuvT6rjJC7Spd/UH99cii/fxqGIFoSsm28ZSowefTTMJTASDqfjObrfHm90KS0o3WMIgeO/yQISKmgSyggDSY5ZNdsKKTU0WaWEgyLrKomKpOKWT6mMrTQYWcO4dD8" rel="nofollow noreferrer">Try it online!</a></p>

<h2>Usage</h2>

<pre><code>   f =: _2&amp;(0((+,-)]%_1^i.@#%#)&amp;$:/@|:]\)~1&lt;#
   f 1 1 1 1
4 0 0 0
   f 1 2 3 4
10 _2j2 _2 _2j_2
   f 5.24626 3.90746 3.72335 5.74429 4.7983 8.34171 4.46785 0.760139
36.9894 _6.21186j0.355661 1.85336j_5.74474 7.10778j_1.13334 _0.517839 7.10778j1.13334 1.85336j5.74474 _6.21186j_0.355661
</code></pre>

<h2>Explanation</h2>

<pre><code>_2&amp;(0((+,-)]%_1^i.@#%#)&amp;$:/@|:]\)~1&lt;#  Input: array A
                                    #  Length
                                  1&lt;   Greater than one?
_2&amp;(                            )~     Execute this if true, else return A
_2                            ]\         Get non-overlapping sublists of size 2
    0                       |:           Move axis 0 to the end, equivalent to transpose
                          /@             Reduce [even-indexed, odd-indexed]
                       &amp;$:               Call recursively on each 
                   #                     Get the length of the odd list
                i.@                      Range from 0 to that length exclusive
                    %#                   Divide each by the odd length
             _1^                         Compute (-1)^x for each x
           ]                             Get the odd list
            %                            Divide each in that by the previous
       +                                 Add the even values and modified odd values
         -                               Subtract the even values and modified odd values
        ,                                Join the two lists and return
</code></pre>
</div>
<div id="pu10" class="pu"><h1>Pari/GP, 76 characters</h1>
<pre><code>X(v)=my(t=-2*Pi*I/#v,s);vector(#v,k,s=t*(k-1);sum(n=0,#v-1,v[n+1]*exp(s*n)))
</code></pre>
<p>Usage</p>
<pre><code>X([1,1,1,1])
%2 = [4.000000000000000000000000000, 0.E-27 + 0.E-28*I, 0.E-28 + 0.E-27*I, 0.E-27 + 0.E-28*I]
</code></pre>
</div>
<div id="pu11" class="pu"><h1>Mathematica, 95 bytes</h1>

<p>Another implementation of the Cooley–Tukey FFT with help from @<a href="https://codegolf.stackexchange.com/users/7254/chyaong">chyaong</a>.</p>

<pre><code>{n=Length@#}~With~If[n&gt;1,Join[+##,#-#2]&amp;[#0@#[[;;;;2]],#0@#[[2;;;;2]]I^Array[-4#/n&amp;,n/2,0]],#]&amp;
</code></pre>

<h3>Ungolfed</h3>

<pre><code>FFT[x_] := With[{N = Length[x]},
  If[N &gt; 1,
    With[{a = FFT[ x[[1 ;; N ;; 2]] ], 
          b = FFT[ x[[2 ;; N ;; 2]] ] * Table[E^(-2*I*Pi*k/N), {k, 0, N/2 - 1}]},
      Join[a + b, a - b]],
    x]]
</code></pre>
</div>
<div id="pu12" class="pu"><h1>C, 259</h1>

<pre class="lang-c prettyprint-override"><code>typedef double complex cplx;
void fft(cplx buf[],cplx out[],int n,int step){
if(step &lt; n){
fft(out, buf,n, step * 2);
fft(out+step,buf+step,n,step*2);
for(int i=0;i&lt;n;i+=2*step){
cplx t=cexp(-I*M_PI*i/n)*out[i+step];
buf[i/2]=out[i]+t;
buf[(i+n)/2]=out[i]-t;
}}}
</code></pre>

<p>The problem is, such implementations are useless, and straightforward algorithm is MUCH faster.</p>
</div>
<div id="pu13" class="pu"><h2>Python, 134</h2>

<p>This borrows heavily from jakevdp's solution, so I've set this one to a community wiki.</p>

<pre><code>from math import*
F=lambda x:x*(len(x)&lt;2)or[a+s*b/e**(2j*pi*n/len(x))for s in(1,-1)for n,(a,b)in
enumerate(zip(F(x[::2]),F(x[1::2])))]
</code></pre>

<p>Changes:</p>

<p>-12 chars: kill <code>t</code>.</p>

<pre><code>def F(x):N=len(x);t=N&lt;2or(F(x[::2]),F(x[1::2]));return ... in zip(range(N),*t)]
def F(x):N=len(x);return ... in zip(range(N),F(x[::2]),F(x[1::2]))]
</code></pre>

<p>-1 char: exponent trick, <code>x*y**-z == x/y**z</code>  (this could help some others)</p>

<pre><code>...[a+s*b*e**(-2j*pi*n/N)...
...[a+s*b/e**(2j*pi*n/N)...
</code></pre>

<p>-2 char: replace <code>and</code> with <code>*</code></p>

<pre><code>...return N&lt;2and x or[
...return x*(N&lt;2)or[
</code></pre>

<p>+1 char: <code>lambda</code>ize, killing <code>N</code></p>

<pre><code>def F(x):N=len(x);return x*(N&lt;2)or[a+s*b/e**(2j*pi*n/N) ... zip(range(N) ...
F=lambda x:x*(len(x)&lt;2)or[a+s*b/e**(2j*pi*n/len(x)) ... zip(range(len(x)) ...
</code></pre>

<p>-2 char: use <code>enumerate</code> instead of <code>zip(range(len(</code></p>

<pre><code>...for(n,a,b)in zip(range(len(x)),F(x[::2]),F(x[1::2]))]
...for n,(a,b)in enumerate(zip(F(x[::2]),F(x[1::2])))]
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/12420/">12420</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




