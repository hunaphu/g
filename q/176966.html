<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::176966</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>232</td><td>Binary Lambda Calculus 1856 bits</td><td>240802T162912Z</td><td><a href="https://codegolf.stackexchange.com/questions/176966/golf-a-number-bigger-than-loaders-number/274634#274634">John Tro</a></td></tr>
<tr d-ix="1"><td>nan</td><td>Python 3</td><td>191218T175323Z</td><td><a href="https://codegolf.stackexchange.com/questions/176966/golf-a-number-bigger-than-loaders-number/197173#197173">Naruyoko</a></td></tr>
<tr d-ix="2"><td>nan</td><td>JavaScript</td><td>190426T034324Z</td><td><a href="https://codegolf.stackexchange.com/questions/176966/golf-a-number-bigger-than-loaders-number/184808#184808">Naruyoko</a></td></tr>
<tr d-ix="3"><td>192</td><td>Python</td><td>220415T061356Z</td><td><a href="https://codegolf.stackexchange.com/questions/176966/golf-a-number-bigger-than-loaders-number/246256#246256">benrg</a></td></tr>
<tr d-ix="4"><td>319</td><td>Python</td><td>211120T111732Z</td><td><a href="https://codegolf.stackexchange.com/questions/176966/golf-a-number-bigger-than-loaders-number/237490#237490">Binary19</a></td></tr>
<tr d-ix="5"><td>nan</td><td>Ruby</td><td>200114T135056Z</td><td><a href="https://codegolf.stackexchange.com/questions/176966/golf-a-number-bigger-than-loaders-number/198022#198022">Naruyoko</a></td></tr>
<tr d-ix="6"><td>498</td><td>Python</td><td>200214T164014Z</td><td><a href="https://codegolf.stackexchange.com/questions/176966/golf-a-number-bigger-than-loaders-number/199517#199517">Spitemas</a></td></tr>
</table>
<div id="pu0" class="pu"><h2><strong>Binary Lambda Calculus: 1856 bits (232 bytes):</strong></h2>
<pre><code>01000101010110101001000100010001000001000101011000011000000000010111111100011001111111111011001011100001010111000010101111000000001011111000000001111111000010101010111111111111111101111111111110111101000000100000101011100100000001011011101100001010110000101101111101111111000011111111110011000001000011111111100110000010001001010101011111111011111111111111111100000011100001010111111111111111111110001110111111100001000000010110111011001000001010110111111111110010111011111111111110111111111001011101111111111110111111111000000001010101010111101000000001111000110000010000010000000000101011110000010011111111011111011110011101000001000001001011111100000010000000101101110110010000010101101110010101111111000100101110000011011110111111110010101110111111011110111111100000000000000001010111100000011101111111110011111110111100001111111000010110110111111001011100001011000010101100001011011111101111111100001111111001100000100001100000110110100001010101111011111111111111111000000000100000111000001000000010011101011000101000010110000101011000001000000000011100000110000000000111000001000001000001011000010001101000000110000000010111111101110010101111110111110110100000010101111110000001011101001011011000001100111101100111101000010101010001101000010000000001000100010101111100000000111111001010111111111101111111101100101111000011111110000101101100101011111111111100000011100101111111111111011010011110000000011001111111111111100001100000101111111100111110010101111111111011111111010111111000011100111100001011011011111000011001011111110110011100111101111000000101100000101100000010110000011011001101000001001101100000100101000110100000010000010110000000011011111001011111011110110000111000010110000010110001000010001101000000001011100000000101111100000010101111111111011111011001010111111111011111111011110100000100101100000001111100000110100000011100111010
</code></pre>
<p>This is the binary representation of this <a href="https://github.com/tromp/AIT/blob/master/fast_growing_and_conjectures/loader.lam" rel="nofollow noreferrer">lambda expression</a> which computes 2^2^2=16 iterations, on starting value 2, of a slightly slower growing derive function which is modeled after this <a href="https://github.com/tromp/AIT/blob/master/fast_growing_and_conjectures/CoC.hs" rel="nofollow noreferrer">Haskell port</a> of Loader's 643 byte C program.</p>
<p>derive n computes a list of all judgements which can be formed with n rule applications and returns n to the power of the product of all term sizes.</p>
<p>For the first iteration we have derive 2 = 2^27 &gt;&gt; 99.</p>
<p>Loader's Derive does something similar with fewer rule applications but returns a power tower of term sizes instead. Since derive easily constructs power towers, we have derive (derive n) &gt;&gt; D(n), and thus 11 iterations certainly suffice to exceed Loader's number.</p>
<p>Thanks to <a href="https://github.com/int-e" rel="nofollow noreferrer">https://github.com/int-e</a> for some of the final optimizations.</p>
</div>
<div id="pu1" class="pu"><h1>Python 3, D^6(9) (<sub><s>608</s></sub> <sub><s>600</s></sub> <sub><s>599</s></sub> <sub><s>597</s></sub> <sub><s>591</s></sub> <sub><s>583</s></sub> <sub><s>573</s></sub> 572 bytes)</h1>
<pre class="lang-python prettyprint-override"><code>_=&quot;a=0@PJ$x-~x&lt;&lt;c@ZJr=0'C?1+YxKO$r@LJ$xK+Yx)@SBu!f,d=FuQr#$A(RBYdE)'f==2?If,IR(x+2U,/tQYdEE'f&lt;2?u-(f&gt;x)*c'f-x?t@AJ$5&lt;&lt;P.)'Fx)-1?MU,YrE@D.=0,t=7,u=14!Hx:Nx-1O6H~CXa=IIt,Iu,P.EQaO $a#d,f,x=FFNxEQFrQFrOHc-r:#'not(Fu)or(Fr)-fEG'C:u=M,d,rTA(t,dO'fKG'WdUT/tVuOHcX6'CG q=~u&amp;2|C# 'q:u=1&lt;&lt;IFuQuO  tU=Iu'q?q,IFcQtE,r#6HuK&amp;WtUVtT9#$DBu)\nprint(NNNNNN9EEE)!):#global r,a##\n $return ' H.(xU/M-8,13,6x=xK#? else @\ndef B.,t,Cx%2E))FL(GX 6 Hif IP(J.=0!K&gt;&gt;1MS(4,4ND(O)#Q),RSBFdE,ST);t=U,cV);u=/WC:c=IX:# YZ(&quot;
for Y in&quot;YXWVUTRQONMKJIHGFECB@?6/.'$#!&quot;:_=_.split(Y);_=_.pop().join(_)
exec(_)
</code></pre>
<p>This is an encoded code. Extracted:</p>
<pre class="lang-python prettyprint-override"><code>a=0
def P(x,c=0):
 global r,a
 return x-~x&lt;&lt;c
def Z(x,c=0):
 global r,a
 r=0 if x%2 else 1+Z(x&gt;&gt;1)
 return r
def L(x,c=0):
 global r,a
 return x&gt;&gt;1+Z(x)
def S(x,c,t,u):
 global r,a
 f,d=L(u),r
 return A(S(x,c,t,L(d)),S(x,c,t,Z(d))) if f==2 else P(f,P(S(x,c,t,L(d)),S(x+2,c,S(4,4-8,13,t),Z(d)))) if f&lt;2 else u-(f&gt;x)*c if f-x else t
def A(x,c=0):
 global r,a
 return 5&lt;&lt;P(x,c) if L(x)-1 else S(4,4,c,Z(r))
def D(x,c=0,t=7,u=14):
 global r,a
 if x:D(x-1)
 x=x&gt;&gt;1
 if ~x%2:
  a=P(P(t,P(u,P(x,c))),a)
  return a
 d,f,x=L(L(D(x))),L(r),L(r)
 if c-r:
  if not(L(u)or(L(r)-f)):
   x=x&gt;&gt;1
   if x%2:u=S(4,4,d,r);t=A(t,d)
  if f&gt;&gt;1:
   x=x&gt;&gt;1
   if x%2:c=P(d,c);t=S(4,4-8,13,t);u=S(4,4-8,13,u)
 if c:
  x=x&gt;&gt;1
  if x%2:
   x=x&gt;&gt;1
   q=~u&amp;2|x%2
   if q:u=1&lt;&lt;P(L(u),u)
   t,c=P(u if q else q,P(L(c),t)),r
 x=x&gt;&gt;1
 if u&gt;&gt;1&amp;x%2:c=P(t,c);u=S(4,4-8,13,t);t=9
 return D(x,c,t,u)
print(D(D(D(D(D(D(9)))))))
</code></pre>
<p>In this, it is assumed to be:</p>
<ul>
<li>Infinite call stack</li>
<li>Infinite memory</li>
</ul>
<p>This is basically a port of my <a href="https://codegolf.stackexchange.com/a/184808/">JavaScript answer</a>. For more details, check that one.</p>
<p>The compression was done with <a href="https://naruyoko.github.io/tests/compression/Python%203/" rel="nofollow noreferrer">this</a>.</p>
<p>I am not very knowledgeable in Python, so there are certainly places to save bytes. <s>I think sub-600 is possible.</s> sub-600 has been proven.</p>
<ul>
<li>608-&gt;600B, -8B
<ul>
<li>Grouped some assignments</li>
<li>Reversed conditions of <code>S</code> to reduce parenthesis</li>
</ul>
</li>
<li>600-&gt;599B, -1B
<ul>
<li>Changing <code>u/2</code> in the third last line of the definition of <code>D</code> to <code>u&gt;&gt;1</code>, saving a byte from compressing it to a character with other <code>&gt;&gt;1</code>s.</li>
</ul>
</li>
<li>599-&gt;597B, -2B
<ul>
<li>2 bytes from removing assignment to <code>r</code>.</li>
</ul>
</li>
<li>597-&gt;591B, -6B
<ul>
<li>Made <code>D</code> recursive.</li>
<li>Removed the unnecessary assignments to <code>d</code>, <code>f</code>, and <code>c</code>. Making <code>D</code> recursive allows this to be completely removed and save more bytes whereas keeping it in a loop would have still needed an assignment to <code>c</code>.</li>
</ul>
</li>
<li>591-&gt;583B, -8B
<ul>
<li>Changed the 1-argument and 2-arguments functions' arguments to <code>(x,c=0)</code>.</li>
<li>Added <code>global r,a</code> to every function.</li>
<li>Swapped the second and the third of <code>S</code>.</li>
<li>Changed the instances of <code>S(4,-4,13,</code> to <code>S(4,4-8,13,</code>.</li>
<li>Fixed the compression algorithm (specifically displaying) so it actually works now.</li>
</ul>
</li>
<li>583-&gt;573B, -10B
<ul>
<li>Replaces <code>q and u</code> with <code>u if q else q</code> and that somehow saved 10 bytes.</li>
</ul>
</li>
<li>573-&gt;572B, -1B
<ul>
<li>Renamed the arguments of S to match <code>D</code>'s.</li>
</ul>
</li>
</ul>
</div>
<div id="pu2" class="pu"><h1>JavaScript, D<sup>6</sup>(9) (<sub><s>508</s></sub> <sub><s>501</s></sub> <sub><s>495</s></sub> <sub><s>492</s></sub> <sub><s>487</s></sub> <sub><s>485</s></sub> <sub><s>481</s></sub> <sub><s>478</s></sub> <sub><s>456</s></sub> <sub><s>452</s></sub> 447 bytes)</h1>
<pre class="lang-js prettyprint-override"><code>_=&quot;P.x-~x&lt;&lt;c,Z.r=x&amp;1?0:1+ZC/2$L.x/2&gt;&gt;ZC$S='u,f=6u$d=rJf-2?f&gt;2?f-x?u-(f&gt;x)*c:t:@f,@EC+2K,IZ(d;;:A(E'Z(d;$A.6x)-1?5&lt;&lt;P!):BK,Z(rMD=!=0,H7,N14J_=C&amp;&amp;DC-1$ 1;?(d=66DC;$f=6r$x=6r$c-r||(6u)||6r)-f|| NB,d,r$HA(t,dMfGdK$HIN#u;$c&amp;&amp; H@~u&amp;2| N1&lt;&lt;@6c$uM@6c$tMc=r$uGtK$NIH9$D'u;:@@t,@u,P!;$_$FFF9;;; C&gt;&gt;=1)%2&amp;&amp;(!CK#B-8,13,$),'!,t,.=!J6L(;))@P(BS(4,4C(xES'6dMSFD(D(G/2&amp; c=@Ht=I#t$J)=&gt;K,cM)$Nu=&quot;;for($ of&quot;NMKJIHGFECB@;6.'$#! &quot;)with(_.split($))_=join(pop());eval(_)
</code></pre>
<p>This is an encoded code.</p>
<pre class="lang-js prettyprint-override"><code>_=&quot;P.x-~x&lt;&lt;c,Z.r=x&amp;1?0:1+ZC/2$L.x/2&gt;&gt;ZC$S='u,f=6u$d=rJf-2?f&gt;2?f-x?u-(f&gt;x)*c:t:@f,@EC+2K,IZ(d;;:A(E'Z(d;$A.6x)-1?5&lt;&lt;P!):BK,Z(rMD=!=0,H7,N14J_=C&amp;&amp;DC-1$ 1;?(d=66DC;$f=6r$x=6r$c-r||(6u)||6r)-f|| NB,d,r$HA(t,dMfGdK$HIN#u;$c&amp;&amp; H@~u&amp;2| N1&lt;&lt;@6c$uM@6c$tMc=r$uGtK$NIH9$D'u;:@@t,@u,P!;$_$FFF9;;; C&gt;&gt;=1)%2&amp;&amp;(!CK#B-8,13,$),'!,t,.=!J6L(;))@P(BS(4,4C(xES'6dMSFD(D(G/2&amp; c=@Ht=I#t$J)=&gt;K,cM)$Nu=&quot;; //encoded code
for($ of&quot;NMKJIHGFECB@;6.'$#! &quot;)with(_.split($))_=join(pop()); //decoding
eval(_) //Evaluation of the string
</code></pre>
<p>Decoded code:</p>
<pre class="lang-js prettyprint-override"><code>P=(x,c)=&gt;x-~x&lt;&lt;c,Z=(x,c)=&gt;r=x&amp;1?0:1+Z(x/2),L=(x,c)=&gt;x/2&gt;&gt;Z(x),S=(x,c,t,u,f=L(u),d=r)=&gt;f-2?f&gt;2?f-x?u-(f&gt;x)*c:t:P(f,P(S(x,c,t,L(d)),S(x+2,c,S(4,4-8,13,t),Z(d)))):A(S(x,c,t,L(d)),S(x,c,t,Z(d))),A=(x,c)=&gt;L(x)-1?5&lt;&lt;P(x,c):S(4,4,c,Z(r)),D=(x,c=0,t=7,u=14)=&gt;_=(x&amp;&amp;D(x-1),(x&gt;&gt;=1)%2&amp;&amp;(1))?(d=L(L(D(x))),f=L(r),x=L(r),c-r||(L(u)||L(r)-f||(x&gt;&gt;=1)%2&amp;&amp;(u=S(4,4,d,r),t=A(t,d)),f/2&amp;(x&gt;&gt;=1)%2&amp;&amp;(c=P(d,c),t=S(4,4-8,13,t),u=S(4,4-8,13,u))),c&amp;&amp;(x&gt;&gt;=1)%2&amp;&amp;(t=P(~u&amp;2|(x&gt;&gt;=1)%2&amp;&amp;(u=1&lt;&lt;P(L(c),u)),P(L(c),t)),c=r),u/2&amp;(x&gt;&gt;=1)%2&amp;&amp;(c=P(t,c),u=S(4,4-8,13,t),t=9),D(x,c,t,u)):P(P(t,P(u,P(x,c))),_),D(D(D(D(D(D(9))))))
// We also have _ equal to the code itself.
</code></pre>
<p>The logic is the same as the original loader.c, but few non-critical modifications are made to compress the code better.</p>
<p>In this, it is assumed to be:</p>
<ul>
<li>Infinite call stack</li>
<li>Infinite memory</li>
<li>Infinite precision <code>Number</code></li>
<li>Infinite magnitude <code>Number</code></li>
<li>Bitshift and bitwise operators work on infinite bit integers instead of 53 bits. Bitwise negation still negates the sign bit.</li>
</ul>
<h2>Encoding/Decoding algorithm:</h2>
<p>The encoding is done as follows:</p>
<ul>
<li>Take a repeated string, call it S.</li>
<li>Replace all S in the code to a key K.</li>
<li>Put K and S at the end.</li>
<li>Make a list of keys, and also put decoding algorithm so the code actually runs.</li>
</ul>
<p>The decoding algorithm:</p>
<ul>
<li>Take list of keys.</li>
<li>Take the earliest key K.</li>
<li>Split the string for each K.</li>
<li>Since last of the array is what to replace K S, pop it, and replace all K by joining the array with the popped value S.</li>
</ul>
<p>The compression was done with <a href="https://naruyoko.github.io/tests/compression/JavaScript/" rel="nofollow noreferrer">this code</a>.</p>
(d=String.fromCharCode)((c=a.charCodeAt())>>8)+d(c&255)).join``.slice(1))
```

This code will take the 16bit string as a, converts it to 8bit string with same binary(BE), and `eval` it.

The decoded code is the encoded code above. -->
<h2>Proof that D<sup>6</sup>(9)&gt;D<sup>5</sup>(99)</h2>
<p>For this, we would compare D(0) and 99. We find that D(0) is equal to <code>8646911284551352321</code> (note that in a normal environment without modifications we won't get a correct result because the higher bits are truncated). So, D(0)&gt;99, and since D is strictly increasing, D<sup>6</sup>(9)&gt;D<sup>6</sup>(0)&gt;D<sup>5</sup>(99).</p>
<ul>
<li>508B-&gt;501B, -7B
<ul>
<li>-1B for... I don't know why. I did change <code>D(D(D(D(D(99)))))</code> to <code>D(D(D(D(D(D(9))))))</code>. Also that shuffled the letters.</li>
<li>-6B for re-adding <code>&amp;&amp;(1)</code> for <code>D(x)</code>'s loop condition.</li>
</ul>
</li>
<li>501B-&gt;495B, -6B
<ul>
<li>Fixed most <code>/2</code>s to <code>&gt;&gt;1</code>s because <code>Number</code></li>
<li>6 bytes saved from somewhere</li>
<li>You can see my attempt in this update <a href="https://docs.google.com/spreadsheets/d/12xhVzRC3lwkmzdWItbySeQoFEkxf2NL7-5aXeDkI7YI/edit?usp=drivesdk" rel="nofollow noreferrer">here</a></li>
</ul>
</li>
<li>495-&gt;492B, -3B
<ul>
<li>By changing the decoder from <code>for...in</code> to <code>for...of</code>.</li>
</ul>
</li>
<li>492-&gt;487B, -5B
<ul>
<li>Removing unnecessary assignments</li>
<li>Changing argument names</li>
</ul>
</li>
<li>487-&gt;485B, -2B
<ul>
<li>1 byte from using <code>eval</code> for <code>D</code>, removing <code>return</code>.</li>
<li>1 byte compression combining the closing parentheses to a comma.</li>
</ul>
</li>
<li>485-&gt;481B, -4B
<ul>
<li>By compressing different substrings.</li>
</ul>
</li>
<li>481-&gt;478B, -3B
<ul>
<li>Removed unnecessary variable assignment.</li>
</ul>
</li>
<li>478-&gt;456B, -22B
<ul>
<li>You can find me posting updates at <em>Googology Server!</em> (Discord).</li>
<li>2 bytes from changing from D<sup>6</sup>(9) to D<sup>6</sup>(0).</li>
<li>1 byte from making <code>D</code> recursive instead of using a loop.</li>
<li>7 bytes from making <code>f</code> and <code>d</code> in <code>D</code> global and not declaring them. It works since they are reassigned every time going through the loop, and <code>D</code> is not called between the assignment and the next iteration.</li>
<li>2 bytes from removing assignment to <code>r</code>. They will be assigned before use.</li>
<li>1 byte from removing an unnecessary assignment corresponding <a href="https://github.com/rcls/busy/blob/82d729e4f9d251ffd568d6db5c60a75d09f8c260/pure.c#L34" rel="nofollow noreferrer">here</a> in the original code. It no longer saved bytes.</li>
<li>1 byte from fixing a typo. I still don't know how it appeared.</li>
<li>2 bytes from swapping the second and the third variable of <code>S</code>. I checked and it should work fine.</li>
<li>1 byte from changing instances of <code>S(4,-4,13,</code> to <code>S(4,4-8,13,</code>.</li>
<li>2 bytes from adding unused variables <code>y</code> to <code>Z</code> and <code>L</code>.</li>
<li>1 byte from changing <code>Z</code>.</li>
<li>2 bytes from reusing <code>_</code> as the accumulator. It starts out as a <code>String</code> containing the decoded code, and in such a case, it acts as <code>0</code> in bitwise operators. Also changed back to D<sup>6</sup>(9) for good measure.</li>
</ul>
</li>
<li>456-&gt;452B -4B
<ul>
<li>Changed the 1-argument and 2-arguments functions' argument names to <code>(x,c)</code>.</li>
</ul>
</li>
<li>452-&gt;447B -5B
<ul>
<li>Renamed the arguments of <code>S</code> to match <code>D</code>'s.</li>
</ul>
</li>
</ul>
</div>
<div id="pu3" class="pu"><h1>Python, q<sup>15</sup>(2), 192 bytes</h1>
<pre class="lang-python prettyprint-override"><code>def q(k,c=0,n=0):
 while c*2&lt;1&lt;&lt;k:
  n+=1;*x,=map(s:=lambda b,a=1:s(a,s(b-1,a))if a*b else(a-~b)%c,range(c:=1&lt;&lt;n))
  while x[:c]==x[-c:]:x=x[:c];c&gt;&gt;=1
 return n
print(eval(15*'q('+'2'+')'*15))
</code></pre>
<p>See <a href="/a/237490">Binary198's answer</a> for the definition of q and an argument that q<sup>15</sup>(2) is large enough. If the argument is correct, then this is an impressively concise way to beat Loader's number. Unfortunately their implementation is broken.</p>
<p>This is my attempt at reasonably well golfed code that, I think, actually works. At least, it correctly computes values of q up to q(3)=5. (If you want to test that, you should wrap the definition of <code>s</code> in <code>functools.lru_cache(None)(...)</code>.) Computing q(4)=9 may be possible, but will need a lot of stack space.</p>
<p>s(b,a) computes row a, column b+1 of the Laver table of size c, using 0...c-1 as the representatives of Z/cZ instead of the usual (for these tables) 1...c. The period-finding code uses the fact that the period can only be a power of 2. Other than that, there are only standard golfing tricks here.</p>
<p>I deliberately computed the same value as Binary198's answer, though it could be made larger at no cost, because I'm not trying to compete on size; I just wanted a working implementation of this interesting function (for some definition of &quot;working&quot;).</p>
</div>
<div id="pu4" class="pu"><h1>Python, q^15(2) = q^13(5), 319 bytes</h1>
<p>This is my first time submitting a program to code golf, but certainly not my first time implementing or inventing a large number. I probably won't go down in googology history for this. Anyway, here is my program, the explanation comes later:</p>
<pre><code>_=&quot;78b/:!if b==1:&amp;(a+1)%c!9&amp;s(8b-1/,s(81///\n7f(a):!m=[]*True:!#for x in range(65536):!##if a(x)==a(x+k): break!##9 pass'p = 4x:f(4y:s(1,y,x))\n7q(a):*p(k)&lt;2^a:'k = <span class="math-container">$$$$</span>$2...!\n##    $q(q(q('!#k+=1!&amp;k\n&amp;return *!k=0!while .)))))/,c)4lambda 7def 8s(a,9else:&quot;
for Y in&quot;9874/.*&amp;'$#!&quot;:_=_.split(Y);_=_.pop().join(_)
exec(_)
</code></pre>
<p>I compressed this code using the same tool which Naruyoko used, <a href="https://naruyoko.github.io/tests/compression/Python%203/" rel="nofollow noreferrer">here</a>. Here is the uncompressed form:</p>
<pre><code>def s(a,b,c):
    if b==1:return (a+1)%c
    else:return s(s(a,b-1,c),s(s(a,1,c),c),c)
def f(a):
    m=[]
    k=0
    while True:
        for x in range(65536):
            if a(x)==a(x+k): break
            else: pass
        k+=1
    return k
p = lambda x:f(lambda y:s(1,y,x))
def q(a):
    k=0
    while p(k)&lt;2^a:
        k+=1
    return k
k = q(q(q(q(q(q(q(q(q(q(q(q(q(q(q(2)))))))))))))))
</code></pre>
<h2>Explanation</h2>
<p>I had a hard time choosing what to use. I was originally planning to implement my LINEAR(k) function, which I might do another time, but I didn't know if it would produce large enough numbers, and it would be hard to implement, so my next choice was greedy clique sequences, but those didn't work either, so I just ended up using Laver tables.</p>
<p>So, how do Laver tables work? Well the size-n Laver table is a binary operator ab, with the following rules: a0=0, a1=a+1 mod n and ab=(a(b-1))(a1) for b&gt;1. p(n) is defined as the period of the function 1a, which is quite slow-growing.</p>
<p>The first few values of p(n) are 1,1,2,4,4,8,8,8,8,16,16,16,16,... Then q(n) is the least integer so that p(q(n)) is greater than or equal to 2^n. This is very fast-growing, and its totality can only be proven in ZFC+I3, so one could approximate it to f_PTO(ZFC+I3)(n) in FGH, although this doesn't work since there is no system of fundamental sequences associated to PTO(ZFC+I3).</p>
<p>The first few values of q(n) are 0,2,3,5,9. q(5) is approximated to Ack(9,Ack(8,Ack(8,255))) using the Ackermann function, and q(6) is believed to be greater than Graham's number!</p>
<p>So, now that we know how Laver tables work, how does my code work? Well, s(a,b,c) denotes the operator ab where n=c, then the function f(a) uses complex while loops to find the period of the given function a.</p>
<p>p is represented by the lambda which returns <code>f(lambda y:s(1,y,x))</code>, i.e. the period of <code>s(1,y,x)</code> where x is the input to p. q then just uses for loops to find the least integer k s.t. p(k) =&gt; 2^a.</p>
<p>My code then returns q^13(5), which has been proven to be greater than f_w(f_w+1(5)); note that this was for q^13(1) but q is strictly increasing so this also acts as a lower bound for q^13(5). This lower bound however is a severe understatement, since, as I mentioned earlier, q(n) cannot be proven total in ZFC while f_w(f_w+1(5)) can be by FAR.</p>
<p>Similarly, this code should return a number greater than Loader's number since, although sadly there is no proof, Loader's function is commonly believed to be provably total in ZFC; I do note however that just because a function which is provably total in a stronger theory doesn't mean that it will eventually dominate the one provably total in the weaker theory. It is usually the case though. So, all said, I WIN!!!</p>
<p>Edit: I lose because the code is completely broken and I can't fix it...</p>
</div>
<div id="pu5" class="pu"><h1>Ruby, D<sup>6</sup>(9) (<sub><s>553</s></sub> <sub><s>544</s></sub> <sub><s>535</s></sub> <sub><s>516</s></sub> <sub><s>511</s></sub> 507 bytes)</h1>
<pre class="lang-ruby prettyprint-override"><code>_='a=r=0;P&quot;x-~x&lt;&lt;y};Z&quot;r=x%2B1?0M1+J/2FL&quot;x/2&gt;&gt;JFS=-&gt;vEt{f=L(t);x=r;fB2?A*EJ6Mf&gt;2?fBv ?yMf&gt;v ?t-cMtM@f,P*+2,#y8c,J6FA&quot;Cx]B1?Ky,4,Z[r]]M5&lt;&lt;@x,yFD&quot;f=d=c=0;t=7;O14;while[xIHx-18.&gt;0][1];d=CCHx6;f=N;x=N;cBr&amp;&amp;[Cu]B0&amp;&amp;NBf&amp;&amp;.I[OKd,4,rQA[t,d]8fGd,cQ#t8O#u6;cI.&amp;&amp;[t=@~u&amp;2|.I(O1&lt;&lt;@Cc8u]),@Cc8t]8c=r];uGt,c8O#tQ9];end;a=@@t,@u,@x,c6,aF$&gt;&lt;&lt;HHHHHH966&quot;=-&gt;x,y=0{#K13,-4,*[S[vECx]8S[v.(x/=2)%26]]]8],@P[B==CL[E,y,c,F]};G/2&amp;.I[c=@HD[IB0||JZ[xKS[4,M: NCr]Ou=Q8t=';'QONMKJIHGFECB@86.*#&quot;'.each_char{|y|*_,y=_.split y;_=_*y};eval _
</code></pre>
<p>This is an encoded code. Extracted:</p>
<pre class="lang-ruby prettyprint-override"><code>a=r=0;P=-&gt;x,y=0{x-~x&lt;&lt;y};Z=-&gt;x,y=0{r=x%2==1?0: 1+Z[x/2]};L=-&gt;x,y=0{x/2&gt;&gt;Z[x]};S=-&gt;v,y,c,t{f=L(t);x=r;f==2?A[S[v,y,c,L[x]],S[v,y,c,Z[x]]]: f&gt;2?f==v ?y: f&gt;v ?t-c: t: P[f,P[S[v,y,c,L[x]],S[v+2,S[4,13,-4,y],c,Z[x]]]]};A=-&gt;x,y=0{L[x]==1?S[4,y,4,Z[r]]: 5&lt;&lt;P[x,y]};D=-&gt;x,y=0{f=d=c=0;t=7;u=14;while[x==0||D[x-1],(x/=2)%2&gt;0][1];d=L[L[D[x]]];f=L[r];x=L[r];c==r&amp;&amp;[L[u]==0&amp;&amp;L[r]==f&amp;&amp;(x/=2)%2==0||[u=S[4,d,4,r],t=A[t,d]],f/2&amp;(x/=2)%2==0||[c=P[d,c],t=S[4,13,-4,t],u=S[4,13,-4,u]]];c==0||(x/=2)%2&amp;&amp;[t=P[~u&amp;2|(x/=2)%2==0||(u=1&lt;&lt;P[L[c],u]),P[L[c],t]],c=r];u/2&amp;(x/=2)%2==0||[c=P[t,c],u=S[4,13,-4,t],t=9];end;a=P[P[t,P[u,P[x,c]]],a]};$&gt;&lt;&lt;D[D[D[D[D[D[9]]]]]]
</code></pre>
<p>This code is Loader's Number with D<sup>6</sup>(9) instead.</p>
<p>In this, it is assumed to be:</p>
<ul>
<li>Infinite call stack</li>
<li>Infinite memory</li>
</ul>
<p>This is basically a port of my <a href="https://codegolf.stackexchange.com/a/184808/">JavaScript answer</a> and <a href="https://codegolf.stackexchange.com/a/197173/">Python 3 answer</a>. For more details, check those.</p>
<p>The compression was done with <a href="https://naruyoko.github.io/tests/compression/Ruby/" rel="nofollow noreferrer">this</a>.</p>
<p>I am a beginner at Ruby, so maybe under 512 is possible, but I doubt it.</p>
<ul>
<li>553-&gt;544B, -9B
<ul>
<li>Added 3 bytes from fixing a formatting error.</li>
<li>5 bytes from removing an unused print.</li>
<li>4 bytes from changing expression <code>t-(f&gt;v ?1: 0)*c</code> to <code>f&gt;v ?t-c: t</code></li>
<li>1 byte from removing an unnecessary assignment to <code>t</code>.</li>
<li>2 bytes from removing an assignment to <code>r</code>.</li>
</ul>
</li>
<li>544-&gt;535B, -9B
<ul>
<li>Improved the decoder.</li>
</ul>
</li>
<li>535-&gt;516B, -19B
<ul>
<li>17 bytes from changing functions to lambda expressions.</li>
<li>1 byte each from removing parenthesis from <code>split</code> and <code>eval</code>.</li>
<li>Thanks <a href="https://codegolf.stackexchange.com/users/9365/dom-hastings">@Dom Hastings</a>!</li>
</ul>
</li>
<li>516-&gt;511B, -5B
<ul>
<li>Use <code>a</code> and <code>r</code> declared globally, instead of <code>$a</code> and <code>$a</code>.</li>
</ul>
</li>
<li>511-&gt;507B, -4B
<ul>
<li>Change all 1 and 2 argument functions' arguments to <code>x,y=0</code>.</li>
</ul>
</li>
</ul>
</div>
<div id="pu6" class="pu"><h1>Python, 498 bytes, ???</h1>



<p>I don't know how large this program would get.</p>

<p>Okay, I've had a few failed attempts on this, but I think I've got it this time.  First, the code:</p>

<pre class="lang-python prettyprint-override"><code>from itertools import product as X
C=[1,0]
V=[9]
r=range
L=list
def R(n):
    C[0]=1
    while C[0]:
        C[0]=0
        for m in r(V[0]):P(m,n)
        if(C[0]&lt;1)+(C[1]&lt;len(V)):P(C[1],n,1)
    return sum(V)
def P(m,n,B=0,T=0):
    if m==len(V):V.append(0)
    k=m+n;c=r(k)
    for M in X(*[L(X(*[L(X(c,c,[-1,0,1]))]*k))]*k):
        t={};u=p=s=d=1
        while d:
            s,c,d=M[s][t.get(p,0)];t[p]=c;p+=d;u+=1
            if u&gt;sum(V):u=d=0
        T+=u
    if T&gt;V[m]:C[0]=V[m]=T;C[1]=min(C[1],m+1)
    if B&gt;C[0]:V[m]+=1;P(m,n,1)
z=9**9
exec("z=R(z);"*R(z))
print(z)
</code></pre>

<h1>Explanation:</h1>

<p>This function simulates all Turing machines with n states and n colours for a number of steps (initially 9), then sums the number of steps that it took for any machine that halted to halt, storing that value as the number of steps to take on the next iteration.  It keeps doing this until it reaches a steady state.</p>

<p>We don't just look at machines that have n states and colours, but also n+1, n+2, up to n+V[0], where V[0] is the sum of the halting times for the machines with n states and colours.</p>

<p>So far, I've just described a function which is polynomial at best.  Notably, it grows slower than the busy beaver function on these Turing machines.  Thus, we can be confident that there is at least one machine of size n which halts but we have not yet found.  So we search for that one (this function is undefined on inputs which are too small).</p>

<p>Once we find it, we continue on as we were.  We'll reach another steady state.  This time, we can't be confident that there is another halting Turing machine of size n, but as BB(n+1)>F(BB(n)) for any reasonable polynomial function F (which this is), we can be confident that there is a halting Turing machine of size n+1 which we have not found.  If we then find a halting machine of size n, we know that we can perform this step on n+1 again.</p>

<p>We repeat this process until we've attempted this on every size of machine we're looking at (from n to n+V[0]), and thus can no longer be confident that there is a machine that halts of those sizes that we have not seen.</p>

<p>While this number is certainly less than BB(n), I'm not sure how one would go about determining just how big it is.  The guarantee that it halts is basically "BB(n) grows much faster than this does".  I'm fairly confident that's a safe assumption for values of <code>R(n)</code> greater than, say, <code>R(5)</code>. </p>

<p>Here's a less golfed version with comments:</p>

<pre class="lang-python prettyprint-override"><code>from itertools import product as X
 # C[0] is 1 or 0 representing a change, so keep looping
 # C[1] is the next machine that needs to search.
C=[1,0]
 # V[x] is the total steps taken by the machine with n+x colours and states
V=[9]
def R(n):
    while C[0]:
        C[0]=0
        # Run each set of machines sum(V) steps.
        for m in range(V[0]):P(m,n)
        # Run machine set C[1] sum(V) steps, then run it until one more machine stops.
        if C[0]&lt;1 and C[1]&lt;len(V):P(C[1],n,1)
    return sum(V)
 # Run one set of machines with m+n colours and states.
def P(m,n,B=0):
    if m==len(V):V.append(0)
    # Start our total at 0
    T=0
    # For each machine in the set...
    for M in G(m+n):
        # Step count u starts at 0
        # The tape t starts empty
        # Position p starts at 1
        # State s starts at 1
        # Direction d starts at 1.  These are all 1 because it's shorter and we use d=0 as break
        t={};u=p=s=d=1
        while d:
            s,c,d=M[s][t.get(p,0)];t[p]=c;p+=d;u+=1
            if u&gt;sum(V):u=d=0
        T+=u
    # If the total is greater than the last time we ran this set, increase it and note there's been a change
    if T&gt;V[m]:
        C[0]=V[m]=T
        if m&lt;C[1]:C[1]=m+1
    # If we're running it until there's a change, increment V[m] and try again.
    if B&gt;C[0]:V[m]+=1;P(m,n,1)
 # Generate all the machines of appropriate size.
def G(k):
    L=list
    # List of colours
    c=range(k)
    # List of options for a single state/colour combination - new state, colour written, direction moved (0 being halt)
    O=L(X(c,c,[-1,0,1]))
    # List of options for one state
    S=L(X(*[O]*k))
    # List of options for all states
    return L(X(*[S]*k))
r=9**9
for i in range(R(r)):
    # Reset C[0], as we need to be able to run again.  C[1] will get reset in P().
    C[0]=1;r=R(r)
print(r)
</code></pre>

<p>Actually, it occurs to me that there's no reason why (in principle) we can know that <code>R(n) &lt; BB(n)</code> (when <code>BB(n)</code> is defined to be on Turing machines with n colours and states).  Determining exactly how big <code>R(n)</code> is is related to a limited version of the halting problem, as it isn't guaranteed that <span class="math-container">$$BB(n)*2^{n*2^{3n^2}}&lt;BB(n+1)$$</span> That's the limit on how quickly <code>R(n)</code> grows without the "look for the next terminating machine" step.  I think it's a pretty safe assumption, though, that it's true with <code>n&gt;5</code> or so.</p>

<p>while we can know that <code>R(n)</code> halts on big enough inputs, it's certainly possible that the result is in every case larger than <code>BB(n)</code>.  Proving such (if true) would be equivalent to the halting problem, of course.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/176966/">176966</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




