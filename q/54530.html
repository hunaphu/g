<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::54530</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>672</td><td>C++</td><td>150825T220441Z</td><td><a href="https://codegolf.stackexchange.com/questions/54530/print-increment-decrement-alias-interpret-prindeal/55298#55298">Jerry Je</a></td></tr>
<tr d-ix="1"><td>383</td><td>APL Dyalog Unicode</td><td>231001T201924Z</td><td><a href="https://codegolf.stackexchange.com/questions/54530/print-increment-decrement-alias-interpret-prindeal/265660#265660">boltcapt</a></td></tr>
<tr d-ix="2"><td>468</td><td>Uiua tentative</td><td>231003T235918Z</td><td><a href="https://codegolf.stackexchange.com/questions/54530/print-increment-decrement-alias-interpret-prindeal/265724#265724">Pseudo N</a></td></tr>
<tr d-ix="3"><td>688</td><td>Python</td><td>160406T200749Z</td><td><a href="https://codegolf.stackexchange.com/questions/54530/print-increment-decrement-alias-interpret-prindeal/77251#77251">The Fift</a></td></tr>
<tr d-ix="4"><td>nan</td><td>Common Lisp</td><td>150812T161027Z</td><td><a href="https://codegolf.stackexchange.com/questions/54530/print-increment-decrement-alias-interpret-prindeal/54565#54565">coredump</a></td></tr>
<tr d-ix="5"><td>1009</td><td>Haskell</td><td>150813T145048Z</td><td><a href="https://codegolf.stackexchange.com/questions/54530/print-increment-decrement-alias-interpret-prindeal/54631#54631">ankh-mor</a></td></tr>
<tr d-ix="6"><td>273</td><td>JavaScript ES6</td><td>150812T194133Z</td><td><a href="https://codegolf.stackexchange.com/questions/54530/print-increment-decrement-alias-interpret-prindeal/54579#54579">edc65</a></td></tr>
<tr d-ix="7"><td>136</td><td>Pyth</td><td>150813T023108Z</td><td><a href="https://codegolf.stackexchange.com/questions/54530/print-increment-decrement-alias-interpret-prindeal/54603#54603">isaacg</a></td></tr>
<tr d-ix="8"><td>653</td><td>C#6</td><td>150812T160558Z</td><td><a href="https://codegolf.stackexchange.com/questions/54530/print-increment-decrement-alias-interpret-prindeal/54564#54564">Sok</a></td></tr>
<tr d-ix="9"><td>373</td><td>Python 2</td><td>150812T073152Z</td><td><a href="https://codegolf.stackexchange.com/questions/54530/print-increment-decrement-alias-interpret-prindeal/54538#54538">Calvin&#</a></td></tr>
<tr d-ix="10"><td>328</td><td>Python 3</td><td>150812T150618Z</td><td><a href="https://codegolf.stackexchange.com/questions/54530/print-increment-decrement-alias-interpret-prindeal/54559#54559">Sp3000</a></td></tr>
<tr d-ix="11"><td>1322</td><td>Python 3</td><td>150812T105133Z</td><td><a href="https://codegolf.stackexchange.com/questions/54530/print-increment-decrement-alias-interpret-prindeal/54546#54546">Zach Gat</a></td></tr>
<tr d-ix="12"><td>486</td><td>Python 2</td><td>150812T110857Z</td><td><a href="https://codegolf.stackexchange.com/questions/54530/print-increment-decrement-alias-interpret-prindeal/54547#54547">PurkkaKo</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>C++, 672 bytes</h1>
<p><strong>Thanks to @ceilingcat for some very nice pieces of golfing - now even shorter (yet again!)</strong></p>
<p>This one is C++ - as idiomatic as I could make it.<br>
That means making it more C++-ish and less C-ish.<br>
That also means it is bigger than the equivalent C program.<br>
I think C++ rivals Java for the most verbose standard library.<br></p>
<pre><code>#import&lt;bits/stdc++.h&gt;
#define c(s);else if(B==#s)
#define e(n)(n=regex_replace(n,regex{&quot;^ *(.*?) *(#.*)?$&quot;},&quot;$1&quot;))[0]
#define i(x)get&lt;x+0&gt;(p[j-1])
#define k n[o[0]]
#define U;using
int j,v;U namespace std;U g=string;U h=istream_iterator&lt;g&gt;U s=deque&lt;g&gt;;map&lt;g,s&gt;m;map&lt;g,int&gt;n;tuple&lt;int,s,s&gt;p[999];main(){g Y;for(s X(3);getline(cin,Y);)if(e(Y))for(p[j++]={0,{Y,&quot;&quot;,&quot;&quot;},{}};bool z=j;){g B;s C,o;copy(h(stringstream(i(1)[i()])&gt;&gt;B),h(),back_inserter(C));for(g x:C)o.push_back((v=atoi(&amp;x[0]))&gt;0?i(2)[v-1]:x);if(0)c()c(p)cout&lt;&lt;o[0]+&quot; = &quot;&lt;&lt;k&lt;&lt;'\n'c(i)k++c(d)k-=z=k c(a)for(g&amp;y:X)for(;getline(cin,y),m[o[0]]=X,!e(y););else{p[j++]={0,m[B],o};continue;}while(j*i())j--;i()-=!!j*~!z;}}
</code></pre>
<p><a href="https://tio.run/##bVLRbuIwEHznK0yorrvEcNB7ap2kEv2GSkU5DgXHTUyIk4sdCkW5X@cWWtHrqZIVj@3xeHaysq5HmZTH40CXddW4YKWd/W5dKn1/nEe9QaqetVFMgkWhNlYx/QyzMBxYvJwpMAgmbFSmdstG1ZtE0hY/rw/eLzaE8fAeaRqMh3h/5XXcu5p6iPFkcdHQsMNMuWDnTyKo4/Vouvh4oGAmroj9QX8UrdUm62nj2JpvxSMzSalsTS8zMk/rLLSuIQrBPNSEVVIutVNN4qomyKJHZsNU/W4VYVEmdZBxG5XviGQjI1xbb1RAmFs6q@Pb29sFEbQBPGRsLp6rBix7gh8oyPqGfIHUhs9RIIWkYI54olA1vr8IDxN@mHPPo9HxQ9eJVVVt2Gu4Fie1mbDsgVdCVvUecnjz/uYaNEwx1oALjKIZ8hyQrxJZLLWxqqGK4AHxbCZju7sHrMZ1a/PliQKwDaleDd92FB9iNLnXcIPxluK926EgmxOUQKNGWbUuCE4x@x4LmRcERRBc/zTXEjQWvi8hxWIUvoYFNUNyriz7tr97OqNPAeyRl2//K3zifQV7CuTcO4ePKMp4tuBVR/Uap02rRPeS642C9ZAKxfVoJGgehf3@evin/yq67nhMmDayUaUybuletFQ9ptn0/ZOyKRsYtVUNo8xkrtLev/xV5fLLpc8qZ4n/tm6@FPxKjlG3uz0FztJWFr36siZ42vkL" rel="nofollow noreferrer" title="C++ (gcc) – Try It Online">Try it online!</a></p>
<p>Below is the original.  If anyone can think of a way to make it more idiomatic and shorter at the same time please let me know.</p>
<pre><code>#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;regex&gt;
#include &lt;sstream&gt;
#include &lt;stack&gt;

typedef std::vector&lt;std::string&gt; List;
typedef std::pair&lt;std::string, List&gt; Statement;
typedef std::array&lt;std::string, 3&gt; Alias;
typedef std::pair&lt;long, Alias&gt; IndexedAlias;
typedef std::pair&lt;IndexedAlias, List&gt; Item;

std::map&lt;std::string, Alias&gt; aliases;
std::map&lt;std::string, long&gt; variables;
std::stack&lt;Item&gt; stack;
std::regex re(&quot;^ *(.*?) *(#.*)?$&quot;);

int main()
{
    std::string line, line1, line2, line3;
    while (std::getline(std::cin, line)) // control-Z to exit
    {
        line = std::regex_replace(line, re, &quot;$1&quot;);
        if (line.empty()) continue;
        stack.push(Item{ { 0, { { line, &quot;&quot;, &quot;&quot; } } }, {} });

        bool flag;
        while (!stack.empty())
        {
            Statement statement;
            std::istringstream ss(stack.top().first.second[stack.top().first.first]);
            ss &gt;&gt; statement.first;
            std::copy(std::istream_iterator&lt;std::string&gt;(ss), std::istream_iterator&lt;std::string&gt;(), std::back_inserter(statement.second));

            List arguments;
            std::transform(std::begin(statement.second), std::end(statement.second), std::back_inserter(arguments),
                [](std::string arg){ int i = atoi(arg.c_str()); return i &gt; 0 ? stack.top().second[i - 1] : arg; });

            flag = true;
            if (statement.first == &quot;&quot;)
                ;
            else if (statement.first == &quot;p&quot;)
                std::cout &lt;&lt; arguments[0] &lt;&lt; &quot; = &quot; &lt;&lt; variables[arguments[0]] &lt;&lt; std::endl;
            else if (statement.first == &quot;i&quot;)
                variables[arguments[0]]++;
            else if (statement.first == &quot;d&quot;)
                variables[arguments[0]] -= (flag = variables[arguments[0]]);
            else if (statement.first == &quot;a&quot;)
            {
                do { std::getline(std::cin, line1); line1 = std::regex_replace(line1, re, &quot;$1&quot;); } while (line1.empty());
                do { std::getline(std::cin, line2); line2 = std::regex_replace(line2, re, &quot;$1&quot;); } while (line2.empty());
                do { std::getline(std::cin, line3); line3 = std::regex_replace(line3, re, &quot;$1&quot;); } while (line3.empty());
                aliases.insert(std::make_pair(arguments[0], Alias{ { line1, line2, line3 } }));
            }
            else
            {
                stack.push(Item{ { 0, aliases[statement.first] }, arguments });
                continue;
            }

            while (!stack.empty() &amp;&amp; stack.top().first.first) stack.pop();
            if (!stack.empty()) stack.top().first.first += 1 + !flag;
        }
    }

    std::cout &lt;&lt; &quot;-- Variables --&quot; &lt;&lt; std::endl;
    std::transform(std::begin(variables), std::end(variables), std::ostream_iterator&lt;std::string&gt;(std::cout, &quot;\n&quot;),
        [](std::map&lt;std::string, long&gt;::value_type pair){ std::ostringstream ss; ss &lt;&lt; pair.first &lt;&lt; &quot; = &quot; &lt;&lt; pair.second; return ss.str(); });
    std::cout &lt;&lt; &quot;-- Aliases --&quot; &lt;&lt; std::endl;
    std::transform(std::begin(aliases), std::end(aliases), std::ostream_iterator&lt;std::string&gt;(std::cout, &quot;\n&quot;),
        [](std::map&lt;std::string, Alias&gt;::value_type pair){ std::ostringstream ss; ss &lt;&lt; pair.first &lt;&lt; &quot; = [1]:&quot; &lt;&lt; pair.second[0] &lt;&lt; &quot; [2]:&quot; &lt;&lt; pair.second[1] &lt;&lt; &quot; [3]:&quot; &lt;&lt; pair.second[1]; return ss.str(); });
    std::cout &lt;&lt; &quot;---------------&quot; &lt;&lt; std::endl;

    return 0;
}
</code></pre>
</div>
<div id="pu1" class="pu"><h1>APL (Dyalog Unicode), <s>449</s> <s>422</s> <s>388</s> 383 bytes</h1>
<p>This is a somewhat optimized APL version of a program to run the Prindeal code. It assumes that the index origin is 0 (⎕IO←0). The Prindeal program to run is in an enclosed string array P.</p>
<pre><code>
z
L←0
V←N←F←M←⍬
r←{⍬≡h←⍸⎕D∊⍨⊃¨t←↑⍵:t⋄t[h]←⍺[⍎¨t[h]]⋄t}
R←{⍵/⍨∊0≠⍴∘∊¨⍵}{' '(≠⊆⊢)⍵/⍨~∨\'#'=⍵}∘∊¨P
k:e↑L⌷R
L+←1
→k/⍨L&lt;⍴R

{y}←e c;x
y←1
→((⊃c)∘≡∘,¨'pida')/p i d a
y←e c r x⌷⍨2-e c r 0⌷x←↑F[M⍳0⌷c]
→0
p:N[x],’=‘,2⊥⌽↑V[x←g c]
→0
i:V[x]←⊂{⍬≡⍵:1⋄⊃⍵:0,∇1↓⍵⋄1,1↓⍵}↑V[x←g c]
→0
d:→0/⍨~y←(,0)≢m←↑V[x←g c]
V[x]←⊂m↓⍨-(1=⍴m)⍱⊃⌽m←{⍬≡⍵:⍬⋄~⊃⍵:1,∇1↓⍵⋄0,1↓⍵}m
→0
a:M←M,1⌷c
F←F,⊂R[L+1+⍳3]
L+←3

x←g c
x←N⍳1⌷c
→0/⍨x&lt;⍴N
N←N,1⌷c
V←V,⊂,0

</code></pre>
<p>The code length was a bit less until I reread the specification that requires arbitrary precision integers. I added code to provide this functionality although I'd hate to wait around for a Prindel program that requires this feature to execute. Dialog APL does have some prewritten routines ('big') to provide this functionality, However, I felt it would be a bit of a cheat to use all that extra 'hidden' code and call it an inherent part of the language.</p>
<p>In any case, the program consists of eight basic functions as follows:</p>
<pre><code> z - this function initializes variables, strips comments, trailing blanks and empty lines; then loops through the Prindeal program code.

 e - this executes a Prindeal statement either an inherent statement (p,i,d,a) or a defined alias. Recursive.

 g - gets a reference to a variable value (defines if as-of-yet undefined)

 r - at execution time, resolves numerical reference to arguments in alias functions

</code></pre>
<p>Comments and improvements are welcomed. I first dabbled in APL in the late 60s and early 70s. Life took me in another direction, but apparently I never lost my interest in the language. I recently took a look at the state of the language (via Dialog) and found that what was a powerful language back in the day had only grown in complexity and capability. I'm using some of these code golf challenges to introduce me to the newer (to me) language features and have a bit of fun ... lifelong learning.</p>
<p>In any case, here is the output from the test program:</p>
<pre><code>
     z
 A = 0
 B = 0
 C = 0
 ____ = 0
 A = 1
 B = 1
 C = 2
 ____ = 0
 A = 1
 B = 3
 C = 2
 ____ = 0
 d = 6
 ____ = 0
 d = 18
 ____ = 0
 d = 0
 ____ = 0
 A = 8
 B = 3
 C = 2
 ____ = 0
 A = 9
 B = 3
 C = 2
 ____ = 0
 A = 9
 B = 3
 C = 729

<span class="math-container">```</span>
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://uiua.org" rel="nofollow noreferrer">Uiua</a> (tentative), 468 characters</h1>
<p><strong>Note that due to a bug in the interpreter, there is a spurious error preventing proper execution. Once the bug is fixed, I will update this answer to reflect that. Until then, I'm leaving the (tentative) in the heading.</strong></p>
<pre><code>p←⊂↯→(⊟∶□0□,)¬/+≡(|2≅!)→(↯→∶⧻).≡⊢.→(.!⊡1)!→→(⊡2)⊡1,∶
;∧(|2!⊡∶(⊂□1⊟□&amp;p/+∺(×≅→∶∷!⊢∶⊡1.),∶&amp;pf⊂∶&quot; = &quot;,p)_(⊂□1⊟□∺([∶∷□]+→(∶→≅.)!⊡1∶!⊢.)p)_(⊂⊟→□→≡(⍜'⊡1⍜!'↥0)/×≡(≥0!⊡1).∺([∶∷□]-∶→(∶→≅.)!⊡1∶!⊢.)p)_(|2↬2∶□/(⊂⊂∶@ ∷!)⊡-∶2!⊢,∶↬2∶□/(⊂⊂∶@ ∷!)⊢,∶→→;∺(|2⍜'↘1∺(|2□⍣(!⊡parse)(→;;)!)⊜□≠,@ !)→,↘1⊡∶!⊡2,⊗∶≡⊢!⊡2,⊢,)⊗∶[&quot;p&quot;&quot;i&quot;&quot;d&quot;]!⊢,∶⊜□≠@ .!∶)⊂{1[{&quot;1&quot;0}]}□→(▽¬∵(|1↥=@ ∶=@a.⊢!).)≡(⍜'↘1(∵⍜!(↘1))⍜⊢(⍜!(↘2)))⊜·▽∵(4;).+1⇡÷4⧻.▽∵(|1↥=@ ⊢∶≅&quot;a &quot;.↙2!)..▽↧1∵⧻.∵⍜!(⇌▽\↥×≠@\r∶≠@ ..⇌▽=0\+=@#.)⊜□≠@\n.&amp;ru@\00
</code></pre>
<p>This is my first Uiua program of more than a couple dozen characters, so I'm sure there's lots of places I could golf it more effectively. It was a good opportunity to practice the language, though :)</p>
<h2>Non-minified version</h2>
<pre><code># preexec state_alias_array command -&gt; state_array command_arg alias_array
preexec ← (
  ⊡1,∶ # put state on top
  !→→(⊡2) # get aliases (for later)
  →(.!⊡1) # get variable name (put two copies on stack for later)
  ≡⊢. # get list of current variable names 
  ¬/+≡(|2 ≅!) →(↯→∶⧻). # test if we need to add a new variable
  ⊂↯→(⊟∶□0□,) # add variable if necessary
)

# exec&lt;T&gt; state_alias_array command -&gt; state_alias_array
execp ← (
  preexec
  &amp;pf⊂∶&quot; = &quot;, # print &quot;varName = &quot;
  &amp;p/+∺(×≅→∶∷!⊢∶⊡1.),∶ # print &quot;varValue\n&quot;
  ⊂□1⊟□
)
execi ← (
  preexec
  ∺([∶∷□]+→(∶→≅.)!⊡1∶!⊢.) # increment the relevant variable
  ⊂□1⊟□ # reform state_alias_array
)
execd ← (
  preexec
  ∺([∶∷□]-∶→(∶→≅.)!⊡1∶!⊢.) # decrement the relevant variable
  /×≡(≥0!⊡1). # check if &lt;0
  →≡(⍜'⊡1⍜!'↥0) # reset back up to 0
  ⊂⊟→□ # reform state_alias_array
)
execcall ← (|2
  ⊢, # get alias name
  ⊗∶≡⊢!⊡2, # get index of call
  ↘1⊡∶!⊡2, # get subcommands
  →,
  ∺(|2
    ⊜□≠,@ ! # split box&quot;thing 1 2&quot; into [box&quot;thing&quot; box&quot;1&quot; box&quot;2&quot;]
    ⍜'↘1∺(|2 □⍣(!⊡parse)(→;;)!) # turn the 1 and 2 into first and second arguments
  )
  →→; # original call no longer necessary
  □/(⊂⊂∶@ ∷!)⊢,∶ # join [box&quot;i&quot; box&quot;dog&quot;] into box&quot;i dog&quot;
  ↬2∶ # call first
  ⊡-∶2!⊢,∶ # select second or third based on success
  □/(⊂⊂∶@ ∷!) # join [box&quot;i&quot; box&quot;dog&quot;] into box&quot;i dog&quot;
  ↬2∶
)

execline ← (|2
  ∶⊜□≠@ .!∶ # split command
  !⊡∶execp_execi_execd_execcall⊗∶[&quot;p&quot;&quot;i&quot;&quot;d&quot;]!⊢, # dispatch correct command
)

&amp;ru@\00

⊜□≠@\n. # split lines
∵⍜!(
  ▽=0\+=@#. # remove comments
  ⇌▽\↥×≠@\r∶≠@ ..⇌ # remove trailing whitespace
)
▽↧1∵⧻. # remove blank lines

▽∵(|1 ↥=@ ⊢∶≅&quot;a &quot;.↙2!).. # get alias definitions
⊜· ▽∵(4;).+1⇡÷4⧻. # separate out each alias
≡(
  ⍜⊢(⍜!(↘2)) # remove alias decl
  ⍜'↘1(∵⍜!(↘1)) # remove indentation
)
→(▽¬∵(|1 ↥=@ ∶=@a.⊢!).) # remove alias definitions from command list
⊂{1 [{&quot;123illegalvariable&quot; 0}]}□ # group last success, state array and alias array
∧execline # exec all instructions
;
</code></pre>
</div>
<div id="pu3" class="pu"><h1>Python - <s>695</s> 688 bytes</h1>
<pre class="lang-python prettyprint-override"><code>def p(v):print v,&quot;=&quot;,w.get(v,0)
def i(v):w[v]=w.get(v,0)+1
def d(v):
 if v in w:
&lt;TAB&gt;w[v]-=1
&lt;TAB&gt;if not w[v]:del w[v]
 else:return 1
def a(n,b,d,h):
 def g(*a):
&lt;TAB&gt;i=1;f=b;s=d;t=h
&lt;TAB&gt;for v in a:v=q+v+q;k=q+j(i)+q;f=c(f,k,v);s=c(s,k,v);t=c(t,k,v);i+=1
&lt;TAB&gt;y=u(t,e)if u(f,e)else u(s,e);i=1;return y
 e[n]=g
q=&quot;'&quot;;w=x={};u=eval;e={'a':a,'d':d,'i':i,'p':p};import sys;l=sys.stdin.readlines();r=&quot;&quot;;j=str;c=j.replace;sys.setrecursionlimit(2000)
for h in l:
 h = h.strip()
 if not h:continue
 l = h.split();f=l[0];n=f+&quot;(&quot;
 if &quot;#&quot; in f:continue
 for g in l[1:]:
&lt;TAB&gt;b=g.find(&quot;#&quot;)+1
&lt;TAB&gt;if b:g=g[:b-1]
&lt;TAB&gt;if g:n+=&quot;'%s',&quot;%g
&lt;TAB&gt;if b:break
 if x:x-=1;d+='&quot;%s)&quot;,'%n
 else:x=(f==&quot;a&quot;)*3;d=n
 if not x:d+=&quot;)\n&quot;;r+=d
exec r in e
</code></pre>
<p><code>&lt;TAB&gt;</code> is a literal tab character.</p>
</div>
<div id="pu4" class="pu"><h1>Common Lisp, <del>758</del> <del>646</del> 619</h1>



<pre class="lang-lisp prettyprint-override"><code>(progn(set-macro-character #\#(get-macro-character #\;))(setf(readtable-case *readtable*):invert)(#3=defun v(s)(if(boundp s)(eval s)0))(#3# i(s)(set s(1+ (v s))))(#3# d(s)(and(plusp(v s))(set s(1-(v s)))))(#3# p(s)(format t"~A = ~A~%"s(v s)))(defmacro a(n . p)`(#3#,(cadr n)(&amp;rest g)(if,@p)))(#3# k(s)(typecase s(integer`(nth,(1- s)g))(symbol `',s)(t(list*(car s)(mapcar 'k(cdr s))))))(#3# r()(prog(l p q)$(setf p()l(make-string-input-stream(or(read-line()()())(return))))@(when(setf p(read l()()))(push p q)(go @))(if q(return(k(reverse q)))(go $))))(do ((x(r)(r)))((not x))(eval(if(eq(car x)'a)`(,@x,(r),(r),(r))x))))
</code></pre>

<p>Put this in <code>file.lisp</code> and call for example <code>sbcl --script file.lisp</code>; input is read from the standard input stream. </p>

<p>This version parses a <em>superset</em> of Prindeal: without not much difficulties, you can access all Common Lisp from a Prindeal source. I consider this a <em>feature</em> of the intepreter.</p>

<h3>Commented version</h3>

<pre class="lang-lisp prettyprint-override"><code>;; copy-readtable is only used during development, so that I do not 
;; mess with my running environment. The real code starts with the
;; progn below, which is superfluous of course inside a let.
(let ((*readtable* (copy-readtable)))

  ;; I use PROGN in the golfed version so that I can have the whole
  ;; program as a unique tree. This allows me to define reader 
  ;; variables like #3=defun in order to gain a few bytes by writing
  ;; #3# instead of defun. Reader variables are removed in
  ;; this human-friendly version.
  (progn
    ;; Let # point to the same reader function as ;
    ;; Of course, ; is still usable as a comment delimiter
    (set-macro-character #\#
                         (get-macro-character #\;))

    ;; :invert does what is necessary to enable case-sensitive reading
    ;; and printing of symbols
    (setf (readtable-case *readtable*) :invert)

    ;; value of symbol, or zero
    (defun v(s)(if(boundp s)(eval s)0))

    ;; increment
    (defun i(s)(set s(1+ (v s))))

    ;; decrement
    (defun d(s)(and(plusp(v s))(set s(1-(v s)))))

    ;; print
    (defun p(s)(format t"~A = ~A~%"s(v s)))

    ;; alias: wrap an "if" inside a "defun".
    ;; YES, that means you can redefine ANY lisp function with "a" !
    ;; A safer version would properly intern symbols in a dedicated package.
    ;;
    ;; Notice the G variable.  We take advantage of the "unhygienic"
    ;; (what a bad adjective) nature of macros to create a context
    ;; where G is bound to the argument list. The same G is referenced
    ;; implicitely later.
    (defmacro a(n . p)`(defun,(cadr n)(&amp;rest g)(if,@p)))

    ;; Canonicalize expressions:
    ;;
    ;; - if s is a symbol, return s quoted. All functions manipulate
    ;; symbols in order to allow the undeclared use of variables. With
    ;; symbols, we can check for boundness.
    ;;
    ;; - if s is an integer, then we are inside an alias definition. The
    ;; integer is replaced by an access to the s'th element of the
    ;; implicit argument list G using (nth (1- s) g). G will be bound
    ;; when the expressions is injected in the defun corresponding to
    ;; the alias, or else an error will be signaled: either because G
    ;; is unbound, or because you defined a variable named G which is
    ;; by construction not a list. Since we do not sanitize properly
    ;; the input, you could bind G globally to a list, but that would be
    ;; nasty.
    ;; 
    ;; - Finally, if s is a list, apply k to all but the first
    ;; elements of s.  The first element is a symbol but we do not
    ;; need to quote it because we want to call the function
    ;; associated with the symbol. Due to the Lisp-2-ness
    ;; of Common Lisp, functions and variables can coexist
    ;; with the same name.
    ;;
    (defun k(s)(typecase s
                 (integer`(nth,(1- s)g))
                 (symbol`',s)
                 (t(list*(car s)(mapcar #'k(cdr s))))))

    ;; Reader function
    (defun r()
      (prog (l ; current line, as an input-stream reading a string
             p ; current read form
             q ; whole line and return value, as a list
             )

         ;; PROG includes an implicit TAGBODY. Below, $ and @ are
         ;; labels for GO statements (gotos).

       $ (setf
          ;; emtpy p
          p ()

          ;; Read a whole line and if we do not fail, build an input
          ;; stream to read from it.
          l (make-string-input-stream
             (or (read-line()()()) ;; try to read a line,
                 (return)          ;; but return from prog if we reach
                                   ;; the end of file.
                 )))
       @ (when (setf p (read l()()))
           ;; Read a lisp expression, put it in p and if p is not nil
           ;; push it into q.  A nil could happen at the end of the
           ;; line or if someone (you know who) inserted an empty list
           ;; in the file being read.
           ;; 
           ;; Thanks to the readtable which now handles comments
           ;; and spaces for us, nothing needs to be done here to
           ;; preprocess the input.

           (push p q) (go @))

         ;; If we read an empty line, q can be nil. In this case, go
         ;; back to $ and read another line. If q is not nil, reverse
         ;; it (we pushed, remember), canonicalize it and return the
         ;; result.
         (if q (return(k(reverse q))) (go $)))
      )

    ;; Read/eval loop.  When reading "(a name)", we read the three
    ;; next lines and append them to the first so that it builds a
    ;; call the the alias definition macro a. Otherwise, just eval x.
    (do((x(r)(r))((not x))
      (eval (if (eq(car x'a))
                `(,@x,(r),(r),(r))
                x)))))
</code></pre>

<h1>Example</h1>

<pre class="lang-sh prettyprint-override"><code>~$ sbcl --script file.lisp &lt; testfile

A = 0
B = 0
C = 0
____ = 0
A = 1
B = 1
C = 2
____ = 0
A = 1
B = 3
C = 2
____ = 0
d = 6
____ = 0
d = 18
____ = 0
d = 0
____ = 0
A = 8
B = 3
C = 2
____ = 0
A = 9
B = 3
C = 2
____ = 0
A = 9
B = 3
C = 729
</code></pre>

<p>If we replace <code>eval</code> by <code>print</code> in the read/eval loop, then we can see what is being evaluated:</p>

<pre class="lang-lisp prettyprint-override"><code>(a 's (i '_) (d '_) (d '_)) 
(a 'f (d '_) (d '_) (d '_)) 
(a 'z (d (nth 0 g)) (z (nth 0 g)) (s)) 
(a 'n (z (nth 0 g)) (i (nth 0 g)) (s)) 
(a 'move (moveH (nth 0 g) (nth 1 g)) (move (nth 0 g) (nth 1 g)) (s)) 
(a 'moveH (d (nth 0 g)) (i (nth 1 g)) (f)) 
(a 'dupe (dupeH1 (nth 0 g) (nth 1 g) (nth 2 g))
   (dupe (nth 0 g) (nth 1 g) (nth 2 g)) (s)) 
(a 'dupeH1 (d (nth 0 g)) (dupeH2 (nth 1 g) (nth 2 g)) (f)) 
(a 'dupeH2 (i (nth 0 g)) (i (nth 1 g)) (s)) 
(a 'copy (z (nth 1 g)) (copyH (nth 0 g) (nth 1 g)) (s)) 
(a 'copyH (dupe (nth 0 g) (nth 1 g) '_copy) (move '_copy (nth 0 g)) (s)) 
(a 'addTo (copy (nth 1 g) '_add) (move '_add (nth 0 g)) (s)) 
(a 'add (z (nth 0 g)) (addH (nth 0 g) (nth 1 g) (nth 2 g)) (s)) 
(a 'addH (addTo (nth 0 g) (nth 1 g)) (addTo (nth 0 g) (nth 2 g)) (s)) 
(a 'mul (mulH1 (nth 0 g) (nth 1 g)) (mulH2 (nth 0 g) (nth 2 g)) (s)) 
(a 'mulH1 (z (nth 0 g)) (copy (nth 1 g) '_mul) (s)) 
(a 'mulH2 (mulH3 (nth 0 g) (nth 1 g)) (mulH2 (nth 0 g) (nth 1 g)) (s)) 
(a 'mulH3 (d '_mul) (addTo (nth 0 g) (nth 1 g)) (f)) 
(a 'mulBy (mul '_mulBy (nth 0 g) (nth 1 g)) (copy '_mulBy (nth 0 g)) (s)) 
(a 'pow (powH1 (nth 0 g) (nth 2 g)) (powH2 (nth 0 g) (nth 1 g)) (s)) 
(a 'powH1 (n (nth 0 g)) (copy (nth 1 g) '_pow) (s)) 
(a 'powH2 (powH3 (nth 0 g) (nth 1 g)) (powH2 (nth 0 g) (nth 1 g)) (s)) 
(a 'powH3 (d '_pow) (mulBy (nth 0 g) (nth 1 g)) (f)) 
(p 'A) 
(p 'B) 
(p 'C) 
(n 'A) 
(n 'B) 
(add 'C 'A 'B) 
(p '____) 
(p 'A) 
(p 'B) 
(p 'C) 
(add 'B 'A 'C) 
(p '____) 
(p 'A) 
(p 'B) 
(p 'C) 
(mul 'd 'B 'C) 
(p '____) 
(p 'd) 
(mulBy 'd 'B) 
(p '____) 
(p 'd) 
(d 'A) 
(mulBy 'd 'A) 
(p '____) 
(p 'd) 
(pow 'A 'C 'B) 
(p '____) 
(p 'A) 
(p 'B) 
(p 'C) 
(pow 'A 'B 'C) 
(p '____) 
(p 'A) 
(p 'B) 
(p 'C) 
(pow 'C 'A 'B) 
(p '____) 
(p 'A) 
(p 'B) 
(p 'C)
</code></pre>

<h3>Macroexpansion</h3>

<p>If we pick the following alias definition:</p>

<pre class="lang-lisp prettyprint-override"><code>(a 'powH2 (powH3 (nth 0 g) (nth 1 g)) (powH2 (nth 0 g) (nth 1 g)) (s))
</code></pre>

<p>... we can see references to a variable named <code>g</code> which is nowhere to be found in the lexical scope. But after macroexpansion, here is the actual code  being evaluated: </p>

<pre class="lang-lisp prettyprint-override"><code>(defun powH2 (&amp;rest g)
  (if (powH3 (nth 0 g) (nth 1 g))
      (powH2 (nth 0 g) (nth 1 g))
      (s))) 
</code></pre>

<p>Now, <code>g</code> refers to the argument list of the function being defined.</p>
</div>
<div id="pu5" class="pu"><h1>Haskell, 1009</h1>

<p>I did my best to golf it; my ungolfed code consisted of over 3,000 characters. At this point I can't remember what all the functions are doing so golfing it more mean guessing what will break it and what won't.</p>



<pre class="lang-haskell prettyprint-override"><code>import qualified Data.Map as M
import Control.Monad.State.Lazy
import Data.List
type A=M.Map String
data P=P(A Int)(A([String]-&gt;StateT P IO Int))
a f=evalStateT f(P M.empty$M.fromList[("i",\(b:_)-&gt;(+1)%b),("d",\(b:_)-&gt;pred%b),("p",\(b:_)-&gt;i b&gt;&gt;= \v-&gt;liftIO(putStrLn$b++"="++show v)&gt;&gt;q 1)])
e(k:l)=do{(P v a)&lt;-get;put.P v$M.insert k(m l)a;q 1}
g t s f= \a-&gt;t a&gt;&gt;= \b-&gt;if b&gt;0then s a else f a
f%k=f&lt;$&gt;i k&gt;&gt;= \v-&gt;if v&lt;0then k#0&gt;&gt;q 0else k#v&gt;&gt;q 1
i k=get&gt;&gt;= \(P v _)-&gt;q$M.findWithDefault 0 k v
k#v=get&gt;&gt;= \(P b a)-&gt;put$P(M.insert k v b)a
l k=get&gt;&gt;= \(P _ a)-&gt;q$a M.!k
f s=let(f:a)=r s in($a)&lt;$&gt;l f&gt;&gt;=id
m(t:s:f:_)=g(k t)(k s)(k f)
k s=let(f:b)=r s in\a-&gt;($(map((\y z-&gt;if all(\c-&gt;c&gt;'/'&amp;&amp;c&lt;':')z then y!!(read z-1)else z)a)b))&lt;$&gt;l f&gt;&gt;=id
n=dropWhileEnd(==' ').takeWhile(not.(=='#')).dropWhile(==' ')
o[]=[]
o(l:ls)|(head.r$l)=="a"=(l:take 3 ls):(o$drop 3 ls)|1&gt;0=[l]:o ls
p s|length s&gt;1=e$(n.tail.head$s):tail s|1&gt;0=f.head$s
q=return
main=join$a.(\s-&gt;mapM_ p(o.filter(not.null).map n.lines$s))&lt;$&gt;getContents
r=words
</code></pre>
</div>
<div id="pu6" class="pu"><h1>JavaScript (ES6), 273 <s>258</s></h1>

<p><strong>Edit</strong> Fixed bugs and added a real test suite.</p>

<p>Not counting leading spaces and newlines.</p>

<p>Surely can be golfed a little more.</p>

<p>Too tired to write an explanation now, I think it's a good example of using closures to keep alive temporary values (parameters).</p>

<p>Test running the snippet on any EcmaScript 6 compliant browser (notably not Chrome not MSIE. I tested on Firefox, Safari 9 could go)</p>

<p><div class="snippet" data-lang="js" data-hide="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>F=p=&gt;(
  p=p.match(/^[^#\n]+/gm).filter(r=&gt;r.trim(o='',v=[])),
  s={
    '':_=&gt;1,
    p:a=&gt;o+=a+` = ${v[a]||0}\n`,
    i:a=&gt;v[a]=-~v[a],
    d:a=&gt;v[a]&amp;&amp;v[a]--,
    a:(n,j)=&gt;s[n]=(u,t,a)=&gt;x(p[!x(p[j+1],0,a,1)+j+2],0,a,1)
  },
  p.map(x=(r,i,w,l,a=r.split(/ +/).slice(l).map(x=&gt;-x?w[x]:x))=&gt;s[a[0]](a[1],i,a)),
  o
)

// TEST

$('#O tr').each(function() {
  var $cells = $(this).find('td')
  var prg = $cells.eq(0).text()
  console.log(prg)
  var output = F(prg)
  $cells.eq(1).text(output)
})</code></pre>
<pre class="snippet-code-css lang-css prettyprint-override"><code>#O td { vertical-align:top; white-space: pre; border: 1px solid #888; font-family:monospace }</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"&gt;&lt;/script&gt;
&lt;table&gt;
&lt;tr&gt;&lt;th&gt;Program&lt;/th&gt;&lt;th&gt;Outpout&lt;/th&gt;&lt;/tr&gt;
&lt;tbody id=O&gt;  
&lt;tr&gt;&lt;td&gt;p _MyVariable_321
p screaming_hairy_armadillo&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;i alpaca
p alpaca
i alpaca
p alpaca&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;i malamute
p malamute
d malamute    #success
p malamute
d malamute    #failure
p malamute
d akita       #failure
p akita&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;a increment_frog_twice
 i frog
 i frog
 d frog
p frog
increment_frog_twice
p frog&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;a increment_twice
 i 1
 i 1
 d 1 #never reached
a increment_both_twice
 increment_twice 1
 increment_twice 2
 d 1 #never reached
increment_both_twice platypus duck
p platypus
p duck&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;a set_to_zero
 d 1
 set_to_zero 1
 i _dummy_
i oryx
i oryx
i oryx
p oryx
set_to_zero oryx
p oryx&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;#Command Definitions:
a s             #flag as a success
 i _
 d _
 d _
a f             #flag as a failure
 d _
 d _
 d _
a z             #1 = zero
 d 1
 z 1
 s
a n             #1 = one
 z 1
 i 1
 s
a move          #2 += 1, 1 = zero
 moveH 1 2
 move 1 2
 s
a moveH         #move helper
 d 1
 i 2
 f
a dupe          #2 += 1, 3 += 1, 1 = zero
 dupeH1 1 2 3
 dupe 1 2 3
 s
a dupeH1        #dupe helper
 d 1
 dupeH2 2 3
 f
a dupeH2        #dupe helper
 i 1
 i 2
 s
a copy          #2 = 1
 z 2
 copyH 1 2
 s
a copyH         #copy helper
 dupe 1 2 _copy
 move _copy 1
 s
a addTo         #1 += 2
 copy 2 _add
 #testing comments #
 move _add 1#in weird places # just because #
 s
#it's a g##d idea
###
a add           #1 = 2 + 3
 #its a good idea
 z 1
 addH 1 2 3
 s
##

#
a addH          #add helper
#this is a comment
 addTo 1 2 #as is this
 addTo 1 3
 s
a mul           #1 = 2 * 3
 mulH1 1 2
 mulH2 1 3
 s
a mulH1         #mul helper
 z 1
 copy 2 _mul
 s
a mulH2         #mul helper
 mulH3 1 2
 mulH2 1 2
 s
a mulH3         #mul helper
 d _mul
 addTo 1 2
 f
a mulBy         #1 *= 2
 mul _mulBy 1 2
 copy _mulBy 1
 s
a pow           #1 = 2^3
 powH1 1 3
 powH2 1 2
 s
a powH1         #pow helper
 n 1
 copy 2 _pow
 s
a powH2         #pow helper
 powH3 1 2
 powH2 1 2
 s
a powH3         #pow helper
 d _pow
 mulBy 1 2
 f

#Running Tests:
p A
p B
p C
n A         #A = 1
n B         #B = 1
add C A B   #C = A + B = 1 + 1 = 2
p ____
p A
p B
p C
add B A C   #B = A + C = 1 + 2 = 3
p ____
p A
p B
p C
mul d B C   #d = B * C = 3 * 2 = 6
p ____
p d
mulBy d B   #d = d * B = 6 * 3 = 18
p ____
p d
d A         #A = A - 1 = 1 - 1 = 0
mulBy d A   #d = d * A = 18 * 0 = 0
p ____
p d
pow A C B   #A = C ^ B = 2 ^ 3 = 8
p ____
p A
p B
p C
pow A B C   #A = B ^ C = 3 ^ 2 = 9
p ____
p A
p B
p C
pow C A B   #C = A ^ B = 9 ^ 3 = 729
p ____
p A
p B
p C  
&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</code></pre>
</div>
</div>
</p>
</div>
<div id="pu7" class="pu"><h1>Pyth, <s>162</s> 136 bytes</h1>

<pre><code>JfTmchcd\#).zKHW&lt;ZlJI!e=T@J~+Z1=@Tk)=k0 .x=J+]h=Nm.xL@Tskd@K=NhT+]+tN0&gt;J~Z0,=Y.x@H=eT0?qN\pps[Td\=dYb)?xGN?qN\iXHThY?YXTH_1=k1XKT:JZ=+Z3
</code></pre>

<p><a href="https://pyth.herokuapp.com/?code=JfTmchcd%5C%23).zKHW%3CZlJ%3DG%40JZI!eG%3D%40GT)%3DT0%3DNhGI.x%7DNK0%3Dkm.xL%40Gskd%40KN%3DJ%2B%5Dhk%2B%5D%2Btk0%3EJhZ%3DZ0)E%3DeG%3DY.x%40HG0%3D%2BZ1IqN%5Ca%20XKG%3AJZ%2BZ3%3D%2BZ3)IqN%5Cpjd%5BG%5C%3DY))IqN%5Ci%20XHGhY)IqN%5CdIY%20XGH_1)E%3DT1&amp;input=%23Command%20Definitions%3A%0Aa%20s%20%20%20%20%20%20%20%20%20%20%20%20%20%23flag%20as%20a%20success%0A%20i%20_%0A%20d%20_%0A%20d%20_%0Aa%20f%20%20%20%20%20%20%20%20%20%20%20%20%20%23flag%20as%20a%20failure%0A%20d%20_%0A%20d%20_%0A%20d%20_%0Aa%20z%20%20%20%20%20%20%20%20%20%20%20%20%20%231%20%3D%20zero%0A%20d%201%0A%20z%201%0A%20s%0Aa%20n%20%20%20%20%20%20%20%20%20%20%20%20%20%231%20%3D%20one%0A%20z%201%0A%20i%201%0A%20s%0Aa%20move%20%20%20%20%20%20%20%20%20%20%232%20%2B%3D%201%2C%201%20%3D%20zero%0A%20moveH%201%202%0A%20move%201%202%0A%20s%0Aa%20moveH%20%20%20%20%20%20%20%20%20%23move%20helper%0A%20d%201%0A%20i%202%0A%20f%0Aa%20dupe%20%20%20%20%20%20%20%20%20%20%232%20%2B%3D%201%2C%203%20%2B%3D%201%2C%201%20%3D%20zero%0A%20dupeH1%201%202%203%0A%20dupe%201%202%203%0A%20s%0Aa%20dupeH1%20%20%20%20%20%20%20%20%23dupe%20helper%0A%20d%201%0A%20dupeH2%202%203%0A%20f%0Aa%20dupeH2%20%20%20%20%20%20%20%20%23dupe%20helper%0A%20i%201%0A%20i%202%0A%20s%0Aa%20copy%20%20%20%20%20%20%20%20%20%20%232%20%3D%201%0A%20z%202%0A%20copyH%201%202%0A%20s%0Aa%20copyH%20%20%20%20%20%20%20%20%20%23copy%20helper%0A%20dupe%201%202%20_copy%0A%20move%20_copy%201%0A%20s%0Aa%20addTo%20%20%20%20%20%20%20%20%20%231%20%2B%3D%202%0A%20copy%202%20_add%0A%20move%20_add%201%0A%20s%0Aa%20add%20%20%20%20%20%20%20%20%20%20%20%231%20%3D%202%20%2B%203%0A%20z%201%0A%20addH%201%202%203%0A%20s%0Aa%20addH%20%20%20%20%20%20%20%20%20%20%23add%20helper%0A%20addTo%201%202%0A%20addTo%201%203%0A%20s%0Aa%20mul%20%20%20%20%20%20%20%20%20%20%20%231%20%3D%202%20*%203%0A%20mulH1%201%202%0A%20mulH2%201%203%0A%20s%0Aa%20mulH1%20%20%20%20%20%20%20%20%20%23mul%20helper%0A%20z%201%0A%20copy%202%20_mul%0A%20s%0Aa%20mulH2%20%20%20%20%20%20%20%20%20%23mul%20helper%0A%20mulH3%201%202%0A%20mulH2%201%202%0A%20s%0Aa%20mulH3%20%20%20%20%20%20%20%20%20%23mul%20helper%0A%20d%20_mul%0A%20addTo%201%202%0A%20f%0Aa%20mulBy%20%20%20%20%20%20%20%20%20%231%20*%3D%202%0A%20mul%20_mulBy%201%202%0A%20copy%20_mulBy%201%0A%20s%0Aa%20pow%20%20%20%20%20%20%20%20%20%20%20%231%20%3D%202%5E3%0A%20powH1%201%203%0A%20powH2%201%202%0A%20s%0Aa%20powH1%20%20%20%20%20%20%20%20%20%23pow%20helper%0A%20n%201%0A%20copy%202%20_pow%0A%20s%0Aa%20powH2%20%20%20%20%20%20%20%20%20%23pow%20helper%0A%20powH3%201%202%0A%20powH2%201%202%0A%20s%0Aa%20powH3%20%20%20%20%20%20%20%20%20%23pow%20helper%0A%20d%20_pow%0A%20mulBy%201%202%0A%20f%0A%0A%23Running%20Tests%3A%0Ap%20A%0Ap%20B%0Ap%20C%0An%20A%20%20%20%20%20%20%20%20%20%23A%20%3D%201%0An%20B%20%20%20%20%20%20%20%20%20%23B%20%3D%201%0Aadd%20C%20A%20B%20%20%20%23C%20%3D%20A%20%2B%20B%20%3D%201%20%2B%201%20%3D%202%0Ap%20____%0Ap%20A%0Ap%20B%0Ap%20C%0Aadd%20B%20A%20C%20%20%20%23B%20%3D%20A%20%2B%20C%20%3D%201%20%2B%202%20%3D%203%0Ap%20____%0Ap%20A%0Ap%20B%0Ap%20C%0Amul%20d%20B%20C%20%20%20%23d%20%3D%20B%20*%20C%20%3D%203%20*%202%20%3D%206%0Ap%20____%0Ap%20d%0AmulBy%20d%20B%20%20%20%23d%20%3D%20d%20*%20B%20%3D%206%20*%203%20%3D%2018%0Ap%20____%0Ap%20d%0Ad%20A%20%20%20%20%20%20%20%20%20%23A%20%3D%20A%20-%201%20%3D%201%20-%201%20%3D%200%0AmulBy%20d%20A%20%20%20%23d%20%3D%20d%20*%20A%20%3D%2018%20*%200%20%3D%200%0Ap%20____%0Ap%20d%0Apow%20A%20C%20B%20%20%20%23A%20%3D%20C%20%5E%20B%20%3D%202%20%5E%203%20%3D%208%0Ap%20____%0Ap%20A%0Ap%20B%0Ap%20C%0Apow%20A%20B%20C%20%20%20%23A%20%3D%20B%20%5E%20C%20%3D%203%20%5E%202%20%3D%209%0Ap%20____%0Ap%20A%0Ap%20B%0Ap%20C%0Apow%20C%20A%20B%20%20%20%23C%20%3D%20A%20%5E%20B%20%3D%209%20%5E%203%20%3D%20729%0Ap%20____%0Ap%20A%0Ap%20B%0Ap%20C&amp;debug=0">Demonstration.</a></p>

<p>Golfed out 26 characters by inlining variables and changing from <code>I</code> and <code>E</code> based control flow to <code>?</code> and <code>.x</code> based control flow.</p>

<p>For the first time ever, I ran out of variables in Pyth. Every single variable in Pyth (<code>bdkGHNTY</code> and <code>JK</code>) was in use, and I wanted to use <code>b</code> as a newline. Fortunaely, I was able to use <code>N</code> to mean two completely different things in different parts of the program, and so it still works.</p>

<h3>Ungolfed (run with -m):</h3>

<pre><code>JfTmchcd\#).z
KH
W&lt;ZlJ
  I!e=T@J~+Z1
    =@Tk)
  =k0
     .x
      =J+]h=Nm.xL@Tskd@K=NhT+]+tN0&gt;J~Z0
      ,
        =Y.x@H=eT0
        ?qN\p
          ps[Td\=dYb)
          ?xGN
            ?qN\i
              XHThY
              ?Y
                XTH_1
                =k1
            XKT:JZ=+Z3
</code></pre>
</div>
<div id="pu8" class="pu"><h1>C#6, 653 bytes</h1>



<p>Here's my entry, amidst a sea of Python...</p>

<pre class="lang-cs prettyprint-override"><code>class P{string[]l;string r="";Dictionary&lt;string,int&gt;v=new Dictionary&lt;string,int&gt;();Dictionary&lt;string,int&gt;s=new Dictionary&lt;string,int&gt;();public string R(string t){l=t.Split('\n');for(int i=0;i&lt;l.Length;i++){var z=l[i].Split(' ');if(z[0]=="a"){s.Add(z[1],i);i+=3;}else E(i, null);}return r;}bool E(int n,string[]p){var z=l[n].Split(' ');var a=z.Skip(1).Select(x=&gt;Char.IsDigit(x[0])?p[int.Parse(x)-1]:x).ToArray();if(a.Length&gt;0&amp;&amp;!v.ContainsKey(a[0]))v[a[0]]=0;if (z[0]=="p")r+=$"{a[0]} = {v[a[0]]}\n";else if(z[0]=="i")v[a[0]]++;else if(z[0]=="d")if(v[a[0]]&gt;0)v[a[0]]--;else return false;else{var y=s[z[0]];return E(y+1,a)?E(y+2,a):E(y+3,a);}return true;}}
</code></pre>

<p>Expanded and commented:</p>

<pre class="lang-cs prettyprint-override"><code>class Prindeal
{
    string[] lines;
    string result = "";
    Dictionary&lt;string, int&gt; variables = new Dictionary&lt;string, int&gt;();
    Dictionary&lt;string, int&gt; statements = new Dictionary&lt;string, int&gt;();

    public string Run(string text)
    {
        lines = text.Split('\n');

        for (int i = 0; i &lt; lines.Length; i++)
        {
            // Split on spaces to get the statement and any arguments
            var z = lines[i].Split(' ');

            // Are we defining a new statement?
            if (z[0] == "a")
            {
                // Add to the statements dictionary, step over definition statements
                statements.Add(z[1], i);
                i += 3;
            }
            else
            {
                // Execute the statement
                Execute(i, null);
            }
        }

        return result;
    }

    bool Execute(int lineNumber, string[] parameters)
    {
        // Split on spaces to get the statement and any arguments
        var z = lines[lineNumber].Split(' ');

        // Parse the arguments - if it's a number, get the corresponding 
        // parameter from the calling statement
        var arguments = z.Skip(1).Select(
            x =&gt; Char.IsDigit(x[0]) ? 
            parameters[int.Parse(x) - 1] : 
            x)
            .ToArray();

        // If the first argument isn't already in the variables dict, add it
        if (arguments.Length &gt; 0 &amp;&amp; !variables.ContainsKey(arguments[0])) variables[arguments[0]] = 0;

        // Print statement, using string interpolation
        if (z[0] == "p")
            result += $"{arguments[0]} = {variables[arguments[0]]}\n";
        // Increment statement
        else if (z[0] == "i")
            variables[arguments[0]]++;
        // Decrement statement
        else if (z[0] == "d")
            if (variables[arguments[0]] &gt; 0)
                variables[arguments[0]]--;
            else
                return false;
        else
        {
            // Get the line number to jump to
            var y = statements[z[0]];

            // Execute A ? B : C
            return Execute(y + 1, arguments) ? Execute(y + 2, arguments) : Execute(y + 3, arguments);
        }

        // If we reach this point, it's from a 'p', 'i' or 'd' statement which has succeeded
        return true;
    }
}
</code></pre>

<p>To use it, simply instantiate the class and call the <code>R()</code> method, for example:</p>

<pre class="lang-cs prettyprint-override"><code>string prindealText = new StreamReader("prindeal.txt").ReadToEnd();
Console.WriteLine(new P().R(prindealText));
</code></pre>
</div>
<div id="pu9" class="pu"><h1>Python 2, <s>600</s> <s>584</s> <s>397</s> 373 bytes</h1>
<p>This is my own golfed reference solution. Anyone is welcome to improve it or follow its logic in their own answer as long as attribution is given.</p>
<p>The neat part about it is that no recursion is done, so it will never have problems with Python's recursion limit. For example, <a href="https://codegolf.stackexchange.com/a/54559/26997">Sp's</a> Countup Prindeal program can run indefinitely.</p>
<pre class="lang-python prettyprint-override"><code>p=filter(len,[l.split('#')[0].split()for l in input().split('\n')]);m={};v={};i=0
while i&lt;len(p):
 s=p[i]
 if'('in`s`:s=s[f]
 n,f=s[0],0
 if n in m:a,b,c=([s[int(g)]if g.isdigit()else g for g in t]for t in m[n]);p=[a,(b,c)]+p[i+1:];i=0;continue
 s=s[1]
 q=v.get(s,0)
 if'd'&gt;n:m[s]=p[i+1:i+4];i+=3
 elif'i'&lt;n:print s,'=',q
 elif'd'&lt;n:v[s]=q+1
 elif q:v[s]-=1
 else:f=1
 i+=1
</code></pre>
<p>It's a program that takes in the quoted program string with newlines escaped, e.g.<br />
<code>'p _MyVariable_321\np screaming_hairy_armadillo'</code>.</p>
<p>I took various golfing cues from <a href="https://codegolf.stackexchange.com/a/54559/26997">Sp's</a> and <a href="https://codegolf.stackexchange.com/a/54547/26997">Pietu's</a> answers. Thanks guys :)</p>
</div>
<div id="pu10" class="pu"><h1>Python 3, <s>345</s> <s>336</s> <s>335</s> 328 bytes</h1>
<pre class="lang-py prettyprint-override"><code>a=0
A={}
V={}
def f(l):
 if l[0]in&quot;d p i&quot;:c,u=l;U=V[u]=V.get(u,0)+&quot;pi&quot;.find(c);S=U&lt;0;V[u]+=S;c&lt;&quot;p&quot;or print(u,&quot;=&quot;,U)
 else:d=lambda q:[w.isdigit()and l[int(w)]or w for w in A[l[0]][q]];S=f(d(1+f(d(0))))
 return S
for z in open(&quot;P&quot;):
 l=z.split(&quot;#&quot;)[0].split()
 if&quot;a &quot;==z[:2]:a,s,*x=3,l[1]
 elif l*a:x+=l,;a-=1;A[s]=x
 elif l:f(l)
</code></pre>
<p><em>(-6 bytes thanks to @orlp)</em></p>
<p>Still golfing. Assumes the program is stored in a file named <code>P</code>.</p>
<p>Putting the calls to <code>f</code> inside the lambda <code>d</code> would save a few bytes, but it would make the last test case hit max recursion depth.</p>
<h2>Some Prindeal programs</h2>
<h3>The useless subtraction program</h3>
<p>Here is <a href="http://pastebin.com/8u4hXDdd" rel="nofollow noreferrer">a useless subtraction program</a>. It's useless because, even though it subtracts properly, it doesn't return success/failure accordingly.</p>
<p>The output should be:</p>
<pre><code>a = 15
b = 6
__________ = 0
a = 9
b = 6
</code></pre>
<h3>Countup</h3>
<pre><code>a helper
 p 1
 countup 1
 i success
 
a countup
 i 1
 helper 1
 d failure
 
countup n
</code></pre>
<p>Counts upwards and prints <code>n</code> forever. Could possibly work as a test for interpreter speed (beware the long tracebacks on keyboard interrupt).</p>
</div>
<div id="pu11" class="pu"><h1>Python 3, 1322 bytes</h1>
<p><strong>Golfed:</strong></p>
<pre><code>import re,sys;sys.setrecursionlimit(2000);F,L=filter,list
class P:
 N,O,F=0,{},{}
 def __init__(S,c):
  S.B,S.E={&quot;p&quot;:S.P,&quot;i&quot;:S.I,&quot;d&quot;:S.D,&quot;a&quot;:S.L},dict(enumerate(F(None,[i.split('#')[0].rstrip()for i in c.splitlines()])))
  while S.N in S.E:S.X(S.E[S.N])
 def V(S, v, y, z=0):
  if re.match(&quot;[\w_][\d\w_]*&quot;,v):
   if not v in y:
    if z is not None:y[v]=z
    else:return False
   return True
  return False
 def A(S):S.N+=1
 def P(S,v):
  if S.V(v,S.O):print(&quot;{0} = {1}&quot;.format(v, S.O[v]));return True
  return False
 def I(S,v):
  if S.V(v, S.O):S.O[v]+=1;return True
  return False
 def D(S,v):
  if S.V(v,S.O)and S.O[v]&gt;0:S.O[v]-=1;return True
  return False
 def L(S,v):
  e=[]
  if S.V(v,S.F,e):
   for i in range(3):S.A();e.append(S.E[S.N].lstrip())
   return True
  return False
 def C(S,c,v):
  def R(Z,v):
   for i in re.findall(&quot;\s(\d+)&quot;, Z):Z=Z.replace(&quot; %s&quot;%i,&quot; %s&quot;%v[int(i)-1])
   return Z
  Q,m,f=map(lambda l:R(l,v),S.F[c])
  if S.X(Q,False):return S.X(m,False)
  return S.X(f,False)
 def X(S,Z,C=True):
  u=re.match(&quot;\s?([\w_][\d\w_]*)\s?([\w_][\d\w ]*)?&quot;,Z)
  if u:
   c,v=map(lambda i:''if i is None else i,u.groups());v=L(F(None,v.split(' ')))
   if S.V(c,S.F,None):
    T=S.C(c, v)
    if C:S.A()
   elif S.V(c,S.B,None):
    T=S.B[c](*v)
    if C:S.A()
   else:return False
   return T
  return False
</code></pre>
<p><strong>Ungolfed:</strong></p>
<pre><code>import re

class Prindeal:
    iline = 0
    local = {}
    udef = {}
    content  = {}

    def __init__(self, c):
        self.built = {
            &quot;p&quot;: self.print,
            &quot;i&quot;: self.increment,
            &quot;d&quot;: self.decrement,
            &quot;a&quot;: self.alias,
        }
        self.content = dict(enumerate(filter(None, [i.split('#')[0].rstrip()for i in c.splitlines()])))
        while self.iline in self.content:
            self.execute_line(self.content[self.iline])

    def validate_name(self, varname, stack, default=0):
        if re.match(&quot;[\w_][\d\w_]*&quot;, varname):
            if not varname in stack:
                if default is not None:
                    stack[varname] = default
                else:
                    return False
            return True
        return False

    def advance_stack(self):
        self.iline += 1

    def print(self, varname):
        if self.validate_name(varname, self.local):
            print(&quot;{0} = {1}&quot;.format(varname, self.local[varname]))
            return True
        return False

    def increment(self, varname):
        if self.validate_name(varname, self.local):
            self.local[varname] += 1
            return True
        return False

    def decrement(self, varname):
        if self.validate_name(varname, self.local) and self.local[varname] &gt; 0:
            self.local[varname] -= 1
            return True
        return False

    def alias(self, aliasname):
        indexed_lines = []
        if self.validate_name(aliasname, self.udef, indexed_lines):
            for i in range(3):
                self.advance_stack()
                indexed_lines.append(self.content[self.iline].lstrip())
            return True
        return False

    def execute_alias(self, cmd, variables):
        def parse_args(line, variables):
            for i in re.findall(&quot;\s(\d+)&quot;, line):
                line = line.replace(&quot; %s&quot; % i, &quot; %s&quot; % variables[int(i) - 1])
            return line
        init, success, failure = map(lambda l: parse_args(l, variables), self.udef[cmd])
        if self.execute_line(init, False):
            return self.execute_line(success, False)
        return self.execute_line(failure, False)

    def execute_line(self, line, cont=True):
        valid_execution = re.match(&quot;\s?([\w_][\d\w_]*)\s?([\w_][\d\w ]*)?&quot;, line)
        if valid_execution:
            cmd, variables = map(lambda i: '' if i is None else i, valid_execution.groups())
            variables = list(filter(None, variables.split(' ')))
            if self.validate_name(cmd, self.udef, None):
                temp = self.execute_alias(cmd, variables)
                if cont:
                    self.advance_stack()
            elif self.validate_name(cmd, self.built, None):
                temp = self.built[cmd](*variables)
                if cont:
                    self.advance_stack()
            else:
                return False
            return temp
        return False
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code>P(c)
</code></pre>
<p>Where <code>c</code> is the text content.</p>
<p><strong>Examples:</strong></p>
<p><em>Single-line strings are accepted:</em></p>
<ul>
<li><code>P(&quot;p cat&quot;)</code></li>
<li><code>P(&quot;p dog\ni dog\np dog&quot;)</code></li>
</ul>
<p><em>Multi-lined strings are also accepted:</em></p>
<pre><code>P(&quot;&quot;&quot;
p dog
i dog
p dog
&quot;&quot;&quot;)
</code></pre>
<p>Or:</p>
<pre><code>P(&quot;&quot;&quot;p dog
i dog
p dog&quot;&quot;&quot;)
</code></pre>
<p>Etc.</p>
<p><strong>Notes:</strong></p>
<p>This works correctly for all test cases, but reaches the recursion limit on:</p>
<pre><code>pow C A B   #C = A ^ B = 9 ^ 3 = 729
</code></pre>
<p>Hence the <code>sys.setrecursionlimit(2000)</code>.</p>
</div>
<div id="pu12" class="pu"><h1>Python 2, 486 bytes</h1>
<p><strong>This is the reference solution which I golfed more (currently -98 bytes).</strong></p>

<pre class="lang-py prettyprint-override"><code>import sys;sys.setrecursionlimit(2000)
def r(s):
 n=s[0]
 if n in A:f=lambda i:r([s[int(t)]if'0'&lt;t[0]&lt;':'else t for t in A[n][i]]);return f(1+(f(0)or 0))
 k=s[1]
 if'i'&lt;n:print k,'=',V.get(k,0)
 elif'd'&lt;n:V[k]=-~V[k]if k in V else 1
 elif'a'&lt;n:
    if~-(k in V)or V[k]&lt;1:return 1
    V[k]-=1
 else:A[k]=s[2:]
A={};V={};c=filter(bool,([l,l[:l.find('#')]]['#'in l]for l in input().split('\n')))
while c:
 s=c[0].split();c=c[1:]
 if'a'!=s[0]:r(s)
 else:r(['a',s[1]]+map(str.split,c[:3]));c=c[3:]
</code></pre>
<p>Changes (that I recall):</p>
<ul>
<li>automatic boolean-integer conversion (<code>[l,l[:l.find('#')]]['#'in l]</code>).</li>
<li>set or increment in one statement (<code>V[k]=-~V[k]if k in V else 1</code>)</li>
<li>more aliases to longer expressions (<code>k=s[1]</code>)</li>
<li>no counter in the main loop, clearing the input list instead</li>
<li><code>print</code> automatically adding spaces (<code>print k,'=',V.get(k,0)</code>)</li>
<li>checking digits 1-9 (<code>'0'&lt;t[0]&lt;':'</code>)</li>
<li>flipping the return values of <code>r</code> around to save <code>return</code>s</li>
<li>removing repetition of slicing and splitting (<code>map(str.split,c[:3]))</code>)</li>
</ul>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/54530/">54530</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




