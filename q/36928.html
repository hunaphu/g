<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::QNNN</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
  <!-- TXXX -->
<tr d-ix="0"><td>010</td><td>Sidef</td><td>230725T051349Z</td><td><a href="https://codegolf.stackexchange.com/questions/36928/multiply-quaternions/263289#263289">south</a></td></tr>
<tr d-ix="1"><td>002</td><td>Mathematica</td><td>230725T025245Z</td><td><a href="https://codegolf.stackexchange.com/questions/36928/multiply-quaternions/263282#263282">138 Aspe</a></td></tr>
<tr d-ix="2"><td>119</td><td>Go</td><td>230724T133209Z</td><td><a href="https://codegolf.stackexchange.com/questions/36928/multiply-quaternions/263260#263260">bigyihsu</a></td></tr>
<tr d-ix="3"><td>396</td><td>Whispers v2</td><td>181115T214356Z</td><td><a href="https://codegolf.stackexchange.com/questions/36928/multiply-quaternions/176045#176045">caird co</a></td></tr>
<tr d-ix="4"><td>056</td><td>Python</td><td>140830T035453Z</td><td><a href="https://codegolf.stackexchange.com/questions/36928/multiply-quaternions/37078#37078">Keith Ra</a></td></tr>
<tr d-ix="5"><td>083</td><td>Python</td><td>140829T172727Z</td><td><a href="https://codegolf.stackexchange.com/questions/36928/multiply-quaternions/37056#37056">xnor</a></td></tr>
<tr d-ix="6"><td>050</td><td>Mathematica</td><td>140828T212634Z</td><td><a href="https://codegolf.stackexchange.com/questions/36928/multiply-quaternions/37003#37003">freddiek</a></td></tr>
<tr d-ix="7"><td>099</td><td>Lua</td><td>140827T202537Z</td><td><a href="https://codegolf.stackexchange.com/questions/36928/multiply-quaternions/36936#36936">AndoDaan</a></td></tr>
<tr d-ix="8"><td>039</td><td>CJam</td><td>140827T203316Z</td><td><a href="https://codegolf.stackexchange.com/questions/36928/multiply-quaternions/36938#36938">Dennis</a></td></tr>
<tr d-ix="9"><td>069</td><td>Python</td><td>140827T194042Z</td><td><a href="https://codegolf.stackexchange.com/questions/36928/multiply-quaternions/36932#36932">Falko</a></td></tr>
<tr d-ix="10"><td>086</td><td>JavaScript ES6</td><td>140827T195851Z</td><td><a href="https://codegolf.stackexchange.com/questions/36928/multiply-quaternions/36935#36935">William </a></td></tr>
<tr d-ix="11"><td>085</td><td>Haskell</td><td>140827T194519Z</td><td><a href="https://codegolf.stackexchange.com/questions/36928/multiply-quaternions/36934#36934">ThreeFx</a></td></tr>
<tr d-ix="12"><td>094</td><td>Python</td><td>140827T193209Z</td><td><a href="https://codegolf.stackexchange.com/questions/36928/multiply-quaternions/36931#36931">Florian </a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/trizen/sidef" rel="nofollow noreferrer">Sidef</a>, 10 bytes</h1>
<pre><code>{|a,b|a*b}
</code></pre>
<p>Sidef has a built-in Quaternion type, as does <a href="https://github.com/odin-lang/Odin/blob/5ac7fe453f5fbf0995c24f0c1c12ed439ae3aee9/examples/demo/demo.odin#L1483" rel="nofollow noreferrer">Odin</a>. Neither language versions used by TIO support this, however.</p>
<pre><code>var f = {|a,b|a*b}
say f(Quaternion(12, 54, -2, 23), Quaternion(1, 4, 6, -2))
#=&gt; Quaternion(-146, -32, 270, 331)

say f(Quaternion(1, 4, 6, -2), Quaternion(12, 54, -2, 23))
#=&gt; Quaternion(-146, 236, -130, -333)

say f(Quaternion(3.5, 4.6, -0.24, 0), Quaternion(2.1, -3, -4.3, -12))
#=&gt; Quaternion(10059/500, 51/25, 19823/500, -125/2)
</code></pre>
</div>
<div id="pu1" class="pu"><h1>Mathematica, 2 bytes</h1>
<pre><code>**
</code></pre>
<p>Definitely Mathematica has <code>NonCommutativeMultiply</code> for quaternions.</p>
<p>Reference: <a href="https://reference.wolfram.com/legacy/language/v13/Quaternions/tutorial/Quaternions.html" rel="nofollow noreferrer">Official Documentation</a></p>
<pre><code>Needs[&quot;Quaternions`&quot;];

q1 = Quaternion[12, 54, -2, 23];
q2 = Quaternion[1, 4, 6, -2];
q3 = Quaternion[3.5, 4.6, -0.24, 0];
q4 = Quaternion[2.1, -3, -4.3, -12];

q1 ** q2
q2 ** q1
q3 ** q4
</code></pre>
<pre><code>Quaternion[-146, -32, 270, 331]
Quaternion[-146, 236, -130, -333]
Quaternion[20.118, 2.04, 39.646, -62.5]
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://go.dev" rel="nofollow noreferrer">Go</a>, 119 bytes</h1>
<pre class="lang-go prettyprint-override"><code>type F=float64
func f(a,b,c,d,e,f,g,h F)[]F{return[]F{a*e-b*f-c*g-d*h,a*f+b*e+c*h-d*g,a*g-b*h+c*e+d*f,a*h+b*g-c*f+d*e}}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=XVHBbtswDEWv-grCwADboQRLcrxuQHbMeb0VSH1QHEk22jiBo7QYDH_JLsGAfsW-ZP2aUqkPxQ5P5OMjRUr8_ccfLn-Ppnk03sLedD3r9sfDEETi9iFh7PUcHL_99xJ-HS2sV-7pYEJVMnfuG3CpwS02uEOLDj22sM429XocbDgPffRMbvk2d7zJPd_lLZrcLba5XTR5S9wT96S3xO1ilzviLeme8h1xO00f7d9u7q8N43xpBiNjXX-C7yvY1HcjG6XCZYlcodIoscSK_AkpPvv4KSHGtVhiKUgphCqxQCUkco28FHTIWDoxM99_CkPX-zHZcFlWwLUC9bUArWWd4BxUmgSpC1K1voZVIaS8BSWKEvQ3UcXKSollnUyMucMABrt4_WB6-vX4lpH9pD7BpcmX54ceVj8g2jTaU_bQJ9ihSztBdWJLaAg7giU4gie0GZrTxtQZTU9trgu7A5r_3AQY_9_UvMj5gy-XD_sO" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>The very straightforward solution</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/cairdcoinheringaahing/Whispers" rel="nofollow noreferrer">Whispers v2</a>, 396 bytes</h1>

<pre><code>&gt; 1
&gt; 2
&gt; 0
&gt; 4
&gt; Input
&gt; Input
&gt;&gt; 6ᶠ2
&gt;&gt; 6ᵗ2
&gt;&gt; 7ⁿ3
&gt;&gt; 7ⁿ1
&gt;&gt; 10‖9
&gt;&gt; 8ⁿ3
&gt;&gt; 8ⁿ1
&gt;&gt; 13‖12
&gt;&gt; 7‖8
&gt;&gt; 11‖14
&gt;&gt; 8‖7
&gt;&gt; 14‖11
&gt;&gt; 15‖16
&gt;&gt; 19‖17
&gt;&gt; 20‖18
&gt;&gt; 4⋅5
&gt;&gt; L⋅R
&gt;&gt; Each 23 22 21
&gt; [1,-1,-1,-1,1,1,1,-1,1,-1,1,1,1,1,-1,1]
&gt;&gt; Each 23 24 25
&gt;&gt; 26ᶠ4
&gt;&gt; 26ᵗ4
&gt;&gt; 28ᶠ4
&gt; 8
&gt;&gt; 26ᵗ30
&gt;&gt; 31ᶠ4
&gt;&gt; 31ᵗ4
&gt;&gt; ∑27
&gt;&gt; ∑29
&gt;&gt; ∑32
&gt;&gt; ∑33
&gt;&gt; Output 34 35 36 37
</code></pre>

<p><a href="https://tio.run/##jZCxTsQwDIb3PoUfoI1iO03bpRsDEhISa9UBIaRjQSfuTqxlQEJiYumtvMSx8iz0RYqdNq2ABTVOPjv/7yZ53NzttrcPOxrHGjCpgSSshJM4v98e9utag//6eKcJTscAxfD0yRFQAe3Q9ZVSGffKZY9lD2dj15ehhlpzk67ri1BzWpssuaIPWCkGAelPMPjd8PqcK1wIXCmcXd9sgBiIgPRKDaZZHNOXLdOatz@sDig0Jb2ym@l0nKicalAudbaKjFEsNIuHlzcqIlQzMEUI73N52MsDAzvgHNgDF@PYsMlTcMankFlDLgXbJg0ZlJwlnNEZqR0bpBRyEWSyEotKNJKqk9okkwfI0GnGKihsCsxy3V@6P21WI7FqkK32YFbrf08XupA1iKX0MVaUXBkfjuPJ5O03" rel="nofollow noreferrer" title="Whispers v2 – Try It Online">Try it online!</a></p>

<p>Takes input in the form</p>

<pre><code>[a, b, c, d]
[e, f, g, h]
</code></pre>

<p>and outputs as</p>

<pre><code>w
x
y
z
</code></pre>

<p>to represent <span class="math-container">\$q = w + xi + yj + zk\$</span></p>

<p>The structure tree of this answer is:</p>

<p><a href="https://i.stack.imgur.com/sW2BG.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/sW2BG.png" alt="tree"></a></p>

<p>A good chunk of this answer comes from two main faults in Whispers:</p>

<ul>
<li>No function to reverse an array</li>
<li>The usage of sets in the computation of the Cartesian product</li>
</ul>

<p>Therefore, we can split the code into 3 sections.</p>

<h2>How it works</h2>

<p>We'll use the following definitions for clarity and conciseness:</p>

<p><span class="math-container">$$q = a + bi + cj + dk$$</span>
<span class="math-container">$$p = e + fi + gj + hk$$</span>
<span class="math-container">$$r = w + xi + yj + zk, \: (q \cdot p = r)$$</span>
<span class="math-container">$$A = [a, b, c, d]$$</span>
<span class="math-container">$$B = [e, f, g, h]$$</span>
<span class="math-container">$$C = [w, x, y, z]$$</span></p>

<h3>Section 1: Permuting <span class="math-container">\$A\$</span> and <span class="math-container">\$B\$</span></h3>

<p>The first section is by far the longest, stretching from line <strong>1</strong> to line <strong>22</strong>:</p>

<pre><code>&gt; 1
&gt; 2
&gt; 0
&gt; 4
&gt; Input
&gt; Input
&gt;&gt; 6ᶠ2
&gt;&gt; 6ᵗ2
&gt;&gt; 7ⁿ3
&gt;&gt; 7ⁿ1
&gt;&gt; 10‖9
&gt;&gt; 8ⁿ3
&gt;&gt; 8ⁿ1
&gt;&gt; 13‖12
&gt;&gt; 7‖8
&gt;&gt; 11‖14
&gt;&gt; 8‖7
&gt;&gt; 14‖11
&gt;&gt; 15‖16
&gt;&gt; 19‖17
&gt;&gt; 20‖18
&gt;&gt; 4⋅5
</code></pre>

<p>The main purpose of this section is to permute <span class="math-container">\$B\$</span> so that simple element-wise multiplication between <span class="math-container">\$A\$</span> and <span class="math-container">\$B\$</span> is possible. There are four different arrangements of <span class="math-container">\$B\$</span> to multiply the elements of <span class="math-container">\$A\$</span> with:</p>

<p><span class="math-container">$$B_1 = [e, f, g, h]$$</span>
<span class="math-container">$$B_2 = [f, e, h, g]$$</span>
<span class="math-container">$$B_3 = [g, h, e, f]$$</span>
<span class="math-container">$$B_4 = [h, g, f, e]$$</span></p>

<p>The second input, <span class="math-container">\$B\$</span>, is stored on line <strong>6</strong>. We then split <span class="math-container">\$B\$</span> down the middle, as each possible arrangement of <span class="math-container">\$B\$</span> is grouped in pairs. In order to reverse these pairs (to get the correct orders in <span class="math-container">\$B_2\$</span> and <span class="math-container">\$B_4\$</span>), we take the first and last element, then concatenate them in reverse order:</p>

<pre><code>&gt;&gt; 7ⁿ3
&gt;&gt; 7ⁿ1
&gt;&gt; 10‖9
</code></pre>

<p>(forming <span class="math-container">\$[f, e]\$</span>) and</p>

<pre><code>&gt;&gt; 8ⁿ3
&gt;&gt; 8ⁿ1
&gt;&gt; 13‖12
</code></pre>

<p>(forming <span class="math-container">\$[h, g]\$</span>). We now have all the halves needed to form the arrangements, so we concatenate them together to form <span class="math-container">\$B_1, B_2, B_3\$</span> and <span class="math-container">\$B_4\$</span>. Finally, we concatenate these four arrangements together to form <span class="math-container">\$B_T\$</span>. We then quickly make <span class="math-container">\$A_T\$</span>, defined as <span class="math-container">\$A\$</span> repeated <span class="math-container">\$4\$</span> times:</p>

<p><span class="math-container">$$A_T = [a, b, c, d, a, b, c, d, a, b, c, d, a, b, c, d]$$</span>
<span class="math-container">$$B_T = [e, f, g, h, f, e, h, g, g, h, e, f, h, g, f, e]$$</span></p>

<p>When each element of <span class="math-container">\$B_T\$</span> is multiplied by the corresponding element in <span class="math-container">\$A_T\$</span>, we get the (signless) values in <span class="math-container">\$q \cdot p\$</span></p>

<h2>Section 2: Signs and products</h2>

<p>As said in Section 1, the values in <span class="math-container">\$A_T\$</span> and <span class="math-container">\$B_T\$</span> correspond to the signless (i.e. positive) values of each of the coefficients in <span class="math-container">\$q \cdot p\$</span>. No obvious pattern is found in the signs that would be shorter than simply hardcoding the array, so we hardcode the array:</p>

<pre><code>&gt; [1,-1,-1,-1,1,1,1,-1,1,-1,1,1,1,1,-1,1]
</code></pre>

<p>We'll call this array <span class="math-container">\$S\$</span> (signs). Next, we zip together each element in <span class="math-container">\$A_T, B_T\$</span> and <span class="math-container">\$S\$</span> and take the product of each sub-array e.g. <span class="math-container">\$[[a, e, 1], [b, f, -1], \dots, [e, f, -1], [d, e, 1]] \to D = [ae, -bf, \dots, -ef, de]\$</span>.</p>

<h2>Section 3: Partitions and final sums.</h2>

<p>Once we have the array of coefficients of <span class="math-container">\$q \cdot p\$</span>, with signs, we need to split it into 4 parts (i.e. the four factorised coefficients of <span class="math-container">\$q \cdot p\$</span>), and then take the sums. This leads us to the only golfing opportunity found: moving the</p>

<pre><code>&gt; 4
</code></pre>

<p>to line <strong>4</strong> rather than <strong>26</strong>, as it is used 6 times, each time saving a byte by moving it. Unfortunately, this costs a byte changing the <strong>9</strong> to a <strong>10</strong>, so only <span class="math-container">\$5\$</span> bytes are saved. The next section takes slices of size <span class="math-container">\$4\$</span> from the front of <span class="math-container">\$D\$</span>, saving each slice to the corresponding row and passing on the shortened list of <span class="math-container">\$D\$</span>. Once 4 slices are taken, we the take the sum of each, before outputting them all.</p>
</div>
<div id="pu4" class="pu"><h2>Python, <strike>58</strike> 56 chars</h2>

<pre><code>m=lambda x,y,z,w:(x*z-y*(2*w.real-w),x*w+y*(2*z.real-z))
</code></pre>

<p>I take <em>very</em> liberal use of the input/output format wiggle room.  The inputs are 4 complex numbers, encoded thusly:</p>

<pre><code>x = a+b*i
y = c+d*i
z = e+f*i
w = g+h*i
</code></pre>

<p>It outputs a pair of complex numbers in a similar format, the first of the pair encodes the real and <code>i</code> part, the second encodes the <code>j</code> and <code>k</code> parts.</p>

<p>To see this works, note that the first quaternion is <code>x+y*j</code> and the second is <code>z+w*j</code>.  Just evaluate <code>(x+y*j)*(z+w*j)</code> and realize that <code>j*t</code> = <code>conj(t)*j</code> for any imaginary number <code>t</code>.</p>
</div>
<div id="pu5" class="pu"><h2>Python (83)</h2>

<pre class="lang-python prettyprint-override"><code>r=lambda A,B,R=range(4):[sum(A[m]*B[m^p]*(-1)**(14672&gt;&gt;p+4*m)for m in R)for p in R]
</code></pre>

<p>Takes two lists <code>A,B</code> in <code>[1,i,j,k]</code> order and returns a result in the same format.</p>

<p>The key idea is that with <code>[1,i,j,k]</code> corresponding to indices <code>[0,1,2,3]</code>, you get the product's index (up to sign) by XOR'ing the indices. So, the terms that get placed in index <code>p</code> are those who indices XOR to <code>p</code>, and are thus the products <code>A[m]*B[m^p]</code>. </p>

<p>It only remains to make the signs work out. The shortest way I found was to simply code them into a magic string. The 16 possibilities for <code>(m,p)</code> are turned into numbers <code>0</code> to <code>15</code> as <code>p+4*m</code>. The number <code>14672</code> in binary has <code>1</code>'s at the places where <code>-1</code> signs are needed. By shifting it the appropriate number of places , a <code>1</code> or <code>0</code> winds up at the last digit, making the number odd or even, and so <code>(-1)**</code> is either <code>1</code> or <code>-1</code> as needed.</p>
</div>
<div id="pu6" class="pu"><h2>Mathematica <s>83</s> 50</h2>

<p>Probably can be golfed more..</p>

<pre><code>p = Permutations;
f = #1.(Join[{{1, 1, 1, 1}}, p[{-1, 1, -1, 1}][[1 ;; 3]]] p[#2][[{1, 8, 17, 24}]]) &amp;
</code></pre>

<p>Spaces and newlines not counted &amp; not needed.</p>

<p>Usage:</p>

<pre><code>f[{a,b,c,d},{e,f,g,h}]        (* =&gt; {x,w,y,z}   *)
</code></pre>

<p><br>
<strong>EDIT</strong>
How this works.</p>

<p>The Mathematica function <code>Permutations</code> makes all possible permutations of <code>#2</code> (the second argument). There are 24 permutations, but we only need <code>{e,f,g,h}</code>, <code>{f,e,h,g}</code>, <code>{g,h,e,f}</code>, and <code>{h,g,f,e}</code>. These are the first, 8th, 17th and 24th permutations. So the code</p>

<pre><code>p[#2][[{1,8,17,24}]]
</code></pre>

<p>exactly selects these from the permutations of the second argument and returns them as a matrix. But then they don't have the correct sign yet. The code <code>p[{-1,1,-1,1}][[1;;3]]</code> returns a 3x4 matrix with the correct sign. We prepend it with <code>{1,1,1,1}</code> by using <code>Join</code>, and making a normal multiplication (<code>Times</code>, or as is the case here by just writing them after each other) between two matrices makes an element-by-element multiplication in Mathematica.</p>

<p>So finally, the result of</p>

<pre><code>(Join[{{1, 1, 1, 1}}, p[{-1, 1, -1, 1}][[1 ;; 3]]] p[#2][[{1, 8, 17, 24}]])
</code></pre>

<p>is the matrix</p>

<pre><code> e  f  g  h
-f  e -h  g
-g  h  e -f
-h -g  f  e
</code></pre>

<p>Making a matrix multiplication between <code>{a,b,c,d}</code> (the first argument <code>#1</code>) and the former matrix gives the desired result.</p>

<p><br><br>
<strong>EDIT 2</strong> Shorter code</p>

<p>Inspired by the Python code of Falko, I split up the quaternion in a scalar and a vector part, and use Mathematica's built in command <code>Cross</code> to calculate the cross product of the vector parts:</p>

<pre><code>f[a_, A_, b_, B_] := Join[{a*b - A.B}, a*B + b*A + Cross[A, B]]
</code></pre>

<p>Usage:</p>

<pre><code>f[a,{b,c,d},e,{f,g,h}]        (* =&gt; {x,w,y,z}   *)
</code></pre>
</div>
<div id="pu7" class="pu"><h1>Lua - 99</h1>
<p>Might as well.</p>
<pre><code>_,a,b,c,d,e,f,g,h=unpack(arg)print(a*e-b*f-c*g-d*h,a*f+b*e+c*h-d*g,a*g-b*h+c*e+d*f,a*h+b*g-c*f+d*e)
</code></pre>
<p>Lua's &quot;unpack()&quot; frees the elements of a table. So the table 'arg' is where all the command line input is stored (including <code>arg[0]</code> which is the program's file name, it gets discarded).</p>
</div>
<div id="pu8" class="pu"><h1>CJam, <s>49</s> <s>45</s> 39 bytes</h1>

<pre><code>"cM-^\M-^G-^^KM-zP"256bGbq~m*f{=:*}4/{:-W*}/W*]`
</code></pre>

<p>The above uses caret and M notation, since the code contains unprintable characters.</p>

<p>At the cost of two additional bytes, those characters can be avoided:</p>

<pre><code>6Z9C8 7YDXE4BFA5U]q~m*f{=:*}4/{:-W*}/W*]`
</code></pre>

<p>You can try this version online: <a href="http://cjam.aditsu.net/" rel="nofollow">CJam interpreter</a></p>

<h3>Test cases</h3>

<p>To calculate <code>(a + bi + cj + dk) * (e + fi + gj + hk)</code>, use the following input:</p>

<pre><code>[ d c b a ] [ h g f e ]
</code></pre>

<p>The output will be</p>

<pre><code>[ z y x w ]
</code></pre>

<p>which corresponds to the quaternion <code>w + xi + yj + zk</code>.</p>

<pre><code>$ base64 -d &gt; product.cjam &lt;&lt;&lt; ImOchy0eS/pQIjI1NmJHYnF+bSpmez06Kn00L3s6LVcqfS9XKl1g
$ wc -c product.cjam
39 product.cjam
$ LANG=en_US cjam product.cjam &lt;&lt;&lt; "[23 -2 54 12] [-2 6 4 1]"; echo
[331 270 -32 -146]
$ LANG=en_US cjam product.cjam &lt;&lt;&lt; "[-2 6 4 1] [23 -2 54 12]"; echo
[-333 -130 236 -146]
$ LANG=en_US cjam product.cjam &lt;&lt;&lt; "[0 -0.24 4.6 3.5] [-12 -4.3 -3 2.1]"; echo
[-62.5 39.646 2.04 20.118]
</code></pre>

<h3>How it works</h3>

<pre><code>6Z9C8 7YDXE4BFA5U]  " Push the array [ 6 3 9 12 8 7 2 13 1 14 4 11 15 10 5 0].         ";
q~                  " Read from STDIN and interpret the input.                         ";
m*                  " Compute the cartesian product of the input arrays.               ";
f                   " Execute the following for each element of the first array:       ";
{                   " Push the cartesian product (implicit).                           ";
    =               " Retrieve the corresponding pair of coefficients.                 ";
    :*              " Calculate their product.                                         ";
}                   "                                                                  ";
4/                  " Split into chunks of 4 elements.                                 ";
{:-W*}/             " For each, subtract the first element from the sum of the others. ";
W*                  " Multiply the last integers (coefficient of 1) by -1.             ";
]`                  " Collect the results into an array and stringify it.              ";
</code></pre>
</div>
<div id="pu9" class="pu"><h1>Python - <s>90 75 72</s> 69</h1>

<p><strong>Pure Python, no libraries - 90:</strong></p>

<pre><code>m=lambda a,b,c,d,e,f,g,h:[a*e-b*f-c*g-d*h,a*f+b*e+c*h-d*g,a*g-b*h+c*e+d*f,a*h+b*g-c*f+d*e]
</code></pre>

<p>It's probably pretty hard to shorten this "default" solution in Python. But I'm very curious as to what other might come up with. :)</p>

<hr>

<p><strong>Using NumPy - <s>75 72</s> 69:</strong></p>

<p>Well, since the input and output are rather flexible, we can use some NumPy functions and exploit the <a href="http://en.wikipedia.org/wiki/Quaternion#Scalar_and_vector_parts" rel="nofollow">scalar-vector representation</a>:</p>

<pre><code>import numpy
m=lambda s,p,t,q:[s*t-sum(p*q),s*q+t*p+numpy.cross(p,q)]
</code></pre>

<p>Input arguments <code>s</code> and <code>t</code> are the scalar parts of the two quaternions (the real parts) and <code>p</code> and <code>q</code> are the corresponding vector parts (the imaginary units). Output is a list containing scalar part and vector part of the resulting quaternion, the latter being represented as NumPy array.</p>

<p><strong>Simple test script:</strong></p>

<pre><code>for i in range(5):
    a,b,c,d,e,f,g,h=np.random.randn(8)
    s,p,t,q=a, np.array([b, c, d]), e, np.array([f, g, h])
    print mult(a, b, c, d, e, f, g, h), "\n", m(s,p,t,q)
</code></pre>

<p>(<code>mult(...)</code> being the OP's reference implementation.)</p>

<p>Output:</p>

<pre><code>[1.1564241702553644, 0.51859264077125156, 2.5839001110572792, 1.2010364098925583] 
[1.1564241702553644, array([ 0.51859264,  2.58390011,  1.20103641])]
[-1.8892934508324888, 1.5690229769129256, 3.5520713781125863, 1.455726589916204] 
[-1.889293450832489, array([ 1.56902298,  3.55207138,  1.45572659])]
[-0.72875976923685226, -0.69631848934167684, 0.77897519489219036, 1.4024428845608419] 
[-0.72875976923685226, array([-0.69631849,  0.77897519,  1.40244288])]
[-0.83690812141836401, -6.5476014589535243, 0.29693969165495304, 1.7810682337361325] 
[-0.8369081214183639, array([-6.54760146,  0.29693969,  1.78106823])]
[-1.1284033842268242, 1.4038096725834259, -0.12599103441714574, -0.5233468317643214] 
[-1.1284033842268244, array([ 1.40380967, -0.12599103, -0.52334683])]
</code></pre>
</div>
<div id="pu10" class="pu"><h2>JavaScript ES6 - 86</h2>

<pre class="lang-javascript prettyprint-override"><code>f=(a,b,c,d,e,f,g,h)=&gt;[a*e-b*f-c*g-d*h,a*f+b*e+c*h-d*g,a*g-b*h+c*e+d*f,a*h+b*g-c*f+d*e]
</code></pre>
</div>
<div id="pu11" class="pu"><h1>Haskell, 85</h1>
<pre><code>m a b c d e f g h=[a*e-b*f-c*g-d*h,a*f+b*e+c*h-d*g,a*g-b*h+c*e+d*f,a*h+b*g-c*f+d*e]
</code></pre>
<p>Porting it to Haskell saves us a few chars ;)</p>
</div>
<div id="pu12" class="pu"><h2>Python, 94</h2>
<p>The most straightforward way isn't too long.</p>
<pre><code>def m(a,b,c,d,e,f,g,h):return[a*e-b*f-c*g-d*h,a*f+b*e+c*h-d*g,a*g-b*h+c*e+d*f,a*h+b*g-c*f+d*e]
</code></pre>
</div>
<!-- TYYY -->

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/QNNN/">QNNN</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




