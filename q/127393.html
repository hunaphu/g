<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::127393</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>063</td><td>R</td><td>251013T094626Z</td><td><a href="https://codegolf.stackexchange.com/questions/127393/the-sequence-is-too-meta/284098#284098">Glory2Uk</a></td></tr>
<tr d-ix="1"><td>016</td><td>Husk</td><td>210317T061025Z</td><td><a href="https://codegolf.stackexchange.com/questions/127393/the-sequence-is-too-meta/220810#220810">Leo</a></td></tr>
<tr d-ix="2"><td>023</td><td>Stax</td><td>210317T091715Z</td><td><a href="https://codegolf.stackexchange.com/questions/127393/the-sequence-is-too-meta/220813#220813">Razetime</a></td></tr>
<tr d-ix="3"><td>087</td><td>JavaScript ES6</td><td>170620T101845Z</td><td><a href="https://codegolf.stackexchange.com/questions/127393/the-sequence-is-too-meta/127427#127427">Arnauld</a></td></tr>
<tr d-ix="4"><td>104</td><td>C gcc</td><td>210317T081552Z</td><td><a href="https://codegolf.stackexchange.com/questions/127393/the-sequence-is-too-meta/220812#220812">l4m2</a></td></tr>
<tr d-ix="5"><td>067</td><td>Haskell</td><td>170620T230804Z</td><td><a href="https://codegolf.stackexchange.com/questions/127393/the-sequence-is-too-meta/127604#127604">xnor</a></td></tr>
<tr d-ix="6"><td>029</td><td>Pyth</td><td>170620T204449Z</td><td><a href="https://codegolf.stackexchange.com/questions/127393/the-sequence-is-too-meta/127586#127586">Anders K</a></td></tr>
<tr d-ix="7"><td>067</td><td>Haskell</td><td>170620T114140Z</td><td><a href="https://codegolf.stackexchange.com/questions/127393/the-sequence-is-too-meta/127458#127458">Anders K</a></td></tr>
<tr d-ix="8"><td>124</td><td>Java 8</td><td>170620T182109Z</td><td><a href="https://codegolf.stackexchange.com/questions/127393/the-sequence-is-too-meta/127553#127553">Xanderha</a></td></tr>
<tr d-ix="9"><td>123</td><td>C</td><td>170620T083123Z</td><td><a href="https://codegolf.stackexchange.com/questions/127393/the-sequence-is-too-meta/127407#127407">Doorknob</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.r-project.org" rel="nofollow noreferrer">R</a>, 63 bytes</h1>
<pre class="lang-r prettyprint-override"><code>`&gt;`=\(a=1,b)`if`(u&lt;-b-1,`if`(u%%(r=1&gt;a),a+1&gt;u-u%/%r,2+u%/%r),2)
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m72waMGCpaUlaboWN-0T7BJsYzQSbQ11kjQTMtMSNEptdJN0DXUgbFVVjSJbQ7tETZ1EbUO7Ut1SVX3VIh0jbTCtqWOkCTFma25iQUFOpUaMRpamoV2WjqGVoYEBVA5mFQA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>I have followed the published recursive solution, explained in <a href="https://codegolf.stackexchange.com/a/127586/101276">this post</a> of Anders Kaseorg.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/barbuz/Husk" rel="nofollow noreferrer">Husk</a>, <s>20</s> 16 bytes</h1>
<pre><code>!ƒψΣz`:tNΘC←←¹²t
</code></pre>
<p><a href="https://tio.run/##yygtzv6vkPuoqdHvv@KxSec7zi2uSrAq8Ts3w/lR2wQgOrTz0KaS//8B" rel="nofollow noreferrer" title="Husk – Try It Online">Try it online!</a></p>
<p>A golfed port of the mind-bending <a href="https://codegolf.stackexchange.com/a/127458/62393">Haskell answer by Anders Kaseorg</a></p>
<h3>Explanation</h3>
<p>This answer builds this meta list with a self-referential process.</p>
<p>Let's get a few things out of the way before we can look at how the list is actually built: <code>!</code> simply takes an item from the list, since the challenge asks to return the element at a given list. <code>ƒ</code> is the fixpoint operator, it takes a function and applies the function to itself ad infinity, i.e. <code>ƒg</code> = <code>g(g(g(g(g(g(...</code>; this is what allows us to define the list in terms of the list itself. <code>ψ</code> is a way to write a recursive function in Husk: the following commands define a function of one argument where <code>⁰</code> (or <code>¹</code>) marks the argument, and <code>²</code> marks the function itself.</p>
<p>The inner code (with implicit parameters made explicit) is this:</p>
<pre><code>Σz`:tNΘC←←⁰²t⁰    Takes an infinite list as input, returns an infinite list
           ²      Apply the function recursively
            t⁰      to the tail of the list
         ←⁰       then take the head of the input list
        ←          -1
       C          and cut the resulting list in groups of that length
      Θ           Prepend an empty group
 z           For each group
  `:          append
    tN        a natural number (starting from 2)
Σ            Then concatenate all groups together
</code></pre>
<p>What this function does is taking the current <code>a(n)</code> and the list of values that are marked as blanks in step <code>n</code>, and add <code>2,3,4,5...</code> at the right locations between those &quot;blanks&quot;.</p>
<p>It would be shorter (and more natural) to prepend a number to each group (each value 2,3,4... goes at the <em>beginning</em> of the group of a(n) blanks, after all), but to do that we wouldn't be able to generate the first element of the list until we generate the first group of blanks, and since this definition is self-referential we couldn't generate the first element of the first group of blanks until we generate the first group of blanks after that, and so on forever. By adding an empty group at the beginning and putting values at the end of groups instead, we can generate the initial <code>2</code> without having to look at the rest of the list, and this is enough to kickstart the whole process that will generate the infinite list recursively.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/tomtheisen/stax" rel="nofollow noreferrer">Stax</a>, 23 <a href="https://github.com/tomtheisen/stax/blob/master/docs/packed.md#packed-stax" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>ü→è«wε⌠╒└I◄►¼═Öà=╬à╞⌐-Ω
</code></pre>
<p><a href="https://staxlang.xyz/#p=811a8aae77eef4d5c0491110accd99853dce85c6a92dea&amp;i=1%0A2%0A3%0A4%0A5%0A6%0A7%0A8%0A9%0A10%0A11%0A12%0A13%0A14%0A15%0A16%0A17%0A18%0A19%0A20%0A21%0A22%0A23%0A24%0A&amp;m=2" rel="nofollow noreferrer">Run and debug it</a></p>
<p>A direct implementation of the procedure.</p>
<p>Uses zeroes as placeholders till the array is fully filed, and take the last element.</p>
<h2>Explanation</h2>
<pre><code>z({c:0ni@i1&gt;s2?::{i^^&amp;F}x*H Input: x
z                           empty list
 (                          pad with x zeroes (call this S)
  {                    }x*  perform the following x times:
   c:0                      get the falsy indices
         i1&gt;  ?             if iteration index &gt;1 :
      ni@                   get nth element of S
            2               else push 2
               ::           get every nth element of the falsy indices
                 {    F     for each index:
                  i^^&amp;      replace with iteration index + 2
</code></pre>
</div>
<div id="pu3" class="pu"><h1>JavaScript (ES6), <s> 98 93 91</s> 87 bytes</h1>
<p><em>Saved 4 bytes thanks to @l4m2</em></p>
<p>A recursive function that stops as soon as the result is available.</p>
<pre class="lang-js prettyprint-override"><code>f=(n,p,a=[])=&gt;a[n-1]++||f(n,-~p,[...a].map(c=&gt;c?c:i?i++%(a[p]||2)?c:++v:(i=1,v=2),i=0))
</code></pre>
<p><a href="https://tio.run/##FY1BDoMgFET3nuJvGiEfiZp0o/16EMKCUG1oWiDauCnt1Sndzby8ydzNYXa7ufhqfLguOa/EvIjCkNKcJqN802nElNaCm28USkpptHyayCxNdraDmx3iiRkVdUo9LwTxGJijThzUc@Go5TyvYWMeCLoRPFwIzm0JiBzeFYANfg@PRT7CjdVG1YBFQqh1GfxLOed8rD75Bw" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
</div>
<div id="pu4" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C (gcc)</a>, 104 bytes</h1>

<pre class="lang-c prettyprint-override"><code>j;k;f(n){int*p=calloc(n,4)-4,i=1,y;for(;j=k=p[n],!j;++i)for(y=p[i]?:2;j++&lt;n;)p[j]||k++%y||(p[j]=k/y+2);}
</code></pre>
<p><a href="https://tio.run/##RYxBDoIwEEX3nmIkIenYEgFZOTQeBFmQGkxbLIS4IcDZa8vG2fzMe/lfZW@lvDdkqWcOV@2@l0mqbhhGxZyoMKuEloVYqB9nRkZaOTWuFWdDnGuMcAlEt497SYbz2hFOjWm3zXKeLtvG4iftdeEl0u7DPnw67RjCeoJwYQFYpBokFBSihlueE8R5mOagepakL5EI6JlGpKP2F093mNCJbvc/" rel="nofollow noreferrer" title="C (gcc) – Try It Online">Try it online!</a></p>
<p>Trying to golf <a href="https://codegolf.stackexchange.com/a/127407/">the last C solution</a> but it's just too hard to understand</p>
<pre class="lang-c prettyprint-override"><code>f(n){
    int*p=calloc(n,4)-4,i=0,j,k,y;         // p as Array[1..n]
    for(;j=k=p[n],!j;++i)                  // Once p[n] is filled we're over
                                           // and that's what we want
                                           // Otherwise j and k are inited to 0
        for(;j++&lt;n;) p[j]||                // For zeros
            k++%(y=p[i]?:2)||(p[j]=k/y+2); // On correct time fill them
}
</code></pre>
</div>
<div id="pu5" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, 67 bytes</h1>



<pre class="lang-hs prettyprint-override"><code>0%j=2
i%j|d&lt;-div i$f j=last$d+2:[(i-d-1)%(j+1)|d*f j&lt;i]
f=(%1).pred
</code></pre>

<p><a href="https://tio.run/##NVHLboMwELzzFT4ECZqH2LW9QBW@o4coByRIY0oiBLSHqv9Od1z1gD14d@dh39vlox/HbSvSoeEkpMNPdz524cuE3c0Mzdgu667b8@slC8fuSHmaDXvKf7oXrZ7DNbk1WUr5aZr7bpv75XNcF9OYRzuZm7nQ6XRN1nZ@71c9vPCBD1Y/p6vXXRSVulf6V@sZFXpEBMRaIPSS0zJ57STRJiqBKrRSrWUuMMAEPsYYR2oXh6HBAgoulZkjEdcKbQE6CynLILVWBW2kth5QwG9LNFRQsbX6cAWkHAEyBF2M46DqkMEJtF0JWMGAQy5fwIYnuPYMMz6G9Q6ePMJ5gTFfIo2v4M/XwFLApajoQRheJV6OODgWH7HAuOAiJbqXGunL4pokjzY89eanOTxXszPts9P1O0xvYb1nTZOb/yf7e6TtFw" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>

<p>A recursive arithmetical solution that turned out basically the same method as <a href="https://codegolf.stackexchange.com/a/127586/20260">Anders Kaseorg's Pyth answer</a>.</p>

<p>This code is covered in warts -- ugly parts that look like they could be golfed away, but I didn't see how. </p>

<p>The function <code>i%j</code> really wants to use a guard to check whether <code>mod i(f j)&gt;0</code> and evaluate one of corresponding two expression. But, both expressions use <code>div i(f j)</code>. Binding that in a guard won't make it apply to both sides. As far as I know, a guard can't be made to "distribute" over other guards. <code>let</code> and <code>where</code> are too long. So, the code uses <code>last</code> to pick one of two expressions while the guard binds the variable. Ugh.</p>

<p>Ideally we'd use <code>divMod</code> because both the <code>div</code> and <code>mod</code> are used, but <code>(d,m)&lt;-divMod ...</code> is a long expression. We instead hackily check of the mod is nonzero by seeing if the <code>div</code> value times the divisor falls short of the original value.</p>

<p>The <code>0%j=2</code> case would not be needed if Haskell short-circuited <code>div 0</code>, which it doesn't. The <code>.pred</code> converts the 1-indexed input to zero-indexed, or else there would be <code>-1</code> corrections everywhere.</p>
</div>
<div id="pu6" class="pu"><h1>Pyth, 29 bytes</h1>

<pre><code>M?tH?eJ.DtHg1GghG-tHhJ+2hJ2g1
</code></pre>

<p><a href="https://pyth.herokuapp.com/?code=M%3FtH%3FeJ.DtHg1GghG-tHhJ%2B2hJ2g1&amp;test_suite=1&amp;test_suite_input=1%0A2%0A3%0A4%0A5%0A6%0A7%0A8%0A9%0A10%0A11%0A12%0A13%0A14%0A15%0A16%0A17%0A18%0A19%0A20" rel="nofollow noreferrer">Try it online</a></p>

<h3>How it works</h3>

<p>Instead of fooling around with lists, this uses a plain recursive formula.</p>

<pre><code>M                                def g(G, H):
 ?tH                                 if H - 1:
      J.DtHg1G                           J = divmod(H - 1, g(1, G))
    ?e                                   if J[-1]:
              ghG-tHhJ                       return g(G + 1, H - 1 - J[0])
                                         else:
                      +2hJ                   return 2 + J[0]
                                     else:
                          2              return 2
                           g1Q   print(g(1, eval(input())))
</code></pre>
</div>
<div id="pu7" class="pu"><h1><a href="https://www.haskell.org/" rel="noreferrer">Haskell</a>, <s>80</s> 67 bytes</h1>



<pre class="lang-hs prettyprint-override"><code>g~(a:b)|let k!l=k:take(a-1)l++(k+1)!drop(a-1)l=2!g b
m=g m
(!!)$0:m
</code></pre>

<p><a href="https://tio.run/##JchBCsIwEADAe1@xAQ8bgiHxGMgTfEER2WIay@7WUHMUvx4PznGe9OYiMkb9IqXFfqR0YCOZUycuSOdoxTlkF615HK/2n3wxFZZJcwWd1ozG2FNIOpS2HTIotesdsB3b3sHDamGO3scQbuMH" rel="noreferrer" title="Haskell – Try It Online">Try it online!</a></p>

<p>Haskell is the perfect language for defining an infinite list in terms of itself.</p>
</div>
<div id="pu8" class="pu"><h1>Java 8, 124 bytes</h1>

<pre><code>(i)-&gt;{int j=1,a[]=new int[i+1],k,s,n;for(;a[i]&lt;2;){for(k=0,n=2;a[++k]&gt;0;);for(s=a[j++]|2*k;k&lt;=i;k+=s)a[k]=n++;}return a[i];}
</code></pre>

<p>Lambda expression. </p>

<p>Creates an integer array and continually populates it until the nth value gets populated.</p>

<p>Pre-declaring variables at the top to cut down on as many declarations as possible as each <code>int</code> costs 4 bytes of space as opposed to adding <code>,n</code> which is 2.</p>

<p>On the <code>j</code>'th iteration of calculation, the number of 'blanks' one has to skip is equal to <code>a[j]</code> (or 2, if blank). It works out that if the first blank space we have to fill in is at position <code>k</code>,  <code>k * a[j]</code> gives us the 'step' (<code>s</code>).</p>
</div>
<div id="pu9" class="pu"><h2>C, 123 bytes</h2>



<pre class="lang-c prettyprint-override"><code>f(n){int*p=calloc(n,4),i=0,j,k;for(*p=p[1]=2;i&lt;n;++i)for(j=0,k=i/2?0:2-i;j&lt;n;++j)p[j]||k++%p[i]||(p[j]=k/p[i]+2);n=p[n-1];}
</code></pre>

<p><a href="https://tio.run/##RY09DoMwDIX3nsJCQkqaIP461UQ9CGVAqagcaIhQN@Ds1GGpF9vvs9@z2dva4xiElyv57zUY20/TbIXXN6nJFNrpEYd5EYxCW3amQmo8KkUyqo4vRkN59SjuVUboTuZkaF23baNSaWiJJxEFM@ZxU5VEz2Y@KzvcD46FT09eSFgvwMW@IKJKYKBEbg3UBULMhLAwGUSSvnSiYRAkJZ5ff/D0J6mLiPbjBw" rel="noreferrer" title="C (gcc) – Try It Online">Try it online!</a></p>

<h2>Walkthrough</h2>

<pre class="lang-c prettyprint-override"><code>f(n){int*p=calloc(n,4),
</code></pre>

<p>Allocate an array of <em>n</em> integers to store the first <em>n</em> elements of the sequence. This hardcodes <code>sizeof(int)</code> as <code>4</code>, which is a safe assumption in most cases and certainly one I'm willing to make in the context of code golf. :)</p>

<pre class="lang-c prettyprint-override"><code>i=0,j,k;
</code></pre>

<p>These are all counters: <code>i</code> for the index of the step we're on, <code>j</code> to loop through the sequence looking for empty spaces, and <code>k</code> to count how many empty spaces have been seen.</p>

<pre class="lang-c prettyprint-override"><code>for(*p=p[1]=2;i&lt;n;++i)
</code></pre>

<p>Before we start our main loop, we sneak in an initialization of the first two elements of the sequence to <code>2</code>. (<code>p[0]</code> = <code>*(p + 0)</code> = <code>*p</code>.) This throws off the count for <code>k</code>, though, but...</p>

<pre class="lang-c prettyprint-override"><code>for(j=0,k=i/2?0:2-i;j&lt;n;++j)
</code></pre>

<p>... we also do a sneaky initialization of <code>k</code>, which tests to see if <code>i</code> is less than <code>2</code> and corrects the starting value of <code>k</code> if so. The inner loop also starts here, which iterates over the entire sequence-so-far during each step.</p>

<pre class="lang-c prettyprint-override"><code>p[j]||k++%p[i]||(p[j]=k/p[i]+2);
</code></pre>

<p>This line could really use some explaining. We can expand this to:</p>

<pre class="lang-c prettyprint-override"><code>if (!(p[j] || ((k++) % p[i]))) {
    p[j] = k / p[i] + 2;
}
</code></pre>

<p>by short circuiting, and then by De Morgan's laws and the fact that <code>0</code> is falsy in C:</p>

<pre class="lang-c prettyprint-override"><code>if (p[j] == 0 &amp;&amp; ((k++) % p[i]) == 0) {
    p[j] = k / p[i] + 2;
}
</code></pre>

<p>This essentially states: "if this space is empty, increment <code>k</code>. And if <code>k</code> was previously a multiple of the step size, run the following statement." Hence, we run the statement on every <em>step size</em> elements, which is exactly how the sequence is described. The statement itself is simple; all it does is generate <code>2</code>, <code>3</code>, <code>4</code>, ....</p>

<pre class="lang-c prettyprint-override"><code>n=p[n-1];}
</code></pre>

<p>Using the tricky-return-without-a-return that works with <code>gcc</code>, we "return" the last element of the first <em>n</em> terms in the sequence, which happens to be the <em>n</em>th term.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/127393/">127393</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




