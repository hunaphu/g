<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::76975</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>013</td><td>Uiua</td><td>250517T005821Z</td><td><a href="https://codegolf.stackexchange.com/questions/76975/highest-score-on-the-field/279761#279761">nyxbird</a></td></tr>
<tr d-ix="1"><td>274</td><td>Python3</td><td>250516T205604Z</td><td><a href="https://codegolf.stackexchange.com/questions/76975/highest-score-on-the-field/279757#279757">Ajax1234</a></td></tr>
<tr d-ix="2"><td>049</td><td>MATL</td><td>160404T222037Z</td><td><a href="https://codegolf.stackexchange.com/questions/76975/highest-score-on-the-field/77125#77125">Luis Men</a></td></tr>
<tr d-ix="3"><td>093</td><td>Pyth</td><td>160404T081318Z</td><td><a href="https://codegolf.stackexchange.com/questions/76975/highest-score-on-the-field/77033#77033">Leaky Nu</a></td></tr>
<tr d-ix="4"><td>157</td><td>JavaScript ES6</td><td>160404T080255Z</td><td><a href="https://codegolf.stackexchange.com/questions/76975/highest-score-on-the-field/77032#77032">user8165</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://uiua.org" rel="nofollow noreferrer">Uiua</a>, 13 bytes</h1>
<pre><code>/↥⊜(/+≡⋕)⊸≠@-
</code></pre>
<p><a href="https://uiua.org/pad?src=0_16_0-rc_1__ZiDihpAgL-KGpeKKnCgvK-KJoeKLlSniirjiiaBALQoK4o2k4qSZ4omNMTFmIFsiMTEtMDExMTIzIgogICAgICAgICIxMTEtMDEwLS0iCiAgICAgICAgIjAwMTAtLS0wMSIKICAgICAgICAiMTExLTAxMjM0Il0KCuKNpOKkmeKJjTFmIFsiMSJdCgrijaTipJniiY0yZiBbIjEtMS0xLTEiCiAgICAgICAiLTEtMS0xLSIKICAgICAgICIyLTEtMS0xIgogICAgICAgIi0xLTEtMS0iXQoK4o2k4qSZ4omNNjlmIFsiMTItNDUtIgogICAgICAgICI0LTY1LTkiCiAgICAgICAgIjg3LTY1NCIKICAgICAgICAiMTItNDg3IgogICAgICAgICI0NS0tLS0iCiAgICAgICAgIjY4NDc2NCJdCgrijaTipJniiY0zZiBbIjExMS0xMiIKICAgICAgICItLS0tLS0iCiAgICAgICAiMjEtLTEwIl0K" rel="nofollow noreferrer">Try it!</a></p>
<p>2d <code>⊜ partition</code> strikes again!</p>
<p><code>⊜ partition</code> <code>⊸ by</code> <code>≠ not equals</code> <code>-</code>, <code>⋕ parse</code> each digit and <code>/+ sum</code> each partition, then take the <code>/↥ maximum</code>.</p>
</div>
<div id="pu1" class="pu"><h1>Python3, 274 bytes</h1>
<pre class="lang-py prettyprint-override"><code>E=enumerate
def f(b):
 d={(x,y):v for x,r in E(b)for y,v in E(r)if'-'!=v}
 s=[]
 while d:
  S,q=d.pop(V:=[*d][0]),[V]
  for x,y in q:
   if(O:=[(V,d.pop(V))for X,Y in[(0,1),(1,0),(0,-1),(-1,0)]if d.get(V:=(x+X,y+Y))]):A,B=zip(*O);q+=A;S+=sum(B)
   else:s+=[S]
 return max(s)
</code></pre>
<p><a href="https://tio.run/##bVFNj5swED3Xv2KaS@zFjjCQj7LyYVfaa/cQKdoVRVVWmF1HCRCbpKFVf3s6JqSVqhiJmff85o3tabr2o67iRWPP5yelq8NO23WrSaFLKOkbSwkU6hc98Y6lRyhrCyduwVTwhJsedvx4gZaZcizGn9XxNwGnspzAjw@z1VCgByz5XhWTpm7oKlXZXZFnYc54tkLV4Np5m73XginpM6roig8lrG/1wl9Rk9GQS8ap5CH@Qy48EB7lpoRi8q5b34OeghfeBa@M5Sx94I/qp2no3TO73wfq4X4ZKHfY0Ufm2@mt06kLVLbE01jdHmwFu/WJOnZ2EhSMRiMipQillFGMmU9DIUjYBwQDF8UJ8VoXXYsuML5C0X/kEgSJ/sO9OLmKI5FMBUnEbCq@kMUcY9KTiznBDVxktkjms6Hl9O850Soiol8kkkLIsFf4gbb197d6bQu8WUo@DTfNMlO1dIPTg83EuMK8m5ay/lFg089m4ydjcp8an5Zm22pLv9aV5uAmrtlixfhbNca3JqSx3q@k/5pJxtgNOrpNx7fp5DY9Rfr8Bw" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu2" class="pu"><h1><a href="https://esolangs.org/wiki/MATL" rel="nofollow noreferrer">MATL</a>, <s>54</s> <s>51</s> 49 bytes</h1>
<pre><code>n:&quot;G~1@(2Y6Z+leG45&gt;1e*5M@)*]vtz:&quot;otY*g]G48-X:*sX&gt;
</code></pre>
<p>Input is a 2D char array in MATL(AB) format, with <code>;</code> as row separator. The inputs in the example and in the test cases are respectively:</p>
<pre><code>['11-011123';'111-010--';'0010---01';'111-01234']
['1']
['1-1-1-1';'-1-1-1-';'2-1-1-1';'-1-1-1-']
['12-45-';'4-65-9';'87-654';'12-487';'45----';'684764']
['111-12';'------';'21--10']
</code></pre>
<p><a href="http://matl.tryitonline.net/#code=bjoiR34xQCgyWTZaK2xlRzQ1PjFlKjVNQCkqXXZ0ejoib3RZKmddRzQ4LVg6KnNYPg&amp;input=WycxMi00NS0nOyc0LTY1LTknOyc4Ny02NTQnOycxMi00ODcnOyc0NS0tLS0nOyc2ODQ3NjQnXQ" rel="nofollow noreferrer"><strong>Try it online!</strong></a></p>
<h3>Explanation</h3>
<p>This works by building an adjacency matrix of the graph defined by the relation &quot;being connected&quot;. As an example, consider the 3×4 field</p>
<pre><code>52-4
15-8
3-72
</code></pre>
<p>Entries in a 2D array are easily described in MATL using (column-major) linear indexing. In the 3×4 case, the linear index of each entry is given as</p>
<pre><code>1  4  7 10
2  5  8 11
3  6  9 12
</code></pre>
<p>The adjacency matrix is built in steps using matrix multiplication. In the first step, <em>immediate</em> neighbours are considered. For example, the point indexed 3 is neighbour of itself and of that with index 2. It's not a neighbour of 6 because that point doesn't contain a number according to the field. In this example the adjacency matrix of the relation  &quot;immediate-neighbour&quot; is the 12×12 matrix <strong>L</strong> given as</p>
<pre><code>1 1 0 1 0 0 0 0 0 0 0 0
1 1 1 0 1 0 0 0 0 0 0 0
0 1 1 0 0 0 0 0 0 0 0 0
1 0 0 1 1 0 0 0 0 0 0 0
0 1 0 1 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 0 0 1
0 0 0 0 0 0 0 0 0 1 1 0
0 0 0 0 0 0 0 0 0 1 1 1
0 0 0 0 0 0 0 0 1 0 1 1
</code></pre>
<p>(It can seen that column 3 has value <code>1</code> at rows 2 and 3.) This matrix is always symmetric and its diagonal has value <code>1</code> for points that don't contain <code>-</code>.</p>
<p>The next step would be the adjacency matrix of the relation &quot;connected with <em>at most one point in between</em>&quot;. To obtain it, it suffices to multiply <strong>L</strong> by itself and set nonzero entries to <code>1</code>. In general, the adjacency matrix of the relation &quot;connected by <em>some</em> path&quot;, <strong>M</strong>, is obtained by raising <strong>L</strong> to an exponent (in matrix sense) that represents the maximum possible path length. An upper bound of the maximum path length is the number of nonzero entries in <strong>L</strong>.</p>
<p>Computing the matrix power directly may cause overflow, because large numbers quickly occur. So it's better to gradually multiply by the same matrix, converting nonzero entries into 1 after each step to prevent large numbers from building up.</p>
<p>Column <em>i</em> of <strong>M</strong> represents the points that are connected (by any path) with point <em>i</em>. Now, the level field can be reduced to a column vector <strong>c</strong> in linear order, where each entry contains the corresponding number or an undefined value for <code>-</code>. So in this case <strong>c</strong> would be</p>
<pre><code>5
1
3
2
5
-
-
-
7
4
8
2
</code></pre>
<p>Mutiplying each column of <strong>M</strong> by <strong>c</strong> element-wise and computing the sum of each column gives, for each point <em>i</em>, the total score of the area point <em>i</em> belongs to. An area is defined by all points that are mutually connected. Note that many columns will give the same result; namely, columns <em>i</em> and <em>j</em> will give the same sum if points <em>i</em> and <em>j</em> are connected (belong to the same area). The final result is the maximum of those sums.</p>
<pre><code>        % Implicitly take input: 2D char array
n:      % Range [1,...,N], where N is number of entries in the input
&quot;       % For loop. Each iteration builds a row of matrix L
  G     %   Push input again
  ~     %   Logical negate: transform into matrix of zeros
  1     %   Push 1, to be written into a matrix entry
  @     %   Iteration index. Ranges from 1 to N
  (     %   Write that 1 into the N-th entry (linear order)
  2Y6   %   Push array [0 1 0; 1 1 1; 0 1 0]: mask of immediate neighbours
  Z+    %   Convolve and keep same-size result
  le    %   Linearize into row array
  G45&gt;  %   Array of same size as the input that contains 1 for numbers, 0 for '-'
  1e    %   Linearize into row array
  *     %   Multiply element-wise
  5M    %   Push last array again: 1 for numbers, 0 for '-'
  @)    %   Get 0 or 1 value of that array corresponding to current iteration
  *     %   Multiply. This is to give a row of zeros for non-numbers
]       % End. We have all rows of L in the stack
v       % Concatenate all rows into a matrix: L.
tz:     % Duplicate. Range [1,...,K], where K is the number of nonzeros in L
&quot;       % For loop. Repear K times. This loop computes the 0/1 matrix power
  o     %   Convert matrix entries to double
  tY*   %   Duplicate and matrix-multiply
  g     %   Convert to logical values, that is, nonzero values become 1
]       % End. We have matrix M
G48-    % Convert input chars to the corresponding numbers by subtractig 48
X:      % Linearize into column array. This is vector c
*       % Element-wise multiplication with broadcast (implicit repetition)
s       % Sum of each column. Gives a row array
X&gt;      % Maximum of that row array
        % Implicitly display
</code></pre>
</div>
<div id="pu3" class="pu"><h1>Pyth, 93 bytes</h1>

<pre><code>A,hlh.zjJ\-.zKsm?qdJd\#HD'b=KXKbJR+i@HbTsm?&amp;&amp;gd0&lt;dlKq@Kd\#'d0[tbhb-bG+bG;Wh=NxK\#=+Y'N)h.MZY
</code></pre>

<p><a href="http://pyth.herokuapp.com/?code=A%2Chlh.zjJ%5C-.zKsm%3FqdJd%5C%23HD%27b%3DKXKbJR%2Bi%40HbTsm%3F%26%26gd0%3CdlKq%40Kd%5C%23%27d0[tbhb-bG%2BbG%3BWh%3DNxK%5C%23%3DY%2BY%27N%29h.MZY&amp;input=11-011123%0A111-010--%0A0010---01%0A111-01234&amp;debug=1" rel="nofollow">Try it online!</a></p>

<h2>How it works</h2>

<hr>

<h3>First step: read the input</h3>

<pre><code>A,hlh.zjJ\-.zKsm?qdJd\#H
A,                           Assign the following to G and H:
  hlh.z                          G = increment(length(first(all_input())))
       jJ\-.z                    H = join(J="-",all_input())
                m       H    for d in H:
                 ?qdJ            if equal(d,J):
                     d               add d to the list
                                 else:
                      \#             add "#" to the list
                             end
               s             sum the list
              K              assign to K

Sample input:
11-011123
111-010--
0010---01
111-01234

G = 10
H = "11-011123-111-010---0010---01-111-01234" (note the extra dashes connecting each line)
J = "-"
K = "##-######-###-###---####---##-###-#####"
</code></pre>

<h3>Second step: define a function to evaluate one area</h3>

<pre><code>D'b=KXKbJR+i@HbTsm?&amp;&amp;gd0&lt;dlKq@Kd\#'d0[tbhb-bG+bG;
D'b                                             ;  def quote(b):
   =KXKbJ                                              K[b] = J
         R+                                            return the sum of A and B, where:
           i@HbT                                         A = to_integer(H[b],10)

                 m                   [tbhb-bG+bG         for d in {dec(b), inc(b), minus(b,G), add(b,G)}:
                  ?&amp;&amp;                                      if .... and ........ and ............... :
                     gd0                                      d&gt;=0
                        &lt;dlK                                           d&lt;len(K)
                            q@Kd\#                                                  equal(K[d],"#")
                                  'd                           add quote(d) to temp_list
                                                           else:
                                    0                          add 0 to temp_list
                s                                        B = sum(temp_list)

Basically, this function (quote) is given a starting
point (b), and then recursively find its neighbour and
add their values to the output.
</code></pre>

<h3>Third step: read all the areas and find the rqeuired maximum</h3>

<pre><code>Wh=NxK\#=+Y'N)h.MZY
Wh=NxK\#     )         while inc(N=find(K,"#")):   --while K still has "#"
        =+Y'N              Y+= quote(N)
               .MZY    find the maximum of Y,
              h        then print the first.
</code></pre>
</div>
<div id="pu4" class="pu"><h1>JavaScript (ES6), 157 bytes</h1>

<pre class="lang-js prettyprint-override"><code>s=&gt;[...o=s].map((n,i)=&gt;o=n&lt;'.'|(a=[...s]).map(_=&gt;a.map((c,j)=&gt;c&gt;'-'&amp;c&lt;10&amp;(a[j+1]|a[j-1]|a[j+l]|a[j-l])&gt;90?a[n-=-c,j]=99:0),a[i]=99)|o&gt;n?o:n,l=~s.search`
`)|o
</code></pre>

<h2>Explanation</h2>

<p>Takes an input field as a string. For each number in the field, sums all numbers in the area. It does this by iterating over each number in the field multiple times, adding the number to the score if an adjacent cell contains a previously counted number. Counted numbers that are part of the area are represented by setting them to 99 so that they are not counted again. Outputs the highest score as a number.</p>

<p><div class="snippet" data-lang="js" data-hide="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var solution =

s=&gt;
  [...o=s].map((n,i)=&gt;o=n&lt;'.'|             // for each number on the field
                                           // n = area score
      (a=[...s])                           // a = array of each field character
      .map(_=&gt;                             // loop to ensure whole area is found
        a.map((c,j)=&gt;                      // for each cell c at index j
          c&gt;'-'&amp;c&lt;10&amp;                      // if the current cell is a number
          (a[j+1]|a[j-1]|a[j+l]|a[j-l])&gt;90 // and an adjacent cells is in the area
          ?a[n-=-c,j]=99:0                 // add the cell to the area
        ),                                 // and the number to the score
        a[i]=99                            // mark the starting cell as counted
      )
      |o&gt;n?o:n,                            // o = output (max of o and n)
    l=~s.search`
`                                          // l = line length of field
  )
  |o                                       // return o</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;textarea id="input" rows="6" cols="40"&gt;12-45-
4-65-9
87-654
12-487
45----
684764&lt;/textarea&gt;&lt;br /&gt;
&lt;button onclick="result.textContent=solution(input.value)"&gt;Go&lt;/button&gt;
&lt;pre id="result"&gt;&lt;/pre&gt;</code></pre>
</div>
</div>
</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/76975/">76975</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




