<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::74853</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>010</td><td>Japt</td><td>250703T215257Z</td><td><a href="https://codegolf.stackexchange.com/questions/74853/find-the-words-on-the-grid/282540#282540">Shaggy</a></td></tr>
<tr d-ix="1"><td>017</td><td>Uiua</td><td>250704T005814Z</td><td><a href="https://codegolf.stackexchange.com/questions/74853/find-the-words-on-the-grid/282542#282542">ErikDaPa</a></td></tr>
<tr d-ix="2"><td>014</td><td>Vyxal 3</td><td>250703T204322Z</td><td><a href="https://codegolf.stackexchange.com/questions/74853/find-the-words-on-the-grid/282538#282538">pacman25</a></td></tr>
<tr d-ix="3"><td>251</td><td>Python 3.5 using Numpy</td><td>160516T110143Z</td><td><a href="https://codegolf.stackexchange.com/questions/74853/find-the-words-on-the-grid/80004#80004">R. Kap</a></td></tr>
<tr d-ix="4"><td>108</td><td>JavaScript ES6</td><td>160305T213727Z</td><td><a href="https://codegolf.stackexchange.com/questions/74853/find-the-words-on-the-grid/74905#74905">edc65</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/ETHproductions/japt" rel="nofollow noreferrer">Japt</a>, <s>14</s> 10 <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" rel="nofollow noreferrer">bytes</a></h1>
<p>Takes the end coordinates as the first input, start coordinates as the second, and the grid, as a 2D array of characters, as the third. Outputs a character array.</p>
<pre><code>íõV ÕËrgWz
</code></pre>
<p><a href="https://petershaggynoble.github.io/Japt-Interpreter/?v=1.4.6&amp;code=7fVWINXLcmdXeg&amp;input=WzQsMF0sWzAsNF0KW1snQScgJ0cnICdPJyAnQScgJ1QnICdDJyAnQScgJ1QnXQogWydFJyAnQScgJ1QnICdNJyAnRScgJ04nICdPJyAnVyddCiBbJ1cnICdPJyAnUicgJ0QnICdTJyAnRScgJ0EnICdSJ10KIFsnQScgJ0snICdMJyAnTCcgJ0snICdKJyAnSCcgJ0cnXQogWydOJyAnUCcgJ0wnICdGJyAnRycgJ0gnICdGJyAnRCddCiBbJ0EnICdTJyAnUCcgJ0wnICdLJyAnSicgJ0gnICdHJ10KIFsnTycgJ1AnICdJJyAnTCcgJ0YnICdHJyAnSCcgJ0onXQogWydUJyAnRicgJ0EnICdTJyAnRScgJ0onICdLJyAnTCddXQotUA" rel="nofollow noreferrer">Try it</a></p>
<pre><code>íõV ÕËrgWz     :Implicit input of arrays U=end &amp; V=start, and 2D-array W=wordsearch
í V            :Interleave U &amp; V
 õ             :  Reducing each pair by reversed inclusive range (e.g. 0õ4=[4,3,2,1,0])
    Õ          :Transpose
     Ë         :Map
      r        :  Reduce by
       g       :  Indexing
        Wz     :  With a starting value of W rotated 90° clockwise
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://uiua.org/" rel="nofollow noreferrer">Uiua</a>, 17 bytes</h1>
<pre><code>⊡⊓◴⇌\+˜⊂↯⊣⊃⍆±⤚-∩⇌
</code></pre>
<p><strong>Explanation:</strong></p>
<pre><code>⊡⊓◴⇌\+˜⊂↯⊣⊃⍆±⤚-∩⇌
                    ∩⇌ =&gt; reverse both coordinates (due to Uiua's coordinate system)
             ⊃⍆±⤚-    =&gt; get both direction vector and distance
           ↯⊣          =&gt; direction vector repeated by amount of the distance
      \+˜⊂             =&gt; combine with the 1st coordinate, then do accumulative sum
     ⇌                 =&gt; arrange grid for proper indexing
  ⊓◴                  =&gt; remove duplicate coordinates
⊡                     =&gt; finally pick the coordinates from grid
</code></pre>
<p><a href="https://www.uiua.org/pad?src=0_17_0-dev_1__R-KCgSDihpAg4oqcKOKKnOKKouKKuOKJoEAgKeKKuOKJoEBcbiQgQSBHIE8gQSBUIEMgQSBUCiAgICAgICAgICAgICAgICAgICAkIEUgQSBUIE0gRSBOIE8gVwogICAgICAgICAgICAgICAgICAgJCBXIE8gUiBEIFMgRSBBIFIKICAgICAgICAgICAgICAgICAgICQgQSBLIEwgTCBLIEogSCBHCiAgICAgICAgICAgICAgICAgICAkIE4gUCBMIEYgRyBIIEYgRAogICAgICAgICAgICAgICAgICAgJCBBIFMgUCBMIEsgSiBIIEcKICAgICAgICAgICAgICAgICAgICQgTyBQIEkgTCBGIEcgSCBKCiAgICAgICAgICAgICAgICAgICAkIFQgRiBBIFMgRSBKIEsgTApGICDihpAg4oqh4oqT4pe04oeMXCvLnOKKguKGr-KKo-KKg-KNhsKx4qSaLeKIqeKHjApGIDBfNCA0XzAgR-KCgQpGIDFfNyA0XzcgR-KCgQpGIDBfNSA3XzUgR-KCgQpGIDBfNiA1XzYgR-KCgQpGIDdfMCAwXzcgR-KCgQo=" rel="nofollow noreferrer">Try this online!</a></p>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal/tree/version-3/" rel="nofollow noreferrer">Vyxal 3</a>, 14 bytes</h1>
<pre><code>-∥±GY⁰pσ$⇄T$Þi
</code></pre>
<p>input is start, end, then grid as character matrix</p>
<p><a href="https://vyxal.github.io/latest.html#H4sIAAAAAAAACqtWSssvyk0sUbIy1lHKSE1MSS1SslJS0lFKzk9JBbJ0H3UsPbTRPfJR44aC880qj9pbQlQOz8sEKkjLzy-BKU7LSUwvVrKKjtVRyswrKC0BsaOVHAsKclKVdKKVog10TGKByqJNdAzAdHSMkmOMko5CjJI7hPKHUFDBEAjljC4Yq6MA1OmKTa0vhILK-aGYGg7TGY4iHAShXCBUMIoBjnAlEJ1QvjeE8kGhoIJeEMoD7i-ITqhTAlC0uKF43gNF0AXNzmBsBuC30x9Fiydhq71gOkNQFKG6wBXFTkRQxMYCETCW0_OByQgU24Y65tDYNh-N7WEZ28B8XpZaVJyZnwfM_8Z65noGSrUAP-5Wn0oEAAA" rel="nofollow noreferrer">Vyxal It Online!</a></p>
<pre><code>-∥±GY⁰pσ$⇄T$Þi­⁡​‎‎⁪⁡⁪⁠⁪⁡⁪‏‏​⁡⁠⁡‌⁢​‎‎⁪⁡⁪⁠⁪⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁪‏⁠⁪⁪‏​⁡⁠⁡‌⁣​‎⁪⁪⁠⁪⁪⁠⁪⁪⁠‎⁪⁡⁪⁠⁪⁢⁡⁪‏⁠⁪⁪‏​⁡⁠⁡‌⁤​‎‎⁪⁡⁪⁠⁪⁢⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁪‏‏​⁡⁠⁡‌⁢⁡​‎‎⁪⁡⁪⁠⁪⁣⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁤⁪‏‏​⁡⁠⁡‌⁢⁢​‎‎⁪⁡⁪⁠⁪⁤⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁢⁪‏‏​⁡⁠⁡‌­
-               # ‎⁡difference between two coords
 ∥±G            # ‎⁢the direction vector of the difference and the maximum distance
    Y           # ‎⁣direction vector repeated that many times
     ⁰pσ        # ‎⁤prepend the initial coordinate and cumulative sum for coords of all letters
        $⇄T$    # ‎⁢⁡arrange the grid so indexing works properly
            Þi  # ‎⁢⁢get letter at coordinate
💎
</code></pre>
<p>Created with the help of <a href="https://vyxal.github.io/Luminespire" rel="nofollow noreferrer">Luminespire</a>.</p>
</div>
<div id="pu3" class="pu"><h1>Python 3.5 using Numpy, 251 bytes:</h1>

<pre><code>def r(t,y,z):import numpy;l=numpy.array([[*i.split()]for i in z.split('\n')]);A,B,C,D=t[0],y[0],t[1],y[1];p=[1,-1];a=p[A&gt;B];b=p[C&gt;D];n=range(A,B+a,a);m=range(C,D+b,b);w=[l[:,i][::-1][p]for i,p in zip([[A]*len(m),n][A!=B],[[C]*len(n),m][C!=D])];return w
</code></pre>

<ul>
<li><p>Takes <strong>input</strong> in the following format:</p>

<pre><code>print(''.join(r((start1,start2),(end1,end2),'''grid''')))
</code></pre></li>
<li><p><strong>Outputs</strong> in the format of a string (e.g. <code>APPLE</code>) as long as the function is called using the format above. Otherwise, a list
containing each letter (e.g. <code>['A','P','P','L','E']</code>) is returned.</p></li>
</ul>

<p>Will golf more over time where and when I can.</p>

<p><a href="http://ideone.com/9IIjvx" rel="nofollow">Try It Online! (Ideone)</a> (Here, input is taken such that the grid is surrounded with double quotes (<code>""</code>) and input on one line, with <code>\n</code>s between each line of the grid. Then, the points are provided in a simple tuple form, with the starting on the second line, and the end on the third.)</p>

<h2>Ungolfed code along with Explanation</h2>

<pre><code>def r(t,y,z):
    import numpy
    l=numpy.array([[*i.split()]for i in z.split('\n')])
    A,B,C,D=t[0],y[0],t[1],y[1]
    p=[1,-1]
    a=p[A&gt;B]
    b=p[C&gt;D]
    n=range(A,B+a,a)
    m=range(C,D+b,b)
    w=[l[:,i][::-1][p]for i,p in zip([[A]*len(m),n][A!=B],[[C]*len(n),m][C!=D])]
    return w
</code></pre>

<p>For the purposes of this explanation, assume this program was run with the inputs <code>((0,4),(4,0))</code> and the first grid of the question. Here, I will go through the 2 main parts of the code:</p>

<ul>
<li><p><code>l=numpy.array([[*i.split()]for i in z.split('\n')])</code></p>

<p>Here, <code>l</code> is a numpy array containing each line of the input in a separate "list". For instance, the first grid in the question, which is:</p>

<pre><code>A G O A T C A T
E A T M E N O W
W O R D S E A R
A K L L K J H G
N P L F G H F D
A S P L K J H G
O P I L F G H J
T F A S E J K L
</code></pre>

<p>returns this numpy array:</p>

<pre><code>[['A' 'G' 'O' 'A' 'T' 'C' 'A' 'T']
 ['E' 'A' 'T' 'M' 'E' 'N' 'O' 'W']
 ['W' 'O' 'R' 'D' 'S' 'E' 'A' 'R']
 ['A' 'K' 'L' 'L' 'K' 'J' 'H' 'G']
 ['N' 'P' 'L' 'F' 'G' 'H' 'F' 'D']
 ['A' 'S' 'P' 'L' 'K' 'J' 'H' 'G']
 ['O' 'P' 'I' 'L' 'F' 'G' 'H' 'J']
 ['T' 'F' 'A' 'S' 'E' 'J' 'K' 'L']]
</code></pre></li>
<li><p><code>w=[l[:,i][::-1][p]for i,p in zip([[A]*len(m),n][A!=B],[[C]*len(n),m][C!=D])]</code></p>

<p>This is the main list of the function in which all of the letters corresponding to each point on the grid is found. Here, <code>i</code> corresponds to either each integer in <code>n</code>, which is a range object containing every number in the range <code>start1=&gt;end1+1</code> in increments of <code>+1</code> if <code>start1&lt;end1</code> or <code>-1</code> if the opposite is true. However, <code>i</code> only corresponds to this as long as <code>start1</code> does not equal <code>end1</code>. Otherwise <code>start1</code> is returned as many times as the length of <code>m</code>, where <code>m</code> is a range object containing each integer in the range <code>start2=&gt;end2+1</code> with the same conditions as <code>n</code>, and <code>p</code> corresponds to every integer in <code>m</code>. That being said, let us now walk through this step by step:</p>

<ul>
<li><p><code>l[:,i]</code> basically returns a row vector for each column, <code>i</code>, in the array, <code>l</code>. for instance, <code>l[:,0]</code> would return:</p>

<pre><code>['A' 'E' 'W' 'A' 'N' 'A' 'O' 'T']
</code></pre>

<p><code>l[:,1]</code> would return:</p>

<pre><code>['G' 'A' 'O' 'K' 'P' 'S' 'P' 'F']
</code></pre>

<p>so on and so forth. You can read more about different ways of indexing in numpy, including this method, <a href="http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html" rel="nofollow">here</a>.</p></li>
<li><p>Then, after that, the function reverses each array returned, using <code>l[:,i][::-1]</code>, since each array is indexed from left to right, but since the point <code>0,0</code> on the grid in on the lower left hand corner of the grid, reversing each array would return the index values as if they were being looked for from right to left. For instance, <code>l[:,0][::-1]</code> would return:</p>

<pre><code>['T' 'O' 'A' 'N' 'A' 'W' 'E' 'A']
</code></pre></li>
<li><p>After this, the function then indexes through that reversed array for the index value corresponding to <code>p</code>, which is your letter, and then adds that to the list being created. For instance, <code>l[:,0][::-1][4]</code>, which corresponds to point <code>(0,4)</code>, would return <code>A</code>.</p></li>
<li><p>This process keeps on repeating and adding new values to the list until  the range objects are exhausted. </p></li>
</ul></li>
</ul>

<p>After all that, the output, which is list <code>w</code>, is finally returned. In this case, that would be <code>APPLE</code> if called with <code>print(''.join(r((0,4),(4,0),'''The Grid''')))</code> or <code>['A','P','P','L','E']</code> if it is called without <code>''.join()</code>. Either way, it returns the correct answer, and we are done!</p>
</div>
<div id="pu4" class="pu"><h1>JavaScript (ES6) 108</h1>

<pre class="lang-js prettyprint-override"><code>(x,y,t,u,g)=&gt;eval(&quot;for(g=g.split`\n`.reverse(),r=g[y][2*x];x-t|y-u;)r+=g[y+=u&lt;y?-1:u&gt;y][2*(x+=t&lt;x?-1:t&gt;x)]&quot;)
</code></pre>
<p><strong>Less golfed</strong></p>
<pre class="lang-js prettyprint-override"><code>(x,y,t,u,g)=&gt;{
    g=g.split`\n`.reverse();
    for(r = g[y][2*x]; x-t | y-u; )
        r+=g[y += u&lt;y ? -1 : u&gt;y][2*( x += t&lt;x ? -1 : t&gt;x)];
    return r
}   
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/74853/">74853</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




