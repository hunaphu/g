<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::65549</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>004</td><td>Japt mP</td><td>240918T222848Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/275623#275623">Shaggy</a></td></tr>
<tr d-ix="1"><td>007</td><td>Uiua</td><td>240918T220055Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/275622#275622">Adelie</a></td></tr>
<tr d-ix="2"><td>004</td><td>Vyxal</td><td>240918T231527Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/275625#275625">emanresu</a></td></tr>
<tr d-ix="3"><td>043</td><td>Python</td><td>220715T120054Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/249980#249980">pxeger</a></td></tr>
<tr d-ix="4"><td>029</td><td>V vim</td><td>210409T055317Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/223127#223127">Razetime</a></td></tr>
<tr d-ix="5"><td>006</td><td>Husk</td><td>210103T090517Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/217218#217218">Razetime</a></td></tr>
<tr d-ix="6"><td>005</td><td>Stax</td><td>190828T115729Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/190992#190992">Khuldrae</a></td></tr>
<tr d-ix="7"><td>033</td><td>Pari/GP</td><td>151203T042017Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65619#65619">alephalp</a></td></tr>
<tr d-ix="8"><td>035</td><td>Haskell</td><td>151202T171050Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65561#65561">nimi</a></td></tr>
<tr d-ix="9"><td>050</td><td>Common Lisp</td><td>180513T031409Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/164673#164673">ASCII-on</a></td></tr>
<tr d-ix="10"><td>004</td><td>Jelly</td><td>180513T015827Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/164671#164671">Dennis</a></td></tr>
<tr d-ix="11"><td>016</td><td>K ngn/k</td><td>180512T204647Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/164661#164661">ngn</a></td></tr>
<tr d-ix="12"><td>060</td><td>Python 3</td><td>151203T123449Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65635#65635">Sherlock</a></td></tr>
<tr d-ix="13"><td>083</td><td>C</td><td>151203T114327Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65632#65632">Ruud Hel</a></td></tr>
<tr d-ix="14"><td>009</td><td>MATL</td><td>151227T050816Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/67836#67836">Luis Men</a></td></tr>
<tr d-ix="15"><td>055</td><td>Arcyóu</td><td>151202T212559Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65591#65591">jqkul</a></td></tr>
<tr d-ix="16"><td>086</td><td>Math++</td><td>151204T112446Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65725#65725">SuperJed</a></td></tr>
<tr d-ix="17"><td>008</td><td>Par</td><td>151204T020906Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65698#65698">lynn</a></td></tr>
<tr d-ix="18"><td>033</td><td>Ruby</td><td>151203T225207Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65689#65689">Level Ri</a></td></tr>
<tr d-ix="19"><td>006</td><td>Pyth</td><td>151202T185428Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65579#65579">Jakube</a></td></tr>
<tr d-ix="20"><td>054</td><td>Haskell</td><td>151203T172900Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65656#65656">Ruud Hel</a></td></tr>
<tr d-ix="21"><td>053</td><td>ES6</td><td>151203T170313Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65653#65653">Neil</a></td></tr>
<tr d-ix="22"><td>nan</td><td>Batch</td><td>151203T164209Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65651#65651">Neil</a></td></tr>
<tr d-ix="23"><td>066</td><td>Bash</td><td>151202T213333Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65593#65593">Ruud Hel</a></td></tr>
<tr d-ix="24"><td>1123</td><td>𝔼𝕊𝕄𝕚𝕟</td><td>151203T044122Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65620#65620">Mama Fun</a></td></tr>
<tr d-ix="25"><td>069</td><td>Retina</td><td>151203T124637Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65638#65638">Martin E</a></td></tr>
<tr d-ix="26"><td>115</td><td>Prolog SWI</td><td>151203T125448Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65639#65639">Emigna</a></td></tr>
<tr d-ix="27"><td>049</td><td>Perl 5</td><td>151203T093351Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65627#65627">hobbs</a></td></tr>
<tr d-ix="28"><td>021</td><td>Mathematica</td><td>151202T182225Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65574#65574">alephalp</a></td></tr>
<tr d-ix="29"><td>031</td><td>Octave</td><td>151203T032920Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65612#65612">alephalp</a></td></tr>
<tr d-ix="30"><td>007</td><td>Dyalog APL</td><td>151202T165646Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65558#65558">lirtosia</a></td></tr>
<tr d-ix="31"><td>011</td><td>Japt</td><td>151202T164121Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65554#65554">ETHprodu</a></td></tr>
<tr d-ix="32"><td>015</td><td>LabVIEW</td><td>151202T162847Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65552#65552">Eumel</a></td></tr>
<tr d-ix="33"><td>013</td><td>K5</td><td>151202T162644Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65550#65550">JohnE</a></td></tr>
<tr d-ix="34"><td>042</td><td>Matlab</td><td>151202T173555Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65565#65565">flawr</a></td></tr>
<tr d-ix="35"><td>010</td><td>Pyth</td><td>151202T164404Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65555#65555">lirtosia</a></td></tr>
<tr d-ix="36"><td>021</td><td>Burlesque</td><td>151202T171253Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65562#65562">mroman</a></td></tr>
<tr d-ix="37"><td>009</td><td>CJam</td><td>151202T162734Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65551#65551">Martin E</a></td></tr>
<tr d-ix="38"><td>011</td><td>J</td><td>151202T164049Z</td><td><a href="https://codegolf.stackexchange.com/questions/65549/write-out-the-thue-morse-sequence/65553#65553">Zgarb</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/ETHproductions/japt" rel="nofollow noreferrer">Japt</a> <a href="https://codegolf.meta.stackexchange.com/a/14339/"><code>-mP</code></a>, 4 <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>¢¬r^
</code></pre>
<p><a href="https://petershaggynoble.github.io/Japt-Interpreter/?v=1.4.6&amp;flags=LW1Q&amp;code=oqxyXg&amp;input=MjA" rel="nofollow noreferrer">Try it here</a></p>
<pre><code>¢¬r^     :Implicit map of range [0,input)
ç        :Convert to binary string
 ¬       :Split
  r      :Reduce by
   ^     :  Bitwise XOR
         :Implicitly join &amp; output
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.uiua.org" rel="nofollow noreferrer">Uiua</a>, 7 bytes</h1>
<pre><code>◿2/+⍉⋯⇡
</code></pre>
<p>Returns an array; port of <a href="https://codegolf.stackexchange.com/a/164671/120625">Dennis's Jelly answer</a>. <a href="https://uiua.org/pad?src=0_13_0-dev_2__RiDihpAg4pe_Mi8r4o2J4ouv4oehCkYwRjEyRjM3RjQyRjIwCg==" rel="nofollow noreferrer">Try it online!</a></p>
<h2>Explanation</h2>
<pre><code>◿2/+⍉⋯⇡ # main function
      ⇡ # generate array of all natural numbers less than the input
     ⋯  # encode each number in the array as bits, LSB-first
    ⍉   # rotate the shape of the array
  /+    # sum each column of bits
◿2      # modulo each sum by 2
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal/tree/version-2" rel="nofollow noreferrer">Vyxal</a>, 4 bytes</h1>
<pre><code>ʁbṠ∷
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/?v=2&amp;c=1#WyIiLCIiLCLKgWLhuaDiiLciLCIiLCIyMCJd" rel="nofollow noreferrer">Try it Online!</a> Port of Dennis's Jelly answer.</p>
<pre><code>ʁ    # 0...n-1
   ∷ # parity of
  Ṡ  # number of
 b   # 1s in binary representation
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.python.org" rel="nofollow noreferrer">Python</a>, 43 bytes</h1>
<pre>def f(n):n&gt;0==f(n-1);print(n.bit_count()%2)</pre>
<p><a href="https://ato.pxeger.com/run?1=m72soLIkIz9vwYKlpSVpuhY3tVNS0xTSNPI0rfLsDGxtgSxdQ03rgqLMvBKNPL2kzJL45PxSIFtT1UgTomVpmoaRAZQNMwYA" rel="nofollow noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/DJMcMayhem/V" rel="nofollow noreferrer">V (vim)</a>, <sup><s>35</s></sup> 29 bytes</h1>
<pre><code>C0&lt;esc&gt;qqy$V!tr 01 10
P|q@-@q@-lD
</code></pre>
<p><a href="https://tio.run/##K/v/39nAJrU42a6wsFIlTLGkSMHAUMHQgCugptBB1wGIc1z@/zcy@K9bBgA" rel="nofollow noreferrer" title="V (vim) – Try It Online">Try it online!</a></p>
<p>-6 bytes from Leo.</p>
<p>Prints the first <span class="math-container">\$n\$</span> elements.</p>
<p>The sequence is basically a string replacement and append, so it does that <span class="math-container">\$n\$</span> times using <code>tr</code> and then truncates the sequence to <span class="math-container">\$n\$</span> digits.</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/barbuz/Husk" rel="nofollow noreferrer">Husk</a>, 6 bytes</h1>
<pre><code>moF≠ḋŀ
</code></pre>
<p><a href="https://tio.run/##yygtzv7/Pzff7VHngoc7uo82/P//38gAAA" rel="nofollow noreferrer" title="Husk – Try It Online">Try it online!</a></p>
<h2>Using infinite list:</h2>
<pre><code>↑¹!¡S+m¬;0
</code></pre>
<p><a href="https://tio.run/##yygtzv7//1HbxEM7FQ8tDNbOPbTG2uD///9GBgA" rel="nofollow noreferrer" title="Husk – Try It Online">Try it online!</a></p>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/tomtheisen/stax" rel="nofollow noreferrer">Stax</a>, 5 <a href="https://github.com/tomtheisen/stax/blob/master/docs/packed.md#packed-stax" rel="nofollow noreferrer">bytes</a></h1>

<pre><code>╩0ΔΔ(
</code></pre>

<p><a href="https://staxlang.xyz/#p=ca30ffff28&amp;i=20%0A42%0A0%0A37%0A12&amp;a=1&amp;m=2" rel="nofollow noreferrer">Run and debug it at staxlang.xyz!</a></p>

<h3>Unpacked (6 bytes) and explanation:</h3>

<pre><code>mv:11I
mv        Map block over range [0,n):
  :1        Popcount
    1I      Is odd?
            Implicit print with newline
</code></pre>

<p><code>1I</code> is bitwise and with 1. <code>2%</code> would work just as well, also packing to 5 bytes.</p>
</div>
<div id="pu7" class="pu"><h1><a href="http://pari.math.u-bordeaux.fr/" rel="nofollow noreferrer">Pari/GP</a>, 33 bytes</h1>

<pre><code>n-&gt;[sumdigits(x,2)%2|x&lt;-[0..n-1]]
</code></pre>

<p><a href="https://tio.run/##K0gsytRNL/ifpmD7P0/XLrq4NDclMz2zpFijQsdIU9WopsJGN9pATy9P1zA29n9BUWZeiUaahrGRpuZ/AA" rel="nofollow noreferrer" title="Pari/GP – Try It Online">Try it online!</a></p>
</div>
<div id="pu8" class="pu"><h2>Haskell, <s>39</s> <s>36</s> 35 bytes</h2>

<pre><code>take&lt;*&gt;(iterate([id,(1-)]&lt;*&gt;)[0]!!)
</code></pre>

<p><a href="https://tio.run/##VcixDkAwEADQ3VecxNCKJtUY8SNluFRLo2i03@9Yje9tmHYbArlhooy77euR@WxvzJZpvzSsFXz@kms5lyWnA/0JAyxXARBvf2aowEGrflTyx04V9BgXcE0kTIwv" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>

<p>How it works: start with <code>[0]</code> and apply the <code>x ++ invert x</code>-function <code>n</code> times. Take the first <code>n</code> elements from the resulting list. Thanks to Haskell's laziness only the first <code>n</code> elements are actually calculated.
Note: the first <code>&lt;*&gt;</code> is in function context, the second in list context.</p>

<p>With GHC v8.4 (which wasn't available at the the time of the challenge) there's a 34 byte solution:</p>

<pre><code>take&lt;*&gt;(iterate(id&lt;&gt;map(1-))[0]!!)
</code></pre>

<p>Edit: -3 resp. -4 bytes thanks to @Laikoni. -1 byte thanks to  @Ørjan Johansen.</p>
</div>
<div id="pu9" class="pu"><h1><a href="http://www.clisp.org/" rel="nofollow noreferrer">Common Lisp</a>, 50 bytes</h1>



<pre class="lang-lisp prettyprint-override"><code>(lambda(n)(dotimes(i n)(princ(mod(logcount i)2))))
</code></pre>

<p><a href="https://tio.run/##DcdLEoAgCADQfadgCTvrRuanYQbBUs9Pvt1LwqM7jjJfqI4S250jKmG2ya0MZNjpH2vCZhnFnmRLJzBdtDkdWJemKAIVzhDIfw" rel="nofollow noreferrer" title="Common Lisp – Try It Online">Try it online!</a></p>
</div>
<div id="pu10" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 4 bytes</h1>

<pre><code>ḶB§Ḃ
</code></pre>

<p>Note that this challenge is older than Jelly.</p>

<p><a href="https://tio.run/##y0rNyan8///hjm1Oh5Y/3NH0//9/EyMA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>

<h3>How it works</h3>

<pre><code>ḶB§Ḃ  Main link. Argument: n (integer)

Ḷ     Unlength; yield [0, ..., n-1].
 B    Compute the binary representation of each integer in the range.
  §   Take the sum of each binary representation.
   Ḃ  Take the LSB of each sum.
</code></pre>
</div>
<div id="pu11" class="pu"><h1><a href="https://github.com/ngn/k" rel="nofollow noreferrer">K (ngn/k)</a>, 16 bytes</h1>

<pre><code>{2!+/'(x#2)\'!x}
</code></pre>

<p><a href="https://tio.run/##y9bNS8/7/z/NqtpIUVtfXaNC2UgzRl2xovZ/moKJ0X8A" rel="nofollow noreferrer" title="K (ngn/k) – Try It Online">Try it online!</a></p>
</div>
<div id="pu12" class="pu"><h1>Python 3, <s>84</s> <s>80</s> 60 bytes</h1>
<p>Since nobody else was using characters other than <code>0</code> and <code>1</code>, I decided to write my own answer. Here, I use the characters <code>o</code> and <code>t</code>, but I was quite tempted to use <code>b</code> and <code>o</code>, or <code>p</code> and <code>o</code> :P</p>
<p>This is a parity checker in 60 bytes.</p>
<pre><code>lambda n:''.join(&quot;ot&quot;[bin(i).count(&quot;1&quot;)%2]for i in range(n))
</code></pre>
<p>This is a string rewriting algorithm in 109 bytes.</p>
<pre><code>def t(n):
 r=&quot;o&quot;;s=&quot;&quot;
 for i in range(len(bin(n))):
  for c in r:s+=&quot;otto&quot;[c&gt;&quot;o&quot;::2]
  r=s;s=&quot;&quot;
 return r[:n]
</code></pre>
</div>
<div id="pu13" class="pu"><h1>C, <strike>88</strike> 83 bytes</h1>

<p>Calculates the parity for each individual position.</p>

<pre><code>i,j;main(int c,char**a){for(;i&lt;atoi(a[1]);putchar(c))for(c=48,j=i++;j;j&amp;=j-1)c^=1;}
</code></pre>

<p>Fiddle: <a href="http://goo.gl/znxmOk" rel="nofollow">http://goo.gl/znxmOk</a></p>
</div>
<div id="pu14" class="pu"><h1><a href="https://esolangs.org/wiki/MATL" rel="nofollow noreferrer">MATL</a>, 9 bytes</h1>

<p><em>This language was designed after the challenge</em>.</p>

<h2>Approach 1: 13 bytes</h2>

<p>This builds the sequence by concatenating negated copies of increasing-size blocks.</p>

<pre><code>itBFw"t~h]w:)
</code></pre>

<h3>Example</h3>

<pre><code>&gt;&gt; matl itBFw"t~h]w:)
&gt; 20
0 1 1 0 1 0 0 1 1 0 0 1 0 1 1 0 1 0 0 1
</code></pre>

<h3>Explanation</h3>

<pre><code>i           % input number, say "N"
tB          % duplicate and convert to binary. Produces a vector
F           % initialize sequence to "false"
w           % swap to bring vector to top
"           % for loop. There will be at least log2(N) iterations
  t~h       % duplicate, negate, concatenate
]           % end for
w           % swap
:)          % index with vector 1, 2, ..., N
</code></pre>

<h2>Approach 2: 9 bytes</h2>

<p>This uses the same approach as <a href="https://codegolf.stackexchange.com/a/65612/36398">Alephalpha's answer</a>.</p>

<pre><code>i:1-B!s2\
</code></pre>

<h3>Example</h3>

<pre><code>&gt;&gt; matl i:1-B!s2\
&gt; 20
0 1 1 0 1 0 0 1 1 0 0 1 0 1 1 0 1 0 0 1
</code></pre>

<h3>Explanation</h3>

<pre><code>i           % input "N" 
:1-         % create vector 0, 1, ..., N-1
B           % convert to binary
!           % tranpose
s           % sum
2\          % modulo 2
</code></pre>
</div>
<div id="pu15" class="pu"><h1><a href="https://github.com/nazek42/arcyou" rel="nofollow">Arcyóu</a>, <s>50</s> 55 bytes</h1>

<p><em>I had to add 5 bytes to get it to work correctly :(</em></p>

<pre><code>(f i(_(#(l)))(r b^(@(&gt; i 0)(pg 0(% i 2)(: i(#/ i 2))))0
</code></pre>

<p>Explanation (with Pythonesque pseudocode along the side:</p>

<pre><code>(f i (_ (# (l)))       ; For i in range(int(input())):
  (r b^                ; Reduce with binary xor
    (@ (&gt; i 0)         ; While i &gt; 0:
      (pg 0            ; Return first of its arguments
        (% i 2)        ; i mod 2
        (: i (#/ i 2)) ; i //= 2
      )
    )
    0                  ; Default reduce argument of 0 for the first bit in the sequence
</code></pre>
</div>
<div id="pu16" class="pu"><h1><a href="http://esolangs.org/wiki/Math%2B%2B" rel="nofollow">Math++</a>, 86 bytes</h1>

<p>Uses <code>0.0\n</code> for 0 and <code>1.0\n</code> for 1</p>

<pre><code>?&gt;n
3*!!(n-m)&gt;$
m&gt;a
0&gt;k
6+6*!a&gt;$
9-2*!(a%2)&gt;$
a/2&gt;a
5&gt;$
(a-1)/2&gt;a
!k&gt;k
5&gt;$
k
m+1&gt;m
2&gt;$
</code></pre>
</div>
<div id="pu17" class="pu"><h1><a href="http://ypnypn.github.io/Par/" rel="nofollow">Par</a>, 8 bytes</h1>

<pre><code>✶u[Σ_✶¨^
</code></pre>

<p>Explanation:</p>

<pre><code>✶          parse implicit input number
 u         range [0..n-1]
  [        map:
   Σ           convert to binary
    _✶         get digit list
      ¨^       fold with xor
</code></pre>

<p>Outputs something like:</p>

<pre><code>(0 1 1 0 1 0 0 1)
</code></pre>
</div>
<div id="pu18" class="pu"><h1>Ruby, 33</h1>
<pre><code>-&gt;n{n.times{|i|p (&quot;%b&quot;%i).sum%2}}
</code></pre>
<p>Call like this:</p>
<pre><code>f=-&gt;n{n.times{|i|p (&quot;%b&quot;%i).sum%2}}
f[16]
</code></pre>
<p>Uses the fact that the parity of binary numbers forms the thue-morse sequence.</p>
<p>Separator character is newline. Converts number <code>i</code> to a binary string, then calculates the sum of all ASCII codes, modulo 2.</p>
<p>If newline is not an acceptable separator, the following has no separator for an additional 2 bytes:</p>
<pre><code>-&gt;n{n.times{|i|$&gt;&lt;&lt;(&quot;%b&quot;%i).sum%2}}
</code></pre>
</div>
<div id="pu19" class="pu"><h1>Pyth, 6 bytes</h1>

<pre><code>xMjR2Q
</code></pre>

<p>Try it online: <a href="http://pyth.herokuapp.com/?code=xMjR2Q&amp;input=20&amp;debug=0" rel="noreferrer">Demonstration</a></p>

<p>Based on the solution from @ThomasKwa and a variation of @FryAmTheEggman. </p>

<p>It uses the following formular: the <code>i</code>-th digit in the Thue-Morse sequence is: <code>xor(digits of i in base 2)</code>. </p>

<h3>Explanation:</h3>

<pre><code>xMjR2Q   implicit: Q = input number
  jR2Q   convert each number in [0, 1, ..., Q-1] to its binary digits
xM       xor each binary list
</code></pre>
</div>
<div id="pu20" class="pu"><h2>Haskell, 54 bytes</h2>

<p>Less compact than nimi's solution, but I did not want to deny you this piece of functional code obfuscation. Works for any pair of objects; e.g. you can replace <code>(f 0.f 1)</code> by <code>(f 'A'.f 'B')</code>.</p>

<p>Based on the definition that the first 2<sup>n</sup> digits are followed by the same sequence of digits inverted.
What we do is build up two lists side-by-side; one for the sequence, one for the inverse. Continuously we append increasingly long parts of one list to the other.</p>

<p>The implementation consists of three definitions:</p>

<pre><code>t=(f 0.f 1)t
f c=flip take.(c:).g 1
g n l=l n++g(n+n)l
</code></pre>

<p>Function <code>t</code> accepts any number and returns the Thue-Morse sequence of that length. The other two functions are helpers.</p>

<ul>
<li>Function <code>f</code> represents either list; <code>f 0</code> is for the sequence, <code>f 1</code> for the inverse.</li>
<li>Function <code>g</code> takes care of appending increasingly long repetitions of one list to the other.</li>
</ul>

<p>Fiddle: <a href="http://goo.gl/wjk9S0" rel="nofollow">http://goo.gl/wjk9S0</a></p>
</div>
<div id="pu21" class="pu"><h2>ES6, 53 bytes</h2>

<pre><code>f=(i,x="0",y=1)=&gt;x.length&lt;i?f(i,x+y,y+x):x.slice(0,i)
</code></pre>

<p>Recursion seemed simpler than a loop.</p>
</div>
<div id="pu22" class="pu"><h2>Batch, 115 + 2 = 117 bytes</h2>

<p>Based on the Bash answer.</p>

<pre><code>@echo off
set x=0
set y=1
set z=0
:a
set x=!x!!y!
set y=!y!!z!
set z=!x:~0,%1!
if !z!==!x! goto a
echo !z!
</code></pre>

<p>Needs an extra <code>/V</code> in the invocation to allow the use of <code>!</code>s.</p>
</div>
<div id="pu23" class="pu"><h2>Bash, <strike>71</strike> 66 bytes</h2>

<p>Based on the definition that the first 2<sup>n</sup> digits are followed by the same sequence of digits inverted.</p>

<pre><code>x=0;y=1;while((${#x}&lt;$1));do z=$x;x=$x$y;y=$y$z;done;echo ${x::$1}
</code></pre>

<p><code>$1</code> as a parameter is the desired number of digits.</p>

<p>Fiddle: <a href="http://goo.gl/RkDZIC" rel="nofollow">http://goo.gl/RkDZIC</a></p>
</div>
<div id="pu24" class="pu"><h1>𝔼𝕊𝕄𝕚𝕟, 11 chars / 23 bytes (non-competitive)</h1>
<pre><code>Ⓐïⓜ_ⓑⓢĊ⇀$^_
</code></pre>
<p><kbd><a href="http://molarmanful.github.io/ESMin/interpreter.html?eval=true&amp;input=5&amp;code=%E2%92%B6%C3%AF%E2%93%9C_%E2%93%91%E2%93%A2%C4%8A%E2%87%80%24%5E_" rel="nofollow noreferrer">Try it here (Firefox only).</a></kbd></p>
<p>The circles are strong with this one.</p>
</div>
<div id="pu25" class="pu"><h2><a href="https://github.com/mbuettner/retina" rel="nofollow noreferrer">Retina</a>, <s>70</s> 69 bytes</h2>

<p>Using the definition as an L-system with initial word <code>0</code> and productions <code>0 --&gt; 01</code> and <code>1 --&gt; 10</code>.</p>

<pre><code>^
0;
(T`d`ab`^(.)+;(?!(?&lt;-1&gt;.)+$)
a
01
)`b
10
!`^(?=.*;(.)+)(?&lt;-1&gt;.)+
</code></pre>

<p>Input is taken <a href="https://codegolf.meta.stackexchange.com/questions/5343/can-numeric-input-output-be-in-unary">in unary</a>.</p>

<p>You can run the code from a single file with the <code>-s</code> flag. Or just <a href="http://retina.tryitonline.net/#code=XgphCihUYGFiYEFCYF4oXEQpKzEoPyEoPzwtMT4uKSskKQpBCmFiCilgQgpiYQohYF4oPz1cRCooLikrKSg_PC0xPi4pKw&amp;input=MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEx" rel="nofollow noreferrer">try it online.</a></p>

<h3>Explanation</h3>

<pre><code>^
0;
</code></pre>

<p>Prepends <code>0;</code> to the input, where <code>0</code> is the initial word and <code>;</code> is just a separator.</p>

<pre><code>(T`d`ab`^(.)+;(?!(?&lt;-1&gt;.)+$)
</code></pre>

<p>The <code>(</code> indicates that this is the beginning of a loop (which repeats until the loop stops changing the string). This stage itself turns <code>0</code> and <code>1</code> into <code>a</code> and <code>b</code> respectively (because <code>d</code> expands to <code>0-9</code>). It does this as long as current word (whose length is measured with <code>(.)+</code> is shorter than the input (i.e. as long as we can't read the end of the string by matching as many <code>1</code>s as we have in the word).</p>

<pre><code>a
01
</code></pre>

<p>Replace <code>a</code> (stand-in for <code>0</code>) with <code>01</code>.</p>

<pre><code>)`b
10
</code></pre>

<p>Replace <code>b</code> (stand-in for <code>1</code>) with <code>10</code>. This is also the end of the loop. The loop terminates once the condition in the transliteration stage fails, because then all <code>0</code>s and <code>1</code>s will remain unchanged and the other two stages won't find anything to match.</p>

<pre><code>!`^(?=.*;(.)+)(?&lt;-1&gt;.)+
</code></pre>

<p>The last step is to truncate the word to the length of the input. This time we measure the length of the input with <code>(.)+</code> in a lookahead. Then we match that many characters from the beginning of the string.</p>
</div>
<div id="pu26" class="pu"><h1>Prolog (SWI), 115 bytes</h1>
<p><strong>Code:</strong></p>
<pre><code>N*X:-N&gt;1,R is N//2,R*Y,X is(N mod 2)xor Y;X=N.
p(N):-M is N-1,findall(E,between(0,M,E),L),maplist(*,L,K),write(K).
</code></pre>
<p><strong>Explained:</strong></p>
<pre><code>N*X:-                                 % Calculate Thue-Morse number at index N
     N&gt;1,                             % Input is bigger than 1
     R is N//2,R*Y,X is(N mod 2)xor Y % Thue-Morse digit at index N is binary digits of N xor'ed
     ;X=N.                            % OR set X to N (end of recursion)
p(N):-
      M is N-1,                       % Get index of Nth number
      findall(E,between(0,M,E),L),    % Make a list of number 0-&gt;N-1
      maplist(*,L,K),                 % Map * on list L producing K
      write(K).                       % Print K
</code></pre>
<p><strong>Example:</strong></p>
<pre><code>p(20).
[0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1]
</code></pre>
<p>Try it online <a href="http://swish.swi-prolog.org/p/HhUAESEr.pl" rel="nofollow noreferrer">here</a></p>
</div>
<div id="pu27" class="pu"><h1>Perl 5, <s>62</s> 49 bytes</h1>

<p>Yeah, not the best language for this one, but I still like the way it came out. Requires 5.14+ for <code>/r</code> and <code>say</code>.</p>

<pre><code>sub{$_=0;$_.=y/01/10/r while$_[0]&gt;length;say substr$_,0,$_[0]}
</code></pre>

<p>Using the parity definition, requires 5.12+ for <code>say</code>:</p>

<pre><code>sub{say map{sprintf("%b",$_)=~y/1//%2}0..$_[0]-1}
</code></pre>
</div>
<div id="pu28" class="pu"><h1>Mathematica, <s>35</s> 21 bytes</h1>

<p>Mathematica has a built-in for the Thue-Morse sequence!</p>

<pre><code>Array[ThueMorse,#,0]&amp;
</code></pre>

<hr>

<p>Original answer:</p>

<pre><code>#&amp;@@@DigitCount[Range@#-1,2]~Mod~2&amp;
</code></pre>
</div>
<div id="pu29" class="pu"><h1>Octave, <s>33</s> 31 bytes</h1>

<p>Saved 2 bytes thanks to Thomas Kwa.</p>

<pre><code>@(n)mod(sum(dec2bin(0:n-1)'),2)
</code></pre>
</div>
<div id="pu30" class="pu"><h2>Dyalog APL, <s>8</s> 7 bytes</h2>
<pre><code>≠⌿⍴∘2⊤⍳
</code></pre>
<p>This is a monadic train that expects an index origin of 0 (<code>⎕IO←0</code>). The equivalent non-train function is <code>{≠⌿(⍵⍴2)⊤⍳⍵}</code>.</p>
<p>Explanation:</p>
<pre><code>      ⍳      List of numbers from 0 to (input-1)
  ⍴∘2        (input) copies of 2
     ⊤       Convert all the elements in ⍳ to base 2 to (input) digits
≠⌿           Reduce over the first axis by not-equal
</code></pre>
<p>Output is a space-separated list of <code>0</code> and <code>1</code>. Try it <a href="http://tryapl.org/?a=%u2395IO%u21900%u22C4%28%u2260%u233F%u2374%u22182%u22A4%u2373%29%A80%201%202%203%205%208%2013&amp;run" rel="nofollow noreferrer">here</a>.</p>
</div>
<div id="pu31" class="pu"><h1><a href="https://github.com/ETHproductions/Japt" rel="nofollow noreferrer">Japt</a>, <s>29</s> 11 <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>Uo ®¤¬r@X^Y
</code></pre>
<p><a href="http://ethproductions.github.io/japt?v=master&amp;code=VW8grqSsckBYXlk=&amp;input=NDI=" rel="nofollow noreferrer">Try it online!</a></p>
<p>Outputs directly as an array, which saves about 4 bytes.</p>
<h3>Ungolfed and explanation</h3>
<pre><code>Uo ®   ¤  ¬ r@  X^Y
Uo mZ{Zs2 q rXY{X^Y}}
        // Implicit: U = input number
Uo      // Create an array of integers in the range `[0, U)`. 
mZ{Zs2  // Map each item Z in this range to Z.toString(2),
q rXY{  //  split into chars, and reduced by
X^Y}}   //   XORing.
        //  This returns (number of 1s in the binary string) % 2.
        // Implicit: output last expression
</code></pre>
<p><strong>Edit:</strong> You can now use the following <strong>8-byte</strong> code (not valid; feature published after this challenge):</p>
<pre><code>Uo ®¤¬r^
</code></pre>
</div>
<div id="pu32" class="pu"><h1>LabVIEW, 15 <a href="http://meta.codegolf.stackexchange.com/a/7589/39490">LabVIEW Primitives</a></h1>

<p>now as super fancy gif with a probe</p>

<p><a href="https://i.sstatic.net/nRHM4.gif" rel="noreferrer"><img src="https://i.sstatic.net/nRHM4.gif" alt="enter image description here"></a></p>
</div>
<div id="pu33" class="pu"><h1>K5, <s>27</s> 13 bytes</h1>

<pre><code>{x#((log x)%log 2){x,~x}/0}
</code></pre>

<p>Calculating the sequence is pretty easy, the problem is avoiding computing too much. We can recognize that the easy expansion of the sequence gives us a sequence of strings which are successive powers of two in length. Taking the log base 2 of the input and rounding up will give us enough to work with and then we can cut it down to the appropriate size:</p>

<pre><code>  {x#((log x)%log 2){x,~x}/0}'(20 42 37 12 0)
(0 1 1 0 1 0 0 1 1 0 0 1 0 1 1 0 1 0 0 1
 0 1 1 0 1 0 0 1 1 0 0 1 0 1 1 0 1 0 0 1 0 1 1 0 0 1 1 0 1 0 0 1 1 0 0 1 0 1 1 0 0 1
 0 1 1 0 1 0 0 1 1 0 0 1 0 1 1 0 1 0 0 1 0 1 1 0 0 1 1 0 1 0 0 1 1 0 0 1 0
 0 1 1 0 1 0 0 1 1 0 0 1
 ())
</code></pre>

<h2>Edit:</h2>

<p>A parity-based solution:</p>

<pre><code>~=/'(64#2)\'!
</code></pre>

<p>In action:</p>

<pre><code>  ~=/'(64#2)\'!20
0 1 1 0 1 0 0 1 1 0 0 1 0 1 1 0 1 0 0 1
</code></pre>

<p>Note that since K5 doesn't have an arbitrary convert-to-binary primitive I have to specify, for example, a 64-bit decoding. K5 doesn't use arbitrary precision math, so there will be a limit to the size of inputs we can deal with in any case.</p>
</div>
<div id="pu34" class="pu"><h1>Matlab, 42</h1>
<p>I am using the fact that it is the same as beginning with <code>0</code> and then repeating the step of appending the complement of the current series, <code>n</code> times.</p>
<pre><code>t=0;for k=1:input('');t=[t;~t];end;disp(t)
</code></pre>
</div>
<div id="pu35" class="pu"><h2>Pyth, <s>11</s> 10 bytes</h2>
<pre><code>m%ssM.Bd2Q
</code></pre>
<p>Outputs as a Python-style list.</p>
</div>
<div id="pu36" class="pu"><h2>Burlesque, 21 bytes</h2>

<pre><code>{0}{J)n!_+}400E!jri.+
</code></pre>

<p>Examples:</p>

<pre><code>blsq ) "20"{0}{J)n!_+}400E!jri.+
{0 1 1 0 1 0 0 1 1 0 0 1 0 1 1 0 1 0 0 1}
blsq ) "42"{0}{J)n!_+}400E!jri.+
{0 1 1 0 1 0 0 1 1 0 0 1 0 1 1 0 1 0 0 1 0 1 1 0 0 1 1 0 1 0 0 1 1 0 0 1 0 1 1 0 0 1}
</code></pre>

<p>Explanation:</p>

<pre><code>{0}      -- setup
{J)n!_+} -- duplicate, map invert, concatenate
400E!    -- do 400 times (this will eventually run
            out of memory).
jri.+    -- take n elements
</code></pre>

<p>Without the <code>jri.+</code> part you will run out of memory (because it will compute the morse sequence of length <em>incredibly huge number</em>). But since Burlesque is lazy just asking for the first n-element will work anyway. </p>
</div>
<div id="pu37" class="pu"><h2>CJam, <s>17</s> 9 bytes</h2>

<pre><code>ri{2b:^}/
</code></pre>

<p>or</p>

<pre><code>ri,2fb::^
</code></pre>

<p><a href="http://cjam.aditsu.net/#code=q~%7B2b%3A%5E%7D%2F&amp;input=42">Test it here.</a></p>

<h3>Explanation</h3>

<p>This uses the alternative definition given on Wikipedia, based on the parity of the number of <code>1</code>s in the binary representation of the <code>n</code>.</p>

<pre><code>ri   e# Read input and convert to integer n.
{    e# For each i from 0 to n-1...
  2b e#   Convert i to base 2.
  :^ e#   Fold XOR over the bits to compute the parity of the number of 1s.
}/
</code></pre>

<p>The alternative solution uses <code>,</code> to turn <code>n</code> explicitly into a range <code>[0 ... n-1]</code> before using infix operators to compute the binary representations and the XOR without needing a block.</p>

<h3>Bonus Solutions</h3>

<p>Here are some solutions based on other definitions. If there are two solutions, the shorter one will blow up memory <em>very</em> quickly (because the precomputation generates <code>2^n</code> bits before truncating to <code>n</code>).</p>

<p>As an L-system with <code>0 --&gt; 01</code> and <code>1 --&gt; 10</code>:</p>

<pre><code>ri_2mL2,\{2,aA+f=s:~}*&lt;
ri_2,\{2,aA+f=s:~}*&lt;
</code></pre>

<p>By negating and appending the previous part:</p>

<pre><code>ri_2mL2,\{_:!+}*&lt;
ri_2,\{_:!+}*&lt;
</code></pre>

<p>Using the recurrence relation given in the challenge, using <code>divmod</code> and XOR to distinguish between the two recursive definitions:</p>

<pre><code>ri{Ta{2md\j^}j}/
</code></pre>

<p>(Although, of course, this recurrence relation is just a different way to express the Thue-Morse sequence as the parity of the 1-bits in the binary representation of <code>n</code>.)</p>
</div>
<div id="pu38" class="pu"><h2>J, <s>12</s> 11 bytes</h2>

<p>@MartinBüttner saved a byte.</p>

<pre><code>~:/@#:"0@i.
</code></pre>

<p>This is a monadic (meaning unary) function, used as follows:</p>

<pre><code>   f =: ~:/@#:"0@i.
   f 10
0 1 1 0 1 0 0 1 1 0
</code></pre>

<h2>Explanation</h2>

<p>I'm using the alternative definition that T<sub>n</sub> is the parity of the number of 1-bits in the binary representation of n.</p>

<pre><code>~:/@#:"0@i.  Input is n.
~:/          Output is XOR folded over
   @#:       the binary representations of
      "0     each element of
        @i.  integers from 0 to n-1.
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/65549/">65549</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




