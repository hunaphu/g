<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::59934</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>010</td><td>Vyxal j</td><td>210725T091229Z</td><td><a href="https://codegolf.stackexchange.com/questions/59934/print-out-all-ipv6-addresses/231755#231755">emanresu</a></td></tr>
<tr d-ix="1"><td>099</td><td>Tcl</td><td>250506T151431Z</td><td><a href="https://codegolf.stackexchange.com/questions/59934/print-out-all-ipv6-addresses/279544#279544">sergiol</a></td></tr>
<tr d-ix="2"><td>049</td><td>Ruby</td><td>250506T153213Z</td><td><a href="https://codegolf.stackexchange.com/questions/59934/print-out-all-ipv6-addresses/279545#279545">Jordan</a></td></tr>
<tr d-ix="3"><td>nan</td><td>Go</td><td>240122T212151Z</td><td><a href="https://codegolf.stackexchange.com/questions/59934/print-out-all-ipv6-addresses/269485#269485">bigyihsu</a></td></tr>
<tr d-ix="4"><td>060</td><td>Zsh P</td><td>240121T175822Z</td><td><a href="https://codegolf.stackexchange.com/questions/59934/print-out-all-ipv6-addresses/269441#269441">pxeger</a></td></tr>
<tr d-ix="5"><td>024</td><td>Regenerate a</td><td>220703T000519Z</td><td><a href="https://codegolf.stackexchange.com/questions/59934/print-out-all-ipv6-addresses/249457#249457">Deadcode</a></td></tr>
<tr d-ix="6"><td>016</td><td>Cinnamon Gum</td><td>160406T170026Z</td><td><a href="https://codegolf.stackexchange.com/questions/59934/print-out-all-ipv6-addresses/77240#77240">a spaghe</a></td></tr>
<tr d-ix="7"><td>nan</td><td>Python 3</td><td>151007T081559Z</td><td><a href="https://codegolf.stackexchange.com/questions/59934/print-out-all-ipv6-addresses/59936#59936">Anders K</a></td></tr>
<tr d-ix="8"><td>103</td><td>PowerShell v4</td><td>151008T010213Z</td><td><a href="https://codegolf.stackexchange.com/questions/59934/print-out-all-ipv6-addresses/60056#60056">Tessella</a></td></tr>
<tr d-ix="9"><td>075</td><td>Ruby</td><td>151007T152305Z</td><td><a href="https://codegolf.stackexchange.com/questions/59934/print-out-all-ipv6-addresses/59979#59979">MegaTom</a></td></tr>
<tr d-ix="10"><td>166</td><td>CBM BASIC v7.0</td><td>151016T150811Z</td><td><a href="https://codegolf.stackexchange.com/questions/59934/print-out-all-ipv6-addresses/61007#61007">Psychona</a></td></tr>
<tr d-ix="11"><td>301</td><td>Tcl 341 318</td><td>151016T174126Z</td><td><a href="https://codegolf.stackexchange.com/questions/59934/print-out-all-ipv6-addresses/61027#61027">wolfhamm</a></td></tr>
<tr d-ix="12"><td>339</td><td>Commodore BASIC 2.0</td><td>151010T205843Z</td><td><a href="https://codegolf.stackexchange.com/questions/59934/print-out-all-ipv6-addresses/60318#60318">Mark</a></td></tr>
<tr d-ix="13"><td>231</td><td>AutoIt3</td><td>151007T105400Z</td><td><a href="https://codegolf.stackexchange.com/questions/59934/print-out-all-ipv6-addresses/59951#59951">GiantTre</a></td></tr>
<tr d-ix="14"><td>111</td><td>Haskell</td><td>151009T141603Z</td><td><a href="https://codegolf.stackexchange.com/questions/59934/print-out-all-ipv6-addresses/60184#60184">Franky</a></td></tr>
<tr d-ix="15"><td>095</td><td>Python 2</td><td>151007T230838Z</td><td><a href="https://codegolf.stackexchange.com/questions/59934/print-out-all-ipv6-addresses/60047#60047">Status</a></td></tr>
<tr d-ix="16"><td>024</td><td>Pyth</td><td>151007T084229Z</td><td><a href="https://codegolf.stackexchange.com/questions/59934/print-out-all-ipv6-addresses/59937#59937">PurkkaKo</a></td></tr>
<tr d-ix="17"><td>021</td><td>Pyth</td><td>151008T173926Z</td><td><a href="https://codegolf.stackexchange.com/questions/59934/print-out-all-ipv6-addresses/60096#60096">izzyg</a></td></tr>
<tr d-ix="18"><td>nan</td><td>C</td><td>151007T153927Z</td><td><a href="https://codegolf.stackexchange.com/questions/59934/print-out-all-ipv6-addresses/59980#59980">Random83</a></td></tr>
<tr d-ix="19"><td>067</td><td>Python 2.7</td><td>151008T130206Z</td><td><a href="https://codegolf.stackexchange.com/questions/59934/print-out-all-ipv6-addresses/60084#60084">xsot</a></td></tr>
<tr d-ix="20"><td>335</td><td>Verilog</td><td>151007T235936Z</td><td><a href="https://codegolf.stackexchange.com/questions/59934/print-out-all-ipv6-addresses/60054#60054">nanofara</a></td></tr>
<tr d-ix="21"><td>137</td><td>AutoIt3</td><td>151007T224904Z</td><td><a href="https://codegolf.stackexchange.com/questions/59934/print-out-all-ipv6-addresses/60045#60045">rav_kr</a></td></tr>
<tr d-ix="22"><td>027</td><td>CJam</td><td>151007T084932Z</td><td><a href="https://codegolf.stackexchange.com/questions/59934/print-out-all-ipv6-addresses/59940#59940">Sp3000</a></td></tr>
<tr d-ix="23"><td>nan</td><td>C with GCC extensions</td><td>151007T180323Z</td><td><a href="https://codegolf.stackexchange.com/questions/59934/print-out-all-ipv6-addresses/59996#59996">Digital </a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal/tree/version-2" rel="nofollow noreferrer">Vyxal</a> <code>j</code>, 10 bytes</h1>
<pre><code>k64↔8↔\:vj
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/?v=2&amp;c=1#WyJqIiwiIiwiazY04oaUOOKGlFxcOnZqIiwiIiwiIl0=" rel="nofollow noreferrer">Try it Online!</a></p>
<p>So, unlike most of the other answers here, this doesn't iterate from 1 to 2^128 and print the corresponding IP address for that number. Most other answers do this due to the challenge disallowing constructing the list of all IP addresses in memory, but in Vyxal we can do so anyway!</p>
<p>This is due to lists in Vyxal being inherently lazy: they will only generate items when they need to. For example, when I tell Vyxal to generate all 8-length combinations of 4-digit hexadecimal strings, what it's actually doing is not constructing the full list in memory, but creating an iterator that will eventually yield every combination.</p>
<p>The <code>j</code> flag formats the outputted list of lines - it's actually necessary to do this so that the output doesn't get concatenated into a massive string in memory.</p>
<pre><code>    8↔     # All combinations, of length 8, of
  4↔       # combinations of length 4 of
k6         # hexadecimal digits - &quot;0123456789abcdef&quot;
      \:vj # each joined by colons
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="http://tcl.tk/" rel="nofollow noreferrer">Tcl</a>, 99 bytes</h1>
<pre><code>set i 0
while $i&lt;[expr 4**64] {puts [string trim [regsub -all .{4} [format %032x $i] :&amp;] :]
incr i}
</code></pre>
<p><a href="https://tio.run/##Dcw7CoUwEEbh3lX8hVoIXkSDhbiTkEIl6kB8MBm5grj2mOJ85ZHJheCtgFAl/5WcRUq9tvfJUEXRKoPnvMRDe2HaF0Q3aLaLv0aUg3P4PeqFng/eBkFWNfUdFwZdHjMJ7ROD3hA@" rel="nofollow noreferrer" title="Tcl – Try It Online">Try it online!</a></p>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, 49 bytes</h1>
<p><code>p</code> would be shorter than <code>puts</code> but I don't like the extraneous quotation marks.</p>
<pre class="lang-ruby prettyprint-override"><code>(2**128).times{puts (&quot;%032x&quot;%_1).scan(/..../)*?:}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m72kqDSpcsGCpaUlaboWNw01jLS0DI0sNPVKMnNTi6sLSkuKFTSUVA2MjSqUVOMNNfWKkxPzNPT1gEBfU8veqhaiEaofZg4A" rel="nofollow noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu3" class="pu"><h1><a href="https://go.dev" rel="nofollow noreferrer">Go</a>, <span class="math-container">\$243 \times 0.8 = \$</span> 194.4 bytes</h1>
<pre class="lang-go prettyprint-override"><code>import(.&quot;fmt&quot;;.&quot;net/netip&quot;)
func F(){for a,M:=0,1&lt;&lt;32-1;a&lt;M;a++{for b:=0;b&lt;M;b++{for c:=0;c&lt;M;c++{for d:=0;d&lt;M;d++{s:=&quot;&quot;
for n,k:=0,Sprintf(&quot;%08x%08x%08x%08x&quot;,a,b,c,d);n&lt;8;n++{s+=k[4*n:4*(n+1)]+&quot;:&quot;}
A,_:=ParseAddr(s[:len(s)-1])
Println(A)}}}}}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=TdAxasMwFAbgXacwgoAUyWncZjCSPXjpFgh0DKHIkhWM42djKxAoOUkXU-jWqbfpOXqBSomHCh6C70cPfr1_HLvpq1e6UccqalUNn2dn4_Tnt277bnBkhW3rsFxhqNyDn7rHFNkz6OiZ0DfbDZHiW5GveZJlT49xIlW2lYqxW1T6QJYeyhl0AO1Bz2ACGA_GwyhyjFFg4E3Y-dIPNThL8GKdXv4P5oqXXHNDJWSphPCY5c1-swSxWRJgCT0wLPAVFfxV5Ds1jFVhzEDGvThVQEYaJweKdmH9CUhBr-Hcq3_f2oWv8AWRb4nmYJru9x8" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Prints to STDOUT. Uses the <code>netip.Addr</code> type from the Golang standard library to do the formatting for me.</p>
<h3>Explanation</h3>
<pre class="lang-go prettyprint-override"><code>import(.&quot;fmt&quot;;.&quot;net/netip&quot;)
func F(){
for a,M:=0,1&lt;&lt;32-1;a&lt;M;a++{ // first 8 digits
for b:=0;b&lt;M;b++{           // next  8 digits
for c:=0;c&lt;M;c++{           // next  8 digits
for d:=0;d&lt;M;d++{           // final 8 digits
k:=Sprintf(&quot;%08x%08x%08x%08x&quot;,a,b,c,d)  // join the numbers into a single string
s:=&quot;&quot;
for n:=0;n&lt;8;n++{s+=k[4*n:4*(n+1)]+&quot;:&quot;} // split into 8 groups of 4, split by colons
A,_:=ParseAddr(s[:len(s)-1])            // parse the address
Println(A)}}}}}                         // print using the default String() method, which formats the address
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://www.zsh.org/" rel="nofollow noreferrer">Zsh</a> <code>-P</code>, 60 bytes</h1>
<pre class="lang-bash prettyprint-override"><code>x=({0..9} {a..f})
eval for\ {1..8}' ($x$x$x$x)&lt;&lt;&lt;${(j/:/)@}'
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m724qjhjWbSSboBS7IKlpSVpuhY3bSpsNaoN9PQsaxWqE_X00mo1uVLLEnMU0vKLYhSqDfX0LGrVFTRUKiBQ08bGRqVaI0vfSl_ToVYdYgbUqAVQGgA" rel="nofollow noreferrer">Attempt This Online!</a> (Warning: if you don't click the kill button fairly quickly, your browser will run out of memory and crash)</p>
<p><code>eval for\ {1..8}</code> creates 8 nested loops using the loop variables <code>$1</code>, <code>$2</code>, ..., <code>$8</code>. These numbered variables can then be referred to implicitly using <code>$@</code> (here, they're joined with colons using <code>${(j/:/)}</code>).</p>
<p>The <code>&lt;&lt;&lt;${...}</code> section is actually repeated for each level of nested loop as well, but (apart from the last one) they all do nothing, because they feed into the next loop, which ignores its input.</p>
<p>The <code>-P</code> option enables an implicit cartesian product on the adjacent expansions <code>$x$x$x$x</code>. This is the shortest way I could find to count up to <code>0xffff</code> <em>in hex</em> without needing to convert each loop variable to hex individually.</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/dloscutoff/Esolangs/tree/master/Regenerate" rel="nofollow noreferrer">Regenerate</a> <code>-a</code>, 24 bytes</h1>
<pre><code>(($3:!)[0-9a-f]{4}()){8}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m72qKDU9NS-1KLEkdVm0km6iUuyCpaUlaboWOzQ0VIytFDWjDXQtE3XTYqtNajU0NastaiHSUFULoDQA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<pre><code>(
    # Match &quot;:&quot; iff we're not on the first iteration
    (
        $3        # Match iff we're not on the first iteration
        :         # Match &quot;:&quot;
    !             # Short-circuiting alternation - only try matching the below
                  # if it was impossible for the above to match.
                  # Do nothing
    )
    [0-9a-f]{4}   # Match 4 hexadecimal digits
    ()            # $3 = signal that we're not on the first iteration anymore
)
{8}               # Repeat the above 8 times
</code></pre>
<p>Alternative 24 bytes:</p>
<pre><code>(({#1}:!)[0-9a-f]{4}){8}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m72qKDU9NS-1KLEkdVm0km6iUuyCpaUlaboWOzQ0qpUNa60UNaMNdC0TddNiq01qNastaiHSUFULoDQA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>It might not be intended that this is possible, but Regenerate allows a quantifier to be preceded by nothing. This is what's happening with <code>{#1}</code> - it's impossible for it to match on the first iteration because <code>$1</code> hasn't been captured yet and doesn't have a length. On subsequent iterations, a match of nothing gets repeated 4 times (the length of <code>$1</code>).</p>
</div>
<div id="pu6" class="pu"><h1>Cinnamon Gum, 16 bytes</h1>
<pre><code>0000000: 678b 36d0 b54c d44d 8bc5 455b 8d0c 0500  g.6..L.M..E[....                               .
</code></pre>
<p><a href="http://cinnamon-gum.tryitonline.net/#code=MDAwMDAwMDogNjc4YiAzNmQwIGI1NGMgZDQ0ZCA4YmM1IDQ1NWIgOGQwYyAwNTAwICBnLjYuLkwuTS4uRVsuLi4uCg&amp;input=" rel="nofollow noreferrer">Try it online. (TIO limits output)</a></p>
<h2>Explanation</h2>
<p>The <code>g</code> mode puts Cinnamon Gum in <em>generate mode</em>. The rest of the string decompresses to this regex:</p>
<pre><code>[0-9a-f][0-9a-f][0-9a-f][0-9a-f]:[0-9a-f][0-9a-f][0-9a-f][0-9a-f]:[0-9a-f][0-9a-f][0-9a-f][0-9a-f]:[0-9a-f][0-9a-f][0-9a-f][0-9a-f]:[0-9a-f][0-9a-f][0-9a-f][0-9a-f]:[0-9a-f][0-9a-f][0-9a-f][0-9a-f]:[0-9a-f][0-9a-f][0-9a-f][0-9a-f]:[0-9a-f][0-9a-f][0-9a-f][0-9a-f]
</code></pre>
<p>It then creates a generator of all possible strings that match the regex and iterates through it, printing out each one.</p>
<p>Somewhat amusingly, the golfier regex <code>([0-9a-f]{4,4}:){7,7}[0-9a-f]{4,4}</code> actually compresses to a longer string than the regex above.</p>
</div>
<div id="pu7" class="pu"><h1>Python 3, 65 bytes · 0.8 = 52.0</h1>

<pre><code>from ipaddress import*
n=4**64
while n:n-=1;print(IPv6Address(n))
</code></pre>
</div>
<div id="pu8" class="pu"><h3>PowerShell (v4), <strike>193 166 162 145</strike> 103 bytes</h3>

<p>TimmyD's no-bonus version at 103 bytes:</p>
<pre class="lang-powershell prettyprint-override"><code>$i=[bigint]::Pow(4,64);while($i-gt0){('{0:X32}'-f($i-=1)-replace'0(?=.{32})'-re‌​place'.{4}(?!$)','$0:')}
</code></pre>
<hr />
<p>Previous with-bonus version at 145 * 0.8 = 116 bytes</p>
<p>With help from <a href="https://codegolf.stackexchange.com/users/42963/timmyd">TimmyD</a> and <a href="https://codegolf.stackexchange.com/users/25181/tomkandy">tomkandy</a>, who points out that <code>0 -eq $false</code> but <code>([bigint]0) -eq $true</code>. So all my previous versions won't terminate.</p>
<pre class="lang-powershell prettyprint-override"><code>$i=[bigint]::Pow(4,64);while($i-gt0){$i-=1;[IPAddress]::Parse((('{0:X32}'-f$i
)-replace'0(?=.{32})'-replace'.{4}(?!$)','$0:')).IPAddressToString}
</code></pre>
<hr />
<p>Previously at 162, before some regex changes:</p>
<pre class="lang-powershell prettyprint-override"><code>$i=[bigint]::Pow(4,64)
while($i){$i-=1;if(($x='{0:X32}'-f$i).Length-eq33){$x=$x.Substring(1)}
[IPAddress]::Parse(($x-replace'.{4}(?!$)','$0:')).IPAddressToString}
</code></pre>
<p><em>&quot;A challenge where PowerShell ought to be reasonably competetive!&quot;</em> - me, before I tried it.</p>
<p><strong>Explanation</strong></p>
<pre class="lang-powershell prettyprint-override"><code># PowerShell (PS) has no IP address arithmetic, e.g. IP + 1
#- PS has no 128 bit integers
#- PS has no automatic bignums

# Start from the top, with the BigInteger specialised Power()
$i = [BigInt]::pow(4,64)

# Loop 4**64 through 1, work with $i-1 for ff... -&gt; ::0
while ($i) {
    # PS has no decrement operator for bignums
    # (no using $i-- in the while loop test)
    $i-=1

    # The Net.IPAddress class can't turn a BigInteger
    # into an IPv6 address directly. And because it mashes
    # IPv4 and IPv6 into one class, there's no obvious way 
    # to make a small number always cast to an IPv6 address.
    # Format the bignum as a string of 32 hex digits.
    $x = '{0:X32}' -f $i

    # The BigInteger often formats as /33/ hex digits, 
    # with a leading zero (to avoid unintentional +/- sign bits)
    # ( https://msdn.microsoft.com/library/dd268287 )
    # So remove the leading 0, if there is one
    if (($x).Length-eq33){$x=$x.Substring(1)}

    # I can't always remove the leading zero, because it 
    # can't parse FFFFF... into an address without colons
    # and this regex replace into groups of 4 with colons
    # would go wrong at length 31. No : after the last group
    # This is still better than split/join ... because there
    # isn't a split-into-groups-of-N that I know of.
    $x = ($x -replace '.{4}(?!$)', '$1:'
   
    # Woo! * 0.8 bonus! 45 characters to save 38! :D
    [IPAddress]::Parse($x).IPAddressToString

}
</code></pre>
</div>
<div id="pu9" class="pu"><h1>Ruby 75</h1>
<pre><code>x=-&gt;s,n{n&gt;0?65536.times{|m|x.(s+?:*(8&lt;=&gt;n)+m.to_s(16),n-1)}: p(s)};x.('',8)
</code></pre>
<p>This is a recursive solution that takes a each prefix and finds every possible suffix. Recursively.</p>
</div>
<div id="pu10" class="pu"><h1>CBM BASIC v7.0 (166 characters)</h1>

<pre><code>a=65535
fOi=0toa:fOj=0toa:fOk=0toa:fOl=0toa:fOm=0toa:fOn=0toa:fOo=0toa:fOp=0toa:?hE(i)":"hE(j)":"hE(k)":"hE(l)":"hE(m)":"hE(n)":"hE(o)":"hE(p):nE:nE:nE:nE:nE:nE:nE:nE
</code></pre>

<p><a href="https://codegolf.stackexchange.com/a/60318/46220">Mark's answer</a> is for the Commodore 64's BASIC 2.0, which lacks a built-in command for printing numbers in hexadecimal.  However, thanks to the <code>HEX$()</code> function in BASIC 7.0, the Commodore 128 version is much shorter.  It doesn't fit on a single logical line (which on the C128 is limited to 160 characters) but can still be entered as two separate lines in direct mode.</p>
</div>
<div id="pu11" class="pu"><h2>Tcl <del>341</del> <del>318</del> 301</h2>

<pre><code>proc ip6 {p c} {
    set s %x:%x:%x:%x:%x:%x:%x:%x
    set p [scan $p $s]
    while {[set d 7]} {
        $c [format [string map {x 04x} $s] {*}$p]
        while {[set i [lindex $p $d]]==0xFFFF} {
            lset p $d 0
            if {!$d} return
            incr d -1
        }
        lset p $d [incr i]
    }
}
ip6 fFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:0000 puts
</code></pre>
</div>
<div id="pu12" class="pu"><h1>Commodore BASIC 2.0, 339 bytes</h1>

<p>In order to get lower-case hex digits, this program is written in "shifted mode" (press <code>&lt;SHIFT&gt;+&lt;C=&gt;</code>)</p>

<pre><code>1k=65535:a=0
2fOb=0tok:fOc=0tok:fOd=0tok:fOe=0tok:fOf=0tok:fOg=0tok:fOh=0tok
3x=a:goS6:?":";:x=b:goS6:?":";:x=c:goS6:?":";:x=d:goS6:?":";:x=e:goS6:?":";:x=f
4goS6:?":";:x=g:goS6:?":";:x=h:goS6:?
5nE:nE:nE:nE:nE:nE:nE:nE:a=a+1:ifa&lt;65536tH2
6y=x/4096:goS7:y=x/256aN15:goS7:y=x/16aN15:goS7:y=xaN15:goS7:reT
7?mI("0123456789abcdef",y+1,1);:reT
</code></pre>

<p>Simply making this <em>work</em> on the Commodore 64 was a challenge, because of memory, screen size, data size, and other limitations.  I considered implementing the abbreviated representation, but other limitations (such as the undocumented inability to use array elements as loop indices) meant it would increase the length of the program by an estimated 1000 bytes.</p>

<p>Line 7 is an implementation of <code>HEX$()</code>, which Commodore BASIC 2.0 is lacking.  I can't use a <code>DEF FN</code> for this because those can only return numbers, not strings.  Line 6 is a subroutine that applies it to a group of four digits, which would have been considerably shorter if functions could return strings.</p>

<p>Lines 2 and 5 are eight nested loops, implemented as seven "for" loops and a conditional goto because eight "for" loops, when combined with the two "gosubs" for printing out the address, will overflow the C64's tiny stack.</p>

<p>A C64 can print out about 1.2 addresses per second, for an estimated runtime of 1.3*10^31 years.</p>
</div>
<div id="pu13" class="pu"><h1>AutoIt3, <s>142</s> 231 Bytes</h1>

<pre><code>For $a=0 To 2^32-1
For $b=0 To 2^32-1
For $c=0 To 2^32-1
For $d=0 To 2^32-1
$s=StringFormat("%08x%08x%08x%08x",$a,$b,$c,$d)
For $j=0 To 8
ConsoleWrite(StringMid($s,$j*4+1,4)&amp;($j&lt;7?":":""))
Next
ConsoleWrite(@LF)
Next
Next
Next
Next
</code></pre>

<h2>Explanation</h2>

<ul>
<li><code>For $a=0 To 2^32-1</code>: Iterate 4 times over 0-2^32 ((2^32)^4=2^128) possible combinations.</li>
<li><code>$s=StringFormat("%08x%08x%08x%08x",$a,$b,$c,$d)</code>: Convert the numbers to a hexadecimal string with a length of 32 (4*32).</li>
<li><code>For $j=0 To 8</code>: Iterate over all 8 sections of the string.</li>
<li><code>ConsoleWrite(StringMid($s,$j*4+1,4)&amp;($j&lt;7?":":""))</code>: Extract the next 4 characters from the string and add a colon (<code>:</code>) at the end, if we haven't reached the last section, then output everything to the console</li>
<li><code>Next</code>: End the inner for-loop</li>
<li><code>ConsoleWrite(@LF)</code>: Add a line-feed at the end of the line</li>
<li><code>Next</code>: End the outer for-loops</li>
</ul>

<p>Expected output size: (One line (39 bytes) + line-feed) (=40 bytes) * 2^128 = 1.361* 10^16 YB  (yottabytes)</p>
</div>
<div id="pu14" class="pu"><h1>Haskell 111</h1>
<pre><code>s[]=[[]]
s(a:b)=[y:z|z&lt;-s b,y&lt;-a]
r=replicate
main=mapM putStrLn$s$tail$concat$r 8$&quot;:&quot;:r 4&quot;0123456789abcdef&quot;
</code></pre>
<p>With my own sequence function <code>s</code> it no longer leaks memory, but does not feel golfed any more.</p>
</div>
<div id="pu15" class="pu"><h1>Python 2, 95 bytes</h1>
<pre><code>def i(p=0):
 while p&lt;4**64:print':'.join(hex(p)[2:].zfill(32)[4*s:4*s+4]for s in range(8));p+=1
</code></pre>
<p>Simply goes through every number from 0 to 2^128. First it converts the current number to hexadecimal string, then strips off the <code>'0x'</code> that that function gives. Next it adjusts the string to have 32 zeros in the front and then breaks it up into groups of four. Finally it joins the groups of four with colons, prints that out and adds 1 to the current number. Has the added bonus that you can start it at any value if you give it one, but no input is needed.</p>
</div>
<div id="pu16" class="pu"><h1>Pyth, <s>27</s> <s>25</s> 24 bytes</h1>

<p><em>Note: the code had a bug previously, fixing it saved 1 byte</em></p>

<pre><code>J^4 64WJj\:c%"%032x"=tJ4
</code></pre>

<p>Prints the addresses like</p>

<pre><code>ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff
ffff:ffff:ffff:ffff:ffff:ffff:ffff:fffe
ffff:ffff:ffff:ffff:ffff:ffff:ffff:fffd
ffff:ffff:ffff:ffff:ffff:ffff:ffff:fffc
...
0000:0000:0000:0000:0000:0000:0000:0003
0000:0000:0000:0000:0000:0000:0000:0002
0000:0000:0000:0000:0000:0000:0000:0001
0000:0000:0000:0000:0000:0000:0000:0000
</code></pre>

<p>Previous (more complicated) version using the pad operator (also 24 bytes):</p>

<pre><code>J^4 64WJj\:c.[\032.H=tJ4
</code></pre>

<h3>Explanation</h3>

<pre><code>J^4 64                  set J to 2^128
WJ                     while J is not 0:
            =tJ               decrement J
    %"%032x"                 format to length-32 hex string
   c           4            split every 4 chars
j\:                        join by : and print
</code></pre>

<h2>Pyth, 21 bytes (invalid)</h2>

<pre><code>jmj\:c.[\032.Hd4^4 64
</code></pre>

<p>This can't be run since 1) it would consume at least 2<sup>132</sup> bytes (2<sup>52</sup> yobibytes) of memory and 2) the interpreter doesn't like it (2<sup>128</sup> doesn't fit in <code>ssize_t</code>, so no <code>list</code>s of that size). It would print the addresses in lexicographical order. You can try out the algorithm by changing the number(s) in the end to something usable.</p>
</div>
<div id="pu17" class="pu"><h1>Pyth, 21 bytes</h1>

<pre><code>KJ^8CdWJj\:ct.H+K=tJ4
</code></pre>

<p>Uses a while loop with <code>J</code> as the iterator variable. Initializes the maximum using <code>8^chr(' ')</code>. Pads by adding that initial value, converting to hex, then removing the first character.</p>
</div>
<div id="pu18" class="pu"><h1>C, 91-126 bytes</h1>

<p>My original version, 119 bytes.</p>

<pre><code>long a[9],i;
f(long*x){if(65536&amp;++*x)*x=0,f(x+1);}
main(){for(;!a[8];f(a))for(i=7;i+1;i--)printf(i?"%lx:":"%lx\n",a[i]);}
</code></pre>

<p>Best golfed portable-ish version, 103 bytes (thanks @Dennis for some of these concepts)</p>

<pre><code>long*p,a[9];
main(i){while(!a[8]){
for(i=8;i--;printf(i?"%lx:":"%lx\n",a[i]));
for(p=a;++*p&gt;&gt;16;*p++=0);}}
</code></pre>

<p>Explanation: The algorithm itself is reasonably straightforward. I used long rather than unsigned int because it's shorter. Declaring them at the file level means everything's preinitialized with zeros. The <code>f</code> function is a simple increment with carry that operates on the low 16 bits of each word. The loop ends when it carries into the 129th bit.</p>

<p>Iterating backwards for the printf means that we print the addresses in the "proper" order and also the check for printing a newline is a few characters shorter.</p>

<p>This does use some non-portable constructs. It's best regarded as a K&amp;R dialect of C, since it uses implicit int return types and does not include stdio.h. And my use of long was informed by this - on most modern systems int is sufficient because it's 32 bits. This could probably run unmodified on PDP-11 Unix.</p>

<p>However, it can be shorter. If we assume that we can use int (either as a type wider than 16 bits, or a type of exactly 16 bits with various properties that happen to be true on many systems such as twos complement and arithmetic rollover), we can get rid of the stuff related to using long.</p>

<p>Version for int wider than 16 bits, 97 bytes.</p>

<pre><code>a[9],*p;main(i){while(!a[8]){
for(i=8;i--;printf(i?"%x:":"%x\n",a[i]));
for(p=a;++*p&gt;&gt;16;*p++=0);}}
</code></pre>

<p>Version for 16-bit systems, 91 bytes.</p>

<pre><code>a[9],*p;main(i){while(!a[8]){
for(i=8;i--;printf(i?"%x:":"%x\n",a[i]));
for(p=a;!++*p;p++);}}
</code></pre>

<p>Oddly enough, though, the original K&amp;R compiler didn't actually support the declaration without int (it compiles fine, but treats the variables as external and therefore undefined at link time), so an additional three bytes are needed to change the declaration to <code>int*p,a[9];</code> for a total of 94.</p>

<p>Also, if the assumption that it is interrupted before completing output were a hard constraint, we could remove the end check, saving five bytes.</p>

<p>Bonus: fully ANSI portable version, 126 bytes:</p>

<pre><code>#include&lt;stdio.h&gt;
long*p,i,a[9];
int main(){while(!a[8]){
for(i=8;i--;printf(i?"%lx:":"%lx\n",a[i]));
for(p=a;++*p&gt;&gt;16;*p++=0);}}
</code></pre>

<p>Newlines in all versions are inserted for readability and in locations where whitespace is not required, and are excluded from the byte count, except for the newline after the <code>#include</code> line in the ANSI version.</p>

<p>All versions except the ANSI version fall through at the end of main and therefore may return a spurious exit code to the operating system.</p>
</div>
<div id="pu19" class="pu"><h1>Python 2.7, 67 bytes</h1>

<pre><code>n=4**64
while n:n-=1;s='%032x'%n;exec"s=s[4:]+':'+s[:4];"*7;print s
</code></pre>

<p>As a side effect of the method used to insert the colons, the addresses are printed with the rightmost column appearing at the left:</p>

<pre><code>ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff
fffe:ffff:ffff:ffff:ffff:ffff:ffff:ffff
fffc:ffff:ffff:ffff:ffff:ffff:ffff:ffff
...
0003:0000:0000:0000:0000:0000:0000:0000
0002:0000:0000:0000:0000:0000:0000:0000
0001:0000:0000:0000:0000:0000:0000:0000
</code></pre>
</div>
<div id="pu20" class="pu"><h1>Verilog, 335</h1>
<p>My first Verilog submission, probably could use more golfing but I don't have the energy to do so right now. <code>c</code> is clock, <code>o</code> is ASCII output. Does not qualify for formatting bonus due to zero-padding instead of abbreviating.</p>
<pre><code>module b(output[0:38]o,input c);reg[127:0]a;wire[0:39]d;assign o=d[0:38];always @(posedge c) a&lt;=a+(~(&amp;a));genvar i,j;generate for(i=0;i&lt;8;i=i+1) begin:q for(j=0;j&lt;4;j=j+1) begin:r assign d[5*i+j]=a[16*i+4*j:16*i+4*j+7]&gt;9?{4'h6,a[16*i+4*j:16*i+4*j+7]-9}:{4'h3,a[16*i+4*j:16*i+4*j+7]};end assign d[5*i+4]=8'h3A; end endgenerate endmodule
</code></pre>
<p>This is a simple iteration followed by some bit-twiddling to make the output ASCII. I chop the colon after the last group with a small hack. Synthesizes and appears to work for xc3s500e-4ft256-4 on ISE 13.7 lin64.</p>
</div>
<div id="pu21" class="pu"><h1>AutoIt3, 137 Bytes</h1>

<pre><code>For $i=0 To 4^64
$s=StringFormat("%032x",$i)
For $j=0 To 7
ConsoleWrite(StringMid($s,$j*4+1,4)&amp;($j&lt;7?':':''))
Next
ConsoleWrite(@LF)
Next
</code></pre>
</div>
<div id="pu22" class="pu"><h1>CJam, <s>36</s> 27 bytes</h1>

<pre><code>G32#{(_"%032x"e%4/':*oNo}h;
</code></pre>

<p>-9 bytes thanks to @Dennis (I forgot that CJam has string formatting). Prints the addresses lowercase and descending.</p>

<p>For obvious reasons, use the Java interpreter, not the online one. You can replace <code>G32#</code> with something smaller for testing online though, e.g. <a href="http://cjam.aditsu.net/#code=100%20%7B%28_%22%25032x%22e%254%2F&#39;%3A*oNo%7Dh%3B">here's the last 100</a>.</p>

<h3>Explanation</h3>

<pre><code>G32#             16^32 = 2^128. Call this n
{ ... }h;        While loop. The final ; is to pop n at the end
 (               Decrement n
 _               Copy n
 "%032x"e%       String format to hex, padded to 32 digits
 4/              Split into groups of 4
 ':*             Join with colons
 oNo             Output with newline
</code></pre>
</div>
<div id="pu23" class="pu"><h1>C (with GCC extensions), 76 bytes * 0.8 = 60.8</h1>
<pre><code>__uint128_t i;main(){char s[50];for(;inet_ntop(10,&amp;i,s,49),puts(s),++i&gt;0;);}
</code></pre>
<p>This uses the <a href="https://gcc.gnu.org/onlinedocs/gcc-4.8.5/gcc/_005f_005fint128.html#_005f_005fint128" rel="noreferrer">128-bit integers GCC extension</a> to simply count up from <code>::</code> to <code>ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff</code>.  <code>inet_ntop()</code> correctly formats each address so the -20% bonus can be claimed.</p>
<h3>Output</h3>
<p>Using <code>sed</code> to output every millionth line up to 10 million:</p>
<pre><code>$ ./ipv6all | sed -n '1~1000000p;10000000q'
::
4042:f00::
8084:1e00::
c0c6:2d00::
9:3d00::
404b:4c00::
808d:5b00::
c0cf:6a00::
12:7a00::
4054:8900::
$ 
</code></pre>
<p>Note I am using a little-endian x86_64 machine, and that network addresses are typically always in network-order (big-endian), so the endianness is effectively swapped by using <code>inet_ntop()</code>.  This does not matter - all addresses will still (eventually) be displayed.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/59934/">59934</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




