<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::106035</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>030</td><td>APLNARS</td><td>250330T194239Z</td><td><a href="https://codegolf.stackexchange.com/questions/106035/pi-3-2/278994#278994">Rosario</a></td></tr>
<tr d-ix="1"><td>045</td><td>Wolfram Language Mathematica</td><td>170107T232044Z</td><td><a href="https://codegolf.stackexchange.com/questions/106035/pi-3-2/106037#106037">LegionMa</a></td></tr>
<tr d-ix="2"><td>042</td><td>Desmos</td><td>220505T012711Z</td><td><a href="https://codegolf.stackexchange.com/questions/106035/pi-3-2/246892#246892">fireflam</a></td></tr>
<tr d-ix="3"><td>080</td><td>JavaScript ES7</td><td>170108T233725Z</td><td><a href="https://codegolf.stackexchange.com/questions/106035/pi-3-2/106154#106154">Arnauld</a></td></tr>
<tr d-ix="4"><td>043</td><td>PARI/GP</td><td>170108T021539Z</td><td><a href="https://codegolf.stackexchange.com/questions/106035/pi-3-2/106046#106046">Christia</a></td></tr>
<tr d-ix="5"><td>031</td><td>MATL</td><td>170108T033120Z</td><td><a href="https://codegolf.stackexchange.com/questions/106035/pi-3-2/106054#106054">Luis Men</a></td></tr>
<tr d-ix="6"><td>092</td><td>Python + scipy</td><td>170107T230913Z</td><td><a href="https://codegolf.stackexchange.com/questions/106035/pi-3-2/106036#106036">orlp</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>APL(NARS), 30 chars</h1>
<pre><code>p←⎕⋄(2÷p)×{p√+/(1-p)*⍨⍵,1-⍵}∫1
</code></pre>
<p>Just the integral other has in answers, i don't know if the function
of integral is  <code>(2÷p)×{p√+/(1-p)*⍨⍵,1-⍵}</code> or <code>{p√+/(1-p)*⍨⍵,1-⍵}</code>
or before make integration and after the product, i think in both way would return the same result....</p>
<p>test:</p>
<pre><code>  p←⎕⋄(2÷p)×{p√+/(1-p)*⍨⍵,1-⍵}∫1
⎕:
  1.5
3.259767993 
  p←⎕⋄(2÷p)×{p√+/(1-p)*⍨⍵,1-⍵}∫1
⎕:
  4
3.396934823
</code></pre>
</div>
<div id="pu1" class="pu"><h1>Wolfram Language (Mathematica), <s>49</s> <s>46</s> 45 bytes</h1>
<p><sup><em>3 bytes saved thanks to <a href="https://codegolf.stackexchange.com/u/9288">alephalpha</a>.</em></sup><br />
<sup><em>1 byte saved thanks to <a href="https://codegolf.stackexchange.com/u/81203">att</a>.</em></sup></p>
<pre><code>\!\(2N@∫\_0\%1\@+++(a^-#-1)^(1-#)\%#a\)&amp;
</code></pre>
<p><a href="https://tio.run/##y00syUjNTSzJTE78n2b7P0YxRsPIz@FRx@qYeIMYVcMYB21tbY3EOF1lXUPNOA1DXWXNGFXl93N7EmM01f4HlmamljgEFGXmlUQr69qlOSjHqtUFJyfm1VVzGepwGelwGeqZGRmDKFMdLhOu2v8A" rel="nofollow noreferrer" title="Wolfram Language (Mathematica) – Try It Online">Try it online!</a> Pure function. Takes a number as input and returns a number as output. The Unicode characters are U+222B for <code>\[Integral]</code> and U+F74C for <code>\[DifferentialD]</code>.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://desmos.com/calculator" rel="nofollow noreferrer">Desmos</a>, 42 bytes</h1>
<pre><code>f(p)=2∫_0^1(x/x^p+(1-x)^{1-p})^{1/p}dx/p
</code></pre>
<p>Port of <a href="https://codegolf.stackexchange.com/a/106036/68261">orlp's integration formula</a>. Yay for integration built-in!</p>
<p><a href="https://www.desmos.com/calculator/g5capgcp0h" rel="nofollow noreferrer">Try it on Desmos!</a></p>
</div>
<div id="pu3" class="pu"><h2>JavaScript (ES7), 80 bytes</h2>
<p>Based on <a href="https://codegolf.stackexchange.com/a/106036/58563">orlp's answer</a>. This JS implementation is quite slow. You may want to try <code>i=1e-7</code> (or even higher) for a faster approximation.</p>
<p><em>Note</em>: This is basically intended for Chrome and Edge only. An equivalent ES6 version using <code>Math.pow()</code> on Firefox 50.1 seems to be <em>much</em> slower.</p>
<p><em>Edit</em>: According to Neil, this should also work fine on Firefox 52.</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>f=
p=&gt;{for(i=5e-8,s=x=0;(x+=i)&lt;1;)s+=i*(x**(1-p)+(1-x)**(1-p))**(1/p);return 2/p*s}

console.log(f(1).toFixed(3))
console.log(f(2).toFixed(3))
console.log(f(1.623).toFixed(3))</code></pre>
</div>
</div>
</p>
</div>
<div id="pu4" class="pu"><h2>PARI/GP, <s>48</s> 43 bytes</h2>

<p>It's easy after @orlp has found the formula, and @alephalpha's version saves 5 bytes:</p>

<pre><code>p-&gt;2*intnum(u=0,1,(1+(u^-p-1)^(1-p))^(1/p))
</code></pre>

<p>To add something slightly useful, let's calculate the <code>p</code> for which we get <code>3.2</code>:</p>

<pre><code>? f=p-&gt;2*intnum(u=0,1,(1+(u^-p-1)^(1-p))^(1/p));
? solve(p=1,2,f(p)-3.2)
%2 = 1.623002382384469009676324702
</code></pre>

<h3>Correct usage</h3>

<p>While the code gives results that are much more exact than the challenge demands, it can easily be improved a lot: if we replace the upper integration limit <code>1</code> with <code>[1,1/p-1]</code> (giving what the manual calls the singularity exponent) then all shown digits of <code>f(2)</code> agree with <code>Pi</code>. This is still true if we increase the precision to 100  (type <code>\p100</code>).</p>

<p>However, after that change the <code>solve</code> computation no longer worked. I changed the inner term to explicitely handle the case <code>u=0</code> and also changed to a different computer with a newer PARI version and 64 bit (which implies a higher default precision).</p>

<p>Here is the improved calculation of the <code>p</code> value for <code>Pi=3.2</code>, and let's also have a look at the real Pi:</p>

<pre><code>? f=p-&gt;2*intnum(u=0,[1,1/p-1],if(u,(1+(u^-p-1)^(1-p))^(1/p),0));
? f(2)
%2 = 3.1415926535897932384626433832795028842
? Pi
%3 = 3.1415926535897932384626433832795028842
? solve(p=1,2,f(p)-3.2)
%4 = 1.6230023823844690096763253745604419761
</code></pre>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/lmendo/MATL" rel="nofollow noreferrer">MATL</a>, 31 bytes</h1>

<pre><code>0:1e-3:1lyG^-lG/^v!d|G^!slG/^sE
</code></pre>

<p><a href="https://tio.run/nexus/matl#@29gZZiqa2xlmFPpHqeb464fV6aYUuMep1gMYhe7/v9vqGcKAA" rel="nofollow noreferrer" title="MATL – TIO Nexus">Try it online!</a> Or <a href="https://tio.run/nexus/matl#S4jwrvhvYGWYqmtsZZhT6R2nm@OtH1emmFLjHadYDGIXu/53CflvyGXEZahnZmQMJE25TAA" rel="nofollow noreferrer">verify all test cases</a>.</p>

<h3>Explanation</h3>

<p>This generates the <em>x</em>,<em>y</em> coordinates of one quarter of the unit circle sampled at 1001 points with step 0.001 in <em>x</em>. The length of the quarter of circle is approximated by that of the polygonal line that passes through those points; that is, the sum of the lengths of the 1000 segments. Length is of course computed according to <code>p</code>-norm. Multiplying the result by 2 gives the approximate lenght of half a circle, that is, pi.</p>

<pre><code>0:1e-3:1   % Push [0 0.001 0.002 ... 0.999 1]. These are the x coordinates of
           % the vertices of the polygonal line that will approximate a quarter
           % of the unit circle
l          % Push 1
y          % Duplicate [0 0.001 0.002 ... 0.999 1] onto the top of the stack.
G          % Push input, p
^          % Element-wise power: gives [0^p 0.001^p ... 1^p]
-          % Element-wise subtract from 1: gives [1-0^p 1-0.001^p ... 1-1^p]
lG/        % Push 1, push p, divide: gives 1/p
^          % Element-wise power: gives [(1-0^p)^(1/p) (1-0.001^p)^(1/p) ...
           % ... (1-1^p)^(1/p)]. These are the y coordinates of the vertices
           % of the polygonal line
v          % Concatenate vertically into a 2×1001 matrix. The first row contains
           % the x coordinates and the second row contains the y coordinates
!          % Transpose
d|         % Compute consecutive differences down each column. This gives a
           % 1000×2 matrix with the x and y increments of each segment. These
           % increments will be referred to as Δx, Δy
G          % Push p
^          % Element-wise power
!          % Transpose
s          % Sum of each column. This gives a 1×1000 vector containing
           % (Δx)^p+(Δy)^p for each segment
lG/        % Push 1/p
^          % Element-wise power. This gives a 1×1000 vector containing 
           % ((Δx)^p+(Δy)^p)^(1/p) for each segment, that is, the length of 
           % each segment according to p-norm
s          % Sum the lenghts of all segments. This approximates the length of
           % a quarter of the unit circle
E          % Multiply by 2. This gives the length of half unit circle, that is,
           % pi. Implicitly display
</code></pre>
</div>
<div id="pu6" class="pu"><h1>Python + scipy, 92 bytes</h1>

<pre class="lang-py prettyprint-override"><code>from scipy.integrate import*
lambda p:2/p*quad(lambda x:(x/x**p+(1-x)**(1-p))**(1/p),0,1)[0]
</code></pre>

<p>Formula is from <a href="https://math.stackexchange.com/questions/254620/pi-in-arbitrary-metric-spaces">this math.SE question</a>.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/106035/">106035</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




