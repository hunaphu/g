<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::68355</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>025</td><td>Vyxal</td><td>240717T202931Z</td><td><a href="https://codegolf.stackexchange.com/questions/68355/visualize-the-greatest-common-divisor/274222#274222">emanresu</a></td></tr>
<tr d-ix="1"><td>072</td><td>MATL</td><td>160104T015858Z</td><td><a href="https://codegolf.stackexchange.com/questions/68355/visualize-the-greatest-common-divisor/68539#68539">Luis Men</a></td></tr>
<tr d-ix="2"><td>191</td><td>Python 2</td><td>160102T112104Z</td><td><a href="https://codegolf.stackexchange.com/questions/68355/visualize-the-greatest-common-divisor/68410#68410">Sherlock</a></td></tr>
<tr d-ix="3"><td>136</td><td>Javascript</td><td>160101T195422Z</td><td><a href="https://codegolf.stackexchange.com/questions/68355/visualize-the-greatest-common-divisor/68357#68357">nicael</a></td></tr>
<tr d-ix="4"><td>091</td><td>Retina</td><td>160101T194940Z</td><td><a href="https://codegolf.stackexchange.com/questions/68355/visualize-the-greatest-common-divisor/68356#68356">Martin E</a></td></tr>
<tr d-ix="5"><td>083</td><td>Japt</td><td>160101T213356Z</td><td><a href="https://codegolf.stackexchange.com/questions/68355/visualize-the-greatest-common-divisor/68364#68364">nicael</a></td></tr>
<tr d-ix="6"><td>096</td><td>Julia</td><td>160101T195528Z</td><td><a href="https://codegolf.stackexchange.com/questions/68355/visualize-the-greatest-common-divisor/68358#68358">Alex A.</a></td></tr>
<tr d-ix="7"><td>052</td><td>Jolf</td><td>160101T215259Z</td><td><a href="https://codegolf.stackexchange.com/questions/68355/visualize-the-greatest-common-divisor/68366#68366">Conor O&</a></td></tr>
<tr d-ix="8"><td>5090</td><td>ğ”¼ğ•Šğ•„ğ•šğ•Ÿ</td><td>160101T200751Z</td><td><a href="https://codegolf.stackexchange.com/questions/68355/visualize-the-greatest-common-divisor/68359#68359">Mama Fun</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal/tree/version-2" rel="nofollow noreferrer">Vyxal</a>, 25 bytes</h1>
<pre><code>Ä¡/Ê€á¹˜*fDÃÇ”â€›.oÄ°â€ŸáºŠ'?Ä¡+â†”;hâ½É¾Â¢
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/?v=2&amp;c=1#WyJBIiwiIiwixKEvyoDhuZgqZkTDnseU4oCbLm/EsOKAn+G6iic/xKEr4oaUO2jigb3JvsKiIiwi4oiRIiwiWzQsIDVdXG5bMTAsIDJdXG5bNiwgOF1cbls0LCA2XSJd" rel="nofollow noreferrer">Try it Online!</a> Input as pair of numbers, output as char list.</p>
<pre><code>Ä¡/                        # Divide both by gcd
  Ê€                       # Range from 0 to each inclusive
   á¹˜*                     # Multiply by each other
     f                    # And flatten, resulting in all divisors of the inputs up to lcm(a,b)
       ÃÇ”                 # Untruth; create a list with 1s at indices in list
         â€›.oÄ°             # Index into &quot;.o&quot;
      D      â€ŸáºŠ           # All pairs of the previous list
               '----;h    # Find the first one where
                   â†”      # One element is equal to
                ?Ä¡+       # The other + gcd(input)
                        Â¢ # At those two indices
                      â½É¾  # Uppercase
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://esolangs.org/wiki/MATL" rel="nofollow noreferrer">MATL</a>, 72 bytes</h1>

<p>Uses <a href="https://github.com/lmendo/MATL/releases/tag/6.0.0" rel="nofollow noreferrer">version 6.0.0</a>, which is earlier than this challenge. The code runs in Matlab and in Octave.</p>

<pre><code>2$tZm1+:1-bbvtbw\A~otbZ}ZdXK1+ltb(3X53$X+1K2$lh*t2=f1)tK+hwg1+Ib('.oO'w)
</code></pre>

<h3>Example</h3>

<pre><code>&gt;&gt; matl
 &gt; 2$tZm1+:1-bbvtbw\A~otbZ}ZdXK1+ltb(3X53$X+1K2$lh*t2=f1)tK+hwg1+Ib('.oO'w)
 &gt; 
&gt; 1
&gt; 1
OO

&gt;&gt; matl
 &gt; 2$tZm1+:1-bbvtbw\A~otbZ}ZdXK1+ltb(3X53$X+1K2$lh*t2=f1)tK+hwg1+Ib('.oO'w)
 &gt; 
&gt; 2
&gt; 3
o.OOo.o

&gt;&gt; matl
 &gt; 2$tZm1+:1-bbvtbw\A~otbZ}ZdXK1+ltb(3X53$X+1K2$lh*t2=f1)tK+hwg1+Ib('.oO'w)
 &gt; 
&gt; 12
&gt; 15
o...........O..O........o.....o.....o........o..o...........o
</code></pre>

<h3>Explanation</h3>

<p>I have <a href="https://i.sstatic.net/6x5av.jpg" rel="nofollow noreferrer">no idea</a> how it works. I just typed characters randomly. I think there is some convolution involved.</p>

<p><strong>Edit: <a href="http://matl.tryitonline.net/#code=MiR0Wm0xKzoxLWJiJnZ0YndcQX50Ylp9WmRYSzErbHRiKDNYNTMkWSsxSzIkbGgqdDI9ZjEpdEsraHdnMStJYignLm9PJ3cp&amp;input=MTIKMTU" rel="nofollow noreferrer">Try it online!</a></strong> The code in the link has been slightly modified to conform to changes in the language (as of June 2, 2016).</p>
</div>
<div id="pu2" class="pu"><h1>Python 2, <s>217</s> <s>200</s> 191 bytes</h1>



<p>This is a little blunt, but it works. Any golfing tips are appreciated, <s>especially if you know how to fix that <code>s[i] = s[v] = "o"</code> problem I encountered, where that would overwrite "O"s</s> Got it!</p>

<pre class="lang-python prettyprint-override"><code>g=lambda a,b:b and g(b,a%b)or a
def f(a,b):
 h=g(a,b);x=1+a*b/h;s=["."]*x;v=k=0
 for i in range(x):
    if(i%a)*(i%b)&lt;1:
     if k:s[i]="o"
     else:k=i==h+v;s[i]=s[v]="oO"[k]
     v=i
 return''.join(s)
</code></pre>

<p><strong>Ungolfed:</strong></p>

<pre class="lang-python prettyprint-override"><code>def gcd(a,b):                           # recursive gcd function
    if b:
        return g(b,a%b)
    else:
        return a
def f(a,b):
    h = gcd(a,b)
    x = 1 + a*b/h                       # 1 + lcm(a,b)
    s = ["."] * x
    v = 0
    k = 0
    for i in range(x):
        if i%a == 0 and i % b == 0:
            if k == 0:
                k = (i == h+v)          # correct distance apart?
                if k:                   # if "O" just found
                    s[i] = s[v] = "O"
                else:
                    s[i] = s[v] = "o"
            else:
                s[i] = "o"              # if "O" already found, always "o"
            v = i                       # If we found an "o" or an "O", i is the new v
    return ''.join(s)
</code></pre>
</div>
<div id="pu3" class="pu"><h2>Javascript, <s>170</s> <s>164</s> <s>161</s> <s>153</s> <s>145</s> <s>141</s> 136 bytes</h2>
<pre><code>(a,b)=&gt;[...Array(a*b/(c=(g=(a,b)=&gt;b?g(b,a%b):a)(a,b))+1)].map((x,i)=&gt;i%a&amp;&amp;i%b?'.':'o').join``.replace(`o${e='.'.repeat(c-1)}o`,`O${e}O`)
</code></pre>
<p>That's quite lonnnggggg....</p>
<p><a href="http://www.es6fiddle.net/iix3s7ty/" rel="nofollow noreferrer">Demo</a>, explicitly defined variables because the interpreter uses strict mode.</p>
</div>
<div id="pu4" class="pu"><h2><a href="https://github.com/mbuettner/retina" rel="nofollow">Retina</a>, <s>112</s> <s>109</s> <s>99</s> <s>94</s> 91 bytes</h2>

<pre><code>^
. 
+r`(?&lt;!^\1+). (.+) 
$'$0
.(?=.* (.+) (.+))(?=\1* |\2* )
o
o(\.*)o((\1\.*o)*) .*
O$1O$2
</code></pre>

<p>Not very competitive, I think, but number theory in Retina is always quite fun. :)</p>

<p>Takes input as unary numbers using <code>.</code> as the unary digit.</p>

<p><a href="http://retina.tryitonline.net/#code=XgouIAorcmAoPzwhXlwxKykuICguKykgCiQnJDAKLig_PS4qICguKykgKC4rKSkoPz1cMSogfFwyKiApCm8KbyhcLiopbygoXDFcLipvKSpcLiopIC4qCk8kMU8kMg&amp;input=Li4uLi4uLi4uLi4uIC4uLi4uLi4uLi4uLi4uLg" rel="nofollow">Try it online.</a></p>

<h3>Explanation</h3>

<pre><code>^
. 
</code></pre>

<p>This inserts a <code>.</code> and a space in front of the input. This will ultimately become the output.</p>

<pre><code>+r`(?&lt;!^\1+). (.+) 
$'$0
</code></pre>

<p>This prepends the LCM of <code>a</code> and <code>b</code> to the string. Since we already have a <code>.</code> there, we'll end up with <code>lcm(a,b)+1</code>. This is accomplished by repeatedly prepending <code>b</code> as long as <code>a</code> does not divide this new prefix. We capture <code>a</code> into a group one and then check if we can reach the beginning of the string by matching that capture at least once. <code>b</code> is then inserted into the string via the rarely used <code>$'</code> which inserts everything <em>after</em> the match into the substitution.</p>

<pre><code>.(?=.* (.+) (.+))(?=\1* |\2* )
o
</code></pre>

<p>This one matches characters at positions which are divided by <code>a</code> or <code>b</code>. It makes use of the fact that the result is symmetric: since <code>lcm(a,b)</code> is divided by both <code>a</code> and <code>b</code> going left by subtracting instances of <code>a</code> or <code>b</code> yields the same pattern as going right from <code>0</code> by adding them. The first lookahead simply captures <code>a</code> and <code>b</code>. The second lookahead checks that there is a multiple of each <code>a</code> or <code>b</code> characters before the first space.</p>

<pre><code>o(\.*)o((\1\.*o)*) .*
O$1O$2
</code></pre>

<p>As stated on Wikipedia, in addition to BÃ©zout's identity it is also true that</p>

<blockquote>
  <p>The greatest common divisor <code>d</code> is the smallest positive integer that can be written as <code>ax + by</code>.</p>
</blockquote>

<p>This implies that the GCD will correspond to the shortest gap between two <code>o</code>s in the output. So we don't have to bother finding the GCD at all. Instead we just look for first instance of the shortest gap. <code>o(\.*)o</code> matches a candidate gap and captures its width into group 1. Then we try to reach the first space by alternating between a backreference to group 1 and <code>o</code>s (with optional additional <code>.</code>s). If there is a shorter gap further to the right, this will fail to match, because we cannot get past that gap with the backreference. As soon as all further gaps are at least as wide as the current one, this matches. We capture the end of the LCM-string into group 2 and match the remainder of the string with <code>.*</code>. We write back the uppercase <code>O</code>s (with the gap in between) as well as the remainder of the LCM string, but discard everything starting from the space, to remove <code>a</code> and <code>b</code> from final result.</p>
</div>
<div id="pu5" class="pu"><h2><a href="http://ethproductions.github.io/japt/" rel="nofollow noreferrer">Japt</a>, 83 bytes</h2>
<pre><code>'.pD=U*V/(C=(G=@Y?G$($YX%Y :X} $($UV)+1 Â£Y%UÂ©Y%V?&quot;.:o&quot;} $.replace($E=`o{'.pC-1}o`Eu
</code></pre>
<p>Not fully golfed yet... And doesn't want to be golfed :/</p>
</div>
<div id="pu6" class="pu"><h1>Julia, <s>111</s> <s>110</s> <s>107</s> <s>103</s> 96 bytes</h1>



<pre class="lang-default prettyprint-override"><code>f(a,b)=replace(join([i%a*(i%b)&lt;1?"o":"."for i=0:lcm(a,b)]),"o$(d="."^(gcd(a,b)-1))o","O$(d)O",1)
</code></pre>

<p>This is a function that accepts two integers and returns a string.</p>

<p>Ungolfed:</p>

<pre class="lang-default prettyprint-override"><code>function f(a::Int, b::Int)
    # Construct an array of dots and o's
    x = [i % a * (i % b) &lt; 1 ? "o" : "." for i = 0:lcm(a, b)]

    # Join it into a string
    j = join(x)

    # Replace the first pair with distance gcd(a, b) - 1
    replace(j, "o$(d = "."^(gcd(a, b) - 1))o", "O$(d)O", 1) 
end
</code></pre>

<p>Saved a byte thanks to nimi!</p>
</div>
<div id="pu7" class="pu"><h1>Jolf, 52 bytes</h1>

<pre><code>on*'.wm9jJÎ¡R m*Yhm8jJDN?&lt;*%Sj%SJ1'o'.}"'o%o"n"O%O"n
</code></pre>

<p>I will split this code up into two parts.</p>

<pre><code>on*'.wm9jJ
on         set n
  *'.       to a dot repeated
      m9jJ  the gcd of two numeric inputs

Î¡R m*Yhm8jJDN?&lt;*%Sj%SJ1'o'.}"'o%o"n"O%O"n
    *Y                                    multiply (repeat) Y (Y = [])
      hm8jJ                                by the lcm of two inputs + 1
  _m       DN              }              and map the array of that length
             ?&lt;*%Sj%SJ1'o'.               "choose o if i%a*(i%b)&lt;1; otherwise choose ."
 R                          "'            join by empty string
Î¡                            'o%o"n        replace once (capital Rho, 2 bytes): "o"+n+"o"
                                   "O%O"n   with "O"+n+"O"
                                          implicit printing
</code></pre>

<p><a href="http://conorobrien-foxx.github.io/Jolf/#code=b24qJy53bTlqSs6hUiBtKllobThqSkROPzwqJVNqJVNKMSdvJy59IidvJW8ibiJPJU8ibg&amp;input=NAoKNg">Try it here!</a></p>
</div>
<div id="pu8" class="pu"><h1>ğ”¼ğ•Šğ•„ğ•šğ•Ÿ, 50 chars / 90 bytes</h1>
<pre><code>â©¥ĞœÅ«â½Ã®Ã­+1)â“œ$%Ã®â…‹$%Ã­?â˜.:â˜o)â¨Ä‹É¼(`oâ¦ƒâ˜.Ä˜ĞœÅ©â½Ã®Ã­-1)}oâ€,â†ª$Ãºâ¬®
</code></pre>
<p><kbd><a href="http://molarmanful.github.io/ESMin/interpreter.html?eval=true&amp;input=%5B4%2C6%5D&amp;code=%E2%A9%A5%D0%9C%C5%AB%E2%81%BD%C3%AE%C3%AD%2B1%29%E2%93%9C%24%25%C3%AE%E2%85%8B%24%25%C3%AD%3F%E2%8D%98.%3A%E2%8D%98o%29%E2%A8%9D%C4%8B%C9%BC%28%60o%E2%A6%83%E2%8D%98.%C4%98%D0%9C%C5%A9%E2%81%BD%C3%AE%C3%AD-1%29%7Do%E2%80%9D%2C%E2%86%AA%24%C3%BA%E2%AC%AE" rel="nofollow noreferrer">Try it here (Firefox only).</a></kbd></p>
<p>There must be a way to golf this further!</p>
<h1>Explanation</h1>
<p>This is a basic two-phase algorithm. It's actually quite simple.</p>
<h3>Phase 1</h3>
<pre><code>â©¥ĞœÅ«â½Ã®Ã­+1)â“œ$%Ã®â…‹$%Ã­?â˜.:â˜o)â¨
</code></pre>
<p>First, we create a range from 0 to the LCM+1. Then we map over it, checking if either of the inputs is a factor of the current item in the range. If so, we replace that item with an <code>o</code>; otherwise, we replace it with a <code>.</code> . Joining it gives us a series of o's and dots that we can pass to phase two.</p>
<h3>Phase 2</h3>
<pre><code>Ä‹É¼(`oâ¦ƒâ˜.Ä˜ĞœÅ©â½Ã®Ã­-1)}oâ€,â†ª$Ãºâ¬®
</code></pre>
<p>This is just one big replace function. A regex is created as <code>o[dots]o</code>, where the amount of dots is determined by the GCD-1. Since this regex is not global, it will only match the first occurrence. After, the match is replaced by <code>O[dots]O</code> using a toUpperCase function.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/68355/">68355</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




