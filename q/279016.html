<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::279016</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td>Scala 3</td><td>250524T120423Z</td><td><a href="https://codegolf.stackexchange.com/questions/279016/inequality-region-vertices-with-4-equations/281945#281945">Ahamad</a></td></tr>
<tr d-ix="1"><td>193</td><td>Python</td><td>250524T072549Z</td><td><a href="https://codegolf.stackexchange.com/questions/279016/inequality-region-vertices-with-4-equations/281943#281943">Willow W</a></td></tr>
<tr d-ix="2"><td>058</td><td>Charcoal</td><td>250402T094554Z</td><td><a href="https://codegolf.stackexchange.com/questions/279016/inequality-region-vertices-with-4-equations/279033#279033">Neil</a></td></tr>
<tr d-ix="3"><td>111</td><td>Maple</td><td>250401T183334Z</td><td><a href="https://codegolf.stackexchange.com/questions/279016/inequality-region-vertices-with-4-equations/279024#279024">dharr</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.scala-lang.org/" rel="nofollow noreferrer">Scala 3</a>, <del>567</del> 350 bytes</h1>
<p><em>- 217 bytes thanks  to @squareroot12621</em></p>
<p>Golfed version. <a href="https://ato.pxeger.com/run?1=jZLPjtowEMbVa55ienNC4iZAxRbWKyX0slIrIa16QnRlEocajBMcJwJWPEkvXNoX6VNsH6TnOn9Y1EOr5mB_4_z8zYztr9-LmAo6OD__4Ns8UxqaGMeZECzWPJN4W2q6FAx_4IWOyjRlyvoDLTUXhpdaZQJHitFNgR8tK1uujQF8pFzCk2VVVEDKZXIvNVNFaz3LuNTF_TZXWcWSMaAHtpu_z0qTbeHC3wKb3NWlzFEbu9DO9gLIt1Kn3s3PV59R6Ebu1JBPdd4Z-Y-mXvwudsie1JslCbFgcqW_TNJMIX7r-aU0LYOcrG893gu6yG5SURIi3m5ckugiYzK9yL0B1q08GKCTRwN0MiHUOXh7ZznhKUpeEx_7rfWOoNj8OTpL-03SoIqgo0O92NlfVnKCdq6qjRRURKuSNUVvrkUDT6GyjXWINraT48egF3Wqfzc1qhcw751dkZSKgtU1VPasR_LTaTLDOqvP69Qe8_MvCyBhKWzNFSOqVsUYQqXoYf6gFZerhT2GT5JrIPX9g_nqCkMTmstEfdx3oY-Dty54I2zGwPT5QkUd5Q1xYIAGHmLfBR_3h1dsesF8fDMy3AAPzTTwW3I4sq95FStKUdfy70doHg5ELkzbHLnpQwuJ2s312snquj-f2_k3" rel="nofollow noreferrer">Attempt This Online!</a></p>
<pre class="lang-scala prettyprint-override"><code>(A,B,C)=&gt;{val P=scala.collection.mutable.ListBuffer[(Double,Double)]();val n=A.length;for(i&lt;-0until n;j&lt;-i+1until n){val a=A(i);val b=B(i);val c=C(i);val x=A(j);val y=B(j);val z=C(j);val d=a*y-x*b;if(d!=0.0){val q=(c*y-z*b)/d;val r=(z*a-c*x)/d;val p=(q,r);var v=true;for(k&lt;-0until n if v)if(A(k)*p._1+B(k)*p._2&gt;C(k)+1e-9)v=false;if(v)P+=p}};P.toList}
</code></pre>
<p>Ungolfed version. <a href="https://ato.pxeger.com/run?1=1Vjdbts2FL739R7g7Cpy6ig_zdCuWIY53goU6IABWbeLoKhpmY5pU5JHUkmEoU-ym95sD7W9zL5DSrIkJ-0yFEOHBLZMnj-en-8c6rc_bCK0ePzu3e-FWxw8_fOzv1S6yY0jvx4nudYycSrP4rRwYqZl_FJZd14sFtIMOqSFUxr0mTO5js-NFGsbvxkM8tkKAuh7oTL6dTAgOtzfxyft03OVzUllThobVNAmx09L-YK0yqSluVzge06zkpJcLhYqUZIJxiM6H9EkiLlZSiNJimTpuUjZZzS-VK_3b-kRnfNDSWc0wYOnD0zfbIQRKY3xZ-UvhcwSyWo7Wha5oVuKWNaww3X-Ia6SovMdrskOV2adyBzBAamlaNLiMNIVJgODhrOZOLodUTkkV2w0_GLkxkgLdSq7IreUd3rRLQVCI5yyi5KE1kGhEbwZez2H-ISLCU6ev2hJ-MELiMbP6EL-cvltXiDsr-Hy3u9J5_fwGXFmXEbh94jC9_A1nP8rq6NroTuGBjXY3mbULnc0bHizIn3p0-KMxrGW2ZVb0uEhja0tUnZElRW0FNfSe8WKVFIgHHgpoJ4sZbL27tgIZVq5FqkRrYZVNin6ilY1y8-SMoksPK0oOcJe_EYmCnGnjclha0rC4nx-64fSLREJeSvSDZ9mVjhKxZqtVI6uZCaN0HGt4McdDnxvNDLK6RIMIHaV3sf-U5HI2B5-Xo0IZahLll1byFbkrqXhpXR7FvbBU3LrxxsFN8wk2CqzocVRIqwMjCw-gisO6IgKJNs2BMMqpBXNimkUyu34XjqiGUMCI0i0XeOwijeKIxqpYWd55pfP-8uJX57wck_KyktZ9aWsvJRVX8rKS1m1pHByCJ0UGs5GWXBVqozrs4l3aR2ijIxBFQvOYNsR2uY588fa9_oPvHH8rDraLtZqQ6rOP4G0Y6AA3mqKurKOttaDvruJ3fio7ecQ8F2ZOEWCikvUHMDRpX6OPctZxClXjuhGetYsdyTmc5-1GUACmYh8TEVW1hiz6AgNJ4m7sjm56wIB3sGDTOmVwcIiU0DEu_CrJ-bFoqVoxPEo7wM39lGORuDl4MkHz7eGwMB6sZSOuhq4RquD6zz3tcrH22_bZvc5_HPgFUy577zKoqgAQgrcqXDJMuirSzzJ57LN4-uiZsS_9zqtZXmTG-6PdMHt1QdlVaA-LacNyzMy9IbQAAApbPemkfyWpLaynxgXuQY6ehDZ8XndZQrLh5-gaUkD2DCFli0hnOq3SMooaWV4Umf4kA7bhdDjKwMf03J9HFCQgfp4P18w76wycNA9UoB0xY6A-wLpNtL95IgQM5SvVg67w9062A4S6xEltejx5boeKNY8UHzFE8X6NUU3Cl3IpqzF5RpIje4-7FhvtsaMtZ60TDkjZ4q-axsp2D6WB1_6FheKsKfGR3Ghc-HHgHBuaUxubNtBHqDX7wfxrfatp34SupAeUtdDhMiLj98csws6KycdGQxPfRlfA2jB8ajloJ5meo-LFgJZ3KP2JUMfrJmYW3eBGhBwk7jyTTOw5qh1mJnIjUMq6DLuKHg7aD_v4NAHMmzEmMlt3uVcooV2tiWCHXTPYfteuWNWenQWtHcMvOOpKZGwFj535cUu59lrUB0Tx_su5f5Xj5V73lt73nF7PNqrrJB7jX-fBZ5XHi4EDy_sUIYTTrqpZ55yeJI8TbEKvlzPgVOeG53JwaDMeuRNwD_jac0ioHOVAzhVEgcFY-ww6YjSHOi8KDJ_Bu76G7QWLthUXS0dC4DTOeJTnmmn3POm8hZHtNOmjW9DFco76MDmjRGbHpiSL-_pvRecaWUhA8dcGb7oQHRmtR8PRkFfYQy3PCgtEoz1shIKZJh6z07VwnsJHVhpYeIqFGFmM3IhEleZ_gDD_HFFcFjjz62_4KYqPnyCf3KPe99V4UUKsddy_n-4Mgw-4mj7Sc6xDx5F-yPl5_VIWeHddj5lmK3nyU92IririXb3H9CRm0tL8MYrQMt2aaZzTActrOvA9z9vvB-n9f775vvQ9lu5JRo2LTjcJJvWWg2lNfJNG5dNg8968t4O7vvV6b7_SesMKd-_Yfnp29-QSj9_4_dSAUZVmOxbvRGzpUI0ZXNv5PbX3Kgf1JAryE1xwkiYK36tZYwoLy-cQcNl9HyFK1mDlRwLvhHMhRMNAI6xDcSNTuKTEZ3Ex1-M6OBJjM_j-GgLk-cV1cFpfAwCT3wa49RH8cnplmxSkx3FT5-A7nF8iq_HR4Hy9MmwecviX-1xb9sYLtM7rnc1ZRgefHOrmghdgxaEjdowRHEufqD5hPc_wV6vWGdRYB56j74N7zirV531K8-_AQ" rel="nofollow noreferrer">Attempt This Online!</a></p>
<pre class="lang-scala prettyprint-override"><code>  def findIntersectionPointsImproved(A: Seq[Double], B: Seq[Double], C: Seq[Double]): List[(Double, Double)] = {
    val intersectionPoints = ListBuffer[(Double, Double)]()
    val numLines = A.length

    for (i &lt;- 0 until numLines) {
      for (j &lt;- i + 1 until numLines) {

        val a_i = A(i)
        val b_i = B(i)
        val c_i = C(i)

        val a_j = A(j)
        val b_j = B(j)
        val c_j = C(j)

        val determinant = a_i * b_j - a_j * b_i

        if (determinant != 0.0) { 
          val x = (c_i * b_j - c_j * b_i) / determinant
          val y = (c_j * a_i - c_i * a_j) / determinant
          val point = (x, y)

          val tolerance = 1e-9

          var satisfiesAllConstraints = true
          breakable { 
            for (k &lt;- 0 until numLines) {
              val constraintValue = A(k) * point._1 + B(k) * point._2
              if (constraintValue &gt; C(k) + tolerance) {
                satisfiesAllConstraints = false
                break() 
              }
            }
          }

          if (satisfiesAllConstraints) {
            intersectionPoints += point
          }
        }

      }
    }
    intersectionPoints.toList
  }
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.python.org" rel="nofollow noreferrer">Python</a>, 193 bytes</h1>
<pre class="lang-python prettyprint-override"><code>F=lambda A,B,C:[p for i in[0,1,2]for j in range(i+1,4)if(z:=A[i]*B[j]-A[j]*B[i])if(p:=((C[i]*B[j]-C[j]*B[i])/z,(C[j]*A[i]-C[i]*A[j])/z))if min([A[k]*p[0]+B[k]*p[1]&lt;C[k]+1e-9for k in range(4)])]
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=RZBBTsMwEEX3OcUs7cY2sWuUEpFFYqmXsEYiqA24pa4VhQW9Cptu4B4cg9tgu1A24__n-cvjef8Mb_Pz0Z_PH6_zyFffX-v2ZTg8bgboWM9MYwOMxwkcOG8rJpnCZHfRwjT4py1xpWSaupGcmrazDhe93SHvYonKYSKhaQkxV2au7ObESHYpyPONFIx9GnNwcJ7Yzu5xEWyFZX9REu9NVKXc8rs0y_5_Fk2R4u9HHjpowSqhGCghbxnwWsQqsegT4FrI2MtcM6iE0liYTCqxqiNaCh2PZZWgrrEowuT8TNYkL4bSyzt_i_sB" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>The arguments <code>A</code>, <code>B</code>, and <code>C</code> are the lists of coefficients in x, y, and the right-hand side respectively, i.e. <code>A = [a, d, g, j]</code>, <code>B = [b, e, h, k]</code>, and <code>C = [c, f, i, l]</code>.</p>
<p>This is simply the exhaustive method of computing every intersection point and verifying if they satisfy every inequality.
We first iterate over every pair of inequalities with <code>for i in[0,1,2]for j in range(i+1,4)</code>, and we assign the variable <code>z:=A[i]*B[j]-A[j]*B[i]</code> using <code>if</code>.
Since we assume no lines are parallel, <code>z</code> is always non-zero, and with some algebra we find that the intersection point is given by the coordinates <code>p:=((C[i]*B[j]-C[j]*B[i])/z,(C[j]*A[i]-C[i]*A[j])/z)</code>, which we assign using <code>if</code> once more.</p>
<p>The last statement <code>if min([A[k]*p[0]+B[k]*p[1]&lt;C[k]+1e-9for k in range(4)])</code> verifies that <code>p</code> is in the polygon by checking that it satisfies every inequality, which is the case if the &quot;minimum&quot; of the conditions is True. The <code>+1e-9</code> is there to compensate for floating-point artefacts, since we also check the lines on which the point <code>p</code> lies.
Note: the lack of a space between <code>1e-9</code> and <code>for</code> yields a SyntaxWarning, but the code still runs. Adding the space back in removes the warning at the cost of 1 byte.</p>
<p>This is my first post on here, please let me know if I forgot anything! This was fun, I learned a lot trying to chip away as much as I could :]</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 58 bytes</h1>
<pre><code>ＥΦＥΣＥθＥ…θκＥ³⁻×§ι⊕ν§λ⊖ν×§λ⊕ν§ι⊖ν∕ι§ι²⬤θ‹Σ×λιＸχ±χ⭆¹…ι²
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=fVDNSsQwEMY3CXtKIQ39ky14WlaExR8W1lvpoabjbjBNtUlXfRYve1D0lfRpdpJWdBHMZWa-n5nMvHyITdWJtlK73Vtvb8P86yhfdlJbelnd0zOpLHQ-XfWNjw-MuDB_Fgrmm9YDd8EAphik7g29lg0YOrMLXcMTlYwstOigAW2hpjpA-TenGDmFAw7JQ7v6xy7_2v1DWG5lDU7wS5t4aqaU-_UFGOPXGsbhGOnYZfuIK8cRI1ewrixgOrZcWTzM2i0aM_JzgLFvcPJqboQZz_heTMKtmpSf50VRJDxhJMw42iKeT0tGEIqPEfNMyjOPhVOOWIZwGrnayxNXR05RlkPrPQ" rel="nofollow noreferrer">Attempt This Online!</a> Link is to verbose version of code. Takes input with negated constants as compared to the example i.e. <code>ax + by + c &lt;= 0</code> etc. Explanation:</p>
<pre><code>ΣＥθＥ…θκ
</code></pre>
<p>Looping over every pair of lines...</p>
<pre><code>Ｅ³⁻×§ι⊕ν§λ⊖ν×§λ⊕ν§ι⊖ν
</code></pre>
<p>... calculate their cross product in <code>3D</code> space, ...</p>
<pre><code>Ｅ...∕ι§ι²
</code></pre>
<p>... normalise to <code>2D</code> points in homogenous coordinates, ...</p>
<pre><code>Φ...⬤θ‹Σ×λιＸχ±χ
</code></pre>
<p>... filter on those inside the polygon (with a small fudge factor due to floating-point inaccuracy), ...</p>
<pre><code>Ｅ...⭆¹…ι²
</code></pre>
<p>... and pretty-print the matching points.</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.maplesoft.com/" rel="nofollow noreferrer">Maple</a>, 111 bytes</h1>
<pre><code>proc(s)uses PolyhedralSets;evalf(map2(eval,[x,y],Relations~(Vertices(PolyhedralSet(convert(s,rational))))))end;
</code></pre>
<p>Input is a set of the inequalities. Output is a list of coordinates as [x,y].</p>
<p>The task is just finding a 2D <a href="https://en.wikipedia.org/wiki/Convex_polytope" rel="nofollow noreferrer">convex polytope's</a> vertices from its H-representation. These operations are available in Maple's PolyhedralSets package. The package works in exact arithmetic, so convert(..,rational) is the first step. PolyhedralSet makes an internal data structure, Vertices finds the vertices, and Relations extracts them from the internal data structure. At this point we have a list of equations, e.g., [[y = -2379/878, x = -11952/2195],...]. The rest converts to a list of coordinates, e.g., [[-5.445102506, -2.709567198],...]. If [[y = -2.709567198, x = -5.445102506],...] were an acceptable output, the code could be shortened to 95 bytes:</p>
<pre><code>proc(s)uses PolyhedralSets;(evalf@Relations)~(Vertices(PolyhedralSet(convert(s,rational))))end;
</code></pre>
<p>Lines going through the same point return that point, e.g., {x&lt;=0,y&lt;=0,x&lt;=y} returns [[0., 0.]].</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/279016/">279016</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




