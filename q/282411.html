<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::282411</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>121</td><td>Dyalog APL</td><td>250830T051734Z</td><td><a href="https://codegolf.stackexchange.com/questions/282411/output-the-holes/283397#283397">Aaron</a></td></tr>
<tr d-ix="1"><td>173</td><td>Perl 5</td><td>250629T123300Z</td><td><a href="https://codegolf.stackexchange.com/questions/282411/output-the-holes/282466#282466">good old</a></td></tr>
<tr d-ix="2"><td>095</td><td>Charcoal</td><td>250627T104515Z</td><td><a href="https://codegolf.stackexchange.com/questions/282411/output-the-holes/282420#282420">Neil</a></td></tr>
<tr d-ix="3"><td>067</td><td>05AB1E</td><td>250627T083431Z</td><td><a href="https://codegolf.stackexchange.com/questions/282411/output-the-holes/282417#282417">Kevin Cr</a></td></tr>
<tr d-ix="4"><td>037</td><td>Uiua 0.17.0dev.1</td><td>250627T042501Z</td><td><a href="https://codegolf.stackexchange.com/questions/282411/output-the-holes/282412#282412">Tbw</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Dyalog APL, 121 chars</h1>
<pre><code>{↑{⍵⌷¨⊂' o'}¨{⍵∘{⊃1+{(⍵-1)↓⍺↑b}/(⌈/,⌊/)⍸⍺=⍵}¨0~⍨∪,⍵}⊃{⌈/(⍸b){⍵[⊂⍺]⌈@((b∧1≥+/¨2*⍨(⊂⍺)-⍳⍴b)⍨)⍵}¨⍵}⍣≡⊂b×(⊢⍴⍳∘(×/))⍴b←↑' '=⍵}
</code></pre>
<p>woof.  Input is a vector of strings, one for each row of input, on the right.  Alright, here goes</p>
<pre><code>{↑{⍵⌷¨⊂' o'}¨{⍵∘{⊃1+{(⍵-1)↓⍺↑b}/(⌈/,⌊/)⍸⍺=⍵}¨0~⍨∪,⍵}⊃{⌈/(⍸b){⍵[⊂⍺]⌈@((b∧1≥+/¨2*⍨(⊂⍺)-⍳⍴b)⍨)⍵}¨⍵}⍣≡⊂b×(⊢⍴⍳∘(×/))⍴b←↑' '=⍵}­⁡​‎‎⁪⁡⁪⁠⁪⁢⁤⁡⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁡⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁡⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁡⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁢⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁢⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁢⁤⁪‏‏​⁡⁠⁡‌⁢​‎‎⁪⁡⁪⁠⁪⁢⁣⁢⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁤⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁤⁤⁪‏‏​⁡⁠⁡‌⁣​‎⁪⁪⁠⁪⁪⁠‎⁪⁡⁪⁠⁪⁢⁣⁣⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁣⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁣⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁣⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁤⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁤⁢⁪‏‏​⁡⁠⁡‌⁤​‎‎⁪⁡⁪⁠⁪⁢⁣⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁢⁤⁪‏‏​⁡⁠⁡‌⁢⁡​‎‎⁪⁡⁪⁠⁪⁢⁣⁡⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁢⁡⁪‏‏​⁡⁠⁡‌⁢⁢​‎‎⁪⁡⁪⁠⁪⁢⁣⁡⁣⁪‏‏​⁡⁠⁡‌⁢⁣​‎‎⁪⁡⁪⁠⁪⁤⁢⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁤⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁡⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁡⁢⁪‏‏​⁡⁠⁡‌⁢⁤​‎‎⁪⁡⁪⁠⁪⁤⁣⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁣⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁣⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁣⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁤⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁤⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁤⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁤⁣⁪‏‏​⁡⁠⁡‌⁣⁡​‎‎⁪⁡⁪⁠⁪⁢⁡⁡⁤⁪‏‏​⁡⁠⁡‌⁣⁢​‎‎⁪⁡⁪⁠⁪⁢⁡⁢⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁣⁣⁪‏‏​⁡⁠⁡‌⁣⁣​‎‎⁪⁡⁪⁠⁪⁢⁢⁡⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁡⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁡⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁡⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁢⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁢⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁢⁤⁪‏‏​⁡⁠⁡‌⁣⁤​‎‎⁪⁡⁪⁠⁪⁢⁡⁤⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁤⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁤⁤⁪‏‏​⁡⁠⁡‌⁤⁡​‎‎⁪⁡⁪⁠⁪⁢⁡⁣⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁣⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁣⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁣⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁤⁡⁪‏‏​⁡⁠⁡‌⁤⁢​‎‎⁪⁡⁪⁠⁪⁢⁡⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁢⁤⁪‏‏​⁡⁠⁡‌⁤⁣​‎‎⁪⁡⁪⁠⁪⁢⁡⁢⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁣⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁣⁢⁪‏‏​⁡⁠⁡‌⁤⁤​‎‎⁪⁡⁪⁠⁪⁤⁤⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁤⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁤⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁡⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁡⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁡⁣⁪‏‏​⁡⁠⁡‌⁢⁡⁡​‎‎⁪⁡⁪⁠⁪⁤⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁢⁤⁪‏‏​⁡⁠⁡‌⁢⁡⁢​‎‎⁪⁡⁪⁠⁪⁤⁢⁡⁪‏‏​⁡⁠⁡‌⁢⁡⁣​‎‏​⁢⁠⁢‌⁢⁡⁤​‎‎⁪⁡⁪⁠⁪⁤⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁡⁤⁪‏‏​⁡⁠⁡‌⁢⁢⁡​‎‎⁪⁡⁪⁠⁪⁣⁤⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁤⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁤⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁡⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁡⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁡⁣⁪‏‏​⁡⁠⁡‌⁢⁢⁢​‎‎⁪⁡⁪⁠⁪⁤⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁣⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁤⁡⁪‏‏​⁡⁠⁡‌⁢⁢⁣​‎‎⁪⁡⁪⁠⁪⁣⁢⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁣⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁣⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁣⁣⁪‏‏​⁡⁠⁡‌⁢⁢⁤​‎‎⁪⁡⁪⁠⁪⁣⁡⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁡⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁡⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁡⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁢⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁢⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁢⁣⁪‏‏​⁡⁠⁡‌⁢⁣⁡​‎‎⁪⁡⁪⁠⁪⁢⁢⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁤⁪‏‏​⁡⁠⁡‌⁢⁣⁢​‎‎⁪⁡⁪⁠⁪⁢⁣⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁢⁪‏‏​⁡⁠⁡‌⁢⁣⁣​‎‎⁪⁡⁪⁠⁪⁢⁢⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁣⁪‏‏​⁡⁠⁡‌⁢⁣⁤​‎‎⁪⁡⁪⁠⁪⁢⁡⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁤⁪‏‏​⁡⁠⁡‌⁢⁤⁡​‎‎⁪⁡⁪⁠⁪⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁡⁪‏‏​⁡⁠⁡‌⁢⁤⁢​‎‎⁪⁡⁪⁠⁪⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁣⁪‏‏​⁡⁠⁡‌⁢⁤⁣​‎‎⁪⁡⁪⁠⁪⁢⁪‏‏​⁡⁠⁡‌­
                                                                                                                b←↑' '=⍵   # ‎⁡Find the elements equal to space and save in (b)itmask
                                                                                                     (        )⍴           # ‎⁢Send the shape of it to this train
                                                                                                        ⍳∘(×/)             # ‎⁣Generate indices for the product of the shape
                                                                                                      ⊢⍴                   # ‎⁤reshape that into the bitmask's shape
                                                                                                   b×                      # ‎⁢⁡and multiply that by the bitmask.  This gives a unique id to every marked element
                                                                                                  ⊂                        # ‎⁢⁢Enclose to pass the whole thing to the next function
                                                     {                                         }⍣≡                         # ‎⁢⁣Apply this function until the output stops changing
                                                        (⍸b){                               }¨⍵                            # ‎⁢⁤Apply to each coordinate where the bitmask is 1 to and the entirety of the input matrix
                                                                   @                                                       # ‎⁣⁡Update the input matrix AT
                                                                    (                     )                                # ‎⁣⁢The indices where this is true
                                                                                (⊂⍺)-⍳⍴b                                   # ‎⁣⁣The difference between the coords of the bitmask and the current one I'm looking at
                                                                             2*⍨                                           # ‎⁣⁤Squaring each (the x-difference and the y-difference)
                                                                        1≥+/¨                                              # ‎⁤⁡where the sum is less than or equal to 1.  This finds the cardinal neighbors
                                                                      b∧                                                   # ‎⁤⁢AND with the bitmask to only flow into holes indicated by the bitmask
                                                                     (                  )⍨                                 # ‎⁤⁣Make all that avaialble as a function because that is what @ expects
                                                             ⍵[⊂⍺]⌈                                                        # ‎⁤⁤For every element indicated, get the max between the current index I'm looking at and the cardinal neighbor
                                                      ⌈/                                                                   # ‎⁢⁡⁡Find the max among all the maps generated.  When the map stops changing, then the flood fill is complete and any touching holes with be isolated from non-touching ones
                                                    ⊃                                                                      # ‎⁢⁡⁢Disclose to get a good ol' fashioned matrix
‎⁢⁡⁣
             {                                     }                                                                       # ‎⁢⁡⁤Now to isolate the holes
                                             0~⍨∪,⍵                                                                        # ‎⁢⁢⁡Ravel the final map, find unique ids, and remove 0
              ⍵∘{                          }¨                                                                              # ‎⁢⁢⁢For each of those unique ids, call this function, putting the map as the left argument
                                       ⍸⍺=⍵                                                                                # ‎⁢⁢⁣Get the coordinates of the elements of the map that match this id
                                (⌈/,⌊/)                                                                                    # ‎⁢⁢⁤Get the maximum and minimum of each.  This gives us the bounding box
                    {         }/                                                                                           # ‎⁢⁣⁡Call this function between those maxs and mins
                           ⍺↑b                                                                                             # ‎⁢⁣⁢Take max many rows/cols from the bitmask
                     (⍵-1)↓                                                                                                # ‎⁢⁣⁣Drop one less than the min rows/cols from that.  This gets the minimal box containing the hole
                 ⊃1+                                                                                                       # ‎⁢⁣⁤Add 1 for index's sake (in a moment) and disclose
  {        }¨                                                                                                              # ‎⁢⁤⁡For each of those minimal bounding-box bitmasks
   ⍵⌷¨⊂' o'                                                                                                                # ‎⁢⁤⁢Index each of them into this string
 ↑                                                                                                                         # ‎⁢⁤⁣and mix for a lovely display
💎
</code></pre>
<p>Created with the help of <a href="https://vyxal.github.io/Luminespire" rel="nofollow noreferrer">Luminespire</a>.</p>
<p>I do have a sneaking suspicion I can golf this down a bit but I already golfed down about 30 chars, so pausing for now.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.perl.org/" rel="nofollow noreferrer">Perl 5</a>, 173 bytes</h1>

<pre class="lang-perl prettyprint-override"><code>$_=&quot;3\n @{[&lt;&gt;]} \n&quot;;$L=length;for(s/.+/pack&quot;A$L&quot;,$&amp;/ge;s/ /3/;y/3/#/){1while s/3(.{$L})?\K | (?=(.{$L})?3)/3/s;local$_=/^3/?next:y/#/ /r;s/^ //mg until/^3/m;s/ +$//mg;print}
</code></pre>
<p><a href="https://tio.run/##VU3RCoJAEHzvKxY9QjFc4uily6zn/IOsELlUOk9Ro8T8dluLAgd2l5lZZkpZqdUwsItn8FDDrjtutqceQm0IFnhK6qRJxbWorBpdB8sovhl7FhgLNsdEihoBOYqWlol2t3ykmZJQI7fcjgW97YcHeIHlez/ObXqthSriSFEnnjn6Wj6bdUsBgBUlngExT@Cum0yNfj62OGwURVlluumHwZxgRgN/EAWiJJmf86V/b4I3" rel="nofollow noreferrer" title="Perl 5 – Try It Online">Try it online!</a></p>
<p>A few extra linefeeds in the output, as (<em>I guess</em>) allowed in the challenge. &quot;Any visible character to represent the hole&quot; is &quot;3&quot;, of course (because if you rub-rub-rub, there'll be a hole).</p>
<p>Here with a few comments:</p>
<pre class="lang-perl prettyprint-override"><code># Pad on the left, top and bottom. Seed.
$_=&quot;3\n @{[&lt;&gt;]} \n&quot;;
$L=length;
for(
# Pad on the right, make all lines equal.
    s/.+/pack&quot;A$L&quot;,$&amp;/ge;
# Any more spaces? Seed then.
    s/ /3/;
# Coalesce the hole processed just before.
    y/3/#/
    ) {
# Flood fill.
        1while s/3(.{$L})?\K | (?=(.{$L})?3)/3/s;
# Ugly part: skip the very 1st iteration. Its only purpose is 
# to account for cavities (if any) on the sides.
# Otherwise, localise and make other holes and walls appear the same.
        local$_=/^3/?next:y/#/ /r;
# Trim on the left..
        s/^ //mg until/^3/m;
# ...and on the right. It also converts blank lines to just linefeeds.
# (And IF it was a cheat, it'd be easy to crop them.)
        s/ +$//mg;
        print
}
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 95 bytes</h1>
<pre><code>ＷＳ⊞υ⪫⪪ι ψＢ⁺²Ｌθ⁺²ＬυψＭ↘υ¤#≔⟦⟧υＦⅉＦＬθ«ＵＭＫＡ⎇Σλ#λＪ⊕κι¤1¿ΣＫＫ⊞υ⪪⪫ＫＡω⁺²Ｌθ»⎚ＵＴＥυＥΦιΣλ✂⭆λ§ oΣν⌊Ｅι⌕λ1⊕⌈⌕Ａλ1
</code></pre>
<p><a href="https://tio.run/##ZVFNb4MwDD2XX2HRiyOxw3ZcT12nSq2GhAaXadoB0RSihoSF0A9N@@3Mhqntukgodvz83rMpqtwVNtd9f6iUloAr03Q@9U6ZEoWApGsr7CJYW2UwbbTyqCIIIRQRnISYBU/2iInuWnyI4EWa0lf4Kah489aJoWEWxHYv8fHZHsyrKitPLwlpeQLMgqXSGsNpSOG8bVVp8P0jAq5srQN8Y0NDdBGCr2AS583C1nVuNphIuZsTCYll0pncnTDtatSUE28Emi1P1l3dZJZGLZyspfFygztCKK6NHu7Zw0RtYWhnVtK@bGNcxLCTK8XD/7HJISt@Bwstc4cUZrYstcycqvE8Ow3ArHyRvJeOdzz6JspUq0Li@EsYoiOY@5XZyCOGYMMRaQRDY2VUTRnDiGKpaCUE53G4fD1wnB8HKGPY/xk2OO776Z8T0AfnQylQSk/T4RrT3xpAcNPb3@31Dw" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Takes input as a rectangle of newline-terminated strings. Explanation:</p>
<pre><code>ＷＳ⊞υ⪫⪪ι ψ
</code></pre>
<p>Input the shape and replace spaces with nulls.</p>
<pre><code>Ｂ⁺²Ｌθ⁺²ＬυψＭ↘υ¤#
</code></pre>
<p>Output the shape surrounded with a border of nulls and then fill that border with <code>#</code>s.</p>
<pre><code>≔⟦⟧υＦⅉＦＬθ«
</code></pre>
<p>Look for a hole at each position of the shape.</p>
<pre><code>ＵＭＫＡ⎇Σλ#λ
</code></pre>
<p>Fill in any hole found in the previous iteration.</p>
<pre><code>Ｊ⊕κι¤1
</code></pre>
<p>Try to fill a hole with <code>1</code>s.</p>
<pre><code>¿ΣＫＫ⊞υ⪪⪫ＫＡω⁺²Ｌθ
</code></pre>
<p>If that was successful then save a snapshot of the canvas.</p>
<pre><code>»⎚ＵＴ
</code></pre>
<p>Clear the canvas and turn off automatic space-padding.</p>
<pre><code>ＥυＥΦιΣλ✂⭆λ§ oΣν⌊Ｅι⌕λ1⊕⌈⌕Ａλ1
</code></pre>
<p>Trim each snapshot and replace the <code>#</code>s with spaces and the <code>1</code>s with <code>o</code>s.</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 67 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>ðQ4F¬dšøí}©˜ƶ®gäΔ4F¬dšøí}2Fø€ü3}®*εε˜ŽqÆSèà]©˜ê¦¨ε®Qø[¬à#¦}ø0δÜ0ð:
</code></pre>
<p>Input as a rectangular matrix of characters (right-padded with spaces).<br />
Output as a list of matrices of characters, including leading/trailing linefeeds (as <code>[]</code>).</p>
<p><a href="https://tio.run/##yy9OTMpM/V/zqGlN8P/DGwJN3A6tSTm68PCOw2trD608PefYtkPr0g8vOTcFWcLI7fAOoIbDe4xrD63TOrf13NbTc47uLTzcFnx4xeEFsSB9h1cdWnZoxbmth9YFHt4RfWjN4QXKh5bVHt5hcG7L4TkGhzdY/fc6tFun9r8yCuACYgU4AHIVgFygkDKYgnChcgoKXKh6/@vq5uXr5iRWVQIA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/V@mFFCUWlJSqVtQlJlXkpqikJlXUFpipaCkU@l1aLdOpdL/wxsCTdwOrUk5uvDwjsNraw@tPD3n2LZD69IPLzk3BVnCyO3wjkdNaw7vMa49tE7r3NZzW0/PObq38HBb8OEVhxfEgvQdXnVo2aEV57YeWhd4eEf0oTWHFygfWlZ7eIfBuS2H5xgc3mD1X0kvTMkxuaQ0MUchv7QE4hJ7Wy50R8LldMrAzqw9tM3@f3R0tJKykg4BHKuDqkoBipH5CFUKaBi7KgI2xuooRGM3DoKxGaOA4WDSHEqMA5EchjAU2UBlDOfhMhaLUcRjXFFCCCtjcSy2MMImh0snbrvwxRaR/oyN/a@rm5evm5NYVQkA" rel="nofollow noreferrer">verify all test cases</a>. The header is for copy-pastable input (make sure to right-pad it with spaces!) and the footer is to pretty-print the output list of matrices.</p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>ðQ               # Mark all spaces as 1s and &quot;#&quot;s as 0s in the (implicit) input-matrix
  4F¬dšøí}       # Add a border of 1s around the matrix:
  4F     }       #  Loop 4 times:
    ¬            #   Get the first row (without popping the matrix)
     d           #   Transform all to 0s to 1s using an &gt;=0 check
      š          #   Prepend this row to the matrix
       øí        #   Rotate the matrix 90 degrees:
       ø         #    Zip/transpose; swapping rows/columns
        í        #    Reverse each inner row
©˜ƶ®gäΔ4F¬dšøí}2Fø€ü3}®*εε˜ŽqÆSèà]
                 # Flood-fill the matrix †
©                # Store this flood-filled matrix in variable `®` (without popping)
 ˜               # Flatten it
  ê              # Uniquify and sort its values
   ¦             # Remove the leading 0
    ¨            # Remove the trailing largest island
                 # (the outer border we added for the island of right-padded spaces)
     ε           # Map over each unique island:
      ®Q         #  Mark those as 1s in matrix `®`
        ø[¬à#¦}ø #  Remove all left-padded 0s without changing the shape:
        ø        #   Zip/transpose; swapping rows/columns
         [       #   Start an infinite loop:
          ¬      #    Get the first row (without popping the matrix)
           à     #    Pop and push its maximum
            #    #    If this is 1: stop the infinite loop
             ¦   #    If it's a 0 instead: remove this row of 0s
              }ø #   After the infinite loop: zip/transpose back
        0δÜ      #  Remove all left-padded 0s:
         δ       #   Map over each row:
        0 Ü      #    Trim trailing 0s
        0ð:      #  Then replace all 0s with spaces
                 # (after which the list of matrices is output implicitly as result)
</code></pre>
<p>†: Just look at the explanation of some of my existing answers with flood-fills, like <a href="https://codegolf.stackexchange.com/a/278182/52210">this one</a> or <a href="https://codegolf.stackexchange.com/a/282341/52210">this one</a>.</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://www.uiua.org/" rel="nofollow noreferrer">Uiua 0.17.0-dev.1</a>, <sup><strike></strike></sup> 37 bytes <sup><a href="https://t.ly/aly6S" rel="nofollow noreferrer" title="SBCS for Uiua 0.15">SBCS</a></sup></h1>
<pre><code>↘1⊜(□⊏:&quot; o&quot;°⊚-¤/↧.):°⊡↻⊟.¯1⬚1↙+2△.=@ 
</code></pre>
<p><a href="https://uiua.org/pad?src=0_17_0-dev_1__RiDihpAg4oaYMeKKnCjilqHiio86IiBvIsKw4oqaLcKkL-KGpy4pOsKw4oqh4oa74oqfLsKvMeKsmjHihpkrMuKWsy49QCAKWyIjIyMjIyMjIyMjIyMjIyIKICIjIyMgICAgICAgICAgIyIKICIjICMgICMjICMjICAjIyIKICIjICMgICAgICAgICMgICIKICIjIyMjIyMjIyMjIyMjIyJdCgpGCg==" rel="nofollow noreferrer">Try on Uiua Pad!</a></p>
<p>Takes input and output as arrays of single line strings. The main thing that makes this work is multidimensional <code>partition</code> working on contiguous regions. The initial code pads the outer edge so that at the end we can just drop the first &quot;hole&quot;, which is the outside face.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/282411/">282411</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




