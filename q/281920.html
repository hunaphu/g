<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::281920</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td>ğ™µğšğšŒğš” ğšğš›ğšŠğš—ğš—ğš’ğšğšœ</td><td>250523T212317Z</td><td><a href="https://codegolf.stackexchange.com/questions/281920/count-all-the-fish/281937#281937">doppelgr</a></td></tr>
<tr d-ix="1"><td>109</td><td>05AB1E</td><td>250523T141717Z</td><td><a href="https://codegolf.stackexchange.com/questions/281920/count-all-the-fish/281927#281927">Kevin Cr</a></td></tr>
</table>
<div id="pu0" class="pu"><p>ğ™µğšğšŒğš” ğšğš›ğšŠğš—ğš—ğš’ğšğšœ, ğš¢ğš˜ğš ğš ğš’ğš•ğš• ğš—ğšğšŸğšğš› ğš‹ğš ğšŠ ğš›ğšğšŠğš• ğš ğš˜ğš–ğšŠğš—, ğš•ğš˜ğšŸğš ğšğš˜ğš› ğš—ğš’ğšğšğšğš›ğšœ, ğšŒğš‘ğš’ğš—ğš”ğšœ ğšŠğš—ğš ğšğš˜ğš˜ğš”ğšœ</p>
<p>The sequence contains the decimal representation of the binary numbers of the form: 10101..., where the n-th term has n bits.</p>
<p>The sequence is probably easiest to explain by just showing the relationships between the binary and decimal representations of the numbers:</p>
<p>0 -&gt; 0 1 -&gt; 1 10 -&gt; 2 101 -&gt; 5 1010 -&gt; 10 10101 -&gt; 21 101010 -&gt; 42 Challenge: Take an input integer n, and return the first n numbers in the sequence. You may choose to have the sequence 0-indexed or 1-indexed.</p>
<p>Test cases: n = 1 &lt;- 1-indexed 0 The sequence contains the decimal representation of the binary numbers of the form: 10101..., where the n-th term has n bits.</p>
<p>The sequence is probably easiest to explain by just showing the relationships between the binary and decimal representations of the numbers:</p>
<p>0 -&gt; 0 1 -&gt; 1 10 -&gt; 2 101 -&gt; 5 1010 -&gt; 10 10101 -&gt; 21 101010 -&gt; 42 Challenge: Take an input integer n, and return the first n numbers in the sequence. You may choose to have the sequence 0-indexed or 1-indexed.</p>
<p>Test cases: n = 1 &lt;- 1-indexed 0</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, <s>114</s> 109 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>JÃ°Ã½Ã¼3Âº2Î´Ã¤Ëœâ€¦&gt;&lt;&gt;Â¢IÎµN&gt;xs3*&quot;Iâ‚¬Ã¼Ã¿Ã¸â‚¬Ã¼Ã¿&quot;.VÎµDÎµÎµRÎµÂºÎ¸}}}Â«}JNU1DÃºÎµXN+4Ğ¸2.Ã½ZXÄ€+N_XÎ˜*-.Ã¸1Å¡sâ€¢1Ã¸~Ã¼Ã»â€¢S.Î›}Î¸VÎµÎµÂ»YÃâ€¦\/\X&gt;Ã—ÂºQ]ËœO+
</code></pre>
<p>Input as a rectangular matrix of characters.</p>
<p><a href="https://tio.run/##yy9OTMpM/a/n9KhpTfChlf@9Dm84vPfwHuNDu4zObTm85PScRw3L7GzsDi06tO7cVj@7imJjLaVD64CKD@85vP/wDihDSS/s3FaXc1vPbQ06t/XQrnM7amtrD62u9fILNXQ5vOvc1gg/bZMLO4z0Du@NijjSoO0XH3Fuhpau3uEdhkcXFj9qWGR4eEcd0JzdQGaw3rnZted2hIEMO7Q78nA/0AEx@jERdoenH9oVGHt6jr/2//9KSkoKCvoxCkCgD8RcIBLI09eP0ecCCSjE6ANRDFeMgo2djX4M0ANcYHmwKrAGkAqgHIgLNOy/rm5evm5OYlUlAA" rel="nofollow noreferrer">Try it online.</a></p>
<p>I attempted to make a test suite, but it became a complete mess with work-around fixes (mostly because the Canvas should be cleared). Nonetheless, here is one for the original 114 bytes version, with additional <code>.BÃ°Î´ÃœÃµK.BÂ»</code> within the code and <code>X&gt;4Ğ¸2.Ã½Z&gt;.Ã¸1Å¡Ã°â€¢1Ã¸~Ã¼Ã»â€¢S.Î›\</code> after each test case to clear up the Canvas for the next iteration: <a href="https://tio.run/##dVJNaxRBEL3nVzRzNLtTbCIeZOzAkosrbNBgWLVFIngIyETYRIwwEjx5EY8eXAQXESQS9uDIsJsgdOMp0Pgb9o@M9dEzsxt1mI@qV69eVdfU/nD38d6T8nl0M312eHBdRa2jGyvR1uGBeBtxd/7627b9WvbcxJ27s3U7XfPf3eeL0fz4i060HdtTn/f1i@H6lcieItmduZ@uCEYU7/h80@c@v@NzO/VFlmX2JOv1H@31bEEiHw1cm795a8fupH@3s@mmPh/0V6/@LtZid35fx67o/Po0nB@PO654hZIzNLdj/yHzRdx1E@xl5PJbcdfOdqiMnd1z77A1A2ag3Xs7vY0Vs4vR1mrZsj82Vgb6krSb/K1tygcRni1qqQgMKqX0MuQaoxSaJlUIKcUWCJiyD8RSguEHoZTfRBEtoABlsyhpq0QnaGJFxcKqyiCXqUggn7SlrUQ3X7GQBkFPhNHkihD6RmLdF19Si2qHahVatbAAE9o03QQYJwR4HiCzYLhWBRmMjAJEhEkm9EMzqXVBVWyjLncux5LzgZw0zA7vRHOEppDKuCAQ8UpovPhIiGh1DkCTA5U4inIYOCPUJRCAc5Cc1ipMDASuk0KyJB/@jZbdkAWCeoHC0aEe8tKi/ZO3uGr/o4WtbMYpjmpWWDWx5a3lnV0oBuH38rLyHf5bcFi02lUWjR6W7Xa63366@/LoDw" rel="nofollow noreferrer">verify all test cases</a>.</p>
<p><strong>Explanation:</strong></p>

<p>Step 1: Count all small fish (that only use <code>&gt;&lt;</code> as characters):</p>
<pre class="lang-python prettyprint-override"><code>J                       # Join the rows of the (implicit) input-matrix together
 Ã°Ã½                     # Then join this list of lines with space delimiter
                        # (any non-newline delimiter is fine here)
   Ã¼3                   # Split it into overlapping triplets
     Âº2Î´Ã¤Ëœ              # Create a mirrored copy of each triplet:
     Âº                  #  Mirror each inner triplet
       Î´                #  Then map over each sextet:
      2 Ã¤               #   Split it into two equal-sized parts
         Ëœ              #  Flatten this list of pairs
          â€¦&gt;&lt;&gt;Â¢         # Count how many times &quot;&gt;&lt;&gt;&quot; occurs in this list
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/a/n9KhpTfChlf@9Dm84vPfwHuNDu4zObTm85PScRw3L7GzsDi36/19JSUlBQT9GAQj0gZgLRAJ5@vox@lwgAYUYfSCK4YpRsLGz0Y8B6uICy4NVgTWAVADlQFygYf91dfPydXMSqyoB" rel="nofollow noreferrer">Try just step 1 online.</a></p>
<p>Step 2: Count all larger fish (that only use <code>\/ </code> as characters):</p>
<pre class="lang-python prettyprint-override"><code>I                       # Push the input-matrix again
 Îµ                      # Map over each row:
  N&gt;                    #  Push the 1-based row-index
    x                   #  Double it (without popping)
     s                  #  Swap so the 1-based index is at the top again
      3*                #  Multiply it by 3
        &quot;Iâ‚¬Ã¼Ã¿Ã¸â‚¬Ã¼Ã¿&quot;      #  Push this string, where the `Ã¿` are replaced with the 3(N+1)
                        #  and 2(N+1) respectively
                  .V    #  Execute it as 05AB1E code:
         I              #   Push the input-matrix
          â‚¬             #   Map over each row:
           Ã¼Ã¿           #    Split it into overlapping 3(N+1)-sized sublists
             Ã¸          #   Zip/transpose; swapping rows/columns
              â‚¬         #   Map over each list again:
               Ã¼Ã¿       #    Split it into overlapping 2(N+1)-sized blocks
                        #  (we now have a list of overlapping 3(N+1) by 2(N+1) sized blocks
   ÎµDÎµÎµRÎµÂºÎ¸}}}Â«}        #  Create a mirrored copy of each block:
   Îµ           }        #   Map over the list of lists of blocks
    D                   #    Duplicate the current list of blocks
     ÎµÎµ     }}          #    Nested map over each row of each block
       R                #      Reverse the row
        Îµ  }            #      Inner map over each character within this row
         Âº              #       Mirror it
          Î¸             #       Pop and leave the last (mirrored) character
              Â«         #    After the inner maps: merge the lists of blocks together
   J                    #  Join each inner-most row of characters together
    NU                  #  Store the current 0-based map-index in variable `X`
    1DÃº                 #  Push &quot; 1&quot; (push 1; duplicate; pad that many spaces)
       Îµ                #  Inner map over this pair of characters:
        X               #   Push `X`
         N+             #   Add the inner map's 0-based index `N` to it
           4Ğ¸           #   Repeat that four times
             2.Ã½        #   Intersperse with 2s
                Z       #   Push the maximum (the `X+N) without popping the list
                 XÄ€+    #   Add (X&gt;0) to it
                      - #   And then possibly decrease it by:
                 N_     #   (N==0)
                     *  #   AND
                   XÎ˜   #   (X==1)
                 .Ã¸     #   Prepend &amp; append that `X+N+(X&gt;0)-((N==0)*(X==1))`
                   1Å¡   #   And prepend an additional 1
        s               #   Swap so the current character (&quot; &quot; or &quot;1&quot;) is at the top
        â€¢1Ã¸~Ã¼Ã»â€¢         #   Push compressed integer 8332107655
               S        #   Convert it to a list of digits
        .Î›              #   Use the (modifiable) Canvas builtin with these three options
       }Î¸               #  After the map: keep the last one for character &quot;1&quot;
                        #  (the first iteration with &quot; &quot; was to clean the Canvas)
         V              #  Pop and store this fish-shape in variable `Y`
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/a/n9KhpTfChlf@9Dm84vPfwHuNDu4zObTm85PScRw3L7GzsDi06tO7cVj@7imJjLaVD64CKD@85vP/wDihDSS/s3FaXc1vPbQ06t/XQrnM7amtrD62u9fILNXQ5vOvc1gg/bZMLO4z0Du@NijjSoO0XH3Fuhpau3uEdhkcXFj9qWGR4eEcd0JzdQGaw3rnZted2/Nc5tM3@v5KSkoKCfowCEOgDMReIBPL09WP0uUACCjH6QBTDFaNgY2ejHwN0KBdYHqwKrAGkAigH4gIN@6@rm5evm5NYVQkA" rel="nofollow noreferrer">Try this sub-step online to see the created fish-shapes.</a></p>
<pre class="lang-python prettyprint-override"><code> ÎµÎµ                     #  Nested map over each block:
   Â»                    #   Join the lines together with newline delimiter
    Y                   #   Push the fish-shape of 1s from variable `Y`
     Ã                  #   Only keep the characters at the truthy (==1) locations
      â€¦\/\              #   Push string &quot;\/\&quot;
          X&gt;Ã—           #   Repeat it `X+1` amount of times
             Âº          #   Mirror that entire string
              Q         #   Check if the two strings are equal
]                       # Close all maps
 Ëœ                      # Flatten the list of lists of 0s and 1s
  O                     # Sum to see how many were truthy
</code></pre>
<p><a href="https://tio.run/##LU6xSgNBEO3vK5YtE26XSyyPKyRVihMNhlNWJIKFIKa4RoWVwx@wVDCNQQRRgoULyyVB2NEqMPgN9yPr7OEwM8ybefN403JycnbqxXZz@z5yr34IH7CGVd/VPfyE582sqV6yNHNzt0CTZ5dlv8Pdgsiwgi@w/wMXYzQDNGj20Lgardbavelhvp8MoEZT5N2tX9sTsD4svqtuflzgQycWYJOfp7Kp5gnYG9JZ0jgS@KjRjoOYWx7AHRlQUhUZ3Lt692gz2/Gec86YVIxCUkWhE5JSySgsmJKUKlIszVKpyH/U3ltW@xAYdAuQxHwcX0zj88n11R8" rel="nofollow noreferrer">Try just step 2 online.</a></p>
<p>Step 3: Add those counts together, and output the result</p>
<pre class="lang-python prettyprint-override"><code>+                       # Add the sum of larger fish to the count of smaller fish
                        # (after which the result is output implicitly)
</code></pre>
<p><a href="https://codegolf.stackexchange.com/a/166851/52210">See this 05AB1E tip of mine (section <em>How to compress large integers?</em>)</a> to understand why <code>â€¢1Ã¸~Ã¼Ã»â€¢</code> is <code>8332107655</code>.<br />
<a href="https://codegolf.stackexchange.com/a/175520/52210">See this 05AB1E tip of mine</a> to understand how the Canvas builtin works, and why I've used the following options to draw the fish:</p>
<ul>
<li>Character to draw: <code>1</code></li>
<li>Directions to draw in: <span class="math-container">\$[8,3,3,2,1,0,7,6,5,5]\$</span></li>
<li>Lengths of each section: <span class="math-container">\$v=X+N, \\
t=v+(X&gt;0)-(N=0)\times(X=1) \\
[1,t,v,2,v,2,v,2,v,t]\$</span></li>
</ul>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/281920/">281920</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




