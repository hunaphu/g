<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::237291</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>375</td><td>Javascript limBMS</td><td>240618T200016Z</td><td><a href="https://codegolf.stackexchange.com/questions/237291/infinite-ordinals-from-a-well-ordering/273700#273700">Patcail</a></td></tr>
<tr d-ix="1"><td>010</td><td>Charcoal</td><td>211116T111159Z</td><td><a href="https://codegolf.stackexchange.com/questions/237291/infinite-ordinals-from-a-well-ordering/237358#237358">Neil</a></td></tr>
<tr d-ix="2"><td>266</td><td>Python 2</td><td>211115T040643Z</td><td><a href="https://codegolf.stackexchange.com/questions/237291/infinite-ordinals-from-a-well-ordering/237306#237306">cardboar</a></td></tr>
<tr d-ix="3"><td>002</td><td>Husk</td><td>211114T220010Z</td><td><a href="https://codegolf.stackexchange.com/questions/237291/infinite-ordinals-from-a-well-ordering/237301#237301">Dominic </a></td></tr>
<tr d-ix="4"><td>001</td><td>Polyglot</td><td>211116T004721Z</td><td><a href="https://codegolf.stackexchange.com/questions/237291/infinite-ordinals-from-a-well-ordering/237343#237343">Dingus</a></td></tr>
<tr d-ix="5"><td>003</td><td>Haskell</td><td>211114T144804Z</td><td><a href="https://codegolf.stackexchange.com/questions/237291/infinite-ordinals-from-a-well-ordering/237294#237294">Wheat Wi</a></td></tr>
<tr d-ix="6"><td>053</td><td>Haskell</td><td>211115T223818Z</td><td><a href="https://codegolf.stackexchange.com/questions/237291/infinite-ordinals-from-a-well-ordering/237342#237342">AnttiP</a></td></tr>
<tr d-ix="7"><td>006</td><td>Pyth</td><td>211115T000629Z</td><td><a href="https://codegolf.stackexchange.com/questions/237291/infinite-ordinals-from-a-well-ordering/237303#237303">Anders K</a></td></tr>
<tr d-ix="8"><td>048</td><td>Python 2</td><td>211115T025639Z</td><td><a href="https://codegolf.stackexchange.com/questions/237291/infinite-ordinals-from-a-well-ordering/237305#237305">xnor</a></td></tr>
<tr d-ix="9"><td>022</td><td>Haskell</td><td>211115T014332Z</td><td><a href="https://codegolf.stackexchange.com/questions/237291/infinite-ordinals-from-a-well-ordering/237304#237304">xnor</a></td></tr>
<tr d-ix="10"><td>028</td><td>Python 3</td><td>211114T182943Z</td><td><a href="https://codegolf.stackexchange.com/questions/237291/infinite-ordinals-from-a-well-ordering/237299#237299">loopy wa</a></td></tr>
<tr d-ix="11"><td>054</td><td>Retina 0.8.2</td><td>211114T153100Z</td><td><a href="https://codegolf.stackexchange.com/questions/237291/infinite-ordinals-from-a-well-ordering/237296#237296">Neil</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Javascript (lim(BMS),375)</h1>
<p>See this <a href="https://codegolf.stackexchange.com/questions/48931/make-the-largest-infinity-that-you-can/273698#273698">similar answer</a>, which uses the Bashicu Matrix System.</p>
<p>This is the code, where comparison is C(x)(y):</p>
<pre><code>J=JSON.stringify
R='replaceAll'
N=x=&gt;x.toString(2).split`0`.map(x=&gt;x.length)
L=x=&gt;x[R]('[','')[R](']','+')
E=(A,n)=&gt;{if(!A?.[0])return &quot;[]&quot;
p=A.pop()
B=J(Object.assign([...p],A))
for(_=n;n--;)B=B[R](J(p),B)
return +p?J(Array(_).fill([])):B}
C=x=&gt;y=&gt;{M=x&gt;y?x:y
A=[]
for(i=1;A.length&lt;=M;i++)q='[[1]]',N(i).map(x=&gt;q=E(eval(q),x)),A.includes(q)||A.push(q)
return L(A[x])&lt;L(A[y])}
</code></pre>
<h2>Analysis</h2>
<h3>Header</h3>
The header consists of four helper functions
<pre><code>J=JSON.stringify
R='replaceAll'
N=x=&gt;x.toString(2).split`0`.map(x=&gt;x.length)
L=x=&gt;x[R]('[','')[R](']','+')
</code></pre>
<p>Here, <code>N</code> performs a bijection from a positive number into an array of nonnegative numbers by using the binary expansion. Technically, it is not a bijection since the first entry of the output array is never zero, but this works well enough for our purposes.</p>
<p><code>L</code> is a function that strips away all of the left brackets and turn all the right brackets into pluses. This is used later for lexicographic comparison, since the <code>+</code> comes before <code>,</code> in ASCII.</p>
<h3>Body</h3>
<pre><code>E=(A,n)=&gt;{if(!A?.[0])return &quot;[]&quot;
p=A.pop()
B=J(Object.assign([...p],A))
for(_=n;n--;)B=B[R](J(p),B)
return +p?J(Array(_).fill([])):B}
</code></pre>
<p>This is basically the same thing as in a <a href="https://codegolf.stackexchange.com/questions/48931/make-the-largest-infinity-that-you-can/273698#273698">similar answer</a>, but this time we use <code>n</code> specific iterations. <code>E</code> takes in a recursive PAS array and an expanding number <code>n</code> and returns the expanded string. Successor ordinal (a+1) satisfy (a+1)[n] = a</p>
<h3>Comparison</h3>
<pre><code>C=x=&gt;y=&gt;{M=x&gt;y?x:y
A=[]
for(i=1;A.length&lt;=M;i++)q='[[1]]',N(i).map(x=&gt;q=E(eval(q),x)),A.includes(q)||A.push(q)
return L(A[x])&lt;L(A[y])}
</code></pre>
<p>We first set i=1 and then run through all possible natural number arrays N(i). After that, we applied those numbers as expansion numbers for the fundamental sequence of <code>q</code>, where <code>q</code> started as <code>[[1]]</code> = lim(BMS). After expansions, we determine whether we have seen that ordinal before or not. If we did not, we add that ordinal to the big list <code>A</code>.</p>
<p>After we generate our list of ordinals <code>A</code>, we compare <code>A[x]</code> against <code>A[y]</code>. PAS has a simple comparison algorithm: remove all of the left brackets and then compare lexicographically under <code>[</code>&lt;<code>,</code>. This is what <code>L</code> was used for.</p>
<h2> Sample Ordinals </h2>
<pre><code>A[0]  = 1     //technically we should exclude A[0], but this doesn't change the order type of the overall ordinal.
A[1]  = 0
A[2]  = ω
A[3]  = ε_0
A[4]  = 2
A[5]  = ψ(Ω_ω)
A[6]  = 4
A[7]  = ω^ω
A[8]  = (0,0,0,0)(1,1,1,1)   // this is very big ordinal
A[9]  = 3
A[10] = 8
A[11] = ω^2
A[12] = ω^(ω^(ω^ω))
A[13] = ψ(Ω_2) = BHO
A[14] = (0,0,0,0,0)(1,1,1,1,1)
A[15] = 7
A[16] = 16
A[17] = ω+1
A[18] = ω^3
A[19] = ω^(ω^(ω^2))
A[20] = ω^(ω^(ω^(ω^(ω^(ω^(ω^ω))))))
A[21] = ψ(Ω^2) = ζ_0
A[22] = ψ(Ω_4)
A[23] = (0,0,0)(1,1,1)(2,2,2) = Small Bashicu Ordinal
A[24] = (0,0,0,0,0,0)(1,1,1,1,1,1)
A[25] = 6
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, <span class="math-container">\$ω^2\$</span>, 10 bytes</h1>
<pre><code>‹⟦ΣθＮ⟧⟦ΣηＮ
</code></pre>
<p><a href="https://tio.run/##S85ILErOT8z5/z@gKDOvRMMntbhYIzq4NFejUFNHwTOvoLTErzQ3KbVIQzNWRwEskYEhoalp/f@/oYEll6Xlf92yHAA" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Orders by sum of digits, then regular ascending order, resulting in the following ordering:</p>
<p><code>1, 10, 100, ..., 2, 11, 20, 101, 200, ..., 3, 12, 21, 30, 102, 111, 120, 201, 210, 300, ..., 4, 13, 22, 31, 40, 103, 112, 121, 130, 202, 211, 220, 301, 400 ..., ...</code></p>
<h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, <span class="math-container">\$ω^2\cdot 9\$</span>, 14 bytes</h1>
<pre><code>‹⟦⌈θΣθＮ⟧⟦⌈ηΣηＮ
</code></pre>
<p><a href="https://tio.run/##S85ILErOT8z5/z@gKDOvRMMntbhYI9o3sSIztzRXo1BTRyEYSnvmFZSW@JXmJqUWaWjG6ijAFWVAFWVgKNLUtP7/39DAksvS8r9uWQ4A" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Orders by greatest digit, then sum of digits, then regular ascending order, resulting in the following ordering:</p>
<p><code>1, 10, 100, ..., 11, 101, ..., 111, ..., ... 2, 20, 200, ..., 12, 21, 102, 120, 201, 210, ..., 22, 112, 121, 202, 211, 220, ..., ... 9, 90, 900, ..., 91, 109, 190, 901, 910, ..., 92, 119, 191, 209, 290, 902, 911, 920, ..., ...</code></p>
<h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, <span class="math-container">\$ω^3\$</span>, 16 bytes</h1>
<pre><code>‹⟦ΣΣθΣθＮ⟧⟦ΣΣηΣηＮ
</code></pre>
<p><a href="https://tio.run/##S85ILErOT8z5/z@gKDOvRMMntbhYIzq4NFcDhAs1NXUUIAwdBc@8gtISv9LcpNQiDc1YHQW4qgyYqgwMVZqa1v//GxpYclla/tctywEA" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Orders by sum of digits of sum of digits, then sum of digits, then regular ascending order, resulting in the following ordering:</p>
<p><code>1, 10, ..., 19, 28, 37, 46, 55, 64, 73, 82, 91, ..., ... 2, 11, 20, ..., 29, 38, 47, 56, 65, 74, 83, 92, ..., ... 3, 12, 21, 30, ..., 39, 48, 57, 66, 75, 84, 93, ..., ... 4, 13, 22, 31, 40, ..., 49, 58, 67, 76, 85, 94, ..., ...</code></p>
<h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, <span class="math-container">\$ω^ω\cdot 9\$</span>, 29 bytes</h1>
<pre><code>Ｆ²⊞υ⟦Ｎ⟧Ｗ›⌈Ｅυ⌊κ⁹Ｆυ⊞κΣ⌊κ›⮌⊟υ⮌⊟υ
</code></pre>
<p><a href="https://tio.run/##XYy9CsIwFIX3PMUdcyEOuoU@gDhUQh3FIZZIQvNT0qT69jEpIuJ0OIfvfKOWcQzSlvIIEegBQeRF08zgevJzTufs7ipSvGFHntpYBfQYlUx16@XLuOxqzo3vjd/qhIgMOCJsxvwxTgwuDf6hOiKi8ekrHNSq4qKoCFXYJH9DfZSy55xwXnarfQM" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Repeatedly sums the digits of the inputs until they both reach their digital root, then compares the results in reverse order from the digital root working back to the original input. Since there are 9 digital roots and a potentially arbitrary number of summation steps I think I have the correct value for this. For small inputs the ordering is the same as the previous version; it first diverges for 199, which for instance compares less than 99 here but not in the previous ordering.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>, <span class="math-container">\$\psi_0(\Omega^{\Omega^\omega})\cdot\omega\$</span> with respect to Buchholz's psi, 266 bytes</h1>

<pre class="lang-python prettyprint-override"><code>l=len
T=lambda i,s='(',d=1:T(i/2,s+['),','('][i%2],d+i*2%4-1)if d else(eval(s)[0],i)
L=lambda A,B:any(A==b or L(A,b)for b in B)or all(L(a,B)for a in A)and(l(A)-l(B),0)&lt;(0,next((L(a,b)for a,b in zip(A,B)if a!=b),0))
def f(a,b):A,a=T(a);B,b=T(b);return(a,0)&lt;(b,L(A,B))
</code></pre>
<p><a href="https://tio.run/##hVTLbtswEDxbX7GBUZismVaSe0orFDZQ9OKj0R4MJ6AsOmEqUwKp1HF/Pl0@9HJSND5EmhkOl7vi1OfmoVLpy0uZlUJFm6zkx7zgIJnJZmTGiiy52RD5MWVmvp1RNmOI7rbyXbpjxVy@T999uk6oPEABojSCiN@8JIZu4x2TNFq3dku2uuHqTJZZlkOlYU2WLKcHfMpBKlhRfOJlSdaEs5XDucWXlKuClGRJr0uyoiymX0jMlHhuiJN6C/xvxX9kja4rWwy/ynKrplEhDnBwypsl49mGcPp5xXJ8yOlnLZonrZC1vjlbu@X0ZQobYRpoHngDG6h1VQtdnqHRXJmSN8KAejrmQhtoKkQFAnPQ4silKoSONnd7bhDLYBtNtnEeMyCUAXbEvSbhPQnvcZwggMhIMwAHwhYdq2NkHOHgS6JbY9nRHvb3psJzqNtFkW2wZPaUrDui7XY45U00wX7jF0LhKgMy1lFkJ5pLI@Db817UjawUmf3Ulbp3fbua0SgadnsNp0r/MsANiOda7BtRQKXAVEfhG/0hwvY3d77prsG2lZd/U4iR8E26IBJLtH0aEqkjAtNzU1h4K0LHZlM4AZFHfi@VcMXPsGwFWOk9p2ETu2awyi6Zhwo6tuU9mYbNwiQG5Z1aT0/1y9LO1JL@AD27OPWOuGHnidvdpgNLx3nWUReertYx3RfU86jo6JFDf9yBJB3WFmqwe1h@0c2JjBtxuj31kyKjTiDV9ddzZHzgV2vJ4EwjuiVJV9BA4O7fRVmiNrKsVNxtflFbyw8KvLCZwnd@PPJ4sMOIrXQhFS@hOuDnhp@c0IrrM/wQOQY3PEihud4/nIHXNddCNeX5q72//gLbG4vxdS8Iikl/h6i9olbx2CvkHPPgDdmE443rsa3cIZaPsUfccWITYY15yqmNelXhvfYJjNTrOFjxwt1t2FdHrFyaSrlcwGBYlqZy7oAhjlYuB0L2hiSQqglBMMEedcnDvGXoWTRxKRyigdl0CLkbgCQAFnLAyQJJHD6OJCxJvMQBQRF7j7RXeI80mCZJUCxaRRIUi1YRO5MpfLKK3b8HZo/6/3l1qn5cFrqYloMed35Wh9GsDv@ZFS59NapaI0pmNsgN1NwYUXywxMtf" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>
<p>At least I think that's how this ordinal is written. It's a little bigger than the <a href="https://en.wikipedia.org/wiki/Small_Veblen_ordinal" rel="nofollow noreferrer">Small Veblen ordinal</a>.</p>
<p><code>T</code> is a bijective function that maps natural numbers <code>n</code> to tuples <code>(tree,remainder)</code> of ordered trees and natural numbers. It does so by treating the reversed binary representation of the input as a sequence of <code>(</code>s and <code>)</code>s, prepended by an extra <code>(</code>. Once the initial <code>(</code> is given a matching <code>)</code>, the unused bits form the remainder. For example, <code>37</code> is <code>100101</code> in binary, which gets reversed to <code>101001</code> which becomes <code>( ()()) 1</code>, giving <code>(()())</code> as the tree and <code>1</code> as the remainder.</p>
<p><code>L</code> is a well ordering of ordered trees, the ordinal of which is the small Veblen ordinal. It is taken from Jervell, Herman Ruge (2005), &quot;Finite Trees as Ordinals&quot; (which I found via the Wikipedia article linked above). I horizontally mirrored it because it made the code shorter.</p>
<p><code>f</code> accepts 2 natural numbers, converts them to <code>(tree,remainder)</code> tuples, and compares these by remainder first, then by tree.</p>
<p>Numbers which map to tuples in the form <code>(tree, 0)</code> form the small Veblen ordinal.</p>
<p>Tuples in the form <code>(tree, 1)</code> come next, then <code>(tree, 2)</code>, <code>(tree, 3)</code> etc. for a total of <span class="math-container">\$\omega\$</span> copies of the small Veblen ordinal, which I think is written <span class="math-container">\$\phi_{\Omega^\omega}(0)\cdot\omega\$</span>.</p>
<p>Note: while I defined <code>f</code> in terms of non-negative integers, the ordinal doesn't change if you only use strictly positive integers.</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/barbuz/Husk" rel="nofollow noreferrer">Husk</a>, <span class="math-container">\$\omega\$</span>, 2 bytes</h1>
<pre><code>¬&lt;
</code></pre>
<p><a href="https://tio.run/##yygtzv6f6/aoqfH/oTU2////j4421DGO1Yk2ApPGYNIETJqCSTMwaQ4mLcCkJZg0NABSsQA" rel="nofollow noreferrer" title="Husk – Try It Online">Try it online!</a></p>
<p>Boring single-omega solution: well-ordering is just normal integer order (example 1 in question).</p>
<hr />
<h1><a href="https://github.com/barbuz/Husk" rel="nofollow noreferrer">Husk</a>, <span class="math-container">\$\omega\$</span>+1, 7 bytes</h1>
<pre><code>¬F&lt;σ7\0
</code></pre>
<p><a href="https://tio.run/##yygtzv6f@6ip8f@hNW4255vNYwz@//8fHW2oYxSrE22kYwgkDXXMgaQ5mG0BZVvExgIA" rel="nofollow noreferrer" title="Husk – Try It Online">Try it online!</a></p>
<p>Omega+1: well-ordering is integers starting at 1 in normal order, but missing 7, and finally with 7 last, so: 1,2,3,4,5,6,8,9,10,...,7.<br />
Change the <code>7</code> in the code to select any other digit at the end.</p>
<hr />
<h1><a href="https://github.com/barbuz/Husk" rel="nofollow noreferrer">Husk</a>, <span class="math-container">\$\omega\$</span>.2, 11 bytes</h1>
<pre><code>¬F&lt;m?o_\I%2
</code></pre>
<p><a href="https://tio.run/##yygtzv6f@6ip8f@hNW42ufb58TGeqkb///@PjjbWMYzVAZJGYNIETJoCSROwuAlY3AQqYhYbCwA" rel="nofollow noreferrer" title="Husk – Try It Online">Try it online!</a></p>
<p>Odd numbers first, then even numbers, so: 1,3,5,7,...,2,4,6,8,... .</p>
<hr />
<h1><a href="https://github.com/barbuz/Husk" rel="nofollow noreferrer">Husk</a>, <span class="math-container">\$ω^ω\$</span>, 6 bytes</h1>
<pre><code>¬¤&lt;(↔p
</code></pre>
<p><a href="https://tio.run/##yygtzv7//9CaQ0tsNB61TSn4//@/8X8zAA" rel="nofollow noreferrer" title="Husk – Try It Online">Try it online!</a></p>
<p>Port of <a href="https://codegolf.stackexchange.com/a/237296/95126">Neil's omega^omega approach</a>: gets the reversed (<code>↔</code>) <code>p</code>rime factors of each <code>¤</code> argument, and compares them lexicographically (<code>&lt;</code>), finally taking the logical NOT (<code>¬</code>) to ensure only two output values.</p>
<hr />
<h1><a href="https://github.com/barbuz/Husk" rel="nofollow noreferrer">Husk</a>, <span class="math-container">\$ω^ω\$</span>+1, 12 bytes</h1>
<pre><code>¬¤&gt;?o↔pȯ;\←←
</code></pre>
<p><a href="https://tio.run/##yygtzv7//9CaQ0vs7PMftU0pOLHeOuZR2wQg@v//v5HJf0MjAA" rel="nofollow noreferrer" title="Husk – Try It Online">Try it online!</a></p>
<p>Lexicographic ordering of reversed prime factors of inputs minus 1, but finally with <code>1</code> last: subtract 1 (<code>←</code>) from each (<code>¤</code>) input, then if the result is falsey (zero), convert it to a list containing infinity (<code>ȯ;\←</code>), otherwise make a list of its reversed (<code>↔</code>) <code>p</code>rime factors, before comparing them (<code>&gt;</code>) and taking the logical NOT (<code>¬</code>).</p>
</div>
<div id="pu4" class="pu"><h1>Polyglot, <span class="math-container">\$(\omega, 1)\$</span></h1>
<p>Feel free to add languages to the list.</p>
<pre class="lang-none prettyprint-override"><code>&lt;
</code></pre>
<p>Try it in:</p>
<ul>
<li><a href="https://tio.run/##S0wuKU3Myan8/9/m/39DUxNzE2NTQyNTAzMzQ0NLLgsjM0tLA2Mzc1NjQ0MLQyMA" rel="nofollow noreferrer" title="Actually – Try It Online">Actually</a>. Outputs <code>0</code>/<code>1</code>.</li>
<li>APL family languages: <a href="https://tio.run/##SyzI0U2pTMzJT///P@1R2wSb//8NTU3MTYxNDY1MDczMDA0tFdIULIzMLC0NjM3MTY0NDS0MjQA" rel="nofollow noreferrer">APL</a>, <a href="https://tio.run/##BcHJEQAgCASwViiB5cbRdnzY/x@TN3PP2jNwS1OHOEcATZdKops10hUoyAc" rel="nofollow noreferrer">J</a>, <a href="https://ngn.bitbucket.io/k/#eJwFwckRACAIBLA/1bDcqJ04fum/BJNZh2gu3NLUIc4RQO+S6GaNdAUK8j66FgjN" rel="nofollow noreferrer">K</a>, <a href="https://mlochbaum.github.io/BQN/try.html#code=RuKGkDwKMTU0NzQzNTEyNTA2NjExOSBGIDgyNjk5MDM2NzUzMTE4MTI=" rel="nofollow noreferrer">BQN</a>. Outputs <code>1</code>/<code>0</code>.</li>
<li><a href="https://tio.run/##BcHJDQAgDAOwlZrelViHD2IBpg/22fc@cpFEeLkFNCQTGLbmjFhWGNDQDw" rel="nofollow noreferrer" title="Jelly – Try It Online">Jelly</a>. Outputs <code>1</code>/<code>0</code>.</li>
<li><a href="https://tio.run/##y05N///f5v9/Q1MTcxNjU0MjUwMzM0NDSy4LIzNLSwNjM3NTY0NDC0MjAA" rel="nofollow noreferrer" title="Keg – Try It Online">Keg</a>. Outputs <code>0</code>/<code>1</code>.</li>
<li><a href="https://tio.run/##y00syUjPz0n7/9/m/39DUxNzE2NTQyNTAzMzQ0NLBQsjM0tLA2Mzc1NjQ0MLQyMA" rel="nofollow noreferrer" title="MathGolf – Try It Online">MathGolf</a>. Outputs <code>0</code>/<code>1</code>.</li>
<li><a href="https://tio.run/##BcGxEQAgCASw3ml4kAfuXMZeO/fH5O53ulc3fMY0h7qQQI1UVokx3ICEfg" rel="nofollow noreferrer" title="MATL – Try It Online">MATL</a>. Outputs <code>1</code>/<code>0</code>.</li>
<li><a href="https://tio.run##BcG5EQAgCATA3Go44HhmLMrAxOpx97w7s2dATzdCKRFAr9LoFoukAQX9" rel="nofollow noreferrer" title="Pyt – Try It Online">Pyt</a>. Outputs <code>False</code>/<code>True</code>.</li>
<li><a href="https://tio.run/##Ky5JrPj/3@b/f0NTE3MTY1NDI1MDMzNDQ0sFCyMzS0sDYzNzU2NDQwtDIwA" rel="nofollow noreferrer" title="Stax – Try It Online">Stax</a>. Outputs <code>1</code>/<code>0</code>.</li>
<li><a href="https://lyxal.pythonanywhere.com?flags=&amp;code=%3C&amp;inputs=1547435125066119%0A8269903675311812&amp;header=&amp;footer=" rel="nofollow noreferrer">Vyxal</a>. Outputs <code>0</code>/<code>1</code>.</li>
</ul>
<p>Also one byte in <a href="https://tio.run/##yy9OTMpM/f//UcPO//8NTU3MTYxNDY1MDczMDA0tuSyMzCwtDYzNzE2NDQ0tDI0A" rel="nofollow noreferrer" title="05AB1E – Try It Online">05AB1E</a>, but <code>‹</code> instead of <code>&lt;</code>. Outputs <code>0</code>/<code>1</code>.</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, <span class="math-container">\$(\omega, 3)\$</span></h1>
<p>This solution is dead simple, really can't be beat in Haskell.</p>

<pre class="lang-hs prettyprint-override"><code>(&lt;)
</code></pre>
<p><a href="https://tio.run/##y0gszk7Nyfn/P81Ww0bzf25iZp5tQVFmXolKmoKRgonpfwA" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
<h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, <span class="math-container">\$(\omega+n,19+2\left\lfloor\log_{10}(n+1)\right\rfloor)\$</span></h1>
<p>Here's a scheme to get <span class="math-container">\$\omega + n\$</span> for any <span class="math-container">\$n\in\mathbb{N}\$</span>.  Just replace the <code>9</code>s below with one more than <span class="math-container">\$n\$</span>.  This will make the first <span class="math-container">\$n\$</span> numbers bigger than all other numbers but otherwise compare normally.</p>
<pre class="lang-hs prettyprint-override"><code>x#y=(x&lt;9,x)&lt;(y&lt;9,y)
</code></pre>
<p><a href="https://tio.run/##y0gszk7NyfmfmVuQX1Si4JJYkqjnk1lc8r9CudJWo8LGUqdC00ajEkhXav5Pzs8tUEhUSKpJtLVNsnUNrElUTrL1CeGCidu6h3DlJmbm2RYUZeaVqBQDTXSqVADLRhvq6RkaGMT@BwA" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
<p>Looks like the leader board should now have an infinite number of winners.  However we can beat an infinite number of these pretty easily.  Most of this can just be done by fiddling with things a little bit up until we hit 26 bytes. So I will present my scores for 21, 23 and 25 without individual commentary. They should be pretty clear modifications of the 19 byte case.</p>
<h3>21 bytes, <span class="math-container">\$\omega+98\$</span></h3>
<pre class="lang-hs prettyprint-override"><code>x#y=(x&lt;99,x)&lt;(y&lt;99,y)
</code></pre>
<h3>23 bytes, <span class="math-container">\$\omega+387420488\$</span></h3>
<pre class="lang-hs prettyprint-override"><code>x#y=(x&lt;9^9,x)&lt;(y&lt;9^9,y)
</code></pre>
<h3>25 bytes, <span class="math-container">\$\omega+9^{99}-1\$</span></h3>
<pre class="lang-hs prettyprint-override"><code>(.q).(&lt;).q
q x=(x&lt;9^99,x)
</code></pre>
<p>Luckily this wraps up by 26 we can get to a much larger ordinal:</p>
<h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, <span class="math-container">\$(\omega\cdot n,26+\left\lfloor\log_{10}(n)\right\rfloor)\$</span></h1>
<p><em>Thanks to the OP for pointing out that I didn't need division for this.</em></p>
<p>Another scheme much like the last, replace <code>9</code> with the desired number.</p>

<pre class="lang-hs prettyprint-override"><code>(.q).(&lt;).q
q x=(mod x 9,x)
</code></pre>
<p><a href="https://tio.run/##y0gszk7Nyfn/P81WQ69QU0/DRlOvkKtQocJWIzc/RaFCwVKnQvN/bmJmnm1BUWZeiUqagomCsel/AA" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
<p>Once again we can use kolmogorov complexity to improve some of these.   Here's a few that are currently records for their respective program sizes.</p>
<h3>28 bytes, <span class="math-container">\$\omega\cdot 9^9\$</span></h3>
<pre class="lang-hs prettyprint-override"><code>(.q).(&lt;).q
q x=(x`mod`9^9,x)
</code></pre>
<h3>29 bytes, <span class="math-container">\$\omega\cdot 9^{99}\$</span></h3>
<pre class="lang-hs prettyprint-override"><code>(.q).(&lt;).q
q x=(x`mod`9^99,x)
</code></pre>
<h3>30 bytes, <span class="math-container">\$\omega\cdot 9^{9^9}\$</span></h3>
<pre class="lang-hs prettyprint-override"><code>(.q).(&lt;).q
q x=(x`mod`9^9^9,x)
</code></pre>
<h3>31 bytes, <span class="math-container">\$\omega\cdot 9^{9^{99}}\$</span></h3>
<pre class="lang-hs prettyprint-override"><code>(.q).(&lt;).q
q x=(x`mod`9^9^99,x)
</code></pre>
<h3>32 bytes, <span class="math-container">\$\omega\cdot 9^{9^{9^9}}\$</span></h3>
<pre class="lang-hs prettyprint-override"><code>(.q).(&lt;).q
q x=(x`mod`9^9^9^9,x)
</code></pre>
<h3>33 bytes, <span class="math-container">\$\omega\cdot 9^{9^{9^{99}}}\$</span></h3>
<pre class="lang-hs prettyprint-override"><code>(.q).(&lt;).q
q x=(x`mod`9^9^9^9,x)
</code></pre>
<h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, <span class="math-container">\$(\omega^\omega, 63)\$</span></h1>
<p>Implements the order for <span class="math-container">\$\omega^\omega\$</span> in the question.</p>
<pre class="lang-hs prettyprint-override"><code>n#1=[]
n#a|mod a n&lt;1=n#div a n++[n]|m&lt;-n+1=m#a
y=(.(2#))
f=y.y(&lt;)
</code></pre>
<p><a href="https://tio.run/##PY6xCoMwFEX3fEUgHRRpMJ19S2np4lJwE4dnVRqaPK2mhUD@PdVCu93DPXDvHZdHb0zUdhpnx58vNHrQfcdP6FCWenGRhIK6YSQw2LHjyKlQQKLT7y1nWU1NsMWeMgVWIPOQyOQg0pQN4KVPijTeRjutbhsQoIXzNQwbQVmxXwOXilnUBNOsye3@43JZXx09/3q1klLleRM/" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
<h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, <span class="math-container">\$(\phi_{\Omega^\omega}(0)\cdot\omega,208)\$</span></h1>
<p>This implements the same ordinal as in <a href="https://codegolf.stackexchange.com/a/237306/56656">cardboard_box's answer</a>.  It's slightly bigger than the small Veblen ordinal <span class="math-container">\$\phi_{\Omega^\omega}(0)\$</span>.</p>
<p>This could certain be golfed more.  I'm not sure that either the type or the instance are really necessary, but for now it puts Haskell back on the leaderboard.</p>

<pre class="lang-hs prettyprint-override"><code>data T=T[T]deriving Eq
instance Ord T where a&lt;=b=a==b||a&lt;b;T a&lt;T b=any(T a&lt;=)b||(all(&lt;T b)a&amp;&amp;(l a,a)&lt;(l b,b))
l=length
c x|odd x,(y,t)&lt;-c$div x 2=(T t:)&lt;$&gt;c y|1&gt;0=(div x 2,[])
g f x|(y,t)&lt;-c x=f(T t,y)
g.g(&lt;)
</code></pre>
<p><a href="https://tio.run/##hVLbitswEH3XVwxsWGxwir2l0Iu1T01LYWEp67cQythWZFFZztrKOqHpt6cj52bnQjHBztGZc86MpsDmt9B6@2d8B09o5BKlgBeLJkddGfFV1OpNGQl347/bHC1CwpNpMssP@OSVKdMQPxPwXOeQQFuIWgDGPOXIebrZYJx@SQhIgBCz9tw39@nAQ609B/t4f@9pwAD9mN5pkPo@01wLI23BMlhtqjyHVeCtA@vH42yUqzdYwQMnLfvZj0ePGaw30WPIvf1JMJ35TMKcSg9FsOJzxw/WPptz@U56sb899nFs4qWoWkgYG4/huRQSWQscqOXpLKDfrDv4YayQoobKESCNwoi1vxT/cKoCW4EtxI7B2oOGU7gl069wmmFEqk42@tSxJ4tG0ZWAwaUsLBNhP9elqBjQu5AUU4Qk@BB1zG9iLuoSDbW8FNaSdZ0rg5rJ8Czupfqt2p2Piy6d08f3jJWoDM8rBrColbEwggyoreH/c8DlHABOjhFyHLB4XaJu9gPuMatygbR/LT2cw@TnoEg1oEXT0KAp@uXYr@t0Qk9J73DuGtiF7qsPbpCsZC3Q0rBObtcM9km/J7eTDu/yakq3DldTitPghht0PeH/5kE@7SHvwOrM67Qg2dmGqKYz0FhL0fSbKXGlymUJ0zZo20CEgQxnzkmGF03J4Xrs7S9Ql6dDt/8A" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
<h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, <span class="math-container">\$(\phi_{\Omega^\omega}(0)^n\cdot\omega,218+2n)\$</span></h1>
<p>This example code at 222 bytes, iterates the previous algorithm twice. Giving <span class="math-container">\$\phi_{\Omega^\omega}(0)^2\cdot\omega\$</span>.</p>
<pre class="lang-hs prettyprint-override"><code>data T=T[T]deriving Eq
instance Ord T where a&lt;=b=a==b||a&lt;b;T a&lt;T b=any(T a&lt;=)b||(all(&lt;T b)a&amp;&amp;(l a,a)&lt;(l b,b))
l=length
c x|odd x,(y,t)&lt;-c$div x 2=(T t:)&lt;$&gt;c y|1&gt;0=(div x 2,[])
g f x|(y,t)&lt;-c x=(T t,f y)
r=g$g id
f=(.r).(&lt;).r
</code></pre>
<p><a href="https://tio.run/##hVPvi9pAEP2@f8XAyZG0URKPQq9171NtKRwc5fJNpKxmXJcmG2@zGqXe325nE3/GSAkSeTvz3pvZl7ko/mCa7v527@BZaLkUEuHVCp2INNf4DY1aKS3hrvu@S4QVEPN4FI@TAz58Y0oXVD9FeDEJxFDO0SCIAZ9wwflkuxWDydeYgBgI0RvP/ec@HXgiTT0H@@L@3ktBBMIf0HsSTHyfpTxFLe2cTWG9zZME1oG3Caw/6E47iVrBGvqcuOwXf9B5msJmGz2F3NufBKOxzyTMqPXQBOuqPJjBxmeGy44ElbAZ93rG73kDv2d2x6mOI73O8xJixrpdeMlQClYCB1rAaBzQb1wd/NQWJRrIXQFMojBi5W/FP526wOZg51hXsPLA4Rhu0Zx3OM4wIlZHGz1W1cNFoeiCQIulnFuG4bmva1K8KK9Mkk0MibAfVZXfcYYmE5pGXqK1JG0SpUXKZNiwe81@q7fWcdalU/r8UK9kf1gqCwUNCCnObL5CUzCDmQsRh@jxw0P/I60wE0rzJGcAC6O0hQ64awPaxBXUgrkBm5hswWrdM9Q0FEyT3jS5TZPYHFgJOwYB35YiLfZBONVO82wh6Ksp6eEchr8umlRBKyoKCgSt@Doe7TwV0XN8djhzM9VznLNfJI2kpEFh6VJPam0Ce6c/4ttOLzPX6tLFttVltdya@TLp7Q7/tw/SKQ9@L6QaWqcgTxtJVkUlkAojsTgfJhNrlS0zGJVBWQYYBjIcOyUZXg3VCMhe/gp1fip09w8" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
<p>Every time we add a <code>g$</code> to the front of the definition of <code>r</code> we add 1 to the power at the cost of two bytes.</p>
<hr />
<h2>Haskell Leaderboard</h2>
<p><s>Since Haskell has been complete removed from the main leaderboard,</s> for now I am maintaining a short list of Haskell winners here</p>
<div class="s-table-container">
<table class="s-table">
<thead>
<tr>
<th style="text-align: right;">Bytes</th>
<th style="text-align: center;">Value</th>
<th style="text-align: left;">Author</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: right;">3</td>
<td style="text-align: center;"><span class="math-container">\$\omega\$</span></td>
<td style="text-align: left;">Grain Ghost</td>
</tr>
<tr>
<td style="text-align: right;">19</td>
<td style="text-align: center;"><span class="math-container">\$\omega+8\$</span></td>
<td style="text-align: left;">Grain Ghost</td>
</tr>
<tr>
<td style="text-align: right;">21</td>
<td style="text-align: center;"><span class="math-container">\$\omega+98\$</span></td>
<td style="text-align: left;">Grain Ghost</td>
</tr>
<tr>
<td style="text-align: right;">22</td>
<td style="text-align: center;"><span class="math-container">\$\omega\cdot 2\$</span></td>
<td style="text-align: left;"><a href="https://codegolf.stackexchange.com/a/237304/56656">xnor</a></td>
</tr>
<tr>
<td style="text-align: right;">24</td>
<td style="text-align: center;"><span class="math-container">\$\omega\cdot 4\$</span></td>
<td style="text-align: left;"><a href="https://codegolf.stackexchange.com/a/237304/56656">xnor</a></td>
</tr>
<tr>
<td style="text-align: right;">25</td>
<td style="text-align: center;"><span class="math-container">\$\omega\cdot 12\$</span></td>
<td style="text-align: left;"><a href="https://codegolf.stackexchange.com/a/237304/56656">xnor</a></td>
</tr>
<tr>
<td style="text-align: right;">26</td>
<td style="text-align: center;"><span class="math-container">\$\omega\cdot 32\$</span></td>
<td style="text-align: left;"><a href="https://codegolf.stackexchange.com/a/237304/56656">xnor</a></td>
</tr>
<tr>
<td style="text-align: right;">27</td>
<td style="text-align: center;"><span class="math-container">\$\omega\cdot 99\$</span></td>
<td style="text-align: left;">Grain Ghost</td>
</tr>
<tr>
<td style="text-align: right;">28</td>
<td style="text-align: center;"><span class="math-container">\$\omega\cdot 9^9\$</span></td>
<td style="text-align: left;">Grain Ghost</td>
</tr>
<tr>
<td style="text-align: right;">29</td>
<td style="text-align: center;"><span class="math-container">\$\omega\cdot 9^{99}\$</span></td>
<td style="text-align: left;">Grain Ghost</td>
</tr>
<tr>
<td style="text-align: right;">30</td>
<td style="text-align: center;"><span class="math-container">\$\omega\cdot 9^{9^9}\$</span></td>
<td style="text-align: left;">Grain Ghost</td>
</tr>
<tr>
<td style="text-align: right;">31</td>
<td style="text-align: center;"><span class="math-container">\$\omega\cdot 9^{9^{99}}\$</span></td>
<td style="text-align: left;">Grain Ghost</td>
</tr>
<tr>
<td style="text-align: right;">32</td>
<td style="text-align: center;"><span class="math-container">\$\omega\cdot 9^{9^{9^9}}\$</span></td>
<td style="text-align: left;">Grain Ghost</td>
</tr>
<tr>
<td style="text-align: right;">33</td>
<td style="text-align: center;"><span class="math-container">\$\omega\cdot 9^{9^{9^{99}}}\$</span></td>
<td style="text-align: left;">Grain Ghost</td>
</tr>
<tr>
<td style="text-align: right;">34</td>
<td style="text-align: center;"><span class="math-container">\$\omega^{10}\$</span></td>
<td style="text-align: left;"><a href="https://codegolf.stackexchange.com/a/237304/56656">xnor</a></td>
</tr>
<tr>
<td style="text-align: right;">53</td>
<td style="text-align: center;"><span class="math-container">\$\omega^\omega\$</span></td>
<td style="text-align: left;"><a href="https://codegolf.stackexchange.com/a/237342/84290">AnttiP</a></td>
</tr>
<tr>
<td style="text-align: right;">208</td>
<td style="text-align: center;"><span class="math-container">\$\phi_{\Omega^\omega}(0)\cdot\omega\$</span></td>
<td style="text-align: left;">Grain Ghost</td>
</tr>
<tr>
<td style="text-align: right;">218+2<span class="math-container">\$n\$</span></td>
<td style="text-align: center;"><span class="math-container">\$\phi_{\Omega^\omega}(0)^n\cdot\omega\$</span></td>
<td style="text-align: left;">Grain Ghost</td>
</tr>
</tbody>
</table>
</div></div>
<div id="pu6" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, <span class="math-container">\$\omega^\omega\$</span>,<strike>62</strike> 53 bytes</h1>
<pre><code>i#0=[i]
i#a=(i+1)#sum[1|'0'&lt;-show a]++[a]
a&amp;b=1#a&lt;1#b
</code></pre>
<p><a href="https://tio.run/##PY69CsIwFEb3PEUgYpViSPbeRRSXLkK3kOFGK720aWuTIkLfPf6Art85cL4GQ1t3XSI/DlPk9xk7ulF95QeMKEsKMZFQYMgyEggbyvVWhNkbvWQqK3ahGR4cbZ4btAzXDrTAQguXLoMfOXK3IICD43n5wLJivx1OFfNIPYwT9XH1z8nw/rF/8q9ntJRaKWXTCw" rel="nofollow noreferrer">Try it online!</a></p>
<p><em>-9 bytes thanks to xnor</em></p>
<p>Conceptually, this transforms an integer into an infinite list, that is made by iterating <code>sum[1|'0'&lt;-show a]</code>, which just counts the zeroes, until zero is reached. Then it's just zeroes after that. Then those lists are then compared in reverse lexicographic order.</p>
<p>To actually do that in practice, the lists are constructed in reverse, and the head of the list is it's own length. The &quot;ideal&quot; infinite lists have an infinite trail of zeroes, which are removed in the &quot;practical&quot; ones. These zeroes are accounted for with the length.</p>
<p>For example, the number <code>100_000_000_001</code> has the &quot;ideal&quot; representation <code>[100_000_000_001,10,1,0,0,0,...]</code> and the &quot;practical&quot; representation <code>[4, 1, 10, 100_000_000_001]</code></p>
</div>
<div id="pu7" class="pu"><h1><a href="https://github.com/isaacg1/pyth" rel="nofollow noreferrer">Pyth</a>, <span class="math-container">\$(ω^ω, 6)\$</span></h1>
<pre><code>&gt;_PE_P
</code></pre>
<p><a href="https://tio.run/##K6gsyfj/3y4@wDU@4P9/QyNjLhNTMwA" rel="nofollow noreferrer" title="Pyth – Try It Online">Try it online!</a></p>
<p>Compares the reversed prime factorizations of the two inputs.</p>
<h1><a href="https://github.com/isaacg1/pyth" rel="nofollow noreferrer">Pyth</a>, <span class="math-container">\$(ε_0, 17)\$</span></h1>
<pre><code>L_SmylP#U_dPb&gt;yEy
</code></pre>
<p><a href="https://tio.run/##K6gsyfj/3yc@OLcyJ0A5ND4lIMmu0rXy/39DI2MuE1MzAA" rel="nofollow noreferrer" title="Pyth – Try It Online">Try it online!</a></p>
<pre><code>L                     def y(b):
           Pb           prime factors of b
   m                    map over d:
         _d               -d
        U                 range [-d, …, -1]
      P#                  filter for (negated) primes
     l                    count
    y                     recursively call y
  S                     sort
 _                      reverse
             &gt;yEyQ    y(second input) &gt; y(first input)
</code></pre>
<p>The ordinal corresponding to each positive integer is given by</p>
<p><span class="math-container">$$α(p_{i_0}p_{i_1} \dotsc p_{i_{c-1}}) = \sum_k ω^{α(i_k)}$$</span></p>
<p>where <span class="math-container">\$p_i\$</span> is the <span class="math-container">\$i\$</span>th prime, and the sum on the right is taken in nonincreasing order of <span class="math-container">\$α(i_k)\$</span> (since ordinal addition isn’t commutative). This allows us to build any ordinal with a finitely long <a href="https://en.wikipedia.org/wiki/Ordinal_arithmetic#Cantor_normal_form" rel="nofollow noreferrer">Cantor normal form</a>. For example:</p>
<pre><code>α(1) = 0,          y(1) = []
α(2) = 1,          y(2) = [[]]
α(4) = 2,          y(4) = [[], []]
α(8) = 3,          y(8) = [[], [], []]
α(16) = 4,         y(16) = [[], [], [], []]
α(3) = ω,          y(3) = [[[]]]
α(6) = ω + 1,      y(6) = [[[]], []]
α(12) = ω + 2,     y(12) = [[[]], [], []]
α(9) = ω·2,        y(9) = [[[]], [[]]]
α(18) = ω·2 + 1,   y(18) = [[[]], [[]], []]
α(27) = ω·3,       y(27) = [[[]], [[]], [[]]]
α(7) = ω^2,        y(7) = [[[], []]]
α(14) = ω^2 + 1,   y(14) = [[[], []], []]
α(21) = ω^2 + ω,   y(21) = [[[], []], [[]]]
α(49) = ω^2·2,     y(49) = [[[], []], [[], []]]
α(19) = ω^3,       y(19) = [[[], [], []]]
α(5) = ω^ω,        y(5) = [[[[]]]]
α(10) = ω^ω + 1,   y(10) = [[[[]]], []]
α(15) = ω^ω + ω,   y(15) = [[[[]]], [[]]]
α(35) = ω^ω + ω^2, y(35) = [[[[]]], [[], []]]
α(25) = ω^ω·2,     y(25) = [[[[]]], [[[]]]]
α(13) = ω^(ω + 1), y(13) = [[[[]], []]]
α(23) = ω^(ω·2),   y(23) = [[[[]], [[]]]]
α(17) = ω^ω^2,     y(17) = [[[[], []]]]
α(11) = ω^ω^ω,     y(11) = [[[[[]]]]]
α(31) = ω^ω^ω^ω,   y(31) = [[[[[[]]]]]]
</code></pre>
<h1><a href="https://github.com/isaacg1/pyth" rel="nofollow noreferrer">Pyth</a>, <span class="math-container">\$(ε_0, 19)\$</span></h1>
<pre><code>L_S.ey-bkx1_jb2&gt;yEy
</code></pre>
<p><a href="https://codegolf.stackexchange.com/revisions/237303/8">Explanation</a> for this old answer, which is now obsolete, but may be of interest for porting to languages lacking prime-related builtins.</p>
</div>
<div id="pu8" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>, <span class="math-container">\$\omega^{10}\$</span>, 48 bytes</h1>

<pre class="lang-python prettyprint-override"><code>lambda*l:cmp(*[(sorted(`n`)[::-1],n)for n in l])
</code></pre>
<p><a href="https://tio.run/##Ncw9CoAgGADQvVM4@oWBNgpewrUE7ccK9FPMpdNbSwd4Lz/1TDg2r@YWXFw21we5xkz7id6p1H2jFi1MUg7CMASfCkFyIQkGmlbF4bFTwQTnHLpcLqw/0@xrlAdoLw" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>
<p>Outputs <code>-1</code> for <code>&lt;</code> and <code>+1</code> for <code>&gt;</code></p>
<p>Takes each number and sorts its digits in descending order, then compares lexicographically. This effectively compares the count of digit 9's, tiebroken by the number of count 8's, and so on down to 0's. This is all tiebroken by the value of the number itself.</p>
<p>This having order type <span class="math-container">\$\omega^{10}\$</span> follows the same argument as my <a href="https://codegolf.stackexchange.com/a/237304/20260">Haskell <span class="math-container">\$\omega^{10}\$</span> answer</a>, with sorting replacing taking the running minimum.</p>
</div>
<div id="pu9" class="pu"><h2><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, <span class="math-container">\$ \omega \cdot 2\$</span>,  22 bytes</h2>

<pre class="lang-hs prettyprint-override"><code>(.q).(&lt;).q
q=odd&gt;&gt;=(,)
</code></pre>
<p><a href="https://tio.run/##y0gszk7NyfmfmVuQX1Si4JJYkqjnk1lcwpVmG/NfQ69QU0/DRlOvkKvQNj8lxc7OVkNH839yfm6BQqJCUk2irW2SrWtgTRqIZ@sTwgWTsXUP4cpNzMyzLSjKzCtRKQYa7VSpAJaNNtTTs7S0jP3/LzktJzG9@L9uckEBAA" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
<p>Based off <a href="https://codegolf.stackexchange.com/a/237294/20260_">Grain Ghost's Haskell answers</a>. The function <code>q</code> is pointfree for <code>q x=(odd x,x)</code>. That is, we sort numbers by whether they're odd, then the number itself, which gives the evens followed by the odds. We can generalize this idea as:</p>
<h3><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, <span class="math-container">\$ \omega \cdot 4\$</span>,  24 bytes</h3>

<pre class="lang-hs prettyprint-override"><code>(.q).(&lt;).q
q=gcd 6&gt;&gt;=(,)
</code></pre>
<p><a href="https://tio.run/##y0gszk7NyfmfmVuQX1Si4JJYkqjnk1lcwpVmG/NfQ69QU0/DRlOvkKvQNj05RcHMzs5WQ0fzf3J@boFCokJSTaKtbZKta2BNGohn6xPCBZOxdQ/hyk3MzLMtKMrMK1EpBhruVKkAlo021NOztLSM/f8vOS0nMb34v25yQQEA" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
<p>Partitions numbers by the greatest common divisors with 6, which is one of <code>[1,2,3,6]</code>. In general, we can replace 6 with any number <span class="math-container">\$c\$</span>, and get order type <span class="math-container">\$ \omega \cdot \sigma(c)\$</span>, where <span class="math-container">\$ \sigma(c)\$</span> counts the divisors of <span class="math-container">\$c\$</span>. For instance:</p>
<h3><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, <span class="math-container">\$ \omega \cdot 12\$</span>,  25 bytes</h3>

<pre class="lang-hs prettyprint-override"><code>(.q).(&lt;).q
q=gcd 60&gt;&gt;=(,)
</code></pre>
<p><a href="https://tio.run/##y0gszk7NyfmfmVuQX1Si4JJYkqjnk1lcwpVmG/NfQ69QU0/DRlOvkKvQNj05RcHMwM7OVkNH839yfm6BQqJCUk2irW2SrWtgTRqIZ@sTwgWTsXUP4cpNzMyzLSjKzCtRKQaa7lSpAJaNNtTTs7S0jP3/LzktJzG9@L9uckEBAA" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
<p>For 3 digits, 840 gives <span class="math-container">\$ \omega \cdot 32\$</span> for 26 bytes. The optimal values of <span class="math-container">\$c\$</span> to use are <a href="https://en.wikipedia.org/wiki/Highly_composite_number" rel="nofollow noreferrer">Highly Composite Numbers</a>.</p>
<hr />
<h2><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, <span class="math-container">\$\omega^{10}\$</span>, 34 bytes</h2>

<pre class="lang-hs prettyprint-override"><code>(.q).(&lt;).q
q=scanl1 min.show&gt;&gt;=(,)
</code></pre>
<p><a href="https://tio.run/##Nc27CsIwFIDhPU@RwaEBPdAx4OkgiksXoZs6nAZjQ3NrExChz268gOPPN/wDpfFmbTEuhjnzPWWC1qTMNF5KBZOAaitgYhMmRd7W3BkPaQiPpsFqLYoKLnLi/UKIPR5Oi/4Wth37Cx475sh4jLPxeZU@m92T//RcA0gpr@WltKV7KhsV4xs" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
<p>The helper <code>scanl1 min.show</code> takes the decimal representation of a number and computes the running minimum, resulting in a non-increasing sequence. For example, <code>45271</code> becomes <code>44521</code>. We then compare these representations lexicographically, tiebroken by the number itself.</p>
<p>Let's show that the non-decreasing finite lists of digits <span class="math-container">\$0,\dots,9\$</span> are in well-ordered, with order type <span class="math-container">\$\omega^{10}\$</span>. The lexicographic comparison first checks which sequence has more 9's in the prefix, tiebroken by whichever is followed by more 8's, and so on down to which ends with more 0's. So, if we represent the list as <span class="math-container">\$a_9\$</span> 9's followed by <span class="math-container">\$a_8\$</span> 8's, and so on to <span class="math-container">\$a_0\$</span> 0's, the comparison is equivalent to comparing <span class="math-container">\$a_9, a_8, \dots, a_0\$</span> lexicographically. Each <span class="math-container">\$a_i\$</span> is an arbitrary natural number, so this is exactly the order type <span class="math-container">\$\omega^{10}\$</span>.</p>
<p>The <code>scanl min</code> operation suffices to obtain almost every non-increasing sequence of digits 0 through 9, as is seen by it leaving the numbers represented by these digits unchanged -- the only exception is sequences made of only 0's, but their omission doesn't affect the order type. Moreover, each such sequence is produced by a finite number of values, a subset of the numbers with that many digits, and it doesn't matter what the tiebreak is among these values as long as there are no ties. So, the order type produced by the main function is also <span class="math-container">\$\omega^{10}\$</span>.</p>
<p>Sorting the digits in decreasing order would have also worked, but Haskell doesn't have a built-in sort. In other languages, sorting would likely be the way to go.</p>
<p>If we could remove the cap of 9 from the values of the digits, we'd get order type <span class="math-container">\$\omega^{\omega}\$</span></p>
</div>
<div id="pu10" class="pu"><h1><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python 3</a>, <span class="math-container">\$(\omega^2,28)\$</span></h1>

<pre class="lang-python prettyprint-override"><code>lambda a,b:(a&amp;-a,a)&lt;(b&amp;-b,b)
</code></pre>
<p><a href="https://tio.run/##K6gsycjPM/6fZhvzPycxNyklUSFRJ8lKI1FNN1EnUdNGI0lNN0knSfN/QVFmXolGmoZBkqGhgYEOkDIA0pqaXCgShmAJsPh/AA" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
<p><a href="https://tio.run/##K6gsycjPM/6fZhvzPycxNyklUSFRJ8lKIzEuUa1ON1EnUdNGIykuCchO0knS/F9QlJlXopGmYZBkaGhgoAOkDIC0piYXioQhWAIs/h8A" rel="nofollow noreferrer" title="Python 3 – Try It Online">Old version</a></p>
<p>This orders by number of trailing zeros (of binary rep) first and then by the number itself.</p>
</div>
<div id="pu11" class="pu"><h1><a href="https://github.com/m-ender/retina/wiki/The-Language/a950ad7d925ec9316e3e2fb2cf5d49fd15d23e3d" rel="nofollow noreferrer">Retina 0.8.2</a>, <span class="math-container">\$ω^ω\$</span>, 54 bytes</h1>
<pre><code>\d+
$*
+`\b(11+)(\1)+\b
$1 1$#2$*
^(.+)(,\1|\b.*,\1\B)
</code></pre>
<p><a href="https://tio.run/##HY0xDsIwEAR7vwKJIDlxFPnOTnQ1DZ@wEERQ0FAgSv5ubrcZr@zR@PP8vt73foqXW2@PFIYppFvbo0gaY5MxtT0McpDhqP50jYtfz01@bV8mP9t57F22WTQ4tYJi3BksZF2D6CwbCEfpKB2lo3C0wgGVNNAdZyHRMXaMPxprxo6xY@xkdjI7GQ62gehkOIVOoVPoFDrYGXSnrnBABd3BNu4MlvwH" rel="nofollow noreferrer" title="Retina 0.8.2 – Try It Online">Try it online!</a> Link includes test cases. Explanation:</p>
<pre><code>\d+
$*
</code></pre>
<p>Convert to unary.</p>
<pre><code>+`\b(11+)(\1)+\b
$1 1$#2$*
</code></pre>
<p>Factorise with the smallest prime factors last.</p>
<pre><code>^(.+)(,\1|\b.*,\1\B)
</code></pre>
<p>Compare lexicographically.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/237291/">237291</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




