<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::2203</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td></td><td>110424T204550Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/2229#2229">Casey</a></td></tr>
<tr d-ix="1"><td>nan</td><td></td><td>240524T120847Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/273286#273286">None1</a></td></tr>
<tr d-ix="2"><td>nan</td><td></td><td>240522T072329Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/273236#273236">R&#233;m</a></td></tr>
<tr d-ix="3"><td>nan</td><td></td><td>240423T231713Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/272764#272764">c--</a></td></tr>
<tr d-ix="4"><td>nan</td><td></td><td>240113T015408Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/269189#269189">vengy</a></td></tr>
<tr d-ix="5"><td>nan</td><td></td><td>231223T125343Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/268712#268712">Nicholas</a></td></tr>
<tr d-ix="6"><td>nan</td><td></td><td>161229T053858Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/104999#104999">ceilingc</a></td></tr>
<tr d-ix="7"><td>nan</td><td></td><td>230705T162324Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/262440#262440">l4m2</a></td></tr>
<tr d-ix="8"><td>nan</td><td></td><td>220415T132542Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/246267#246267">badatgol</a></td></tr>
<tr d-ix="9"><td>nan</td><td></td><td>190913T010239Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/192746#192746">Jonathan</a></td></tr>
<tr d-ix="10"><td>nan</td><td>Abuse wchar_t to print one character from a string</td><td>220805T164745Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/250732#250732">c--</a></td></tr>
<tr d-ix="11"><td>032</td><td>Use bitwise operators to convert characters to uppercase/lowercase. Bitwise AND with 95 or '_' to convert to uppercase</td><td>220426T195452Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/246612#246612">naffetS</a></td></tr>
<tr d-ix="12"><td>nan</td><td></td><td>121028T073105Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/8841#8841">luser dr</a></td></tr>
<tr d-ix="13"><td>nan</td><td></td><td>211124T091315Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/237618#237618">dingledo</a></td></tr>
<tr d-ix="14"><td>nan</td><td></td><td>211117T082113Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/237373#237373">AZTECCO</a></td></tr>
<tr d-ix="15"><td>nan</td><td></td><td>210729T003412Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/231933#231933">Bubbler</a></td></tr>
<tr d-ix="16"><td>nan</td><td></td><td>200519T093828Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/204951#204951">l4m2</a></td></tr>
<tr d-ix="17"><td>nan</td><td></td><td>150504T110804Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/49606#49606">Abr001am</a></td></tr>
<tr d-ix="18"><td>nan</td><td>Favor recursion over loops</td><td>200402T012732Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/202934#202934">Bubbler</a></td></tr>
<tr d-ix="19"><td>nan</td><td></td><td>200221T021739Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/199860#199860">S.S. Ann</a></td></tr>
<tr d-ix="20"><td>nan</td><td></td><td>200216T043248Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/199586#199586">ceilingc</a></td></tr>
<tr d-ix="21"><td>nan</td><td></td><td>180720T084322Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/168932#168932">Toby Spe</a></td></tr>
<tr d-ix="22"><td>nan</td><td></td><td>170920T080631Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/143247#143247">ceilingc</a></td></tr>
<tr d-ix="23"><td>nan</td><td></td><td>190416T074014Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/183283#183283">r3mainer</a></td></tr>
<tr d-ix="24"><td>nan</td><td></td><td>180923T040408Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/172671#172671">Jonathan</a></td></tr>
<tr d-ix="25"><td>nan</td><td></td><td>180709T161157Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/168262#168262">Geo</a></td></tr>
<tr d-ix="26"><td>nan</td><td>When your algorithm produces output in reverse order</td><td>180622T021604Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/167273#167273">Peter Co</a></td></tr>
<tr d-ix="27"><td>nan</td><td>Set an array of int to the same value C99</td><td>180616T041557Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/166909#166909">ceilingc</a></td></tr>
<tr d-ix="28"><td>nan</td><td></td><td>170331T051322Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/114619#114619">ceilingc</a></td></tr>
<tr d-ix="29"><td>nan</td><td></td><td>180502T194002Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/164010#164010">Jonathan</a></td></tr>
<tr d-ix="30"><td>nan</td><td>Sometimes</td><td>180113T024850Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/153124#153124">Steadybo</a></td></tr>
<tr d-ix="31"><td>nan</td><td>Whenever a certain function is called several times</td><td>171231T090227Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/152207#152207">gastropn</a></td></tr>
<tr d-ix="32"><td>nan</td><td></td><td>171127T033421Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/149187#149187">Colera S</a></td></tr>
<tr d-ix="33"><td>nan</td><td></td><td>161030T050005Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/98023#98023">Dennis</a></td></tr>
<tr d-ix="34"><td>nan</td><td></td><td>170521T043332Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/121857#121857">MD XF</a></td></tr>
<tr d-ix="35"><td>nan</td><td></td><td>170521T042833Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/121855#121855">MD XF</a></td></tr>
<tr d-ix="36"><td>nan</td><td></td><td>170108T073646Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/106067#106067">G B</a></td></tr>
<tr d-ix="37"><td>nan</td><td></td><td>170227T101207Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/111495#111495">Karl Nap</a></td></tr>
<tr d-ix="38"><td>nan</td><td></td><td>161017T183525Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/96555#96555">Dennis</a></td></tr>
<tr d-ix="39"><td>nan</td><td></td><td>160929T002105Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/94807#94807">ceilingc</a></td></tr>
<tr d-ix="40"><td>nan</td><td></td><td>160918T222637Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/93763#93763">luser dr</a></td></tr>
<tr d-ix="41"><td>nan</td><td></td><td>160717T214229Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/85581#85581">aloisdg</a></td></tr>
<tr d-ix="42"><td>nan</td><td>Knowing basic logical equalities might be able to save a couple bytes. For instance</td><td>160618T215428Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/83261#83261">tox123</a></td></tr>
<tr d-ix="43"><td>nan</td><td></td><td>160203T215120Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/70984#70984">MegaTom</a></td></tr>
<tr d-ix="44"><td>nan</td><td>Here are a few tips I've used to my advantage. I've shamelessly stolen them from others</td><td>160201T195015Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/70719#70719">Cole Cam</a></td></tr>
<tr d-ix="45"><td>nan</td><td>For scanning a string into an array</td><td>150621T060709Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/51956#51956">Spikatri</a></td></tr>
<tr d-ix="46"><td>nan</td><td>Use bitwise and & when comparing boolean expressions to save one byte.</td><td>150613T000442Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/51665#51665">takra</a></td></tr>
<tr d-ix="47"><td>nan</td><td>If you ever need to output a single newline character \n</td><td>150504T104800Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/49605#49605">user1220</a></td></tr>
<tr d-ix="48"><td>nan</td><td></td><td>141024T080401Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/40266#40266">feersum</a></td></tr>
<tr d-ix="49"><td>nan</td><td></td><td>110424T020130Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/2205#2205">dmckee -</a></td></tr>
<tr d-ix="50"><td>nan</td><td></td><td>140725T084404Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/35065#35065">es1024</a></td></tr>
<tr d-ix="51"><td>nan</td><td>Certain compilers</td><td>110424T011018Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/2204#2204">Casey</a></td></tr>
<tr d-ix="52"><td>nan</td><td>Make use of return values to zero stuff. If you call some function</td><td>140106T001341Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/17684#17684">MvG</a></td></tr>
<tr d-ix="53"><td>001</td><td>Since usually EOF == 1</td><td>110425T140432Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/2242#2242">Lowjacke</a></td></tr>
<tr d-ix="54"><td>nan</td><td>Using asprintf saves you the explicit allocating and also measuring the length of a string aka char*!</td><td>131219T131635Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/16063#16063">klingt.n</a></td></tr>
<tr d-ix="55"><td>nan</td><td>Print a character then carriage return</td><td>131217T020249Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/15970#15970">moala</a></td></tr>
<tr d-ix="56"><td>nan</td><td>Instead of >= and <= you can simply use integer division / when the compared values are above zero</td><td>130416T220941Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/11339#11339">Fors</a></td></tr>
<tr d-ix="57"><td>nan</td><td></td><td>120615T214141Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/6374#6374">walpen</a></td></tr>
<tr d-ix="58"><td>nan</td><td></td><td>120508T055022Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/5754#5754">Andreas </a></td></tr>
<tr d-ix="59"><td>nan</td><td>The ternary operator ? is unusual in that it has two separate pieces. Because of this</td><td>120507T023532Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/5747#5747">breadbox</a></td></tr>
<tr d-ix="60"><td>nan</td><td></td><td>120315T112058Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/5163#5163">Neeraj G</a></td></tr>
<tr d-ix="61"><td>nan</td><td></td><td>120112T130755Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/4617#4617">ugoren</a></td></tr>
<tr d-ix="62"><td>nan</td><td>If your program is reading or writing on one in each step basis always try to use read and write function instead of getchar and putchar.</td><td>110426T122433Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/2265#2265">Quixotic</a></td></tr>
<tr d-ix="63"><td>nan</td><td></td><td>110425T122625Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/2240#2240">Lowjacke</a></td></tr>
<tr d-ix="64"><td>nan</td><td></td><td>110424T202727Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/2227#2227">dmckee -</a></td></tr>
<tr d-ix="65"><td>nan</td><td></td><td>110424T205928Z</td><td><a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c/2230#2230">Joey Ada</a></td></tr>
</table>
<div id="pu0" class="pu"><p>The comma operator can be used to execute multiple expressions in a single block while avoiding braces:</p>
<pre><code>main(){                                                                                     
                                                                                            
int i = 0;                                                                                  
int j = 1;                                                                                  
if(1)                                                                                       
    i=j,j+=1,printf(&quot;%d %d\n&quot;,i,j); // multiple expressions are all executed                                                  
else                                                                                        
    printf(&quot;failed\n&quot;);                                                                     
                                                                                            
}
</code></pre>
<p>Outputs: <code>1 2</code></p>
</div>
<div id="pu1" class="pu"><h1>Access the first element of array using unary <code>*</code></h1>
<p>Arrays are similar to const pointers, so instead of <code>a[0]</code>, you can use <code>*a</code>, saves 2 bytes.</p>
</div>
<div id="pu2" class="pu"><p>If you have some variables declared in a row :</p>
<pre><code>int a,b,c,d;
</code></pre>
<p>You can access b by (&amp;a)[1], or c by (&amp;a)[2] ...</p>
<p>It can be interesting there :</p>
<pre><code>i?a=k:i-1?b=k:i-2?c=k:(d=k);
VS
(&amp;a)[i]=k;
</code></pre>
<p>You could have declared an array a[4], but if you use a, b, c, d in other ways, it's not always interesting to replace b by a[1], c by a[2]</p>
<p>Moreover, you know that x[y] = *(x+y) = y[x], so :</p>
<pre><code>i?a=k:i-1?b=k:i-2?c=k:(d=k);
VS
(&amp;a)[i]=k;
VS
i[&amp;a]=k;
</code></pre>
</div>
<div id="pu3" class="pu"><h1>Abuse implicit conversions</h1>
<p>If you need to check if a variable is in a given range (say <code>islower(3)</code>)...</p>
<p>Instead of</p>
<pre><code>96&lt;c&amp;c&lt;123
</code></pre>
<p>... try something like</p>
<pre><code>c-97&lt;26u // this also has the advantage of only using the expression `c` once
</code></pre>
</div>
<div id="pu4" class="pu"><h1>Omit Array Length</h1>
<p>If you don't mind possible undefined behavior, define an array <code>C[]</code> (compiler assumes to have one element) and then rely upon the adjacent memory as usable space.</p>
<pre><code>C[];main(){...}
</code></pre>
<p><a href="https://tio.run/##S9ZNT07@/985OtY6NzEzT0OzOi2/SCMzr0Qh09bAOtPG0ABIamtrVjtHZ8baZloXFAHl0jSUVFMUlHRAYprWtbX///9LTstJTC/@r1sOAA" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu5" class="pu"><h1><strong>Use strings as arrays</strong></h1>
<p>Suppose you had an array like the following.</p>
<pre class="lang-c prettyprint-override"><code>c[]={1,2,3,4,5,6,7,8,9,10};
// ...some code here...
printf(&quot;%d&quot;,c[i]);
</code></pre>
<p>You can make this at least 9 bytes shorter using this method.</p>
<pre class="lang-c prettyprint-override"><code>char*x,*c=&quot;abcdefghij&quot;; // initialize like this if you already have a 'char *' declaration somewhere.
c[]=L&quot;abcdefghij&quot;;      // initialize like this you do not (thanks to @ceilingcat for teaching me this one).
// ...some code here...
printf(&quot;%d&quot;,c[i]-97);
</code></pre>
<hr />
<p>You can also do something similar with an array of strings.</p>
<pre class="lang-c prettyprint-override"><code>char*c[]={&quot;cat&quot;,&quot;dog&quot;,&quot;mouse&quot;,&quot;fish&quot;};
// ...some code here...
puts(c[i]);
</code></pre>
<p>you can reduce 2 bytes. However, this is slightly more tricker to get right. This usually only works when the length of the strings in the array only differ by 2 at most.</p>
<p>The '.' characters are padding that allows you to access each &quot;substring&quot; within the string using a multiple of a fixed offset.</p>
<pre class="lang-c prettyprint-override"><code>char*c=&quot;cat\0..dog\0..mouse\0fish&quot;;
// ...some code here...
puts(c+6*i);
</code></pre>
<p>If the order of the strings do not matter, it is best to place the longest string at the end as, you may be able to save some bytes worth of padding.</p>
<pre class="lang-c prettyprint-override"><code>char*c=&quot;cat\0.dog\0.fish\0mouse&quot;;
// ...some code here...
puts(c+5*i);
</code></pre>
<hr />
<p>This is a useful trick that I have used to reduce quite a lot of bytes in the following answers.</p>
<p><a href="https://codegolf.stackexchange.com/questions/248070/lol-is-an-ambigram-dad-isnt/248167#248167">`lol` is an ambigram, `dad` isn&#39;t</a></p>
<p><a href="https://codegolf.stackexchange.com/questions/267313/can-the-chefs-go/267368#267368">Can the chefs go?</a></p>
</div>
<div id="pu6" class="pu"><h1>Use lambdas (unportable)</h1>
<p>Instead of</p>
<pre><code>f(int*a,int*b){return*a&gt;*b?1:-1;}
...
qsort(a,b,4,f);
</code></pre>
<p>or (gcc only)</p>
<pre><code>qsort(a,b,4,({int L(int*a,int*b){a=*a&gt;*b?1:-1;}L;}));
</code></pre>
<p>or (clang with blocks support)</p>
<pre><code>qsort_b(a,b,4,^(const void*a,const void*b){return*(int*)a&gt;*(int*)b?1:-1;});
</code></pre>
<p>try something like</p>
<pre><code>qsort(a,b,4,&quot;\x8b\7+\6\xc3&quot;);
</code></pre>
<p>...where the string literal contains the machine language instructions of your &quot;lambda&quot; function (conforming to all platform ABI requirements).</p>
<p>This works in environments in which string constants are marked executable. By default this is true in Linux and OSX but not Windows.</p>
<p>One silly way to learn to write your own &quot;lambda&quot; functions is to write the function in C, compile it, inspect it with something like <code>objdump -D</code> and copy the corresponding hex code into a string. For example,</p>
<pre><code>int f(int*a, int*b){return *a-*b;}
</code></pre>
<p>...when compiled with <code>gcc -Os -c</code> for a Linux x86_64 target generates something like</p>
<pre><code>0:   8b 07                   mov    (%rdi),%eax
2:   2b 06                   sub    (%rsi),%eax
4:   c3                      retq
</code></pre>
<p><a href="https://codegolf.stackexchange.com/users/61563/md-xf">MD XF</a> wrote a bash <a href="https://gist.github.com/aaronryank/c6fd96d543658b19ed9268a3844d0657" rel="nofollow noreferrer">script</a> that may assist in the writing of simple &quot;lambda&quot; functions.</p>
<p>Edit: This technique was previously published by Shinichiro Hamaji in <a href="http://shinh.skr.jp/dat_dir/golf_prosym.pdf" rel="nofollow noreferrer">this document</a>.</p>
<h1>GNU CC <code>goto</code>:</h1>
<p>You can call these &quot;lambda functions&quot; directly but if the code you're calling doesn't take parameters and isn't going to return, you can use <code>goto</code> to save a few bytes. So instead of</p>
<pre><code>((int(*)())L&quot;ﻫ&quot;)();
</code></pre>
<p>or (if your environment doesn't have Arabic glyphs)</p>
<pre><code>((int(*)())L&quot;\xfeeb&quot;)();
</code></pre>
<p>Try</p>
<pre><code>goto*&amp;L&quot;ﻫ&quot;;
</code></pre>
<p>or</p>
<pre><code>goto*&amp;L&quot;\xfeeb&quot;;
</code></pre>
<p>In this example, <code>eb fe</code> is x86 machine language for something like <code>for(;;);</code> and is a simple example of something that doesn't take parameters and isn't going to return :-)</p>
<p>It turns out you can <code>goto</code> code that returns to a calling parent.</p>
<pre><code>#include&lt;stdio.h&gt;
int f(int a){
 if(!a)return 1;
 goto*&amp;L&quot;\xc3c031&quot;; // return 0;
 return 2; // never gets here
}
int main(){
 printf(&quot;f(0)=%d f(1)=%d\n&quot;,f(0),f(1));
}
</code></pre>
<p>The above example (might compile and run on Linux with <code>gcc -O</code>) is sensitive to the stack layout.</p>
<p>EDIT: Depending on your toolchain, you may have to use the <code>-zexecstack</code> (for gcc) or <code>-Wl,-z,execstack</code> (for clang) compile flag.</p>
<p><i>If it isn't immediately apparent, this answer was mainly written for the lols. I take no responsibility for better or worse golfing or adverse psychological outcomes from reading this.</i></p>
</div>
<div id="pu7" class="pu"><h1>Conditional <code>printf</code> different format</h1>
<pre><code>x&gt;0?printf(&quot;%c&quot;,x):printf(&quot;%d&quot;,-x);
printf(x&gt;0?&quot;%c&quot;:&quot;%.f&quot;,x,0.-x);     // float goes different registers
</code></pre>
<p>Used <a href="https://codegolf.stackexchange.com/a/262438/">here</a></p>
</div>
<div id="pu8" class="pu"><h1>Use bitwise operators for boolean conditions</h1>
<p>For example:</p>
<pre class="lang-c prettyprint-override"><code>if(a||b) /* do something */
</code></pre>
<p>This saves one byte:</p>
<pre class="lang-c prettyprint-override"><code>if(a|b) /* do something */
</code></pre>
<p>Respectively, <code>a!=b</code> becomes <code>a^b</code> and <code>a&amp;&amp;b</code> becomes <code>a&amp;b</code></p>
<p><a href="https://codegolf.stackexchange.com/a/243608/108879">An example of using this trick.</a></p>
<p>Note that sometimes you have to use <code>||</code>. For example:</p>
<pre><code>if(!a)b++
</code></pre>
<p>can be written as</p>
<pre><code>a||b++
</code></pre>
<p>but</p>
<pre><code>a|b++
</code></pre>
<p>doesn't work.</p>
</div>
<div id="pu9" class="pu"><h1>Calculating <span class="math-container">\$\lceil\log_{10}(n)\rceil\$</span></h1>
<p>Especially in challenges where properties of decimal representations are of interest, one needs to find a number's decimal representation's length, or for <span class="math-container">\$n\in\mathbb{N}^+\$</span> equivalently, <span class="math-container">\$\lceil\log_{10}(n)\rceil\$</span>.<br />
In this post, several approaches are presented and discussed.</p>
<p>For a C source file containing approaches (a.1) to (b.3) together with a testing setup, see <a href="https://tio.run/##dZLLTsMwEEX3/opRpEo2NcRpeZcs4DcAVU4yKVbScWW7BQR8e7EJFQWVRfyIdO6ZyaQ@XtT1Nj@Cu9eA4NY9umtWTKanZ@cXl1fq8Ikd5ds8B65PCgH4snLovbEEfKKgijlesFtO4o1K5mnlDIWWK6lkNmoySYLNPhgb@ImAdk11GOirHa0H@hCc2IGukv2Hnk52dMVJduKttY53pZrRrBuPBeVlEc9lt5NXSe6DDrhECvD8hA4hPFvYaGd01aOPrRkfJHgMwdACqFT7LVbzwcMOiZjDsHYEe7rpL511XcrUTWOC2WD/CrGJ7o@suID7lQ0nUJw/7rQxLL2LIUb3EdMRWZra9pG3bbzGcdSITQr58dWaoELweoPNYyx9v/b/Ct8utaE0CQbfc8hqND0/NtQKuC5BgXVQPFAmZgxSEqWvcBNjVNzH4/f31Tp4nmVCMPid0dtFofjotBECShg1cu@JgRJIQvqHJOivtRrW@feW9ij92H4C" rel="nofollow noreferrer">TIO</a>.</p>
<p>I wrote this tip based on <a href="https://codegolf.stackexchange.com/a/192745">this answer of mine</a>, searching for a smaller approach than <strong>(a.1)</strong>.<br />
If you know of any other approach possibly shorter in even a specific scenario, feel free to either add your own tip add to the list below.</p>
<h2>(a.1) An expression in <code>n</code>, 20 bytes</h2>
<pre><code>snprintf(0,0,&quot;%d&quot;,n)
</code></pre>
<p>Versatility is a great property of the above approach, when used to determine a number's decimal representation's length, the most direct approach might be the most byte-effective.</p>
<p><code>0</code> is given its correct decimal representation length of 1.</p>
<p>GCC only throws a warning for ignoring <code>#include &lt;stdio.h&gt;</code>, otherwise the inclusion would be very byte-heavy at potentially 19+20=39 bytes. If instead of <code>sprintf(0</code>, one uses <code>sprintf(NULL</code>, the byte count is increased to 23 bytes. If using both, the byte count could jump to 42 bytes.</p>
<h2>(a.2) A function in <code>n</code>, 29 bytes</h2>
<pre><code>a(n){n=snprintf(0,0,&quot;%d&quot;,n);}
</code></pre>
<p>By being a function, this approach's versatility is high; <strong>(a.1)</strong>'s compiler-specifics also apply, when properly <code>return</code>ing, the byte count increases to 5+29=34 bytes.</p>
<p><code>0</code> is given its correct decimal representation length of 1.</p>
<h2>(b.1) A function in <code>n</code>, requiring another variable, 32 bytes</h2>
<pre><code>b(n,k){for(k=0;n;k++)n/=10;n=k;}
</code></pre>
<p>Of all approaches presented, this one has the worst byte count. However, considering potential compiler restrictions discussed in <strong>(a.1)</strong>, it could prove more byte-efficient, since the approach is nearer to the C core.</p>
<p><code>0</code> is given its incorrect decimal representation length of 0. One can make the case for defining <span class="math-container">\$\lceil-\infty\rceil:=0\$</span> which would make this approach closer to a logarithm implementation, when further defining <span class="math-container">\$\log(0):=-\infty\$</span>.</p>
<p>Modification to calculate <span class="math-container">\$\lceil\log_b(n)\rceil\$</span> for a base <span class="math-container">\$b\in\mathbb{N}^+\$</span> is possible, changing the byte count by the bytes required to represent <span class="math-container">\$b\$</span> in C-source.</p>
<h2>(b.2) A statement requiring existence of two variables, setting <code>n=0</code>, 20 bytes</h2>
<pre><code>for(k=0;n;k++)n/=10;
</code></pre>
<p>If another variable is already declared and <code>n</code> can be either discarded or needs to be cleared regardless and the use case is a whole block instead of a one-line expression, the above could be used. Since it is equivalent in byte count to <strong>(a.1)</strong>, the behavioural differences have to be analyzed.</p>
<p>Minimally wrapped inside a function, it becomes <strong>(b.1)</strong>, both being similar in features.</p>
<h2>(b.3) A statement working additively on <code>k</code>, setting <code>n=0</code>, 17 (pot. 16) bytes</h2>
<pre><code>for(;n;k++)n/=10;
</code></pre>
<p>Another variation on <strong>(b.1)</strong>, removing initialization of <code>k</code>. Furthermore, <code>for(;</code> leaves space for an expression, potentially allowing to save a semicolon's byte, effectively rendering this approach 16 bytes long.</p>
<h2>(c.1) A statement in <code>n</code>, producing <code>stdout</code>-output, 14 bytes</h2>
<pre><code>printf(&quot;%d&quot;,n)
</code></pre>
<p>Courtesy of <a href="https://codegolf.stackexchange.com/users/71256/h-pwiz">H.PWiz</a>.</p>
<p>This approach's utter conciseness and simplicity may be alluring, its major drawback, however, is its <code>stdout</code>-output; tolerability being heavily challenge-dependent.</p>
<h2>(c.2) A statement in <code>n</code>, producing <code>stderr</code>-output, 17 bytes</h2>
<pre><code>dprintf(2,&quot;%d&quot;,n)
</code></pre>
<p>Courtesy of <a href="https://codegolf.stackexchange.com/users/76162/jo-king">Jo King</a>.</p>
<p>The above is equivalent to the five bytes longer <code>fprintf(stderr,&quot;%d&quot;,n)</code> and a variant of <strong>(c.1)</strong>, side-effecting not <code>stdout</code> but rather the much more clutterable <code>stderr</code>.<br />
Ref. <code>man dprintf.3</code></p>
</div>
<div id="pu10" class="pu"><h1>Abuse <code>wchar_t</code> to print one character from a string</h1>
<p>In a little-endian architecture, you can replace</p>
<pre><code>putchar(&quot;string&quot;[i])
</code></pre>
<p>with</p>
<pre><code>printf(L&quot;string&quot;+i)
</code></pre>
<p>to save a byte.</p>
</div>
<div id="pu11" class="pu"><p>Use bitwise operators to convert characters to uppercase/lowercase. Bitwise AND with 95 (or <code>'_'</code>) to convert to uppercase, bitwise OR with 32 (or <code>' '</code>) to convert to lowercase, and to invert case, bitwise XOR with 32 (or <code>' '</code>).</p>
<p>This only works for letters, and it also seems to work for just a few other characters: <code>{</code> and <code>}</code> are lowercase for <code>[</code> and <code>]</code>, <code>~</code> and <code>`</code> are lowercase for <code>^</code> and <code>@</code>, <code>)</code> is lowercase for a tab, and <code>*</code> is lowercase for a newline.</p>
<p><a href="https://tio.run/##rZHBSsQwEIbvfYqhgqRbFZviQXb1pOAhUPDiQVeoaWoHYlLSrgvKPntNXNNNhd72EAYmH//Px/Dzd86H4QQVl5tKwKrrK9QXzW00WUl8c7sIVQ8fJSqSwHcEwJvSQNeb54yu4QbiRkipt9rIKl7678WmbYXhZScqi/DSEpxk9Aw6/BK6Jg5KEofX2gBxDWjBy6UdK8ionWm6rwNYkCAtBUws6fpxDadwfeVSdva1xsbUAfub/7eNX1S87zNCTJlRiXqjB8FksS0MC41QfQrTH8dnzPI21Mm8Qk7/yXhwXiUgRpF8FLlnrHgqHtldIGKPdcTTBGleJp@ROaDzOhNmNww/" rel="noreferrer">Example</a>.</p>
</div>
<div id="pu12" class="pu"><p>Use <em>cursors</em> instead of pointers. Snag the <code>brk()</code> at the beginning and use it as a <em>base-pointer</em>.</p>
<pre><code>char*m=brk();
</code></pre>
<p>Then make a #define for memory access.</p>
<pre><code>#define M [m]
</code></pre>
<p><code>M</code> becomes a postfix <code>*</code> applied to integers. (The old a[x] == x[a] trick.)</p>
<p>But, there's more! Then you can have pointer args and returns in functions that are shorter than macros (especially if you abbreviate 'return'):</p>
<pre><code>f(x){return x M;} //implicit ints, but they work like pointers
#define f(x) (x M)
</code></pre>
<p>To make a cursor from a pointer, you subtract the base-pointer, yielding a ptrdiff_t, which truncates into an int, losses is yer biz.</p>
<pre><code>int p = sbrk(sizeof(whatever)) - m;
strcpy(m+p, &quot;hello world&quot;);
</code></pre>
<p>This technique is used in my answer to <a href="https://codegolf.stackexchange.com/questions/284/write-an-interpreter-for-the-untyped-lambda-calculus/3290#3290">Write an interpreter for the untyped lambda calculus</a>.</p>
</div>
<div id="pu13" class="pu"><h1><code>dprintf</code> for conditional printing</h1>
<p>As you may know, printing something by a condition can be done with <code>?:</code>, <code>&amp;&amp;</code> or <code>||</code>:</p>
<pre class="lang-c prettyprint-override"><code>cond&amp;&amp;printf(&quot;%d\n&quot;,n);
cond||printf(&quot;%d\n&quot;,n);
cond?:printf(&quot;%d\n&quot;,n);
</code></pre>
<p>Another interesting idea is to use <code>dprintf</code>, which is the same as <code>printf</code> except that it takes an extra argument, specifying the output file descriptor.  It will only output to STDOUT if said argument is equal to 1. This can be abused to potentially save a few bytes over the previously mentioned methods:</p>
<pre class="lang-c prettyprint-override"><code>x-1||printf(&quot;%d\n&quot;,n);
dprintf(x,&quot;%d\n&quot;,n);
</code></pre>
</div>
<div id="pu14" class="pu"><p>Sometimes you can use <em>floating point</em> where you don't expect to.</p>
<p>Ignoring possible <em>floating point</em> imprecision issues you still can use them with many operators you wouldn't normally expect :</p>
<ul>
<li><code>++</code> <code>--</code> increment / decrement</li>
<li><code>!</code> <code>||</code> <code>&amp;&amp;</code> Boolean comparative</li>
<li><code>?</code> and even ternary!</li>
</ul>
</div>
<div id="pu15" class="pu"><h2 id="abuse-dark-corners-of-array-indexing-9y77">Abuse dark corners of array indexing</h2>
<p><a href="https://i.sstatic.net/X4tzt.png" rel="noreferrer"><img src="https://i.sstatic.net/X4tzt.png" alt="enter image description here" /></a></p>
<p><code>i[array]</code> desugars into <code>*(i+array)</code>, and since <code>+</code> is commutative for <code>pointer+integer</code> too, it is equivalent to <code>*(array+i)</code> and therefore <code>array[i]</code>.</p>
<p>It's not very common to see an array indexing expression <code>(whatever)[x]</code> where <code>whatever</code> requires wrapping in parens and <code>x</code> doesn't, but when you see one, you can swap the two positions and write <code>x[whatever]</code> to save two bytes.</p>
<p><a href="https://codegolf.stackexchange.com/a/163258/78410">A real golfing example.</a></p>
</div>
<div id="pu16" class="pu"><h1>Omit <code>return</code></h1>

<p>Surprised that only <a href="https://codegolf.stackexchange.com/a/106067/">this answer</a> provided a similar situation </p>

<p>Instead of <code>return x;</code> in the end, use <code>g=x;</code> where <code>g</code> is a global variable.</p>

<p>In other situations, it may be more shortened. Refer <a href="https://codegolf.stackexchange.com/questions/204877/">here</a> for more about this.</p>
</div>
<div id="pu17" class="pu"><p>instead of the printf loop</p>

<pre><code>for(i=1;i&lt;12;i++){if(!i%3)printf("\n");printf("%d",i);}
</code></pre>

<p>just use</p>

<pre><code>for(i=1;i&lt;12;i++) printf("%c%d",!(i%3)*10,i);
</code></pre>

<p>it helps me so much .</p>

<hr>

<p>@SamHocevar 's answer (shorter by 2bytes)</p>

<pre><code>for(i=1;i&lt;12;i++) printf("\n%d"+!!(i%3),i); 
</code></pre>

<hr>

<p>Credits to @AbhayAravinda for ripping off three more bytes</p>

<pre><code>for(i=1;i++&lt;12;) printf("\n%d"+!!(i%3),i);
</code></pre>

<p>The incrementer here works as a part of the inspector.</p>
</div>
<div id="pu18" class="pu"><h1>Favor recursion over loops, especially if going forwards then backwards</h1>

<h2>Loops, 67 bytes</h2>



<pre class="lang-c prettyprint-override"><code>l;f(char*s){for(l=0;s[l];)putchar(s[l++]);for(;l;)putchar(s[--l]);}
</code></pre>

<p><a href="https://tio.run/##XYxNCsIwEIWvIlllGoa6H3oSzSIOVAtjLMm4kp69ZorQ4u697/0w3pnXvudHKp3S6DdR4TO@itehUoMwv9Ww7zQEIEuo4pEjKtCyyt9ehjPVi8S92VwI8fchR44o0T6eacq@zb1zQKe5TFmbvmZzTaQbO6t9AQ" rel="nofollow noreferrer" title="C (gcc) – Try It Online">Try it online!</a></p>

<h2>Recursion, 47 bytes</h2>



<pre class="lang-c prettyprint-override"><code>f(char*s){*s?putchar(*s),f(s+1),putchar(*s):0;}
</code></pre>

<p><a href="https://tio.run/##S9ZNT07@/z9NIzkjsUirWLNaq9i@oLQExNMAcnXSNIq1DTV1kISsDKxr/@cmZuZpaFanaSgpaVorFBRl5pUA2TF5IB6QkZiUDGTV/gcA" rel="nofollow noreferrer" title="C (gcc) – Try It Online">Try it online!</a></p>

<p>You can remove two for-loops and a counter variable. Even if you use just one for-loop in order to loop in one direction, you could save ~10 bytes with this transformation.</p>
</div>
<div id="pu19" class="pu"><h2>Abuse two's complement</h2>
<p>A lot of expressions can be changed by (ab)using two's complement. Take this for example:</p>
<pre><code>getchar()+1
</code></pre>
<p>If you need higher precedence, you can use this:</p>
<pre><code>-~getchar()
</code></pre>
<p>Or, if you're using it as the condition for a loop, this can be used:</p>
<pre><code>~getchar()
</code></pre>
<p>Additionally, instead of subtracting one after another subtraction:</p>
<pre><code>a+b-1
</code></pre>
<p>you can add the bitwise-NOT of the second operand:</p>
<pre><code>a+~b
</code></pre>
<p>This applies similarly to multiplication by 2:</p>
<pre><code>2*(a-b)-1
</code></pre>
<p>can be shortened to:</p>
<pre><code>a-b+a+~b
</code></pre>
</div>
<div id="pu20" class="pu"><h1>Exploit ASLR</h1>
<p>On systems with <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" rel="noreferrer">ASLR (Address Space Layout Randomization)</a>, the address of a stack variable can be used as a one time pseudorandom number. Instead of something like...</p>
<pre><code>srand(time(0));
</code></pre>
<p>...try something like</p>
<pre><code>srand(&amp;x)
</code></pre>
<p>...where the address of <code>x</code> (hopefully on the stack) is unique each time the program is run.</p>
</div>
<div id="pu21" class="pu"><h1>Use <code>for</code> rather than <code>while</code></h1>
<p>Any <code>while</code> can be changed into a <code>for</code> of the same length:</p>
<pre><code>while(*p++)
for(;*p++;)
</code></pre>
<p>On its own, that's not golf.  But we now have an opportunity to move an immediately-preceding statement into the parens, saving its terminating semicolon.  We might also be able to hoist an expression statement from the end of the loop; if the loop contained two statements, we could also save the braces:</p>
<pre><code>a=5;while(*p++){if(p[a])--a;++b;}

for(a=5;*p++;++b)if(p[a])--a;
</code></pre>
<p>Even <code>do...while</code> loops should be replaced with <code>for</code> loops. <code>for(;foo,bar,baz;);</code> is shorter than <code>do foo,bar;while(baz);</code>.</p>
</div>
<div id="pu22" class="pu"><h1>Try <code>cpow()</code> instead of <code>cos()</code></h1>

<p>Instead of</p>

<pre><code>double y=cos(M_PI*2*x);
</code></pre>

<p>try something like</p>

<pre><code>double y=cpow(-1,x*2);
</code></pre>

<p>This uses <a href="https://en.wikipedia.org/wiki/Euler%27s_formula" rel="nofollow noreferrer">Euler's formula</a>, a little complex analysis and the observation that assigning a complex to a double yields the real part (careful with variadic function calls and other subtleties).</p>

<p><span class="math-container">\$\cos 2\pi x+j\sin 2\pi x=e^{j2\pi x}=e^{j\pi 2x}=\left(-1\right)^{2x}\$</span></p>

<p>This type of trick can be used to reduce</p>

<pre><code>double y=cpow(-1,x/2);
</code></pre>

<p>into</p>

<pre><code>double y=cpow(1i,x);
</code></pre>

<p>because <span class="math-container">\$\left(-1\right)^\frac{x}{2}=j^\frac{2x}{2}=j^x\$</span></p>

<p>Edit: Equations now inline <span class="math-container">\$\LaTeX\$</span> instead of images.</p>
</div>
<div id="pu23" class="pu"><h2>Get the length of a string with <code>puts()</code> instead of <code>strlen()</code></h2>

<p>According to the standard C specification, <code>puts()</code> returns a non-negative integer on success. In practice, most C libraries seem to treat <code>puts(s)</code> as equivalent to <code>printf("%s\n", s)</code>, which returns an integer equal to the number of bytes written.</p>

<p>As a result, the return value of <code>puts(s)</code> is equal to <code>1 + strlen(s)</code>. If the additional console output can be ignored, this saves a few bytes.</p>
</div>
<div id="pu24" class="pu"><h1>Boolean constant string selection when the selector's true value is guaranteed to be one larger than the second option's length</h1>

<p>At its heart, this tip attempts to golf a ternary if of the form <code>cnd?str_true:string_false</code> when two conditions are met, namely that both <code>str_true</code> and <code>string_false</code> are constant strings and <code>cnd</code> is either <code>0</code> or <code>strlen(string_false)+1</code>.  </p>

<p>If the above conditions are met, the expression <code>cnd?"true":"false"</code> can be golfed* by one byte to <code>"false\0true"+cnd</code> (here <code>cnd == 0 || cnd == 6</code> always holds); another byte can be shaved off by not escaping the null byte (a compiler dependent feature).</p>

<h3>The tip in action</h3>

<p>For this example, suppose the string selection's criterion is <code>k%3</code>'s truthiness, where <code>k-1</code> is never divisible by three. In this case the ternary if</p>

<pre><code>k%3?"°@°":"_" // 13 bytes
</code></pre>

<p>can be golfed to:</p>

<pre><code>"_\0°@°"+k%3 // 12 bytes
</code></pre>

<p>Which can be golfed down to eleven bytes if one does not escape the null byte.</p>

<h3>Application in obfuscation</h3>

<p>As the above requirements are rather strict, this tip is most likely not widely applicable. Nonetheless, the shown technique can also be used to potentially obfuscate a program at no further byte cost.</p>

<p>Given <code>e</code> as a truly boolean expression -- <code>(e) == 0 || (e) == 1</code> holds -- with the proper operator precedence regarding the upcoming factor, the following snippets are interchangeable* at the same byte count -- when not escaping the null byte.</p>

<pre><code>e?"lifeless":"lychee"
"lychee\0lifeless"+e*7
</code></pre>

<p>Bare in mind that this obfuscation is only non-detrimental to the byte count if the second option's string is not longer than eight characters -- since else the factor spans more than one byte.</p>

<p>*: If interpreted as constant strings.</p>
</div>
<div id="pu25" class="pu"><p>Use recursion over loops. </p>

<p>Recursive example</p>

<pre><code>f(){printf("infiniteloop");f();}
</code></pre>

<p>For loop equivalent is 3 bytes longer.</p>

<pre><code>f(){for(;;)printf("infiniteloop");}
</code></pre>
</div>
<div id="pu26" class="pu"><p><strong>When your algorithm produces output in reverse order, take a pointer to the <em>end</em> of a buffer</strong> and write it in decreasing order, returning a pointer to the first element.  It's up to the caller to supply a buffer large enough for any this input, or for any possible input.</p>

<p><a href="https://stackoverflow.com/questions/13166064/how-do-i-print-an-integer-in-assembly-level-programming-without-printf-from-the/46301894#46301894">Base conversion / int-to-string</a> is a classic example where this interface is used in real life, such as <a href="https://code.woboq.org/userspace/glibc/sysdeps/generic/_itoa.h.html#39" rel="nofollow noreferrer">glibc's internal <code>_itoa</code></a>, used by the printf family of functions as well as some other internal callers.  The max buffer size is 65 bytes for a 64-bit integer -> base 2 string.</p>

<pre><code>// takes a pointer to one-past-the-end, which is also a valid option.
char *itoa_end(unsigned long val, char *p_end) {
  // does *not* zero terminate the buffer.  Use *--p_end = 0;
  const unsigned base = 10;
  char *p = p_end;
  do {
    *--p = (val % base) + '0';
    val /= base;
  } while(val);                  // runs at least once to print '0' for val=0.    

  // write(1, p,  p_end-p);
  return p;  // let the caller know where the leading digit is
}
</code></pre>

<hr>

<p>For golfing, <strong>it can be more compact to take the pointer by reference and modify it, instead of returning it</strong>.  (<code>return</code> is a long keyword, and code depending on <code>gcc -O0</code> evaluating expressions in the return-value register isn't even C.)</p>

<p>For example, I used this in <a href="https://codegolf.stackexchange.com/questions/166708/ascii-art-uncompression-from-a-base-n-number/166831#166831">ASCII art uncompression from a base-n number</a> (i.e. int->string with a digit lookup table), where I already needed a <code>char*</code> arg, so it was <em>very</em> cheap to declare another as a <code>char **</code>.</p>

<p><strong>Use <code>*p</code> everywhere you have <code>p</code> in the simple version</strong>.  <code>*--*p</code> decrements the caller's pointer, then dereferences that to reference the actual character.</p>

<pre><code>/* int n = the number
 * int B = size of I = base
 * char I[] = input table
 * char **O = input/output arg passed by ref:
 *    on entry: pointer to the last byte of output buffer.
 *    on exit:  pointer to the first byte of the 0-terminated string in output buffer
 */
void semi_golfed_g(n,I,B,O)char*I,**O;
{
    for(**O=0 ; n ; n/=B)
        *--*O = I[n%B];
}
</code></pre>
</div>
<div id="pu27" class="pu"><h1>Set an array of <code>int</code> to the same value (C99, Linux, BSD, OSX)</h1>
<p>Instead of</p>
<pre><code>int a[n]=...,x=...;
for(int i=n;i--;)a[i]=x
</code></pre>
<p>Try something like</p>
<pre><code>int a[n]=...,x=...;
wmemset(a,x,n);
</code></pre>
<p>On MSVC on Windows, <code>wmemset()</code> works on arrays of <code>short</code> instead of <code>int</code>.</p>
</div>
<div id="pu28" class="pu"><h1>Overload functions (unportable)</h1>
<p>Instead of declaring multiple functions...</p>
<pre><code>d(x){return x*2;}
float r(float x){return 1/sqrt(x);}
...
printf( &quot;%d %f\n&quot;, d(2), r(2) );
</code></pre>
<p>...declare one &quot;function&quot; that does different things depending on return and parameter types.</p>
<pre><code>(*f)()=L&quot;\xf33f048d\xc3c0520f&quot;; // global
...
printf( &quot;%d %f\n&quot;, f(2), ((float(*)(float))f)(2) );
</code></pre>
<p><a href="https://tio.run/##ZY7RCoJAEEXf/YrBCGZkLdOCwOoL@gRfZLcpQbdaVxCiX29bE5LoaWbuuZc7Mj5L6dys0rLu1GnXWlVdF5dD8FWa0l4GQWFPD3OyndHQR2n@DLi@lhYMjnOiq2V7N9bbvQcjJqT9MSx6zjJO1ltV9DKTySZNOMyDSltoykojPQKAm/E3I4RzBXMudChAYUrCl6QElP9ZYDLyx4jjNxjRuBD5/hH43FcW/viglch@Ux6IKTngoffp3EtyXZ5bF9fNGw" rel="nofollow noreferrer" title="C (gcc) – Try It Online">Try it online!</a> This works because some ABI's (Linux x86_64, in this example) use separate registers for floating point and integer arguments and return values.</p>
<p>The disassembly of the <code>(*f)()</code> &quot;function&quot;...</p>
<pre><code>0:       8d 04 3f                lea    (%rdi,%rdi,1),%eax
3:       f3 0f 52 c0             rsqrtss %xmm0,%xmm0
7:       c3                      retq
</code></pre>
<p>On a x86_64 Linux machine, this function  takes the first integer parameter, doubles it and places the result in <code>%eax</code> (char/short/int/long return value). It takes the first floating point parameter, computes a low precision reciprocal square root and places it in <code>%xmm0</code> (float/double return value).</p>
</div>
<div id="pu29" class="pu"><h1>Inverse flag update</h1>

<p>Sometimes a challenge asks to determine a data set's specific boolean property. To avoid the unacceptably long <code>return</code> keyword, I often use a flag variable which gets updated in a loop and assign-returned at the end (I will refer to <a href="https://codegolf.stackexchange.com/a/106067/73111">this tip</a> for more detail on assign-returning).  </p>

<p>When working with such boolean flags and boolean values, to update them I often use either <code>f&amp;=a|b</code> or <code>f*=a|b</code> to align them with the result of <code>a|b</code>. This is equivalent to saying <code>f = f &amp;&amp; (a|b)</code>.  </p>

<p>However, sometimes a flag needs to be inversely updated, meaning <code>f = f &amp;&amp; !(a|b)</code>. Naively, one would use <code>f&amp;=!(a|b)</code> (9 bytes), or -- using fundamental logical equivalences -- one would golf it to <code>f&amp;=!a&amp;!b</code> (8 bytes).<br>
For the case of an inverse flag update, though, one might be better off using the binary shift right operator <code>&gt;&gt;</code>, as the previous assignment is (when working with boolean values) equivalent to <code>f&gt;&gt;=!(!a&amp;!b)</code>, which simply golfs to <code>f&gt;&gt;=a|b</code> (7 bytes).  </p>

<p>If the flag update in question does not involve parentheses due to negation (as in the previous example), inverse flag updating may still be shorter, as for example <code>f&amp;=!a|!b</code> (8 bytes) is equivalent to <code>f&amp;=!(a&amp;b)</code> (9 bytes), which is equivalent to <code>f&gt;&gt;=a&amp;b</code> (7 bytes).</p>

<p>Inverse flag updating may in certain cases also be used even though the values in question are not boolean (either <code>0</code> or <code>1</code>).<br>
If only one operand is boolean, bitwise and (<code>&amp;</code>) can still be used, as the second operand's bits will all be cleared. When using bitwise or (<code>|</code>) or both operands are non-boolean, one should consider using logical and (<code>&amp;&amp;</code>) and logical or (<code>||</code>) to get a boolean result, even though they are one byte longer.</p>

<p>As a side node, these rules also apply when the expression is side-effect-dependent, meaning <code>!f()&amp;&amp;!g()</code> is equivalent to <code>!(f()||g())</code> regarding the execution of <code>g()</code>, such that even in those cases inverse flag updating can be used.</p>

<p>For testing purposes, I wrote a simple truth table tester (<a href="https://tio.run/##Tc1NDoIwEAXgNT3FgJG0AcW45SeBJpzCDRSLTRQM4ko5O3YcDHbRyZvvJaN2rVLzvDGduj6bMySPsTH9/pIxZroRbpXpuIAXc3Q/AMdVCSkcYiiTo/2CQDBntZwsR8vJViwIC8RiwVUlqUSVVvEmPjRtrQyhpVHZkYdQ21GEoOyQMXXvg21r7m0bSNIMts2p80LghE4UaT91eeXXYtlgrny3pij@q22Wpba55G96/3qCzk1smucP" rel="nofollow noreferrer">TIO-link</a>).  </p>

<p>One recent real-world example of this technique in action would be for example my answer to <a href="https://codegolf.stackexchange.com/a/163974/73111">Detect Rectangular Text</a>.</p>
</div>
<div id="pu30" class="pu"><p>Sometimes, albeit rarely, if your code contains many <code>for</code> loops, <code>#define F for(</code> may save a byte or two (especially if some of the loops have an empty init section).</p>

<p>If it is applicable to your situation, <code>#define F;for(</code> may save even more bytes.</p>

<p><strong>Examples:</strong></p>

<p><a href="https://codegolf.stackexchange.com/a/153117/61405">https://codegolf.stackexchange.com/a/153117/61405</a></p>

<p><a href="https://codegolf.stackexchange.com/a/149629/61405">https://codegolf.stackexchange.com/a/149629/61405</a></p>
</div>
<div id="pu31" class="pu"><p>Whenever a certain function is called several times, it's common to <code>#define</code> it to something shorter. However, certain compilers (MinGW and clang as far as I know) allows for something even more compact by using function pointers:</p>

<pre><code>(*P)()=printf;
P("Test: %d\n", 10);
</code></pre>

<p>Other compilers might require an <code>#include</code> of the proper header file for it to work.</p>
</div>
<div id="pu32" class="pu"><h1>Inline arrays</h1>
<p>If you need a <strong>non-int</strong> constant array and just use it once, you can do</p>
<pre><code>float f(a){return (float[]){.3,.2,.7}[a];}
</code></pre>
<p>instead of</p>
<pre><code>float z[]={.3,.2,.7};float f(a){return z[a];}
</code></pre>
<p>to save 3 bytes.</p>
<p>(In this case it can save one more byte since the blank after <code>return</code> can be omitted.)</p>
</div>
<div id="pu33" class="pu"><h2><code>import</code> if you have to</h2>

<p>As noted in the <a href="https://codegolf.stackexchange.com/a/2204/12012">very first answer</a>, some compilers (notably, GCC and clang) let you get away with omitting <code>#include</code>s for standard library functions.</p>

<p>Even if you can't just remove the <code>#include</code>, there might be <a href="https://codegolf.stackexchange.com/a/96555/12012">other ways to avoid it</a>, but that's not always practical or particularly golfy.</p>

<p>In the remaining cases, you can use <code>#import&lt;header file&gt;</code> instead of <code>#include&lt;header file&gt;</code> to save a byte. This is a GNU extension and it is considered deprecated, but it works at least in gcc 4.8, gcc 5.1, and clang 3.7.</p>
</div>
<div id="pu34" class="pu"><h3>Use <code>s[i]</code> instead of <code>i&lt;strlen(s)</code> in string-handling loops</h3>

<p>For example:</p>

<pre><code>for(i=0;i&lt;strlen(s);i++)s[i]=s[i+1];
</code></pre>

<p>can be shortened to:</p>

<pre><code>for(i=0;s[i];i++)s[i]=s[i+1];
</code></pre>
</div>
<div id="pu35" class="pu"><h3>Use <code>#define</code> instead of functions when possible</h3>

<p>For example:</p>

<pre><code>f(int i,char*s){/*do something with i and s*/;}
</code></pre>

<p>Using <code>#define</code> can eliminate the argument list type, curly-braces and closing semicolon:</p>

<pre><code>#define f(i,s)/*do something with i and s*/
</code></pre>
</div>
<div id="pu36" class="pu"><h3>Assign instead of return.</h3>
<p>This is not really standard C, but works with every compiler and CPU that I know of:</p>
<pre><code>int sqr(int a){return a*a;}
</code></pre>
<p>has the same effect as:</p>
<pre><code>int sqr(int a){a*=a;}
</code></pre>
<p>Because the first argument is stored into the same CPU register as the return value.</p>
<p><em>Note: As noted in one comment, this is undefined behaviour and not guaranteed to work for every operation. And any compiler optimization will just skip over it.</em></p>
<h3>X-Macros</h3>
<p>Another useful feature: X-Macros can help you when you have a list of variables and you need to do some operation which involve all of them:</p>
<p><a href="https://en.wikipedia.org/wiki/X_Macro" rel="noreferrer">https://en.wikipedia.org/wiki/X_Macro</a></p>
</div>
<div id="pu37" class="pu"><h1>Swap variables</h1>

<p>If you ever need to swap variables, don't use the pattern with an extra variable or that addition-subtraction-method, just do some chained XORing:</p>

<pre><code>a^=b^=a^=b;
</code></pre>
</div>
<div id="pu38" class="pu"><h2>Missing <code>include</code>s and return values</h2>

<p>As noted in the <a href="https://codegolf.stackexchange.com/a/2204/12012">very first answer</a>, some compilers (notably, GCC anc clang) let you get away with omitting <code>#include</code>s for standard library functions.</p>

<p>While that <em>usually</em> goes well, it might cause problems in some cases, since the implicit declarations of standard library functions inside the source code will cause the compiler to treat return values as <code>int</code>s. For example, the code</p>

<pre><code>char*p=getenv("PATH");
</code></pre>

<p>wont work as expected on a 64-bit platform since <code>getenv</code> returns a 64-bit memory address which doesn't fit into an <em>int</em>.</p>

<p>In this case, there are at least three ways to use <em>getenv</em> without errors.</p>

<ul>
<li><p>Include the header file as follows.</p>

<pre><code>#include&lt;stdlib.h&gt;
char*p=getenv("PATH");
</code></pre>

<p>This is <em>the right way</em>™, but not very golfy; it costs <strong>19</strong> bytes.</p></li>
<li><p>Declare <em>getenv</em> with the pointer as follows.</p>

<pre><code>char*getenv(),*p=getenv("PATH");
</code></pre>

<p>This costs <strong>10</strong> bytes.</p></li>
<li><p>Finally, unless your code wouldn't work on 32-bit platforms, compile your code on one of those or with the <code>-m32</code> flag (gcc). This costs <strong>0</strong> bytes.</p></li>
</ul>
</div>
<div id="pu39" class="pu"><h1>Reverse Loops</h1>
<p>If you can, try to replace</p>
<pre><code>for(int i=0;i&lt;n;i++){...}
</code></pre>
<p>with</p>
<pre><code>for(int i=n;i--;){...}
</code></pre>
</div>
<div id="pu40" class="pu"><h2>Go functional!</h2>

<p>If you can reduce your problem to simple functions with the same signature and defined as single expressions, then you can do better than <code>#define r return</code> and factor-out almost all of the boilerplate for defining a function.</p>

<pre><code>#define D(f,...)f(x){return __VA_ARGS__;}
D(f,x+2)
D(g,4*x-4)
D(main,g(4))
</code></pre>

<p>Program result is its status value returned to the OS or controlling shell or IDE.</p>

<p>Using <code>__VA_ARGS__</code> allows you to use the comma operator to introduce sequence points in these <em>function-expressions</em>. If this is not needed, the macro can be shorter.</p>

<pre><code>#define D(f,b)f(x){return b;}
</code></pre>
</div>
<div id="pu41" class="pu"><p>When you have to walk a string you can walk the pointer instead of incrementing the index.</p>

<p>Code :</p>

<pre><code>#include &lt;stdio.h&gt;

// print each char
void f(char* s) {
    for (int i=0;s[i];i++) putchar(s[i]);
}

// same output than f;
void g(char* s)
{
    for (;*s;) putchar(*s++);
}

int main(void) {
    f("hello\n");
    g("hello\n");
    return 0;
}
</code></pre>

<p>example: <a href="https://codegolf.stackexchange.com/a/85520/15214">Remove duplicated &amp; switched case</a></p>
</div>
<div id="pu42" class="pu"><p>Knowing basic logical equalities might be able to save a couple bytes. For instance, instead of <code>if (!(a&amp;&amp;b)){}</code> try instead using DeMorgan's law <code>if (!a||!b){}</code>. The same applies to bitwise functions: instead of <code>~(a|b)</code> do <code>~a&amp;~b</code>.</p>
</div>
<div id="pu43" class="pu"><p><code>for(int i=0;i&lt;n;i++){a(i);b(i);}</code>
can be made shorter a few ways:</p>

<p><code>for(int i=0;i&lt;n;){a(i);b(i++);}</code>
-1 for moving the <code>++</code> to the last <code>i</code> in the loop</p>

<p><code>for(int i=0;i&lt;n;b(i++))a(i);</code>
-3 more for moving all but one statement into the top and out of the main loop, removing the braces</p>
</div>
<div id="pu44" class="pu"><p>Here are a few tips I've used to my advantage. I've shamelessly stolen them from others, so credit to anyone but me:</p>

<p><strong>Combine assignment with function calls</strong></p>

<p>Instead of this:</p>

<pre><code>r = /* Some random expression */
printf("%d", r);
</code></pre>

<p>Do this:</p>

<pre><code>printf("%d", r = /* Some random expression */);
</code></pre>

<p><strong>Initialize multiple variables together (when possible)</strong></p>

<p>Instead of this:</p>

<pre><code>for(i=0,j=0;...;...){ /* ... */ }
</code></pre>

<p>Do this:</p>

<pre><code>for(i=j=0;...;...){ /* ... */ }
</code></pre>

<p><strong>Collapse zero/nonzero values</strong></p>

<p>This is a neat trick I picked up from someone here (don't remember who, sorry). When you have an integer value and you need to collapse it to either 1 or 0, you can use <code>!!</code> to do so easily. This is sometimes advantageous for other alternatives like <code>?:</code>.</p>

<p>Take this situation:</p>

<pre><code>n=2*n+isupper(s[j])?1:0; /* 24 */
</code></pre>

<p>You could instead do this:</p>

<pre><code>n=n*2+!!isupper(s[j]); /* 22 */
</code></pre>

<p>Another example:</p>

<pre><code>r=R+(memcmp(b+6,"---",3)?R:0); /* 30 */
</code></pre>

<p>Could be rewritten as:</p>

<pre><code>r=R+R*!!memcmp(b+6,"---",3)); /* 29 */
</code></pre>
</div>
<div id="pu45" class="pu"><p>For scanning a string into an array, you can use</p>

<pre><code>gets(str);
</code></pre>

<p>instead of </p>

<pre><code>scanf("%s",str);
</code></pre>
</div>
<div id="pu46" class="pu"><p>Use bitwise and (&amp;) when comparing boolean expressions to save one byte. </p>

<p>Example: </p>

<pre><code>if(i^2&amp;k/3) DoSomething;
</code></pre>

<p>Really, really useful when combined with the other tips</p>
</div>
<div id="pu47" class="pu"><p>If you ever need to output a single newline character (<code>\n</code>), don't use <code>putchar(10)</code>, use <code>puts("")</code>.</p>
</div>
<div id="pu48" class="pu"><h1>Avoid catastrophic function-argument type declarations</h1>
<p>If you're declaring a function where all five arguments are <code>int</code>s, then life is good. you can simply write</p>
<pre><code>f(a,b,c,d,e){
</code></pre>
<p>But suppose <code>d</code> needs to be a <code>char</code>, or even an <code>int*</code>. Then you're screwed! If one parameter is preceded by a type, all of them must be:</p>
<pre><code>f(int a,int b,int c,int*d,int e){
</code></pre>
<p>But wait! There is a way around this disastrous explosion of useless characters. It goes like this:</p>
<pre><code>f(a,b,c,d,e) int *d; {
</code></pre>
<p>This even saves on a standard <code>main</code> declaration if you need to use the command-line arguments:</p>
<pre><code>main(c,v)char**v;{
</code></pre>
<p>is two bytes shorter than</p>
<pre><code>main(int c,char**v){
</code></pre>
<p>I was surprised to discover this, as I have not so far encountered it on PPCG.</p>
</div>
<div id="pu49" class="pu"><p>Any part of your code that repeats several times is a candidate for replacement with the pre-processor.</p>

<pre><code>#define R return
</code></pre>

<p>is a very common use case if you code involves more than a couple of functions. Other longish keywords like <code>while</code>, <code>double</code>, <code>switch</code>, and <code>case</code> are also candidates; as well as anything that is idomatic in your code.</p>

<p>I generally reserve uppercase character for this purpose.</p>
</div>
<div id="pu50" class="pu"><ol>
<li><p>Use <code>*a</code> instead of <code>a[0]</code> for accessing the first element of an array.</p></li>
<li><p>Relational operators (<code>!=</code>, <code>&gt;</code>,  etc.) give <code>0</code> or <code>1</code>. Use this with arithmetic operators to give different offsets depending on whether the condition is true or false: <code>a[1+2*(i&lt;3)]</code> would access <code>a[1]</code> if <code>i &gt;= 3</code> and <code>a[3]</code> otherwise. </p></li>
</ol>
</div>
<div id="pu51" class="pu"><p>Certain compilers, such as GCC, allow you to omit basic <code>#include</code>s, param, and return types for <code>main</code>.</p>

<p>The following is a valid C89 and C99 program that compiles (with warnings) with GCC:</p>

<pre><code>main(i) { printf("%d", i); }
</code></pre>

<p>Notice that the <code>#include</code> for stdio.h is missing, the return type for <code>main</code> is missing, and the type declaration for <code>i</code> is missing.</p>
</div>
<div id="pu52" class="pu"><p>Make use of return values to zero stuff. If you call some function, and that function returns zero under normal conditions, then you can place it in a location where zero is expected. Likewise if you know the function will return non-zero, with the addition of a bang. After all, you don't do proper error handling in a code golf in any case, right?</p>

<p>Examples:</p>

<pre><code>close(fd);foo=0;   →  foo=close(fd);    /* saves two bytes */
putchar(c);bar=0;  →  bar=!putchar(c);  /* saves one byte  */
</code></pre>
</div>
<div id="pu53" class="pu"><p>Since usually <code>EOF == -1</code>, use the bitwise NOT operator to check for EOF: <code>while(~(c=getchar()))</code> or <code>while(c=getchar()+1)</code> and modify value of c at every place</p>
</div>
<div id="pu54" class="pu"><p>Using <code>asprintf()</code> saves you the explicit allocating and also measuring the length of a string aka <code>char*</code>! 
This isn't maybe too useful for code golfing, but eases the everyday work with a char arrays. There are some more good advises in <a href="http://shop.oreilly.com/product/0636920025108.do" rel="noreferrer">21st Century C</a>.</p>

<p>Usage example:</p>

<pre><code>#define _GNU_SOURCE
#include &lt;stdio.h&gt;

int main(int argc, char** argv) {
  char* foo;
  asprintf(&amp;foo, "%s", argv[1]);
  printf("%s",foo);
}
</code></pre>
</div>
<div id="pu55" class="pu"><p>Print a character then carriage return, instead of:</p>

<pre><code>printf("%c\n",c);
</code></pre>

<p>or</p>

<pre><code>putchar(c);putchar('\n'); // or its ascii value, whatever!
</code></pre>

<p>simply, declare c as an int and:</p>

<pre><code>puts(&amp;c);
</code></pre>
</div>
<div id="pu56" class="pu"><p>Instead of >= and &lt;= you can simply use integer division (/) when the compared values are above zero, which saves one character. For example:</p>

<pre><code>putchar(c/32&amp;&amp;126/c?c:46); //Prints the character, but if it is unprintable print "."
</code></pre>

<p>Which is of course still shrinkable, using for example just > and ^ (a smart way to avoid writing &amp;&amp; or || in some cases).</p>

<pre><code>putchar(c&gt;31^c&gt;126?c:46);
</code></pre>

<p>The integer division trick is for example useful to decide whether a number is less than 100, as this saves a character:</p>

<pre><code>a&lt;100 vs 99/a
</code></pre>

<p>This is also good in cases when higher precedence is needed.</p>
</div>
<div id="pu57" class="pu"><p><a href="http://graphics.stanford.edu/~seander/bithacks.html">http://graphics.stanford.edu/~seander/bithacks.html</a></p>

<p>Bits are nice.</p>

<pre><code>~-x = x - 1
-~x = x + 1
</code></pre>

<p>But with different precedences, and don't change x like ++ and --. Also you can use this in really specific cases: ~9 is shorter than -10.</p>

<pre><code>if(!(x&amp;y)) x | y == x ^ y == x + y
if(!(~x&amp;y)) x ^ y == x - y
</code></pre>

<p>That's more esoteric, but I've had occassion to use it.
If you don't care about short-circuiting</p>

<pre><code>x*y == x &amp;&amp; y
if(x!=-y) x+y == x || y
</code></pre>

<p>Also:</p>

<pre><code>if(x&gt;0 &amp;&amp; y&gt;0) x/y == x&gt;=y   
</code></pre>
</div>
<div id="pu58" class="pu"><p>You may look into the IOCCC archives (international obfuscated C code contest).</p>

<p>One notable trick is to #define macros whose expansion has unbalanced braces/parentheses, like</p>

<pre><code>#define P printf(
</code></pre>
</div>
<div id="pu59" class="pu"><p>The ternary operator <code>?:</code> is unusual in that it has two separate pieces. Because of this, it provides a bit of a loophole to standard operator precedence rules. This can be useful for avoiding parentheses.</p>

<p>Take the following example:</p>

<pre><code>if (t()) a = b, b = 0;  /* 15 chars */
</code></pre>

<p>The usual golfing approach is to replace the <code>if</code> with <code>&amp;&amp;</code>, but because of the low precedence of the comma operator, you need an extra pair of parentheses:</p>

<pre><code>t() &amp;&amp; (a = b, b = 0);  /* still 15 chars */
</code></pre>

<p>The middle section of the ternary operator doesn't need parentheses, though:</p>

<pre><code>t() ? a = b, b = 0 : 0;  /* 14 chars */
</code></pre>

<p>Similar comments apply to array subscripts.</p>
</div>
<div id="pu60" class="pu"><ol>
<li><p>use <code>scanf("%*d ");</code> to read the dummy input. (in case that input is meaningless in further program)
it is shorter than <code>scanf("%d",&amp;t);</code> where you also need to declare the variable t.</p></li>
<li><p>storing characters in int array is much better than character array. example.</p>

<p><code>s[],t;main(c){for(scanf("%*d ");~(c=getchar());s[t++]=c)putchar(s[t]);}</code></p></li>
</ol>
</div>
<div id="pu61" class="pu"><p>Define parameters instead of variables.</p>

<p><code>f(x){int y=x+1;...}</code></p>

<p><code>f(x,y){y=x+1;...}</code></p>

<p>You don't need to actually pass the second parameter.</p>

<p>Also, you can use operator precedence to save parenthesis.<br>
For example, <code>(x+y)*2</code> can become <code>x+y&lt;&lt;1</code>.</p>
</div>
<div id="pu62" class="pu"><p>If your program is reading or writing on one in each step basis always try to use <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/read.html" rel="noreferrer">read</a> and <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/write.html" rel="noreferrer">write</a> function instead of <a href="http://www.cplusplus.com/reference/clibrary/cstdio/getchar/" rel="noreferrer">getchar()</a> and <a href="http://www.cplusplus.com/reference/clibrary/cstdio/putchar/" rel="noreferrer">putchar()</a>.</p>

<p><strong>Example</strong> (<a href="https://codegolf.stackexchange.com/questions/242/reverse-stdin-and-place-on-stdout/1336#1336">Reverse stdin and place on stdout</a>)</p>

<pre><code>main(_){write(read(0,&amp;_,1)&amp;&amp;main());}
</code></pre>

<p>Exercise:Use this technique to get a good score <a href="http://www.spoj.pl/problems/NOP/" rel="noreferrer">here</a>. </p>
</div>
<div id="pu63" class="pu"><p>Use bitwise XOR to check for inequality between integers:</p>

<p><code>if(a^b)</code> instead of <code>if(a!=b)</code> saves 1 character.</p>
</div>
<div id="pu64" class="pu"><p>The ternary conditional operator <code>?:</code> can often be used as a stand in for simple <code>if</code>--<code>else</code> statements at considerable savings.</p>

<p>Unlike <a href="https://codegolf.stackexchange.com/questions/132/tips-for-golfing-in-c/2228#2228">the c++ equivalent</a> the operator <a href="https://stackoverflow.com/q/1082655/2509">does not formally yield an lvalue</a>, but some compilers (notably gcc) will let you get away with it, which is a nice bonus.</p>
</div>
<div id="pu65" class="pu"><ul>
<li><p>Abuse <code>main</code>'s argument list to declare one or more integer variables:</p>

<pre><code>main(a){for(;++a&lt;28;)putchar(95+a);}
</code></pre>

<p><em>(answer to <a href="https://codegolf.stackexchange.com/questions/2078/the-alphabet-in-programming-languages/2093#2093">The alphabet in programming languages</a>)</em></p>

<p>This solution also abuses the fact that <code>a</code> (a.k.a. <code>argc</code>) starts out as <code>1</code>, provided the program is called with no arguments.</p></li>
<li><p>Use global variables to initialize things to zero:</p>

<pre><code>t[52],i;main(c){for(;i&lt;52;)(c=getchar())&lt;11?i+=26:t[i+c-97]++;
for(i=27;--i&amp;&amp;t[i-1]==t[i+25];);puts(i?"false":"true");}
</code></pre>

<p><em>(answer to <a href="https://codegolf.stackexchange.com/questions/1294/anagram-code-golf/1307#1307">Anagram Code Golf!</a>)</em></p></li>
</ul>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/2203/">2203</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




