<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::277009</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>133</td><td>Ruby</td><td>241204T091626Z</td><td><a href="https://codegolf.stackexchange.com/questions/277009/tracing-light-through-a-house-of-mirrors/277010#277010">Doorknob</a></td></tr>
<tr d-ix="1"><td>341</td><td>Python3</td><td>241204T173738Z</td><td><a href="https://codegolf.stackexchange.com/questions/277009/tracing-light-through-a-house-of-mirrors/277031#277031">Ajax1234</a></td></tr>
<tr d-ix="2"><td>172</td><td>Python</td><td>241204T113839Z</td><td><a href="https://codegolf.stackexchange.com/questions/277009/tracing-light-through-a-house-of-mirrors/277014#277014">tsh</a></td></tr>
<tr d-ix="3"><td>040</td><td>05AB1E</td><td>241204T094734Z</td><td><a href="https://codegolf.stackexchange.com/questions/277009/tracing-light-through-a-house-of-mirrors/277012#277012">Kevin Cr</a></td></tr>
<tr d-ix="4"><td>101</td><td>Charcoal</td><td>241204T092831Z</td><td><a href="https://codegolf.stackexchange.com/questions/277009/tracing-light-through-a-house-of-mirrors/277011#277011">Neil</a></td></tr>
</table>
<div id="pu0" class="pu"><h2>Ruby, <s>172</s> <s>164</s> <s>157</s> 133 bytes</h2>

<pre class="lang-none prettyprint-override"><code>-&gt;r,*a{(r*a[0].size**2).map{|x,n|x*=n;a.map{a+=[_1.sub(/(.)\1/,'').gsub(q=x[0...n],w=x[1..n]),_1.gsub(w,q)]}}
a.min_by{[_1.size,_1]}}
</code></pre>
<p>-24 from stealing lots of improvements from <a href="https://codegolf.stackexchange.com/a/277014/3808">tsh's python answer</a>, thanks!
Will update the explanation below when I have time,
but for now it refers to the previous version:</p>
<pre class="lang-none prettyprint-override"><code>-&gt;s,r{a=[s]
(r*s.size**9).map{|x,n|x*=n;a.map{|s|s.sub! /(.)\1/,'';a+=s.gsub(/#{x[0...n]+?|+x[1..n]}/).map{$`+$&amp;.tr(x[1..2],x)+$'}}}
a.min_by{|s|[s.size,s]}}
</code></pre>
<p>It is hard to exaggerate how comically slow this is.
It would use about <span class="math-container">\$2^{10,000,000}\$</span> gigabytes of memory
for the smallest test case.
But you can <a href="https://tio.run/##hY1BbsIwEEX3OUUqrDjB7gTHIBYo5SDuqLUjQFkQoRikQOyzp46puukCWdY8zfyn39/MfTrW0/uH5f2oa2Ux2cC1PR/sqOGsL6OzzoK9mbe0zKH4FCWndKdZbeEUtnm5GPtnbuCdy4dl3RVqBQAdsr1jgxIz@uXe@bKIQfLNSAbXPieZEhhYrZCTrGCEeu@T0Np2X@Y@F6vQ3D4O3KL30yU9KqrN/ChP1cxhSkRM4qkx/45rDEx1E7CKaJpXyvaFUolKhv804pQxJuSfUclfY/oB" rel="nofollow noreferrer">Try it online!</a>
if you replace <code>(s.size**9)</code> with a hardcoded number that works for the test cases.
(It appears the second test case has a mistake,
so I also included what I assume the intended test case was.)</p>
<p>The general idea is to initialize an array containing just the input,
then repeatedly apply all* possible transformations
to all elements of the array,
and append the new results.
If it takes <span class="math-container">\$n\$</span> transformations to get to the fully reduced form,
then as long as we have done this at least <span class="math-container">\$n\$</span> times,
the array will contain the answer somewhere,
and we can take the <code>min_by</code> length (tiebreaking alphabetically) to get it.</p>
<p>Of course,
since we never throw away the previous results,
every single string we have ever seen gets processed again
on each iteration.
This means the size of the array grows exponentially,
which makes this solution totally impractical for any nontrivial input.
But that's okay,
this is code golf.</p>
<p>The first line (initialize the array)
and the last line (take the winner)
are self-explanatory --
the meat of the solution is line 2.
Let's start with the regex:</p>
<pre class="lang-none prettyprint-override"><code>x*=n; [...] /#{x[0...n]+?|+x[1..n]}/
</code></pre>
<p><code>x</code> is the two characters in a braid and <code>n</code> is the reducible braid length.
We build this pattern
(by modifying <code>x</code> in place!)
that matches any possible substring of the two characters in <code>x</code>
that can be transformed.
Note that if there is a braid longer than the corresponding relation,
there are several overlapping matches,
but we only get some.
This is fine, though:
making the first substitution yields an adjacent pair of same symbols,
which after removal has the net effect of shortening the braid
until it is at most as long as the corresponding relation.</p>
<pre class="lang-none prettyprint-override"><code>.gsub( - ).map{$`+$&amp;.tr(x[1..2],x)+$'}
</code></pre>
<p>This is a pretty neat bit of Ruby flair.
We call <code>gsub</code>,
the global regex replace function,
on that regex,
but decline to give a replacement.
This makes <code>gsub</code> instead return an enumerator over each match.
We ignore the value of the enumerator
and instead refer to some magic globals:
<code>$`</code> is the string before the match,
<code>$&amp;</code> is the match,
and <code>$'</code> is the string after the match.
So we map over each match,
and for each one return the original string
with the matched substring replaced with <code>$&amp;.tr(x[1..2],x)</code>,
swapping the relevant characters.
<code>x</code> used to be two characters,
but <code>x[1..2]</code> now exists because we modified <code>x</code> in place in the previous step,
which is delightfully gross.</p>
<pre class="lang-none prettyprint-override"><code>a.map{|s|s.sub! /(.)\1/,'';a+=s.gsub - }
</code></pre>
<p>The main body of the loop first deletes a single adjacent pair, if any,
in each string.
We unfortunately have to do this outside the <code>gsub</code>
because the input might be something like <code>aabc</code> with no relevant relations,
where the only thing to do is delete the <code>aa</code>
(and all the <code>gsub.map</code>s return an empty array).
Obviously,
this is worse than writing <code>s.gsub!</code> instead,
to delete all adjacent pairs instead of only one.
But that's okay,
this is code golf.</p>
<pre class="lang-none prettyprint-override"><code>(r*s.size**9).map{|x,n| - }
</code></pre>
<p>Finally,
we do that whole thing <span class="math-container">\$|s|^9\$</span> times.
Why?
Well,
we need an upper bound on how many steps it might take to reduce.
I'm pretty sure <span class="math-container">\$|s|^2\$</span> is actually such a bound:
there can be at most <span class="math-container">\$|s|\$</span> deletion steps,
and between each deletion step
there can be at most <span class="math-container">\$|s|-1\$</span> useful braid-swapping steps
(because a step is only useful if it brings the two symbols involved in the next deletion closer together).
I put a 9 instead of a 2 just to be safe.
Naturally,
this makes the runtime even more hilariously impractical.
But that's okay,
this is code golf.</p>
</div>
<div id="pu1" class="pu"><h1>Python3, 341 bytes</h1>
<pre class="lang-py prettyprint-override"><code>R=range
def f(a,b):
 q,s,S=[a],[],[a]
 for A in q:
  s+=[A]
  for j,k in b:
   u,U,T='','',[]
   for i in R(k):u+=j[i%2];U+=j[j[i%2]==j[0]]
   for i in R(len(A)-1):
    if A[i]==A[i+1]:T+=[A[:i]+A[i+2:]]
    if(V:=A[i:i+len(u)])in[u,U]:T+=[A[:i]+[u,U][V==u]+A[i+len(u):]]
   for i in T:
    if i not in S:q+=[i];S+=[i]
 return min(s,key=len)
</code></pre>
<p><a href="https://tio.run/##jZBNboMwEIX3nGIUqcIWrlRMqlaOvOAK@dtYXkAKrUPrJAQWUdWz07EhKUWqVGFsv5lvHjMcL83bwSbPx7rrlrLO7GsRvBQllCRjORUBnNiZraTKNFO4Mh1AeaghBWPhhGk4R1KlGPXhPatcIncJaNmGrWUYMlzKER4xDliSioo2kntl7rhebNytv0u8Pegp/V5YktL7mHpjMCWkyiCLexRrsXY9KGF05AJc9PWIka1wjDCRc2ippsYq7Gtc4rXaStn25T0pJj2sb182YA@NC63ECU2MXqz8EUBdNG1t4cNYcmZVcZFoRbtjbWxDSjLLcvfM2CchYYZ/JQ8pS@gXpcEN2eVXCMbUnLJB7VBxr/JBTRx4zBN8B4MYIe4hNqikNwCUfJATh2xoYtIDzPuqURfwdxs/JmOPp3/PEcY4RJwkiT/cFv6e6HE6g5fXCYE7t@4b" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu2" class="pu"><h1>Python, 172 bytes</h1>

<pre class="lang-none prettyprint-override"><code>f=lambda r,*a:f(r,*T)if{*a}!=(T:={k.replace(u,v)for k in a for u,v in[(x[:n],x[1:n+1])for y,n in r for x in[y*n,y[1]+y*n]]+[(c+c,'')for c in k]})else min(sorted(T),key=len)
</code></pre>
<p><a href="https://tio.run/##lYvBasQgEEDv/Qp7ckyGgrHQJZC/yE08GFdpSNYENy2RZb89VQ85FHooIj5n3lvj9rl4cVnDcbhu1rfhqknASrcO0tOz0T0q/XztoG@7x/QW7DprY@ELv5lbApnI6IkmGdMofSTssvUKd8lbX3NVrIg@e6F4e7Zi5TFKruoEStUSTG2Q0mKb7E7qyex8t@Q2ergvYbNX6BlONnaz9exYw@g3cCCB6oEiEUwhSZgPZezl9/6dIUloEjYFB3NWZvi7@/h/x5tiZJmLs2vE2TW8Eemm7PgB" rel="nofollow noreferrer" title="Python 3.8 (pre-release) – Try It Online">Try it online!</a></p>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 40 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>ε`∍ÐÙÂ‡‚}Dí«sÙSºõδ‚«U¸ΔDεVXεYs`:}}«˜êé}н
</code></pre>
<p>Inputs in reversed order, with the braid relations as a list of <span class="math-container">\$[string,length]\$</span>-pairs.</p>
<p><a href="https://tio.run/##yy9OTMpM/f//3NaERx29hyccnnm46VHDwkcNs2pdDq89tLr48MzgQ7sObz23BSh0aHXooR3npric2xoWcW5rZHGCVW3todWn5xxedXhl7YW9//9HRyslJinpmMTqABnJSjpGIEYSkGEcG8uVnJQIhgA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/V9WmWCvpJCYl6KgZA9kPGqbBGRUJrgU/T@3NeFRR@/hCYdnHm561LDwUcOsWpfDaw@tLj48M/jQrsNbz20BCh1aHXpox7kpLue2hkWc2xpZnGBVW3to9ek5h1cdXll7Ye9/nf/RQKBkaKSkYxqrE61kZKykYwxiGAIZRrGxOoZGQGhsbAymQESsjgJIR2ISSGGsDpABgkpIwiYg/YnJIP1ARlIyVGFyEqZSc@KUgpyH5Cq4O4FKgU4COUspNhYA" rel="nofollow noreferrer">verify all test cases</a>.</p>
<p><strong>Explanation:</strong></p>

<p>Step 1: Create a list of all possible replacements:</p>
<pre class="lang-none prettyprint-override"><code>ε          # Map over the (implicit) first input of braid relations:
 `         #  Pop the pair, and push string and length separately
  ∍        #  Extend the string to the specified length
   Ð       #  Triplicate this string
    Ù      #  Uniquify the top copy
     Â     #  Bifurcate it; short for Duplicate &amp; Reverse copy
      ‡    #  Transliterate (e.g. &quot;ababa&quot;,&quot;ab&quot;,&quot;ba&quot; becomes &quot;babab&quot;)
       ‚   #  Pair the two 'mirrored' strings together
}D         # After the map: duplicate the list of pairs
  í        # Reverse each pair in the copy
   «       # Merge the two lists together
s          # Swap to get the second (implicit) input-string
 Ù         # Uniquify its characters
  S        # Convert the string to a list of characters
   º       # Mirror/double each character in the list
     δ     # Map over each double letter string:
    õ ‚    #  Pair it with an empty string
«          # Merge the two lists together
 U         # Pop and store this list of replacements in variable `X`
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//3NaERx29hyccnnm46VHDwkcNs2pdDq89tLr48MzgQ7sObz23BSh0aPX//9HRSolJSjomsTpARrKSjhGIkQRkGMfGciUnJYIhAA" rel="nofollow noreferrer">Try just this first online (without <code>U</code>).</a></p>
<p>Step 2: Keep expanding the (sorted) list as long as there are replacements possible:</p>
<pre class="lang-none prettyprint-override"><code>¸          # Wrap the second (implicit) input-string into a singleton list
 Δ         # Loop until the list no longer changes:
  D        #  Duplicate the current list
   ε       #  Map over each string:
    V      #   Pop and store the current string in variable `Y`
    X      #   Push the list of replacement-pairs `X`
     ε     #   Map over each pair:
      Y    #    Push the current string `Y`
       s   #    Swap so the current replacement-pair is at the top again
        `  #    Pop and push both value in this pair separately
         : #    Do the replacement
     }     #   Close the inner map
   }«      #  After the outer map: merge it to the original list
     ˜     #  Flatten it to a single list of strings
      ê    #  Uniquify and (lexicographically) sort this list
       é   #  Then sort an additional time by length
 }         # Close the changes-loop
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//3NaERx29hyccnnm46VHDwkcNs2pdDq89tLr48MzgQ7sObz23BSh0aHXooR3npric2xoWcW5rZHGCVW3todWn5xxedXhl7f//0dFKiUlKOiaxOkBGspKOEYiRBGQYx8ZyJSclgiEA" rel="nofollow noreferrer">Try the first two steps online.</a></p>
<p>Step 3: Since it's already being sorted correctly in the previous step, its first item is the result we want to output:</p>
<pre class="lang-none prettyprint-override"><code>н          # Pop and keep just the first/shortest item
           # (which is output implicitly as result)
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 101 bytes</h1>
<pre><code>≔⦃⦄ζＦＥη…κ⊕ι«≔⮌Φ⮌ιλε§≔ζΦιλε§≔ζε✂ι¹»⊞υθＦυＦζＦＥ⌕Ａι§ζκ⁺⁺…ιλκ✂ι⁺λＬκＬι¹«ＷΦλ№λ×²ν≔⁻λ×²⌊μλ¿¬№υλ⊞υλ»⌊Φυ⁼Ｌι⌊ＥυＬλ
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=dVLBTgIxEE30JF8x2dM0KQf0oJETIZKQiCHqjXhYysA2dLuw3aJC-BIvHDT6S_o1tqWLXOwmnWnnvembl337EllaiiJVu92HrabNq5-T044xcqZxs-WwZu3GtCgBB-kCMw7dV6GomxULnHPoa1FSTrqiCUrmFmwaZ5F8TysqDWFPqorKw1EyDoq5jVzjiO1UfT2hF1xziGjpQf9hiMODkoI8qsUcZNsYWpOh5bCs1VoGIa5j9Op7Uk86SnnaUbe5FzNU1mDY_uaLGubs6LkAURxuSc-qDAM35n6wVu3BcyYVQT27I3QLqyufPMqcDJ5z0AEbzRpIvW98KLsbmdscc8aCY84IOQW8Kyrc97LBRwb16GpvRCldrSbH9131ZmlTZfBIa43xztjDFL6lX-13MxYm_hGfo6S5UsnTNxslYpyGL-GwSVy4hksOSSpc4lQnY59cbJ_2xF8" rel="nofollow noreferrer">Attempt This Online!</a> Link is to verbose version of code. Explanation:</p>
<pre><code>≔⦃⦄ζＦＥη…κ⊕ι«≔⮌Φ⮌ιλε§≔ζΦιλε§≔ζε✂ι¹»
</code></pre>
<p>Expand the braid relations into a bidirectional mapping between substrings e.g. <code>&quot;bc&quot;: 3</code> becomes <code>&quot;bcb&quot;: &quot;cbc&quot;, &quot;cbc&quot;: &quot;bcb&quot;</code>.</p>
<pre><code>⊞υθＦυ
</code></pre>
<p>Start a breadth-first search of sequences of reflections.</p>
<pre><code>Ｆζ
</code></pre>
<p>Loop over each mapping.</p>
<pre><code>ＦＥ⌕Ａι§ζκ⁺⁺…ιλκ✂ι⁺λＬκＬι¹«
</code></pre>
<p>Loop over all the possible reflections from this mapping.</p>
<pre><code>ＷΦλ№λ×²ν≔⁻λ×²⌊μλ
</code></pre>
<p>Remove all reflection pairs.</p>
<pre><code>¿¬№υλ⊞υλ
</code></pre>
<p>If this is a new result then add it to the search list.</p>
<pre><code>»⌊Φυ⁼Ｌι⌊ＥυＬλ
</code></pre>
<p>Output the minimum result of minimal length.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/277009/">277009</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




