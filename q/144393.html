<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::144393</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>009</td><td>Uiua</td><td>241231T215346Z</td><td><a href="https://codegolf.stackexchange.com/questions/144393/prime-factoral-roots/277460#277460">nyxbird</a></td></tr>
<tr d-ix="1"><td>101</td><td>Java 8</td><td>171004T121506Z</td><td><a href="https://codegolf.stackexchange.com/questions/144393/prime-factoral-roots/144409#144409">Kevin Cr</a></td></tr>
<tr d-ix="2"><td>033</td><td>Factor</td><td>210507T083053Z</td><td><a href="https://codegolf.stackexchange.com/questions/144393/prime-factoral-roots/225225#225225">chunes</a></td></tr>
<tr d-ix="3"><td>061</td><td>Haskell</td><td>171004T110640Z</td><td><a href="https://codegolf.stackexchange.com/questions/144393/prime-factoral-roots/144402#144402">Laikoni</a></td></tr>
<tr d-ix="4"><td>004</td><td>Ohm v2</td><td>171004T132350Z</td><td><a href="https://codegolf.stackexchange.com/questions/144393/prime-factoral-roots/144413#144413">Cinaski</a></td></tr>
<tr d-ix="5"><td>063</td><td>Javascript ES6</td><td>171004T175140Z</td><td><a href="https://codegolf.stackexchange.com/questions/144393/prime-factoral-roots/144431#144431">Endenite</a></td></tr>
<tr d-ix="6"><td>063</td><td>Ruby</td><td>171004T164722Z</td><td><a href="https://codegolf.stackexchange.com/questions/144393/prime-factoral-roots/144428#144428">Snack</a></td></tr>
<tr d-ix="7"><td>084</td><td>Python 2</td><td>171004T141459Z</td><td><a href="https://codegolf.stackexchange.com/questions/144393/prime-factoral-roots/144420#144420">ovs</a></td></tr>
<tr d-ix="8"><td>030</td><td>Retina</td><td>171004T110155Z</td><td><a href="https://codegolf.stackexchange.com/questions/144393/prime-factoral-roots/144399#144399">Martin E</a></td></tr>
<tr d-ix="9"><td>124</td><td>PowerShell</td><td>171004T132904Z</td><td><a href="https://codegolf.stackexchange.com/questions/144393/prime-factoral-roots/144414#144414">AdmBorkB</a></td></tr>
<tr d-ix="10"><td>053</td><td>R + pracma</td><td>171004T131409Z</td><td><a href="https://codegolf.stackexchange.com/questions/144393/prime-factoral-roots/144412#144412">Giuseppe</a></td></tr>
<tr d-ix="11"><td>035</td><td>Mathematica</td><td>171004T104440Z</td><td><a href="https://codegolf.stackexchange.com/questions/144393/prime-factoral-roots/144395#144395">user2027</a></td></tr>
<tr d-ix="12"><td>003</td><td>Pyth</td><td>171004T113348Z</td><td><a href="https://codegolf.stackexchange.com/questions/144393/prime-factoral-roots/144405#144405">Erik the</a></td></tr>
<tr d-ix="13"><td>003</td><td>05AB1E</td><td>171004T110423Z</td><td><a href="https://codegolf.stackexchange.com/questions/144393/prime-factoral-roots/144401#144401">scottine</a></td></tr>
<tr d-ix="14"><td>006</td><td>MATL</td><td>171004T104403Z</td><td><a href="https://codegolf.stackexchange.com/questions/144393/prime-factoral-roots/144394#144394">Luis Men</a></td></tr>
<tr d-ix="15"><td>005</td><td>Jelly</td><td>171004T110231Z</td><td><a href="https://codegolf.stackexchange.com/questions/144393/prime-factoral-roots/144400#144400">the defa</a></td></tr>
<tr d-ix="16"><td>004</td><td>Husk</td><td>171004T110932Z</td><td><a href="https://codegolf.stackexchange.com/questions/144393/prime-factoral-roots/144404#144404">Laikoni</a></td></tr>
<tr d-ix="17"><td>006</td><td>Jelly</td><td>171004T110840Z</td><td><a href="https://codegolf.stackexchange.com/questions/144393/prime-factoral-roots/144403#144403">Sherlock</a></td></tr>
<tr d-ix="18"><td>007</td><td>Actually</td><td>171004T105303Z</td><td><a href="https://codegolf.stackexchange.com/questions/144393/prime-factoral-roots/144397#144397">user4594</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://uiua.org" rel="nofollow noreferrer">Uiua</a>, 9 bytes</h1>
<pre><code>⍥(/+°/×)∞
</code></pre>
<p><a href="https://www.uiua.org/pad?src=0_15_0-dev_1__ZiDihpAg4o2lKC8rwrAvw5cp4oieCuKJoWYgNF8yNV8xMV8yNTAK4o2k4qSZ4omNIDRfN18xMV8xNwo=" rel="nofollow noreferrer">Try it!</a></p>
<pre><code>⍥(/+°/×)∞
⍥(     )∞  # repeat until fixed point:
     °/×    #   factorize
   /+       #   sum
</code></pre>
</div>
<div id="pu1" class="pu"><h1>Java 8, <s>175</s> <s>144</s> <s>142</s> <s>141</s> <s>139</s> 101 bytes</h1>

<pre class="lang-java prettyprint-override"><code>n-&gt;{for(int i=n;i--&gt;0;)n=f(n,2);return n;};int f(int n,int d){return n&gt;1?n%d&lt;1?f(n/d,2)+d:f(n,d+1):0;}
</code></pre>
<p>-38 bytes porting <em>@ovs</em>' Python answer, so make sure to upvote him as well!</p>
<p><a href="https://tio.run/##PVDLboMwELz3K1aRKtnCUEyTCy7kC5pLjmkOLjaVU7IgY1JVyN9ObdJW2of2MaPZvcibTPtB40V9Lk0nxxFepcH5AcCg07aVjYZDLNcGNCRGpCJ0fPBgB0CoYMG0ntvernNToTBpWueCYtUSZAUVVrvJIqDwIq60dyIWo6Lz37Tme3xUL3wfUE8q4BJVRgKVcFrmwi8Aw/TemQZGJ11It94ouAbJ5OiswY/TGSS96/1XU6L@iupP57lgz2zLdoxzVmxZscs9XXcBjt@j09esn1w2BCLXITHJpnxzmyTC41cIzTALH6C/5/vlBw" rel="nofollow noreferrer">Try it online.</a></p>
<pre class="lang-java prettyprint-override"><code>n-&gt;{                 // Method with integer as both parameter and return-type
  for(int i=n;i--&gt;0;)//  Loop the input `n` amount of times:
    n=f(n,2);        //   Change `n` that many times by calling the recursive method
                     //   with n,2 as parameters
  return n;}         //  Then return the potentially modified `n` as result

int f(int n,int d){  // Separated method with 2 integer parameters &amp; integer return
                     // (`d` is 2 when we initially call this recursive-method)
  return n&gt;1?        //  If input `n` is larger than 1:
          n%d&lt;1?     //   If `n` is divisible by `d`:
           f(n/d     //    Divide `n` by `d`
             ,2)     //    Do a recursive call with n/d,2 as parameters
                +d   //    And add `d` to its result
          :          //   Else:
           f(n,d+1)  //    Do a recursive-call with the next `d` by using n,d+1 as
                     //    parameters
         :           //  Else:
          0;}        //   Simply return 0
</code></pre>
<p><strong>Original <s>175</s> <s>144</s> <s>142</s> <s>141</s> 139 bytes answer:</strong></p>
<pre class="lang-java prettyprint-override"><code>n-&gt;{for(int i,t=n,x;;n=t){for(i=2;i&lt;t;)t=t%i++&lt;1?0:t;if(t&gt;1|n&lt;5)return n;for(t=0,i=1;i++&lt;n;)for(;n%i&lt;1;t+=x)for(n/=x=i;x&gt;9;x/=10)t+=x%10;}}
</code></pre>
<p>-1 byte thanks to <em>@Nevay</em><br />
-2 bytes thanks to <em>@ceilingcat</em></p>
<p><strong>Explanation:</strong></p>
<p><a href="https://tio.run/##PVBBbsJADLzzCgsJKasskKXkUJylLygXjpTDNoTKFByUGJqK5u3pbkBItmWPR9aMD@7qxuW54MPuu8uPrq7h3RHfBgDEUlR7lxewCmMPQB6Fygo90vr0UYsTymEFDBY6Hi9v@7LqaaTFsm4Q2Yq6o3aGlAkqsTKiOM7MW7IQpH0kS/PHWaqqQi4VA2Ogi000WYOByagChDyizKDEtulnntrGEjbLV2ym1iQqbEYmwbbtcODlnS@fRy/vofJa0g5O3mG0lor4a7MFp@72nqoXXPwEs5vtzeiZftFznWrj27mepUmrejbA@reW4jQpLzI5@1Ny5Iji4eJDhjFP/J/U40lt9w8" rel="nofollow noreferrer">Try it online.</a></p>
<pre class="lang-java prettyprint-override"><code>n-&gt;{                 // Method with integer as both parameter and return-type
  for(int i,         //  Index-integer `i`
          t=n,       //  Temp integer `t`, starting at the input `n`
          x;         //  Temp integer `x`
      ;              //  Loop indefinitely:
      n=t){          //    After every iteration, replace `n` with the value `t`
    for(i=2;i&lt;t;)    //   Inner loop `i` in the range [2,t):
      t=t%i++&lt;1?     //    If `t` is divisible by `i`:
         0           //     Set `t` to 0
        :            //    Else:
         t;          //     Leave `t` the same
    if(t&gt;1           //   If `t` is not 0 or 1 (it means it's a prime),
       |n&lt;5)         //   or if `n` is below 5 (for edge-cases n=1 and n=4)
      return n;      //    Return `n` as result
    for(t=0,         //   Reset `t` to 0
        i=1;         //   Reset `i` to 1
        i++&lt;n;)      //   Inner loop `i` in the range (2,n]:
      for(;n%i&lt;1;    //    Inner loop as long as `n` is divisible by `i`:
          t+=x)      //      After every iteration: Increase `t` by `x`
        for(n/=x=i;  //     Reset `x` to `i`
                     //     And divide `n` by `i`
            x&gt;9;     //     Inner loop as long as `x` contains more than 1 digit:
            x/=10)   //       After every iteration, remove the trailing digit of `x`
          t+=x%10;}} //      Increase `t` with the trailing digit of `x`
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://factorcode.org/" rel="nofollow noreferrer">Factor</a>, 33 bytes</h1>
<pre><code>[ [ factors Σ ] to-fixed-point ]
</code></pre>
<p><a href="https://tio.run/##S0tMLskv@h8a7OnnbqWQm1iSoVeal5mcn5IK4RQUZeamFuulgZUVKyTn5yZl5iWC2QVFqSUllUAFeSUKxamFpal5yanFCtZc1QomCkYmCoaGCkamBgq1/6MVohVg@s8tVohVKMnXTcusSE3RLcgH6Y39n5tYoFBckpicrfcfAA" rel="nofollow noreferrer" title="Factor – Try It Online">Try it online!</a></p>
<ul>
<li><code>to-fixed-point</code> Apply a quotation to an object until it stops changing.</li>
<li><code>factors Σ</code> Sum of prime factors.</li>
</ul>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.haskell.org/" rel="noreferrer">Haskell</a>, 61 bytes</h1>



<pre class="lang-hs prettyprint-override"><code>import Data.Numbers.Primes
until=&lt;&lt;((==)=&lt;&lt;)$sum.primeFactors
</code></pre>

<p><a href="https://tio.run/##y0gszk7Nyfn/PzO3IL@oRMElsSRRz680Nym1qFgvoCgzN7WYK822NK8kM8fWxkZDw9ZWE0hrqhSX5uoVgKTdEpNL8ouK/@cmZuYp2CoAxfJKFFQUchMLFNIUoo1MdBQMDXUUjEwNYv8DAA" rel="noreferrer" title="Haskell – Try It Online">Try it online!</a></p>

<h3>Explanation</h3>

<p><code>until=&lt;&lt;((==)=&lt;&lt;)</code> takes a function <code>f</code> and applies it to input <code>x</code> until a fix point is reached, that is <code>f x</code> equals <code>x</code>. <code>primeFactors</code> returns the list of prime factors of a number, <code>sum</code> yields the sum of a list of numbers.</p>

<p><em>But wait, why does</em> <code>until=&lt;&lt;((==)=&lt;&lt;)</code> <em>the job and looks so weird?</em></p>

<p>If we assume <code>f=sum.primeFactors</code>, a more natural definition  would be <code>until(\x-&gt;f x==x)f</code>, because <code>until</code> takes a predicate (a function which returns a boolean), a function which has the same input and return type (e.g. <code>Int -&gt; Int</code>) and value of this type, and then applies the function to the value until the predicate is fulfilled. </p>

<p><code>until(\x-&gt;f x==x)f</code> is the same as <code>until(\x-&gt;(==)(f x)x)f</code>, and as it holds that <code>g (h x) x</code> is the same as <code>(g=&lt;&lt;h)x</code>, we get <code>until(\x-&gt;((==)=&lt;&lt;f)x)f</code>. After <a href="https://en.wikipedia.org/wiki/Lambda_calculus#.CE.B7-conversion" rel="noreferrer">Eta conversion</a>, this becomes <code>until((==)=&lt;&lt;f)f</code>. But if we now treat <code>(==)=&lt;&lt;</code> as a function which is applied to <code>f</code>, we can see that <code>until(((==)=&lt;&lt;)f)f</code> is again of the form <code>g (h x) x</code>, with <code>g=until</code>, <code>h=((==)=&lt;&lt;)</code> and <code>x=f</code>, so it can be rewritten to <code>(until=&lt;&lt;((==)=&lt;&lt;))f</code>. Using the <code>$</code> operator to get rid of the outer parentheses and substituting <code>f</code> with <code>sum.primeFactors</code> yields the solution from above.</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/MiningPotatoes/Ohm" rel="nofollow noreferrer">Ohm v2</a>, 4 bytes</h1>

<pre><code>·ΘoΣ
</code></pre>

<p><a href="https://tio.run/##y8/INfr//9D2czPyzy3@/9/I1OA/AA" rel="nofollow noreferrer" title="Ohm v2 – Try It Online">Try it online!</a></p>

<p><strong>Explanation:</strong></p>

<pre><code>·Θ    evaluate the block until the result returned has already been seen
   Σ  sum
  o   the full prime factorization
</code></pre>
</div>
<div id="pu5" class="pu"><h1>Javascript (ES6), 63 bytes</h1>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>f=n=&gt;(q=(p=(m,x)=&gt;m&lt;x?0:m%x?p(m,x+1):x+p(m/x,x))(n,2))^n?f(q):q</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;input id=i type=number min=0 value=0 oninput="o.innerText=f(i.value)"&gt;
&lt;p id=o&gt;&lt;/p&gt;</code></pre>
</div>
</div>
</p>
<h2>Ungolfed:</h2>
<pre class="lang-js prettyprint-override"><code>f=n=&gt;(                  // Recursive function `f`
    p=(m,x=2)=&gt;(        //   Recursive function `p`, used to sum prime factors
        m&lt;x?            //     If m (the number to be factored) is less than x (the current
            0           //     iteration), return 0
        :m%x?           //     Else if m doesn't divide x
            p(m,x+1)    //     run the next iteration
        :               //     Else (if m divides x)
            x+p(m/x,x)  //     Divide m by x and repeat the current iteration
    ),
    q=p(n),             //   Set q to the sum of the prime factors of n
    q^n?                //   If q != n then
        f(q)            //     repeat f with q
    :                   //   else
        q               //     return q
)
</code></pre>
</div>
<div id="pu6" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, 63 bytes</h1>

<pre class="lang-ruby prettyprint-override"><code>-&gt;n{n.times{n=n.prime_division.map{|x|x.reduce:*}.sum};n}
</code></pre>
<p><a href="https://tio.run/##KypNqvyfZvtf1y6vOk@vJDM3tbg6zzZPr6AIyIxPySzLLM7Mz9PLTSyorqmoqdArSk0pTU610qrVKy7NrbXOq/1fUFpSrKBkYqWgXJ0WbRJbq8QFETGCChkhiRkaQsQMDZHUmRpAFZoaAEX//8svKAFaWfxftwjsCAA" rel="nofollow noreferrer" title="Ruby – Try It Online">Try it online!</a></p>
<p>Uses the <code>-rprime</code> flag for +6 bytes to make use of <a href="https://ruby-doc.org/stdlib-2.3.0/libdoc/prime/rdoc/Prime.html#method-i-prime_division" rel="nofollow noreferrer">Prime#prime_division</a>.</p>
<p><code>prime_division</code> returns pairs of <code>[prime, exponent]</code> (for example, for 24 we have the factors <code>[2, 2, 2, 3]</code> so it gives <code>[[2, 3], [3, 1]]</code>) so in each step we just multiply the members of those pairs together and sum the results.</p>
</div>
<div id="pu7" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>, 84 bytes</h1>



<pre class="lang-python prettyprint-override"><code>f=lambda n,d=2:n&gt;1and(n%d and f(n,d+1)or d+f(n/d))
i=input()
exec'i=f(i);'*i
print i
</code></pre>

<p><a href="https://tio.run/##FY1RCsIwEET/9xRLQJpYQRPan0o8hReo3YQu1G0JKerpY/o1zGN4s/3yvIor00rBK6VK9Mv4ftGIciHvBnnYUUjLibAmRl1xa82akNparmQMsGfZ9qwNhG@YGvZRs7k3Z4YtsWTkUsXwmXkJ@Ex7GADxWOJxWjpwHVgLrr/9AQ" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>
</div>
<div id="pu8" class="pu"><h2><a href="https://github.com/m-ender/retina" rel="nofollow noreferrer">Retina</a>, 30 bytes</h2>

<pre><code>{+`(\1|\b11+?\B)+$
$1;$#1$*
;

</code></pre>

<p>Input and output in <a href="http://meta.codegolf.stackexchange.com/questions/5343/can-numeric-input-output-be-in-unary">unary</a>.</p>

<p><a href="https://tio.run/##K0otycxL/K@qkaCnzaWi9b9aO0EjxrAmJsnQUNs@xklTW4VLxdBaRdlQRYvLmuu/pnsCl95/Iy5jLhMuUy5DQy4jEy4jUwMA" rel="nofollow noreferrer" title="Retina – Try It Online">Try it online!</a> (Performs decimal/unary conversion for convenience.)</p>

<h3>Explanation</h3>

<pre><code>{+`(\1|\b11+?\B)+$
$1;$#1$*
</code></pre>

<p>The <code>{</code> instructs Retina to run the entire program in a loop until a full pass fails to modify the string, i.e. until a fixed point is reached. Consequently, the program itself computes one step of summing the prime factors of the current value.</p>

<p>This stage itself computes the prime factorisation of the input. The <code>+</code> is similar to <code>{</code> but loops only this stage until it stops changing the string. The regex tries to match the final run of <code>1</code>s by repeatedly matching the same substring (i.e. the factor). The way this is done is a bit convoluted due to the forward reference <code>\1</code>. On the first iteration, group <code>1</code> hasn't captured anything yet, so <code>\1</code> fails unconditionally. Instead, we have to match <code>\b11+?\B</code> which is the smallest possible substring that starts at the beginning of the run, contains at least two <code>1</code>s and doesn't cover the entire run. Subsequent iterations will not be able to use this alternative again, due to the <code>\b</code>. So on all further iterations, we're matching <code>\1</code>, i.e. the same substring over and over again. This process has to hit the end of the string exactly (<code>$</code>) to make sure we've captured and actual divisor. The benefit of using this somewhat tricky approach is that group <code>1</code> will have been used exactly <strong>n/d</strong> times, i.e. what remains after dividing out the divisor <strong>d</strong>.</p>

<p>We replace this match with <strong>d</strong> (<code>$1</code>), a separating <code>;</code> and <strong>n/d</strong> (<code>$#1$*</code>, which inserts <code>$#1</code> copies of <code>1</code>, where <code>$#1</code> is the number of captures made by group <code>1</code>).</p>

<p>This process stops once the final run in the string is itself a prime, because then the regex no longer matches.</p>

<pre><code>;

</code></pre>

<p>All we need to do to sum the primes is to remove all the separators.</p>
</div>
<div id="pu9" class="pu"><h1><a href="https://github.com/TryItOnline/TioSetup/wiki/Powershell" rel="nofollow noreferrer">PowerShell</a>, 124 bytes</h1>



<pre class="lang-powershell prettyprint-override"><code>function f($a){for($i=2;$a-gt1){if(!($a%$i)){$i;$a/=$i}else{$i++}}}
for($x=$args[0];$l-ne$x){$l=$x;$x=(f($x))-join'+'|iex}$x
</code></pre>

<p><a href="https://tio.run/##HYzBCgIhFEX3fUXBi/Eh0jTQSvySaCGh0wvR0IkemN9u0vLec@59pY/L5eFC6N2/432jFPdegMXqUxZAZtFg1bqdsZIXh0GOQIgVaPQnA9RcKG5EKVtru/@IDdi8lut80xBUdMDDDwZYDyTGOyOqZ6I4yelLjhtw7325zD8" rel="nofollow noreferrer" title="PowerShell – Try It Online">Try it online!</a></p>

<p>PowerShell doesn't have any prime factorization built-ins, so this uses code from my answer on <a href="https://codegolf.stackexchange.com/a/94323/42963">Prime Factors Buddies</a> (the top line) to perform the factorization calculations.</p>

<p>The second line is the meat of this program. We take input from <code>$args</code> into <code>$x</code>, then <code>for</code> loop until <code>$l</code> is <code>-n</code>ot<code>e</code>qual to <code>$x</code>. (The first iteration, <code>$l</code> is <code>$null</code> and <code>$x</code> is an integer, so we'll loop at least once).</p>

<p>Inside the loop, we set our <code>$l = $x</code> to determine if we've hit the end of the loop or not. Then we get the factors of <code>$x</code> with <code>f($x)</code>, <code>-join</code> those together with <code>+</code> and <code>|iex</code> them (short for <code>Invoke-Expression</code> and similar to <code>eval</code>). That's stored back into <code>$x</code>. Thus, we've hit the "end" where the prime factorization summed together is back to itself. Then, we simply place <code>$x</code> on the pipeline and output is implicit.</p>
</div>
<div id="pu10" class="pu"><h1><a href="https://www.r-project.org/" rel="nofollow noreferrer">R</a> + <a href="https://cran.r-project.org/web/packages/pracma/pracma.pdf" rel="nofollow noreferrer">pracma</a>, 53 bytes</h1>



<pre class="lang-r prettyprint-override"><code>function(n){for(i in 1:n)n=sum(pracma::factors(n))
n}
</code></pre>

<p><a href="http://www.r-fiddle.org/#/fiddle?id=EgzwI0sK&amp;version=1" rel="nofollow noreferrer">Try it online! (r-fiddle)</a></p>

<p>R doesn't have a prime factors builtin, but numerous packages (<code>pracma</code>, <code>numbers</code>, etc.) do, so I picked a conveniently short one.</p>
</div>
<div id="pu11" class="pu"><h1>Mathematica, 35 bytes</h1>

<pre><code>#//.x_:&gt;Tr[1##&amp;@@@FactorInteger@x]&amp;
</code></pre>

<p><a href="https://tio.run/##Dcy7CsIwFADQ3a8IDXTxah/oUmm5iAqCgkO3EErsQ4NtAkmGQOm3x@6HMwn3la0NtWG@eUjreFGeR93@2NyVFzn1ykqtLPoFau3EyGrxHnt29c6I1jEPcpt2HGYJT6mwWzjnp81QBpoke98U1fpmlMaIeFu9Nnfl@k9v0PM4vIxUjlEgEdlVJAIyIOUxSZDM@QFIlgHJj@kS/g" rel="nofollow noreferrer" title="Mathics – Try It Online">Try it online!</a></p>

<p>(Mathics does not support <code>Tr</code>. I have to implement it manually)</p>
</div>
<div id="pu12" class="pu"><h1><a href="https://github.com/isaacg1/pyth" rel="noreferrer">Pyth</a>, 3 bytes</h1>

<pre><code>usP
</code></pre>

<p><a href="http://pyth.herokuapp.com/?code=usP&amp;input=250&amp;debug=0" rel="noreferrer">Try it here.</a></p>

<p>Explanation:</p>

<pre><code>usPGQ The trailing GQ is implicit
  PG  Get prime factors
 s    Sum
u   Q Repeat until returned value no longer unique starting with the input
</code></pre>
</div>
<div id="pu13" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E" rel="noreferrer">05AB1E</a>, 3 bytes</h1>

<pre><code>FÒO
</code></pre>

<p><a href="https://tio.run/##MzBNTDJM/f/f7fAk////jUwNAA" rel="noreferrer" title="05AB1E – Try It Online">Try it online!</a></p>

<p><strong>Explanations:</strong></p>

<pre><code>FÒO   
F    Loops &lt;input&gt; times + 1
 Ò   List of prime factors w/ duplicates
  O  Total sum of the list
     -- implicit output
</code></pre>
</div>
<div id="pu14" class="pu"><h1><a href="https://github.com/lmendo/MATL" rel="nofollow noreferrer">MATL</a>, 6 bytes</h1>
<p><em>Uses <a href="https://codegolf.stackexchange.com/a/144401/36398">scottinet's idea</a> of looping more times than needed. Thanks also to <a href="https://codegolf.stackexchange.com/users/58974/shaggy">Shaggy</a> for a pointing out a mistake, now corrected.</em></p>
<pre><code>t:&quot;Yfs
</code></pre>
<p><a href="https://tio.run/##y00syfn/v8RKKTKt@P9/I1MDAA" rel="nofollow noreferrer"><strong>Try it online!</strong></a></p>
<h3>Explanation</h3>
<pre><code>t       % Take input (implicit). Duplicate
:&quot;      % Do the following that many times
  Yf    %   Array of prime factors
  s     %   Sum of array
        % End (implicit). Display (implicit)
</code></pre>
</div>
<div id="pu15" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 5 bytes</h1>

<pre><code>ÆfS$¡
</code></pre>

<p>Explanations:</p>

<pre><code>Æf    list of prime factors
  S   sum
   $¡ repeat n times
</code></pre>

<p><a href="https://tio.run/##y0rNyan8//9wW1qwyqGF////NzI1AAA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
</div>
<div id="pu16" class="pu"><h1><a href="https://github.com/barbuz/Husk" rel="noreferrer">Husk</a>, 4 bytes</h1>

<pre><code>ω(Σp
</code></pre>

<p><a href="https://tio.run/##yygtzv7//3ynxrnFBf///zcyAQA" rel="noreferrer" title="Husk – Try It Online">Try it online!</a></p>

<p>Explanation:</p>

<pre><code>ω(   -- apply the following function until the result no longer changes (fixpoint)
  Σ  -- sum
   p -- the list of primefactors
</code></pre>
</div>
<div id="pu17" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 6 bytes</h1>

<p>This answer uses one of Jelly's many prime factorization builtins, and the quick for <code>repeat until the results are no longer unique</code>.</p>

<pre><code>ÆfSµÐL
</code></pre>

<p><strong><a href="https://tio.run/##y0rNyan8//9wW1rwoa2HJ/j8///fyAQA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></strong></p>
</div>
<div id="pu18" class="pu"><h1><a href="https://github.com/Mego/Seriously" rel="nofollow noreferrer">Actually</a>, 7 bytes</h1>

<pre><code>⌠w♂πΣ⌡Y
</code></pre>

<p><a href="https://tio.run/##S0wuKU3Myan8//9Rz4LyRzObzjecW/yoZ2Hk//9GJgA" rel="nofollow noreferrer" title="Actually – Try It Online">Try it online!</a></p>

<p>Explanation:</p>

<pre><code>⌠w♂πΣ⌡Y
⌠    ⌡Y  do this until output stops changing (fixed-point combinator)
 w         factor into [prime, exponent] pairs
  ♂π       product of each pair
    Σ      sum of products
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/144393/">144393</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




