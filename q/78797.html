<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::78797</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>010</td><td>Uiua</td><td>241021T012440Z</td><td><a href="https://codegolf.stackexchange.com/questions/78797/calculate-the-kronecker-product/276215#276215">nyxbird</a></td></tr>
<tr d-ix="1"><td>086</td><td>R</td><td>201120T153121Z</td><td><a href="https://codegolf.stackexchange.com/questions/78797/calculate-the-kronecker-product/215448#215448">Giuseppe</a></td></tr>
<tr d-ix="2"><td>010</td><td>APL Dyalog Unicode</td><td>201119T193953Z</td><td><a href="https://codegolf.stackexchange.com/questions/78797/calculate-the-kronecker-product/215422#215422">fireflam</a></td></tr>
<tr d-ix="3"><td>037</td><td>Julia</td><td>160428T160748Z</td><td><a href="https://codegolf.stackexchange.com/questions/78797/calculate-the-kronecker-product/78811#78811">Dennis</a></td></tr>
<tr d-ix="4"><td>079</td><td>JavaScript ES6</td><td>160428T125208Z</td><td><a href="https://codegolf.stackexchange.com/questions/78797/calculate-the-kronecker-product/78802#78802">edc65</a></td></tr>
<tr d-ix="5"><td>010</td><td>J</td><td>160428T220830Z</td><td><a href="https://codegolf.stackexchange.com/questions/78797/calculate-the-kronecker-product/78816#78816">miles</a></td></tr>
<tr d-ix="6"><td>009</td><td>Jelly</td><td>160428T124017Z</td><td><a href="https://codegolf.stackexchange.com/questions/78797/calculate-the-kronecker-product/78799#78799">Leaky Nu</a></td></tr>
<tr d-ix="7"><td>042</td><td>MATLAB / Octave</td><td>160428T131425Z</td><td><a href="https://codegolf.stackexchange.com/questions/78797/calculate-the-kronecker-product/78804#78804">Stewie G</a></td></tr>
<tr d-ix="8"><td>011</td><td>Pyth</td><td>160428T125200Z</td><td><a href="https://codegolf.stackexchange.com/questions/78797/calculate-the-kronecker-product/78801#78801">Leaky Nu</a></td></tr>
<tr d-ix="9"><td>013</td><td>CJam</td><td>160428T123115Z</td><td><a href="https://codegolf.stackexchange.com/questions/78797/calculate-the-kronecker-product/78798#78798">Martin E</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://uiua.org" rel="nofollow noreferrer">Uiua</a>, 10 bytes</h1>
<pre><code>/⊂≡/≡⊂×¤¤:
</code></pre>
<p><a href="https://www.uiua.org/pad?src=0_13_0-rc_6__IyBFeHBlcmltZW50YWwhCmsg4oaQIC_iioLiiaEv4omh4oqCw5fCpMKkOgprWzFfMiAzXzRdWzVfNiA3XzhdCmtbNV82IDdfOF1bMV8yIDNfNF0Ka1vCpDEgwqQyXVsxXzJdCmtbMTZfMl8zXzEzIDVfMTFfMTBfOCA5XzdfNl8xMiA0XzE0XzE1XzFdWzFfMSAwXzFdCmtbMV8xIDBfMV1bMTZfMl8zXzEzIDVfMTFfMTBfOCA5XzdfNl8xMiA0XzE0XzE1XzFdCmsgwqTCpDIgwqTCpDUK" rel="nofollow noreferrer">Try it!</a></p>
<p>I wouldn't be surprised if this was suboptimal. If we can take input reversed, remove <code>: flip</code> for -1 byte. <code>¤ fix</code>ing twice forces <code>× multiply</code> to vectorize, and then we <code>/ reduce ⊂ join</code> across various <code>≡ rows</code>.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.r-project.org/" rel="nofollow noreferrer">R</a>, <s>98</s> 86 bytes</h1>

<pre class="lang-r prettyprint-override"><code>function(x,y,`+`=array)aperm(apply(x,1:2,`*`,y)+c(w&lt;-dim(y),v&lt;-dim(x)),c(1,3,2,4))+v*w
</code></pre>
<p><a href="https://tio.run/##TY/dCoMwDEbvfYreCM2MsKj7RS8U9gJju2/nNhCmk@LUPr1LJwMLh4Svh6Q1k/LlCL4SaSim56cpu@rdyBEtqkBl2hhtQbcPU0vdti/LN3SMUK0UWghKOaThvaqlBeznbgTAUhLGGGECEPSrYcrd8Fp3phqlV0pBWxQiYmKGYvQEnw0KImbNmdjP2YH7HeN8iuYsYcexcR4BNuY9ZAnerKuX8/UEXrHY595CuMa/yWuXav77feEVv5pPXw" rel="nofollow noreferrer" title="R – Try It Online">Try it online!</a></p>
<p>Reimplementation of <code>.kronecker</code> and <code>outer</code> for matrices. <s>I do think there's a golfier approach out there, maybe using <code>apply</code>?</s> 6 bytes golfed using <code>apply</code> and <code>array</code> thanks to <a href="https://codegolf.stackexchange.com/users/95126/dominic-van-essen">Dominic van Essen</a>!</p>
<p>The builtins are <code>%x%</code> for <code>kronecker(A,B,&quot;*&quot;)</code> and <code>%o%</code> for <code>outer(A,B,&quot;*&quot;)</code>.</p>
<h1><a href="https://www.r-project.org/" rel="nofollow noreferrer">R</a>, 120 bytes</h1>

<pre class="lang-r prettyprint-override"><code>function(A,B){l=list()
a=dim(A)
for(i in 1:a[2]-1)l[[i+1]]&lt;-do.call(rbind,lapply(A,&quot;*&quot;,B)[1:a+a[2]*i])
do.call(cbind,l)}
</code></pre>
<p><a href="https://tio.run/##TY3disIwEEbv8xSDV4lOxam6P2IvWvAFZPeq9CKmFAZiKtkuu7Lss9eJRTBwyPBxZr44lrDP4GyHyL9aOQ30ggC5sBZojQrkbRGIhJVk8DZl7zK/CsmnfMo24iS2ySODIfY/xQZP1/R/HD8PRlVPfU4TEq7wYUrts9oldey@gxu4D7rEyvz5wvPXoI2yRctnXYrVR83AAWhn67zJyPi65gU1zT5r@6Wz3ut44tCit5eLv8qd2Xwmt2pZWKSVOTdGPVQ3qeZ/7O6NqtMVlma8AQ" rel="nofollow noreferrer" title="R – Try It Online">Try it online!</a></p>
<p>Naive approach: calculate the subarrays <span class="math-container">\$a_{ij}B\$</span> and bind them together in the appropriate order. There are probably golfs here too, but I don't think it'll be shorter than the one above.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.dyalog.com/" rel="nofollow noreferrer">APL (Dyalog Unicode)</a>, 10 <a href="https://codegolf.meta.stackexchange.com/questions/9428/when-can-apl-characters-be-counted-as-1-byte-each/">bytes</a></h1>

<pre class="lang-apl prettyprint-override"><code>{⍪/,/⍺×⊂⍵}
</code></pre>
<p><a href="https://tio.run/##SyzI0U2pTMzJT///v/pR7yp9Hf1HvbsOT3/U1fSod2vt/7RHbRMe9fY96mp@1LvmUe@WQ@uNH7VNfNQ3NTjIGUiGeHgG/3cEqWmbqGGoYKSpYaxgosnlBBUxVTDT1DBXsNDkclRIU3ACAA" rel="nofollow noreferrer" title="APL (Dyalog Unicode) – Try It Online">Try it online!</a></p>
<h3>How it Works</h3>
<pre class="lang-apl prettyprint-override"><code>{  ...   }  ⍝ dfn that takes ⍺=A and ⍵=B
     ⍺×⊂⍵   ⍝ Product of each element of A with all of matrix B
            ⍝ Gives a nested array: an matrix of matrices
   ./       ⍝ Join rows
 ⍪/         ⍝ Join columns
</code></pre>
</div>
<div id="pu3" class="pu"><h1>Julia, <s>40</s> <s>39</s> 37 bytes</h1>

<pre><code>A%B=hvcat(sum(A^0),map(a-&gt;a*B,A')...)
</code></pre>

<p><a href="http://julia.tryitonline.net/#code=QSVCPWh2Y2F0KHN1bShBXjApLG1hcChhLT5hKkIsQScpLi4uKQoKUChBLEIpID0gQSVCCgpkaXNwbGF5KFAoWzEgMgogICAgICAgICAgIDMgNF0sCgogICAgICAgICAgWzUgNgogICAgICAgICAgIDcgOF0pKQoKcHJpbnQoIlxuXG4iKQoKZGlzcGxheShQKFs1IDYKICAgICAgICAgICA3IDhdLAoKICAgICAgICAgIFsxIDIKICAgICAgICAgICAzIDRdKSkKCnByaW50KCJcblxuIikKCmRpc3BsYXkoUChbMTYgICAgIDIgICAgIDMgICAgMTMKICAgICAgICAgICAgNSAgICAxMSAgICAxMCAgICAgOAogICAgICAgICAgICA5ICAgICA3ICAgICA2ICAgIDEyCiAgICAgICAgICAgIDQgICAgMTQgICAgMTUgICAgIDFdLAoKICAgICAgICAgIFsxIDEKICAgICAgICAgICAwIDFdKSkKCnByaW50KCJcblxuIikKCmRpc3BsYXkoUChbMSAxCiAgICAgICAgICAgMCAxXSwKCiAgICAgICAgICBbMTYgICAgIDIgICAgIDMgICAgMTMKICAgICAgICAgICAgNSAgICAxMSAgICAxMCAgICAgOAogICAgICAgICAgICA5ICAgICA3ICAgICA2ICAgIDEyCiAgICAgICAgICAgIDQgICAgMTQgICAgMTUgICAgIDFdKSk&amp;input=" rel="nofollow">Try it online!</a></p>

<h3>How it works</h3>

<ul>
<li><p>For matrices <strong>A</strong> and <strong>B</strong>, <code>map(a-&gt;a*B,A')</code> computes the Kronecker product <strong>A⊗B</strong>.</p>

<p>The result is a vector of matrix blocks with the dimensions of <strong>B</strong>.</p>

<p>We have to transpose <strong>A</strong> (with <code>'</code>) since matrices are stored in column-major order.</p></li>
<li><p><code>sum(A^0)</code> computes the sum of all entries of the identity matrix of <strong>A</strong>'s dimensions. For an <strong>n×n</strong> matrix <strong>A</strong>, this yields <strong>n</strong>.</p></li>
<li><p>With first argument <strong>n</strong>, <code>hvcat</code> concatenates <strong>n</strong> matrix blocks horizontally, and the resulting (larger) blocks vertically.</p></li>
</ul>
</div>
<div id="pu4" class="pu"><h1>JavaScript (ES6), 79</h1>

<p>Straightforward implementation with nested looping</p>

<pre class="lang-js prettyprint-override"><code>(a,b)=&gt;a.map(a=&gt;b.map(b=&gt;a.map(y=&gt;b.map(x=&gt;r.push(y*x)),t.push(r=[]))),t=[])&amp;&amp;t
</code></pre>

<p><strong>Test</strong></p>

<p><div class="snippet" data-lang="js" data-hide="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>f=(a,b)=&gt;a.map(a=&gt;b.map(b=&gt;a.map(y=&gt;b.map(x=&gt;r.push(y*x)),t.push(r=[]))),t=[])&amp;&amp;t

console.log=x=&gt;O.textContent+=x+'\n'

function show(label, mat)
{
  console.log(label)
  console.log(mat.join`\n`)
}

;[ 
  {a:[[1,2],[3,4]],b:[[5,6],[7,8]] },
  {a:[[1],[2]],b:[[1,2]]},
  {a:[[16,2,3,13],[5,11,10,8],[9,7,6,12],[4,14,15,1]],b:[[1,1],[0,1]]},
  {a:[[2]],b:[[5]]}
].forEach(t=&gt;{
  show('A',t.a)  
  show('B',t.b)
  show('A⊗B',f(t.a,t.b))
  show('B⊗A',f(t.b,t.a))  
  console.log('-----------------')
})</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;pre id=O&gt;&lt;/pre&gt;</code></pre>
</div>
</div>
</p>
</div>
<div id="pu5" class="pu"><h1>J, 10 bytes</h1>

<p>This is one possible implementation.</p>

<pre><code>[:,./^:2*/
</code></pre>

<h1>J, 13 bytes</h1>

<p>This is a similar implementation, but instead uses J's ability to define ranks. It applies <code>*</code> between each element on the LHS with the entire RHS.</p>

<pre><code>[:,./^:2*"0 _
</code></pre>

<h2>Usage</h2>

<pre><code>   f =: &lt;either definition&gt;
    (2 2 $ 1 2 3 4) f (2 2 $ 5 6 7 8)
 5  6 10 12
 7  8 14 16
15 18 20 24
21 24 28 32
   (2 1 $ 1 2) f (1 2 $ 1 2)
1 2
2 4
   2 f 5
10
</code></pre>
</div>
<div id="pu6" class="pu"><h1>Jelly, <s>10</s> 9 bytes</h1>
<pre><code>×€€;&quot;/€;/
</code></pre>
<p>Uses <a href="https://codegolf.stackexchange.com/a/78798/48934">Büttner's Algorithm</a> (<code>ü</code> pronounced when trying to make an <code>ee</code> sound [as in meet] in the mouth-shape of an <code>oo</code> sound [as in boot]).</p>
<p>The <code>;&quot;/€;/</code> is inspired by <a href="https://codegolf.stackexchange.com/a/78668/48934">Dennis Mitchell</a>. It was originally <code>Z€F€€;/</code> (which costs one more byte).</p>
<ul>
<li><a href="http://jelly.tryitonline.net/#code=w5figqzigqw7Ii_igqw7Lw&amp;input=&amp;args=W1sxLDJdLFszLDRdXQ+W1s1LDZdLFs3LDhdXQ" rel="nofollow noreferrer">Test case 1</a></li>
<li><a href="http://jelly.tryitonline.net/#code=w5figqzigqw7Ii_igqw7Lw&amp;input=&amp;args=W1sxXSxbMl1d+W1sxLDJdXQ" rel="nofollow noreferrer">Test case 2</a></li>
<li><a href="http://jelly.tryitonline.net/#code=w5figqzigqw7Ii_igqw7Lw&amp;input=&amp;args=W1sxNiwyLDMsMTNdLFs1LDExLDEwLDhdLFs5LDcsNiwxMl0sWzQsMTQsMTUsMV1d+W1sxLDFdLFswLDFdXQ" rel="nofollow noreferrer">Test case 3</a></li>
<li><a href="http://jelly.tryitonline.net/#code=w5figqzigqw7Ii_igqw7Lw&amp;input=&amp;args=W1syXV0+W1s1XV0" rel="nofollow noreferrer">Test case 4</a></li>
</ul>
</div>
<div id="pu7" class="pu"><h1>MATLAB / Octave, <s>83</s> 42 Bytes</h1>
<p>Saved <strong>41</strong> bytes, thanks to  FryAmTheEggman!</p>
<pre><code>@(A,B)cell2mat(arrayfun(@(n)n*B,A,'un',0))
</code></pre>
<p><a href="https://ideone.com/SASqUt" rel="nofollow noreferrer">Test it here!</a></p>
<p><strong>Breakdown</strong></p>
<p><code>arrayfun</code> is a disguised for-loop that multiplies <code>n*B</code>, for a variable <code>n</code> defined by the second argument. This works because looping through a 2D matrix is the same as looping through a vector. I.e. <code>for x = A</code> is the same as <code>for x = A(:)</code>.</p>
<p><code>'un',0</code> is equivalent to the more verbose <code>'UniformOutput', False</code>, and specifies that the output contains cells instead of scalars.</p>
<p><code>cell2mat</code> is used to convert the cells back to a numeric matrix, which is then outputted.</p>
</div>
<div id="pu8" class="pu"><h1>Pyth, <s>14</s> <s>12</s> 11 bytes</h1>
<pre><code>JEsMs*RRRRJ
</code></pre>
<p>Translation of <a href="https://codegolf.stackexchange.com/a/78799/48934">Jelly answer</a>, which is based on <a href="https://codegolf.stackexchange.com/a/78798/48934">Büttner's Algorithm</a> (<code>ü</code> pronounced when trying to make an <code>ee</code> sound [as in meet] in the mouth-shape of an <code>oo</code> sound [as in boot]).</p>
<p><a href="http://pyth.herokuapp.com/?code=JEsMs*RRRRJ&amp;input=%5B%5B1%2C2%5D%2C%5B3%2C4%5D%5D%0A%5B%5B5%2C6%5D%2C%5B7%2C8%5D%5D&amp;debug=0" rel="nofollow noreferrer">Try it online (test case 1)!</a></p>
<h3>Bonus: calculate <code>B⊗A</code> in the same number of bytes</h3>
<pre><code>JEsMs*LRLRJ
</code></pre>
<p><a href="http://pyth.herokuapp.com/?code=JEsMs*LRLRJ&amp;input=%5B%5B1%2C2%5D%2C%5B3%2C4%5D%5D%0A%5B%5B5%2C6%5D%2C%5B7%2C8%5D%5D&amp;debug=0" rel="nofollow noreferrer">Try it online (test case 1)!</a></p>
</div>
<div id="pu9" class="pu"><h2>CJam, 13 bytes</h2>

<pre><code>{ffff*::.+:~}
</code></pre>

<p>This is an unnamed block that expects two matrices on top of the stack and leaves their Kronecker product in their place.</p>

<p><a href="http://cjam.aditsu.net/#code=qN%2F%7B%3AQ%3B%0A%0AQ~ffff*%3A%3A.%2B%3A~%0A%0A%7Bs4Se%5B%7Df%25Sf*N*oNoNo%7D%2F&amp;input=%5B%5B1%202%5D%20%5B3%204%5D%5D%20%5B%5B5%206%5D%20%5B7%208%5D%5D%0A%5B%5B5%206%5D%20%5B7%208%5D%5D%20%5B%5B1%202%5D%20%5B3%204%5D%5D%0A%5B%5B1%5D%20%5B2%5D%5D%20%5B%5B1%202%5D%5D%0A%5B%5B1%202%5D%5D%20%5B%5B1%5D%20%5B2%5D%5D%0A%5B%5B16%202%203%2013%5D%20%5B5%2011%2010%208%5D%20%5B9%207%206%2012%5D%20%5B4%2014%2015%201%5D%5D%20%5B%5B1%201%5D%20%5B0%201%5D%5D%0A%5B%5B1%201%5D%20%5B0%201%5D%5D%20%5B%5B16%202%203%2013%5D%20%5B5%2011%2010%208%5D%20%5B9%207%206%2012%5D%20%5B4%2014%2015%201%5D%5D" rel="nofollow noreferrer">Test suite.</a></p>

<h3>Explanation</h3>

<p>This is just the Kronecker product part <a href="https://codegolf.stackexchange.com/a/78621/8478">from the previous answer</a>, therefore I'm here just reproducing the relevant parts of the previous explanation:</p>

<p>Here is a quick overview of CJam's infix operators for list manipulation:</p>

<ul>
<li><code>f</code> expects a list and something else on the stack and maps the following <em>binary</em> operator over the list, passing in the other element as the second argument. E.g. <code>[1 2 3] 2 f*</code> and <code>2 [1 2 3] f*</code> both give <code>[2 4 6]</code>. If both elements are lists, the first one is mapped over and the second one is used to curry the binary operator.</li>
<li><code>:</code> has two uses: if the operator following it is unary, this is a simple map. E.g. <code>[1 0 -1 4 -3] :z</code> is <code>[1 0 1 4 3]</code>, where <code>z</code> gets the modulus of a number. If the operator following it is binary, this will <em>fold</em> the operator instead. E.g. <code>[1 2 3 4] :+</code> is <code>10</code>.</li>
<li><code>.</code> vectorises a binary operator. It expects two lists as arguments and applies the operator to corresponding pairs. E.g. <code>[1 2 3] [5 7 11] .*</code> gives <code>[5 14 33]</code>.</li>
</ul>



<pre><code>ffff*  e# This is the important step for the Kronecker product (but
       e# not the whole story). It's an operator which takes two matrices
       e# and replaces each cell of the first matrix with the second matrix
       e# multiplied by that cell (so yeah, we'll end up with a 4D list of
       e# matrices nested inside a matrix).
       e# Now the ffff* is essentially a 4D version of the standard ff* idiom
       e# for outer products. For an explanation of ff*, see the answer to
       e# to the Kronecker sum challenge.
       e# The first ff maps over the cells of the first matrix, passing in the 
       e# second matrix as an additional argument. The second ff then maps over 
       e# the second matrix, passing in the cell from the outer map. We 
       e# multiply them with *.
       e# Just to recap, we've essentially got the Kronecker product on the
       e# stack now, but it's still a 4D list not a 2D list.
       e# The four dimensions are:
       e#   1. Columns of the outer matrix.
       e#   2. Rows of the outer matrix.
       e#   3. Columns of the submatrices.
       e#   4. Rows of the submatrices.
       e# We need to unravel that into a plain 2D matrix.
::.+   e# This joins the rows of submatrices across columns of the outer matrix.
       e# It might be easiest to read this from the right:
       e#   +    Takes two rows and concatenates them.
       e#   .+   Takes two matrices and concatenates corresponding rows.
       e#   :.+  Takes a list of matrices and folds .+ over them, thereby
       e#        concatenating the corresponding rows of all matrices.
       e#   ::.+ Maps this fold operation over the rows of the outer matrix.
       e# We're almost done now, we just need to flatten the outer-most level
       e# in order to get rid of the distinction of rows of the outer matrix.
:~     e# We do this by mapping ~ over those rows, which simply unwraps them.
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/78797/">78797</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




