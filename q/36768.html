<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::36768</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>093</td><td>C</td><td>240109T092919Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/269098#269098">Fractali</a></td></tr>
<tr d-ix="1"><td>147</td><td>Python</td><td>140826T021236Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36822#36822">Maarten </a></td></tr>
<tr d-ix="2"><td>062</td><td>CJam</td><td>140826T195247Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36874#36874">Dennis</a></td></tr>
<tr d-ix="3"><td>091</td><td>CJam</td><td>140825T160015Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36790#36790">Dennis</a></td></tr>
<tr d-ix="4"><td>037</td><td>CJam</td><td>140827T033955Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36889#36889">Dennis</a></td></tr>
<tr d-ix="5"><td>049</td><td>CJam</td><td>140828T022745Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36952#36952">Dennis</a></td></tr>
<tr d-ix="6"><td>078</td><td>Python</td><td>140827T084945Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36894#36894">Electric</a></td></tr>
<tr d-ix="7"><td>086</td><td>Python</td><td>140827T023337Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36887#36887">Snack</a></td></tr>
<tr d-ix="8"><td>072</td><td>Mathematica</td><td>140826T234809Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36884#36884">Tyilo</a></td></tr>
<tr d-ix="9"><td>067</td><td>Mathematica</td><td>140825T171443Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36794#36794">Tyilo</a></td></tr>
<tr d-ix="10"><td>nan</td><td></td><td>140826T224757Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36882#36882">xnor</a></td></tr>
<tr d-ix="11"><td>173</td><td>MATLAB with Symbolic Toolbox</td><td>140826T194500Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36873#36873">COTO</a></td></tr>
<tr d-ix="12"><td>nan</td><td></td><td>140826T174220Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36863#36863">xnor</a></td></tr>
<tr d-ix="13"><td>342</td><td>Java</td><td>140826T150507Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36857#36857">Geobits</a></td></tr>
<tr d-ix="14"><td>249</td><td>Ruby</td><td>140826T142032Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36855#36855">histocra</a></td></tr>
<tr d-ix="15"><td>nan</td><td></td><td>140826T105035Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36845#36845">Dennis J</a></td></tr>
<tr d-ix="16"><td>146</td><td>Mathematica</td><td>140826T011047Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36814#36814">freddiek</a></td></tr>
<tr d-ix="17"><td>130</td><td>Ruby</td><td>140826T035111Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36827#36827">Vectoriz</a></td></tr>
<tr d-ix="18"><td>256</td><td>Perl</td><td>140826T024342Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36825#36825">hmatt1</a></td></tr>
<tr d-ix="19"><td>212</td><td>C</td><td>140826T002647Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36810#36810">Orby</a></td></tr>
<tr d-ix="20"><td>105</td><td>Lua</td><td>140826T015235Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36818#36818">Kyle Kan</a></td></tr>
<tr d-ix="21"><td>212</td><td>C</td><td>140826T011339Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36815#36815">sourtin</a></td></tr>
<tr d-ix="22"><td>239</td><td>C</td><td>140825T231825Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36807#36807">Orby</a></td></tr>
<tr d-ix="23"><td>nan</td><td></td><td>140825T093850Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36777#36777">isaacg</a></td></tr>
<tr d-ix="24"><td>468</td><td>Java</td><td>140825T174658Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36796#36796">Geobits</a></td></tr>
<tr d-ix="25"><td>958</td><td>Javascript</td><td>140825T202651Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36799#36799">rdans</a></td></tr>
<tr d-ix="26"><td>459</td><td>C</td><td>140825T192234Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36798#36798">BrainSte</a></td></tr>
<tr d-ix="27"><td>182</td><td>Python27</td><td>140825T154723Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36788#36788">stokasti</a></td></tr>
<tr d-ix="28"><td>116</td><td>GolfScript</td><td>140825T173307Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36795#36795">Peter Ta</a></td></tr>
<tr d-ix="29"><td>175</td><td>Ruby</td><td>140825T155257Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36789#36789">histocra</a></td></tr>
<tr d-ix="30"><td>125</td><td>Javascript</td><td>140825T145325Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36785#36785">rdans</a></td></tr>
<tr d-ix="31"><td>128</td><td>Python</td><td>140825T140341Z</td><td><a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36783#36783">Falko</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>C 93 bytes</h1>
<p>A simple hash. To follow the rule of unique solution, I bruteforced all the candidates, which took quite some core-hours. Of course the solution can be found in the same way.</p>
<p>The function <code>f</code> accepts a pointer to the 5 input integers and outputs 1 for the unique solution, 0 otherwise.</p>
<pre class="lang-c prettyprint-override"><code>i=1e5;f(int*x){for(;--i;)x[i&amp;3]+=(x[4]^=x[i&amp;3])*9&gt;&gt;3;return!memcmp(x,&quot;U|]v-W^Scv1(-8V8&quot;,16);}
</code></pre>
<p>For more adventurous hackers, here's a variant with 64-bit security (89 bytes), which I could not verify to have a unique solution due to too big search space (but the chance of it happening is less than 1 in a billion).</p>
<pre class="lang-c prettyprint-override"><code>i=1e5;f(int*x){for(;--i;)x[i&amp;3]+=(x[4]^=x[i&amp;3])*9&gt;&gt;3;return!memcmp(x,&quot;'=P(=31qlite&quot;,12);}
</code></pre>
</div>
<div id="pu1" class="pu"><h1>Python, 147</h1>

<p>Edit: shorter version based on Dennis' comment. I updated the sequence too to avoid leaking any information.</p>

<pre><code>def a(b):
    c=1
    for d in b:
        c=(c&lt;&lt;32)+d
    return pow(7,c,0xf494eca63dcab7b47ac21158799ffcabca8f2c6b3)==0xa3742a4abcb812e0c3664551dd3d6d2207aecb9be
</code></pre>

<p>Based on the discrete logarithm problem which is believed to be uncrackable, however the prime I'm using is probably too small to be secure (and it may have other issues, I don't know). And you can brute-force it of course, since the only unknowns are two 32-bit integers.</p>
</div>
<div id="pu2" class="pu"><h1>CJam, 62 characters</h1>

<pre><code>"ḡꬼ쏉壥떨ሤ뭦㪐ꍡ㡩折量ⶌ팭뭲䯬ꀫ郯⛅彨ꄇ벍起ឣ莨ຉᆞ涁呢鲒찜⋙韪鰴ꟓ䘦쥆疭ⶊ凃揭"2G#b129b:c~
</code></pre>

<p>Stack Exchange is prone to mauling unprintable characters, but copying the code from <a href="http://pastebin.com/xuuYip2T" rel="nofollow" title="block.cjam - Pastebin.com">this paste</a> and pasting it in the <a href="http://cjam.aditsu.net/" rel="nofollow">CJam interpreter</a> works fine for me.</p>

<h3>How it works</h3>

<p>After replacing the Unicode string with an ASCII string, the following code gets executed:</p>

<pre><code>" Push 85, read the integers from STDIN and collect everything in an array.               ";

85l~]

" Convert the array of base 4**17 digits into and array of base 2 digits.                 ";

4H#b2b

" Split into chunks of length 93 and 84.                                                  ";

93/~

" Do the following 611 times:

    * Rotate array A (93 elements) and B one element to the left.
    * B[83] ^= B[14]
    * T = B[83]
    * B[83] ^= B[0] &amp; B[1] ^ A[23]
    * A[92] ^= A[26]
    * Rotate T ^ A[92] below the arrays.
    * A[92] ^= A[0] &amp; A[1] ^ B[5].                                                        ";

{(X$E=^:T1$2&lt;:&amp;^2$24=^+\(1$26=^_T^@@1$2&lt;:&amp;^3$5=^+@}611*

" Discard the arrays and collects the last 177 generated bits into an array.              ";

;;]434&gt;

" Convert the into an integer and check if the result is 922 ... 593.                     ";

2b9229084211442676863661078230267436345695618217593=
</code></pre>

<p>This approach uses Bivium-B (see <a href="http://eprint.iacr.org/2013/240.pdf" rel="nofollow">Algebraic analysis of Trivium-like ciphers</a>), a weakened version of the stream cipher <a href="http://en.wikipedia.org/wiki/Trivium_(cipher)" rel="nofollow" title="Trivium (cipher) - Wikipedia, the free encyclopedia">Trivium</a>.</p>

<p>The program uses the sequence of integers as initial state, updates the state 434 times (354 rounds achieve full diffusion) and generates 177 bit of output, which it compares to those of the correct sequence.</p>

<p>Since the state's size is precisely 177 bits, this <em>should</em> suffice to uniquely identify the initial state.</p>

<h3>Example run</h3>

<pre><code>$ echo $LANG
en_US.UTF-8
$ base64 -d &gt; block.cjam &lt;&lt;&lt; IgThuKHqrLzsj4nlo6XrlqjhiKTrrabjqpDqjaHjoanmipjvpb7itozuoIDtjK3rrbLul7bkr6zqgKvvjafpg6/im4XlvajqhIfrso3uprrotbfvmL/hnqPojqjguonhhp7mtoHujLPuipzlkaLpspLssJzii5npn6rpsLTqn5PkmKbspYbnlq3itorlh4Pmj60iMkcjYjEyOWI6Y34=
$ wc -m block.cjam
62 block.cjam
$ cjam block.cjam &lt; block.secret; echo
1
$ cjam block.cjam &lt;&lt;&lt; "1 2 3 4 5"; echo
0
</code></pre>
</div>
<div id="pu3" class="pu"><h1>CJam, 91 characters</h1>

<pre><code>q~]KK#bD#"᫖࿼듋ޔ唱୦廽⻎킋뎢凌Ḏ끮冕옷뿹毳슟夫΢眘藸躦䪕齃噳卤"65533:Bb%"萗縤ᤞ雑燠Ꮖ㈢ꭙ㈶タ敫䙿娲훔쓭벓脿翠❶셭剮쬭玓ୂ쁬䈆﹌⫌稟"Bb=
</code></pre>

<p>Stack Exchange is prone to mauling unprintable characters, but copying the code from <a href="http://pastebin.com/ypekEyFR" rel="nofollow" title="lock.cjam - Pastebin.com">this paste</a> and pasting it in the <a href="http://cjam.aditsu.net/" rel="nofollow">CJam interpreter</a> works fine for me.</p>

<h3>How it works</h3>

<p>After replacing the Unicode string with integers (by considering the characters digits of base 65533 numbers), the following code gets executed:</p>

<pre><code>" Read the integers from STDIN and collect them in an array.                               ";

q~]

" Convert it into an integer by considering its elements digits of a base 20**20 number.   ";

KK#b

" Elevate it to the 13th power modulus 252 ... 701.                                        ";

D#
25211471039348320335042771975511542429923787152099395215402073753353303876955720415705947365696970054141596580623913538507854517012317194585728620266050701%

" Check if the result is 202 ... 866.                                                      ";

20296578126505831855363602947513398780162083699878357763732452715119575942704948999334568239084302792717120612636331880722869443591786121631020625810496866=
</code></pre>

<p>Since 13 is coprime to the totient of the modulus (the totient is secret, so you'll just have to trust me), different bases will generate different results, i.e., the solution is unique.</p>

<p>Unless someone can exploit the small exponent (13), the most efficient way of breaking this lock is to factorize the modulus (see <a href="http://en.wikipedia.org/wiki/RSA_problem" rel="nofollow" title="RSA problem - Wikipedia, the free encyclopedia">RSA problem</a>). I chose a 512-bit integer for the modulus, which should withstand 72 hours of factorization attempts.</p>

<h3>Example run</h3>

<pre><code>$ echo $LANG
en_US.UTF-8
$ base64 -d &gt; lock.cjam &lt;&lt;&lt; cX5dS0sjYkQjIgHuiJHhq5bgv7zrk4velOWUse6zjuCtpuW7veK7ju2Ci+uOouWHjOG4ju+Rh+uBruWGleyYt+u/ueavs+6boOyKn+Wkq86i55yY6Je46Lqm5KqV6b2D5Zmz75Wp5Y2kIjY1NTMzOkJiJSIB6JCX57ik4aSe74aS6ZuR54eg4Y+G44ii6q2Z44i244K/5pWr5Jm/5aiy7ZuU7JOt67KT7rO26IS/57+g4p2275+K7IWt5Ymu7Kyt546T4K2C7IGs5IiG77mM4quM56ifIkJiPQ==
$ wc -m lock.cjam
91 lock.cjam
$ cjam lock.cjam &lt; lock.secret; echo
1
$ cjam lock.cjam &lt;&lt;&lt; "1 2 3 4 5"; echo
0
</code></pre>
</div>
<div id="pu4" class="pu"><h1>CJam, 37 characters (broken)</h1>

<pre><code>"煷➻捬渓类ⶥ땙ዶ꾫㞟姲̷ᐂ㵈禙鰳쥛忩蔃"2G#b[1q~]4G#b%!
</code></pre>

<p><a href="http://cjam.aditsu.net/" rel="nofollow noreferrer" title="CJam interpreter">Try it online.</a></p>

<h3>How it works</h3>

<p><a href="https://codegolf.stackexchange.com/a/36952/">See my new answer.</a></p>

<h3>Example run</h3>

<pre><code>$ echo $LANG
en_US.UTF-8
$ base64 -d &gt; flock.cjam &lt;&lt;&lt; IueFt+Keu+aNrOa4k+exu+K2peuVmeGLtuq+q+Oen+Wnsu6AhMy34ZCC47WI56aZ6bCz7KWb5b+p6JSDIjJHI2JbMXF+XTRHI2IlIQ==
$ wc -m flock.cjam
37 flock.cjam
$ cjam flock.cjam &lt; flock.secret; echo
1
$ cjam flock.cjam &lt;&lt;&lt; "1 2 3 4 5"; echo
0
</code></pre>
</div>
<div id="pu5" class="pu"><h1>CJam, 49 characters</h1>

<pre><code>"腕옡裃䃬꯳널֚樂律ࡆᓅ㥄뇮┎䔤嬣ꑙ䘿휺ᥰ籃僾쎧諯떆Ἣ餾腎틯"2G#b[1q~]8H#b%!
</code></pre>

<p><a href="http://cjam.aditsu.net/" rel="nofollow noreferrer" title="CJam interpreter">Try it online.</a></p>

<h3>How it works</h3>

<pre><code>" Push a string representing a base 65536 number and convert it to an integer.            ";

"腕옡裃䃬꯳널֚樂律ࡆᓅ㥄뇮┎䔤嬣ꑙ䘿휺ᥰ籃僾쎧諯떆Ἣ餾腎틯"2G#b

" Prepend 1 to the integers read from STDIN and collect them into an array.               ";

[1q~]

" Convert that array into an integer by considering it a base 2**51 number.               ";

8H#b

" Push the logical NOT of the modulus of both computed integers.                          ";

%!
</code></pre>

<p>The result will be 1 if and only if the second integer is a factor of the first, which is a product of two primes: the one corresponding to the secret sequence and another that doesn't correspond to any valid sequence. Therefore, the solution is unique.</p>

<p>Factorizing a 512 bit integer isn't <em>that</em> difficult, but I hope nobody will be able to in 72 hours. My previous version using a 320 bit integer <a href="https://codegolf.stackexchange.com/questions/36768/lockers-vs-crackers-the-five-element-sequence/36887?noredirect=1#comment83347_36889">has been broken</a>.</p>

<h3>Example run</h3>

<pre><code>$ echo $LANG
en_US.UTF-8
$ base64 -d &gt; flock512.cjam &lt;&lt;&lt; IuiFleyYoeijg+SDrOqvs+uEkNaa76a/5b6L4KGG4ZOF76Gi46WE64eu4pSO5JSk5ayj6pGZ5Ji/7Zy64aWw57GD5YO+7I6n6Kuv65aG7qK04byr6aS+6IWO7rSn7YuvIjJHI2JbMXF+XThII2IlIQ==
$ wc -m flock512.cjam
49 flock512.cjam
$ cjam flock512.cjam &lt; flock512.secret; echo
1
$ cjam flock512.cjam &lt;&lt;&lt; "1 2 3 4 5"; echo
0
</code></pre>
</div>
<div id="pu6" class="pu"><h1>Python, 78</h1>
<p>(Cracked by Tyilo in 14 mins)</p>
<p>Fun!</p>
<pre><code>def L(a): return 1 if a==[(i-i**6) for i in bytearray(' ','utf-8')] else 0
</code></pre>
<p><a href="http://pastebin.com/CkEN608E" rel="nofollow noreferrer">Okay, it doesn't display properly here :(</a></p>
<p>Expects a list of five numbers, eg. [1,2,3,4,5]</p>
</div>
<div id="pu7" class="pu"><h1>Python, 86 characters</h1>

<pre class="lang-python prettyprint-override"><code>a,b,c,d,e=input()
print 1if(a*c^b*e)*d==0xd5867e26a96897a2f80 and b^d==48891746 else 0
</code></pre>

<p>Enter the numbers like <code>1,2,3,4,5</code>.</p>

<pre><code>&gt; python 36768.py &lt;&lt;&lt; "1,2,3,4,5"
0
&gt; python 36768.py &lt;&lt;&lt; "[REDACTED]"
1
</code></pre>
</div>
<div id="pu8" class="pu"><h1>Mathematica - 72</h1>

<p>Version 2 of my script, with the same key as the one intended for my version 1.</p>

<p>This basically removes negative prime numbers for <code>NextPrime</code>.</p>

<pre><code>f=Boole[(p=Abs[NextPrime/@#])-#=={18,31,6,9,2}&amp;&amp;BitXor@@#~Join~p==1000]&amp;
</code></pre>

<p>Running:</p>

<pre><code>f[{1,2,3,4,5}] (* =&gt; 0 *)
</code></pre>
</div>
<div id="pu9" class="pu"><h1>Mathematica <s>80</s> 67</h1>

<pre><code>f=Boole[(p=NextPrime/@#)-#=={18,31,6,9,2}&amp;&amp;BitXor@@#~Join~p==1000]&amp;
</code></pre>

<p>Running:</p>

<pre><code>f[{1,2,3,4,5}] (* =&gt; 0 *)
</code></pre>

<p>Probably pretty easy to crack, might also have multiple solutions.</p>

<p><strong>Update:</strong> Improved golfing by doing what Martin Büttner suggested. Functionality of the function and the key hasn't changed.</p>
</div>
<div id="pu10" class="pu"><h1><strike> Python 2 (91) </strike></h1>

<p><strong>Edit:</strong> This isn't allowed because the argument for uniqueness is probabilistic. I give up.</p>

<hr>

<pre class="lang-python prettyprint-override"><code>s=3
for n in input():s+=pow(n,s,7**58)
print s==0x8b5ca8d0cea606d2b32726a79f01adf56f12aeb6e
</code></pre>

<p>Takes lists of integers as input, like <code>[1,2,3,4,5]</code>. </p>

<p>The loop is meant to operate on the inputs in an annoying way, leaving a tower of sums and exponents. The idea is like discrete log, but with messy complication instead of mathematical simplicity. Maybe the compositeness of the  of the modulus is a vulnerability, in which case I could make it something like <code>7**58+8</code>. </p>

<p>I don't really know how I'd prove that my key is the only one, but the range of outputs is at least 10 times bigger than the range of inputs, so probably? Though maybe only a small fraction of potential outputs are achievable. I could always increase the number of digits at the cost of characters. I'll leave it up to you to decide what's fair. </p>

<p>Happy cracking!</p>
</div>
<div id="pu11" class="pu"><h1>MATLAB (with Symbolic Toolbox), 173 characters</h1>

<p>This isn't an official entry and won't count towards anyone's cracking score, but it will net you mad bragging rights. ;)</p>

<pre><code>function b=L(S),c=sprintf('%d8%d',S(1),S(2)-S(1));b=numel(unique(diff(S)))==1&amp;&amp;numel(c)==18&amp;&amp;all(c([8,9])==c([18,17]))&amp;&amp;isequal(c,char(sym(sort(c,'descend'))-sym(sort(c))));
</code></pre>

<p>The symbolic toolbox is only required to handle subtraction of big integers.</p>

<p>Brute forcing it should be a dog, but if you're familiar with the series it involves, the solution is trivial.</p>
</div>
<div id="pu12" class="pu"><h1><strike> Python 3 (152)</strike></h1>

<p><strong>Edit 2:</strong> I'm withdrawing this entry because it accepting the correct key seems to depend on hardware or version specifics, which would be unfair to crackers. On online Python 3 interpreters I tried, low-significance bits of the result differed slightly, suggesting the algorithm is sensitive to the exact hardware implementation of arithmetic.</p>

<p><strong>Edit:</strong> Made a much longer target to make uniqueness likely given 160 bits of input. Unfortunately, now this target takes over half my characters. This means that this style of submission is unfortunately largely a compression contest.</p>

<pre class="lang-python prettyprint-override"><code>def f(l,a=[0]):
 for n in l:a+=[(.8+.6j)**(n+a[-1])]
 return a[2::2]==[-0.20857691594748845+0.9907381787645837j,-0.7480510203178323-0.0856921111325014j]
</code></pre>

<p>Nothing systematic, just some annoying mangling with complex exponents.</p>
</div>
<div id="pu13" class="pu"><h1>Java : 342</h1>



<pre class="lang-java prettyprint-override"><code>int l(int[]a){String s=""+(a[1]-a[0]);for(int b:a)s+=b;char[]c=new char[11];for(char x:s.toCharArray())c[x&lt;48?10:x-48]++;for(int i=0;i&lt;11;c[i]+=48,c[i]=c[i]&gt;57?57:c[i],i++,s="");for(int b:a)s+=new Long(new String(c))/(double)b;return s.equals("-3083.7767567702776-8563.34366442527211022.4345579010483353.1736981951231977.3560837512646")?1:0;}
</code></pre>

<p>Here's a string-based locker that depends on both the input character count and the specific input. The sequence <em>might</em> be based on obscure pop culture references. Have fun!</p>

<p>A bit ungolfed:</p>

<pre class="lang-java prettyprint-override"><code>int lock(int[]a){
    String s=""+(a[1]-a[0]);
    for(int b:a)
        s+=b;
    char[]c=new char[11];
    for(char x:s.toCharArray())
        c[x&lt;48?10:x-48]++;
    for(int i=0;i&lt;11;c[i]+=48,
                     c[i]=c[i]&gt;57?57:c[i],
                     i++,
                     s="");
    for(int b:a)
        s+=new Long(new String(c))/(double)b;
    return s.equals("-3083.7767567702776-8563.34366442527211022.4345579010483353.1736981951231977.3560837512646")?1:0;
}
</code></pre>
</div>
<div id="pu14" class="pu"><h1>Ruby, 249</h1>

<pre><code>a=gets.scan(/\d+/).map(&amp;:to_i)
a.each_cons(2).map{|x,y|x-y}.uniq[1]&amp;&amp;p(0)&amp;&amp;exit
r=(a[0]*a[1]).to_s(5).tr'234','(+)'
v=a[0]&lt;a[1]&amp;&amp;!r[20]&amp;&amp;(0..3).select{|i|/^#{r}$/=~'%b'%[0xaa74f54ea7aa753a9d534ea7,'101'*32,'010'*32,'100'*32][i]}==[0]?1:0rescue 0
p v
</code></pre>

<p>Should be fun. Who needs math?</p>
</div>
<div id="pu15" class="pu"><h1>MATLAB: Apparently invalid</h1>
<p>Very simple, you just have to generate the right random number.</p>
<pre><code>function ans=t(a,b,c,d,e)
rng(a)
r=@(x)rng(rand*x)
r(b)
r(c)
r(d)
r(e)
rand==0.435996843156676
</code></pre>
<p>It can still error out, but that shouldn't be a problem.</p>
</div>
<div id="pu16" class="pu"><p><strong>Mathematica <s>142</s> 146</strong></p>

<p><strong>EDIT</strong>: key wasn't unique, added 4 chars, now it is.</p>

<pre><code>n=NextPrime;
f=Boole[
    FromDigits /@ (
        PartitionsQ[n@(237/Plus@##) {1, ##} + 1] &amp; @@@ 
            IntegerDigits@n@{Plus@##-37*Log[#3],(#1-#5)#4}
    ) == {1913001154,729783244}
]&amp;
</code></pre>

<p>(Spaces and newlines added for readability, not counted &amp; not needed).</p>

<p>Usage:</p>

<pre><code>f[1,2,3,4,5]   (* =&gt; 0 *)
</code></pre>
</div>
<div id="pu17" class="pu"><h2>Ruby - 130</h2>

<p>Based on Linear Feedback Shift Register. Inputs by command line arguments.<br>
Should be unique based on the nature of LFSRs. Clue: ascending and all positive. </p>

<p>Will give more clues if no one solves it soon. </p>

<pre><code>x=($*.map{|i|i.to_i+2**35}*'').to_i
(9**8).times{x=((x/4&amp;1^x&amp;1)&lt;&lt;182)+x/2}
p x.to_s(36)=="qnsjzo1qn9o83oaw0a4av9xgnutn28x17dx"?1:0
</code></pre>
</div>
<div id="pu18" class="pu"><h2>Perl - 256</h2>

<pre><code>sub t{($z,$j,$x,$g,$h)=@_;$t="3"x$z;@n=(7,0,split(//,$g),split(//,$h),4);@r=((2)x6,1,1,(2)x9,4,2,2,2);$u=($j+1)/2;for$n(0..$#r+1){eval{substr($t,$j,1)=$n[$n]};if($@){print 0; return}$j+=$r[$n]*$u}for(1..$x){$t=pack'H*',$t;}eval$t;if($@||$t!~/\D/){print 0}}
</code></pre>

<p>I had to put in a lot of error handling logic and this can definitely be golfed down a lot more. It will print a <code>1</code> when you get the right five numbers. It will <strong>hopefully</strong> print a <code>0</code> for everything else (might be errors or nothing, I don't know). If anyone wants to help improve the code or golf it more, feel free to help out!</p>

<hr>

<h2>Call with:</h2>

<pre><code>t(1,2,3,4,5);
</code></pre>
</div>
<div id="pu19" class="pu"><h2>C, 212 (Cracked)</h2>

<p>This is the same idea as my previous <a href="https://codegolf.stackexchange.com/a/36807/31002">submission</a>, golfed more thoroughly, with a bug corrected that passed 0,0,0,0,0 (Thanks to Dennis for pointing out the bug). Compile with -std=c99.</p>

<pre><code>#define L long long
p(L x){x=abs(x);for(L i=2;i&lt;x;i++){if((x/i)*i==x)return 0;}return(x&gt;1);}
f(a,b,c,d,e){char k[99];L m;sprintf(k,"%d%d%d%d%d",e,d,c,b,a);sscanf(k,"%lld",&amp;m);
return p(a)&amp;p(b)&amp;p(c)&amp;p(d)&amp;p(e)&amp;p(m);}
</code></pre>
</div>
<div id="pu20" class="pu"><h1>Lua 105</h1>
<p>I suspect it won't be long before it's cracked, but here we go:</p>
<pre><code>function f(a,b,c,d,e)
   t1=a%b-(e-2*(d-b))
   t2=(a+b+c+d+e)%e
   t3=(d+e)/2
   print(t1==0 and t2==t3 and&quot;1&quot;or&quot;0&quot;)
end
</code></pre>
<p>(spaces added for clarity, but are not part of count)</p>
</div>
<div id="pu21" class="pu"><h1>C, 212 by Orby -- Cracked</h1>
<p><a href="https://codegolf.stackexchange.com/a/36810/31064">https://codegolf.stackexchange.com/a/36810/31064</a> by Orby has at least two keys:</p>
<pre><code>13 103 193 283 373
113 173 233 293 353
</code></pre>
<p>Orby asked for the method I used to crack it. Function p checks whether x is prime by checking <code>x%i==0</code> for all i between 2 and x (though using <code>(x/i)*i==x</code> instead of <code>x%i==0</code>), and returns true if x is a prime number. Function f checks that all of a, b, c, d and e are prime. It also checks whether the number m, a concatenation of the decimal representations of e, d, c, b and a (in that order), is prime. The key is such that a,b,c,d,e and m are all prime.</p>
<p>Green and Tao (2004) show that there exist infinitely many arithmetic sequences of primes for any length k, so we just need to look for these sequences that also satisfy m being prime. By taking long long as being bounded by -9.223372037e+18 and 9.223372037e+18, we know that for the concatenated string to fit into long long, the numbers have an upper bound of 9999. So by using a python script to generate all arithmetic sequences within all primes &lt; 10000 and then checking whether their reverse concatenation is a prime, we can find many possible solutions.</p>
<p>For some reason I came up with false positives, but the two above are valid according to the program. In addition there may be solutions where e is negative and the rest are positive (p uses the modulus of x), but I didn't look for those.</p>
<p>The keys I gave are all arithmetic sequences but Orby's script doesn't appear to actually require the inputs to be an arithmetic sequence, so there may be invalid keys too.</p>
</div>
<div id="pu22" class="pu"><h2>C, 239 (Cracked by Dennis)</h2>

<p>Go <a href="https://codegolf.stackexchange.com/a/36810/31002">here</a> for my updated submission.</p>

<p>Could probably be golfed a little more thoroughly. Admittedly, I haven't taken the time to prove the key is unique (it probably isn't) but its definitely on the order of a hash collision. If you crack it, please share your method :)</p>

<pre><code>p(long long int x){long long int i;x=abs(x);
for (i=2;i&lt;x;i++) {if ((x/i)*i==x) return 0;}return 1;}
f(a,b,c,d,e){char k[99];long long int m;sprintf(k,"%d%d%d%d%d",e,d,c,b,a);
sscanf(k,"%lld",&amp;m);return p(a)&amp;&amp;p(b)&amp;&amp;p(c)&amp;&amp;p(d)&amp;&amp;p(e)&amp;&amp;p(m);}
</code></pre>
</div>
<div id="pu23" class="pu"><h1>Cracked by @Dennis in 2 hours</h1>
<hr />
<p>Just a simple one to get things started - I fully expect this to be quickly cracked.</p>
<h1><a href="https://github.com/isaacg1/pyth" rel="nofollow noreferrer">Pyth</a>, 13</h1>
<pre><code>h_^ZqU5m-CGdQ
</code></pre>
<p>Takes comma separated input on STDIN.</p>
<p>Run it like this (-c means take program as command line argument):</p>
<pre><code>$ echo '1,2,3,4,5' | python3 pyth.py -c h_^ZqU5m-CGdQ
0
</code></pre>
<p>Fixed the program - I had not understood the spec.</p>
<p>This language might be too esoteric for this competition - If OP thinks so, I will remove it.</p>
</div>
<div id="pu24" class="pu"><h1>Java : 468</h1>

<p>Input is given as <code>k(int[5])</code>. Bails early if not evenly spaced. Otherwise, it takes a bit figuring out if all ten hashes are correct. For large numbers, "a bit" can mean ten seconds or more, so it might dissuade crackers.</p>

<pre class="lang-java prettyprint-override"><code>//golfed
int k(int[]q){int b=q[1]-q[0],i,x,y,j,h[]=new int[]{280256579,123883276,1771253254,1977914749,449635393,998860524,888446062,1833324980,1391496617,2075731831};for(i=0;i&lt;4;)if(q[i+1]-q[i++]!=b||b&lt;1)return 0;for(i=1;i&lt;6;b=m(b,b/(i++*100),(1&lt;&lt;31)-1));for(i=0;i&lt;5;i++){for(j=1,x=b,y=b/2;j&lt;6;x=m(x,q[i]%100000000,(1&lt;&lt;31)-1),y=m(y,q[i]/(j++*1000),(1&lt;&lt;31)-1));if(x!=h[i*2]||y!=h[i*2+1])return 0;}return 1;}int m(int a,int b,int c){long d=1;for(;b--&gt;0;d=(d*a)%c);return (int)d;}

// line breaks
int k(int[]q){
    int b=q[1]-q[0],i,x,y,j,
    h[]=new int[]{280256579,123883276,1771253254,1977914749,449635393,
                  998860524,888446062,1833324980,1391496617,2075731831};
    for(i=0;i&lt;4;)
        if(q[i+1]-q[i++]!=b||b&lt;1)
            return 0;
    for(i=1;i&lt;6;b=m(b,b/(i++*100),(1&lt;&lt;31)-1));
    for(i=0;i&lt;5;i++){
        for(j=1,x=b,y=b/2;j&lt;6;x=m(x,q[i]%100000000,(1&lt;&lt;31)-1),y=m(y,q[i]/(j++*1000),(1&lt;&lt;31)-1));
        if(x!=h[i*2]||y!=h[i*2+1])
            return 0;
    }
    return 1;
}
int m(int a,int b,int c){
    long d=1;for(;b--&gt;0;d=(d*a)%c);
    return (int)d;
}
</code></pre>
</div>
<div id="pu25" class="pu"><h1>Javascript 958</h1>
<p>Converts the inputs to a number of data types and performs some manipulations relevant to each data type along the way. Should be fairly easily reversed for anyone that takes the time.</p>
<pre><code>function encrypt(num)
{
    var dateval = new Date(num ^ (1024-1) &lt;&lt; 10);
    
    dateval.setDate(dateval.getDate() + 365);
    
    var dateString = (dateval.toUTCString() + dateval.getUTCMilliseconds()).split('').reverse().join('');
    
    var result = &quot;&quot;;
    
    for(var i = 0; i &lt; dateString.length; i++)
        result += dateString.charCodeAt(i);
    
    return result;
}

function unlock(int1, int2, int3, int4, int5)
{
    return encrypt(int1) == &quot;5549508477713255485850495848483249555749321109774324948324410511470&quot; &amp;&amp; encrypt(int2) == &quot;5756568477713252485848495848483249555749321109774324948324410511470&quot; &amp;&amp; encrypt(int3) == &quot;5149538477713248485856485848483249555749321109774324948324410511470&quot; &amp;&amp; encrypt(int4) == &quot;5356498477713256535853485848483249555749321109774324948324410511470&quot; &amp;&amp; encrypt(int5) == &quot;5748568477713251535851485848483249555749321109774324948324410511470&quot; ? 1 : 0;
}
</code></pre>
</div>
<div id="pu26" class="pu"><h1>C 459 bytes</h1>
<h1>SOLVED BY Tyilo -- READ EDIT BELOW</h1>
<pre><code>int c (int* a){
int d[4] = {a[1] - a[0], a[2] - a[1], a[3] - a[2], a[4] - a[3]};
if (d[0] != d[1] || d[0] != d[2] || d[0] != d[3]) return 0;
int b[5] = {a[0], a[1], a[2], a[3], a[4]};
int i, j, k;
for (i = 0; i &lt; 5; i++) { 
for (j = 0, k = 2 * i; j &lt; 5; j++, k++) {
k %= i + 1;
b[j] += a[k];
}
}
if (b[0] == 0xC0942 - b[1] &amp;&amp; 
b[1] == 0x9785A - b[2] &amp;&amp; 
b[2] == 0x6E772 - b[3] &amp;&amp; 
b[3] == 0xC0942 - b[4] &amp;&amp; 
b[4] == 0xB6508 - b[0]) return 1;
else return 0;
}
</code></pre>
<p>We need someone to write a C solution, don't we? I'm not impressing anybody with length, I'm no golfer. I hope it's an interesting challenge, though!</p>
<p>I don't think there's an obvious way to crack this one, and I eagerly await all attempts! I know this solution to be unique. Very minimal obfuscation, mostly to meet length requirements. This can be tested simply:</p>
<pre><code>int main(){
    a[5] = {0, 0, 0, 0, 0} /* your guess */
    printf(&quot;%d\n&quot;, c(a));
    return 0;
}
</code></pre>
<p>P.S. There's a significance to <code>a[0]</code> as a number in its own right, and I'd like to see somebody point it out in the comments!</p>
<h1>EDIT:</h1>
<p>Solution: <code>6174, 48216, 90258, 132300, 174342</code></p>
<p>A note about cracking:</p>
<p>While this is not the method used (see the comments), I did happen to crack my own cipher with a very easy bruteforce. I understand now it is vitally important to make the numbers large. The following code can crack any cipher where <code>upper_bound</code> is a known upper bound for <code>a[0] + a[1] + a[2] + a[3] + a[4]</code>. The upper bound in the above cipher is <code>457464</code>, which can be derived from the system of equations of <code>b[]</code> and some working-through of the algorithm. It can be shown that <code>b[4] = a[0] + a[1] + a[2] + a[3] + a[4]</code>.</p>
<pre><code>int a[5];
for (a[0] = 0; a[0] &lt;= upper_bound / 5; a[0]++) {
    for (a[1] = a[0] + 1; 10 * (a[1] - a[0]) + a[0] &lt;= upper_bound; a[1]++) {
        a[2] = a[1] + (a[1] - a[0]);
        a[3] = a[2] + (a[1] - a[0]);
        a[4] = a[3] + (a[1] - a[0]);
        if (c(a)) {
            printf(&quot;PASSED FOR {%d, %d, %d, %d, %d}\n&quot;, a[0], a[1], a[2], a[3], a[4]);
        }
    }
    printf(&quot;a[0] = %d Checked\n&quot;, a[0]);
}
</code></pre>
<p>With <code>a[0] = 6174</code>, this loop broke my work in a little under a minute.</p>
</div>
<div id="pu27" class="pu"><h2>Python27, <s>283</s> 182</h2>

<p>Alright, I am very confident in my locker, however it is quite long as I've added 'difficult to reverse' calculations to the input, to make it well - difficult to reverse. </p>

<pre><code>import sys
p=1
for m in map(int,sys.argv[1:6]):m*=3**len(str(m));p*=m&lt;&lt;sum([int(str(m).zfill(9)[-i])for i in[1,3,5,7]])
print'01'[p==0x4cc695e00484947a2cb7133049bfb18c21*3**45&lt;&lt;101]
</code></pre>

<p>edit: Thanks to colevk for the further golfing. I realized during editing that there was a bug as well as a flaw in my algorithm, maybe I'll have better luck next time.</p>
</div>
<div id="pu28" class="pu"><h2>GolfScript (116 chars)</h2>

<p>Takes input as space-separated integers.</p>

<pre><code>~]{2.5??:^(&amp;}%^base 2733?5121107535380437850547394675965451197140470531483%5207278525522834743713290685466222557399=
</code></pre>
</div>
<div id="pu29" class="pu"><h1>Ruby, 175</h1>

<pre><code>a=gets.scan(/\d+/).map(&amp;:to_i)
a.each_cons(2).map{|x,y|x-y}.uniq[1]&amp;&amp;p(0)&amp;&amp;exit
p a[2]*(a[1]^a[2]+3)**7==0x213a81f4518a907c85e9f1b39258723bc70f07388eec6f3274293fa03e4091e1?1:0
</code></pre>

<p>Unlike using a cryptographic hash or <code>srand</code>, this is provably unique (which is a slight clue). Takes five numbers via STDIN, delimited by any non-digit, non-newline character or characters. Outputs to STDOUT.</p>
</div>
<div id="pu30" class="pu"><h1>Javascript 125</h1>
<p>This one should be cracked pretty quickly. I'll follow up with something stronger.</p>
<pre><code>function unlock(a, b, c, d, e)
{
    return (e &lt;&lt; a == 15652) &amp;&amp; (c &gt;&gt; a == 7826) &amp;&amp; (e - b == d) &amp;&amp; (d - c - a == b) ? 1 : 0;
}
</code></pre>
</div>
<div id="pu31" class="pu"><h1>Python - 128</h1>

<p>Let's try this one:</p>

<pre><code>i=input()
k=1050809377681880902769L
print'01'[all((i&gt;1,i[0]&lt;i[4],k%i[0]&lt;1,k%i[4]&lt;1,i[4]-i[3]==i[3]-i[2]==i[2]-i[1]==i[1]-i[0]))]
</code></pre>

<p>(Expects the user to input 5 comma-separated numbers, e.g. <code>1,2,3,4,5</code>.)</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/36768/">36768</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




