<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::12028</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>079</td><td>R</td><td>240704T173403Z</td><td><a href="https://codegolf.stackexchange.com/questions/12028/flipping-pancakes/273925#273925">int 21h </a></td></tr>
<tr d-ix="1"><td>074</td><td>JavaScript Node.js</td><td>240704T192740Z</td><td><a href="https://codegolf.stackexchange.com/questions/12028/flipping-pancakes/273926#273926">l4m2</a></td></tr>
<tr d-ix="2"><td>066</td><td>Perl 5.10 or higher</td><td>180202T073556Z</td><td><a href="https://codegolf.stackexchange.com/questions/12028/flipping-pancakes/154628#154628">Ton Hosp</a></td></tr>
<tr d-ix="3"><td>071</td><td>Haskell</td><td>180202T091131Z</td><td><a href="https://codegolf.stackexchange.com/questions/12028/flipping-pancakes/154630#154630">Laikoni</a></td></tr>
<tr d-ix="4"><td>229</td><td>C#</td><td>130815T185939Z</td><td><a href="https://codegolf.stackexchange.com/questions/12028/flipping-pancakes/12310#12310">user8865</a></td></tr>
<tr d-ix="5"><td>3421</td><td>GolfScript</td><td>130711T061217Z</td><td><a href="https://codegolf.stackexchange.com/questions/12028/flipping-pancakes/12034#12034">Volatili</a></td></tr>
<tr d-ix="6"><td>090</td><td>Python</td><td>130711T073557Z</td><td><a href="https://codegolf.stackexchange.com/questions/12028/flipping-pancakes/12037#12037">Keith Ra</a></td></tr>
<tr d-ix="7"><td>100</td><td>Perl</td><td>130711T062045Z</td><td><a href="https://codegolf.stackexchange.com/questions/12028/flipping-pancakes/12035#12035">breadbox</a></td></tr>
<tr d-ix="8"><td>029</td><td>GolfScript</td><td>130711T081519Z</td><td><a href="https://codegolf.stackexchange.com/questions/12028/flipping-pancakes/12038#12038">Howard</a></td></tr>
<tr d-ix="9"><td>079</td><td>Ruby 1.9</td><td>130711T011201Z</td><td><a href="https://codegolf.stackexchange.com/questions/12028/flipping-pancakes/12029#12029">Paul Pre</a></td></tr>
<tr d-ix="10"><td>282</td><td>Python</td><td>130711T022835Z</td><td><a href="https://codegolf.stackexchange.com/questions/12028/flipping-pancakes/12031#12031">WendiKid</a></td></tr>
<tr d-ix="11"><td>120</td><td>Python2</td><td>130711T071450Z</td><td><a href="https://codegolf.stackexchange.com/questions/12028/flipping-pancakes/12036#12036">Bakuriu</a></td></tr>
<tr d-ix="12"><td>254</td><td>Python 2</td><td>130711T053319Z</td><td><a href="https://codegolf.stackexchange.com/questions/12028/flipping-pancakes/12033#12033">miles</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.r-project.org" rel="nofollow noreferrer">R</a>, 79 bytes</h1>
<pre class="lang-r prettyprint-override"><code>\(v)for(j in sum(v|1):2){v[1:w]=v[(w=which.max(v)):1];v=rev(v[-1]);cat(w,j,&quot;&quot;)}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m72waMGiNNulpSVpuhY3_WM0yjTT8os0shQy8xSKS3M1ymoMNa2MNKvLog2tymNty6I1ym3LMzKTM_RyEyuAijWtDGOty2yLUss0yqJ1DWM1rZMTSzTKdbJ0lJQ0a6HGtqVpJGuY6ZjqmOgY6hjpGGtCVCnF5ClpcoHkTECiOoYY4mDVQF2maDIg61Bk0TVCJVCNhLhmwQIIDQA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>A function that takes in an unsorted array and prints out the flipping sequence to sort the array. The algorithm is the one described on Wikipedia<a href="https://en.m.wikipedia.org/wiki/Pancake_sorting" rel="nofollow noreferrer"><sup>1</sup></a>.</p>
<ul>
<li><code>for(j in sum(v|1):1)</code> run <span class="math-container">\$n-1\$</span> iterations, where <span class="math-container">\$n\$</span> is the size of the array to sort;</li>
<li><code>w=which.max(v)</code> find the position of the largest number;</li>
<li><code>v[1:w]=v[w:1]</code> insert the spatula between the largest pancake and the next one. Flip the upper pancakes so that the largest one gets on top;</li>
<li><code>v=rev(v[-1])</code> flip the whole heap of pancakes, so that the largest is at the bottom and remove it from the heap;</li>
<li><code>cat(w,j,&quot;&quot;)</code> output both flips.</li>
</ul>
<p>Now, the resulting sequence will always have <span class="math-container">\$(n-1)×2\$</span> flips, which is unnecessary long. Some flips could be skipped, like <code>1</code> or two flips of the whole stack - both of them do not change the order of pancakes. For instance, the sequence <code>6 5 4 1 2 3</code> will produce the flip sequence <code>1 6 5 5 4 4 1 3 2 2</code>, in which only <code>6</code> and <code>3</code> are important - other flips could be ignored.
The reason why those redundant flips do appear in the output is to have the code as short as possible.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 74 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>f=x=&gt;(i=0,k=x.find(c=&gt;c&gt;x[++i]))?[i+1,2,i+1,...f(x,x[i-1]=x[i],x[i]=k)]:[]
</code></pre>
<p><a href="https://tio.run/##bUxLCoMwEN17iuw6gzFo21Uh9gjdKiELiUlJFCP@CJSe3cZCd53FzPvMe67ZmllNdlyywbd63w0PvATLc9rxwIwdWlC8VGUQaWol4l3YtKBnemzGmIFAg7BZIXk88sCSdyhvQu4V4URc4@@FFjKpIzMgYqaSmBg/EXDEG1IjeSUkjvLD7HvNev@EihKHX/UoqdjcW6Uhpw7ZpDc9zRqQxYBqFvi5DjF5/2s6PdZlXJcT7h8" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<p>Bubble sort</p>
<p>Not directly comparable as I didn't do IO. Also <code>reverse</code> is long</p>
</div>
<div id="pu2" class="pu"><h1>Perl 5.10 (or higher), 66 bytes</h1>

<p>Includes <code>+3</code> for <code>-n</code>
The <code>use 5.10.0</code> to bring the language to level perl 5.10 is considered free</p>

<pre><code>#!/usr/bin/perl -n
use 5.10.0;
$'&gt;=$&amp;or$.=s/(\S+) \G(\S+)/$2 $1/*say"$. 2 $."while$.++,/\S+ /g
</code></pre>

<p>Run with the input as one line on STDIN:</p>

<pre><code>flop.pl &lt;&lt;&lt; "1 8 3 -5 6"
</code></pre>

<p>Sorts the list by repeatedly finding any inversion, flipping it to the front then flipping the inversion and flipping everything back to its old position. And that is equivalent to swapping the inversion so I don't need to reverse (which is awkward on strings since it would reverse the digits of the values converting e.g. <code>12</code> to <code>21</code>)</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, <s>72</s> 71 bytes</h1>



<pre class="lang-hs prettyprint-override"><code>h s|(a,x:b)&lt;-span(&lt;maximum s)s=map length[x:a,s]++h(reverse b++a)
h e=e
</code></pre>

<p><a href="https://tio.run/##VY4xagMxEEV7neJjUkhILpJ0i/cUKY2LMau1hEdaodGGLXz3jQIG42Zg3n/D/EBy98z7HiAPTW4bruZ0lEJZnxJtMa0JYmRMVMA@31o4bwM5uVgbdPW/vorH1VoyKsCPfheMOH@6L/ft@rwoNfNSIMidP33d6O47EANrMdWe90Uliv/StCiUtf20isPMsciAQyc15oYP9JqvuHpZucV8A0dpb9688MR4/tb9yux/" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a> Finds the maximum, flips it to the back and recursively sorts the remaining list.</p>

<p><em>Edit: -1 byte thanks to <a href="https://codegolf.stackexchange.com/users/48198/bmo">BMO</a></em></p>
</div>
<div id="pu4" class="pu"><p><strong>C# - 229</strong></p>

<pre><code>using System;using System.Linq;class P{static void Main(string[] a){
var n=a.ToList();Action&lt;int&gt;d=z=&gt;{Console.Write(z+" ");n.Reverse(0,z);};
int c=n.Count;foreach(var s in n.OrderBy(x=&gt;0-int.Parse(x))){
d(n.IndexOf(s)+1);d(c--);}}}
</code></pre>

<p>readable version</p>

<pre><code>using System;
using System.Linq;
class P {
    static void Main(string[] a) {
        var n = a.ToList();
        Action&lt;int&gt; d = z =&gt; { Console.Write(z + " "); n.Reverse(0, z); };
        int c = n.Count;
        foreach (var s in n.OrderBy(x =&gt; 0 - int.Parse(x))) {
            d(n.IndexOf(s) + 1); d(c--);
        }
    }
}
</code></pre>
</div>
<div id="pu5" class="pu"><h2>GolfScript, 34 / 21 chars</h2>

<p>(Thanks @PeterTaylor for chopping 4 chars off)</p>

<pre><code>~].{,,{1$=}$\}2*${.2$?.p)p.@\-+}/,
</code></pre>

<p><a href="http://golfscript.apphb.com/?c=OyIyIDEgMSIKfl0ueywsezEkPX0kXH0yKiR7LjIkPy5wKXAuQFwtK30vLA%3D%3D" rel="nofollow">Online test</a></p>

<p>A shorter, 21 character version works for lists with unique items only</p>

<pre><code>~].${.2$?.p)p.@\-+}/,
</code></pre>

<p><a href="http://golfscript.apphb.com/?c=OyI0IDIgMyAxIgp%2BXS4key4yJD8ucClwLkBcLSt9Lyw%3D" rel="nofollow">Online test</a></p>

<p>Both versions produce sub-optimal solutions.</p>

<hr>

<p>Explanation for the shorter solution:</p>

<pre><code>~]         # read input from stdin
.$         # produce a sorted copy from lowest to highest
{          # iterate over the sorted list
  .2$?     # grab the index of the element
  .p       # print the index
  )p       # increment and print the index
  .@\-+    # move the element to the front
}/
,          # leave the length of the list on the stack
           # this flips the reverse sorted list to become sorted
</code></pre>

<p>This uses a different algorithm to most of the others posted. Basically it grabs the smallest element of the list, and with two flips moves it to the front, preserving the other elements' order.</p>

<p>To move the nth element to the front:</p>

<pre><code>1 2 3 4 5 6 7   # let's move the 3rd (0-based) element to the front
# flip the first 3 elements
3 2 1 4 5 6 7
# flip the first 3+1 elements
4 1 2 3 5 6 7
</code></pre>

<p>It repeats this operation for each element in order, and ends up with a reverse sorted list. It then flips the whole list to leave it fully sorted.</p>

<hr>

<p>In fact the algorithm is a variation of a 90-char Python solution (my own, of course):</p>

<pre><code>d=map(int,raw_input().split());i=0
while d:n=d.index(max(d));d.pop(n);print n+i,n-~i,;i+=1
</code></pre>
</div>
<div id="pu6" class="pu"><h2>Python, <strike>91</strike> 90 chars</h2>

<pre><code>L=map(int,raw_input().split())
while L:i=L.index(max(L));print-~i,len(L),;L=L[:i:-1]+L[:i]
</code></pre>

<p>Flip the biggest pancake to the top, then flip the whole stack.  Remove the biggest pancake from the bottom and repeat.</p>

<p><code>i</code> is the index of the biggest pancake.  <code>L=L[:i:-1]+L[:i]</code> flips <code>i+1</code> pancakes, flips <code>len(L)</code> pancakes, then drops the last pancake.</p>
</div>
<div id="pu7" class="pu"><h2>Perl, <s>103</s> 100 characters</h2>

<p>Expects input on the command line.</p>

<pre><code>for(@n=sort{$ARGV[$a]&lt;=&gt;$ARGV[$b]}0..$#ARGV;@n;say$i+1,$/,@n+1)
{$i=pop@n;$_=@n-$_-($_&lt;=$i&amp;&amp;$i)for@n}
</code></pre>

<p>The solutions it prints are decidedly sub-optimal. (I had a program with much nicer output about 24 characters ago....)</p>

<p>The logic is kind of interesting. It starts by cataloguing the index of each item, were it in sorted order. It then iterates through this catalog from right to left. So applying a flip involves adjusting indexes below the cutoff value, instead of actually moving values around. After some finagling I also managed to save a few characters by doing both flips per iteration simultaneously.</p>
</div>
<div id="pu8" class="pu"><h3>GolfScript, <strike>31</strike> 29 characters</h3>
<pre><code>~].${1$?).p.2$.,p&gt;-1%\@&lt;+)}%,
</code></pre>
<p>Another GolfScript solution, can also be tested <a href="http://golfscript.apphb.com/?c=OyIzIDQgMSAyIgoKfl0uJHsxJD8pLnAuMiQuLHA%2BLTElXEA8Kyl9JSw%3D&amp;run=true" rel="noreferrer">online</a>.</p>
<p>Previous version:</p>
<pre><code>~].$-1%{1$?).2$&gt;-1%@2$&lt;+.,\);}/
</code></pre>
<p>How does it work: it flips the largest item to the top and then to the last place in the list. Since it is now in the correct position we can remove it from the list.</p>
<pre><code>~]         # Convert STDIN (space separated numbers) to array
.$-1%      # Make a sorted copy (largest to smallest)
{          # Iterate over this copy
  1$?)     # Get index of item (i.e. largest item) in the remaining list,
           # due to ) the index starts with one
  .        # copy (i.e. index stays there for output)
  2$&gt;      # take the rest of the list...
  -1%      # ... and reverse it 
  @2$&lt;     # then take the beginning of the list
  +        # and join both. 
           # Note: these operations do both flips together, i.e.
           # flip the largest item to front and then reverse the complete stack
  .,       # Take the length of the list for output
  \);      # Remove last item from list
}/
</code></pre>
</div>
<div id="pu9" class="pu"><h2>Ruby 1.9 - <strike>109</strike> <strike>88</strike> 79 characters</h2>

<p>Much more compact version based on Keith's great python solution:</p>

<pre class="lang-ruby prettyprint-override"><code>a=$*.map &amp;:to_i;$*.map{p v=a.index(a.max)+1,a.size;a=a[v..-1].reverse+a[0,v-1]}
</code></pre>

<p>Original version:</p>

<pre><code>a=$*.map &amp;:to_i
a.size.downto(2){|l|[n=a.index(a[0,l].max)+1,l].map{|v|v&gt;1&amp;&amp;n&lt;l&amp;&amp;p(v);a[0,v]=a[0,v].reverse}}
</code></pre>

<p>If you don't care about spurious operations (reversing stacks of size 1, or reversing the same stack twice in a row) you can make it a bit shorter (96 chars):</p>

<pre><code>a=$*.map &amp;:to_i
a.size.downto(2){|l|[a.index(a[0,l].max)+1,l].map{|v|p v;a[0,v]=a[0,v].reverse}}
</code></pre>

<p>Takes the unsorted list as command-line args.  Example usage:</p>

<pre><code>&gt;pc.rb 4 2 3 1
4
2
3
2
</code></pre>
</div>
<div id="pu10" class="pu"><h2>Python - 282 characters</h2>

<pre><code>import sys
s=sys.argv[1]
l=s.split()
p=[]
for c in l:
 p.append(int(c))
m=sys.maxint
n=0
while(n==(len(p)-1)):
 i=x=g=0
 for c in p:
  if c&gt;g and c&lt;m:
   g=c
   x=i
  i+=1
 m=g
 x+=1
 t=p[:x]
 b=p[x:]
 t=t[::-1]
 p=t+b
 a=len(p)-n;
 t=p[:a]
 b=p[a:]
 t=t[::-1]
 p=t+b
 print p
 n+=1
</code></pre>

<p>My first ever code golf; I'm under no illusions I'll <em>win</em>, but I had a lot of fun. Giving everything one-character names sure makes it frightening to read, let me tell you! This is run from the command line, sample implementation below:</p>

<pre><code>Python PancakeSort.py "4 2 3 1"
[1, 3, 2, 4]
[2, 1, 3, 4]
[1, 2, 3, 4]
</code></pre>

<p>There's nothing particularly special or inventive about the way I've gone about this, but the FAQ suggests posting a non-golfed version for interested readers, so I've done so below:</p>

<pre><code>import sys

pancakesStr = sys.argv[1]
pancakesSplit = pancakesStr.split()
pancakesAr = []
for pancake in pancakesSplit:
    pancakesAr.append(int(pancake))

smallestSorted = sys.maxint
numSorts = 0

while(numSorts &lt; (len(pancakesAr) - 1)):
    i = 0
    biggestIndex = 0
    biggest = 0
    for pancake in pancakesAr:
        if ((pancake &gt; biggest) and (pancake &lt; smallestSorted)):
            biggest = pancake
            biggestIndex = i
        i += 1

    smallestSorted = biggest  #you've found the next biggest to sort; save it off.
    biggestIndex += 1   #we want the biggestIndex to be in the top list, so +1.

    top = pancakesAr[:biggestIndex]
    bottom = pancakesAr[biggestIndex:]

    top = top[::-1] #reverse top to move highest unsorted number to first position (flip 1)
    pancakesAr = top + bottom   #reconstruct stack

    alreadySortedIndex = len(pancakesAr) - numSorts;

    top = pancakesAr[:alreadySortedIndex]
    bottom = pancakesAr[alreadySortedIndex:]

    top = top[::-1] #reverse new top to move highest unsorted number to the bottom position on the unsorted list (flip 2)
    pancakesAr = top + bottom   #reconstruct list

    print pancakesAr    #print after each flip

    numSorts += 1

print "Sort completed in " + str(numSorts) + " flips. Final stack: "
print pancakesAr
</code></pre>

<p>The basic algorithm I used is the one mentioned in the <a href="http://en.wikipedia.org/wiki/Pancake_sorting" rel="nofollow">wiki article linked in the question</a>: </p>

<blockquote>
  <p>The simplest pancake sorting algorithm requires at most 2n−3 flips. In this algorithm, a variation of selection sort, we bring the largest pancake not yet sorted to the top with one flip, and then take it down to its final position with one more, then repeat this for the remaining pancakes.</p>
</blockquote>
</div>
<div id="pu11" class="pu"><p><strong>Python2: 120</strong></p>

<pre><code>L=map(int,raw_input().split())
u=len(L)
while u:i=L.index(max(L[:u]))+1;L[:i]=L[i-1::-1];L[:u]=L[u-1::-1];print i,u;u-=1
</code></pre>

<p>It's not efficient: it wont find the best sorting sequence, and the given sequence can even contain no-ops(i.e. flipping only the first element), nevertheless the output is valid.</p>

<p>The output is given in the form:</p>

<pre><code>n_1 n_2
n_3 n_4
n_5 n_6
...
</code></pre>

<p>Which should be read as the sequence of flips: <code>n_1 n_2 n_3 n_4 n_5 n_6 ...</code>.
If you want to obtain an output like:</p>

<p>n_1 n_2 n_3 n_4 n_5 n_6 ...</p>

<p>Simply add a comma in the <code>print</code> statement.</p>
</div>
<div id="pu12" class="pu"><h2>Python 2 (254)</h2>

<p>Simple BFS-search, some stuff is inlined, probably could be compressed more without changing the search style. Hopefully this shows maybe how to start golfing a bit (too much to be in a simple comment).</p>

<p>Use:</p>

<pre><code>python script.py 4 2 3 1
</code></pre>

<p>(2 spaces = tab)</p>

<pre><code>import sys
t=tuple
i=t(map(int,sys.argv[1:]))
g=t(range(1,len(i)+1))
q=[i]
p={}
l={}
while q:
 c=q.pop(0)
 for m in g:
  n=c[:m][::-1]+c[m:]
  if n==g:
   s=[m]
   while c!=i:s+=[l[c]];c=p[c]
   print s[::-1]
   sys.exit()
  elif n not in p:q+=[n];p[n]=c;l[n]=m
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/12028/">12028</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




