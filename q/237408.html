<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::237408</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>059</td><td>Pip</td><td>211119T042919Z</td><td><a href="https://codegolf.stackexchange.com/questions/237408/write-a-stack-exchange-compliant-brainfuck-explainer/237462#237462">DLosc</a></td></tr>
<tr d-ix="1"><td>079</td><td>Vyxal 3 Ṡ</td><td>231218T201017Z</td><td><a href="https://codegolf.stackexchange.com/questions/237408/write-a-stack-exchange-compliant-brainfuck-explainer/268627#268627">Fmbalbue</a></td></tr>
<tr d-ix="2"><td>231</td><td>Haskell</td><td>211129T212934Z</td><td><a href="https://codegolf.stackexchange.com/questions/237408/write-a-stack-exchange-compliant-brainfuck-explainer/237828#237828">Radek</a></td></tr>
<tr d-ix="3"><td>701</td><td>brainfuck</td><td>211124T161624Z</td><td><a href="https://codegolf.stackexchange.com/questions/237408/write-a-stack-exchange-compliant-brainfuck-explainer/237622#237622">tjjfvi</a></td></tr>
<tr d-ix="4"><td>138</td><td>Ruby</td><td>211125T221505Z</td><td><a href="https://codegolf.stackexchange.com/questions/237408/write-a-stack-exchange-compliant-brainfuck-explainer/237695#237695">lonelyel</a></td></tr>
<tr d-ix="5"><td>330</td><td>Haskell</td><td>211128T000238Z</td><td><a href="https://codegolf.stackexchange.com/questions/237408/write-a-stack-exchange-compliant-brainfuck-explainer/237775#237775">Natte</a></td></tr>
<tr d-ix="6"><td>118</td><td>Ruby</td><td>211127T003447Z</td><td><a href="https://codegolf.stackexchange.com/questions/237408/write-a-stack-exchange-compliant-brainfuck-explainer/237752#237752">Natte</a></td></tr>
<tr d-ix="7"><td>093</td><td>Perl 5 + nF M5.10.0</td><td>211119T130721Z</td><td><a href="https://codegolf.stackexchange.com/questions/237408/write-a-stack-exchange-compliant-brainfuck-explainer/237469#237469">Dom Hast</a></td></tr>
<tr d-ix="8"><td>047</td><td>Charcoal</td><td>211118T074916Z</td><td><a href="https://codegolf.stackexchange.com/questions/237408/write-a-stack-exchange-compliant-brainfuck-explainer/237421#237421">Neil</a></td></tr>
<tr d-ix="9"><td>188</td><td>C clang</td><td>211120T012057Z</td><td><a href="https://codegolf.stackexchange.com/questions/237408/write-a-stack-exchange-compliant-brainfuck-explainer/237482#237482">a stone </a></td></tr>
<tr d-ix="10"><td>046</td><td>Jelly</td><td>211120T030657Z</td><td><a href="https://codegolf.stackexchange.com/questions/237408/write-a-stack-exchange-compliant-brainfuck-explainer/237484#237484">Unrelate</a></td></tr>
<tr d-ix="11"><td>050</td><td>05AB1E</td><td>211118T082051Z</td><td><a href="https://codegolf.stackexchange.com/questions/237408/write-a-stack-exchange-compliant-brainfuck-explainer/237423#237423">Kevin Cr</a></td></tr>
<tr d-ix="12"><td>045</td><td>Stax</td><td>211118T163902Z</td><td><a href="https://codegolf.stackexchange.com/questions/237408/write-a-stack-exchange-compliant-brainfuck-explainer/237448#237448">Razetime</a></td></tr>
<tr d-ix="13"><td>069</td><td>Vyxal oj</td><td>211118T035102Z</td><td><a href="https://codegolf.stackexchange.com/questions/237408/write-a-stack-exchange-compliant-brainfuck-explainer/237412#237412">lyxal</a></td></tr>
<tr d-ix="14"><td>205</td><td>Retina</td><td>211118T121625Z</td><td><a href="https://codegolf.stackexchange.com/questions/237408/write-a-stack-exchange-compliant-brainfuck-explainer/237436#237436">Neil</a></td></tr>
<tr d-ix="15"><td>141</td><td>JavaScript ES2022</td><td>211118T060350Z</td><td><a href="https://codegolf.stackexchange.com/questions/237408/write-a-stack-exchange-compliant-brainfuck-explainer/237418#237418">tsh</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/dloscutoff/pip" rel="nofollow noreferrer">Pip</a>, <s>65</s> <s>60</s> 59 bytes</h1>
<pre><code>OsX4FiPp:#_FIa^C X^Y&quot;&gt;&lt;+-.,[]&quot;P[sX4pRXXsRA Uvis(gs.y@?i|9)]
</code></pre>
<p>The BF program and the nine explanation strings are taken as command-line arguments. Alternately, you can use the <code>-r</code> flag to take them from stdin. <a href="https://ato.pxeger.com/run?1=m724ILNgWbSSbpFS7IKlpSVpuhY3rf2LI0zcMgMKrJTj3TwT45wVIuIilexstHX1dKJjlQKigdIFQRERxUGOCqFlmcUa6cV6lQ72mTWWmrEQI6AmLbjpYwDR5ucfEB1rwBWUmZ5RwuWTmlbC5ZmXXJSam5pXwuWSCmP5l5YUlIKkQGR4RmZOKldQakFqYgmXX75ufgHEUAA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<h3>Explanation</h3>
<p>First, the setup:</p>
<pre><code>OsX4  Pp:#_FIa^C X^Y&quot;&gt;&lt;+-.,[]&quot;
 sX4                            Space character, repeated 4 times
O                               Output it without trailing newline
                   Y&quot;&gt;&lt;+-.,[]&quot;  Yank that string into y (BF commands)
                  ^             Split into a list of chars
                 X              Convert to a regex that matches any one of
                                those chars
               C                Wrap the regex in a capture group
             a^                 Split the first program arg on that regex
                                (As in Python, splitting on a regex wrapped in
                                a group keeps the matches of the regex in the
                                result list)
           FI                   Filter that list on this function:
         #_                      Length of item
                                (This gets rid of empty strings while not getting
                                rid of &quot;0&quot;, which is falsey in Pip)
       p:                       Assign the result to p (the processed program)
      P                         Print it with trailing newline
</code></pre>
<p>Then, the main loop:</p>
<pre><code>Fi...P[sX4pRXXsRA Uvis(gs.y@?i|9)]
Fi                                  For i in
  ...                               the quantity we just assigned to p and printed:
      [                          ]   List containing:
       sX4                            1. Four spaces
                                      2. Current chunk, padded:
          pR                           In p, replace
            XX                         Regex matching any character
              s                        With space
               RA                      Replace the element at index
                   v                   v (initially -1)
                  U                    Incremented each time through the loop
                    i                  With i, the current chunk
                     s                4. One more space before explanation
                                      5. Explanation:
                        s.y            BF commands with a space prefixed
                           @?i         Index of current chunk in that string
                                       (1 to 8 if BF command, 0 or nil otherwise)
                               |9      Logical OR with 9
                                       (1 to 8 if BF command, 9 otherwise)
                      (g         )     Item in program args at that index
     P                               Concatenate and print that whole list
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal/tree/version-3" rel="nofollow noreferrer">Vyxal 3</a> <code>Ṡ</code>, <s>80</s> 79 bytes</h1>
<pre><code>Dð4×§,0$&quot;&lt;&gt;+-.,[]&quot;£([¥nc[⁰Lm-ꜝð×§¹,|n§1#x)4m+ð×§¥nḞꜝ:[#?Ḣin§⁰Lm-ð×§,0|n§1][ð§¹,
</code></pre>
<p><a href="https://vyxal.github.io/latest.html#WyLhuaAiLCIiLCJEw7A0w5fCpywwJFwiPD4rLS4sW11cIsKjKFvCpW5jW+KBsExtLeqcncOww5fCp8K5LHxuwqcxI3gpNG0rw7DDl8KnwqVu4bie6pydOlsjP+G4omluwqfigbBMbS3DsMOXwqcsMHxuwqcxXVvDsMKnwrksIiwiIiwiKystLTw8Pj4uLiwsW1tdXWFhYmJjY34rKy0tPDwrKy0tPDw+Pi4uLCxbW11dYWFiYmNjfisrLS08PFxufmFhYWNcbjw8PDw8XG4+Pj4+PlxuKysrKytcbi0tLS0tXG4uLi4uLlxuLCwsLCxcbltbW1tbXG5dXV1dXSIsIjMuMy4wIl0=" rel="nofollow noreferrer">Try it Online!</a></p>
<h3>Explanation:</h3>
<p>Setup:</p>
<pre><code>Dð4×§,0$&quot;&lt;&gt;+-.,[]&quot;£(­⁡​‎‎⁪⁡⁪⁠⁪⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁪‏‏​⁡⁠⁡‌⁢​‎‎⁪⁡⁪⁠⁪⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁪‏‏​⁡⁠⁡‌⁣​‎⁪⁪⁠⁪⁪⁠⁪⁪⁠⁪⁪⁠‎⁪⁡⁪⁠⁪⁣⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁣⁪‏‏​⁡⁠⁡‌⁤​‎⁪⁪⁠⁪⁪⁠⁪⁪⁠⁪⁪⁠‎⁪⁡⁪⁠⁪⁢⁡⁤⁪‏‏​⁡⁠⁡‌⁢⁡​‎‎⁪⁡⁪⁠⁪⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁪‏⁠⁪⁪‏​⁡⁠⁡‌⁢⁢​‎⁪⁪⁠⁪⁪⁠⁪⁪⁠⁪⁪⁠⁪⁪⁠⁪⁪‏​⁡⁠⁡‌­
 ð4×§                 ## ‎⁡Print &quot;    &quot; without newline
D    ,                ## ‎⁢Print the first line of input with newline
        &quot;&lt;&gt;+-.,[]&quot;£   ## ‎⁣Put &quot;&lt;&gt;+-.,[]&quot; in the register
      0$              ## ‎⁢⁡Push the 0 in the stack (Swapped because the top of the stack is used for looping)
                   (  ## ‎⁤Loop every char in the first line of input
</code></pre>
<p>Looping part:</p>
<pre><code>[¥nc[⁰Lm-ꜝð×§¹,|n§1#x)4m+ð×§¥nḞꜝ:[#?Ḣin§⁰Lm-ð×§,0|n§1]­⁡​‎‎⁪⁡⁪⁠⁪⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁪‏⁠⁪⁪‏​⁡⁠⁡‌⁢​‎‎⁪⁡⁪⁠⁪⁢⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁣⁪‏‏​⁡⁠⁡‌⁣​‎‎⁪⁡⁪⁠⁪⁤⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁢⁪‏‏​⁡⁠⁡‌⁤​‎‎⁪⁡⁪⁠⁪⁢⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁤⁪‏‏​⁡⁠⁡‌⁢⁡​‎‎⁪⁡⁪⁠⁪⁢⁤⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁤⁪‏⁠⁪⁪‏​⁡⁠⁡‌⁢⁢​‎‎⁪⁡⁪⁠⁪⁣⁡⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁡⁢⁪‏⁠⁪⁪⁠⁪⁪‏​⁡⁠⁡‌⁢⁣​‎‎⁪⁡⁪⁠⁪⁣⁡⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁡⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁢⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁢⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁢⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁣⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁣⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁣⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁣⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁤⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁤⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁤⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁤⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁡⁡⁪‏‏​⁡⁠⁡‌⁢⁤​‎‎⁪⁡⁪⁠⁪⁤⁡⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁡⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁡⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁢⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁢⁢⁪‏‏​⁡⁠⁡‌­
[¥nc[                                                   ## ‎⁡if the current character is in &quot;&lt;&gt;+-.,[]&quot;
     ⁰Lm-ꜝð×§¹,                                         ## ‎⁢print that many spaces, then the second line of input, with newline.
               |n§1#x)                                  ## ‎⁣else print the current character and continue with the 1 in the top of the stack.
                      4m+ð×§                            ## ‎⁤Print that many spaces
                            ¥nḞꜝ                        ## ‎⁢⁡index of the current character (1 to 8, 0 if not found)
                                :[                      ## ‎⁢⁢if the index of the current character is 1 or more
                                  #?Ḣin§⁰Lm-ð×§,0       ## ‎⁢⁣Print that many spaces, then the right explanation, with newline, and push 0
                                                 |n§1]  ## ‎⁢⁤else, print the current character, and push 1
</code></pre>
<p>Final part:</p>
<pre><code>[ð§¹,­⁡​‎‎⁪⁡⁪⁠⁪⁡⁪‏⁠⁪⁪⁠⁪⁪⁠⁪⁪⁠⁪⁪‏​⁡⁠⁡‌⁢​‎‎⁪⁡⁪⁠⁪⁡⁪‏‏​⁡⁠⁡‌⁣​‎‎⁪⁡⁪⁠⁪⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁪‏⁠⁪⁪⁠⁪⁪‏​⁡⁠⁡‌⁤​‎‎⁪⁡⁪⁠⁪⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁪‏‏​⁡⁠⁡‌­
[      ## ‎⁡If the top of stack is 1 or greater
       ## ‎⁢(I have no idea why that works)
 ð§    ## ‎⁣print &quot; &quot; without newline
   ¹,  ## ‎⁤Print the second line of input, with newline
💎
</code></pre>
<p>Created with the help of <a href="https://vyxal.github.io/Luminespire" rel="nofollow noreferrer">Luminespire</a>.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, <strike>235</strike> 231 bytes</h1>

<pre class="lang-hs prettyprint-override"><code>import Data.List
main=interact$unlines.map(&quot;    &quot;++).f&quot;&gt;&lt;+-.,[]&quot;.lines
f o(i:e)|let t=not.(`elem`o);p=(&gt;&gt;&quot; &quot;).concat;w((c:r):t)=(c:r++p t++' ':maybe(e!!8)id(lookup c$zip o e)):[p[c:r]++l|l&lt;-w t];w[]=[]=i:w(groupBy(\x y-&gt;t x&amp;&amp;t y)i)
</code></pre>
<p><a href="https://tio.run/##jZLPbtswDMbvfgrWKFoJio0dByf2Yeilw7Y@gGegikLHRPQPNr3UXffsmZNsQw8LWoIHip9@oPhBnR52aO3hQC6GnuFOs86/0MCJ0@RL8oy9Nnw9ekseh9zpKFKYI1VK5m1arVSWL@omzU960kIQVKB8scjApQ@ci0e06B6DXMZSVFUKqcxN8Ebzci@EKXpZsCyPhVIRWKlbuC2cntYo8Orqo6SNsCHsxgjm@pkiBEApizrWM9EoZV/sKtsDN8t93ZRzUrEX2z6M8dMkvj/BlFUMTzc3DJMkeTjUzar6@UtIpbIszxeL5Gv4gcAdQgyndYHD6djTtuOLqsWWk3tvenTo@dRy6EI/gZn9BM2voeQO33nxYeQ4nlum00fr55EDbT21hBtYT2fpP@S9P4L6Fab9BgYOPQIxkL9Ifh5dhKiHP4/TbDryW2iA2ksM0AAfzuBam91fU/6x9RusD/4Z@5B8C/AQ5x/GFPxv" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
<p>Old answer:</p>
<p><strong><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, 235 bytes</strong></p>

<pre class="lang-hs prettyprint-override"><code>import Data.List
main=interact$unlines.map(&quot;    &quot;++).f.lines
o=&quot;&gt;&lt;+-.,[]&quot;
t=not.(`elem`o)
p=(&gt;&gt;&quot; &quot;).concat
f(i:e)|let w((c:r):t)=(c:r++p t++' ':maybe(last e)id(lookup c$zip o e)):[p[c:r]++l|l&lt;-w t];w[]=[]=i:(w$groupBy(\x y-&gt;t x&amp;&amp;t y)i)
</code></pre>
<p><a href="https://tio.run/##jZLBbtswDIbvegrCCFoJio2dvdiHopcW2/oAnoEqCh0TkSXBppe66549cxx06GHBRuhA/tQHUj/UmuGAzp1O1MXQM9wbNtkXGlh0hnxBnrE3llejd@RxyDoTZQJzJFqrrMkWVYQiKTc6zdZVnQgufOBMPqPD7jkoEQtZlgkkKrPBW8OikZSjenPIcJTS5r3KWRXnROsIrPUt3OadmbYonRkYUNFOuhAOYwS7eqUIYdZUXsVqZmqt3ZvbpEfg@vOxqov5UC6Pq30fxng3ye8vMKUlw8vNDcOkSJ1OVb0pf/6SSus0zbL1WnwNPxC4RYhheTJwWMqe9i1f7TpsWDx422OHnhepwy70E9jZUzD8ERL3@J8Xn0aO40WyrTnbP48caO@pIdzBdrq0/kI@@DNoPmDG72Dg0CMQA/mr5OPYRYhnt5flDNuW/B5qoOYaAzTApwu4NfbwbsoftvoH64N/xT6IbwGe4vzLmIL/DQ" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
<p><em>The answer is not final, will probably be golfed further.</em></p>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/TryItOnline/brainfuck" rel="noreferrer">brainfuck</a>, <s>811</s> <s>775</s> <s>709</s> 701 bytes</h1>
<pre><code>&gt;&gt;-[-[---&gt;]&lt;&lt;-]&gt;--...&lt;++++++++++.&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+[-&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;,[[-&lt;+&lt;+&gt;&gt;]&lt;----------[[-]-&gt;]-[+&gt;-]&lt;&lt;&lt;+[-&lt;[-]&gt;]&lt;[-&lt;+&gt;&gt;+&lt;]++++++[-&gt;-------&lt;]&gt;&gt;++++++[-&lt;&lt;++++++&gt;&gt;]&gt;+&lt;&lt;-[&lt;-&gt;&gt;]&gt;[&lt;]&lt;-[&lt;-------&gt;&gt;]&gt;[&lt;]&lt;-[&lt;--&gt;&gt;]&gt;[&lt;]&lt;-[&lt;--------&gt;&gt;]&gt;[&lt;]&lt;--------------[&lt;---&gt;&gt;]&gt;[&lt;]&lt;--[&lt;----&gt;&gt;]&gt;[&lt;]+++++[-&lt;------&gt;]&lt;+[&lt;-----&gt;&gt;]&gt;[&lt;]&lt;--[&lt;------&gt;&gt;]&gt;[&lt;]&lt;[-]&lt;&lt;+&gt;[&gt;&gt;&gt;-]&lt;[&gt;&gt;&gt;]&lt;&lt;&lt;-&gt;&gt;++++[-&gt;++++++++&lt;]+&gt;&gt;&gt;+&gt;]&lt;]+[&lt;&lt;&lt;&lt;&lt;&lt;]&gt;&gt;&gt;&gt;[.&gt;&gt;&gt;&gt;&gt;&gt;]&gt;&gt;&gt;&gt;-&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;[&lt;&lt;&lt;&lt;&lt;&lt;]&lt;&lt;&lt;&lt;&lt;.&gt;&gt;&gt;+[-&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;[&gt;&gt;&gt;&gt;&gt;&gt;]&lt;&lt;&lt;&lt;&lt;[&lt;[&lt;&lt;.&lt;&lt;&lt;&lt;]&gt;&gt;&gt;&gt;&gt;&gt;[&gt;&gt;&gt;&gt;&gt;&gt;]&lt;&lt;&lt;&lt;&lt;.&gt;&gt;&gt;&gt;[&gt;+&gt;&gt;&gt;&gt;&gt;[&lt;&lt;&lt;&lt;.&gt;&gt;&gt;&gt;&gt;+&gt;&gt;&gt;&gt;&gt;]&lt;&lt;&lt;&lt;[&gt;&gt;&gt;.&gt;&gt;&gt;]&gt;&gt;&gt;.&gt;&gt;&gt;[.&gt;&gt;&gt;&gt;&gt;&gt;]&gt;&gt;[&lt;&lt;&lt;&lt;&lt;&lt;]&lt;]&lt;&lt;&lt;[&gt;-&gt;&gt;&gt;+&gt;[&gt;&gt;&gt;.&gt;&gt;&gt;]&gt;&gt;-&lt;&lt;&lt;&lt;&lt;.&lt;[&lt;&lt;&lt;&lt;&lt;&lt;]&lt;[-&gt;&gt;&gt;&gt;&gt;&gt;&gt;[&gt;&gt;&gt;&gt;&gt;&gt;]+&gt;&gt;&gt;&gt;[&gt;&gt;&gt;&gt;&gt;&gt;]&gt;&gt;-&lt;&lt;&lt;&lt;&lt;&lt;[&lt;&lt;&lt;&lt;&lt;&lt;]&lt;]&gt;+[&gt;&gt;&gt;&gt;&gt;&gt;]+&gt;&gt;&gt;&gt;[.&gt;&gt;&gt;&gt;&gt;&gt;]&gt;&gt;[&lt;&lt;&lt;&lt;&lt;&lt;]&lt;&lt;&lt;&lt;]+&lt;&lt;&lt;.&gt;&gt;]&gt;]&gt;[&lt;&lt;&lt;&lt;&lt;&lt;]&lt;&lt;&lt;&lt;&lt;&lt;...
</code></pre>
<p><a href="https://tio.run/##bVJNT8MwDL33r2TOL7BygQsSAomr5QNMGUxAW432NO23j5fESduBKzXO8/Pzh/J2ej32h3n/eb2GQIKPKCgzaSDy3rNr5kMzJ2QO806E2LELSKNmABVCJC4Q5BgZDAicxE6JWlShZCmsgA1jqwvRVIOEKbnCmv1iG@RveIE2luNLqNDtXqtbvqJtvpGq8hWRNJ4LgmXAS0cal8ooGK5uD@JpX4gqRLNp2qDYWvOFuFnl5L9f79xMLM/Y4PsmehP1BXEl0hADMifxvbXht221TjTzKCeu@KVpv3TcGq1NuPWlTbnoYrYN85/a6edK45o3v9oO453i@drbOZ955wNdLto9DTSM3UO/P8Xv2E/dfazeYzxM3cvx/WPqnsfYd3dfw08Ec5wBzBOOXw" rel="noreferrer" title="brainfuck – Try It Online">Try it online!</a></p>
<p>This could probably be golfed more, as this is, like, the second brainfuck program I've written.</p>
<h2>Explanation</h2>
<p>I should really write a program to do this for me...</p>
<p><a href="https://pastebin.com/raw/3qAzHtbm" rel="noreferrer">Fullscreen Explanation</a></p>
<pre><code>#####
# Execution will be divided into two phases: input and output.
# The input phase will input all characters and lay them out into memory with metadata.
# The output phase will then loop over the memory and print various segments of it, forming the explanation.

###############
# Input Phase #
###############

#####
# First, let's take a look at the memory layout.
# We'll divide the memory into 6-byte chunks.
# The chunks will be laid out in this format:
#   - first header chunk, to denote the start
#   - second header chunk, to denote the start
#   - first source chunk
#   - second source chunk
#   - ...
#   - last source chunk
#   - primary separator chunk (in place of newline)
#   - first chunk of first explanation
#   - second chunk of first explanation
#   - ...
#   - last chunk of first explanation
#   - separator chunk (in place of newline)
#   - first chunk of second explanation
#   - ......
#   - last chunk of last explanation
#   - eof chunk
# The first header chunk will have the following bytes:
#   0 10 96 0 0 0
# (10 is newline, and 96 is backtick)
# The second header chunk will consist entirely of zeroes.

                     #####
                     # Initialize the header chunks and output the initial code fence:
&gt;&gt;                     # Move to cell #2 (0-indexed).
-[-[---&gt;]&lt;&lt;-]&gt;--       # Set cell #2 to backtick (96) (pulled from https://esolangs.org/wiki/Brainfuck_constants).
...                    # Print it thrice (fine, there is a tiny bit of output in this phase).
&lt;++++++++++.           # Set cell #1 to newline (10) and print it.
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+          # Move to cell #5 of the second header chunk and temporarily set it to 1.

                     #####
                     # Next, read the input into chunks and initialize them.
                     # Every non-header non-eof chunk will be initialized to the following format:
                     #   #0: [char]  (0 if separator)
                     #   #1: [kind]  (which operator the char is)
                     #   #2: [mark]  (currently 1; this will occasionally be temporarily set to 0 as a &quot;bookmark&quot;)
                     #   #3: 32      (the code for space, used for output)
                     #   #4: [noop]  (1 if no-op source chunk or non-primary separator, 0 otherwise)
                     #   #5: [done]  (currently 0, undone)
                     # During the initialization, some cells are used for temporary values.
[                    # While the current cell (#5 of the preceding chunk) is non-zero (and thus known to be 1), loop over the input:
  -                    # Subtract 1 from the cell, [done], returning it to 0 (undone)
  &gt;                    # Move to the active chunk.
                       # Cell #5 will be used for positioning the pointer after a branch ('alignment'):
  &gt;&gt;&gt;&gt;&gt;+               # Set cell #5 to 1
                       #####
                       # Next, we'll read a character.
  &lt;&lt;,                  # Move to cell #3 and input a character into it (temp).
  [                    # If this character is non-zero (not eof):
    [-&lt;+&lt;+&gt;&gt;]            # Duplicate this character into cells #1 and #2 [temp], erasing this cell, #3.
    &lt;----------          # Move to cell #2 and subtract 10 (code for newline) from it.
                         # The chunk is now:
                         #   #0: 0
                         #   #1: char (temp)
                         # &gt; #2: char - 10 (temp)
                         #   #3: 0
                         #   #4: 0
                         #   #5: 1 (alignment)
                         #####
                         # Next, if char is newline (10), we'll set cell #1 to 0.
    [[-]-&gt;]              # If cell #2 (char - 10) is non-zero (the char is not a newline), set this cell to 255 and move to cell #3.
    -[+&gt;-]               # Move to the first cell to the right set to 1 (cell #5), and set it to 0.
                         # (The above is done without any net change to other cells.) 
    &lt;&lt;&lt;+                 # Move to cell #2 and add one to it; this cell is now 1 if char is a newline, or 0 otherwise.
    [-&lt;[-]&gt;]             # If cell #2 is 1, set it back to 0, move to cell #1, clear it, and move back to cell #2.
                         # From now on, char will be 0 if the character was a newline.
                         # The chunk is now:
                         #   #0: 0
                         #   #1: char (temp)
                         # &gt; #2: 0
                         #   #3: 0
                         #   #4: 0
                         #   #5: 0
                         #####
                         # Next we'll inialize cell #0 [char] and put a copy of char into cell #2.
    &lt;                    # Move to cell #1.
    [-&lt;+&gt;&gt;+&lt;]            # Duplicate this value to cells #0 and #2, clearing this cell.
                         # The chunk is now:
                         #   #0: [char]
                         # &gt; #1: 0
                         #   #2: char (temp)
                         #   #3: 0
                         #   #4: 0
                         #   #5: 0
                         #####
                         # Next, we'll initialize cell #1 [kind] to a number denoting the 'kind' of the char is.
                         # The kind is an index from 0 to 8 matching the order &quot;N+-&lt;&gt;[],.&quot; (where N stands for any no-op).
                         # The kind could be determined by directly checking if the character matches an operation (char == op).
                         # In BF, however, it's easier to check if something is not equal to X than if it is equal to X.
                         # We'll start cell #1 [kind] at the sum of the kind, 36 (1+2+3+4+5+6+7+8).
                         # For each operation, we'll check if the character does not match that operation, (char != op).
                         # To do so, we will use cell #2 for checking whether (char - op) is non-zero.
                         # If the character does not match that operation, we will subtract its kind from the sum.
                         # After doing so for all of the operations, the result will be the kind of the operation that the character matches.
                         # We'll do this not in kind order, but in op order: &quot;+&quot; (43), then &quot;,&quot; (44), then &quot;-&quot; (45), etc.
                         #####
&gt;&gt;++++++[-&lt;&lt;++++++&gt;&gt;]    # Set cell #1 to 36 and move to cell #3.
&gt;+                       # Set cell #4 to 1 to be used for alignment.
                         # The chunk is now:
                         #   #0: [char]
                         #   #1: 36 (sum of all kinds)
                         #   #2: char (char - 0)
                         #   #3: 0
                         # &gt; #4: 1 (alignment)
                         #   #5: 0
                         #####
                         # The next set of lines are based on using the following pattern for each of the operations:
                           # Subtract from cell #2 the difference between the char codes for this operation and the previous.
                           # If cell #2 is not zero (if char != op):
                             # Remove this kind from the sum by subtracting from cell #1 (kind_sum) the kind of this operation.
                           # Return to cell #2 (using cell #4 for alignment).
                           # The resulting chunk will be:
                           #   #0: [char]
                           #   #1: kind_sum
                           # &gt; #2: char (char - op)
                           #   #3: 0
                           #   #4: 1 (alignment)
                           #   #5: 0
                         # For '+', check 43:
    &lt;++++++[-&lt;-------&gt;]&lt;-  # Subtract 43 (6 * 7 + 1) from cell #2, the difference between '+' and 0.
                           # The value in cell #2 is now char - 43.
    [                      # If the cell #2 is non-zero (char != 43; the character is not '+'):
      &lt;-&gt;&gt;                   # Subtract from cell #1 the kind of '+', 1.
    ]                      # End if.
    &gt;[&lt;]&lt;                  # Return to cell #2 (using cell #4 for alignment).
                         # (For the remaining operations, the pattern will be shown in a condensed form.)
                         # For ',', check 44: 
    -                      # Subtract 1 (the difference between ',' and '+').
    [&lt;-------&gt;&gt;]&gt;[&lt;]&lt;      # If not zero, remove 7 from kind_sum. Return to cell #2.
                         # For '-', check 45:
    -                      # Subtract 1.
    [&lt;--&gt;&gt;]&gt;[&lt;]&lt;           # If not zero, remove 2 from kind_sum. Return to cell #2.
                         # For '.', check 46: 
    -                      # Subtract 1.
    [&lt;--------&gt;&gt;]&gt;[&lt;]&lt;     # If not zero, remove 8 from kind_sum. Return to cell #2.
                         # For '&lt;', check 60:
    --------------         # Subtract 14.
    [&lt;---&gt;&gt;]&gt;[&lt;]&lt;          # If not zero, remove 3 from kind_sum. Return to cell #2.
                         # For '&gt;', check 62:
    --                     # Subtract 2.
    [&lt;----&gt;&gt;]&gt;[&lt;]&lt;         # If not zero, remove 4 from kind_sum. Return to cell #2.
                         # For '[', check 91
    &gt;+++++[-&lt;------&gt;]&lt;+    # Subtract 29 (5 * 6 - 1).
    [&lt;-----&gt;&gt;]&gt;[&lt;]&lt;        # If not zero, remove 5 from kind_sum. Return to cell #2.
                         # For ']', check 93
    --                     # Subtract 2.
    [&lt;------&gt;&gt;]&gt;[&lt;]&lt;       # If not zero, remove 6 from kind_sum. Return to cell #2.
                         #
    [-]                  # Set cell #2 to zero.
                         # The chunk is now:
                         #   #0: [char]
                         #   #1: [kind]
                         # &gt; #2: 0
                         #   #3: 0
                         #   #4: 1 (temp)
                         #   #5: 0
                         #####
                         # Next, cell #4 [noop] will be initialized to 0 if char is not a no-op.
    &lt;&lt;+                  # Move to cell #0, adding 1 (temporarily, for alignment)
    &gt;                    # Move to cell #1.
    [&gt;&gt;&gt;-]               # If cell #1 [kind] is non-zero (the char is not a no-op),
                         #  move to cell #4 [noop] and subtract 1 to set it to 0.
    &lt;[&gt;&gt;&gt;]               # Move to cell #3, using cell #0 for realignment.
    &lt;&lt;&lt;-                 # Move to cell #0 and subtract 1 from it, returning it to char.
                         # The chunk is now:
                         # &gt; #0: [char]
                         #   #1: [kind]
                         #   #2: 0
                         #   #3: 0
                         #   #4: [noop] (1 if no-op, 0 otherwise)
                         #   #5: 0
                         #####
                         # Next, cell #2 [mark] will be initialized to 1 (unmarked) and cell #3 [space] will be initialized to 32 (code for space).
    &gt;&gt;++++[-&gt;++++++++&lt;]  # Move to cell #2 and set cell #3 to 32 (4 * 8)
    +                    # Set #2 [mark] to 1 (unmarked)
    &gt;&gt;&gt;+                 # Move to cell #5 and set it to 1 (temporarily, so the input loop continues; this will be unset in the next iteration).
    &gt;                    # Move to cell #0 of the next chunk.
  ]                    # End &quot;if non-eof&quot;.
  &lt;                  # If at cell #0 of the next chunk (from the preceding branch for processing a source chunk), move to cell #5 of the current chunk;
                     #   otherwise (at cell #3 after the source chunks), move to cell #2.
]                    # End input loop.
                     # Every non-header non-eof chunk is now:
                     #   #0: [char]  (0 if separator)
                     #   #1: [kind]  (which operator the char is)
                     #   #2: [mark]  (currently 1; this will occasionally be temporarily set to 0 as a &quot;bookmark&quot;)
                     #   #3: 32      (the code for space, used for output)
                     #   #4: [noop]  (1 if no-op source chunk or non-primary separator, 0 otherwise)
                     #   #5: [done]  (currently 0, undone)
                     # Since the loop ended, it reached eof, and the head is at cell #2 of the eof chunk.

################
# Output Phase #
################

                     #####
                     # First, we will return to the header chunks.
+                    # Set cell #2 to 1 (used later to save a byte).
[&lt;&lt;&lt;&lt;&lt;&lt;]             # Move left one chunk at a time until cell #2 is zero, reaching the second header chunk.
&gt;&gt;&gt;&gt;                 # Move to cell #0 of the first source chunk.
[.&gt;&gt;&gt;&gt;&gt;&gt;]            # While cell #0 is non-zero, print it and move to the next chunk 
                     #  (this writes the first line of the explanation, the code verbatim).
                     # Now, the head is at cell #0 of the primary separator chunk.
&gt;&gt;&gt;&gt;-&lt;&lt;&lt;&lt;            # Set its cell #4 to 0 (used later to break a loop).
&lt;&lt;&lt;&lt;&lt;&lt;[&lt;&lt;&lt;&lt;&lt;&lt;]       # Move to the next 0-char chunk to the left (this is the second header chunk).
&lt;&lt;&lt;&lt;&lt;.               # Move to cell #1 of the first header chunk (newline) and output it (ending the first line).

                     #####
                     # As we go through each line of the explanation, we'll follow this psuedo-code:
                     #   - Output a space for every source character marked as 'done'
                     #   - Output the characters for the active operations (multiple if it's a chain of no-ops, only one otherwise)
                     #   - Mark all active operations 'done'
                     #   - Output a space for every source character after the active ones
                     #   - Output a space followed by the associated explanation
                     # These steps will be expanded on later.

&gt;&gt;&gt;                  # Move to cell #4 of the first header chunk.
+                    # Set it to one to start the loop.
[                    # Begin a loop to print subsequent lines:
                       #####
                       # First, we will find the first not done chunk.
  -                    # Set this cell, #4 of the first header chunk, back to 0.
  &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;        # Move to cell #5 [done] of the first source chunk.
  [&gt;&gt;&gt;&gt;&gt;&gt;]             # Go to the first not done cell to the right (it might be the current chunk).
  &lt;&lt;&lt;&lt;&lt;                # Go to cell #0 [char].
  [                    # If it's non-zero (if it's a source chunk):
                         #####
                         # Next, we will output the leading spaces and the first active character.
    &lt;[&lt;&lt;.&lt;&lt;&lt;&lt;]           # Go to cell #5 of the first not done chunk to the left
                         #  (this is the second header chunk), outputting spaces along the way.
    &gt;&gt;&gt;&gt;&gt;&gt;               # Go to cell #5 [done] of the next chunk.
    [&gt;&gt;&gt;&gt;&gt;&gt;]             # Move to cell #5 of the first non-done cell to the right.
    &lt;&lt;&lt;&lt;&lt;.               # Move to cell #0 [char] of this chunk (the first active source chunk) and output it.
    &gt;&gt;&gt;&gt;                 # Move to cell #4 [noop] of this chunk.
  
                         #####
                         # Next, the following branch will process a sequence of no-op chunks. 
                         # This is handled differently from non-no-op chunks because sequential no-op characters are printed in one line.
    [                    # If it's non-zero (if this character is a no-op):
      &gt;+                   # Set cell #5 [done].
                           #####
                           # First, we will output each subsequent active character and mark their chunks as done.
      &gt;&gt;&gt;&gt;&gt;                # Move to cell #4 [noop] of the next chunk.
      [                    # While the current chunk is a no-op:
        &lt;&lt;&lt;&lt;.                # Move to cell #0 [char] and output it.
        &gt;&gt;&gt;&gt;&gt;+               # Move to cell #5 [done] and set it to 1.
        &gt;&gt;&gt;&gt;&gt;                # Move to cell #4 [noop] of the next chunk.
                             # (Note that the primary separator has cell #4 [noop] set to 0 in order to break this loop)
      ]                    # End loop. Now the head is at the cell #4 [noop] of the first non-no-op chunk.
                           #####
                           # Next, we will output the trailing spaces and the no-op explanation.
      &lt;&lt;&lt;&lt;[&gt;&gt;&gt;.&gt;&gt;&gt;]        # Move to the primary separator chunk, outputting a space for each skipped chunk.
      &gt;&gt;&gt;.&gt;&gt;&gt;              # Move to cell #0 of the first chunk of the first explanation, outputting a space.
      [.&gt;&gt;&gt;&gt;&gt;&gt;]            # Move to the next non-explanation chunk, outputting each character.
      &gt;&gt;                   # Move to cell #2 [mark].
      [&lt;&lt;&lt;&lt;&lt;&lt;]             # Move to cell #2 of the second header chunk.
      &lt;                    # Move to cell #1.
    ]                    # End if.
    &lt;&lt;&lt;                  # If at cell #1 of the second header chunk (from the preceding branch for processing a no-op), move to cell #4 of the first header chunk;
                         #  otherwise, (still at the cell $4 [noop] of the current source chunk), move to cell #1 [kind].

                         #####
                         # Next, the following branch will process a non-no-op chunk.
                         # This is handled separately from no-op chunks because operators are printed on separate lines.
    [                    # If cell #1 [kind] is non-zero (if in a non-no-op source chunk):
                           #####
                           # First, we will output the trailing spaces and find the primary separator chunk.
      &gt;-                   # Move to cell #2 [mark] and set it to 0 (this marks the cell to return to later).
      &gt;&gt;&gt;+                 # Move to cell #5 [done] and set it to 1.
      &gt;[&gt;&gt;&gt;.&gt;&gt;&gt;]           # Move to the primary separator chunk, outputting a space for each skipped chunk.
      &gt;&gt;-                  # Mark this chunk (the primary separator chunk).
      &lt;&lt;&lt;&lt;&lt;.&lt;              # Move to cell #2 [mark] of the previous chunk, outputting a space.
      [&lt;&lt;&lt;&lt;&lt;&lt;]             # Move to the first marked (mark == 0) cell to the left (the active source chunk).
      &lt;                    # Move to cell #1 [kind].
                           #####
                           # Next, we'll locate the correct explanation.
                           # We're at cell #2 [kind], which acts as an index to the explanation.
                           # The primary separator (which precedes the 0th (no-op) explanation) is marked.
      [-                   # Continually decrement the kind:
                             # Each iteration will unmark the currently marked separator and mark the next separator.
        &gt;&gt;&gt;&gt;&gt;&gt;&gt;[&gt;&gt;&gt;&gt;&gt;&gt;]      # Move to the first marked cell to the right.
        +                    # Unmark this chunk.
        &gt;&gt;&gt;&gt;                 # Move to cell #0 of the next chunk.
        [&gt;&gt;&gt;&gt;&gt;&gt;]             # Move through the explanation chunks to the next separator chunk.
        &gt;&gt;-                  # Mark this separator chunk.
        &lt;&lt;&lt;&lt;&lt;&lt;[&lt;&lt;&lt;&lt;&lt;&lt;]&lt;      # Return cell #1 [kind] of the active source chunk (as it's marked).
      ]                    # End loop.
                           #####
                           # Next, we will output the explanation we have located.
      &gt;+                   # Unmark the current source chunk.
      [&gt;&gt;&gt;&gt;&gt;&gt;]             # Move to the marked separator chunk.
      +                    # Unmark this chunk.
      &gt;&gt;&gt;&gt;                 # Move to cell #0 [char] of the next chunk.
      [.&gt;&gt;&gt;&gt;&gt;&gt;]            # While cell #0 [char] is non-zero, output it and move to the next chunk.
      &gt;&gt;[&lt;&lt;&lt;&lt;&lt;&lt;]           # Return to the second header chunk.
      &lt;&lt;&lt;&lt;                 # Move to cell #4 of the first header chunk.
    ]                    # End if.

                         # From either branch, we are now at cell #4 of the first header chunk.
    +                    # Set cell #4 to 1 (to continue the loop).
    &lt;&lt;&lt;.                 # Move to cell #1 (newline) and output it.
    &gt;&gt;                   # Move to cell #3 (which is 0).
  ]                    # End if.
  &gt;                    # If at the first header chunk (from the preceding branch for processing a source chunk), move to cell #4 (which is 1, continuing the loop);
                       #  otherwise (still at the primary separator), move to cell #1 (which is 0, ending the loop).
]                    # End loop.

#####
# Lastly, we will print the final code fence.
&gt;[&lt;&lt;&lt;&lt;&lt;&lt;]            # Move to cell #2 of the second header chunk.
&lt;&lt;&lt;&lt;&lt;&lt;...            # Move to the first header chunk and output the backtick thrice.

#####
# Finally, we can enjoy the fruits of our efforts: https://pastebin.com/raw/C9yYHx3F.
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, <s>143</s> <s>142</s> 138 bytes</h1>

<pre class="lang-ruby prettyprint-override"><code>-&gt;i{c,*e=i.split ?\n;puts&quot; &quot;*(m=4)+c;c.scan(/[^&lt;&gt;+-.,\[\]]+|./){|b|r=&quot; &quot;.*c.size+5;r[m,z=b.size]=b;puts r+e[&quot;&lt;&gt;+-.,[]&quot;.index(b)||8];m+=z}}
</code></pre>
<p><a href="https://tio.run/##7ZOxTsMwEIb3PMWpU1snLlQgITUJC0uRaBlgco3kuNfWIrEjx0W0SZ69hARQByoYGfDku/u/89m/bLfJ7pBGhyBWpfSHGCla5KlycL3Qk3zrih70hv0suhgQOZG0kEL3R@wpjElA/QVbcE4qOhqUVVLZqNHSYSNSeySXE8syfx8lbcijpO0GliDrdTTjPar0El/7yaCqrvgkI9G@rg9KN8pziCAMp7P7xweP8TAu6/6AkCCg1Pe9O/OC4DYIuVHaoQVn2tCq9cadrKa4ct5US4sZatemMsyM3YHENAXhjiHvBn8pnG9dM2@bkhthhXw/slBrrVYKl5DsutI35PT9oiCOMKGXUDhjERoHlD5J3m6zHHJRfAwnnNwovQYOanWKAVXAWQcmQj5/PsoXy35gtdF7tMabGZjnaIVTRnudP61h4yPDYtIuVpahT@Ogrvm/ZX/LMi9l3Tfjn7sxP7wB" rel="nofollow noreferrer" title="Ruby – Try It Online">Try it online!</a></p>
<p>The function expects input to be lines separated by <code>\n</code>. It scans the program using regexp <code>/[^&lt;&gt;+\.,\[\]-]+|./</code>. It outputs to stdout instead of returning. Which is all there is to it.</p>
<p>Thanks to @Fmbalbuena for removing a space!</p>
<p>Saved 4 more bytes by re-reading ruby golfing tips :)</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, 330 bytes</h1>

<pre class="lang-hs prettyprint-override"><code>import Data.List
main=interact$unlines.f.lines
f(c:a)=(s 4++c):(map(p c.(a%)).tail.inits.t)c
t r|r==[]=[]|q x=[x]:t y|0&lt;1=a:t b where(x:y)=r;(a,b)=span(not.q)r
q=(`elem`n)
p c(a,e)=s(4+(l.init)a)++last a++s(1+length c-l a)++e
s=(`replicate`' ')
n=&quot;&gt;&lt;+-.,[]&quot;
e%j=(j,e!!(n#last j))
l=length.concat
(s:z)#c|[s]==c=0|z==[]=1|0&lt;1=1+z#c
</code></pre>
<p><a href="https://tio.run/##jZJRbxoxDMff8yncsqqJDiKQ@sRIn/rSaVs/wOkkQmq40DvnSMwGjH12Fg5t6sPQJkVKYvvnf2yntukNm@Z08m0XIsOTZas/@8SitZ6MJ8ZoHX/YUuMJk17qfhdL6aZWGZngoSicmsrWdrIDp6W9U0qz9Y325DlpVk4wxGM0pqzyOm5gZ8pdNWXYH8ezibH5tIDvNUaUu@lemfhR2uFCmdRZkhRYb1QUGyPn2GA7JyWyTo7AHCEfCnkRUlYVRWMTgy2KJCdFg7TiGtyogbMLRcoZInaNd5Zxfg/3SpC5fZwVIz0sq1uBd2sj10O8uZE06DOtlRKNuSTSLlAGhUzTgxq4Y5kqY5wZHw99XZO@lElxGLjTqaxmjz9@yqw6Gmk9HIov4RsC1whd6DsKHPpr9Kuar3obXLJ4JhexReLe1GIb4h5cHhlYfg@JJ/zPwJctd9uLydX2PN0smfyK/NLjKyz2F9dfyGc6g/YdZukVEoeI4Bk8XSU/bdsOunNP@8dZdrWnFVTgl9cY8AnGF3Bh3dvvpvxhy3@wFOiAMYivAV66/InZB/oF" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
<h4>Explanation:</h4>
<pre class="lang-hs prettyprint-override"><code>import Data.List
main=interact$unlines.f.lines
f(c:a)=(s 4++c):(map(p c.(a%)).tail.inits.t)c
</code></pre>
<p>import Data.List <code>inits</code>(prefixes), this is used to keep track of the number of spaces<br>
call <code>f</code> with lines of input, then output each line<br>
f = <code>&quot; &quot; * 4 + code</code> + <br>
<code>map</code> on each <code>prefix</code> of each command or noop:<br>
select explanation and then pad with spaces<br></p>
<pre class="lang-hs prettyprint-override"><code>t r|r==[]=[]|q x=[x]:t y|0&lt;1=a:t b where(x:y)=r;(a,b)=span(not.q)r
q=(`elem`n)
n=&quot;&gt;&lt;+-.,[]&quot;
</code></pre>
<p><code>t</code> splits the code into commands or noop<br>
<code>q</code> checks if a char is a command<br>
<code>n</code> is the string <code>&quot;&gt;&lt;+-.,[]&quot;</code></p>
<pre class="lang-hs prettyprint-override"><code>p c(a,e)=s(4+(l.init)a)++last a++s(1+length c-l a)++e
s=(`replicate`' ')
e%j=(j,e!!(n#last j))
(s:z)#c|[s]==c=0|z==[]=1|0&lt;1=1+z#c
</code></pre>
<p><code>p</code> pads a (prefix, explanation)-pair with spaces<br>
<code>s</code> returns n spaces<br>
<code>%</code> creates said (prefix, explanation)-pair<br>
<code>#</code> returns the index of the command in <code>n</code> or 8 if it's a noop</p>
</div>
<div id="pu6" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, 118 bytes</h1>

<pre class="lang-ruby prettyprint-override"><code>c,*a=*$&lt;
print&quot; &quot;*l=4,c
c.scan(/[^+-.\[\]&lt;&gt;\n]+|./){puts&quot; &quot;*l+$&amp;+&quot; &quot;*(c.size+4-l+=$&amp;.size)+a[&quot;&gt;&lt;+-.,[]&quot;.index($&amp;)||8]}
</code></pre>
<p><a href="https://tio.run/##jdDNboJAEADgO08xIYSAC9iDhx7UUy82aX0ApMm6jrIpzJJlaIo/z04RW@Ohpr3t/Hw7s2ubddt1KhrJ2cibOpXVxC64o2I2iZSjklpJCsbpm4iTVbrKpvMVZeKYjMND1XA9dArPF@dD0HfrPYpJXIiZ5w9BKGTqzqe9jtLMTTRt8DPw/PB4fMxOXZf2Fx5OQShEHCdJFDkv5gOBc4TK9IugBTZDaPUu57vVArfsLEhZLJF4SJVYGtuCwqIAybfIecJ/Ni4b7h85pFQurVTnkbXekd5q3MC6vZR@kQs6Q3nDJG2gZmMRNIOmu/K5KSuoZP29nGSVa9pBBnp7z4Cu4eEC11K9/3zK1aZ/WDK0R2ucVwPLCq1kbegL" rel="nofollow noreferrer" title="Ruby – Try It Online">Try it online!</a></p>
<h4>Explanation</h4>
<pre class="lang-ruby prettyprint-override"><code>c,*a=*$&lt;                                 # assign 'c' to first line and 'a' to the rest of input
print&quot; &quot;*l=4,c                           # output code and assign 'l' to 4 at the same time
c.scan(/[^+-.\[\]&lt;&gt;\n]+|./)              # for every match:
{puts&quot; &quot;*l+$&amp;+&quot; &quot;*(c.size+4-l+=$&amp;.size)+ # output the padded match, update 'l' to keep track of the spaces
a[&quot;&gt;&lt;+-.,[]&quot;.index($&amp;)||8]}              # output the correct explanation
</code></pre>
<p>inspiration taken from <a href="https://codegolf.stackexchange.com/users/108388/lonelyelk">lonelyelk</a></p>
</div>
<div id="pu7" class="pu"><h1><a href="https://www.perl.org/" rel="nofollow noreferrer">Perl 5</a> + <code>-nF -M5.10.0</code>, 93 bytes</h1>
<p>Thanks to <a href="https://codegolf.stackexchange.com/users/106959/fmbalbuena">@Fmbalbuena</a> for noticing I'd missed printing the unaltered string! Thanks to <a href="https://codegolf.stackexchange.com/users/100664/emanresu-a">@emanresu A</a> and <a href="https://codegolf.stackexchange.com/users/17602/neil">@Neil</a>'s regex wizardry saving 14 (!!) bytes!</p>

<pre class="lang-perl prettyprint-override"><code>@@=&lt;&gt;;say$&quot;x4,$_,map$&quot;x(4+$-).$_.$&quot;x(@F-($-+=y///c)).$@[index'&gt;&lt;+-.,[]',$_],/[^]&lt;&gt;+-.[
]+|./g
</code></pre>
<p><a href="https://tio.run/##K0gtyjH9/9/BwdbGzro4sVJFqcJERyVeJzexAMjUMNFW0dXUU4nXA3Ec3HQ1VHS1bSv19fWTNYHCDtGZeSmpFep2Ntq6ejrRsepAnbE6@tFxsTZ2QJForljtGj399P//IQr8/AOiY7l888tSIYRnXnJRam5qXgmXSyqMFRziAsbhGZk5qVASqI/rX35BSWZ@XvF/3Ty3/7q@pnqGBnoGCgA" rel="nofollow noreferrer" title="Perl 5 – Try It Online">Try it online!</a></p>
<h2>Explanation</h2>
<p>First <code>print</code> <code>4</code> <code>x</code> (string repetition operator) <code>$&quot;</code> (which defaults to space), then store the length of the input (implicitly obtained via <code>-F</code> into <code>@F</code>) in <code>$=</code>, and store the explanations in <code>@@</code>. Then, <code>for</code> each matching piece of code (either one char from <code>-&lt;&gt;+.,[]</code>, or any number of any other chars) concatenate the following with <code>$\</code>: 4 + <code>$-</code> (which starts out as <code>0</code>) <code>x</code> <code>$&quot;</code>, followed by the piece of code (<code>$_</code>), followed by the original length, minus <code>$-</code> (to which we add the current length of this code piece) <code>x</code> <code>$&quot;</code> and finally, using the <code>index</code> function on the string <code>&gt;&lt;+-.,[]</code>, the message associated to the current piece of code (<code>index</code> returns <code>-1</code> for missing index, for which Perl returns the last element of the list). <code>$_</code> is output followed by <code>$\</code> thanks to <code>-p</code> flag.</p>
<hr />
<h1><a href="https://www.perl.org/" rel="nofollow noreferrer">Perl 5</a> + <code>-F/([^]&lt;&gt;+-.[]+|.)/ -M5.10.0</code>, 92 bytes</h1>
<p>The regex used in the above, can be provided via <code>-F</code> to save a byte.</p>

<pre class="lang-perl prettyprint-override"><code>$==y///c;@@=&lt;&gt;;say$&quot;x4,$_,map/./&amp;&amp;$&quot;x(4+$-).$_.$&quot;x($=-($-+=y///c)).$@[index'&gt;&lt;+-.,[]',$_],@F
</code></pre>
<p><a href="https://tio.run/##NYxLC4JAAITv/oxYfLAvAz35YA8idLCCgg7LJmILCb5QCYV@e9uWdZhhZuCbXg61rxSIooVSWgaMRWEcjMUCNrOHQI6aoqeEmqbutgcBdgjIyaeACNsAw5Vz9Mx41d7kbMUhxARxYWlcIJYqtS77w5ELI@secrVdWw6yke1kJPKfTufkq8u9quXPNWe8un6qunZUOKU2v4ow1o9cwCdxqMKZT7Yucd8" rel="nofollow noreferrer" title="Perl 5 – Try It Online">Try it online!</a></p>
</div>
<div id="pu8" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, <s>54</s> <s>48</s> 47 bytes</h1>
<pre><code>× ⁴ＰＳＦθ«⊞υ⌕&gt;&lt;+-.,[]ι¿⁺²Σ✂υ±²↓Ｐ⊟υι»↑⸿↓≔Ｅ⁹ＳηＥυ§ηι
</code></pre>
<p><a href="https://tio.run/##VY9Ba8MwDIXPza8QOSnM3aHssnYMCmGQQ7pAOnboegipmhgc24vtbjD22z072aAzWDzQ06entm/GVjXC@2rk0uKeD2QwhZTBXZZtktIJy/XUKqR2trZBdxhbZzUCvmfwlSwqZ3p0DJ64PGH6@HCzvGWHY2DwaFzwM2AlnMEVg9oNWAveUvTvqGss4SoLD0p1IVzn6kPGGRKG4Gp7pTS6iTYH5UF@J7Nev2gG6duYxsDXlK0xvJNYNhrvGfw/gEEfHDMgGkKcrS3kiT6xn4JnG@/nU3bP1eE4kedSyHakgaRNcvpT9T6f/mvPBf3WMOeXF/ED" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Explanation:</p>
<pre><code>× ⁴
</code></pre>
<p>Indent by 4 spaces.</p>
<pre><code>ＰＳ
</code></pre>
<p>Print the code without moving the cursor.</p>
<pre><code>Ｆθ«
</code></pre>
<p>Loop over the characters in the code.</p>
<pre><code>⊞υ⌕&gt;&lt;+-.,[]ι
</code></pre>
<p>Push the index of the appropriate explanation to the predefined empty list. NOPs will have an index of <code>-1</code>, which will cyclically index to the last explanation, but is also useful for coalescing consecutive NOPs below.</p>
<pre><code>¿⁺²Σ✂υ±²
</code></pre>
<p>If there are not two consecutive NOPs, then...</p>
<pre><code>↓
</code></pre>
<p>... move down a line, else...</p>
<pre><code>Ｐ⊟υ
</code></pre>
<p>... discard one of the NOPs.</p>
<pre><code>ι
</code></pre>
<p>Output the current character.</p>
<pre><code>»↑⸿
</code></pre>
<p>Move to the start of the next column.</p>
<pre><code>↓
</code></pre>
<p>Move to the first row of explanations.</p>
<pre><code>≔Ｅ⁹Ｓη
</code></pre>
<p>Read in the explanations.</p>
<pre><code>Ｅυ§ηι
</code></pre>
<p>Print each appropriate explanation.</p>
<p>Today I discovered a bug in Charcoal's <code>Split</code> command which unintentionally results in partial regex support: <code>Split(&lt;string&gt;, &lt;list&gt;)</code> is supposed to split the string at any occurrence of any word in <code>&lt;list&gt;</code>, but due to the bug what actually happens is that <code>Split(&lt;pattern&gt;, [&lt;string&gt;])</code> escapes the string and splits it on the pattern. Unfortunately the original approach has since been golfed down from its original 54 bytes which this approach ties with, but that's still good going considering the duplication of the command characters:</p>
<pre><code>× ⁴≔Φ⪪“ xMＴ¦Ｔ~≧_x”⟦Ｓ⟧ιθＰ⪫θωＦθ⁺¶ι↑⸿↓≔Ｅ⁹ＳηＥθ§η⌕&gt;&lt;+-.,[]ι
</code></pre>
<p><a href="https://tio.run/##VY5Na8MwDEDv/RXGJ5k6O/WyrhQKoZBBu0A6dkhyCKnXGFzbcZx2h/13T4n3wQwSQpbeU9s1rjWNCiF3Uns4yasYgBLKyYqxp8VuGORFw14qLxwUVkkPtML3CWW92S4TXtYMh8tM29EXHiEXYDXjRGL0SDiMyks7w5@N1NBzcp/I78YR6BmJ3lyNqK00nRbxN3bXr5YTWjk6ccxNwDo1d/131qGx8MjJPzdqu1/ANIDCnc/0WXxAx8le6jPQ7WaZPODpUYfCEGLr@JKX9eyKKdOtE1eh/SIVP1VxSud466QS3xn3QnJTXw" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Note: Backslashes are not supported because this is relying on buggy Charcoal behaviour. Explanation:</p>
<pre><code>× ⁴
</code></pre>
<p>Indent by 4 spaces.</p>
<pre><code>≔Φ⪪“ xMＴ¦Ｔ~≧_x”⟦Ｓ⟧ιθ
</code></pre>
<p>Extract command characters or runs of non-command non-backslash characters from the input.</p>
<pre><code>Ｐ⪫θω
</code></pre>
<p>Print the code without moving the cursor.</p>
<pre><code>Ｆθ⁺¶ι
</code></pre>
<p>Output each command on its own line, but increasing the indent as it goes.</p>
<pre><code>↑⸿
</code></pre>
<p>Move to the start of the next column.</p>
<pre><code>↓
</code></pre>
<p>Move to the first row of explanations.</p>
<pre><code>≔Ｅ⁹Ｓη
</code></pre>
<p>Read in the explanations.</p>
<pre><code>Ｅθ§η⌕&gt;&lt;+-.,[]ι
</code></pre>
<p>Find and output the appropriate explanation for each command, or the last explanation for non-commands.</p>
</div>
<div id="pu9" class="pu"><h1><a href="http://clang.llvm.org/" rel="nofollow noreferrer">C (clang)</a>, <s>191</s> 188 bytes</h1>
<p><em>-3 thanks to @<a href="https://codegolf.stackexchange.com/users/52904/ceilingcat">ceilingcat</a></em></p>

<pre class="lang-c prettyprint-override"><code>*S=&quot;&gt;&lt;+-.,[]&quot;;i;l;d;f(char*a,**e){for(i=5,l=printf(&quot;    %s \n&quot;,a);*a;printf(&quot;%*s%s\n&quot;,l-i,&quot;&quot;,e[d?d-(int)S:8]))for(d=index(S,*a),printf(&quot;%*c&quot;,i++,*a);!d&amp;!index(S,*++a);)i+=write(1,a,*a&gt;0);}
</code></pre>
<p><a href="https://tio.run/##lZJBb9QwEIXv/RVTS4vixFl1D0gIN8uFS5Gghz2GHFx7kh2R2JHjpS2r/euEeLctqSoo@OZ57316tkbnulW2Gcd0U7D1ZZYvRVkxSbKVRtaJ3iqfKpGmyPe18wkVb0Vb9J5sqBMG01kM8NUyobhMlXwUFumwGOK4zUkwJrA0H0yeTCLfvH9XcR5ZpiBr8C7ZiFRx8TuqmaAsi0N5bt6cP5mybJpwyopbTwGTlZh6qfUFl4exU2QTvj@LhY6VQTuDKyiAldXlen9IeJbl@XIpBJMzF971q7KabKdoPOyz@44Qtgi9mxqhh@COV0/NNjDxurHF@pnvymqPHdpwVDvsnL8HjW0LKszz88xH/P/M9S70u5MaX6d07DRQY6kmNHBzf5L@DrmykaFmBGUNDMF5BApA9l8gn3ZdD70aHtqroLdkG6iA6j/FgQa4eMG4Ufrb47c@YcpXMNbZH@jdHPbFwXWPXgVy9mF@OO3BtOJxU8RxFbg8O4w/dd2qZhjz218" rel="nofollow noreferrer" title="C (clang) – Try It Online">Try it online!</a>
Assumes explanations are in the order <code>&gt; &lt; + - . , [ ] NOP</code>.</p>
</div>
<div id="pu10" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 46 bytes</h1>
<pre><code>®Ṭ€z0aḷżṚ⁸ṭṚŻ€4¡o⁶ð“&gt;&lt;+-.,[]”iⱮxṠoŒQÄ©ŒQƲ$$ịŻ€
</code></pre>
<p><a href="https://tio.run/##jdAxTwIxFAfw/T7FGxg0wIXBkTC5YKLE0RCGUh5clWsvvZ4RjAkYNzdHo4m6GBMgaoxyOSfI@T3aL3IeoIZBolNf37@/tH372G53kmQy0uHAnA66BaLHb/G7Di9Nf6zDYVrEURpsTG6F6b9OH03vqlTM5u1ctWZ618w8jY50eCPii93p2eQhXT6eMxkdnc9VoqMXPb6b3mf2kqRaK5aOT9bWs9l83rZzOWtbHCIoB8ETjCuUoMR8K1nLUSvTNjaVVeZUootczVsuukJ2gKZ/AaKWkbWJ/zxYCZQXLFrUIZLQ2ZU@a3HWZNiAemcR/SLLfAbJEiO8Ab4SEoEpYHyl3ApcDzzifz2OKOow3oIasOYqA8yHwgLWCT34HsqPrf5hueBdlMLaEVDxUBLFBP8E" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p>Program on the left and list of descriptions on the right. I suspect this can lose a few bytes fairly easily, but I'm posting it now in order to preserve one of the most hideous things I have ever written for posterity.</p>
</div>
<div id="pu11" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, <s>53</s> <s>52</s> 50 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>.γ&quot;&gt;&lt;+-.,[]&quot;©såN&gt;*}DU¹g&gt;j|VεXN&gt;£JvÁ}Y®XNèkè«}¹š4ú»
</code></pre>
<p>-2 bytes thanks to <em>@ovs</em>.</p>
<p>Outputs the lines with four leading spaces.</p>
<p><a href="https://tio.run/##jdC/S8NAFAfwPX/Fo5OaHzg4lkxdWjCdlErIcLm@JmeTu3B3KVTN4J8iIlQEF3Gobhdc@y9F2qh0MOj43vd9eI8nFIkZNo23een5fdv1nDDqmUdVPwT@UTU4M@vEv7w537xOAt/cjxb1bXVhnidBvZrXK/NUmfXH3Un9Zt6bJoz6/nV1cGjbrut5jmOdigWCThEKwbhGCVrsSsmSVHemGc60NeRUYo5c71o55kIugWKWAdH7yBrgPwfHpS7KtkVTIgndrlQs4WzGcArxso1@kUO@hWSPET4FpYVEYBoY75SjMi@gIOrrOKJpyngCEbBZlwGm4LiFMaHz76f82PAPywW/QimsQMC4QEk0E/wT" rel="nofollow noreferrer">Try it online.</a></p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>.γ                 # Group the first (implicit) input-string into parts:
  &quot;&gt;&lt;+-.,[]&quot;       #  Push the string &quot;&gt;&lt;+-.,[]&quot;
            ©      #  Store it in variable `®` (without popping)
             s     #  Swap to get the current character
              å    #  Check if it's in the string
               N&gt;* #  Multiply it by the 1-based index
                   #  (this ensures all characters in that string become unique
                   #  values, but all unknown characters map to the same value 0)
}DU                # After the group-by, store a copy in variable `X`
   ¹g              # Push the length of the first input-string
     &gt;             # Increase it by 1
      j            # Make all strings of that length by padding leading spaces
|                  # Push a list of all remaining input-lines
 V                 # Pop and store it in variable `Y`
      ε            # Map over the parts:
       X           #  Push the parts from variable `X`
        N&gt;£        #  Leave the first map-index + 1 amount of parts
           J       #  Join them together
            v }    #  Pop and loop its length amount of times:
             Á     #   Rotate the string once towards the right
         XNè       #  Get the map-index'th part from variable `X`
        ®   k      #  Get the index of that part from variable `®`
       Y     è     #  Use that to index into the list of lines `Y`
              «    #  Append the two strings together
      }¹š          # After the map: prepend the first input-string
         4ú        # Pad each string with 4 leading spaces
           »       # Join the list by newlines
                   # (after which the result is output implicitly)
</code></pre>
</div>
<div id="pu12" class="pu"><h1><a href="https://github.com/tomtheisen/stax" rel="nofollow noreferrer">Stax</a>, 45 <a href="https://github.com/tomtheisen/stax/blob/master/docs/packed.md#packed-stax" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>å☺m█Q╗½§ÄN!╢┼♫mù}Jt→v)╢+Θ☼î╔↓bÉü╡⌐CÇ-♠•¿♪FM¥2
</code></pre>
<p><a href="https://staxlang.xyz/#p=86016ddb51bbab158e4e21b6c50e6d977d4a741a7629b62be90f8cc919629081b5a943802d0607a80d464d9d32&amp;i=LBc4NtPY%7B%22%3E%3C%2B-.,%5B%5D%22XI%5Ei*%7D%2FzsFs%25Ntcaay%25%5E%28x_Iasn%40as%2B4NtPs%0AMove+the+pointer+to+the+right%0AMove+the+pointer+to+the+left%0AIncrement+the+memory+cell+at+the+pointer%0ADecrement+the+memory+cell+at+the+pointer%0AOutput+the+character+signified+by+the+cell+at+the+pointer%0AInput+a+character+and+store+it+in+the+cell+at+the+pointer%0AJump+past+the+matching+%5D+if+the+cell+at+the+pointer+is+0%0AJump+back+to+the+matching+%5B+if+the+cell+at+the+pointer+is+nonzero%0ANo+Operation" rel="nofollow noreferrer">Run and debug it</a></p>
<p>Made this after Fmbalbuena's challenge in TNB. Will try to post something in Pip as well.</p>
<p>Found a nice save after Neil pointed out a mistake.</p>
<h2>Explanation</h2>
<pre><code>LBc4NtPY{&quot;&gt;&lt;+-.,[]&quot;XI^i*}/zsFs%Ntcaay%^(x_Iasn@as+4NtPs
LBc4NtPY{&quot;                                              No Operation
          &gt;                                             Move the pointer to the right
           &lt;                                            Move the pointer to the left
            +                                           Increment the memory cell at the pointer
             -                                          Decrement the memory cell at the pointer
              .                                         Output the character signified by the cell at the pointer
               ,                                        Input a character and store it in the cell at the pointer
                [                                       Jump past the matching ] if the cell at the pointer is 0
                 ]                                      Jump back to the matching [ if the cell at the pointer is nonzero
                  &quot;XI^i*}/zsFs%Ntcaay%^(x_Iasn@as       No Operation
                                                 +      Increment the memory cell at the pointer
                                                  4NtPs No Operation
</code></pre>
</div>
<div id="pu13" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a> <code>oj</code>, 69 bytes</h1>
<pre><code>:4$꘍,`([%^])`\\`&gt;&lt;+-,.[]`f:→+∑%ṡ';:vL¦0pṪZƛ÷$꘍nh←=Tuw∨□ḣ∇‟İ„L›„↲p4$꘍∑
</code></pre>
<p><a href="https://lyxal.pythonanywhere.com?flags=oj&amp;code=%3A4%24%EA%98%8D%2C%60%28%5B%25%5E%5D%29%60%5C%5C%60%3E%3C%2B-%2C.%5B%5D%60f%3A%E2%86%92%2B%E2%88%91%25%E1%B9%A1%27%3B%3AvL%C2%A60p%E1%B9%AAZ%C6%9B%C3%B7%24%EA%98%8Dnh%E2%86%90%3DTuw%E2%88%A8%E2%96%A1%E1%B8%A3%E2%88%87%E2%80%9F%C4%B0%E2%80%9EL%E2%80%BA%E2%80%9E%E2%86%B2p4%24%EA%98%8D%E2%88%91&amp;inputs=%3E%2B%2B%2B%2B%2B%2B%5B%7B%7B%3C%2C.%3E-%7D%7D%5D%0AMove%20the%20pointer%20to%20the%20right%0AMove%20the%20pointer%20to%20the%20left%0AIncrement%20the%20memory%20cell%20at%20the%20pointer%0ADecrement%20the%20memory%20cell%20at%20the%20pointer%0AOutput%20the%20character%20signified%20by%20the%20cell%20at%20the%20pointer%0AInput%20a%20character%20and%20store%20it%20in%20the%20cell%20at%20the%20pointer%0AJump%20past%20the%20matching%20%5D%20if%20the%20cell%20at%20the%20pointer%20is%200%0AJump%20back%20to%20the%20matching%20%5B%20if%20the%20cell%20at%20the%20pointer%20is%20nonzero%0ANo%20Operation&amp;header=&amp;footer=" rel="nofollow noreferrer">Try it Online!</a></p>
<h2>Explained</h2>
<pre class="lang-js prettyprint-override"><code>`([%^])`
</code></pre>
<p>Push the string <code>&quot;([%^])&quot;</code> to the stack. This will serve as the basis for a
regular expression that groups on non-BF commands</p>
<pre class="lang-js prettyprint-override"><code>\\
</code></pre>
<p>Push a backslash to the stack. This will serve to escape all the characters in
the BF character set (<code>[</code> and <code>]</code> need to be escaped, because they interfere with the range set)</p>
<pre class="lang-js prettyprint-override"><code>`&gt;&lt;+-,.[]`f
</code></pre>
<p>Push the string <code>&quot;&gt;&lt;+-,.[]&quot;</code> to the stack, and turn it into a list of characters.
It's important it's turned into a list of characters because the backslash will
be prepended to each character using vectorised addition.</p>
<pre class="lang-js prettyprint-override"><code>:→
</code></pre>
<p>But first, put the character set into the ghost variable for later storage -
there's no BF character set element in vyxal, so to save bytes, it needs to be
stored.</p>
<pre class="lang-js prettyprint-override"><code>+∑
</code></pre>
<p>Prepend the backslash to each character just like I said I would, and convert it
back to a single string.</p>
<pre class="lang-js prettyprint-override"><code>%
</code></pre>
<p>And place that into the regex pattern string from earlier using string formatting</p>
<pre class="lang-js prettyprint-override"><code>ṡ';
</code></pre>
<p>Split the input program on that regex, and keep only non-empty strings. This splits
the program into single bf chars and groups of NOPs.</p>
<pre class="lang-js prettyprint-override"><code>:vL¦0pṪZ
</code></pre>
<p>Get the length of each group, get the cumulative sum of that, prepend a 0 and zip
with each group. This has the effect of calculating how many spaces to prepend to
each group.</p>
<pre class="lang-js prettyprint-override"><code>ƛ
</code></pre>
<p>To each item <code>X = [spaces, character_group]</code> in that, do the following</p>
<pre class="lang-js prettyprint-override"><code>÷ð*p
</code></pre>
<p>Prepend <code>spaces</code> spaces to <code>character_group</code></p>
<pre class="lang-js prettyprint-override"><code>nh←=Tuw∨
</code></pre>
<p>Get the index of <code>character_group</code> in the BF character set stored in the
ghost variable. This is basically a hacky version of <code>ḟ</code> because <code>ḟ</code> doesn't
work on the version the site uses (it's fixed in the 2.6 preleases, but I'm
sticking with 2.4.1)</p>
<pre class="lang-js prettyprint-override"><code>□ḣ
</code></pre>
<p>Wrap all inputs (program and explanation strings) into a single list and push
the program separately from the explanation strings.</p>
<pre class="lang-js prettyprint-override"><code>∇‟İ
</code></pre>
<p>Do some weird stack manipulation to retrieve the corresponding explanation
string using the index generated by <code>nh←=Tuw∨</code>.</p>
<pre class="lang-js prettyprint-override"><code>„L›„↲$+
</code></pre>
<p>Left justify the character group with the prepended spaces with extra spaces
to match the length of the input program + 1. And add that to the explanation
using some extra weird stack manipulation.</p>
<pre class="lang-js prettyprint-override"><code>4ð*p∑
</code></pre>
<p>Indent that 4 spaces, and convert into a single string.</p>
<pre class="lang-js prettyprint-override"><code>;⁋
</code></pre>
<p>Join the entire list on newlines. The <code>j</code> flag would usually take care of this,
but 69 is a funny number.</p>
</div>
<div id="pu14" class="pu"><h1><a href="https://github.com/m-ender/retina/wiki/The-Language" rel="nofollow noreferrer">Retina</a>, <s>207</s> 205 bytes</h1>
<pre><code>*\K````
*\0G`
\G.
$&amp; $&amp;¶
m,-10T`_&gt;&lt;+\-.,[]p`d`.$
(?&lt;=^(.+¶)*.) 9¶(?=. 9)

+`^(.+¶)*(.)+ .¶(?!¶|(?&lt;-2&gt; )*(?(2)$))
$&amp; 
,-10P`.+
+`(\d)( *)(¶(.+¶)*¶)
$2$1*_$3
+`(_)+(¶(.+¶)*(?&lt;-1&gt;.*¶)+(.*))
$4$2
(¶.*){9}$
```
</code></pre>
<p><a href="https://tio.run/##RU/NagIxEL7PU6QQZCZxB3ftZUF3L4KU0lao4MHYjWhAQbdFpJe2r7UPsC@2nVSlgW@Y5PuZySmc9/U67TrjHr0cMG4w9eCmDLqndK9t4NhP0sHcV8XIuoT7y9WH33rWgOVo/IZs24YMk8rbBssxq5wArL8RyGQVR@qubb7FkmSFkucSM9JEcQjE/JlnKzZ0W0JlCMVxCRCAznRqKj2MgorsPxnz0oKjyCKbmHevMxCBXL7yHw3ypa6TzWXx55fZcgVP75/hUh7qzSkcQ32GSbh1r/PJHxa7/SFcq/h@AQ" rel="nofollow noreferrer" title="Retina – Try It Online">Try it online!</a> Explanation:</p>
<pre><code>*\K````
</code></pre>
<p>Output the leading fence.</p>
<pre><code>*\0G`
</code></pre>
<p>Output the line of code.</p>
<pre><code>\G.
$&amp; $&amp;¶
</code></pre>
<p>Split the line of code into characters. For each character, repeat it twice, joined with a space.</p>
<pre><code>m,-10T`_&gt;&lt;+\-.,[]p`d`.$
</code></pre>
<p>Transliterate the last character of each pair to a digit <code>1-8</code>, with unknown characters becoming <code>9</code>.</p>
<pre><code>(?&lt;=^(.+¶)*.) 9¶(?=. 9)

</code></pre>
<p>Join together all runs of unknown characters.</p>
<pre><code>+`^(.+¶)*(.)+ .¶(?!¶|(?&lt;-2&gt; )*(?(2)$))
$&amp; 
</code></pre>
<p>(note trailing space) Align each run after the end of the previous run.</p>
<pre><code>,-10P`.+
</code></pre>
<p>Pad all of the explanation lines to the same width.</p>
<pre><code>+`(\d)( *)(¶(.+¶)*¶)
$2$1*_$3
</code></pre>
<p>Convert all of the transliterated digits to runs of underscores and move them to the end of the line.</p>
<pre><code>+`(_)+(¶(.+¶)*(?&lt;-1&gt;.*¶)+(.*))
$4$2
</code></pre>
<p>Replace each run of underscores with the appropriate line of explanation.</p>
<pre><code>(¶.*){9}$
```
</code></pre>
<p>Replace all of the explanations with the trailing fence.</p>
</div>
<div id="pu15" class="pu"><h1>JavaScript (ES2022), 141 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>s=&gt;a=&gt;&quot;    &quot;+s+s.replace(/(?:[^+-.&lt;&gt;[\]]+|.)(?=(.*))/g,(c,e)=&gt;`
`+(c+e.replace(/.|$/g,' ')).padStart(s.length+5)+a.at('&gt;&lt;+-.,[]'.indexOf(c)))
</code></pre>
<p><a href="https://tio.run/##jVPfb9MwEH4mf8XRIdVeWqca4oH1x4TgZROjk9hbVzTXuSTeEjuyL4Wy7m8vTrrBJjFBHiL5@@67@3x3vpFr6ZXTNQ2NTXGXHL6O4BAuSrvJdFmCzeCDc3JzIAkyZ6uWLIhqf5wkuaaiWQllq4TU2/dJ7WxtvSyHDktJeo1DbVL8oU0@rJAKmx7UtuzStlk@2nrjdF4QMMXhaHQ0gku5gg90q42HMyfaoPPTS/isFRqP4ZhE89UNKhIpZtrgRaiHjjascyhCebK0qXEAfUn9AdxFAGtZNngMWWMUaWtAEjM8MK8ADEzhXFIhyAW2hbdbGI1bSmfADExgxENUPAUqtBclmpyK53wrMTB7FsHBITXOQGP2PtNO8wC2gQuzHAdv94Pw@@40yVUZPAYb2CJomgrdHstk6TtQWZPpvHFPQ@/5OIqy6c5PZ3I660H4erGPvXBYl1IhS9jJ8eJbPBST2eJquYy3grOTKROHnCf5gKkB8unsOrqOmYrxj0ps3wS6D33ORS3TryQdscfbxe94LEVoY382CZkHi2VfdGOeZ2GOnO@CU29LFKXNWcZ6i@VkdnfPeBwPh0IMBj3OrqNzu8bQCYTaakPogGx37PbhRbbEjKJToxxWaKiDKqys24DCsKqSnoqiT/ifgfOG6mYPqUI6qdqSXudGZxpTWG321F@Up6YVyicyaVLwZB2CJtDmReVZU9VQS/9gTpIqwjOBZbtZL2hAexjthSupbh@b8lu7@IfWWPMTnY2@WJiHZyPb5xBdh@XXFePC16UOM70yYeh8vPsF" rel="noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<pre class="lang-javascript prettyprint-override"><code>f: (source_code: string) =&gt; (explain_array: string[]) =&gt; string
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/237408/">237408</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




