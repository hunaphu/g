<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::83039</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>215</td><td>Go</td><td>240329T141908Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/272190#272190">bigyihsu</a></td></tr>
<tr d-ix="1"><td>026</td><td>Uiua</td><td>240329T124418Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/272186#272186">noodle m</a></td></tr>
<tr d-ix="2"><td>081</td><td>Javascript</td><td>240329T061834Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/272185#272185">l4m2</a></td></tr>
<tr d-ix="3"><td>048</td><td>Julia p 9</td><td>210827T103240Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/233776#233776">MarcMush</a></td></tr>
<tr d-ix="4"><td>088</td><td>PowerShell Core</td><td>210824T214400Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/233700#233700">Julian</a></td></tr>
<tr d-ix="5"><td>234</td><td>Rust</td><td>210825T062730Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/233705#233705">Ritwin</a></td></tr>
<tr d-ix="6"><td>nan</td><td>C90 OpenMP</td><td>160618T010338Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83214#83214">dj0wns</a></td></tr>
<tr d-ix="7"><td>070</td><td>Matlab</td><td>160619T130821Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83291#83291">Sanchise</a></td></tr>
<tr d-ix="8"><td>021</td><td>Dyalog APL</td><td>160616T203844Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83096#83096">marinus</a></td></tr>
<tr d-ix="9"><td>357</td><td>c++</td><td>170414T074817Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/116449#116449">jdt</a></td></tr>
<tr d-ix="10"><td>131</td><td>C#</td><td>160617T153822Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83169#83169">AXMIM</a></td></tr>
<tr d-ix="11"><td>457</td><td>Common Lisp Lispworks</td><td>160718T045533Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/85603#85603">sadfaf</a></td></tr>
<tr d-ix="12"><td>nan</td><td>Clojure</td><td>160617T195155Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83198#83198">Chris F</a></td></tr>
<tr d-ix="13"><td>101</td><td>Perl</td><td>160620T144224Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83350#83350">primo</a></td></tr>
<tr d-ix="14"><td>166</td><td>Common Lisp SBCL</td><td>160621T181019Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83498#83498">Jason</a></td></tr>
<tr d-ix="15"><td>116</td><td>Ruby with parallel gem</td><td>160616T143417Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83068#83068">Gosha U.</a></td></tr>
<tr d-ix="16"><td>127</td><td>C</td><td>160617T082117Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83121#83121">nneonneo</a></td></tr>
<tr d-ix="17"><td>071</td><td>Perl 6</td><td>160618T222401Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83262#83262">Hotkeys</a></td></tr>
<tr d-ix="18"><td>164</td><td>Scratch</td><td>160618T210907Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83255#83255">Scimonst</a></td></tr>
<tr d-ix="19"><td>132</td><td>Python 2</td><td>160618T120955Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83235#83235">moooeeee</a></td></tr>
<tr d-ix="20"><td>172</td><td>Python 2</td><td>160616T093324Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83050#83050">user4594</a></td></tr>
<tr d-ix="21"><td>246</td><td>Haskell</td><td>160617T132734Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83153#83153">Koterpil</a></td></tr>
<tr d-ix="22"><td>130</td><td>Python 2</td><td>160617T195254Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83199#83199">nneonneo</a></td></tr>
<tr d-ix="23"><td>678</td><td>R + Snowfall</td><td>160617T153648Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83168#83168">JDL</a></td></tr>
<tr d-ix="24"><td>168</td><td>Elixir</td><td>160617T152359Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83167#83167">Candy Gu</a></td></tr>
<tr d-ix="25"><td>nan</td><td>Javascript ES6</td><td>160617T021924Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83107#83107">Ismael M</a></td></tr>
<tr d-ix="26"><td>143</td><td>Groovy</td><td>160616T162309Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83073#83073">manatwor</a></td></tr>
<tr d-ix="27"><td>nan</td><td>C with pthreads</td><td>160617T000348Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83105#83105">bodqhroh</a></td></tr>
<tr d-ix="28"><td>313</td><td>Java</td><td>160616T123236Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83062#83062">user9023</a></td></tr>
<tr d-ix="29"><td>105</td><td>Javascript ES6</td><td>160617T025737Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83109#83109">Andrew</a></td></tr>
<tr d-ix="30"><td>nan</td><td>Javascript ES6</td><td>160616T170932Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83076#83076">Ismael M</a></td></tr>
<tr d-ix="31"><td>nan</td><td>JavaScript ES6</td><td>160616T203425Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83095#83095">bodqhroh</a></td></tr>
<tr d-ix="32"><td>109</td><td>Mathematica</td><td>160616T205742Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83100#83100">LegionMa</a></td></tr>
<tr d-ix="33"><td>148</td><td>JavaScript ES6</td><td>160616T194153Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83089#83089">Neil</a></td></tr>
<tr d-ix="34"><td>085</td><td>Bash + GNU utilities</td><td>160616T172225Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83077#83077">Digital </a></td></tr>
<tr d-ix="35"><td>092</td><td>Ruby</td><td>160616T183219Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83083#83083">histocra</a></td></tr>
<tr d-ix="36"><td>093</td><td>Bash</td><td>160616T085328Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83045#83045">Julie Pe</a></td></tr>
<tr d-ix="37"><td>189</td><td>Go</td><td>160616T150425Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83069#83069">Rob</a></td></tr>
<tr d-ix="38"><td>144</td><td>PowerShell v4</td><td>160616T143310Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83067#83067">AdmBorkB</a></td></tr>
<tr d-ix="39"><td>247</td><td>Rust</td><td>160616T141739Z</td><td><a href="https://codegolf.stackexchange.com/questions/83039/wait-a-minute-in-less-than-ten-seconds/83066#83066">raggy</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://go.dev" rel="nofollow noreferrer">Go</a>, 215 bytes</h1>
<pre class="lang-go prettyprint-override"><code>import.&quot;time&quot;
type D=Duration
func f()(e,t D){N:=Now
s,c:=N(),make(chan D)
for i:=0;i&lt;9;i++{go func(C chan D){s:=N();Sleep(7*Second);C&lt;-N().Sub(s)}(c)}
for i:=0;i&lt;9;i++{select{case a:=&lt;-c:t+=a}}
return N().Sub(s),t}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=ZY89asQwEIV7nWJwJcX2ki6JbVXregn4BIoy9oq1JCONCcH4JGlMIIcI5B4ht4n3J6TYaoY3bx7ve3vv_PI5KH1QHYJVxjFjBx9ok7SWko-R2vz-5_tPI2MxYfQ6INSyHoMi4x1rR6eh5YJjRlCLaVfInX9hMdPrwkVm1QG53iu3HlnrA5hC3pameihNmk6dh2MA38LFMsXTW9n0iAO_u2lQe_csym2Vr_KmGZ94FDPXYr4Oi9ijpkmriKAKWeW6oFSqeWYBaQwO_hMyms94X6f-R3YuYGKPwTjqHV-BBLtYluU8fwE" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Spawns 9 threads of 7 seconds each. Returns in the ballpark of <code>7.000295677s 1m3.002016702s</code>.</p>
<h3>Ungolfed Explaination</h3>
<pre class="lang-go prettyprint-override"><code>import.&quot;time&quot;
func f()(exec,total Duration){
    start:=Now()                  // start time
    duration:=7*Second            // duration per thread
    c:=make(chan Duration)        // channel to get time elapsed from
    for i:=0;i&lt;9;i++{             // for 0 to 9...
        go func(C chan Duration){ // spawn a thread that...
            s:=Now()              // gets its start time
            Sleep(duration)       // sleeps for the duration
            C&lt;-Now().Sub(s)       // returns the time slept
        }(c)                      // actually run the thread
    }
    for i:=0;i&lt;9;i++{             // for each thread...
        select {                  // wait for...
        case amt:=&lt;-c:            // something to come in on the channel
            total+=amt            // add it to the total slept time
        }
    }
    return Now().Sub(start),total // return elapsed time, and slept time
}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=bZBNSsUwFIVxmKwidJRY-3DkT187eo5F6ApielvDa5KS3qIgXYmTIrgIwZW4GpPW51NwdMM9N9_hnJfX1s3vvVR72QIzUluqTe88bpLGYPI2YpNdfZ5cHJaoDSS0Ga1iDRccnkCdoUPZsZvRS9TOimdKBpQe8_LWPXJBSf2t5OXlaQXK2ZoSlZdG7oGrB2mPXylpnGc6L8-3urje6jQNMNI6Fg35jv29jhoZfmwIqTqAntdHGiG7IlvkTTXe8yGuJq7CmP63GqADhSw-lRyASRNiFJnKI2vJmZZhFzELwwOO3rJfFjG5WCuh01rfx1JX7JaLgL7z2mJneehPHE7meZ1f" rel="nofollow noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu1" class="pu"><h1>Uiua, 26 bytes</h1>
<pre><code>âŠƒ/+/â†¥waitâ‰¡spawnâœnow&amp;slâ†¯9 7
</code></pre>
<p>Spawns 9 threads, each waits 7 seconds.</p>
<p>Explanation:</p>
<pre><code>âŠƒ/+/â†¥waitâ‰¡spawnâœnow&amp;slâ†¯9 7Â­â¡â€‹â€â€âªâ¡âªâ âªâ¢â¢â£âªâ€â â€âªâ¡âªâ âªâ¢â¢â¤âªâ€â â€âªâ¡âªâ âªâ¢â£â¡âªâ€â â€âªâ¡âªâ âªâ¢â£â¢âªâ€â€â€‹â¡â â¡â€Œâ¢â€‹â€â€âªâ¡âªâ âªâ£â¢âªâ€â â€âªâ¡âªâ âªâ£â£âªâ€â â€âªâ¡âªâ âªâ£â¤âªâ€â â€âªâ¡âªâ âªâ¤â¡âªâ€â â€âªâ¡âªâ âªâ¤â¢âªâ€â â€âªâ¡âªâ âªâ¤â£âªâ€â€â€‹â¡â â¡â€Œâ£â€‹â€â€âªâ¡âªâ âªâ¤â¤âªâ€â â€âªâ¡âªâ âªâ¢â¡â¡âªâ€â â€âªâ¡âªâ âªâ¢â¡â¢âªâ€â â€âªâ¡âªâ âªâ¢â¡â£âªâ€â€â€‹â¡â â¡â€Œâ¤â€‹â€â€âªâ¡âªâ âªâ¢â¡â¤âªâ€â â€âªâ¡âªâ âªâ¢â¢â¡âªâ€â â€âªâ¡âªâ âªâ¢â¢â¢âªâ€â€â€‹â¡â â¡â€Œâ¢â¡â€‹â€â€âªâ¡âªâ âªâ¢â¢âªâ€â â€âªâ¡âªâ âªâ¢â£âªâ€â â€âªâ¡âªâ âªâ¢â¤âªâ€â â€âªâ¡âªâ âªâ£â¡âªâ€â€â€‹â¡â â¡â€Œâ¢â¢â€‹â€â€âªâ¡âªâ âªâ¡âªâ€â â€âªâ¡âªâ âªâ¢âªâ€â â€âªâ¡âªâ âªâ£âªâ€â â€âªâ¡âªâ âªâ¤âªâ€â â€âªâ¡âªâ âªâ¢â¡âªâ€â€â€‹â¡â â¡â€ŒÂ­
                      â†¯9 7  # â€â¡Create a list of 9 7s.
         â‰¡spawn             # â€â¢For each of these, spawn a thread which
               âœnow         # â€â£  returns the time taken to
                   &amp;sl      # â€â¤  sleep 7 seconds.
     wait                   # â€â¢â¡Wait for all threads to finish.
âŠƒ/+/â†¥                       # â€â¢â¢Push the maximum and the sum of this list.
ğŸ’
</code></pre>
<p>Created with the help of <a href="https://vyxal.github.io/Luminespire" rel="nofollow noreferrer">Luminespire</a>.</p>
</div>
<div id="pu2" class="pu"><h1>Javascript, 81 bytes</h1>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>for(M=(N=Date.now)(T=Y=i=0);i&lt;350;)setTimeout("T+=k=N()-M,--i||alert([k,T])",++i)</code></pre>
</div>
</div>
</p>
<p>From Ismael Miguel's</p>
</div>
<div id="pu3" class="pu"><h1><a href="http://julialang.org/" rel="nofollow noreferrer">Julia</a> -p 9, 48 bytes</h1>

<pre class="lang-julia prettyprint-override"><code>@time show(sum(pmap(_-&gt;@elapsed(sleep(7)),1:9)))
</code></pre>
<p><a href="https://tio.run/##FcoxDsIwDAXQq3yJJZHoUJZKDKgDE5dApjXEKEmjOlbh9IG@@b0tCvWfZir5hatoXeVhlWcckJeKzBOr0vqFPHHbM0QRyfIU/mmTGtCVNlZJDA3L5tSSK4mKu3eXkSMV5dlpZC5u8P7Yn0/e@9Z@" rel="nofollow noreferrer" title="Julia 1.0 â€“ Try It Online">Try it online!</a></p>
<ul>
<li>the <code>-p 9</code> option launches julia with 9 workers and with the <code>Distributed</code> standard library</li>
<li><code>pmap</code> distributes the tasks over the available workers</li>
<li><code>@elapsed</code> returns the time taken so that they can be sumed</li>
<li><code>@time</code> prints the total time taken</li>
</ul>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/PowerShell/PowerShell" rel="nofollow noreferrer">PowerShell Core</a>, 88 bytes</h1>

<pre class="lang-powershell prettyprint-override"><code>$u=date
1..9|% -Pa{$d=date
sleep 7
(date)-$d|% T*ls*}-Th 9|measure -su
(date)-$u|% T*ls*
</code></pre>
<h2>Explained</h2>
<pre class="lang-powershell prettyprint-override"><code>$u=date                              # Execution start time
1..9|% -Pa{$d=date                   # Starts 9 threads
sleep 7                              # Sleeps for 7 seconds
(date)-$d|% T*ls*}-Th 9|measure -su  # Gets the (T)ota(ls)econds for the current thread and sum them
(date)-$u|% T*ls*                    # Gets the script time in seconds
</code></pre>
<h2>Sample output</h2>
<p><a href="https://i.stack.imgur.com/Hv93Z.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/Hv93Z.png" alt="Shows total wait time of 63.1528189 seconds and a total run time of 7.1531403 seconds" /></a></p>
</div>
<div id="pu5" class="pu"><h2>Rust, <s>237</s> 234 bytes</h2>
<p>This is basically the same as @raggy's <a href="https://codegolf.stackexchange.com/a/83066/103498">answer</a>, just improved a bit.</p>
<pre class="lang-rs prettyprint-override"><code>use std::thread::*;fn main(){let n=std::time::Instant::now;let i=n();let mut t=i-i;for x in(0..8).map(|_|spawn(move||{let i=n();sleep_ms(9000);i.elapsed()})).collect::&lt;Vec&lt;_&gt;&gt;(){t+=x.join().unwrap();}print!(&quot;{:?}{:?}&quot;,t,i.elapsed());}
</code></pre>
<p>Ungolfed:</p>
<pre class="lang-rs prettyprint-override"><code>use std::thread::*;
fn main() {
    let n = std::time::Instant::now;
    let i = n();
    let mut t = i-i;
    for x in (0..8).map(|_| spawn(move || {
            let i = n();
            sleep_ms(9000);
            i.elapsed()
        })).collect::&lt;Vec&lt;_&gt;&gt;() {
            t += x.join().unwrap();
    }
    print!(&quot;{:?}{:?}&quot;, t, i.elapsed());
}
</code></pre>
<p>Improvements:</p>
<pre class="lang-rs prettyprint-override"><code>use std::thread::*;
</code></pre>
<p>at the beginning saves 7 bytes.</p>
<p>Not creating a new variable for a Vec of threads saves 5 bytes.</p>
<p>Removing the space in <code>for x in (0..8)</code> saves 1 byte.</p>
<p>The <code>.collect::&lt;Vec&lt;_&gt;&gt;()</code> hurts to look at though, but I can't think of a way to remove it because iterators are lazy in rust (so it won't even start the threads if we simply remove that part).</p>
</div>
<div id="pu6" class="pu"><h1>C90 (OpenMP), 131 Bytes (+ 17 for env variable) = 148 Bytes</h1>

<pre class="lang-c prettyprint-override"><code>#include &lt;omp.h&gt;
#define o omp_get_wtime()
n[4];main(t){t=o;
#pragma omp parallel
while(o-9&lt;t);times(n);printf(&quot;%d,%f&quot;,n[0],o-t);}
</code></pre>
<p>Example Output:</p>
<pre class="lang-c prettyprint-override"><code>7091,9.000014
</code></pre>
<p><a href="https://tio.run/##FYxBCsMgEADvvkISAgqx9NBLse1HQghiViOsqySWHEq/Xptch5mxyltbaxvI4nsG/kgxX5YXa2dwgYAnfoDJQ5n2EiIIyWi4jTqaQKLIT3kmzdq8Gh/NafJsVoMIyPYlIIik7o8i9ZlugqTOa6DiRNPNfeeanobr2Cd1GN9af9ah8VtVeIz@" rel="nofollow noreferrer" title="C (gcc) â€“ Try It Online">Try it online!</a></p>
<p>Notes:</p>
<p>7091 is in cycles (100/sec), so the program ran for 70 seconds</p>
<p>Could be much shorter if I figured a way to get a timer to work other than omp_get_wtime() because then I could remove the include statement aswell.</p>
<p>Run with OMP_NUM_THREADS=9</p>
</div>
<div id="pu7" class="pu"><h2>Matlab, <s>75</s> 70 bytes</h2>
<pre><code>tic;parpool(9);b=1:9;parfor q=b
tic;pause(7);b(q)=toc;end
[sum(b);toc]
</code></pre>
<p>5 bytes saved as it turns out <code>tic</code> and <code>toc</code> are local to each worker process so they did not need to be assigned to a variable.</p>
<p>Quick explanation: <code>parfor</code> creates a parallel for-loop, distributed across the pool of workers. <code>tic</code> and <code>toc</code> measure time elapsed (and are in my opinion one of the best named functions in MATLAB). The last line (an array with the total time slept and the real time elapsed) is outputted since it's not terminated with a semicolon.</p>
<p>Note however that this creates a whopping 9 full-fledged MATLAB processes. Chances are then that this particular program this will not finish within the allotted 10 seconds on your machine. However, I think with a MATLAB installation that has no toolboxes except for the Parallel Computing toolbox installed -  installed on a high-end system with SSD - may just be able to finish within 10 seconds. If required, you can tweak the parameters to have less processes sleeping more.</p>
</div>
<div id="pu8" class="pu"><h1>Dyalog APL, <s>65</s> <s>27</s> <s>23</s> 21 bytes</h1>

<pre><code>(âŒˆ/,+/)â•TSYNCâ•DL&amp;Â¨9/7
</code></pre>

<p>I.e.:</p>

<pre><code>      (âŒˆ/,+/)â•TSYNCâ•DL&amp;Â¨9/7
7.022 63.162
</code></pre>

<p>Explanation: </p>

<ul>
<li><code>â•DL&amp;Â¨9/7</code>: spin off 9 threads, each of which waits for 7 seconds. <code>â•DL</code> returns the actual amount of time spent waiting, in seconds, which will be the same as its argument give or take a few milliseconds. </li>
<li><code>â•TSYNC</code>: wait for all threads to complete, and get the result for each thread. </li>
<li><code>(âŒˆ/,+/)</code>: return the longest execution time of one single thread (during the execution of which all other threads finished, so this is the actual runtime), followed by the sum of the execution time of all threads. </li>
</ul>

<p><a href="https://tio.run/nexus/apl-dyalog#e9TRnvZf41FPh76Otr7mo76pIcGRfs5A2sVH7dAKS33z/4862v@nfc3L101OTM5IBQA" rel="noreferrer" title="APL (Dyalog Unicode) â€“ TIO Nexus">Try it online!</a></p>
</div>
<div id="pu9" class="pu"><h2>c++, <s>332</s> <s>358</s> 357 bytes</h2>

<p>Thanks AdÃ¡m!</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;chrono&gt;
#include &lt;thread&gt;
#define n(x)auto x=chrono::steady_clock::now();
using namespace std;double t=0;void f(){n(s)this_thread::sleep_for(chrono::seconds(9));n(e)t+=(e-s).count()/1e9;}int main(){int i;n(s)thread*a[7];for(i=0;i&lt;7;i++)a[i]=new thread(f);for(i=0;i&lt;7;i++)a[i]-&gt;join();n(e)cout&lt;&lt;t&lt;&lt;","&lt;&lt;(e-s).count()/1e9&lt;&lt;"\n";}
</code></pre>

<p><a href="https://tio.run/nexus/cpp-gcc#bY7NTsMwEAbvfQqrXGxC@DlVjZ2@SKkiY2@ahWQ3ih1ahPrqBIdIgASSD6tPoxlPV0iuHT0IgxziALbbrX421wxM/HuJTWJ8WjzUSCBInpUdI4tzucBFEWIi3irXsnspCuKTVHo1BqSjINtB6K0DEaLXnsenFkQs7/Uroxe1VO8kg4oNhmoJJVsL0Fc1D/LbD47JB7lVSpMEFbNSQh7UreORolR3D7DVF6QoOouUnPOJejHP0mu73xz0rMSURrPRmGXK7vFQEpzEAsla/Yvku2eerV/pVIzGpLe@WRvz5xdpf6S1vkzTh6tbewxT3i/2Tw" rel="nofollow noreferrer">Try it online</a></p>
</div>
<div id="pu10" class="pu"><h1><strong>C#, 131 bytes</strong></h1>

<p>The following start 9 threads that each wait 6667 milliseconds.<br>
The program run in 6.73 secondes and has the following output :  <strong>00:00:06.7116711|604140408</strong><br>
Where "604140408" is the number of tick.<br>
There are 10 000ticks is a millisecond.<br>
So this give ~60.414 seconds.
Total execution time and wait time don't have the same output format for golfing reason.</p>

<pre><code>using t=DateTime;var s=t.Now;Task.WhenAll(new t[9].Select(y=&gt;Task.Delay(6667))).Wait();Debug.Write(t.Now-s+"|"+(t.Now-s).Ticks*9);
</code></pre>

<p><a href="https://dotnetfiddle.net/Widget/eYTgF9" rel="nofollow noreferrer">Here</a> is a fiddle that exceed the limit of execution of time of fiddle. Lower "6667" so that it fix fiddle's criteria if you want to run it.</p>
</div>
<div id="pu11" class="pu"><h2>Common Lisp (Lispworks), 457 bytes</h2>

<pre><code>(defun f(n)(labels((h(n b v)(mp:process-run-function nil nil #'(lambda(b v)(progn(let((s(get-internal-real-time)))(sleep 5)(setf(svref v n)(-(get-internal-real-time)s)))(mp:barrier-wait b :pass-through t)))b v)))(let((s(get-internal-real-time))(e 0)(q 0)(v(make-sequence 'vector n :initial-element 0))(b(mp:make-barrier(1+ n))))(dotimes(i n)(h i b v))(mp:barrier-wait b)(setf e(-(get-internal-real-time)s))(dotimes(p n)(setf q(+ q(svref v p))))(list e q))))
</code></pre>

<p>ungolfed:</p>

<pre><code>    (defun f (n-thread)
      (labels ((my-process (process-name n barrier vec)
                 (mp:process-run-function
                  process-name
                  nil
                  #'(lambda (barrier vec)
                      (progn
                        (let ((start-time (get-internal-real-time)))
                          (sleep 5)
                          (setf (svref vec n)
                                (- (get-internal-real-time) start-time)))
                        (mp:barrier-wait barrier :pass-through t)))
                  barrier
                  vec)))

        (let ((total-start-time (get-internal-real-time))
              (total-time 0)
              (sum-per-process-time 0)
              (vector (make-sequence 'vector n-thread :initial-element 0))
              (barrier (mp:make-barrier (1+ n-thread))))
          (dotimes (i n-thread)
            (my-process
             (concatenate 'string "process-" (write-to-string i))
             i
             barrier
             vector))
          (mp:barrier-wait barrier)
          (setf total-time (- (get-internal-real-time) total-start-time))
          (dotimes (p n-thread)
            (setf sum-per-process-time
                  (+ sum-per-process-time (svref vector p))))
          (list total-time sum-per-process-time))))
</code></pre>

<p>Usage:</p>

<pre><code>CL-USER 1 &gt; (f 14)
(5028 70280)
</code></pre>
</div>
<div id="pu12" class="pu"><h1>Clojure, <del>135</del> <del>120</del> <del>111</del> 109 bytes</h1>

<pre><code>(let[t #(System/nanoTime)s(t)f #(-(t)%)][(apply +(pmap #(let[s(t)](Thread/sleep 7e3)%(f s))(range 9)))(f s)])
</code></pre>

<p>Formatted version with named variables:
</p>

<pre><code>(let [time #(System/currentTimeMillis)
      start (time)
      fmt #(- (time) %)]
  [(apply +
           (pmap #(let [thread-start (time)]
                   (Thread/sleep 7e3)
                   %
                   (fmt thread-start)) (range 9)))
   (fmt start)])
</code></pre>

<p>output (in nanoseconds):</p>

<pre><code>[62999772966 7001137032]
</code></pre>

<p>Changed format. Thanks AdÃ¡m, I might have missed that format specification in the question when I read it.</p>

<p>Changed to nanoTime for golfing abilities.</p>

<p>Thanks cliffroot, I totally forgot about scientific notation and can't believe I didn't see <code>apply</code>. I think I used that in something I was golfing yesterday but never posted. You saved me 2 bytes.</p>
</div>
<div id="pu13" class="pu"><h2>Perl, 101 bytes</h2>



<pre class="lang-perl prettyprint-override"><code>use Time::HiRes&lt;time sleep&gt;;pipe*1=\time,0;
print time-$1,eval&lt;1&gt;if open-print{fork&amp;fork&amp;fork}-sleep 9
</code></pre>

<p>Forks 7 child processes, each of which wait 9 seconds.</p>

<p><strong>Sample Output:</strong></p>

<pre class="lang-perl prettyprint-override"><code>perl wait-one-minute.pl
9.00925707817078-63.001741
</code></pre>
</div>
<div id="pu14" class="pu"><h1>Common Lisp (SBCL) 166 bytes:</h1>

<pre><code>(do((m #1=(get-internal-real-time))(o(list 0)))((&gt;(car o)60000)`(,(car o),(- #1#m)))(sb-thread:make-thread(lambda(&amp;aux(s #1#))(sleep 1)(atomic-incf(car o)(- #1#s)))))
</code></pre>

<p>This just spawns threads that sleep and then atomically increment the time took, with an outer-loop that spins waiting for the total time to be more than 60000 ticks (i.e. 60s on sbcl).  The counter is stored in a list due to limitations to the types of places atomic-incf can modify.  This may run out of space before terminating on faster machines.</p>

<p>Ungolfed:</p>

<pre><code>(do ((outer-start (get-internal-real-time))
       (total-inner (list 0)))
      ((&gt; (car total-inner) 60000)
       `(,(car total-inner)
      ,(- (get-internal-real-time) outer-start)))
    (sb-thread:make-thread
     (lambda (&amp;aux(start (get-internal-real-time)))
       (sleep 1)
       (atomic-incf (car total-inner) (- (get-internal-real-time) start)))))
</code></pre>
</div>
<div id="pu15" class="pu"><h1>Ruby (with <code>parallel</code> gem), <strike>123</strike> 116 bytes</h1>

<pre><code>require'parallel'
n=-&gt;{Time.now}
t=n[]
q=0
Parallel.each(1..10,:in_threads=&gt;10){z=n[];sleep 6;q+=n[]-z}
puts n[]-t,q
</code></pre>

<p>Edit: Added the "Time.now" reference from the Ruby answer by histocrat.</p>
</div>
<div id="pu16" class="pu"><h1>C, 127 bytes (spins CPU)</h1>

<p>This solution spins the CPU instead of sleeping, and counts time using the <code>times</code> POSIX function (which measures CPU time consumed by the parent process and in all waited-for children).</p>

<p>It forks off 7 processes which spin for 9 seconds apiece, and prints out the final times in C clocks (on most systems, 100 clock ticks = 1 second).</p>

<pre><code>t;v[4];main(){fork(fork(fork(t=time(0))));while(time(0)&lt;=t+9);wait(0);wait(0);wait(0)&gt;0&amp;&amp;(times(v),printf("%d,%d",v[0],v[2]));}
</code></pre>

<p>Sample output:</p>

<pre><code>906,6347
</code></pre>

<p>meaning 9.06 seconds real time and 63.47 seconds total CPU time.</p>

<p>For best results, compile with <code>-std=c90 -m32</code> (force 32-bit code on a 64-bit machine).</p>
</div>
<div id="pu17" class="pu"><h1>Perl 6, <s>72</s> 71 bytes</h1>

<p>
There might be a shorter way to do this</p>

<pre class="lang-perl6 prettyprint-override"><code>say sum await map {start {sleep 7;now -ENTER now}},^9;say now -INIT now
</code></pre>

<p>this outputs</p>

<pre class="lang-perl6 prettyprint-override"><code>63.00660729694
7.0064013
</code></pre>
</div>
<div id="pu18" class="pu"><h1>Scratch - <a href="http://meta.codegolf.stackexchange.com/questions/673/golfing-in-scratch/5013#5013">164 bytes</a> (16 blocks)</h1>

<pre><code>when gf clicked
set[t v]to[
repeat(9
  create clone of[s v
end
wait until&lt;(t)&gt;[60
say(join(join(t)[ ])(timer
when I start as a clone
wait(8)secs
change[t v]by(timer
</code></pre>

<p><a href="https://i.stack.imgur.com/07dUP.png" rel="noreferrer"><img src="https://i.stack.imgur.com/07dUP.png" alt="Visual script"></a></p>

<p>See it in action <a href="https://scratch.mit.edu/projects/114222939/" rel="noreferrer">here</a>.</p>

<p>Uses a variable called 't' and a sprite called 's'. The sprite creates clones of itself, each of which waits 8 seconds, and increments a variable clocking the entire wait time. At the end it says the total execution time and the total wait time (for example, <code>65.488 8.302</code>).</p>
</div>
<div id="pu19" class="pu"><h1>Python 2, 132 bytes</h1>

<p>Uses a process pool to spawn 9 processes and let each one sleep for 7 seconds.</p>

<pre><code>import time as t,multiprocessing as m
def f(x):d=s();t.sleep(x);return s()-d
s=t.time
a=s()
print sum(m.Pool(9).map(f,[7]*9)),s()-a
</code></pre>

<p>Prints total accumulated sleeptime first, then the actual runtime:</p>

<pre><code>$ python test.py
63.0631158352 7.04391384125
</code></pre>
</div>
<div id="pu20" class="pu"><h2>Python 2, 172 bytes</h2>
<pre class="lang-py prettyprint-override"><code>import threading as H,time as T
m=T.time
z=H.Thread
s=m()
r=[]
def f():n=m();T.sleep(9);f.t+=m()-n
f.t=0
exec&quot;r+=[z(None,f)];r[-1].start();&quot;*8
map(z.join,r)
print m()-s,f.t
</code></pre>
<p>This requires an OS with time precision greater than 1 second to work properly (in other words, any modern OS). 8 threads are created which sleep for 9 seconds each, resulting in a realtime runtime of ~9 seconds, and a parallel runtime of ~72 seconds.</p>
<p>Though the <a href="https://docs.python.org/2/library/threading.html#threading.Thread" rel="noreferrer">official documentation</a> says that the <code>Thread</code> constructor should be called with keyword arguments, I throw caution to the wind and use positional arguments anyway. The first argument (<code>group</code>) must be <code>None</code>, and the second argument is the target function.</p>
<p>nneonneo pointed out in the comments that attribute access (e.g. <code>f.t</code>) is shorter than list index access (e.g. <code>t[0]</code>). Unfortunately, in most cases, the few bytes gained from doing this would be lost by needing to create an object that allows user-defined attributes to be created at runtime. Luckily, functions support user-defined attributes at runtime, so I exploit this by saving the total time in the <code>t</code> attribute of <code>f</code>.</p>
<p><a href="http://ideone.com/S1KdiG" rel="noreferrer">Try it online</a></p>
<p>Thanks to DenkerAffe for -5 bytes with the <code>exec</code> trick.</p>
<p>Thanks to kundor for -7 bytes by pointing out that the thread argument is unnecessary.</p>
<p>Thanks to nneonneo for -7 bytes from miscellaneous improvements.</p>
</div>
<div id="pu21" class="pu"><h1>Haskell, <s>278</s> <s>271</s> <s>262</s> 246 bytes</h1>

<pre><code>import Control.Concurrent.Chan
import Data.Time
import GHC.Conc
t=getCurrentTime
b!a=b=&lt;&lt;flip diffUTCTime&lt;$&gt;t&lt;*&gt;(a&gt;&gt;t)
w=threadDelay$5^10
0#_=t
i#a=a&gt;&gt;(i-1)#a
main=print!do r&lt;-newChan;9#(forkIO$writeChan r!w);getChanContents r&gt;&gt;=print.sum.take 9
</code></pre>

<p><code>!</code> measures the time taken by action <code>a</code> (second argument) and applies <code>b</code> (first argument) to the result.</p>

<p><code>w</code> is the sleep function.</p>

<p><code>main</code> is measured itself, and result printed (<code>print!...</code>).</p>

<p><code>#</code> is <code>replicateM</code>, repeating the given action N times (and returning <code>t</code> because golfing).</p>

<p>Inside the measured part, 9 threads (<code>replicate 9 $ forkIO ...</code>) sleep for <code>5^10</code> milliseconds (9.765625 seconds) and post the result (<code>writeChan</code>) to a pipe created by the main thread (<code>newChan</code>), which sums the 9 results up and prints the total (<code>getChanContents &gt;&gt;= print . sum . take 9</code>).</p>

<p>Output:</p>

<pre><code>87.938546708s
9.772032144s
</code></pre>
</div>
<div id="pu22" class="pu"><h1>Python 2, 130 bytes</h1>

<pre><code>import thread as H,time as T
m=T.clock;T.z=m()
def f(k):T.sleep(k);T.z+=m()
exec"H.start_new_thread(f,(7,));"*9
f(8);print m(),T.z
</code></pre>

<p>This is a derivation of Mego's answer, but it's sufficiently different that I thought it should be a separate answer. It is tested to work on Windows.</p>

<p>Basically, it forks off 9 threads, which sleep for 7 seconds while the parent sleeps for 8. Then it prints out the times. Sample output:</p>

<pre><code>8.00059192923 71.0259046024
</code></pre>

<p>On Windows, <code>time.clock</code> measures wall time since the first call.</p>
</div>
<div id="pu23" class="pu"><h1>R + <a href="https://cran.r-project.org/web/packages/snowfall/index.html" rel="nofollow">Snowfall</a>, 67 UTF-8 bytes</h1>

<pre><code>library(snowfall)
sfInit(T,8)
sfSapply(1:8,function(j)Sys.sleep(8))
</code></pre>
</div>
<div id="pu24" class="pu"><h1>Elixir, 168 bytes</h1>

<pre><code>import Task;import Enum;IO.puts elem(:timer.tc(fn-&gt;IO.puts(map(map(1..16,fn _-&gt;async(fn-&gt;:timer.tc(fn-&gt;:timer.sleep(4000)end)end)end),&amp;(elem(await(&amp;1),0)))|&gt;sum)end),0)
</code></pre>

<p>Sample run:</p>

<pre><code>$ elixir thing.exs
64012846
4007547
</code></pre>

<p>The output is the total time waited followed by the time the program has run for, in microseconds.</p>

<p>The program spawns 14 <code>Task</code>s, and awaits each of them by mapping over them, and then finds the sum of their elapsed time.  It uses Erlang's <code>timer</code> for measuring time.</p>
</div>
<div id="pu25" class="pu"><h1>Javascript (ES6), <del>108</del> 92 bytes</h1>

<p>I'm making a new answer since this uses a slightly different aproach.</p>

<p>It generates a massive amount of <code>setTimeout</code>s, which are almost all executed with 4ms between them.</p>

<p>Each interval is of 610 milliseconds, over a total of 99 intervals.</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>M=(N=Date.now)(T=Y=0),eval('setTimeout("T+=N()-M,--i||alert([N()-M,T])",610);'.repeat(i=99))</code></pre>
</div>
</div>
</p>

<p>It usually runs within 610ms, for a total execution time of around 60.5 seconds.</p>

<p>This was tested on Google Chrome version 51.0.2704.84 m, on windows 8.1 x64.</p>

<hr>

<p>Old version (108 bytes):</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>P=performance,M=P.now(T=Y=0),eval('setTimeout("T+=P.now()-M,--i||alert([P.now()-M,T])",610);'.repeat(i=99))</code></pre>
</div>
</div>
</p>
</div>
<div id="pu26" class="pu"><h1>Groovy, <s>158</s> 143 characters</h1>

<pre class="lang-groovy prettyprint-override"><code>d={new Date().getTime()}
s=d(j=0)
8.times{Thread.start{b=d(m=1000)
sleep 8*m
synchronized(j){j+=d()-b}}}addShutdownHook{print([(d()-s)/m,j/m])}
</code></pre>

<p>Sample run:</p>

<pre><code>bash-4.3$ groovy wait1minute.groovy
[8.031, 64.055]
</code></pre>
</div>
<div id="pu27" class="pu"><h1>C (with pthreads), <del>339</del> <del>336</del> 335 bytes</h1>

<pre class="lang-cpp prettyprint-override"><code>#include&lt;stdio.h&gt;
#include&lt;sys/time.h&gt;
#include&lt;pthread.h&gt;
#define d double
d s=0;int i;pthread_t p[14];d t(){struct timeval a;gettimeofday(&amp;a,NULL);return a.tv_sec+a.tv_usec/1e6;}
h(){d b=t();sleep(5);s+=t()-b;}
main(){d g=t();for(i=14;i--&gt;0;)pthread_create(&amp;p[i],0,&amp;h,0);for(i=14;i--&gt;0;)pthread_join(p[i],0);printf("%f %f",t()-g,s);}
</code></pre>
</div>
<div id="pu28" class="pu"><h1>Java, <s>358  343 337 316</s> 313 bytes</h1>
<pre><code>import static java.lang.System.*;class t extends Thread{public void run(){long s=nanoTime();try{sleep(999);}catch(Exception e){}t+=nanoTime()-s;}static long t,i,x;public static void main(String[]a)throws Exception{x=nanoTime();for(;++i&lt;99;)new t().start();sleep(9000);out.println((nanoTime()-x)/1e9+&quot; &quot;+t/1e9);}}
</code></pre>
<p>and ungolfed</p>
<pre><code>import static java.lang.System.*;

class t extends Thread {
    public void run() {
        long s = nanoTime();
        try {
            sleep(999);
        } catch (Exception e) {
        }
        t += nanoTime() - s;
    }

    static long t,i,x;

    public static void main(String[] a) throws Exception {
        x = nanoTime();
        for (; ++i &lt; 99;)
            new t().start();
        sleep(9000);
        out.println((nanoTime() - x) / 1e9 + &quot; &quot; + t / 1e9);
    }
}


    
     
    
</code></pre>
<p>please don't try it at home, as this solution is not thread safe.</p>
<h1>Edit:</h1>
<p>I took @A Boschman's and @AdÃ¡m's suggestions, and now my program require less than 10 seconds to run, and it's shorter by 15 bytes.</p>
</div>
<div id="pu29" class="pu"><p><strong>Javascript (ES6), 105 bytes</strong></p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>((t,c,d)=&gt;{i=t();while(c--)setTimeout((c,s)=&gt;{d+=t()-s;if(!c)alert([t()-i,d])},8e3,c,t())})(Date.now,8,0)</code></pre>
</div>
</div>
</p>

<p><strong>Updated version: 106 bytes</strong>
Borrowed from @Ismael Miguel as he had the great idea to lower sleep time and raise intervals.</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>((t,c,d)=&gt;{i=t();while(c--)setTimeout((c,s)=&gt;{d+=t()-s;if(!c)alert([t()-i,d])},610,c,t())})(Date.now,99,0)</code></pre>
</div>
</div>
</p>

<p><strong>Javascript Ungolfed, 167 bytes</strong></p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>(function(t, c, d){
	i = t();
	while(c--){
		setTimeout(function(c, s){
			d += t() - s;
			if (!c) alert([t() - i, d])
		}, 8e3, c, t())
	}
})(Date.now, 8, 0)</code></pre>
</div>
</div>
</p>
</div>
<div id="pu30" class="pu"><h1>Javascript (ES6), <del>212</del> <del>203</del> 145 bytes</h1>

<p>This code creates 10 images with a time interval of exactly 6 seconds each, upon loading.</p>

<p>The execution time goes <strong>a tiny bit</strong> above it (due to overhead).</p>

<p>This code overwrites everything in the document!</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>P=performance,M=P.now(T=Y=0),document.body.innerHTML='&lt;img src=# onerror=setTimeout(`T+=P.now()-M,--i||alert([P.now()-M,T])`,6e3) &gt;'.repeat(i=10)</code></pre>
</div>
</div>
</p>

<p>This assumes that you use a single-byte encoding for the backticks, which is required for the Javascript engine to do not trip.</p>

<hr>

<p>Alternativelly, if you don't want to spend 6 seconds waiting, here's a 1-byte-longer solution that finishes in less than a second:</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>P=performance,M=P.now(T=Y=0),document.body.innerHTML='&lt;img src=# onerror=setTimeout(`T+=P.now()-M,--i||alert([P.now()-M,T])`,600) &gt;'.repeat(i=100)</code></pre>
</div>
</div>
</p>

<p>The difference is that this code waits 600ms across 100 images. This will give a massive ammount of overhead.</p>

<hr>

<p>Old version (203 bytes):</p>

<p>This code creates 10 iframes with a time interval of exactly 6 seconds each, instead of creating 10 images.</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>for(P=performance,M=P.now(T=Y=i=0),D=document,X=_=&gt;{T+=_,--i||alert([P.now()-M,T])};i&lt;10;i++)I=D.createElement`iframe`,I.src='javascript:setTimeout(_=&gt;top.X(performance.now()),6e3)',D.body.appendChild(I)</code></pre>
</div>
</div>
</p>

<hr>

<p>Original version (212 bytes):</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>P=performance,M=P.now(T=Y=0),D=document,X=_=&gt;{T+=_,Y++&gt;8&amp;&amp;alert([P.now()-M,T])},[...''+1e9].map(_=&gt;{I=D.createElement`iframe`,I.src='javascript:setTimeout(_=&gt;top.X(performance.now()),6e3)',D.body.appendChild(I)})</code></pre>
</div>
</div>
</p>
</div>
<div id="pu31" class="pu"><h1>JavaScript (ES6, using WebWorkers), <del>233</del> 215 bytes</h1>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>c=s=0;d=new Date();for(i=14;i--&gt;0;)(new Worker(URL.createObjectURL(new Blob(['a=new Date();setTimeout(()=&gt;postMessage(new Date()-a),5e3)'])))).onmessage=m=&gt;{s+=m.data;if(++c&gt;13)console.log((new Date()-d)/1e3,s/1e3)}</code></pre>
</div>
</div>
</p>

<p><b>UPD:</b> replaced the way a worker is executed from a string with a more compact and cross-browser one, in the aspect of cross-origin policies. Won't work in Safari, if it still have <code>webkitURL</code> object instead of <code>URL</code>, and in IE.</p>
</div>
<div id="pu32" class="pu"><h1>Mathematica, 109 bytes</h1>

<pre><code>a=AbsoluteTiming;LaunchKernels@7;Plus@@@a@ParallelTable[#&amp;@@a@Pause@9,{7},Method-&gt;"EvaluationsPerKernel"-&gt;1]&amp;
</code></pre>

<p>Anonymous function. Requires a license with 7+ sub-kernels to run. Takes 9 seconds realtime and 63 seconds kernel-time, not accounting for overhead. Make sure to only run the preceding statements once (so it doesn't try to re-launch kernels). Testing:</p>

<pre><code>In[1]:= a=AbsoluteTiming;LaunchKernels@7;func=Plus@@@a@ParallelTable[#&amp;@@a@Pause
@9,{7},Method-&gt;"EvaluationsPerKernel"-&gt;1]&amp;;

In[2]:= func[]

Out[2]= {9.01498, 63.0068}

In[3]:= func[]

Out[3]= {9.01167, 63.0047}

In[4]:= func[]

Out[4]= {9.00587, 63.0051}
</code></pre>
</div>
<div id="pu33" class="pu"><h2>JavaScript (ES6), 148 bytes</h2>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>with(performance)Promise.all([...Array(9)].map(_=&gt;new Promise(r=&gt;setTimeout(_=&gt;r(t+=now()),7e3,t-=now())),t=0,n=now())).then(_=&gt;alert([now()-n,t]));</code></pre>
</div>
</div>
</p>

<p>Promises to wait 9 times for 7 seconds for a total of 63 seconds (actually 63.43 when I try), but only actually takes 7.05 seconds of real time when I try.</p>
</div>
<div id="pu34" class="pu"><h1>Bash + GNU utilities, 85</h1>

<pre class="lang-bash prettyprint-override"><code>\time -f%e bash -c 'for i in {1..8};{ \time -aoj -f%e sleep 8&amp;};wait'
paste -sd+ j|bc
</code></pre>
<p>Forces the use of the <code>time</code> executable instead of the shell builtin by prefixing with a <code>\</code>.</p>
<p>Appends to a file <code>j</code>, which must be empty or non-existent at the start.</p>
</div>
<div id="pu35" class="pu"><h1>Ruby, 92</h1>

<pre><code>n=-&gt;{Time.now}
t=n[]
a=0
(0..9).map{Thread.new{b=n[];sleep 6;a+=n[]-b}}.map &amp;:join
p n[]-t,a
</code></pre>
</div>
<div id="pu36" class="pu"><h1>Bash <s>196</s> <s>117</s> <s>114</s> 93 bytes</h1>

<p>Updated to support better time precision by integrating suggestions from @manatwork and @Digital Trauma as well as a few other space optimizations:</p>



<pre class="lang-bash prettyprint-override"><code>d()(date +$1%s.%N;)
b=`d`
for i in {1..8};{ (d -;sleep 8;d +)&gt;&gt;j&amp;}
wait
bc&lt;&lt;&lt;`d`-$b
bc&lt;&lt;&lt;`&lt;j`
</code></pre>

<p>Note that this assumes the <code>j</code> file is absent at the beginning.</p>
</div>
<div id="pu37" class="pu"><h1>Go - 189 bytes</h1>

<p><strong>Thanks @cat!</strong></p>

<pre><code>package main
import(."fmt";."time");var m,t=60001,make(chan int,m);func main(){s:=Now();for i:=0;i&lt;m;i++{go func(){Sleep(Millisecond);t&lt;-0}()};c:=0;for i:=0;i&lt;m;i++{c++};Print(Since(s),c)}
</code></pre>

<p>Outputs (ms):  <strong>160.9939ms,60001</strong> (160ms to wait 60.001 seconds)</p>
</div>
<div id="pu38" class="pu"><h2>PowerShell v4, 144 bytes</h2>

<pre><code>$d=date;gjb|rjb
1..20|%{sajb{$x=date;sleep 3;((date)-$x).Ticks/1e7}&gt;$null}
while(gjb -s "Running"){}(gjb|rcjb)-join'+'|iex
((date)-$d).Ticks/1e7
</code></pre>

<p>Sets <code>$d</code> equal to <code>Get-Date</code>, and clears out any existing job histories with <code>Get-Job | Remove-Job</code>. We then loop <code>1..20|%{...}</code> and each iteration execute <code>Start-Job</code> passing it the script block <code>{$x=date;sleep 3;((date)-$x).ticks/1e7}</code> for the job (meaning each job will execute that script block). We pipe that output to <code>&gt;$null</code> in order to suppress the feedback (i.e., job name, status, etc.) that gets returned.</p>

<p>The script block sets <code>$x</code> to <code>Get-Date</code>, then <code>Start-Sleep</code> for <code>3</code> seconds, then takes a new <code>Get-Date</code> reading, subtracts <code>$x</code>, gets the <code>.Ticks</code>, and divides by <code>1e7</code> to get the seconds (with precision).</p>

<p>Back in the main thread, so long as any job is still <code>-S</code>tatus <code>"Running"</code>, we spin inside an empty <code>while</code> loop. Once that's done, we <code>Get-Job</code> to pull up objects for all the existing jobs, pipe those to <code>Receive-Job</code> which will pull up the equivalent of STDOUT (i.e., what they output), <code>-join</code> the results together with <code>+</code>, and pipe it to <code>iex</code> (<code>Invoke-Expression</code> and similar to <code>eval</code>). This will output the resultant sleep time plus overhead.</p>

<p>The final line is similar, in that it gets a new date, subtracts the original date stamp <code>$d</code>, gets the <code>.Ticks</code>, and divides by <code>1e7</code> to output the total execution time.</p>

<hr>

<h3>NB</h3>

<p>OK, so this is a little <em>bendy</em> of the rules. Apparently on first execution, PowerShell needs to load a bunch of .NET assemblies from disk for the various thread operations as they're not loaded with the default shell profile. <em>Subsequent</em> executions, because the assemblies are already in memory, work fine. If you leave the shell window idle long enough, you'll get PowerShell's built-in garbage collection to come along and <em>unload</em> all those assemblies, causing the next execution to take a long time as it re-loads them. I'm not sure of a way around this.</p>

<p>You can see this in the execution times in the below runs. I started a fresh shell, navigated to my golfing directory, and executed the script. The first run was horrendous, but the second (executed immediately) worked fine. I then left the shell idle for a few minutes to let garbage collection come by, and then that run is again lengthy, but subsequent runs again work fine.</p>

<h3>Example runs</h3>

<pre><code>Windows PowerShell
Copyright (C) 2014 Microsoft Corporation. All rights reserved.

PS H:\&gt; c:

PS C:\&gt; cd C:\Tools\Scripts\golfing

PS C:\Tools\Scripts\golfing&gt; .\wait-a-minute.ps1
63.232359
67.8403415

PS C:\Tools\Scripts\golfing&gt; .\wait-a-minute.ps1
61.0809705
8.8991164

PS C:\Tools\Scripts\golfing&gt; .\wait-a-minute.ps1
62.5791712
67.3228933

PS C:\Tools\Scripts\golfing&gt; .\wait-a-minute.ps1
61.1303589
8.5939405

PS C:\Tools\Scripts\golfing&gt; .\wait-a-minute.ps1
61.3210352
8.6386886

PS C:\Tools\Scripts\golfing&gt;
</code></pre>
</div>
<div id="pu39" class="pu"><h1>Rust, <strike>257</strike>, 247 bytes</h1>
<p>I use the same times as Mego's Python answer.</p>
<p>Really the only slightly clever bit is using i-i to get a Duration of 0 seconds.</p>
<pre><code>fn main(){let n=std::time::Instant::now;let i=n();let h:Vec&lt;_&gt;=(0..8).map(|_|std::thread::spawn(move||{let i=n();std::thread::sleep_ms(9000);i.elapsed()})).collect();let mut t=i-i;for x in h{t+=x.join().unwrap();}print!(&quot;{:?}{:?}&quot;,t,i.elapsed());}
</code></pre>
<p>Prints:</p>
<pre><code>Duration { secs: 71, nanos: 995877193 }Duration { secs: 9, nanos: 774491 }
</code></pre>
<p>Ungolfed:</p>
<pre><code>fn main(){
    let n = std::time::Instant::now;
    let i = n();
    let h :Vec&lt;_&gt; =
        (0..8).map(|_|
            std::thread::spawn(
                move||{
                    let i = n();
                    std::thread::sleep_ms(9000);
                    i.elapsed()
                }
            )
        ).collect();
    let mut t=i-i;
    for x in h{
        t+=x.join().unwrap();
    }
    print!(&quot;{:?}{:?}&quot;,t,i.elapsed());
}
</code></pre>
<p>Edit:
good old for loop is a bit shorter</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/83039/">83039</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




