<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::278179</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>039</td><td>05AB1E</td><td>250210T091045Z</td><td><a href="https://codegolf.stackexchange.com/questions/278179/max-island-area/278182#278182">Kevin Cr</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 39 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>˜ƶsgäΔ4F¬ašøí}2Fø€ü3}*εεÅsyøÅs«à]˜0KD¢à
</code></pre>
<p>Basic flood-fill algorithm I've used in a bunch of other challenges.</p>
<p><a href="https://tio.run/##yy9OTMpM/f//9Jxj24rTDy85N8XE7dCaxKMLD@84vLbWyO3wjkdNaw7vMa7VOrf13NbDrcWVQInW4kOrDy@IPT3HwNvl0KLDC/7/j4420AHDWB0gyxAI0VkQ2VgA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/V@mFFCUWlJSqVtQlJlXkpqikJlXUFpipaCkU@l1aLcOl5JjcklpYg5c2L4SKOZfWgLjuRxaqfT/9Jxj24rTDy85N8XE7dCaxKMLD@84vLbWyO3wjkdNaw7vMa49tE7r3NZzWw@3FlcCpVqLD60@vCD29BwDb5dDiw4v@K@kF6ZzaJv9/@joaAMdMIzVAbIMgRCdBZGN1VEgpBRMw5VCKENUrYY4tWLYYkiULWhKDXErNcTwEkIBQntsLAA" rel="nofollow noreferrer">verify all test cases</a>.</p>
<p><strong>Explanation:</strong></p>
<p>Step 1: Convert all <code>1</code>s to unique numbers:</p>
<pre><code>˜         # Flatten the (implicit) input-matrix
 ƶ        # Multiply each value by its 1-based index
  s       # Swap to get the (implicit) input-matrix again
   g      # Pop and push its length (the amount of rows)
    ä     # Split the list into that many equal-sized rows
</code></pre>
<p>Step 2a: Flood-fill this matrix based on the input-matrix:</p>
<pre><code>Δ         # Loop until the matrix no longer changes:
</code></pre>
<p>Step 2b: Add a border of <code>0</code>s to the matrix:</p>
<pre><code> 4F       #  Loop 4 times:
   ¬      #   Push the first row (without popping the matrix)
    a     #   Convert all values to 0 using an &quot;isLetter&quot; check
     š    #   Prepend that list of 0s to the matrix
      øí  #   Rotate the matrix once clockwise:
      ø   #    Zip/transpose; swapping rows/columns
       í  #    Reverse each inner row
  }       #  Close the loop
</code></pre>
<p>Step 2c: Convert the matrix into overlapping 3x3 blocks:</p>
<pre><code> 2F       #  Loop 2 times:
   ø      #   Zip/transpose; swapping rows/columns
    €     #   Map over each inner list:
     ü3   #    Convert it into overlapping triplets
  }       #  Close the loop
</code></pre>
<p>Step 2d: Transform some 3x3 blocks back to <code>0</code>s, based on the <code>0</code>s in the input-matrix</p>
<pre><code> *        #  Multiple the 3x3 blocks to the values at the same positions of the
          #  (implicit) input-matrix
</code></pre>
<p>Step 2e: For each 3x3 block, get the maximum of its center and its horizontal/vertical neighbors:</p>
<pre><code> εε       #  Nested map over each 3x3 block:
   Ås     #    Pop and leave the middle row
   y      #    Push the 3x3 block again
    ø     #    Zip/transpose; swapping rows/columns
     Ås   #    Pop and leave the middle row (aka the middle column of `y`) again
       «  #    Merge the two lists together
        à #    Pop and push the maximum
  ]       # Close the nested map, as well as the changes-loop
</code></pre>
<p>Step 3: Check which island is the largest, and output its size:</p>
<pre><code>˜         # Flatten the flood-filled matrix
 0K       # Remove all 0s
   D      # Duplicate the list of positive integers
    ¢     # Pop both, and get the count of each
     à    # Pop and leave the largest count,
          # which is the size of the largest island
          # (which is output implicitly as result)
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/278179/">278179</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




