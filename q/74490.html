<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::QNNN</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
  <!-- TXXX -->
<tr d-ix="0"><td>002</td><td>Japt x</td><td>170811T120818Z</td><td><a href="https://codegolf.stackexchange.com/questions/74490/determining-vertical-slices/138509#138509">Shaggy</a></td></tr>
<tr d-ix="1"><td>006</td><td>J</td><td>160302T013219Z</td><td><a href="https://codegolf.stackexchange.com/questions/74490/determining-vertical-slices/74583#74583">Ad&#225;</a></td></tr>
<tr d-ix="2"><td>043</td><td>JavaScript ES6</td><td>160301T010306Z</td><td><a href="https://codegolf.stackexchange.com/questions/74490/determining-vertical-slices/74505#74505">Neil</a></td></tr>
<tr d-ix="3"><td>022</td><td>Perl</td><td>160229T233315Z</td><td><a href="https://codegolf.stackexchange.com/questions/74490/determining-vertical-slices/74496#74496">Ton Hosp</a></td></tr>
<tr d-ix="4"><td>004</td><td>APL</td><td>160301T063051Z</td><td><a href="https://codegolf.stackexchange.com/questions/74490/determining-vertical-slices/74519#74519">Mama Fun</a></td></tr>
<tr d-ix="5"><td>005</td><td>Pyth</td><td>160301T140213Z</td><td><a href="https://codegolf.stackexchange.com/questions/74490/determining-vertical-slices/74526#74526">FryAmThe</a></td></tr>
<tr d-ix="6"><td>030</td><td>Python 2</td><td>160301T064444Z</td><td><a href="https://codegolf.stackexchange.com/questions/74490/determining-vertical-slices/74520#74520">Logic Kn</a></td></tr>
<tr d-ix="7"><td>079</td><td>ùîºùïäùïÑùïöùïü</td><td>160301T054501Z</td><td><a href="https://codegolf.stackexchange.com/questions/74490/determining-vertical-slices/74517#74517">Mama Fun</a></td></tr>
<tr d-ix="8"><td>007</td><td>CJam</td><td>160301T005253Z</td><td><a href="https://codegolf.stackexchange.com/questions/74490/determining-vertical-slices/74504#74504">Luis Men</a></td></tr>
<tr d-ix="9"><td>017</td><td>Bash + common utilities</td><td>160229T234223Z</td><td><a href="https://codegolf.stackexchange.com/questions/74490/determining-vertical-slices/74499#74499">Digital </a></td></tr>
<tr d-ix="10"><td>024</td><td>Mathematica</td><td>160229T234040Z</td><td><a href="https://codegolf.stackexchange.com/questions/74490/determining-vertical-slices/74498#74498">Tally</a></td></tr>
<tr d-ix="11"><td>002</td><td>Jelly</td><td>160229T230832Z</td><td><a href="https://codegolf.stackexchange.com/questions/74490/determining-vertical-slices/74493#74493">lynn</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/ETHproductions/japt" rel="nofollow noreferrer">Japt</a> <a href="https://codegolf.meta.stackexchange.com/a/14339/"><code>-x</code></a>, <s>6</s> <s>4</s> 2 <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" rel="nofollow noreferrer">bytes</a></h1>
<p>Takes input as an array of rows, with <code>1</code> being white and <code>0</code> being black.</p>
<pre><code>ye
</code></pre>
<ul>
<li>2 bytes saved thanks to <a href="https://codegolf.stackexchange.com/users/42545/ethproductions">ETH</a>.</li>
</ul>
<p><a href="https://petershaggynoble.github.io/Japt-Interpreter/?v=1.4.6&amp;flags=LXg&amp;code=eWU&amp;input=W1swLDAsMCwwLDEsMSwxLDEsMSwxLDEsMSwxLDEsMCwwLDAsMCwwXSxbMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDEsMSwxLDEsMSwwLDAsMF0sWzAsMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMSwwLDAsMCwwLDBdLFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwxLDAsMCwwLDAsMCwwXSxbMCwwLDAsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDAsMF0sWzAsMCwwLDAsMCwwLDEsMSwxLDEsMSwxLDAsMCwwLDAsMCwwLDBdLFswLDAsMCwwLDAsMCwwLDEsMSwxLDEsMSwxLDEsMSwwLDAsMCwwXSxbMCwwLDAsMCwxLDEsMSwxLDEsMSwxLDEsMSwxLDAsMCwwLDAsMF1d" rel="nofollow noreferrer">Try it</a></p>
<pre><code>ye     :Implicit input of 2D array
y      :Transpose and map each row
 e     :  All truthy (i.e., 1)
       :Implicit output of sum of resulting array
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="http://jsoftware.com/" rel="nofollow noreferrer">J</a>, <s>5</s> 6 bytes</h1>

<p>Takes Boolean matrix as argument.</p>

<pre><code>[:+/*/
</code></pre>

<p>This is my first J answer! (was wrong for 1¬Ω years‚Ä¶)</p>

<p><code>*/</code>‚ÄÉcolumnwise product</p>

<p><code>+/</code>‚ÄÉsum</p>

<p><code>[:</code>‚ÄÉcap (serves as placeholder since <code>+/</code> should not take a left argument)</p>

<p><a href="https://tio.run/##y/r/P83WKtpKW19L/39qcka@QoGtlbGCmYqBgiEYGgAhmIJxwSIQpiEXWEeaQsF/AA" rel="nofollow noreferrer" title="J ‚Äì Try It Online">Try it online!</a></p>
</div>
<div id="pu2" class="pu"><h2>JavaScript (ES6), <s>54</s> <s>45</s> 43 bytes</h2>

<pre><code>a=&gt;a[s=0].map((_,i)=&gt;s+=a.every(b=&gt;b[i]))|s
a=&gt;a[s=0].map((_,i)=&gt;s+=!a.some(b=&gt;b[i]))|s
</code></pre>

<p>Based on @Lynn's Jelly answer, though since golfed by using <code>every</code> or <code>some</code> instead of <code>reduce</code>. The first version encodes black = 0 while the second encodes black = 1.</p>

<p>Edit: Saved 2 further bytes thanks to @edc65.</p>
</div>
<div id="pu3" class="pu"><h1>Perl, <s>21</s> 22 bytes</h1>

<h2>Fixed version</h2>

<p>Includes +2 for <code>-lp</code> (<code>-l</code> can be omitted and would still be a valid solution, but it's ugly without the final newline)</p>

<p>Give sequences of 1's and 0's on 0 or more lines on STDIN.
You can add spaces or commas or whatever between the digits if you want as long as the usage is.consistent on all lines.</p>

<pre><code>$a|=~$_}{$_=$a=~y;\xce;
</code></pre>

<p>This works as shown, but replace <code>\xce</code> by the literal byte value to get the claimed score</p>

<p>If there are multiple vertical sections this returns the sum of all section widths. If you want the width of <strong>a</strong> vertical section use</p>

<pre><code>$a|=~$_}{$a=~/\xce+/;$_="@+"-"@-"
</code></pre>

<h2>Old version</h2>

<p>I originally misunderstood the challenge and implemented a program that gives true or false based on if a vertical line exists at all. Code and explanation here are for this old version</p>

<pre><code>$a|=~$_}{$_|=~$a=~1
</code></pre>

<p>If only I could add 1=~ at the left for almost perfect symmetry... I suppose the closest would be</p>

<pre><code>1=&gt;$a|=~$_}{$_|=~$a=~1
</code></pre>

<h2>Explanation</h2>

<pre><code>$a|=~$_     The bitwise operators in perl (&amp;, |, ^, ~) also work on strings by 
            working on the sequence of byte values. The digits "0" and "1" happen
            to have the same ASCII value differing only in the last bit which is
            0 for "0" and 1 for "1". So I would really like to do an "&amp;" here.
            Unfortunately "&amp;" of two different length strings shortens the result
            to the shortest of the strings and my accumulator starts as an empty 
            string. The "|" of two strings however extends to the longest string.
            So instead I will apply De Morgan's law and use "|" on the
            complemented byte string 
}{          Standard perl golf trick. "-p code" transforms to (simplified)
            "while (&lt;&gt;) { code; print }". So if code is "code1 } { code2" this
            becomes "while (&lt;&gt;) { code1 } {code2; print }". So you can use code1
            for the loop operation, use code2 for the final calculation and get a
            free print by assigning to $_
$_|=~$a=~1  I would like to match the accumulator with the bit complement of "1",
            but $a=~~1 doesn't work because the 1 is not a string but a number.
            $a=~~"1" would work but is too long. Next up is complementing $a back
            and matching with 1, so $_=~$a=~1. That also doesn't work since the
            first =~ will be interpreted as a string match insteads of equals
            followed by complement. Easily solved by writing it as $_= ~a=~1. But
            if I am going to give up a byte I can at least have some fun with it.
            Using $_|= also makes the parse work and has the advantage that the
            failure case will give 0 instead of an empty string, which looks
            nicer. It also makes the code look very symmetric. I can also bring
            out the symmetry more by putting 1=&gt; in front (which evaluates 1
            before the assignment and then immediately discards it)
</code></pre>
</div>
<div id="pu4" class="pu"><h1>APL, 4 bytes</h1>
<pre><code>+/√ó‚åø
</code></pre>
<p><kbd><a href="http://ngn.github.io/apl/web/index.html#code=%28+/%D7%u233F%298%2019%u23740%200%200%200%201%201%201%201%201%201%201%201%201%201%200%200%200%200%200%200%200%200%200%200%200%200%201%201%201%201%201%201%201%201%201%200%200%200%200%200%200%200%200%200%200%200%200%201%201%201%201%201%200%200%200%200%200%200%200%200%200%200%200%200%200%201%201%201%201%201%200%200%200%200%200%200%200%200%200%201%201%201%201%201%201%201%201%201%201%201%201%201%201%200%200%200%200%200%200%200%200%201%201%201%201%201%201%200%200%200%200%200%200%200%200%200%200%200%200%200%200%201%201%201%201%201%201%201%201%200%200%200%200%200%200%200%200%201%201%201%201%201%201%201%201%201%201%200%200%200%200%200" rel="nofollow noreferrer">Try it here.</a></kbd></p>
<p>This is my first APL answer!</p>
<p>Thanks to @jimmy23013 and @NBZ for saving bytes!</p>
</div>
<div id="pu5" class="pu"><h1>Pyth, 5</h1>

<pre><code>s*VFQ
</code></pre>

<p><a href="http://pyth.herokuapp.com/?code=s%2AVFQ&amp;input=%5B%5B0%2C%200%2C%200%2C%200%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%200%2C%200%2C%200%2C%200%2C%200%5D%2C%20%5B0%2C%200%2C%200%2C%200%2C%200%2C%200%2C%200%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%200%2C%200%2C%200%5D%2C%20%5B0%2C%200%2C%200%2C%200%2C%200%2C%200%2C%200%2C%200%2C%200%2C%201%2C%201%2C%201%2C%201%2C%201%2C%200%2C%200%2C%200%2C%200%2C%200%5D%2C%20%5B0%2C%200%2C%200%2C%200%2C%200%2C%200%2C%200%2C%200%2C%201%2C%201%2C%201%2C%201%2C%201%2C%200%2C%200%2C%200%2C%200%2C%200%2C%200%5D%2C%20%5B0%2C%200%2C%200%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%200%2C%200%5D%2C%20%5B0%2C%200%2C%200%2C%200%2C%200%2C%200%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%200%2C%200%2C%200%2C%200%2C%200%2C%200%2C%200%5D%2C%20%5B0%2C%200%2C%200%2C%200%2C%200%2C%200%2C%200%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%200%2C%200%2C%200%2C%200%5D%2C%20%5B0%2C%200%2C%200%2C%200%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%2C%200%2C%200%2C%200%2C%200%2C%200%5D%5D&amp;debug=0" rel="nofollow">Try it here</a></p>

<p>This uses Lynn's algorithm, but I decided to post it just to show how to golf vector operations in Pyth. The trick here is to chain the "sugar" syntax helpers <code>V</code> and <code>F</code> so that the fold is applied as a vector operation. The operator that is folded is of course multiplication, and then the result is summed to get the final answer.</p>
</div>
<div id="pu6" class="pu"><h1>Python 2, 30 bytes</h1>

<p>There is a surprisingly elegant solution using many of my favourite built-in functions chained together.</p>

<pre><code>lambda c:sum(map(all,zip(*c)))
</code></pre>

<p>Using the test image from @Lynn:</p>

<pre><code>&gt;&gt;&gt; image = [[0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]]
&gt;&gt;&gt; func = lambda c:sum(map(all,zip(*c)))
&gt;&gt;&gt; func(image)
3
</code></pre>
</div>
<div id="pu7" class="pu"><h1>ùîºùïäùïÑùïöùïü, 7 chars / 9 bytes</h1>
<pre><code>‚®≠–ú∆ü√Ø‚ìú‚®¥$
</code></pre>
<p><kbd><a href="http://molarmanful.github.io/ESMin/interpreter3.html?eval=true&amp;input=%5B%5B0%2C0%2C0%2C0%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C0%2C0%2C0%2C0%2C0%5D%2C%5B0%2C0%2C0%2C0%2C0%2C0%2C0%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C0%2C0%2C0%5D%2C%5B0%2C0%2C0%2C0%2C0%2C0%2C0%2C0%2C0%2C1%2C1%2C1%2C1%2C1%2C0%2C0%2C0%2C0%2C0%5D%2C%5B0%2C0%2C0%2C0%2C0%2C0%2C0%2C0%2C1%2C1%2C1%2C1%2C1%2C0%2C0%2C0%2C0%2C0%2C0%5D%2C%5B0%2C0%2C0%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C0%2C0%5D%2C%5B0%2C0%2C0%2C0%2C0%2C0%2C1%2C1%2C1%2C1%2C1%2C1%2C0%2C0%2C0%2C0%2C0%2C0%2C0%5D%2C%5B0%2C0%2C0%2C0%2C0%2C0%2C0%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C0%2C0%2C0%2C0%5D%2C%5B0%2C0%2C0%2C0%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C0%2C0%2C0%2C0%2C0%5D%5D&amp;code=%E2%A8%AD%D0%9C%C6%9F%C3%AF%E2%93%9C%E2%A8%B4%24" rel="nofollow noreferrer">Try it here (Firefox only).</a></kbd></p>
<p>This is @Lynn's great algorithm, but I found it independently. (I thought there was a builtin for this somewhere, still looking :P)</p>
<h1>Explanation</h1>
<p><code>–ú∆ü√Ø</code> transposes the input array, <code>‚ìú‚®¥$</code> turns each inner vector into its product, and <code>‚®≠</code> sums the resulting array.</p>
</div>
<div id="pu8" class="pu"><h1>CJam, 7 bytes</h1>

<pre><code>q~:.*:+
</code></pre>

<p><a href="http://cjam.tryitonline.net/#code=cX46Lio6Kw&amp;input=W1swIDAgMCAwIDEgMSAxIDEgMSAxIDEgMSAxIDEgMCAwIDAgMCAwXSBbMCAwIDAgMCAwIDAgMCAxIDEgMSAxIDEgMSAxIDEgMSAwIDAgMF0gWzAgMCAwIDAgMCAwIDAgMCAwIDEgMSAxIDEgMSAwIDAgMCAwIDBdIFswIDAgMCAwIDAgMCAwIDAgMSAxIDEgMSAxIDAgMCAwIDAgMCAwXSBbMCAwIDAgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDAgMF0gWzAgMCAwIDAgMCAwIDEgMSAxIDEgMSAxIDAgMCAwIDAgMCAwIDBdIFswIDAgMCAwIDAgMCAwIDEgMSAxIDEgMSAxIDEgMSAwIDAgMCAwXSBbMCAwIDAgMCAxIDEgMSAxIDEgMSAxIDEgMSAxIDAgMCAwIDAgMF1d" rel="nofollow"><strong>Try it online!</strong></a></p>

<pre><code>q~      e# read input and evaluate: push nested array
:.*     e# fold vectorized product over nested array: element-wise product of rows
:+      e# fold addition over array: compute its sum
</code></pre>
</div>
<div id="pu9" class="pu"><h1>Bash + common utilities, 17</h1>

<pre class="lang-bash prettyprint-override"><code>rs -Tc|grep -vc 0
</code></pre>
<p>If you're not using <code>grep</code> for <a href="/questions/tagged/image-processing" class="post-tag" title="show questions tagged &#39;image-processing&#39;" rel="tag">image-processing</a>, then you're doing it wrong ;-).</p>
<p>This uses the <code>rs</code> utility to do transposition.  <code>rs</code> is <a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/rs.1.html" rel="noreferrer">bundled in OSX</a>, but will need installing in most linux with something like <code>sudo apt-get install rs</code>.</p>
<p>Input columns are <kbd>TAB</kbd> separated, and rows are newline separated:</p>
<pre class="lang-bash prettyprint-override"><code>0   0   0   0   1   1   1   1   1   1   1   1   1   1   0   0   0   0   0   
0   0   0   0   0   0   0   1   1   1   1   1   1   1   1   1   0   0   0   
0   0   0   0   0   0   0   0   0   1   1   1   1   1   0   0   0   0   0   
0   0   0   0   0   0   0   0   1   1   1   1   1   0   0   0   0   0   0   
0   0   0   1   1   1   1   1   1   1   1   1   1   1   1   1   1   0   0   
0   0   0   0   0   0   1   1   1   1   1   1   0   0   0   0   0   0   0   
0   0   0   0   0   0   0   1   1   1   1   1   1   1   1   0   0   0   0   
0   0   0   0   1   1   1   1   1   1   1   1   1   1   0   0   0   0   0
</code></pre>
<p>If you like, you can preprocess the example input images into this format with imagemagick and (GNU) sed.  E.g:</p>
<pre class="lang-bash prettyprint-override"><code>$ for img in &quot;AmXiR.jpg&quot; &quot;vb2Yt.jpg&quot; &quot;1V7QD.jpg&quot; &quot;MqcDJ.jpg&quot; ; do
&gt;     convert -depth 1 &quot;$img&quot; xpm:- | \
&gt;     sed -nr '/pixels/{:l;n;/}/q;s/^&quot;(.*)&quot;,?$/\1/;y/ ./01/;s/./&amp;\t/g;p;bl}' | \
&gt;     rs -Tc|grep -vc 0
&gt; done
50
57
0
0
$
</code></pre>
</div>
<div id="pu10" class="pu"><h2>Mathematica 24</h2>
<pre><code>Length@Cases[Total@#,0]&amp;
</code></pre>
<p>Takes an array in the following form:</p>
<pre><code>{{1, 0, 0, 0, 1, 0},
{1, 0, 0, 1, 1, 1},
{1, 1, 0, 0, 0, 0},
{1, 1, 0, 0, 1, 1},
{1, 0, 0, 1, 1, 1}}
</code></pre>
<p>And in this case outputs:</p>
<pre><code>1
</code></pre>
</div>
<div id="pu11" class="pu"><h1>Jelly, 2 bytes</h1>

<pre><code>PS
</code></pre>

<p><a href="http://jelly.tryitonline.net/#code=UFM&amp;input=&amp;args=W1swLDAsMCwwLDEsMSwxLDEsMSwxLDEsMSwxLDEsMCwwLDAsMCwwXSxbMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDEsMSwxLDEsMSwwLDAsMF0sWzAsMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMSwwLDAsMCwwLDBdLFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwxLDAsMCwwLDAsMCwwXSxbMCwwLDAsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDAsMF0sWzAsMCwwLDAsMCwwLDEsMSwxLDEsMSwxLDAsMCwwLDAsMCwwLDBdLFswLDAsMCwwLDAsMCwwLDEsMSwxLDEsMSwxLDEsMSwwLDAsMCwwXSxbMCwwLDAsMCwxLDEsMSwxLDEsMSwxLDEsMSwxLDAsMCwwLDAsMF1d">Try it here!</a></p>

<p>If I encode an image like so:</p>

<pre><code>0000111111111100000
0000000111111111000
0000000001111100000
0000000011111000000
0001111111111111100
0000001111110000000
0000000111111110000
0000111111111100000
</code></pre>

<p>Into a nested array like this:</p>

<pre><code>[[0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0],...]
</code></pre>

<p>Then <code>P</code> takes the element-wise product of all of the row vectors, and <code>S</code> sums all of the ones in the result, yielding the length of the vertical slice. (This works only because there‚Äôs guaranteed to be only one contiguous slice.) In our case, the answer is <code>3</code>.</p>
</div>
