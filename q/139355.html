<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::139355</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>622</td><td>0</td><td>240412T003439Z</td><td><a href="https://codegolf.stackexchange.com/questions/139355/golf-a-number-bigger-than-tree3/272510#272510">Polymati</a></td></tr>
<tr d-ix="1"><td>511</td><td>Javascript</td><td>211120T131155Z</td><td><a href="https://codegolf.stackexchange.com/questions/139355/golf-a-number-bigger-than-tree3/237492#237492">Binary19</a></td></tr>
<tr d-ix="2"><td>212</td><td>Python</td><td>210727T070240Z</td><td><a href="https://codegolf.stackexchange.com/questions/139355/golf-a-number-bigger-than-tree3/231887#231887">Eryx Jay</a></td></tr>
<tr d-ix="3"><td>190</td><td>JavaScript</td><td>190426T182244Z</td><td><a href="https://codegolf.stackexchange.com/questions/139355/golf-a-number-bigger-than-tree3/184837#184837">Naruyoko</a></td></tr>
<tr d-ix="4"><td>111</td><td>Javascript</td><td>210221T181951Z</td><td><a href="https://codegolf.stackexchange.com/questions/139355/golf-a-number-bigger-than-tree3/219466#219466">Patcail</a></td></tr>
<tr d-ix="5"><td>031</td><td>Haskell</td><td>171027T235625Z</td><td><a href="https://codegolf.stackexchange.com/questions/139355/golf-a-number-bigger-than-tree3/146532#146532">Christop</a></td></tr>
<tr d-ix="6"><td>135</td><td>New Ruby</td><td>171020T201838Z</td><td><a href="https://codegolf.stackexchange.com/questions/139355/golf-a-number-bigger-than-tree3/145882#145882">Simply B</a></td></tr>
<tr d-ix="7"><td>569</td><td>Julia</td><td>171110T020656Z</td><td><a href="https://codegolf.stackexchange.com/questions/139355/golf-a-number-bigger-than-tree3/147631#147631">eaglgene</a></td></tr>
<tr d-ix="8"><td>140</td><td>Ruby</td><td>171101T185423Z</td><td><a href="https://codegolf.stackexchange.com/questions/139355/golf-a-number-bigger-than-tree3/146869#146869">Deedlit</a></td></tr>
<tr d-ix="9"><td>194</td><td>Python 2</td><td>171025T111027Z</td><td><a href="https://codegolf.stackexchange.com/questions/139355/golf-a-number-bigger-than-tree3/146279#146279">Deedlit</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>(0,0,0)(1,1,1)(2,2,1)(3,0,0)[1000] (SDO <span class="math-container">\$\psi(C(1\{\omega\}0))\$</span>), 622 bytes</h1>
<p>This is my first time on Stack Exchange, but I saw this post some time ago and I finally managed to make this. It implements the Subspecies Pair Sequence System (basically PSS but the second entry works like LPrSS) and outputs (0,0)(1,1000)[1000].</p>

<pre class="lang-javascript prettyprint-override"><code>function spss(t,l){if(t.length){if(t[t.length-1][0]){if(t[t.length-1][1]){var e=t.lastIndexOf(t.filter((e,l)=&gt;e[0]&lt;t[t.length-1][0]&amp;&amp;e[1]&lt;t[t.length-1][1]&amp;&amp;!t.slice(l+1,t.length).filter(l=&gt;l[0]&lt;=e[0]).length).pop()),s=t.slice(0,e),n=t.slice(e,-1),r=t[t.length-1][0]-t[e][0],i=t[t.length-1][1]-t[e][1]-1;return spss([...s,...Array(l).fill(n).map((l,e)=&gt;l.map(l=&gt;[l[0]+r*e,l[1]+i*e])).flat()],l)}var e=t.lastIndexOf(t.filter(l=&gt;l[0]===t[t.length-1][0]-1).pop()),s=t.slice(0,e),n=t.slice(e,-1);return spss([...s,...Array(l).fill(n).flat()],l)}return spss(t.slice(0,-1),l+1)}return l} console.log(spss([[0,0],[1,1000]],1000));
</code></pre>
<p><a href="https://tio.run/##jZHBboMwDIZfhV1QUkJEzm0q7bjTHiDiEFHTZXIDStJq09RnZ6YtrGLT1AuWHfnLl593e7KxCa5Ppe92MAzt0TfJdT6LfYwsCeRfrmVJIvh9ers2ZmpLVZuq/mOoaHiyIQNNUxvTi9/Bx@vIaR0mCIwBkfUWaH2z5OU5EGCzJOb5U5IRXQMMCyVmpQmJeosjTo9QPp/2Xc84F1FPy5UALvzcgigVF0EvLcpkYKzC6aXJ9YiqWgdIx3ALy0gpo6DPcwj2k@HFDJnn8mB7xpDuJcVLQ65mlC3CioIgVOFWUHPaQJsYrymc87/53R6r9W9v9eCbH3S/M7pf@CGP8dEPmY/xnDWdjx2CxG7PrnhTCYrSKKGqqqrrS@F8PQzf" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<p>I definitely lost with the character amount part, but it surpasses all other entries (except the one person who used Loader's program).</p>
</div>
<div id="pu1" class="pu"><h1>Javascript, 511 bytes</h1>
<p>I am new to code golf (this is my second time), but certainly not to implementing or inventing large numbers. However this programs takes quite a lot of code to beat TREE(3) :( The program results in <span class="math-container">\$f_{TFBO+1}(3) = f_{TFBO}(f_{TFBO}(f_{TFBO}(3)))\$</span> in the fast-growing hierarchy, where <span class="math-container">\${TFBO}\$</span> is the Takeuti-Feferman-Buchholz Ordinal <span class="math-container">\$\psi(\Omega_{\omega+1})\$</span>. It uses Buchholz hydras and implements the BH function. Here is my compressed code, which was done with Naruyoko's Javascript compressor:</p>
<pre><code>_=&quot;69{%t.length-1D*6m#{%B]}*6s#{t.splice(m#,14*@n=1;*6e#{7==0/s#;if(9&gt;1/$i=0;i&lt;n;i:t'B-1]4}}7&gt;0&amp;&amp;typeof t==\&quot;number\&quot;/$i=98t[i]&lt;m#8i--/}@s;$j5i8j &lt;= 98j:s't[j]4@?5s;?[j]=?[i]-1;?[l(?)]=0;s#;$k508k &lt;= l(?)8k:t'?[k]4}7==A/B]=n+1Dn += 1;%tD*6b(k/i5[\&quot;+\&quot;,0];$l508l &lt; k-28l:i'A)}while(l(i)&gt;=0/i=e(i4%nD*Console.log(b(b(b(3))));#(t)$for(let %return '.push(*\n    /){4)D5 = 6function 7if(m#8; 9l#:++/?sa@var A\&quot;w\&quot;Bt[9D;}&quot;;for($ of&quot;DBA@?:987654/*'%$#&quot;)with(_.split($))_=join(pop());eval(_)
</code></pre>
<p>This is basically incomprehensible, with only fragments of the original code revealing themselves, so here is the original code (still somewhat golfed):</p>
<pre><code>function l(t){return t.length-1;}
function m(t){return t[l(t)]}
function s(t){t.splice(m(t),1);}
var n=1;
function e(t){if(m(t)==0){s(t);if(l(t)&gt;1){for(let i=0;i&lt;n;i++){t.push(t[l(t)-1]);}}}if(m(t)&gt;0&amp;&amp;typeof t==&quot;number&quot;){for(let i=l(t); t[i]&lt;m(t); i--){}var s;for(let j = i; j &lt;= l(t); j++){s.push(t[j]);}var sa = s;sa[j]=sa[i]-1;sa[l(sa)]=0;s(t);for(let k = 0; k &lt;= l(sa); k++){t.push(sa[k]);}}if(m(t)==&quot;w&quot;){t[l(t)]=n+1;}n += 1;return t;}
function b(k){i = [&quot;+&quot;,0];for(let l = 0; l &lt; k-2; l++){i.push(&quot;w&quot;)}while(l(i)&gt;=0){i=e(i);}return n;}
Console.log(b(b(b(3))));
</code></pre>
<h1>Explanation</h1>
<p>This program, as I mentioned earlier implements Buchholz hydras, which are stored as arrays. This is what the code does:</p>
<p>It defines shorthands l(t), the index of the last element of the array, m(t), the last element of the array, and s(t), which chops off the last element of the array (the rightmost head). I also define a counter n which keeps track of how many times the hydra has been expanded.</p>
<p>The biggest block of code is e(t), which expands the hydra. Here is how it works: it checks if the rightmost head (which it will chop off) has label zero. If it does, then it calls s(t), splicing the last item in the array, and checks if l(t)&gt;1, i.e. the rightmost head's parent is not the root. If it is, then it uses a for loop to push n copies of the rightmost head's parent (which is not the root).</p>
<p>Next, if it is not zero, it checks if it is a positive integer. If it is, it uses a for loop to find i such that t[i] has a lower label than the rightmost head. Then it creates a tree s such that everything after (and including) t[i] is in s, i.e. the subtree rooted at t[i]. It also creates sa where the rightmost head is relabeled with sa[i]-1 and the rightmost head of sa is relabeled with 0. It then deletes t's rightmost head and uses a for loop to insert sa into t.</p>
<p>If it is not zero, then it can only be the least limit ordinal omega (represented by the string &quot;w&quot;). If it is, it simply relabels it with n+1. After everything, it increments n by 1 and returns the new version of t.</p>
<p>Next, we have the function b(n), which represents the function BH(n). It sets i to the tree [+,0] and then pushes n-2 copies of omega &quot;w&quot;. It then repeatedly applies e to i (expands i) and returns the final output. My large number is then b(b(b(n)))</p>
<h1>Size</h1>
<p>Why does this produce a large enough number? Well, the original inventor, Wilfried Buchholz, proved that this function eventually dominates (overtakes) any function which is provably total in <span class="math-container">\$\Pi^1_1\$</span>-comprehension with bar induction (<span class="math-container">\$\Pi^1_1-CA+BI\$</span>), so the <span class="math-container">\$BH(n)\$</span> function is commonly approximated to <span class="math-container">\$\psi_0(\varepsilon_{\Omega_\omega +1})\$</span> using the fast-growing hierarchy, so my number is approximately <span class="math-container">\$f_{ψ(\varepsilon_{\Omega_\omega+1})+1}(3)\$</span>.</p>
<p>The goal is <span class="math-container">\$\psi_0(\Omega^{\Omega^\omega \omega})\$</span>, which is much less than <span class="math-container">\$\psi_0(\varepsilon_{\Omega+1})\$</span>, let alone <span class="math-container">\$\psi_0(\varepsilon_{\Omega_\omega+1})+1\$</span>. In fact, not only does this number defeat TREE(3), it also defeats SCG(13), which is around <span class="math-container">\$\psi_0(\Omega_\omega)\$</span>, although it still falls massively short of Loader's number.</p>
<p>In terms of size, my entry would come second place, while in terms of length, it would come second-to-last. The latter is what matters more, so this is probably a really bad entry.</p>
</div>
<div id="pu2" class="pu"><h1>Python, <strike>359 (184 without whitespace) 224</strike> 212 bytes, ~<span class="math-container">$$H_{ψ(ψ_Ι(0))[7]}(8)$$</span></h1>
<pre class="lang-python prettyprint-override"><code>*S,n=0,2,9
while S:
 i=r=d=0
 for a in S[::-1]:
  i-=1
  if d&lt;S[-1]-a:
   r=r or i;d+=S[-1]-a-d&gt;1
   if[k+d for k in S[i:]]&lt;S[r:]:break
   p=i+1
 S.pop();n*=n
 if r:S=S[:p]+[d*i+k for i in range(n)for k in S[p:]]
</code></pre>
<p>I'm new to codegolf so I'm not sure if all the whitespace here counts. If not, this entry isn't the shortest entry, but vastly dominates patcail's entry in size.
The code here implements <a href="https://googology.wikia.org/wiki/User_blog:Antimony_Star/Full_analysis_of_SSS,_with_respect_to_weak_buchholz" rel="nofollow noreferrer">Sudden Sequence System</a> (definition <a href="https://googology.wikia.org/wiki/User_blog:Antimony_Star/Non-formal_explanation_of_how_Hyper_Sequence_and_Sudden_Sequence_System_works" rel="nofollow noreferrer">here</a>), which is known to have a perfect correspondence to ordinals below <span class="math-container">$$\psi(\psi_I(0))$$</span> represented in Extended Weak Buchholz function. The original idea uses sequences lexicographically less than (0,2) to represent ordinals, but to save characters the sequence itself is reversed.
There are actually a few open problems here that we don't know the answer to, but strongly suspect they are true:</p>
<ol>
<li>Does the limit of Extended Weak Buchholz function equal to limit of Extended Buchholz function?</li>
<li>Is Sudden Sequence System terminating?</li>
<li>Does the correspondence between the two systems hold?</li>
</ol>
<p>Edit 1:
It's broken due to a silly mistake. Now S is correctly initialized.
Thanks to Naruyoko for a few great optimizations.</p>
<p>Edit 2: Optimized a bit</p>
</div>
<div id="pu3" class="pu"><h1 id="javascript-190-bytes-h19based-off-of-this-analysis-x422">JavaScript, 190 bytes, H<sub>ψ(ε<sub>Ω+1</sub>)</sub>(9)<sub>Based off of <a href="https://googology.wikia.org/wiki/Pair_sequence_number#Corresponding_ordinals" rel="nofollow noreferrer">this analysis</a></sub></h1>
<pre><code>A=[0,1,2];B=[0,1,2];for(F=C=9;F;F--){for(C++,G=0;G&lt;=F;G++)(A[F]||A[F-G]&lt;A[F]-H)&amp;&amp;(B[F]?(I=G,G=F):(H=A[F]-A[F-G],B[F-G]&lt;B[F]&amp;&amp;(I=G,G=F)));for(J=0;J&lt;C*I;J++)A[F]=A[F-I]+H,B[F]=B[F-I],F++;H=0}C
</code></pre>
<p>This program is a modified version of <a href="https://googologyforeveryone.fandom.com/wiki/User_blog_comment:C7X/Values_of_%5C(C(1,b)%5C)_for_small_b/@comment-32994025-20190313122812/@comment-32994025-20190316001206" rel="nofollow noreferrer">this 225B Pair-sequence number translation in JavaScript</a>. For Pair-sequence number and their original code, see <a href="https://googology.wikia.org/wiki/Pair_sequence_number" rel="nofollow noreferrer">here</a>.</p>
<p>The modifications done:</p>
<ul>
<li>It is in JavaScript instead of BASIC.</li>
<li>No iteration(f<sub>ψ(Ω<sub>ω</sub>+1)</sub>-&gt;f<sub>ψ(Ω<sub>ω</sub>)</sub>)</li>
<li>The sequence is (0,0)(1,1)(2,2), which corresponds to ordinal ψ(ε<sub>Ω+1</sub>).<sub>This is in Hardy-hierarchy ordinal</sub></li>
</ul>
</div>
<div id="pu4" class="pu"><h1>Javascript, 111 bytes, ~ <span class="math-container">\$f_{\psi(\Omega_\omega)}(6)\$</span></h1>
<p><span class="math-container">\$f\$</span> is the Fast-growing Hierarchy. <span class="math-container">\$ψ\$</span> is Buchholz's Psi. This entry, despite being 111 bytes, dominates all of the previous entries in both size and the amount of bytes (except for Loader's number).</p>
<p>Here is the code:</p>
<pre><code>s=JSON.stringify;P=([y,z])=&gt;y?JSON.parse((k=s([P(y),z])).replaceAll(s(z),k)):z;for(a=b=0;a=b++&lt;9?[a,0]:P(a););b
</code></pre>
<p>Here is the same code expanded out:</p>
<pre><code>function P([y,z]) {
  if (y==0) {
    return z
  } else {
    k = JSON.stringify([P(y),z])
    return JSON.parse(k.replaceAll(JSON.stringify(z),k))
  }
}

for(a=b=0;a=b++&lt;9?[a,0]:P(a););
b;
</code></pre>
<p>I'm going to explain both the <code>P</code> function and the for loop.</p>
<h2>The Predecessor Function</h2>
<p>The inputs of the predecessor function are binary trees with zeroes as leaf nodes. Here are some examples of binary trees:</p>
<ul>
<li><code>0</code></li>
<li><code>[0,0]</code></li>
<li><code>[[0,[0,0]],[0,0]]</code></li>
<li><code>[[[[[0,0],0],[0,0]],[0,0]],[[0,[0,0]],[0,[0,0]]]]</code></li>
<li><code>[[[[[[[[[[0,0],0],0],0],0],0],0],0],0],0]</code></li>
</ul>
<p>The Predecessor function is defined like this:</p>
<ul>
<li><code>P([0,z])=z</code></li>
<li><code>P([x,y])=[P(x),y]</code> but with all instances of <code>y</code> replaced with <code>[P(x),y]</code></li>
<li><code>P(0)</code> is left undefined</li>
</ul>
<p>Right away, we can see <code>0</code> represents the number <span class="math-container">\$0\$</span>, and <code>[0,z]</code> represents the structure <span class="math-container">\$z+1\$</span>.
Natural numbers can be represented as <code>[0,[0,[0,...[0,0]...]]]</code> with <span class="math-container">\$n+1\$</span> zeroes. For example, <span class="math-container">\$1 =\$</span> <code>[0,0]</code>, <span class="math-container">\$2 =\$</span> <code>[0,[0,0]]</code>, <span class="math-container">\$3 =\$</span> <code>[0,[0,[0,0]]]</code>, and so on.</p>
<p>Now consider the string <code>[1,n]</code> where <span class="math-container">\$n&gt;1\$</span>.</p>
<p><code>P([1,n])=[0,n]</code> but replace all instances of <span class="math-container">\$n\$</span> with <code>[0,n]</code> <span class="math-container">\$\to\$</span> <code>[0,[0,n]]</code></p>
<p>Therefore, <code>[1,n]</code> corresponds to <span class="math-container">\$n+3\$</span>, as <code>P(P(P([1,n]))) = n</code></p>
<p>By this logic, <code>[2,n]</code> corresponds to <span class="math-container">\$n+7\$</span>, <code>[3,n]</code> corresponds to <span class="math-container">\$n+15\$</span>, and <code>[n,n]</code> would approximately correspond to <span class="math-container">\$2^n\$</span>. Maybe <code>[[0,n],n]</code> corresponds to <span class="math-container">\$2^{n+1}\$</span>?</p>
<h3>Not so fast!</h3>
<p>Consider the string <code>[[0,n],n]</code>. One would expect this to correspond to <span class="math-container">\$2^{n+1}\$</span>, but it is much stronger. <code>P([[0,n],n])</code> <span class="math-container">\$\to\$</span> <code>[P([0,n]),n] = [n,n]</code>, but then the second step would be to replace all instances of <code>n</code> with the entire tree, or <code>[n,n]</code>. This makes <code>P([[0,n],n])=[[n,n],[n,n]]</code> rather than <code>[n,[n,n]]</code>.</p>
<p>One would ask whether this would cause an infinite loop. Let's try <code>P([[n,n],[n,n]])</code>. If we let <code>J = P([n,n])</code>, we will get:</p>
<p><code>P([[n,n],[n,n]])=[J,[n,n]]</code> but with all instances of <code>[n,n]</code> replaced with <code>[J,[n,n]]</code></p>
<p>However, there are no instances of <code>[n,n]</code> within <code>J</code>, because <code>J</code> is strictly less than <code>[n,n]</code>. Therefore, <code>P([[n,n],[n,n]])=[J,[J,[n,n]]]</code>. This works for all <code>J</code> less than <code>[n,n]</code>.</p>
<p>So this means <code>[[0,n],n]</code> corresponds to <span class="math-container">\$2^{2^n}\$</span>. <code>[[0,[0,n]],n]</code> corresponds to <span class="math-container">\$2^{2^{2^{2^n}}}\$</span>. And finally, <code>[[n,n],n]</code> corresponds to <span class="math-container">\$n \uparrow\uparrow n\$</span>. Now it is time to bring in the Middle Growing Hierarchy.</p>
<h2>Middle Growing Hierarchy</h2>
<p>The Middle Growing Hierarchy is defined here: <a href="https://googology.wikia.org/wiki/Middle-growing_hierarchy" rel="noreferrer">https://googology.wikia.org/wiki/Middle-growing_hierarchy</a></p>
<p>One can make an approximate distinction with the Middle Growing Hierarchy.</p>
<ul>
<li><code>[0,n]</code> corresponds to <span class="math-container">\$m(0,n) \sim n+1\$</span></li>
<li><code>[1,n]</code> corresponds to <span class="math-container">\$m(2,n) \sim n+3\$</span></li>
<li><code>[2,n]</code> corresponds to <span class="math-container">\$m(3,n) \sim n+7\$</span></li>
<li><code>[n,n]</code> corresponds to <span class="math-container">\$m(n,n) \sim n+2^n\$</span> and <span class="math-container">\$m(ω,n)\$</span></li>
<li><code>[n,[n,n]]</code> corresponds to <span class="math-container">\$m(n+1,n) \sim 2^{n+1}\$</span> (not <span class="math-container">\$m(ω+1,n)\$</span>)</li>
<li><code>[[0,n],n]</code> corresponds to <span class="math-container">\$m(ω+1,n) \sim 2^{2^n}\$</span></li>
<li><code>[[0,[0,n]],n]</code> corresponds to <span class="math-container">\$m(ω+2,n) \sim 2^{2^{2^{2^n}}}\$</span></li>
<li><code>[[1,n],n]</code> corresponds to <span class="math-container">\$m(ω+3,n) \sim 2^{2^{2^{2^{2^{2^{2^{2^n}}}}}}}\$</span></li>
<li><code>[[n,n],n]</code> corresponds to <span class="math-container">\$m(ω2,n) \sim n \uparrow\uparrow n\$</span></li>
</ul>
<p>One can see a correspondence with the left-hand side of the binary tree and the inner subscript of the Middle Growing Hierarchy. Let's continue the correspondence. I will omit the right hand side of the binary tree and the base of the Middle Growing Hierarchy.</p>
<ul>
<li><code>[n,n]</code> corresponds to <span class="math-container">\$ω_2\$</span></li>
<li><code>[0,[n,n]]</code> corresponds to <span class="math-container">\$ω_2+1\$</span></li>
<li><code>[n,[n,n]]</code> corresponds to <span class="math-container">\$ω_3\$</span></li>
<li><code>[[0,n],[n,n]]</code> corresponds to <span class="math-container">\$ω_4\$</span></li>
<li><code>[[1,n],[n,n]]</code> corresponds to <span class="math-container">\$ω_6\$</span></li>
<li><code>[[0,n],n]</code> corresponds to <span class="math-container">\$ω^2\$</span></li>
</ul>
<p>So it seems like there is a jump from <code>[[n,n],n]</code> to <code>[[[0,n],n],n]</code>, similar to the jump from <code>[n,n]</code> to <code>[[0,n],n]</code>. But even this doesn't capture the power of this notation.</p>
<h2>More Ordinal Comparison</h2>
<ul>
<li><code>[n,[[0,n],n]]</code> corresponds to <span class="math-container">\$ω^2+ω\$</span></li>
<li><code>[[n,n],[[0,n],n]]</code> corresponds to <span class="math-container">\$2\timesω^2\$</span></li>
<li><code>[[n,[n,n]],[[0,n],n]]</code> corresponds to <span class="math-container">\$ω^3\$</span></li>
<li><code>[[[0,n],[n,n]],[[0,n],n]]</code> corresponds to <span class="math-container">\$ω^4\$</span></li>
<li><code>[[[0,n],n],[[0,n],n]]</code> corresponds to <span class="math-container">\$ω^ω\$</span></li>
</ul>
<p>We're not even at <code>[[0,[0,n]],n]</code> yet, what is going on?</p>
<ul>
<li><code>[[[0,n],n],[[[0,n],n],[[0,n],n]]]</code> corresponds to <span class="math-container">\$2\timesω^ω\$</span></li>
<li><code>[[n,[[0,n],n]],[[[0,n],n],[[0,n],n]]]</code> corresponds to <span class="math-container">\$ω^{ω+1}\$</span></li>
<li><code>[[[n,n],[[0,n],n]],[[[0,n],n],[[0,n],n]]]</code> corresponds to <span class="math-container">\$ω^{ω_2}\$</span></li>
<li><code>[[n,[[n,n],[[0,n],n]]],[[[0,n],n],[[0,n],n]]]</code> corresponds to <span class="math-container">\$ω^{ω_2+1}\$</span></li>
<li><code>[[[0,[n,n]],[[0,n],n]],[[[0,n],n],[[0,n],n]]]</code> corresponds to <span class="math-container">\$ω^{ω_3}\$</span></li>
<li><code>[[[n,[n,n]],[[0,n],n]],[[[0,n],n],[[0,n],n]]]</code> corresponds to <span class="math-container">\$ω^{ω^2}\$</span></li>
<li><code>[[[[0,n],[n,n]],[[0,n],n]],[[[0,n],n],[[0,n],n]]]</code> corresponds to <span class="math-container">\$ω^{ω^3}\$</span></li>
<li><code>[[0,[0,n]],n]</code> corresponds to <span class="math-container">\$ω^{ω^ω}\$</span></li>
</ul>
<p>Where does the strength comes from? The strength lies in the fact that the binary tree notation corresponds to performing the Middle Growing Hierarchy on ordinals! Here are some examples:</p>
<ul>
<li><code>[n,n]</code> corresponds to <span class="math-container">\$m(ω,n)=n+2^n\$</span>, so <code>[n,n]</code> as an ordinal corresponds to <span class="math-container">\$ω+2^ω=ω_2\$</span></li>
<li><code>[[0,n],n]</code> corresponds to <span class="math-container">\$m(ω+1,n)=2^{n+2^n}\$</span>, so <code>[[0,n],n]</code> as an ordinal corresponds to <span class="math-container">\$2^{ω+2^ω}=2^{ω_2}=ω^2\$</span></li>
<li><code>[[[0,n],n],[[0,n],n]]</code> corresponds to <span class="math-container">\$m(ω,m(ω+1,n))=2^{2^{n+2^n}}\$</span>, so <code>[[[0,n],n],[[0,n],n]]</code> as an ordinal corresponds to <span class="math-container">\$2^{2^{ω+2^ω}}=ω^ω\$</span></li>
<li><code>[[0,[0,n]],n]</code> corresponds to <span class="math-container">\$m(ω+2,n)=2^{2^{2^{n+2^n}}}\$</span>, so <code>[[0,[0,n]],n]</code> as an ordinal corresponds to <span class="math-container">\$2^{2^{2^{ω+2^ω}}}=ω^{ω^ω}\$</span></li>
</ul>
<p>As it turns out, this pattern continues. I'm not going to go through the full analysis, but here are some more ordinal values. Remember that these are ordinals, not functions!</p>
<ul>
<li><code>[[1,n],n]</code> corresponds to <span class="math-container">\$ω^{ω^{ω^{ω^{ω^{ω^ω}}}}}\$</span></li>
<li><code>[[n,n],n]</code> corresponds to <span class="math-container">\$ε_0\$</span></li>
<li><code>[[n,[n,n]],n]</code> corresponds to <span class="math-container">\$ζ_0\$</span></li>
<li><code>[[[0,n],n],n]</code> corresponds to <span class="math-container">\$φ(ω,0)\$</span></li>
<li><code>[[[n,n],n],n]</code> corresponds to the BHO</li>
</ul>
<h2>Speed of Notation</h2>
<p>Essentially, if a structure <span class="math-container">\$K\$</span> corresponds to <span class="math-container">\$g_a (n)\$</span> in the slow-growing hierarchy, then the structure <code>[K,n]</code> corresponds to <span class="math-container">\$m_a (n)\$</span> in the middle-growing hierarchy. This makes the limit <code>[[[...,n],n],n]</code>, which corresponds to the first SGH-MGH catching point, of <span class="math-container">\$ψ(Ω_ω)\$</span>. For comparison, <span class="math-container">\$\text{TREE}(n)\$</span> only corresponds to the ordinal <span class="math-container">\$ψ(Ω^{Ω^ω})\$</span>, much much smaller. The premise of this notation is essentially nested Goodstein sequences, except it works!</p>
<p>The Middle Growing Hierarchy corresponds closely to the Fast Growing Hierarchy, this is why I put in <span class="math-container">\$f_{ψ(Ω_ω)}\$</span> as it is a catching point.</p>
<h1>Actual Value of the program</h1>
<p>Now that we have gone through the Predecessor function, and how it corresponds to numbers, functions, and ordinals, it is time to return to the value of this program.</p>
<p>To extract a value from a binary tree, such as <code>[[[0,0],0],0]</code>, one would have to repeatedly apply the predecessor function until the value crashes down to 0. As we seen before, one would have to apply the predecessor function a massive amount of time, on the order of <span class="math-container">\$m(ψ(Ω_ω),x)\$</span></p>
<p>Just to let you know, <code>[[[...,0],0],0]</code> is not degenerate, unlike stuff like <span class="math-container">\$2 \uparrow\uparrow...\uparrow\uparrow2 = 4\$</span> in arrow notation. <code>[[[...,0],0],0]</code> will produce a massive number.</p>
<p>Here is the code again:</p>
<pre><code>for(a=b=0;a=b++&lt;9?[a,0]:P(a););b;
</code></pre>
<p>First, it sets <code>a</code> and <code>b</code> equal to <code>0</code>. Then, it starts incrementing <code>b</code>. If <code>b</code> is less than <code>9</code>, then it sets <code>a</code> to <code>[a,0]</code>. This means at <code>b=9</code>, <code>a</code> would had been already <code>[[[[[[[[[0,0],0],0],0],0],0],0],0],0]</code>, which corresponds to a massive number. Then, the predecessor function gets repeatedly applied to <code>a</code>, increasing <code>b</code> by <code>1</code> for each application. Eventually, <code>a</code> is going to crash down to <code>0</code>, but <code>b</code> will be some value far, <i>far</i> greater than <span class="math-container">\$\text{TREE}(3)\$</span>, or <span class="math-container">\$\text{TREE}(\text{TREE}(...\text{TREE}(3)...))\$</span> with <span class="math-container">\$\text{TREE}(3)\$</span> nests. Finally, the program returns <code>b</code>.</p>
<h1>So what?</h1>
<p>One of the best thing about this program is how the notation enumerates the catching points between the SGH and the MGH. This program only reaches the very first catching point, but by a few simple extension, this program is able to formalize a meameamealokkapoowa oompa, surpass Strong Array Notation, and beat every single Ordinal Collapsing Function ever devised. <span class="math-container">\$ψ(Ω_ω)\$</span> is still a pathetically small value...</p>
</div>
<div id="pu5" class="pu"><h2>Haskell, 252 Bytes, TREE(3)+1</h2>

<pre><code>data T=T[T]Int
l(T n _)=1+sum(l&lt;$&gt;n)
a@(T n c)#T m d=any(a#)m||c==d&amp;&amp;n!m
l@(x:t)!(y:u)=l!u||x#y&amp;&amp;t!u
x!_=null x
a n=do x&lt;-[1..n];T&lt;$&gt;mapM(\_-&gt;a$n-1)[2..x]&lt;*&gt;[1..3]
s 0=[[]]
s n=[t:p|p&lt;-s$n-1,t&lt;-a n,(l t&lt;=n)&gt;any(#t)p]
main=print$[x|x&lt;-[0..],null$s x]!!0
</code></pre>

<p>Thanks for help from H.PWiz, Laikoni and Ørjan Johansen for help golfing the code!</p>

<p>As suggested by <a href="https://codegolf.stackexchange.com/questions/139355/golf-a-number-bigger-than-tree3?noredirect=1#comment355715_139355">HyperNeutrino</a>, my program outputs TREE(3)+1, exactly (TREE is computable as it turns out).</p>

<p><code>T n c</code> is a tree with label <code>c</code> and nodes <code>n</code>. <code>c</code> should be <code>1</code>, <code>2</code>, or <code>3</code>.</p>

<p><code>l t</code> is the number of nodes in a tree <code>t</code>.</p>

<p><code>t1 # t2</code> is true if <code>t1</code> homeomorphically embeds into <code>t2</code> (based on <a href="https://www.cis.upenn.edu/~jean/kruskal.pdf" rel="noreferrer">Definition 4.4 here</a>), and false otherwise.</p>

<p><code>a n</code> outputs a big list of trees. The exact list isn't important. The important property is that <code>a n</code> contains every tree up to <code>n</code> nodes, with nodes being labelled with <code>1</code>, <code>2</code>, or <code>3</code>, and maybe some more trees as well (but those other trees will also be labelled with <code>1</code>, <code>2</code>, or <code>3</code>). It is also guaranteed to output a finite list.</p>

<p><code>s n</code> lists all sequences length <code>n</code> of trees, such that the reverse (since we build it backwards) of that sequence is valid. A sequence is valid if the nth element (where we start counting at 1) has at most n nodes, and no tree homeomorphically embeds into a later one.</p>

<p><code>main</code> prints out the smallest <code>n</code> such that there is no valid sequences of length <code>n</code>.</p>

<p>Since <code>TREE(3)</code> is defined as the length of the longest valid sequence, <code>TREE(3)+1</code> is the smallest <code>n</code> such that there are no valid sequences of length <code>n</code>, which is what my program outputs.</p>
</div>
<div id="pu6" class="pu"><h1>New Ruby, 135 bytes, >> H<sub>ψ(φ<sub>3</sub>(Ω+1))</sub>(9)</h1>

<p>where <strong>H</strong> is the Hardy hierarchy, <strong>ψ</strong> is an extended version of Madore's OCF (will explain below) and <strong>φ</strong> is the Veblen function.</p>

<p><a href="https://tio.run/##FYrBCgIhFEV/ZdpVPEGXOd38kMdbqKMYhkQwRGTfbjOrc@Cc1xo@Y2Som6dGAf4baaEEP3sgTs4rY9MGwCvW4pj3njnttwgtylAUGy23q@k9Ato1y5lj74GaMtvTqMlvLmChigvVTTMXeh7rGfUk73J/pKkcoMf4Aw" rel="noreferrer">Try it online!</a></p>

<pre><code>f=-&gt;a,n,b=a{c,d,e=a;a==c ?a-1:e ?a==a-[0]?[[c,d,f[e,n,b]],d-1,c]:c:[n&lt;1||c==0?n:[f[c||b,n-1]],n,n]};h=[],k=9,k;h=f[h,p(k*=k)]while h!=0
</code></pre>

<p>Ungolfed: (using functions, not lambdas)</p>

<pre><code>def f(a,n,b)
  c,d,e = a
  if a == c
    return a-1
  elsif e
    if a == a-[0]
      return [[c,d,f(e,n,b)],d-1,c]
    else
      return c
    end
  else
    x = c || b
    if n &lt; 1 || c == 0
      return [n,n,n]
    else
      return [f(x,n-1,x),n,n]
    end
  end
end

k = 9
h = [[],k,k]
while (h != 0) do
  k *= k
  p k
  h = f(h,k,h)
end
</code></pre>

<p>Madore's extended OCF:</p>

<p><a href="https://i.stack.imgur.com/yY9gB.png" rel="noreferrer"><img src="https://i.stack.imgur.com/yY9gB.png" alt="enter image description here"></a></p>

<p>And (crudely) Veblen's phi function:</p>

<p><a href="https://i.stack.imgur.com/onvs2.png" rel="noreferrer"><img src="https://i.stack.imgur.com/onvs2.png" alt="enter image description here"></a></p>

<p>Explanation without ordinals: </p>

<pre><code>f(a,n,b) reduces an array recursively. (if no third argument given, it takes the first argument twice.)
f(k,n,b) = k-1, k is a positive int.
f([c,d,0],n,b) = f([c,0,e],n,b) = c
f([c,d,e],n,b) = [[c,d,f(e,n,b)],d-1,c], d ≠ -1 and c ≠ 0

f([a],0,b) = [0,0,0]
f([0],n,b) = [n,n,n]
f([],n,b) = f([b],n,b)
f([a],n,b) = [f[a,n-1,a],n,n]
</code></pre>

<p>My program initiates <code>k = 9, h = [[],9,9]</code>. It then applies <code>k = k*k</code> and <code>h = f(h,k)</code> until <code>h == 0</code> and outputs <code>k</code>.</p>

<p>Explanation with ordinals:</p>

<pre><code>Ordinals follow the following representation: n, [], [a], [a,b,c], where n,d is a natural number and a,c are all ordinals.
x = Ord(y) if y is the syntactic version of x.
a[n,b] = Ord(f(a,n))
ω = Ord([0]) = Ord(f([a],-1,b))
n = Ord(n)
Ω = Ord([])
ψ'(a) = Ord([a])
ψ'(a)[n] = Ord(f([a],n))
φ(b,c) ≈ Ord([[0],b,c])
a(↓b)c = Ord([a,b,c]) (down-arrows/backwards associative hyper operators I designed just for ordinals)

We follow the following FS for our ordinals:
k[n,b] = k-1, k &lt; ω
ω[n,b] = n(↓n)n
(a(↓b)0)[n,b] = (a(↓0)c)[n,b] = a
(a(↓b)c)[n,b] = (a(↓b)(c[n,b]))(↓b[n,b])a, b ≥ 0 and c &gt; 0.
ψ'(a)[0,b] = 0(↓0)0
ψ'(a)[n,b] = (ψ'(a[n-1,a]))(↓n)ω, a &gt; 0 and n ≥ 0. (also note that we've changed from [n,b] to [n,a].)
Ω[n,b] = ψ'(b)[n,b]
</code></pre>

<p>ψ'(ω∙α) ≈ ψ(α), the ordinal collapsing function described in the image above.</p>

<p>My program more or less initiates <code>k = 9</code> and <code>h = Ω(↑9)9</code>, then applies <code>k ← k²</code> and <code>h ← h[k,h]</code> until <code>h = 1</code> and returns <code>k</code>.</p>

<p>And so if I did this right, <code>[[],9,9]</code> is way bigger than the Bachmann-Howard ordinal ψ(Ω<sup>Ω<sup>Ω<sup>...</sup></sup></sup>), which is way bigger than ϑ(Ω<sup>ω</sup>ω)+1.</p>

<p><strong>ψ(Ω(↓9)9) > ψ(Ω(↓4)3) > ψ(Ω<sup>Ω<sup>Ω</sup></sup>)+1 > ψ(Ω<sup>Ω<sup>ω</sup>ω</sup>)+1 > ϑ(Ω<sup>ω</sup>ω)+1</strong></p>

<p>And if my analysis is correct, then we should have ψ'(Ω<sup>Ω</sup>∙x) ~= ψ*(Ω<sup>Ω</sup>∙x), where ψ* is the normal Madore's psi function. If this holds, then my ordinal is approximately ψ*(φ<sub>3</sub>(Ω+ω)).</p>

<hr>

<h1>Old Ruby, 309 bytes, H<sub>ψ'<sub>0</sub>(Ω<sub>9</sub>)</sub>(9) (see <a href="https://codegolf.stackexchange.com/posts/145882/revisions">revision history</a>, besides the new one is way better)</h1>
</div>
<div id="pu7" class="pu"><h1>Julia, 569 bytes, <a href="http://googology.wikia.com/wiki/Loader%27s_number" rel="nofollow noreferrer">Loader's Number</a></h1>

<pre><code>r,/,a=0,div,0;¬x=x/2;r&lt;s=r?s:0;y\x=y-~y&lt;&lt;x;+x=global r=(x%2!=0)&lt;1+(+¬x);!x=¬x&gt;&gt;+x;√x=S(4,13,-4,x);S(v,y,c,t)=(!t;f=x=r;f!=2?f&gt;2?f!=v?t-(f&gt;v)%2*c:y:f\(S(v,y,c,!x)\S(v+2,t=√y,c,+x)):S(v,y,c,!x)$S(v,y,c,+x));y$x=!y!=1?5&lt;&lt;y\x:S(4,x,4,+r);D(x)=(c=0;t=7;u=14;while(x!=0&amp;&amp;D(x-1);(x=¬x)%2!=0)d=!!D(x);f=!r;x=!r;c==r&lt;((!u!=0||!r!=f||(x=¬x)%2!=0)&lt;(u=S(4,d,4,r);t=t$d);¬f&amp;(x=¬x)%2!=0&lt;(c=d\c;t=√t;u=√u));(c!=0&amp;&amp;(x=¬x)%2!=0)&lt;(t=((~u&amp;2|(x=¬x)%2!=0)&lt;(u=1&lt;&lt;(!c\u)))\(!c\t);c=r);¬u&amp;(x=¬x)%2!=0&lt;(c=t\c;u=√t;t=9)end;global a=(t\(u\(x\c)))\a);D(D(D(D(D(BigInt(99))))))
</code></pre>

<p>To save myself a bit of legwork, I decided to port Loader.c to Julia nearly one-for-one and compact it into the block of code above. For those that want to do the comparisons themselves (either to verify my scoring or to help me find mistakes or improve my code), an ungolfed version is below: </p>

<pre><code>r,/,a=0,div,0;
¬x=x/2;
r&lt;s=r?s:0;
y\x=y-~y&lt;&lt;x;
+x=global r=(x%2!=0)&lt;1+(+¬x);
!x=¬x&gt;&gt;+x;
√x=S(4,13,-4,x);
S(v,y,c,t)=(
    !t;
    f=x=r;
    f!=2?
        f&gt;2?
            f!=v?
                t-(f&gt;v)%2*c
                :y
            :f\(S(v,y,c,!x)\S(v+2,t=√y,c,+x))
        :S(v,y,c,!x)$S(v,y,c,+x)
);
y$x=!y!=1?5&lt;&lt;y\x:S(4,x,4,+r);
D(x)=(
    c=0;
    t=7;
    u=14;
    while(x!=0&amp;&amp;D(x-1);(x=¬x)%2!=0) 
        d=!!D(x);
        f=!r;
        x=!r;
        c==r&lt;(
            (!u!=0||!r!=f||(x=¬x)%2!=0)&lt;(
                u=S(4,d,4,r);
                t=t$d
            );
            ¬f&amp;(x=¬x)%2!=0&lt;(
                c=d\c;
                t=√t;
                u=√u
            )
        );
        (c!=0&amp;&amp;(x=¬x)%2!=0)&lt;(
            t=((~u&amp;2|(x=¬x)%2!=0)&lt;(u=1&lt;&lt;(!c\u)))\(!c\t);
            c=r
        );
        ¬u&amp;(x=¬x)%2!=0&lt;(
            c=t\c;
            u=√t;
            t=9
        )
    end;
    global a=(t\(u\(x\c)))\a
);
D(D(D(D(D(BigInt(99))))))
</code></pre>

<p>No previous counts because I made way too many byte miscounts in the aggressive golfing I've done. </p>
</div>
<div id="pu8" class="pu"><h1>Ruby, 140 bytes, ~ H<sub>ψ(Ω<sup>Ω<sup>Ω</sup></sup>)</sub>(81)</h1>

<p>where <strong>H</strong> is the <a href="https://en.wikipedia.org/wiki/Hardy_hierarchy" rel="nofollow noreferrer">Hardy hierarchy</a>, and <strong>ψ</strong> is the standard ordinal collapsing function below the Bachmann-Howard ordinal, as defined <a href="http://googology.wikia.com/wiki/User_blog:Deedlit11/Ordinal_notations_II:_Up_to_the_Bachmann-Howard_ordinal" rel="nofollow noreferrer">here</a>.</p>

<pre><code>s=-&gt;t{*v,u=t;t==1?[]:v&lt;&lt;s[u]}
r=-&gt;t{*v,u=t;$b=t[0][0]?$b:t;u==1?v&lt;&lt;s[$b]:u[0]?v+[r[u]]*$c:v}
$c=9
a=[],[1,[1,1]]
($c*=9;a=r[a])while a[0]
$c
</code></pre>

<p><a href="https://repl.it/N8ju/14" rel="nofollow noreferrer">Try it online!</a></p>

<p>Ungolfed version:</p>

<pre>
def S(a)
  *v, u = a
  if a == 1 
    return []
  else
    return v + [S(u)]
  end
end  

def R(t)
  *v, u = t
  if t[0] == []
    $b = t
  end
  if u == 1
    return v + [S($b)]
  elsif u == []
    return v
  else
    return v + [R(u)]*$c
  end
end

$c = 9

a = [[],[1,[1,1]]]

while a != [] do
  $c *= 9
  a = R(a)
end

print $c
</pre>

<p>This program implements the Buchholz hydra with nodes labelled with []'s and 1's, as described in my Python 2 entry.</p>

<p>The tree [[],[1,[1,1]]] corresponds to the ordinal ψ(Ω<sup>Ω<sup>Ω</sup></sup>), which is considerably bigger than the ordinal ϑ(Ω<sup>ω</sup>ω) = ψ(Ω<sup>Ω<sup>ω</sup>ω</sup>), and so our resulting final number of about H<sub>ψ(Ω<sup>Ω<sup>Ω</sup></sup>)</sub>(81) will exceed TREE(3).</p>
</div>
<div id="pu9" class="pu"><h1>Python 2, 194 bytes, ~ H<sub>ψ(Ω<sup>Ω<sup>Ω</sup></sup>)</sub>(9)</h1>

<p>where <strong>H</strong> is the Hardy hierarchy, and <strong>ψ</strong> is the ordinal collapsing function below the Bachmann-Howard ordinal defined by Pohlers.</p>

<p>Thanks to Jonathan Frech for -3 bytes.</p>

<pre>
def S(T):return 0if T==1else[S(T[0])]+T[1:]
def R(T):U=T[0];V=T[1:];exec"global B;B=T"*(T[-1]==0);return[S(B)]+V if U==1else[R(U)]*c+V if U else V
A=[[[1,1],1],0]
c=9
while A:A=R(A);c*=c
print c
</pre>

<p><a href="https://repl.it/FyOe/10" rel="noreferrer">Try it online!</a></p>

<p>Better spaced version:</p>

<pre>def S(T):
  return 0 if T==1 else [S(T[0])]+T[1:]

def R(T):
  U=T[0]
  V=T[1:]
  global B
  if T[-1]==0:
    B=T
  if U==1: 
    return [S(B)]+V
  return [R(U)]*c+V if U else V

A=[[[1,1],1],0]
c=9
while A:
  A=R(A)
  c*=c
print c
</pre>

<p>Explanation:</p>

<p>This program implements a variant of the <a href="http://googology.wikia.com/wiki/Buchholz_hydra" rel="noreferrer">Buchholz hydra</a>, using just labels of 0 and 1.  Basically, at each step, we look at the first leaf node of the tree, and see if it is labelled with a 0 or a 1.</p>

<p>-If the leaf node is labelled with a 0, then we delete the leaf node, and then copy the tree starting from the parent of the leaf node c times, all of the copies connected to the grandparent of the leaf node.</p>

<p>-If the leaf node is labelled with a 1, then we search back towards the root until we reach an ancestor node labelled with a 0.  Let S be the tree starting from that ancestor node.  Let S' be S with the leaf node relabelled with 0.  Replace the leaf node with S'.</p>

<p>We then repeat the process until we have nothing left but the root node.</p>

<p>This program differs from the normal Buchholz hydra procedure in two ways:  First, after we do the above procedure, we recurse back up the tree, and do the label 0 copy procedure described above for each ancestor node of the original leaf node.  This increases the size of the tree, so our procedure will take longer than the normal Buchholz hydra, and therefore lead to a bigger number in the end; however, it will still terminate because the ordinal associated with the new tree will still be less the the old tree.  The other difference is, rather than start with c = 1 and increasing 1 each time, we start with c = 9 and square it each time, because why not.</p>

<p>The tree [[[1,1],1],0] corresponds to the ordinal ψ(Ω<sup>Ω<sup>Ω</sup></sup>), which is considerably bigger than the ordinal ϑ(Ω<sup>ω</sup>ω), and so our resulting final number of about H<sub>ψ(Ω<sup>Ω<sup>Ω</sup></sup>)</sub>(9) will definitely exceed TREE(3).</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/139355/">139355</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




