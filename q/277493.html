<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::277493</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>229</td><td>Python 3</td><td>250105T003449Z</td><td><a href="https://codegolf.stackexchange.com/questions/277493/how-many-free-polyominos-without-holes/277514#277514">xnor</a></td></tr>
<tr d-ix="1"><td>275</td><td>Ruby</td><td>250103T192921Z</td><td><a href="https://codegolf.stackexchange.com/questions/277493/how-many-free-polyominos-without-holes/277505#277505">Level Ri</a></td></tr>
<tr d-ix="2"><td>686</td><td>Python</td><td>250104T004041Z</td><td><a href="https://codegolf.stackexchange.com/questions/277493/how-many-free-polyominos-without-holes/277508#277508">138 Aspe</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://docs.python.org/3.8/" rel="nofollow noreferrer">Python 3</a>, 229 bytes</h1>

<pre class="lang-none prettyprint-override"><code>def f(n):
 t,=L=[[]]
 for l in L:
  A=p=0;s,*r=1,;L+=l+[0],l+[1],l+[3];L*=len(l)&lt;2*n+3
  for d in l:s*=1j**d*2**(p in r);r+=p,;p+=s;A+=p/s
  if s-1==p==0&lt;A.imag==n*2:t+=max(max(l:=(*l[1:],x),l[::-1])for x in l),
 return len({*t})
</code></pre>
<p><a href="https://tio.run/##HU9BbsMgELz7FRxhIa2xpaqC7MF3/wBxsGQ7dUQIAiI5qvp2F3zY0WhXM7MT3vnn6fvvEI9jXlayUs9UQ7LAEY2xtiHrMxJHNk/GsicDBmx1EhBRCj1ydNy0VhSUJ/ZWj4Bu8dSxawee90VULeZq4VQClHeAGToAGuouMh05BqEDx6SHQj9T0WwrSReJJQ7b6/CxPaYboodOZY6Paad1nEIKzkhlxc6EM0pdpGU1bT/TmGhIXPIrFl4@@oX8x4569mfw5G8LleKrFg5x85l6Ufuz4x8" rel="nofollow noreferrer" title="Python 3.8 (pre-release) – Try It Online">Try it online!</a></p>
<p>I haven't golfed this too hard -- I just want to show off a new method.</p>
<p>We represent a hole-free polyomino by its boundary loop walk. This means, tracing its perimeter one segment at a time, which direction do we turn at each step: left, right, or straight?</p>
<p>For example, the area-3 polyomino</p>
<pre class="lang-none prettyprint-override"><code>XX
X
</code></pre>
<p>has the boundary walk</p>
<pre class="lang-none prettyprint-override"><code>L&lt;S&lt;L
v   ^
S R&gt;L
v ^
L&gt;L
</code></pre>
<p>which corresponds to <code>RLLSLSLL</code> if we start from the <code>R</code>.</p>
<p>This representation has some nice features compared to the usual of a polyomino as the coordinates of each of its squares. Because everything is relative, there's no need to handle translated or rotated polyominoes. Ones with interior holes are never generated, and ones with self-touches can be culled by checking if the boundary ever revisits a point.</p>
<p>Moreover, there's a neat &quot;discrete calculus&quot; trick to find the area from the walk, and I've even posted a challenge about it before: <a href="https://codegolf.stackexchange.com/q/163395/20260">Area enclosed by perimeter loop</a>!</p>
<hr />
<p>So, here's the method. Generate all sequences of turns (left, right, straight) of sufficiently large length. For each one, check that it:</p>
<ul>
<li>Returns to its start point</li>
<li>Ends facing the starting direction</li>
<li>Never encounters a coordinate a second time, since this would indicate a loop of self-crossing</li>
<li>Has the desired area</li>
</ul>
<p>If so, add it to the list of polyominos. However, polyominos will repeat because the starting point of the loop is arbitrary, and reflections correspond to reversed walks. So, convert each walk to a canonical form, by taking the list-maximum among its cyclic rotations and reversals. At the end, output the number of distinct values produced this way.</p>
<p>This code is slow -- it only gets up to <code>n=5</code> on TIO. I've tested a somewhat-optimized version up to <code>n=7</code>.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, 275 bytes</h1>

<pre class="lang-none prettyprint-override"><code>f=-&gt;n,p=[[2]],s=1{q=[]
z=[w=n*3,-1,-w,1]
p.map{|a|(s*4).times{|i|r=[];g=h=1
c=a+[d=z[i%4]+a[i/4]]
8.times{|j|h+=(g-g=2*a.count(d-z[j/2]+j%2*z[j/2-1]))**2
c=c.map!{|k|j%2&lt;1?k-k%w*2:k%w*w+k/w}.sort!.map{|m|m-c[0]+n}
r&lt;&lt;c*1}
a.any?(d)||h&gt;10||q&lt;&lt;r.min}}
s&lt;n ?f[n,q&amp;q,s+1]:p.size}
</code></pre>
<p><a href="https://tio.run/##NY7NboMwAIPveYr2wAT5o0k5TB0pDxLlkNECAZECoUKF8OyMbtrFsuRPtofn92vbCkGuFndCSq4UdoItvZAKzEJOwsIzJgyTCTMFOtrqbvHahw4mER1Ne3eLN37Y8a9SVIKBXGgkb2KWJkgU0tLEiVLg85@tfYVEWJJScKhp/njaMbyRWdYxV6gOOPy1hKkogpDvbfl78rj4xu9pyrKGNMEE@eWtE2riaaXuMYzHv2etb0kuTwrZFQxpmkO2Ak21fWXhLfK@urKT932aDrQ1dl2BS@0hK6TF/UePHWLq0lFn5vu6dYdCMqa2Hw" rel="nofollow noreferrer" title="Ruby – Try It Online">Try it online!</a></p>
<p>Adapted from my answer to a <a href="https://codegolf.stackexchange.com/a/246311/15599">previous question</a> about polyiamonds (shapes composed of equilateral triangles).</p>
<p>This is a recursive function taking required size of polyominos <code>n</code> as an argument, plus two optional arguments: an array <code>p</code> of smaller polyominos and <code>s</code> the number of squares in the smaller polyominos. The initial default value of these corresponds to the seed polyomino of just one square.</p>
<p>First golfed version, runs a little slower than the first working version below due to certain checks being carried out late in the algorithm to avoid <code>()</code>, resulting in a lot of unnecessary calculation. In particular, all next generation polyominos are calculated before a check is made to see whether we have already reached the required value of <code>n</code>, as the decision to return the correct value or recurse further is made at the end of the function. Similarly detection of new squares overlapping old ones is not done until sufficient info has been gathered to find if a hole has been created.</p>
<p>The polyomino is represented as an array of integers of the form <code>d=x+wy</code>. The board is of width <code>3*n</code> in the x direction to avoid overlaps and is effectively infinite in the y direction.</p>
<p>The main new feature is the avoidance of holes. The polyomino is grown by adding a new square beside any existing square in any of the four orthogonal directions. The new square is rejected if it bridges across to another existing square. This is detected by walking around the 8 spaces adjacent to the new square and counting the number of changes from full square to empty square and vice versa. There should be exactly 2 changes. If there are more, the new square is bridging and the polyomino is rejected.</p>
<p>The golfed version maintains a value of 0 or 2 in <code>g</code> for the previous square and calculates a new value each iteration, adding the square of the difference to <code>h</code> each time. <code>h</code> therefore increments by 4 each time a change is detected. Because there are an even number of changes the idealised value of <code>h</code> would be a multiple of 8. In the golfed version we take advantage of this by initialising <code>g</code> and <code>h</code> to a fuzzy value of <code>1</code>. The first increment of <code>h</code> is therefore always to 2, followed by 1-4 proper change detections. If there are more than 2 proper change detections, <code>h</code> exceeds 10 and the polyomino is rejected.</p>
<p>At the same time, the polyomino is alternately reflected 8 times orthogonally (by subtracting <code>x*2</code>=<code>k%w*2</code>) and diagonally (by swapping x and y <code>k%w*w+k/w</code>) to generate all 8 possible orientations.</p>
<p>If the polyomino is not rejected, it is added to the new list of larger polyominos <code>q</code>.</p>
<p><strong>Commented code</strong></p>
<pre class="lang-none prettyprint-override"><code>f=-&gt;n,p=[[2]],s=1{                  #Call function with desired n, seeded with single square
q=[]                                #Make an array for next generation polyominos
z=[w=n*3,-1,-w,1]                   #w=width of board. z=array of 4 orthogonal directions
p.map{|a|(s*4).times{|i|            #Try extending each existing polyomino in p, from each square in 4 directions
  r=[];g=h=1                         #Make array to hold all orientations of new shape. Initialise g&amp;h for hole detection
  c=a+[d=z[i%4]+a[i/4]]              #Make new polyomino c by extending from a[i/4] in direction i%4 adding square d  
  8.times{|j|h+=                          #Loop 8 times for relections and hole detection
(g-g=2*a.count(d-z[j/2]+j%2*z[j/2-1]))**2 #Walk around 8 neighbours of square d, update g, and if it changed increment h
    c=c.map!{|k|j%2&lt;1?k-k%w*2:k%w*w+k/w}. #Reflect c orthogonally or diagonally depending on value of j%2
    sort!.map{|m|m-c[0]+n}                #sort &amp; normalise the elements so that the lowest=n putting it in middle of board
    r&lt;&lt;c*1}                               #add current relection of c to r. We will select the lexically lowest value of c
  a.any?(d)||h&gt;10||q&lt;&lt;r.min}}        #If new square d doesn't overlap existing square &amp; h shows no bridge, add new shape to q
s&lt;n ?f[n,q&amp;q,s+1]:p.size}           #if s==n return the size of existing list p. 
                                    #If s&lt;n, take precalculated list of next size polyominos q, eliminate duplicates and recurse
</code></pre>
<h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, 350 bytes</h1>

<pre class="lang-none prettyprint-override"><code>f=-&gt;n,p=[[2]],s=1{z=[w=n*3,w-1,-1,~w,-w,1-w,1,-~w];p p.size
#p.map{|a|t=(?.*~-w+$/)*s;a.map{|k|t[k]=?#};puts t,$/}
s&lt;n&amp;&amp;(q=[]
p.map{|a|(s*4).times{|i|d=z[i%4*2]+a[i/4]
a.index(d)||(c=a+[d];r=[];g=a.count(d-~w);h=0
8.times{|j|c=c.map!{|k|j%2&lt;1?k-k%w*2:k%w*w+k/w}.sort!.map{|m|m-(c[0])+n};r&lt;&lt;c*1
h+=g^g=a.count(d+z[j])}
h&lt;3&amp;&amp;q&lt;&lt;r.min)}}
f[n,q&amp;q,s+1])
}
</code></pre>
<p><a href="https://tio.run/##TY7dboIwGIbPexUalVBaiqAHy6DzQpou6cCfSqhAa7ph660ziXFZ8n7vyZc879Nfv37G8UDjD4VbyljGOdY0vQ2UWaqiDbZxih@5WxxbnE6H47vleTtriZbDHixa0oj25oQzNNyR6B5btExgpHPxfNTOsJrT3cLn7dXomcHLxANdqCAIO8o4@AOEOtpCYmSz1zcnXUUHJlfbKONIMJlsORBEqmr/HVbQubCkArGK5/2DkR@pIOXlqkxYPfRgfqJr8PZCnV1Jy2lkPtmcV1mR7uq4Xtkoe5/aojqxnuhLb@ZPl8Y1cViyNYdI@bwvijJKwQnR4@e/ITSwM4cenIpNEHRF0ZNGKug9ODCFu6DDGqUcAj8eWJrx8Rc" rel="nofollow noreferrer" title="Ruby – Try It Online">Try it online!</a></p>
<p>First working version  This version prints the full sequence from 1 to n. It will even print the polyominos themselves if you uncomment the second line.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.python.org" rel="nofollow noreferrer">Python</a>, 686 bytes</h1>
<p>Python port of formatted <a href="https://tio.run/##XVLRcoIwEHznK9YHHRBIDfrQKdh@SCadoaIVHRBBh9aqv043OKViZi7J3e1tNpeUx4/vplnN/dfcQ4E5lAWoQFvaQ0VX4oeBk0nUnHKMMfVQw4f04NOuNVeaZMgs9K61DllUoBBVelpyWyFi6WgEe2@YNBgzoxBZXLQnmHFGTLMrnjFzxCHNllWXM9mUlrD@pFIMMSMs0HAR033CTHfIWKR5svyyEwdn8i1YEhOnEh2ibM8P8WmCYrE75gc7ofRr7YRYMzhBx/Ms8CjiJmRDM6wLI3/Qz5r8tsUMEfDaEm/0fdqQbaNkvHT7mqq21F73GC6i2pWHQa81/9xZaz6vpSbaIUHeLw57bokootQxZC@8hjtnC94f2uCytRvt3EEv1n1RhKl5xL0hLUWW5n/QG@w2rxR/0h6EmR/kQpLwYq2UDHTT/AI" rel="nofollow noreferrer">Ruby code by @Level River St</a></p>
<hr />
<p>Golfed version. <a href="https://ato.pxeger.com/run?1=jVJLTsMwEJVYcgpvKtlN0pK0i6quF3bSQr8cwDISAhciFceK3UU3vQgbNrDkQJwGO2mgqF3wFEvxjN-bN_a8fuidfS7U29v71q6jwdfF5w0p79WTvHyUa3ANVajJqlAyNCRGw0vgkK-BBrkBPjzUhPNEiCpBiWr38JRwGtIoDt23p2FEw9ivMNpTgXWZKws3UkGNUKNmRqpW9kgJFz-bdVGCDOQK6N8DTXzm4zfQtPvob9JjTKZ81uq3ExFkfNbt9sXJEVd4DFRhvUx2quDBSBbwscBz5wlPSNZ5KLbO_ti1gvCCXJ0leW_L2tvgjLOj8stWMoqHjHAWsRZtJxWVeSo7tdtAboysOI5BA9bt0n_RWMcUpYUIOyqNGL8SgaqItCbieedea6keIXNd6h1ECK_I5LjrYMqXwvUdkNXd5Gwh19Ni1BvekpdcwTnCaaNpt3oj4e3hyT1SssmNhUZamLpS7tWrPUU_nlKBS2m3paqmMA1NENf06gYOKV2P7fs1jBNU_zej_A0" rel="nofollow noreferrer">Attempt This Online!</a></p>
<pre class="lang-python prettyprint-override"><code>H=range
def G(n,p=None,s=1):
    if p is None:p=[[2]]
    A=n*3;I=[A,A-1,-1,~A,-A,1-A,1,-~A];print(len(p))
    if s&lt;n:
        C=[]
        for D in p:
            for J in H(s*4):
                E=I[J%4*2]+D[J//4]
                if E not in D:
                    B=D+[E];K=[];F=D.count(E-~A);L=0
                    for M in H(8):
                        if M%2&lt;1:B=[B-B%A*2 for B in B]
                        else:B=[B%A*A+B//A for B in B]
                        B.sort();B=[A-B[0]+n for A in B];K.append(B.copy());N=F;F=D.count(E+I[M]);L+=N^F
                    if L&lt;3:O=min(K);C.append(tuple(O))
        C=list(set(C));C=[list(A)for A in C];return G(n,C,s+1)
    else:return p
</code></pre>
<p>Ungolfed version. <a href="https://ato.pxeger.com/run?1=jVXNbtswDD7t4qcgEAyQl5_WaQ_FsJyGXTegWIEBhjcrthwriSVFkuOlh77ILr1sD7Vn2WGk3TQNEmMjYFikyI_UJ5r-8cvsfKnV4-PP2hfjm9-v_uSigIKpEZjZR63ECNwsCt8GgCILMCAdkL2zkBiYQRxPk6S1NKgpeANXrXZPe80IrWOIRjDG5wHVMT4RmuiF2kOTBK27sVJ5thaKmTAEGMCHTS23HA0evIbUgJk4eS9SkApu6_ku2Nfl4B2oQ00byps8q4W2wCnGHFz2dkl2y9VCMId1X4fHLiQ5ot3HTMJr3EafaQJD4LGEiwu4Tk7csZwclPYEzE_RSDJE5AgS56fhJPa4_peyoNBJpmtkKkcOH5rwrF-Jfpdnd-jUy8Opb86ceC8D-IxODiMqSLMU5tyJHLQCXwrAi6kF6ALSZdqLgGQskbcp3k_Un4eEOIlXeCK2woCmJbqtdUW1ZufZIBFrJ_4D-gDbIPOo4e2h-jJDL0g2cdp6dp7p5wwVFp_Fl9QdqsWt_lG5nXBjhMpZhhdqdiwM-0sYwJ3JuReQlik00pfw5dMtsW-s2EpdO0gXKXCFrScaWvcieVHRN7vodThusSH2_jLpP3oJw1mH-RUxz7phE5TYAFf9t1RJ9Y2aHt_M9ufa7AnztVkL1kZ1k-LOCWiNNCgqvhIgPZTclXyONroMJzxoIyz3Uit3KHQAt6LSWwE5hssMKXYw30Gm1VZYL9WCEHkbTuzOebbqLGvp_NHEIQNDP7YJw-NR1O5IJKnrN1pRa2wSSv--y9SV754TUMyLMq3wtVXdaN7gVMZ7ibosx_3_5GeCIMD5-V1kNfYMfa5FrTI6etc8CsuKpoEVrl57XBcsmobdT-DpX7D_J_wF" rel="nofollow noreferrer">Attempt This Online!</a></p>
<pre class="lang-python prettyprint-override"><code>def f(n, p=None, s=1):
    if p is None:
        p = [[2]]
    w = n * 3
    z = [w, w - 1, -1, ~w, -w, 1 - w, 1, -~w]

    print(len(p))  # Equivalent to `p p.size` in Ruby

    if s &lt; n:
        q = []
        for a in p:
            for i in range(s * 4):
                d = z[(i % 4) * 2] + a[i // 4]
                if d not in a:
                    c = a + [d]
                    r = []
                    g = a.count(d - ~w)
                    h = 0
                    for j in range(8):
                        # Transform `c` based on the value of `j`
                        if j % 2 &lt; 1:
                            c = [k - (k % w) * 2 for k in c]
                        else:
                            c = [(k % w) * w + (k // w) for k in c]

                        c.sort()
                        c = [m - c[0] + n for m in c]
                        r.append(c.copy())

                        # Update `h` with XOR of previous `g` and new `g`
                        temp = g
                        g = a.count(d + z[j])
                        h += temp ^ g

                    if h &lt; 3:
                        min_r = min(r)
                        q.append(tuple(min_r))  # Use tuple to make it hashable for set operations

        # Remove duplicates by converting to a set and back to a list
        q = list(set(q))
        q = [list(item) for item in q]  # Convert tuples back to lists

        return f(n, q, s + 1)
    else:
        return p


# Execute the function with n = 12
result = f(12)
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/277493/">277493</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




