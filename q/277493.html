<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::277493</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>221</td><td>Ruby</td><td>250106T212830Z</td><td><a href="https://codegolf.stackexchange.com/questions/277493/how-many-free-polyominos-without-holes/277540#277540">Level Ri</a></td></tr>
<tr d-ix="1"><td>283</td><td>Maple</td><td>250107T232318Z</td><td><a href="https://codegolf.stackexchange.com/questions/277493/how-many-free-polyominos-without-holes/277552#277552">dharr</a></td></tr>
<tr d-ix="2"><td>221</td><td>Python 3</td><td>250105T003449Z</td><td><a href="https://codegolf.stackexchange.com/questions/277493/how-many-free-polyominos-without-holes/277514#277514">xnor</a></td></tr>
<tr d-ix="3"><td>114</td><td>Charcoal</td><td>250105T141533Z</td><td><a href="https://codegolf.stackexchange.com/questions/277493/how-many-free-polyominos-without-holes/277518#277518">Neil</a></td></tr>
<tr d-ix="4"><td>275</td><td>Ruby</td><td>250103T192921Z</td><td><a href="https://codegolf.stackexchange.com/questions/277493/how-many-free-polyominos-without-holes/277505#277505">Level Ri</a></td></tr>
<tr d-ix="5"><td>686</td><td>Python</td><td>250104T004041Z</td><td><a href="https://codegolf.stackexchange.com/questions/277493/how-many-free-polyominos-without-holes/277508#277508">138 Aspe</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, 221 bytes</h1>

<pre class="lang-none prettyprint-override"><code>-&gt;n{c=0
(9**-~n).times{|i|r=i.to_s(3).bytes
(0...2*m=r.size).map{|j|[r=r.rotate,r.reverse][j/m]}.max==r&amp;&amp;(v=1
a=x=y=u=0
q=r.map{|j|(j-=49)!=0&amp;&amp;(u,v=-v*j,u*j);a+=(v*x+=u)-u*y+=v;[x,y]}
x|y|u|~-v|a-n*2==0&amp;&amp;q&amp;q==q&amp;&amp;c+=1)}
c}
</code></pre>
<p><a href="https://tio.run/##LY3RasMgAEXf/YruJaiJLu22h1JufySEYYOFBJI2RkUX01/PHOztcjiHa9wt7nfs4jqtHWpCz5yL18Sk7Ue9rKlPBr20j@@FfjB5i1YvhNZSyhMfYeTS/2gmR/Vc05Aak4l5WGV1lYf22iy6bYb3sd2yEwBTFNTjSBQCIlz@m3Pyn9NB4PPM3lBny1UewvOhcnxgF1WCeh5KOCYcjyX8pQlVbDcSUkwuvYRPSkz8hL94LmZgLoquxJFtpNv25@HefLX7Lw" rel="nofollow noreferrer" title="Ruby – Try It Online">Try it online!</a></p>
<p>Alternate to my previous answer, based on Xnor's perimeter approach, but it works slightly differently. All walks are first generated as a base 3 number in string form, which is then converted into an array of ascii codes. These are rotated and reflected, and discarded if they are not in canonical (lexically highest) form. Hence there is no need to store the polyominoes.</p>
<p>Once a walk in canonical form is found it is checked to see if it is a valid polyomino. The ascii code 49 (for <code>1</code>) is considered straight and 48 and 50 are (for <code>0</code> and <code>2</code>) considered left and right.</p>
<p>The algorithm for finding the polyomino area is based on a classic way of finding the area of a polygon: select a point (such as the origin) which can be inside the polygon (but doesn't have to be if areas are signed.) Draw a triangle from each edge to the point and the area contribution to the polygon for each edge is found from the area of a triangle formula <code>base*height/2</code>. The code actually calculates double the area and subtracts it from <code>n*2</code> instead of dividing.</p>
<p>The following expression confirms that we have returned to the origin, facing the same direction, with area equal to <code>n</code> and without visiting the same point twice: <code>x|y|u|~-v|a-n*2==0&amp;&amp;q&amp;q==q</code>. We use the <code>OR</code> operator to confirm multiple expressions are zero with only a single <code>==0</code>, then we deduplicate list of points <code>q</code> by self intersection before comparing it with <code>q</code> itself to confirm there are no duplicates.</p>
<p>Canonical path detection removes reflections of the path and starts from different points, but certain reversals of direction are not removed - it considers <code>RRSRRS</code> and <code>SRRSRR</code> to be the same but <code>LLSLLS</code> to be different. This does not matter, as one is considered to have positive area and the other negative.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.maplesoft.com/" rel="nofollow noreferrer">Maple</a>, 283 bytes</h1>
<pre><code>proc(n)t:=[1,I,-I];p:=();for m to 2*n+2 do W:=Iterator:-Necklace(m,3);for w in W do z:=seq(w);z=sort([[z],seq([seq([z,z][-i-j],i=1..m)],j=1..m)])[1];c:=0;a:=0;d:=1;C:={for i to m do c+=d;a+=Re(d)*Im(c);d*=t[z[i]+1];c od};if`and`(c=0,d=1,nops(C)=m,a=n)then p,=z fi od od;nops({p})end;
</code></pre>
<pre><code>proc(n)
 t:=[1,I,-I];                 # multiplier to turn by 0 degrees (S), 90 (L), -90 (R) in complex plane
 p:=():                       # initialize set of polyominos
 for m to 2*n+2 do            # perimeter lengths (could be 4 to 2*n+2 by 2 but we're golfing)
   W:=Iterator:-Necklace(m,3);# iterator for necklaces of length m with 3 bead types (turns: S,L,R)
   for w in W do              # for each necklace (beads coded with 0..2 for S, L, R)
     z:=seq(w);
     # next line finds lex lowest canonical ordering of reversed and rotated lists
     z:=sort([[z],seq([seq([z,z][-i-j],i=1..m)],j=1..m)])[1];
     c:=0;                    # initialize coordinates (points in complex plane) to zero
     a:=0;                    # initialize area to zero
     d:=1;                    # arbitrary start direction (+x)
     C:={                     # find coordinates to detect self-intersection and current y value
         for i to m do        # for each bead                  
           c+=d;              # update coordinate                                     
           a+=Re(d)*Im(c);    # update area          
           d*=t[z[i]+1];      # decode and update direction
           c                  # last value in loop retained in set C
         od   
        };
     if `and`(c=0,d=1,        # valid if returns to origin in right direction             
            nops(C)=m,        # and no duplicate coordinates (not self intersecting)
            a=n)              # and correct area
     then
       p,=z                   # record this polyomino
     fi          
   od
 od;
 nops({p})                    # remove duplicates and count
end;
</code></pre>
<p>This is @xnor's nice algorithm with @Level River St's canonical form idea. Coordinates are coded as complex numbers. Areas are done by the sum of (Delta x)*y formula. Maple has a built-in iterator for necklaces, so only rotationally unique perimeters are generated (in lowest lex order canonical form). Unfortunately, it doesn't have a bracelet iterator, so the reversed lists have to be done separately.</p>
<p>n = 5 takes 7 s, n = 6 takes 76 s.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://docs.python.org/3.8/" rel="nofollow noreferrer">Python 3</a>, 221 bytes</h1>

<pre class="lang-none prettyprint-override"><code>def f(n):
 L=[[]];c=0
 for l in L:
  A=p=0;s,*r=1,;L+=l+[0],l+[1],l+[3];L*=len(l)&lt;2*n+3
  for d in l:s*=1j**d*2**(p in r);r+=p,;p+=s;A+=p/s
  c+=s-1==p==0&lt;A.imag==n*2!=l==max(max(l:=l[1:]+[x],l[::-1])for x in l)
 return c
</code></pre>
<p><a href="https://tio.run/##HY9LbsQgEET3PgXZQcMkxpaiCKYX3vsGiIXlz8QR04OwIzmnd8CLLvVHVU8d//bvF7VfMZ3nNC9s4SRMxXp0zns7Yl2x5ZVYYCuxPh9YhxFruylIqJXtJQbpaq@y6ktbb3vAMBMP4t4AyTabSsRUIoLZAPUPwAQNAI9ll4RNEqOyUeJmu9x@bNkz5ummMeOwvnfv63N4IBI0bxgQn8PBSwWDwWnjpTsy3Rlz014U2nHRRMXSvP8mYuNZtnTxBnrMXKvP8mhMK@2cVPlbnP8" rel="nofollow noreferrer" title="Python 3.8 (pre-release) – Try It Online">Try it online!</a></p>
<p><em>Saved 8 bytes with <a href="https://codegolf.stackexchange.com/a/277540/20260">Level River St's idea</a> of discarding paths not in canonical form</em></p>
<p>I haven't golfed this too hard -- I just want to show off a new method.</p>
<p>We represent a hole-free polyomino by its boundary loop walk. This means, tracing its perimeter one segment at a time, which direction do we turn at each step: left, right, or straight?</p>
<p>For example, the area-3 polyomino</p>
<pre class="lang-none prettyprint-override"><code>XX
X
</code></pre>
<p>has the boundary walk</p>
<pre class="lang-none prettyprint-override"><code>L&lt;S&lt;L
v   ^
S R&gt;L
v ^
L&gt;L
</code></pre>
<p>which corresponds to <code>RLLSLSLL</code> if we start from the <code>R</code>.</p>
<p>This representation has some nice features compared to the usual of a polyomino as the coordinates of each of its squares. Because everything is relative, there's no need to handle translated or rotated polyominoes. Ones with interior holes are never generated, and ones with self-touches can be culled by checking if the boundary ever revisits a point.</p>
<p>Moreover, there's a neat &quot;discrete calculus&quot; trick to find the area from the walk, and I've even posted a challenge about it before: <a href="https://codegolf.stackexchange.com/q/163395/20260">Area enclosed by perimeter loop</a>!</p>
<hr />
<p>So, here's the method. Generate all sequences of turns (left, right, straight) of sufficiently large length. For each one, check that it:</p>
<ul>
<li>Returns to its start point</li>
<li>Ends facing the starting direction</li>
<li>Never encounters a coordinate a second time, since this would indicate a loop of self-crossing</li>
<li>Has the desired area</li>
</ul>
<p>If so, add it to the list of polyominos. However, polyominos will repeat because the starting point of the loop is arbitrary, and reflections correspond to reversed walks. So, convert each walk to a canonical form, by taking the list-maximum among its cyclic rotations and reversals, and only increment the count if it was already in that form.</p>
<p>This code is slow -- it only gets up to <code>n=5</code> on TIO. I've tested a somewhat-optimized version up to <code>n=7</code>.</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 114 bytes</h1>
<pre><code>≔Ｉ1jδＮθ⊞υ⟦⟧Ｆυ«≔ＸδＥιΣ…ι⊕λη≔θζ≔⁰εＦη≡κδ≧⁻εζ±δ≧⁺εζ≧⁺κε¿⁼⁰ΣηＭ∧¬ζ∧⁼¹⊟η⁼ι⌊ΣＥＥιＥι§ι⁺λν⟦⮌κκ⟧→¿›‹Ｌι⊗⊕θ№ＥηΣ…ηλΣηＦ³⊞υ⁺ι⟦⊖κ⟧»Ｉⅈ
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=dVLBahsxEIXcsl8x-DQCBRraQ4hPxinFUJsluQSMD-vdsaVa1sYryWkS8iW5JJDQflO_piNZJiale9BqxJun997o6Xetqq5uK_P8_Bb84uTsz9HdwDm9tDisnMfe6Y-ekNCIfjGyN8FPwnpOHW64LoNTGCRMZ1ws2g4wCHgojnN72d4ysJEwrm5QS7gKaxze1YaGqk0HI1t3tCbrqUEj4idBMdWeYCPh_qD8JIFimW5SAtyt9rUCXKVL68oRNOfxsh3-Ui-Vx7G2wXFjpkqoCS0rT9iIf9ClOQQ3tKiC8f9BrbKcx-JYLwC_bkJlXBQZfSo2A-N2SziwDU5aj_dsLu4z7lRCySmo6DkfcSKsVq-5PVLE1HJy-TfwI9vQz7iNEtBIsLvUppe0pc4RZ8HCZiKHeZ70ij6QYdtR5beO2HqH38k5XuzSK9SMvGjD3PAYDkeySRzDNlifhKiPI-QDkzB7xwLSbD4L2D-NpJP1Ti_onXglWGG_eCzKTjN3embXyO39VzevXX6Hv6a9k63pzV6-7Oq_" rel="nofollow noreferrer">Attempt This Online!</a> Link is to verbose version of code. Explanation: Uses @xnor's approach, but even slower so can only manage up to <code>n=4</code> on ATO.</p>
<pre><code>≔Ｉ1jδ
</code></pre>
<p>Get <code>i</code>, the square root of minus one, into a variable, saving a byte.</p>
<pre><code>Ｎθ
</code></pre>
<p>Input <code>n</code>.</p>
<pre><code>⊞υ⟦⟧Ｆυ«
</code></pre>
<p>Start a breath-first search of walks.</p>
<pre><code>≔ＸδＥιΣ…ι⊕λη
</code></pre>
<p>Compute the cumulative sums of turns of this walk in terms of powers of <code>i</code>.</p>
<pre><code>≔θζ
</code></pre>
<p>Start calculating the area with <code>n</code> squares left to account for.</p>
<pre><code>≔⁰ε
</code></pre>
<p>Start at the origin. (I'm not sure it is necessary to reset the value each time in which case three bytes could be saved by using one of the predefined variables with a numeric value instead.)</p>
<pre><code>Ｆη≡κ
</code></pre>
<p>Loop over the direction vectors.</p>
<pre><code>δ≧⁻εζ
</code></pre>
<p>If this is a step up then subtract the current x-position from the area left to account for.</p>
<pre><code>±δ≧⁺εζ
</code></pre>
<p>If this is a step down then add the current x-position to the area left to account for.</p>
<pre><code>≧⁺κε
</code></pre>
<p>Otherwise adjust the current x-position.</p>
<pre><code>¿⁼⁰Ση
</code></pre>
<p>See whether the sum of the direction vectors is <code>0</code>, indicating that this is a closed loop. Conveniently in Charcoal, <code>Sum([])</code> is <code>None</code>, not <code>0</code>, so this fails for the the empty walk.</p>
<pre><code>Ｍ∧¬ζ∧⁼¹⊟η⁼ι⌊ΣＥＥιＥι§ι⁺λν⟦⮌κκ⟧→
</code></pre>
<p>If this closed loop has the correct area, ends facing the original direction, and is in canonical form, the increment the number of polyominoes found.</p>
<pre><code>¿›‹Ｌι⊗⊕θ№ＥηΣ…ηλΣη
</code></pre>
<p>Otherwise if this open loop is short enough and does not self-intersect, then...</p>
<pre><code>Ｆ³⊞υ⁺ι⟦⊖κ⟧
</code></pre>
<p>... add left, straight and right to the walk and save the resulting walks to the list of walks to process.</p>
<pre><code>»Ｉⅈ
</code></pre>
<p>Output the final number of polyominoes found.</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, 275 bytes</h1>

<pre class="lang-none prettyprint-override"><code>f=-&gt;n,p=[[2]],s=1{q=[]
z=[w=n*3,-1,-w,1]
p.map{|a|(s*4).times{|i|r=[];g=h=1
c=a+[d=z[i%4]+a[i/4]]
8.times{|j|h+=(g-g=2*a.count(d-z[j/2]+j%2*z[j/2-1]))**2
c=c.map!{|k|j%2&lt;1?k-k%w*2:k%w*w+k/w}.sort!.map{|m|m-c[0]+n}
r&lt;&lt;c*1}
a.any?(d)||h&gt;10||q&lt;&lt;r.min}}
s&lt;n ?f[n,q&amp;q,s+1]:p.size}
</code></pre>
<p><a href="https://tio.run/##NY7NboMwAIPveYr2wAT5o0k5TB0pDxLlkNECAZECoUKF8OyMbtrFsuRPtofn92vbCkGuFndCSq4UdoItvZAKzEJOwsIzJgyTCTMFOtrqbvHahw4mER1Ne3eLN37Y8a9SVIKBXGgkb2KWJkgU0tLEiVLg85@tfYVEWJJScKhp/njaMbyRWdYxV6gOOPy1hKkogpDvbfl78rj4xu9pyrKGNMEE@eWtE2riaaXuMYzHv2etb0kuTwrZFQxpmkO2Ak21fWXhLfK@urKT932aDrQ1dl2BS@0hK6TF/UePHWLq0lFn5vu6dYdCMqa2Hw" rel="nofollow noreferrer" title="Ruby – Try It Online">Try it online!</a></p>
<p>Adapted from my answer to a <a href="https://codegolf.stackexchange.com/a/246311/15599">previous question</a> about polyiamonds (shapes composed of equilateral triangles).</p>
<p>This is a recursive function taking required size of polyominos <code>n</code> as an argument, plus two optional arguments: an array <code>p</code> of smaller polyominos and <code>s</code> the number of squares in the smaller polyominos. The initial default value of these corresponds to the seed polyomino of just one square.</p>
<p>First golfed version, runs a little slower than the first working version below due to certain checks being carried out late in the algorithm to avoid <code>()</code>, resulting in a lot of unnecessary calculation. In particular, all next generation polyominos are calculated before a check is made to see whether we have already reached the required value of <code>n</code>, as the decision to return the correct value or recurse further is made at the end of the function. Similarly detection of new squares overlapping old ones is not done until sufficient info has been gathered to find if a hole has been created.</p>
<p>The polyomino is represented as an array of integers of the form <code>d=x+wy</code>. The board is of width <code>3*n</code> in the x direction to avoid overlaps and is effectively infinite in the y direction.</p>
<p>The main new feature is the avoidance of holes. The polyomino is grown by adding a new square beside any existing square in any of the four orthogonal directions. The new square is rejected if it bridges across to another existing square. This is detected by walking around the 8 spaces adjacent to the new square and counting the number of changes from full square to empty square and vice versa. There should be exactly 2 changes. If there are more, the new square is bridging and the polyomino is rejected.</p>
<p>The golfed version maintains a value of 0 or 2 in <code>g</code> for the previous square and calculates a new value each iteration, adding the square of the difference to <code>h</code> each time. <code>h</code> therefore increments by 4 each time a change is detected. Because there are an even number of changes the idealised value of <code>h</code> would be a multiple of 8. In the golfed version we take advantage of this by initialising <code>g</code> and <code>h</code> to a fuzzy value of <code>1</code>. The first increment of <code>h</code> is therefore always to 2, followed by 1-4 proper change detections. If there are more than 2 proper change detections, <code>h</code> exceeds 10 and the polyomino is rejected.</p>
<p>At the same time, the polyomino is alternately reflected 8 times orthogonally (by subtracting <code>x*2</code>=<code>k%w*2</code>) and diagonally (by swapping x and y <code>k%w*w+k/w</code>) to generate all 8 possible orientations.</p>
<p>If the polyomino is not rejected, it is added to the new list of larger polyominos <code>q</code>.</p>
<p><strong>Commented code</strong></p>
<pre class="lang-none prettyprint-override"><code>f=-&gt;n,p=[[2]],s=1{                  #Call function with desired n, seeded with single square
q=[]                                #Make an array for next generation polyominos
z=[w=n*3,-1,-w,1]                   #w=width of board. z=array of 4 orthogonal directions
p.map{|a|(s*4).times{|i|            #Try extending each existing polyomino in p, from each square in 4 directions
  r=[];g=h=1                         #Make array to hold all orientations of new shape. Initialise g&amp;h for hole detection
  c=a+[d=z[i%4]+a[i/4]]              #Make new polyomino c by extending from a[i/4] in direction i%4 adding square d  
  8.times{|j|h+=                          #Loop 8 times for relections and hole detection
(g-g=2*a.count(d-z[j/2]+j%2*z[j/2-1]))**2 #Walk around 8 neighbours of square d, update g, and if it changed increment h
    c=c.map!{|k|j%2&lt;1?k-k%w*2:k%w*w+k/w}. #Reflect c orthogonally or diagonally depending on value of j%2
    sort!.map{|m|m-c[0]+n}                #sort &amp; normalise the elements so that the lowest=n putting it in middle of board
    r&lt;&lt;c*1}                               #add current relection of c to r. We will select the lexically lowest value of c
  a.any?(d)||h&gt;10||q&lt;&lt;r.min}}        #If new square d doesn't overlap existing square &amp; h shows no bridge, add new shape to q
s&lt;n ?f[n,q&amp;q,s+1]:p.size}           #if s==n return the size of existing list p. 
                                    #If s&lt;n, take precalculated list of next size polyominos q, eliminate duplicates and recurse
</code></pre>
<h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, 350 bytes</h1>

<pre class="lang-none prettyprint-override"><code>f=-&gt;n,p=[[2]],s=1{z=[w=n*3,w-1,-1,~w,-w,1-w,1,-~w];p p.size
#p.map{|a|t=(?.*~-w+$/)*s;a.map{|k|t[k]=?#};puts t,$/}
s&lt;n&amp;&amp;(q=[]
p.map{|a|(s*4).times{|i|d=z[i%4*2]+a[i/4]
a.index(d)||(c=a+[d];r=[];g=a.count(d-~w);h=0
8.times{|j|c=c.map!{|k|j%2&lt;1?k-k%w*2:k%w*w+k/w}.sort!.map{|m|m-(c[0])+n};r&lt;&lt;c*1
h+=g^g=a.count(d+z[j])}
h&lt;3&amp;&amp;q&lt;&lt;r.min)}}
f[n,q&amp;q,s+1])
}
</code></pre>
<p><a href="https://tio.run/##TY7dboIwGIbPexUalVBaiqAHy6DzQpou6cCfSqhAa7ph660ziXFZ8n7vyZc879Nfv37G8UDjD4VbyljGOdY0vQ2UWaqiDbZxih@5WxxbnE6H47vleTtriZbDHixa0oj25oQzNNyR6B5btExgpHPxfNTOsJrT3cLn7dXomcHLxANdqCAIO8o4@AOEOtpCYmSz1zcnXUUHJlfbKONIMJlsORBEqmr/HVbQubCkArGK5/2DkR@pIOXlqkxYPfRgfqJr8PZCnV1Jy2lkPtmcV1mR7uq4Xtkoe5/aojqxnuhLb@ZPl8Y1cViyNYdI@bwvijJKwQnR4@e/ITSwM4cenIpNEHRF0ZNGKug9ODCFu6DDGqUcAj8eWJrx8Rc" rel="nofollow noreferrer" title="Ruby – Try It Online">Try it online!</a></p>
<p>First working version  This version prints the full sequence from 1 to n. It will even print the polyominos themselves if you uncomment the second line.</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://www.python.org" rel="nofollow noreferrer">Python</a>, 686 bytes</h1>
<p>Python port of formatted <a href="https://tio.run/##XVLRcoIwEHznK9YHHRBIDfrQKdh@SCadoaIVHRBBh9aqv043OKViZi7J3e1tNpeUx4/vplnN/dfcQ4E5lAWoQFvaQ0VX4oeBk0nUnHKMMfVQw4f04NOuNVeaZMgs9K61DllUoBBVelpyWyFi6WgEe2@YNBgzoxBZXLQnmHFGTLMrnjFzxCHNllWXM9mUlrD@pFIMMSMs0HAR033CTHfIWKR5svyyEwdn8i1YEhOnEh2ibM8P8WmCYrE75gc7ofRr7YRYMzhBx/Ms8CjiJmRDM6wLI3/Qz5r8tsUMEfDaEm/0fdqQbaNkvHT7mqq21F73GC6i2pWHQa81/9xZaz6vpSbaIUHeLw57bokootQxZC@8hjtnC94f2uCytRvt3EEv1n1RhKl5xL0hLUWW5n/QG@w2rxR/0h6EmR/kQpLwYq2UDHTT/AI" rel="nofollow noreferrer">Ruby code by @Level River St</a></p>
<hr />
<p>Golfed version. <a href="https://ato.pxeger.com/run?1=jVJLTsMwEJVYcgpvKtlN0pK0i6quF3bSQr8cwDISAhciFceK3UU3vQgbNrDkQJwGO2mgqF3wFEvxjN-bN_a8fuidfS7U29v71q6jwdfF5w0p79WTvHyUa3ANVajJqlAyNCRGw0vgkK-BBrkBPjzUhPNEiCpBiWr38JRwGtIoDt23p2FEw9ivMNpTgXWZKws3UkGNUKNmRqpW9kgJFz-bdVGCDOQK6N8DTXzm4zfQtPvob9JjTKZ81uq3ExFkfNbt9sXJEVd4DFRhvUx2quDBSBbwscBz5wlPSNZ5KLbO_ti1gvCCXJ0leW_L2tvgjLOj8stWMoqHjHAWsRZtJxWVeSo7tdtAboysOI5BA9bt0n_RWMcUpYUIOyqNGL8SgaqItCbieedea6keIXNd6h1ECK_I5LjrYMqXwvUdkNXd5Gwh19Ni1BvekpdcwTnCaaNpt3oj4e3hyT1SssmNhUZamLpS7tWrPUU_nlKBS2m3paqmMA1NENf06gYOKV2P7fs1jBNU_zej_A0" rel="nofollow noreferrer">Attempt This Online!</a></p>
<pre class="lang-python prettyprint-override"><code>H=range
def G(n,p=None,s=1):
    if p is None:p=[[2]]
    A=n*3;I=[A,A-1,-1,~A,-A,1-A,1,-~A];print(len(p))
    if s&lt;n:
        C=[]
        for D in p:
            for J in H(s*4):
                E=I[J%4*2]+D[J//4]
                if E not in D:
                    B=D+[E];K=[];F=D.count(E-~A);L=0
                    for M in H(8):
                        if M%2&lt;1:B=[B-B%A*2 for B in B]
                        else:B=[B%A*A+B//A for B in B]
                        B.sort();B=[A-B[0]+n for A in B];K.append(B.copy());N=F;F=D.count(E+I[M]);L+=N^F
                    if L&lt;3:O=min(K);C.append(tuple(O))
        C=list(set(C));C=[list(A)for A in C];return G(n,C,s+1)
    else:return p
</code></pre>
<p>Ungolfed version. <a href="https://ato.pxeger.com/run?1=jVXNbtswDD7t4qcgEAyQl5_WaQ_FsJyGXTegWIEBhjcrthwriSVFkuOlh77ILr1sD7Vn2WGk3TQNEmMjYFikyI_UJ5r-8cvsfKnV4-PP2hfjm9-v_uSigIKpEZjZR63ECNwsCt8GgCILMCAdkL2zkBiYQRxPk6S1NKgpeANXrXZPe80IrWOIRjDG5wHVMT4RmuiF2kOTBK27sVJ5thaKmTAEGMCHTS23HA0evIbUgJk4eS9SkApu6_ku2Nfl4B2oQ00byps8q4W2wCnGHFz2dkl2y9VCMId1X4fHLiQ5ot3HTMJr3EafaQJD4LGEiwu4Tk7csZwclPYEzE_RSDJE5AgS56fhJPa4_peyoNBJpmtkKkcOH5rwrF-Jfpdnd-jUy8Opb86ceC8D-IxODiMqSLMU5tyJHLQCXwrAi6kF6ALSZdqLgGQskbcp3k_Un4eEOIlXeCK2woCmJbqtdUW1ZufZIBFrJ_4D-gDbIPOo4e2h-jJDL0g2cdp6dp7p5wwVFp_Fl9QdqsWt_lG5nXBjhMpZhhdqdiwM-0sYwJ3JuReQlik00pfw5dMtsW-s2EpdO0gXKXCFrScaWvcieVHRN7vodThusSH2_jLpP3oJw1mH-RUxz7phE5TYAFf9t1RJ9Y2aHt_M9ufa7AnztVkL1kZ1k-LOCWiNNCgqvhIgPZTclXyONroMJzxoIyz3Uit3KHQAt6LSWwE5hssMKXYw30Gm1VZYL9WCEHkbTuzOebbqLGvp_NHEIQNDP7YJw-NR1O5IJKnrN1pRa2wSSv--y9SV754TUMyLMq3wtVXdaN7gVMZ7ibosx_3_5GeCIMD5-V1kNfYMfa5FrTI6etc8CsuKpoEVrl57XBcsmobdT-DpX7D_J_wF" rel="nofollow noreferrer">Attempt This Online!</a></p>
<pre class="lang-python prettyprint-override"><code>def f(n, p=None, s=1):
    if p is None:
        p = [[2]]
    w = n * 3
    z = [w, w - 1, -1, ~w, -w, 1 - w, 1, -~w]

    print(len(p))  # Equivalent to `p p.size` in Ruby

    if s &lt; n:
        q = []
        for a in p:
            for i in range(s * 4):
                d = z[(i % 4) * 2] + a[i // 4]
                if d not in a:
                    c = a + [d]
                    r = []
                    g = a.count(d - ~w)
                    h = 0
                    for j in range(8):
                        # Transform `c` based on the value of `j`
                        if j % 2 &lt; 1:
                            c = [k - (k % w) * 2 for k in c]
                        else:
                            c = [(k % w) * w + (k // w) for k in c]

                        c.sort()
                        c = [m - c[0] + n for m in c]
                        r.append(c.copy())

                        # Update `h` with XOR of previous `g` and new `g`
                        temp = g
                        g = a.count(d + z[j])
                        h += temp ^ g

                    if h &lt; 3:
                        min_r = min(r)
                        q.append(tuple(min_r))  # Use tuple to make it hashable for set operations

        # Remove duplicates by converting to a set and back to a list
        q = list(set(q))
        q = [list(item) for item in q]  # Convert tuples back to lists

        return f(n, q, s + 1)
    else:
        return p


# Execute the function with n = 12
result = f(12)
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/277493/">277493</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




