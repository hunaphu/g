<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::231022</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>019</td><td>Pip P</td><td>210709T043812Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/231135#231135">DLosc</a></td></tr>
<tr d-ix="1"><td>009</td><td>APLDyalog Unicode</td><td>240214T092519Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/270066#270066">Mukundan</a></td></tr>
<tr d-ix="2"><td>005</td><td>flax</td><td>240218T040014Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/270130#270130">zoomlogo</a></td></tr>
<tr d-ix="3"><td>nan</td><td>Python 3 with numpy</td><td>210706T161900Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/231055#231055">m90</a></td></tr>
<tr d-ix="4"><td>062</td><td>Pari/GP</td><td>211112T070107Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/237204#237204">alephalp</a></td></tr>
<tr d-ix="5"><td>018</td><td>BQN</td><td>211114T134933Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/237292#237292">frasiyav</a></td></tr>
<tr d-ix="6"><td>066</td><td>Python 3 + numpy</td><td>211113T230151Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/237280#237280">loopy wa</a></td></tr>
<tr d-ix="7"><td>014</td><td>Japt</td><td>210706T170502Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/231058#231058">Shaggy</a></td></tr>
<tr d-ix="8"><td>048</td><td>ARM A32 machine code</td><td>210729T160314Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/232936#232936">m90</a></td></tr>
<tr d-ix="9"><td>042</td><td>Julia 1.0</td><td>210713T132401Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/231299#231299">MarcMush</a></td></tr>
<tr d-ix="10"><td>084</td><td>Python 3.8 + numpy</td><td>210708T035454Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/231102#231102">Ryan McC</a></td></tr>
<tr d-ix="11"><td>032</td><td>Wolfram Language Mathematica</td><td>210706T034333Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/231029#231029">att</a></td></tr>
<tr d-ix="12"><td>072</td><td>JavaScript ES6</td><td>210707T023538Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/231074#231074">tsh</a></td></tr>
<tr d-ix="13"><td>005</td><td>Jelly</td><td>210706T194334Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/231062#231062">lynn</a></td></tr>
<tr d-ix="14"><td>009</td><td>Jelly</td><td>210706T055921Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/231032#231032">hyperneu</a></td></tr>
<tr d-ix="15"><td>061</td><td>Haskell</td><td>210706T191724Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/231061#231061">lynn</a></td></tr>
<tr d-ix="16"><td>009</td><td>Jelly</td><td>210706T000935Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/231025#231025">Jonathan</a></td></tr>
<tr d-ix="17"><td>049</td><td>R</td><td>210706T094021Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/231037#231037">Dominic </a></td></tr>
<tr d-ix="18"><td>055</td><td>R</td><td>210706T084403Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/231035#231035">Kirill L</a></td></tr>
<tr d-ix="19"><td>064</td><td>Ruby</td><td>210706T113849Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/231044#231044">G B</a></td></tr>
<tr d-ix="20"><td>113</td><td>Python 3 + numpy</td><td>210706T132015Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/231048#231048">ovs</a></td></tr>
<tr d-ix="21"><td>088</td><td>Haskell</td><td>210706T121646Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/231046#231046">flawr</a></td></tr>
<tr d-ix="22"><td>2119</td><td>J</td><td>210706T091615Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/231036#231036">xash</a></td></tr>
<tr d-ix="23"><td>067</td><td>Octave/MATLAB</td><td>210706T115256Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/231045#231045">flawr</a></td></tr>
<tr d-ix="24"><td>018</td><td>Charcoal</td><td>210706T004922Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/231027#231027">Neil</a></td></tr>
<tr d-ix="25"><td>079</td><td>JavaScript ES6</td><td>210705T235200Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/231023#231023">Arnauld</a></td></tr>
<tr d-ix="26"><td>081</td><td>Python 2</td><td>210706T083953Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/231033#231033">tsh</a></td></tr>
<tr d-ix="27"><td>033</td><td>J</td><td>210706T043344Z</td><td><a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix/231030#231030">Jonah</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/dloscutoff/pip" rel="nofollow noreferrer">Pip</a> <code>-P</code>, 19 bytes</h1>
<pre><code>$+{TBg}FB4*^21MC Ea
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m724ILNgWbSSboBS7IKlpSVpuhabVbSrQ5zSa92cTLTijAx9nRVcEyEyUAVLo5WM4aoB" rel="nofollow noreferrer">Attempt This Online!</a></p>
<h3>Explanation</h3>
<p>Inspired by <a href="https://codegolf.stackexchange.com/questions/231022/recursive-z-matrix#comment529704_231022">Neil's comment</a> about interleaving bit patterns, we can simply map the x and y coordinates to the right value (example x = 5, y = 9):</p>
<pre><code>5    101    0 1 0 1
9   1001   1 0 0 1    10010011   147
</code></pre>
<p>We're not going to use Pip's <code>WV</code> operator to do the interleaving, since it works left-to-right and doesn't fill in with zeros; instead, observe that an equivalent formula is to convert to base 4, multiply the y value by 2, and sum:</p>
<pre><code>5    101      1 0 1      10001 (2) =  101 (4) =  17 (10)
9   1001   1 0 0 1    10000010 (2) = 2002 (4) = 130 (10)   147
</code></pre>
<p>So:</p>
<pre><code>$+{TBg}FB4*^21MC Ea
                 Ea   2^input
              MC      Map this function to a grid of coordinate pairs of that size:
  {TBg}                Convert each coordinate to binary
       FB4             Treat as base 4 and convert back to decimal
          *            Multiply by
           ^21         list containing 2 and 1
                       (multiplying the row by 2 and the column by 1)
$+                     Sum
</code></pre>
<p>The <code>-P</code> flag gives the matrix a readable output format; <code>-p</code> or <code>-S</code> would also work.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://dyalog.com" rel="nofollow noreferrer">APL(Dyalog Unicode)</a>, <sup><s>10</s></sup> 9 bytes <sup><a href="https://github.com/abrudz/SBCS" rel="nofollow noreferrer">SBCS</a></sup></h1>
<pre><code>⊢⌸2&lt;,⍳⎕⍴4
</code></pre>
<p><a href="https://razetime.github.io/APLgolf/?h=AwA&amp;c=e9S16FHPDiMbnUe9mx/1TX3Uu8UEAA&amp;f=AwA&amp;i=S@My5FJX50rjMoJQxgA&amp;r=tio&amp;l=apl-dyalog&amp;m=tradfn&amp;n=f" rel="nofollow noreferrer">Try it on APLgolf!</a></p>
<pre><code>⊢⌸2&lt;,⍳⎕⍴4­⁡​‎‎⁪⁡⁪⁠⁪⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁡⁪‏‏​⁡⁠⁡‌⁢​‎‎⁪⁡⁪⁠⁪⁢⁢⁪‏‏​⁡⁠⁡‌⁣​‎⁪⁪⁠‎⁪⁡⁪⁠⁪⁢⁡⁪‏‏​⁡⁠⁡‌⁤​‎‎⁪⁡⁪⁠⁪⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁪‏‏​⁡⁠⁡‌⁢⁡​‎‎⁪⁡⁪⁠⁪⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁪‏‏​⁡⁠⁡‌­
      ⎕⍴4  # ‎⁡4 repeated n times
     ⍳     # ‎⁢create a n-dimensional array with shape [4, 4, ..., 4] where value equals index
    ,      # ‎⁣flatten
  2&lt;       # ‎⁤greater than 2 (vectorized)
⊢⌸         # ‎⁢⁡‎⁢⁡group by value and return indices for each group
💎
</code></pre>
<p>Created with the help of <a href="https://vyxal.github.io/Luminespire" rel="nofollow noreferrer">Luminespire</a>.</p>
</div>
<div id="pu2" class="pu"><h1>flax, 5 bytes</h1>
<pre><code>G&gt;1ṗ4
</code></pre>
<p>Port of <a href="https://codegolf.stackexchange.com/a/231062/103854">@lynn's Jelly answer</a>.</p>
<p>Since the lastest version isn't on ATO, here is an image of the program running (in the REPL).
<a href="https://i.sstatic.net/hFD7z.png" rel="nofollow noreferrer"><img src="https://i.sstatic.net/hFD7z.png" alt="flax repl" /></a></p>
<h2>Explanation</h2>
<p>It is same as the jelly answer.</p>
<pre><code>G&gt;1ṗ4
G      &quot; group by values
 &gt;1    &quot;   greater than 1
   ṗ4  &quot;   nth cartesian power of [0,1,2,3]
</code></pre>
</div>
<div id="pu3" class="pu"><h1>Python 3 with numpy, <del>91</del> <del>87</del> <del>74</del> <del>70</del> <del>69</del> 67 bytes</h1>
<pre>lambda n:c_[s:=(c_[:1&lt;&lt;n]&amp;(b:=1&lt;&lt;r_[:n]))@b]*2+s
from numpy import*</pre>
<p><a href="https://ato.pxeger.com/run?1=m72soLIkIz9vweI025ilpSVpuhY3nXMSc5NSEhXyrJLjo4utbDWAlJWhjU1erJpGkpUtkFUEFMiL1dR0SIrVMtIu5korys9VyCvNLahUyMwtyC8q0YIYtbqgKDOvRCNNw1hTEyKyYAGEBgA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p><code>c_[:1&lt;&lt;n]</code> produces an array of the numbers 0 (inclusive) to 2<sup>n</sup> (exclusive), vertically. <code>r_[:n]</code> produces 0 (inc.) to n (exc.), horizontally, and the left shift makes the corresponding powers of 2, saved in <code>b</code>. The bitwise AND, with broadcasting, produces a table of values, splitting the numbers into their constituent bits. The matrix product (<code>@</code>) is equivalent to taking the dot product of each broken-down number with <code>b</code>; this squares each nonzero bit, changing powers of 2 into powers of 4, and adds them back up, producing a horizontal sequence 0, 1, 4, 5, 16, 17, 20, 21, ..., which is saved in <code>s</code>. <code>c_</code> makes a vertical version of that sequence, which is doubled and added to the original sequence, which (by broadcasting) produces a table of sums, which is the required result.</p>
<hr />
<p>Previously:</p>
<pre><code>from numpy import*
lambda n:(s:=vander([4],8)@unpackbits(mat(r_[:1&lt;&lt;n],uint8),0))+s.T*2
</code></pre>
<p><code>r_[:1&lt;&lt;n]</code> produces 0 (inc.) to 2<sup>n</sup> (exc.). It is passed to <code>mat</code> (&quot;Interpret the input as a matrix&quot;), which in particular makes it 2-dimensional, while also changing its type to <code>uint8</code>, which is necessary for the next function <code>unpackbits</code>, which breaks the numbers down into their binary representations, across the added dimension. <code>vander([4],8)</code> produces an array of powers of 4, which in the <code>@</code> (matrix multiplication) gets dot-producted with each binary vector, producing a similar <code>s</code> (transposed differently), and the rest is similar.</p>
</div>
<div id="pu4" class="pu"><h1><a href="http://pari.math.u-bordeaux.fr/" rel="nofollow noreferrer">Pari/GP</a>, 62 bytes</h1>
<pre><code>n-&gt;matrix(2^n,,i,j,(g=k-&gt;fromdigits(binary(k-1),4))(i)*2+g(j))
</code></pre>
<p><a href="https://tio.run/##DccxDoAgDADArzi2WgbRFZ9igjE0hYCkMujr0duuehXDtYfB9WK27JvKA3YvREKRgF0yW9Arn8LSbjikeH0hmRlpRQTB0U4MEbFXldIqBFj@fA" rel="nofollow noreferrer" title="Pari/GP – Try It Online">Try it online!</a></p>
</div>
<div id="pu5" class="pu"><h1><a href="https://mlochbaum.github.io/BQN/" rel="nofollow noreferrer">BQN</a>, 18 <a href="https://github.com/mlochbaum/BQN/blob/master/commentary/sbcs.bqn" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>{(⍉∾⍉+·≠⥊)⍟2⍟𝕩≍≍0}
</code></pre>
<p><a href="https://mlochbaum.github.io/BQN/try.html#code=RuKGkHso4o2J4oi+4o2JK8K34omg4qWKKeKNnzLijZ/wnZWp4omN4omNMH0KCkbCqDDigL8x4oC/MuKAvzM=" rel="nofollow noreferrer">Try it here.</a></p>
<p>How it works:</p>
<pre><code>{(⍉∾⍉+·≠⥊)⍟2⍟𝕩≍≍0}
              ≍≍0  # Starting from a rank 2 array containing 0
            ⍟𝕩     # apply the preceding function 𝕩 times where 𝕩 is the input
  ⍉∾               # The transposed array joined to
    ⍉+·≠⥊          # the transposed array plus the number of elements
 (       )⍟2       # applied twice
</code></pre>
</div>
<div id="pu6" class="pu"><h1><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python 3</a> + numpy, 66 bytes</h1>

<pre class="lang-python prettyprint-override"><code>from numpy import*
f=lambda m:c_[m and(f(m-.5),4**m//2+f(m-.5))].T
</code></pre>
<p><a href="https://tio.run/##K6gsycjPM/7/P60oP1chrzS3oFIhM7cgv6hEiyvNNicxNyklUSHXKjk@OlchMS9FI00jV1fPVFPHREsrV1/fSBvK14zVC/lfUJSZVwJUYaCpyQVjGyKxjZDYxpqa/wE" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
<p>Mostly straight-forward recursion. Splits the 2x2 update into 2 1x2 updates with intermittent transpose.</p>
<h1><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python 3</a> + numpy, 68 bytes</h1>

<pre class="lang-python prettyprint-override"><code>from numpy import*
f=lambda m:m and log2(kron(4**f(m-.5),c_[1:3])).T
</code></pre>
<p><a href="https://tio.run/##TcaxCoMwEADQ3a@48S6oqKmL0L/oJiJpJa3o3YUQB78@nQTf9MKZfio2Zx@VQQ4OJ6wcNCZT@Ofu@L044IHByQK7fjvcogo@jPHIVd1T@ZnHdrATUf3KIa6S0GNDVFxvb@9ut0T5Dw" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
<p><em>Just noticed that @Kirill L.'s R answer uses the exact same idea.</em></p>
<p>By componentwise exponentiating adding in the original problem becomes multiplying so friend Kronecker can do the heavy lifting for us.</p>
<p>Downside: will get numerically inaccurate pretty fast.</p>
</div>
<div id="pu7" class="pu"><h1><a href="https://github.com/ETHproductions/japt" rel="nofollow noreferrer">Japt</a>, 14 <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" rel="nofollow noreferrer">bytes</a></h1>
<p>Port of <a href="https://codegolf.stackexchange.com/a/231033/58974">tsh's Python solution</a>.</p>
<pre><code>2pU Ç¤n4
£Ë+XÑ
</code></pre>
<p><a href="https://petershaggynoble.github.io/Japt-Interpreter/?v=1.4.6&amp;code=MnBVIMekbjQKo8srWNE&amp;footer=VmMg%2bSDyMnBOKW24&amp;input=MwotUg" rel="nofollow noreferrer">Try it</a></p>
</div>
<div id="pu8" class="pu"><h1>ARM A32 machine code, 48 bytes</h1>
<pre><code>e3a0c000 e1a0215c e1b03152 112fff1e
e02c3112 ec432b10 f2800e00 f2810590
f2211110 f480180d e28cc001 eafffff4
</code></pre>
<p>Following the <a href="https://github.com/ARM-software/abi-aa/blob/2bcab1e3b22d55170c563c3c7940134089176746/aapcs32/aapcs32.rst" rel="noreferrer">AAPCS</a>, this takes in r0 the address of an <em>array</em> of <em>array</em>s of 32-bit integers to be filled with the result, and takes n in r1.</p>
<p>Assembly:</p>
<pre><code>.section .text
.code 32
.global zm
zm:
    mov r12, #0               @ Initialise counter to 0
loop:
    asr r2, r12, r1           @ Shift counter right by n, to obtain the top half
    asrs r3, r2, r1           @ Shift that right by n again, to check for ending (2^2n)
    bxne lr                   @ If so, return
    eor r3, r12, r2, lsl r1   @ Exclusive-or cancels out the top half, to obtain the bottom half
    vmov d0, r2, r3           @ Place the two halves into a 64-bit SIMD&amp;FP register
    vmull.p8 q0, d0, d0       @ Multiply by itself as polynomials over GF(2);
               @ because this is a ring of characteristic 2, (a+b)^2 = a^2 + b^2 holds,
               @ thus squaring doubles each exponent in the polynomial, spreading out the bits.
               @ Results go into Q0, which is also D0 and D1.
    vshl.i64 d0, #1           @ Shift the squared top half left by 1 ...
    vorr d1, d0               @ ... and combine by OR with the bottom half
    vst1.32 {d1[0]}, [r0]!    @ Place the result into memory, advancing the pointer
    add r12, #1               @ Increment the counter
    b loop                    @ Repeat
</code></pre>
<p>(This should work on v7 or later from what I can tell, but in the testing setup I'm using (similar to <a href="https://codegolf.stackexchange.com/questions/175236/sum-square-difference/231078#231078">here</a>), it gives 'instruction not supported' errors on versions lower than v8.4, which doesn't seem right.)</p>
</div>
<div id="pu9" class="pu"><h1 id="julia-1.0-42-bytes-r9du"><a href="http://julialang.org/" rel="nofollow noreferrer">Julia 1.0</a>, 42 bytes</h1>
<pre><code>!x=(x-=1)&lt;0||(~n=n*2^2x.+!x;[~0 ~1;~2 ~3])
</code></pre>
<p><a href="https://tio.run/##yyrNyUw0rPj/X7HCVqNC19ZQ08agpkajLs82T8sozqhCT1uxwjq6zkChztC6zkihzjhW839KZnFBTmKlhqKx5n8A" rel="nofollow noreferrer" title="Julia 1.0 – Try It Online">Try it online!</a>
(one-indexed)</p>
</div>
<div id="pu10" class="pu"><h1>Python 3.8 + numpy, <s>85</s> 84 bytes</h1>
<pre class="lang-python prettyprint-override"><code>import numpy;z=lambda n:n and numpy.block([[m:=z(n-1),m+(k:=4**~-n)],[m+2*k,m+3*k]])
</code></pre>
<p>Not as clever as some of the other python ones, but shorter than the other python 3 ones. Also 0 returns a scalar instead of a list, not sure if that's allowed.</p>
</div>
<div id="pu11" class="pu"><h1><a href="https://www.wolfram.com/wolframscript/" rel="nofollow noreferrer">Wolfram Language (Mathematica)</a>, <s>49</s> 32 bytes</h1>
<pre><code>PositionIndex@Tuples[0|0|1|1,#]&amp;
</code></pre>
<p><a href="https://tio.run/##y00syUjNTSzJTE78n2b7PyC/OLMkMz/PMy8ltcIhpLQgJ7U42qDGoMawxlBHOVbtf0BRZl6JQ5qDa3JGvoOyWl1wcmJeXVBiXnpqtIGOcex/AA" rel="nofollow noreferrer" title="Wolfram Language (Mathematica) – Try It Online">Try it online!</a></p>
<p>Returns an <code>Association</code> where the values correspond with rows of the matrix (associations are ordered). For a traditional list-of-lists output, prepend <code>List@@</code> (+6 bytes).</p>
<p>Port of Lynn's <a href="https://codegolf.stackexchange.com/a/231062/81203">Jelly solution</a>.</p>
<hr />
<p>Older solution:</p>
<pre><code>Outer[#+##&amp;,t=#~FromDigits~4&amp;/@{0,1}~Tuples~#,t]&amp;
</code></pre>
<p><a href="https://tio.run/##BcGxDkAwEADQj7mkiyYIq6QDVoJNDJemaKIldSZxv17vOaTdOCSrMa5V7B4yYYYEQEiqgNtwutpulm4uRareTOYfT891mJtB0iJiH6ynVK2q0fupQPCo0fOAfjNzJosl/g" rel="nofollow noreferrer" title="Wolfram Language (Mathematica) – Try It Online">Try it online!</a></p>
</div>
<div id="pu12" class="pu"><h1>JavaScript (ES6), 72 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>f=(n,a=[0])=&gt;n?f(n-1,a.flatMap(x=&gt;[x*=4,x+1])):a.map(y=&gt;a.map(x=&gt;x+2*y))
</code></pre>
<p><a href="https://tio.run/##JYlBCoMwEEX3nmKWGRODFle1k56gJxAXgzUlxSaiUiKlZ08DhQ/v8f6T37yNq1v2yof7lCzlCa@Y@npAMv5qha8axdrOvN94EZFMH0tqVZTNgHhm/cr1IPOXfEd5Kg/EZMMKwgFB3YGDC0GbKSXCpwAYg9/CPOk5PIQVDrErvukH" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<p>Use the idea from <a href="https://codegolf.stackexchange.com/users/3852/lynn">Lynn</a>'s <a href="https://codegolf.stackexchange.com/a/231061/44718">Haskell answer</a> which saves many bytes on generating the list for iterate. Using base conversion as what my Python answer do will <a href="https://tio.run/##HYpBDoIwEADvvGJPZLdoVcINt4nvMMY0CGQNtKQYQ6O@vSqnmUzmbp92boJMj63ztzZ1nBwbtHzWWp9CsBFLpRxd9Ggn7BmvGyE2kueSH96V6v9hVxLROkQ2dpWFzVKUKhKlzgdAAYZ9DQJHhurHoiB4ZQCNd7MfWj34HjsUojr7pC8" rel="nofollow noreferrer">make it much longer (79 bytes)</a>.</p>
</div>
<div id="pu13" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="noreferrer">Jelly</a>, 5 bytes</h1>
<pre><code>4ṗ&gt;2Ġ
</code></pre>
<p><a href="https://tio.run/##y0rNyan8/9/k4c7pdkZHFvw/3O7@/78xAA" rel="noreferrer" title="Jelly – Try It Online">Try it online!</a> Neil saved a byte. Thanks!</p>
<pre><code>4ṗ       n-th Cartesian power of [1,2,3,4]
  &gt;2     Replace 1,2,3,4 with 0,0,1,1
    Ġ    Group indices by values
</code></pre>
<p>For n=2, <code>4ṗ&gt;2</code> generates a list of 16 pairs:</p>
<pre><code> 1: [0, 0]
 2: [0, 0]
 3: [0, 1]
 4: [0, 1]
 5: [0, 0]
 6: [0, 0]
 7: [0, 1]
 8: [0, 1]
 9: [1, 0]
10: [1, 0]
11: [1, 1]
12: [1, 1]
13: [1, 0]
14: [1, 0]
15: [1, 1]
16: [1, 1]
</code></pre>
<p>Then <code>Ġ</code> turns this into a list of lists:</p>
<ul>
<li>all indices where the value is <code>0 0</code>: namely <code>[ 1,  2,  5,  6]</code>,</li>
<li>all indices where the value is <code>0 1</code>: namely <code>[ 3,  4,  7,  8]</code>,</li>
<li>all indices where the value is <code>1 0</code>: namely <code>[ 9, 10, 13, 14]</code>,</li>
<li>all indices where the value is <code>1 1</code>: namely <code>[11, 12, 15, 16]</code>.</li>
</ul>
<p>The result is a Z-matrix.</p>
<h2>Why does this work?</h2>
<p>Suppose we bump the input up to <span class="math-container">\$n=3\$</span>. How does our output compare to that for <span class="math-container">\$n=2\$</span>?</p>
<p>Let's call <code>4ṗ&gt;2</code> a function <span class="math-container">\$f\$</span>. The list of 16 pairs above is the output of <span class="math-container">\$f(2)\$</span>. By definition of the Cartesian power, <span class="math-container">\$f(3) = [0,0,1,1] \times f(2)\$</span> =</p>
<pre><code>  [[0] + x for x in f(2)]     (indices  1..16)
+ [[0] + x for x in f(2)]     (indices 17..32)
+ [[1] + x for x in f(2)]     (indices 33..48)
+ [[1] + x for x in f(2)]     (indices 49..64)
</code></pre>
<p>There are now 8 values for <code>Ġ</code> to group the indices by, ranging from <code>[0,0,0]</code> to <code>[1,1,1]</code>.</p>
<p>All indices in <code>1..32</code> end up in the first four groups, and because we repeated <code>[[0] + x for x in f(2)]</code> twice, <code>a[i+16]</code> is always in the same group as <code>a[i]</code>. Then, all indices in <code>33..64</code> end up in the last four groups, and their relative order is the same as the first half of the list (the only difference is they have <code>1</code> instead of <code>0</code> in front). Within each quadrant, the order is the same as it was in <code>f(2)</code>. So we get:</p>
<pre><code>[0, 0, 0]:  1  2  5  6 17 18 21 22
[0, 0, 1]:  3  4  7  8 19 20 23 24
[0, 1, 0]:  9 10 13 14 25 26 29 30
[0, 1, 1]: 11 12 15 16 27 28 31 32

[1, 0, 0]: 33 34 37 38 49 50 53 54
[1, 0, 1]: 35 36 39 40 51 52 55 56
[1, 1, 0]: 41 42 45 46 57 58 61 62
[1, 1, 1]: 43 44 47 48 59 60 63 64
</code></pre>
</div>
<div id="pu14" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 9 bytes</h1>
<pre><code>4*Ḷb4:2ḄĠ
</code></pre>
<p><a href="https://tio.run/##y0rNyan8/99E6@GObUkmVkYPd7QcWfD/cLv7///GAA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p>Pretty much a port of <a href="https://codegolf.stackexchange.com/a/231027/68942">Neil's Charcoal answer</a>, so go upvote them too.</p>
<pre><code>4*Ḷb4:2ḄĠ    Main Link; take x
4*           4 ** x
  Ḷ          [0, 1, 2, ..., 4 ** x - 1]
   b4        Convert to base 4
     :2      Floor-divide by 2
       Ḅ     Convert from binary
        Ġ    Group the indices by their corresponding values
</code></pre>
<p>This answer can be ported directly into yuno.</p>
<h1><a href="https://github.com/hyper-neutrino/yuno" rel="nofollow noreferrer">yuno</a>, 9 bytes</h1>
<pre><code>4*ʀb4:2ɮG
</code></pre>
<p><a href="https://yuno.hyper-neutrino.xyz/#WyIiLCI0KsqAYjQ6MsmuRyIsIiIsIiIsIiIsWyIzIl1d" rel="nofollow noreferrer" title="yuno online interpreter">Try it online!</a></p>
<hr />
<p>This approach is probably what Bubbler's 6-byter is going for, but a) I need to find how to get <code>0,0,1,1</code> in 3 bytes, and b) I need to figure out how to make the format valid without the <code>s2*$</code> being that long:</p>
<h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 11 bytes</h1>
<pre><code>Ø.x2¤ṗỤs2*$
</code></pre>
<p><a href="https://tio.run/##ARwA4/9qZWxsef//w5gueDLCpOG5l@G7pHMyKiT///8z" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 16 bytes</h1>
<pre><code>,Uz0$FU
2*ḶBçþ`Ḅ
</code></pre>
<p><a href="https://tio.run/##y0rNyan8/18ntMpAxS2Uy0jr4Y5tToeXH96X8HBHy////40B" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
</div>
<div id="pu15" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, 61 bytes</h1>

<pre class="lang-hs prettyprint-override"><code>f n|r&lt;-iterate(&gt;&gt;= \x-&gt;[4*x,4*x+1])[0]!!n=[[x+2*y|x&lt;-r]|y&lt;-r]
</code></pre>
<p><a href="https://tio.run/##y0gszk7Nyfn/P00hr6bIRjezJLUosSRVw87OViGmQtcu2kSrQgeItQ1jNaMNYhUV82yjoyu0jbQqaypsdItiaypB5P/cxMw829zEAl@FgqLMvBIFFYU0BeP/AA" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
<p>Same idea as tsh's Python, but the list <code>r</code> (e.g. <code>[0,1,4,5,16,17,20,21]</code>) is created in a Haskell-y way.</p>
</div>
<div id="pu16" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, <s> 14 12 </s> 9 <a href="https://github.com/DennisMitchell/jelly/wiki/Code-page" rel="nofollow noreferrer">bytes</a></h1>
<h3>9 byter</h3>
<pre><code>Ø.ṗḅ4+þḤ$
</code></pre>
<p><strong><a href="https://tio.run/##ARwA4/9qZWxsef//w5gu4bmX4biFNCvDvuG4pCT///8z" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></strong></p>
<h5>How?</h5>
<p>Makes a table under <span class="math-container">\$x+2y\$</span> where both <span class="math-container">\$x\$</span> and <span class="math-container">\$y\$</span> are a prefix of the Moser–De Bruijn sequence.</p>
<pre><code>Ø.ṗḅ4+þḤ$ - Link: n
Ø.        - bits -&gt; [0,1]
  ṗ       - Cartesian power (n) -&gt; binary representations of [0..2^n-1]
   ḅ4     - convert from base four -&gt; first 2^n terms of the Moser–De Bruijn sequence
        $ - last two links as a monad, f(S):
       Ḥ  -   double -&gt; D=[2x for x in S]
      þ   -   (s in S) table with (d in D):
     +    -     (s) add (d)
</code></pre>
<p>(Still no clue for the 6 byte code though!)</p>
<hr />
<h3>12 Byter</h3>
<p>-1 thanks to <a href="https://codegolf.stackexchange.com/users/66833/caird-coinheringaahing">caird coinheringaahing</a> (we can use 1-based values)</p>
<pre><code>Ġ;&quot;FL+ƊZƊ⁸¡⁺
</code></pre>
<p>A monadic Link that accepts a non-negative integer and yields the matrix (using the 1-based values option).</p>
<p><strong><a href="https://tio.run/##ASYA2f9qZWxsef//xKA7IkZMK8aKWsaK4oG4wqHigbr/w4fFkuG5mP//Mw" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></strong> (Footer formats as a Python list for clarity.)</p>
<h5>How?</h5>
<p>Starts with <code>[[1]]</code> and repeatedly applies a function that creates the required new entries to the right (and then below, via the transposed matrix) by adding the number of current elements to each element.</p>
<pre><code>Ġ;&quot;FL+ƊZƊ⁸¡⁺ - Link: non-negative integer, n
Ġ            - group indices (of implicit [n]) by value -&gt; [[1]] (our initial M)
          ¡  - repeat...
         ⁸   - ...number of times: chain's left argument -&gt; n
        Ɗ    - ...what: last three links as a monad, f(M):
      Ɗ      -   last three links as a monad, g(M):
   F         -     flatten
    L        -     length
     +       -     add to elements of M
  &quot;          -   zip (rows of M) with (rows of that) and apply:
 ;           -     concatenation
       Z     -   transpose
           ⁺ - repeat last link (i.e. repeat f() n more times)
</code></pre>
</div>
<div id="pu17" class="pu"><h1><a href="https://www.r-project.org/" rel="nofollow noreferrer">R</a>, <s>57</s> <s>52</s> 49 bytes</h1>
<p><em>Edit: -8 bytes by changing to iterative approach with <code>scan()</code> for input (instead of recursive function)</em></p>

<pre class="lang-r prettyprint-override"><code>for(i in seq(l=2*scan())-1)F=t(cbind(F,F+2^i));+F
</code></pre>
<p><a href="https://tio.run/##K/r/Py2/SCNTITNPoTi1UCPH1kirODkxT0NTU9dQ0822RCM5KTMvRcNNx03bKC5TU9Na2@2/8X8A" rel="nofollow noreferrer" title="R – Try It Online">Try it online!</a></p>
<p><strong>Explanation</strong></p>
<p><s>Recursive function that</s> Each loop <code>i</code>creates two side-by-side copies of the columns of a matrix, adding <s>the maximum value of the first +1</s> <code>2^i</code> to the second copy, and then transposes it all.</p>
<p>This creates the top left &amp; top right copies of the last matrix (<code>F</code>), transposed: so, every second loop creates a full 'Z' of four copies of the last matrix, untransposed.</p>
<p>So we need to loop twice the value of <code>n</code> times.</p>
</div>
<div id="pu18" class="pu"><h1><a href="https://www.r-project.org/" rel="nofollow noreferrer">R</a>, <s>65</s> <s>63</s> <s>59</s> <s>57</s> 55 bytes</h1>

<pre class="lang-r prettyprint-override"><code>for(i in seq(l=scan()))T=T^4%x%2^rbind(0:1,2:3);log2(T)
</code></pre>
<p><a href="https://tio.run/##Vc1BCsIwEEDRvacYkMIMKLTRVbW3yLrQ1kQGyiROIgri2dO6Ebr98PhaPFyP4J8yZQ6CTPCBNA2yqcSwty5leOkQo9PigyIDCyT3wLn7ASQi29n@XL0r0@vIcsO6bQ6mPdFlDneDlsp395f12qOyZPTrlcoC" rel="nofollow noreferrer" title="R – Try It Online">Try it online!</a></p>
<p>Relies on the observation that each next iteration <code>N</code> relates to the previous iteration <code>P</code> by Kronecker product-like operation with the matrix <code>M</code> for <code>n=1</code>, but using summation instead of multiplication:</p>
<pre class="lang-r prettyprint-override"><code>N = kronecker(4*P, M, FUN = &quot;+&quot;)
</code></pre>
<p>Here, we transform the values with powers and logarithms in order to make use of the actual Kronecker product function, which is conveniently abbreviated as <code>%x%</code> operator.</p>
</div>
<div id="pu19" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, <s>90...</s> 64 bytes</h1>

<pre class="lang-ruby prettyprint-override"><code>-&gt;n{(k=0...2**n).map{|y|k.map{|x|k.sum{|z|[x,y][z%2][z/2]&lt;&lt;z}}}}
</code></pre>
<p><a href="https://tio.run/##KypNqvyfZvtf1y6vWiPb1kBPT89ISytPUy83saC6prImG8KoADKKS3Ora6pqoit0KmOjq1SNgIS@UayNTVUtEPwvUEiLNo79DwA" rel="nofollow noreferrer" title="Ruby – Try It Online">Try it online!</a></p>
<h3>Quick explanation:</h3>
<p>Every number can be expressed by interleaving the binary digits of the number of row and column.</p>
</div>
<div id="pu20" class="pu"><h1><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python 3</a> + <a href="https://numpy.org/doc/stable/index.html" rel="nofollow noreferrer">numpy</a>, 113 bytes</h1>
<p>A very literal (and long) implementation of the spec.</p>

<pre class="lang-python prettyprint-override"><code>lambda n:sum(tile(R(R(c_[:2,2:4].T,1&lt;&lt;i,0),1&lt;&lt;i,1)&lt;&lt;2*i,(1&lt;&lt;n+~i,)*2)for i in r_[:n])
from numpy import*
R=repeat
</code></pre>
<p><a href="https://tio.run/##JYuxDsIgFAD3fsUbeUiMpU4N/YnGTRuDCvEl5UGQDl38dSQxN1xuuLSXd@Sh@ulWVxseLws8frYgCq1OzI3n/Tpqpcfzcryo3hhSJ/y7R2O0JCVa8eFLCqVGHzMQEENuHy/Y@RwD8BbSDhRSzEV285RdcrbUlImL8GJArD8" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
</div>
<div id="pu21" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, 88 bytes</h1>

<pre class="lang-hs prettyprint-override"><code>f 0=[[1]]
f n=let(#)=zipWith(++);m=n-1;a=f m;[b,c,d]=map(map(+4^m))&lt;$&gt;[a,b,c]in a#b++c#d
</code></pre>
<p><a href="https://tio.run/##FYq7CgMhEAD7fMWCKRQN5Eg6s/cHV6cQA3sPOYkrkljdzxtTTDHM7PR9bym1FuCKzg3enwJkTFuVQuERyzPWXWqtLGO@DJYwAFs3m8WsHpmK/KPvL1bqcR4dmZ58zEBi1noRa2PqhtC3Ccon5goywE21Hw" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
</div>
<div id="pu22" class="pu"><h1><a href="http://jsoftware.com/" rel="nofollow noreferrer">J</a>, <sup>21</sup> 19 bytes</h1>
<p>Found Bubbler's solution. :-)</p>
<pre><code>2(*+/])4#.2#:@i.@^]
</code></pre>
<p><a href="https://tio.run/##y/qvpKeepmBrpaCuoKNgoGAFxLp6Cs5BPm7/jTS0tPVjNU2U9YyUrRwy9RziYv9rcmmkJmfkO1inaSppGGgqZOopmP4HAA" rel="nofollow noreferrer" title="J – Try It Online">Try it online!</a></p>
<p>The first row is <a href="http://oeis.org/A000695" rel="nofollow noreferrer">A000695</a>, the first column is the same but times two. In the comments Marc LeBrun notes that this is rebasing <code>n</code> from base 2 into base 4. So that's helpful with J:</p>
<pre><code>2(*+/])4#.2#:@i.@^]
          2   i.@^]  0 1 … 2^n
           #:        digits in base 2
                      0 0 0
                      0 0 1
                          …
                      1 1 0
                      1 1 1
       4#.           interpret as digits in base 4
                      0 1 4 5 16 17 20 21
2(*+/])              addition table of list*2 with list
</code></pre>
</div>
<div id="pu23" class="pu"><h1><a href="https://www.gnu.org/software/octave/" rel="nofollow noreferrer">Octave</a>/MATLAB, 67 bytes</h1>

<pre class="lang-matlab prettyprint-override"><code>function x=f(n);x=1;for i=1:n;k=4^i/4;x=[x,k+x;2*k+x,3*k+x];end;end
</code></pre>
<p><a href="https://tio.run/##y08uSSxL/f8/rTQvuSQzP0@hwjZNI0/TusLW0Dotv0gh09bQKs8629YkLlPfBCgaXaGTrV1hbaQFJHWMQWSsdWpeCgj/T8ksLtBI0zDR1PwPAA" rel="nofollow noreferrer" title="Octave – Try It Online">Try it online!</a></p>
</div>
<div id="pu24" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, <s>27</s> <s>23</s> 18 bytes</h1>
<pre><code>≔ＥＸ²Ｎ↨⁴↨ι²υＩＥ⊗υ⁺ιυ
</code></pre>
<p><a href="https://tio.run/##S85ILErOT8z5/9@xuDgzPU/DN7FAIyC/PLVIw0hHwTOvoLTErzQ3CcjV1NRRcEosTtUwgdKZOgpGmiDRUk1rroCizLwSDefE4hKwCS75pUk5qSkapUDpgJzSYpDiUqBiTev//03@65blAAA" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Explanation: Now a port of @tsh's Python answer.</p>
<pre><code>≔ＥＸ²Ｎ↨⁴↨ι²υ
</code></pre>
<p>Map the numbers up to 2ⁿ by converting them to base 2 and then interpreting the result as base 4.</p>
<pre><code>ＩＥ⊗υ⁺ιυ
</code></pre>
<p>Vectorised add the doubled array to itself as a matrix.</p>
<p>Previous <s>27</s> 23 byte answer uses a different approach that is interesting in its own right because some golfing languages have built-ins for things like group index by value or sort array by key.</p>
<pre><code>≔ＥＸ⁴Ｎ↨²÷↨ι⁴¦²υＩＥ⊕⌈υ⌕Ａυι
</code></pre>
<p><a href="https://tio.run/##HYw7DsIwEER7TuFyLZkmcpcqgJBSgHIFY69gJXsT@RO4vbFTzps3Yz8m2tX4WqeU6M3wMBss6xcjaCVm3kp@lvBqUUolLiYhDJ3nG@3kEA5CSujWDrI7RY6nJRJnuJqUj7@ZbcSAnNG1/KNQApTu3ond5D0UJaiN5Virrufd/wE" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Explanation:</p>
<pre><code>≔ＥＸ⁴Ｎ↨²÷↨ι⁴¦²υ
</code></pre>
<p>For each element in the final diagram, convert it to base 4, halve the digits, then convert from base 2. This gives the row number for that element.</p>
<pre><code>ＩＥ⊕⌈υ⌕Ａυι
</code></pre>
<p>For each row list the elements assigned to that row.</p>
</div>
<div id="pu25" class="pu"><h1>JavaScript (ES6), <s> 89 86 </s> 79 bytes</h1>
<p><em>Saved 7 bytes thanks to @tsh</em></p>

<pre class="lang-javascript prettyprint-override"><code>n=&gt;[...Array(1&lt;&lt;n)].map((_,y,a)=&gt;a.map(g=(k=1,x)=&gt;k&gt;&gt;n?0:x&amp;k|(y&amp;k|g(k*2,x))*2))
</code></pre>
<p><a href="https://tio.run/##y0osSyxOLsosKNHNy09J/Z9m@z/P1i5aT0/PsagosVLD0MYmTzNWLzexQEMjXqdSJ1HT1i4RzE231ci2NdSpAApk29nl2RtYVahl12hUAol0jWwtI6CMppaRpub/5Py84vycVL2c/HSNNA0DTU0uVBFDDBEjDBFjoDkA" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
</div>
<div id="pu26" class="pu"><h1><a href="https://docs.python.org/2/" rel="noreferrer">Python 2</a>, 81 bytes</h1>

<pre class="lang-python prettyprint-override"><code>R=[int(bin(x)[2:],4)for x in range(2**input())]
for y in R:print[x+y*2for x in R]
</code></pre>
<p><a href="https://tio.run/##K6gsycjPM/r/P8g2OjOvRCMpM0@jQjPayCpWx0QzLb9IoUIhM0@hKDEvPVXDSEsrM6@gtERDUzOWCyRXCZILsiooAuqMrtCu1DKC6wiK/f/fGAA" rel="noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>
</div>
<div id="pu27" class="pu"><h1><a href="http://jsoftware.com/" rel="nofollow noreferrer">J</a>, 33 bytes</h1>
<pre><code>,~@^~&amp;2$4(/:[:&lt;.@-:4#.inv])@i.@^]
</code></pre>
<p><a href="https://tio.run/##y/qvpKeepmBrpaCuoKNgoGAFxLp6Cs5BPm7/deoc4urUjFRMNPStoq1s9Bx0rUyU9TLzymI1HTL1HOJi/2typSZn5CukKRhAGOrqMAFDdAEjdAHj/wA" rel="nofollow noreferrer" title="J – Try It Online">Try it online!</a></p>
<p><sup>The true insight of this idea is due to <a href="https://codegolf.stackexchange.com/a/231027/15469">Neil's excellent answer</a>.</sup></p>
<p>I'll mention a couple of other insights I had which didn't help with bytes but might be useful to others:</p>
<ol>
<li>The deltas along each row follow a repeating pattern whose unique elements are <a href="http://oeis.org/A007583" rel="nofollow noreferrer">http://oeis.org/A007583</a>: 1, 3, 11, 43, 171...</li>
<li>Similarly the deltas going down each column follow <a href="http://oeis.org/A047849" rel="nofollow noreferrer">http://oeis.org/A047849</a>: 1, 2, 6, 22, 86, 342...</li>
</ol>
<h2>how</h2>
<ul>
<li><code>4...@i.@^]</code> Produces <code>0, 1, ... 4^n</code>, where n is the input.</li>
<li><code>/:[:&lt;.@-:4#.inv]</code> Sort those according to row number, which we get by converting to base 4, halving, and flooring.</li>
<li><code>,~@^~&amp;2$</code> Now shape that into a square matrix of side length <code>2^n</code>.</li>
</ul>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/231022/">231022</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




