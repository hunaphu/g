<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::277377</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>059</td><td>Charcoal</td><td>241226T000519Z</td><td><a href="https://codegolf.stackexchange.com/questions/277377/find-the-busiest-unfriendly-matrix/277399#277399">Neil</a></td></tr>
<tr d-ix="1"><td>1260</td><td>Python</td><td>241226T011219Z</td><td><a href="https://codegolf.stackexchange.com/questions/277377/find-the-busiest-unfriendly-matrix/277401#277401">138 Aspe</a></td></tr>
<tr d-ix="2"><td>1260</td><td>Rust</td><td>241226T010832Z</td><td><a href="https://codegolf.stackexchange.com/questions/277377/find-the-busiest-unfriendly-matrix/277400#277400">138 Aspe</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 59 bytes, <code>n=4</code> on ATO</h1>
<pre><code>Ｎθ≔ΦＥＸ²×θθ⪪﹪÷ιＸ²…⁰×θθ²θ⬤ι⬤…ιμ‹Σ×λνΣＥλ↔⁻π§νρη≔ＥηΣΣλζ⭆¹§η⌕ζ⌈ζ
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=VZDPSsQwEMbx6lOEPU0hC7p4EPdUVhYKVhbrTTz0T2wHJknbJOvaV_GygqLP5NOYtMsuHsJkvpnfN5O8_5RN3pc6p_3-y9mX-fXv2U2iWmfvnSxED120PI-NwVrBGsl6Jc1b2OhXf1tw9ohSGOg466KIs6wltJDqypGGRNlb3GIlADk7Ag-5qgVc_CcDu4gOJjFRIEJYvZUkVo1ugyB97U4YA5mTMNHEmRrneiWs5fO4MJqcFZCicgZar9hEVWIHirM-mmY1p0cFrJkcwqGxPvj6pkdlIbM-1KHp8uTk-9eoKhg4S_MdSs8No_Py0xSlOXzk99NsvqXZ88fVlP8B" rel="nofollow noreferrer">Attempt This Online!</a> Link is to verbose version of code. Explanation: Just brute force, so although ATO can solve <code>n=4</code> in about half a minute, <code>n=5</code> would take several hours.</p>
<pre><code>Ｎθ
</code></pre>
<p>Input <code>n</code>.</p>
<pre><code>≔ΦＥＸ²×θθ⪪﹪÷ιＸ²…⁰×θθ²θ⬤ι⬤…ιμ‹Σ×λνΣＥλ↔⁻π§νρη
</code></pre>
<p>Enumerate all binary square matrices of size <code>n</code> and filter on those that are unfriendly.</p>
<pre><code>≔ＥηΣΣλζ⭆¹§η⌕ζ⌈ζ
</code></pre>
<p>Find and pretty-print the busiest of the unfriendly matrices.</p>
<p>86 bytes for a faster version that can do <code>n=5</code> in minutes rather than hours:</p>
<pre><code>Ｎθ≔ＥＸ²θ﹪÷ιＸ²⮌…⁰θ²ηＦη⊞υΦη‹Σ×ικΣ×⁺ιＸ⁰ι⁺Ｘ⁰κκ≔⟦⟦⟧⟧ζＦθ≔ΣＥηＥΦζ⬤μ№§υ↨ξ²κ⁺μ⟦κ⟧ζ≔ＥζΣΣιε⭆¹§ζ⌕ε⌈ε
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=VVHBSsQwEMWrXxH2NIUs6OJB8NRVhIIrZddb6aG7zW5D03TbJLX0V7xUUPSb_BpntrWLgWTIzLz35iVv37ssqXdlovr-09n9_Pbnog_00dlnV2xFDZV3d-kbIw8aVskRwvIVkwvOKo-zVZk6VUKg7YNsZCpAcjY1rEUjaiNgneiDgCtC4OJsQUeGrPuyZpB5LHQmA8fZo1QWoRlnT8IY2LgCXmQhDLHmBDpnQuXMWQy5JdVP2SmVeycYrclBFMUxZ92feOWxsUDUZA_FKYyjdJz5SkHB2X3ptAXfBjoVLQ27TNBaO7rJvUkee6M8Hpx2_5-uGxzQlqe6wHpYSyTeWAwHarpGyVGloyfRKQiaqZUF4sRg58Nsd2b8rq9oNm_ULH6_Ge6_" rel="nofollow noreferrer">Attempt This Online!</a> Link is to verbose version of code. Explanation:</p>
<pre><code>Ｎθ
</code></pre>
<p>Input <code>n</code>.</p>
<pre><code>≔ＥＸ²θ﹪÷ιＸ²⮌…⁰θ²η
</code></pre>
<p>Create all of the bit patterns for a single row.</p>
<pre><code>Ｆη⊞υΦη‹Σ×ικΣ×⁺ιＸ⁰ι⁺Ｘ⁰κκ
</code></pre>
<p>For each bit pattern, find those bit patterns that are unfriendly.</p>
<pre><code>≔⟦⟦⟧⟧ζＦθ≔ΣＥηＥΦζ⬤μ№§υ↨ξ²κ⁺μ⟦κ⟧ζ
</code></pre>
<p>Starting from an empty matrix, build up rows by adding those bit patterns that are unfriendly to all the rows so far.</p>
<pre><code>≔ＥζΣΣιε⭆¹§ζ⌕ε⌈ε
</code></pre>
<p>Find and pretty-print the busiest of the unfriendly matrices.</p>
</div>
<div id="pu1" class="pu"><h1>Python, <code>n=12</code> in less than 60 seconds on my laptop.</h1>
<pre class="lang-python prettyprint-override"><code>import sys
import time

def hamming_distance(a, b):
    &quot;&quot;&quot;
    Returns the Hamming distance (number of differing bits) between two integers a and b.
    &quot;&quot;&quot;
    return bin(a ^ b).count('1')

def common_ones(a, b):
    &quot;&quot;&quot;
    Returns the count of positions where a and b both have 1-bits.
    &quot;&quot;&quot;
    return bin(a &amp; b).count('1')

def is_unfriendly(a, b):
    &quot;&quot;&quot;
    Checks if two rows a and b (bit patterns) are 'unfriendly':
    Hamming distance &gt; number of positions where both have 1s.
    &quot;&quot;&quot;
    return hamming_distance(a, b) &gt; common_ones(a, b)

def backtrack(rows_sorted, n, chosen, start_idx, best_solution, best_ones, end_time):
    &quot;&quot;&quot;
    Recursively attempts to build an unfriendly matrix by picking rows in descending order of 1-count.

    rows_sorted: list of (row_bit_pattern, count_ones)
    n: target number of rows in the solution
    chosen: currently picked row patterns
    start_idx: next index in rows_sorted to try
    best_solution: global best set of rows found
    best_ones: global best number of 1s found
    end_time: cutoff time to stop searching
    &quot;&quot;&quot;
    # Check time limit
    if time.time() &gt; end_time:
        return

    # If we have n rows, see if it improves our best solution
    if len(chosen) == n:
        current_sum = sum(bin(r).count('1') for r in chosen)
        if current_sum &gt; best_ones[0]:
            best_ones[0] = current_sum
            best_solution[:] = chosen[:]
        return

    # Quick sum of chosen
    chosen_sum = sum(bin(r).count('1') for r in chosen)

    # Potential max if we pick the remaining top-ones rows
    # to see if we can beat the current best
    potential_max = chosen_sum + sum(v for _, v in rows_sorted[start_idx:start_idx + (n - len(chosen))])
    if potential_max &lt;= best_ones[0]:
        # Prune if we can't do better
        return

    for i in range(start_idx, len(rows_sorted)):
        if time.time() &gt; end_time:
            break
        row_val, _ = rows_sorted[i]

        # Check if it's unfriendly with all chosen rows
        valid = True
        for prev in chosen:
            if not is_unfriendly(row_val, prev):
                valid = False
                break

        # If valid, recurse
        if valid:
            chosen.append(row_val)
            backtrack(rows_sorted, n, chosen, i+1, best_solution, best_ones, end_time)
            chosen.pop()

def main():
    if len(sys.argv) &lt; 2:
        print(&quot;Usage: python unfriendly.py &lt;n&gt;&quot;)
        sys.exit(1)

    n = int(sys.argv[1])
    
    # For n up to 64, we can store each row in a 64-bit integer.
    # The method only remains feasible for n roughly up to 12 due to 2^n growth.
    if n &gt; 64:
        print(f&quot;{n} is too large to represent in 64 bits.&quot;)
        sys.exit(1)

    # Generate all possible row bit patterns (from 0 to 2^n - 1)
    # and store them with their count of ones
    all_rows = []
    for row_pattern in range(1 &lt;&lt; n):
        all_rows.append((row_pattern, bin(row_pattern).count('1')))

    # Sort rows by descending number of 1 bits
    all_rows.sort(key=lambda x: x[1], reverse=True)

    best_solution = []
    best_ones = [0]  # use list for mutability in function
    
    # You can adjust the search duration limit if desired
    start_time = time.time()
    time_limit_secs = 55
    end_time = start_time + time_limit_secs

    backtrack(all_rows, n, [], 0, best_solution, best_ones, end_time)

    # Convert the chosen row bit patterns into a 2D matrix
    matrix = []
    for row_val in best_solution:
        # build a list of bits '0' or '1'
        row_bits = [(row_val &gt;&gt; col) &amp; 1 for col in range(n)]
        # If you want bits in left-to-right order as standard reading, reverse them:
        # row_bits.reverse()
        matrix.append(row_bits)

    # Print the matrix row by row
    for row in matrix:
        print(&quot; &quot;.join(map(str, row)))

if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
</div>
<div id="pu2" class="pu"><h1>Rust, <code>n=12</code> in less than 60 seconds on my laptop.</h1>
<pre class="lang-rust prettyprint-override"><code>use std::time::Instant;

/// Returns the Hamming distance (count of differing bits) between two bit patterns.
fn hamming_distance(a: u64, b: u64) -&gt; u32 {
    (a ^ b).count_ones()
}

/// Returns the count of positions where both bit patterns have a '1'.
fn common_ones(a: u64, b: u64) -&gt; u32 {
    (a &amp; b).count_ones()
}

/// Checks if two rows (bit patterns) are &quot;unfriendly&quot;:
/// distance &gt; number of common ones.
fn is_unfriendly(a: u64, b: u64) -&gt; bool {
    hamming_distance(a, b) &gt; common_ones(a, b)
}

/// Tries to build an unfriendly matrix by picking rows in descending order of their 1-count.
/// - `rows_sorted` is a list of all bit patterns with their 1-count sorted descending.
/// - `n` is the matrix dimension.
/// - `chosen` holds currently picked row bit patterns.
fn backtrack(
    rows_sorted: &amp;[(u64, u32)],
    n: usize,
    chosen: &amp;mut Vec&lt;u64&gt;,
    start_index: usize,
    best_solution: &amp;mut Vec&lt;u64&gt;,
    best_ones: &amp;mut u32,
    time_limit: std::time::Duration,
    start_time: Instant,
) {
    // If time exceeded, stop searching.
    if Instant::now().duration_since(start_time) &gt; time_limit {
        return;
    }

    // If we already have n rows, update the best solution if better.
    if chosen.len() == n {
        let sum_ones: u32 = chosen
            .iter()
            .map(|&amp;r| r.count_ones())
            .sum();
        if sum_ones &gt; *best_ones {
            *best_ones = sum_ones;
            *best_solution = chosen.clone();
        }
        return;
    }

    // Prune if the maximum possible 1s from here cannot beat current best:
    // (sum of chosen ones + sum of top row-ones in the future)
    let chosen_sum: u32 = chosen.iter().map(|&amp;r| r.count_ones()).sum();
    let max_possible = chosen_sum
        + rows_sorted[start_index..]
            .iter()
            .take(n - chosen.len())
            .map(|&amp;(_, ones)| ones)
            .sum::&lt;u32&gt;();
    if max_possible &lt;= *best_ones {
        return;
    }

    // Try to pick rows from start_index onward.
    for i in start_index..rows_sorted.len() {
        // Quick check for time limit again.
        if Instant::now().duration_since(start_time) &gt; time_limit {
            break;
        }

        let (candidate_row, _) = rows_sorted[i];
        // Check if candidate_row is unfriendly with all chosen rows so far.
        let mut valid = true;
        for &amp;prev_row in &amp;*chosen {
            if !is_unfriendly(candidate_row, prev_row) {
                valid = false;
                break;
            }
        }
        // If it is unfriendly with all, pick it and recurse.
        if valid {
            chosen.push(candidate_row);
            backtrack(
                rows_sorted,
                n,
                chosen,
                i + 1,
                best_solution,
                best_ones,
                time_limit,
                start_time,
            );
            chosen.pop();
        }
    }
}

fn main() {
    // Read n from command line or default to something for demonstration.
    let args: Vec&lt;String&gt; = std::env::args().collect();
    if args.len() &lt; 2 {
        eprintln!(&quot;Usage: {} &lt;n&gt;&quot;, args[0]);
        return;
    }
    let n: usize = args[1].parse().expect(&quot;Invalid integer for n&quot;);

    // For n up to 64, we can store each row in a 64-bit integer.
    // We will explore all possible 2^n patterns (feasible up to about n=12).
    if n &gt; 64 {
        eprintln!(&quot;n = {} is too large to be encoded in 64 bits.&quot;, n);
        return;
    }

    // Generate all possible row bit patterns for n bits.
    // Store them alongside their count of 1s for sorting.
    let mut all_rows = Vec::new();
    for row_pattern in 0..(1u64 &lt;&lt; n) {
        all_rows.push((row_pattern, row_pattern.count_ones()));
    }

    // Sort patterns by descending number of 1s.
    all_rows.sort_by(|a, b| b.1.cmp(&amp;a.1));

    // We'll store the best solution found (list of row patterns),
    // and the best sum of 1s so far.
    let mut best_solution = Vec::new();
    let mut best_ones = 0;

    // Set a time limit (e.g., 55 seconds, giving some buffer under 60).
    let time_limit = std::time::Duration::from_secs(55);
    let start_time = Instant::now();

    // Backtracking search.
    let mut chosen = Vec::new();
    backtrack(
        &amp;all_rows,
        n,
        &amp;mut chosen,
        0,
        &amp;mut best_solution,
        &amp;mut best_ones,
        time_limit,
        start_time,
    );

    // Output the resulting matrix.
    // Each selected row bit pattern is output as '0/1' across n columns.
    let mut matrix = vec![vec![0; n]; n];
    for (row_index, &amp;pattern) in best_solution.iter().enumerate() {
        for col_index in 0..n {
            // If the col_index-th bit is set, fill with 1.
            // Note that bit 0 is the least significant bit, so we check that carefully.
            if (pattern &amp; (1 &lt;&lt; col_index)) != 0 {
                matrix[row_index][col_index] = 1;
            }
        }
    }

    // Print the matrix row by row.
    // If you want columns in &quot;left to right&quot; order matching bits from left to right:
    // you can invert the indexing in the loop above.
    for row in matrix {
        println!(
            &quot;{}&quot;,
            row.iter()
                .map(|&amp;bit| bit.to_string())
                .collect::&lt;Vec&lt;String&gt;&gt;()
                .join(&quot; &quot;)
        );
    }
}
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/277377/">277377</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




