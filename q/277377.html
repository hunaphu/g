<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::277377</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>1260</td><td>C++</td><td>250225T233338Z</td><td><a href="https://codegolf.stackexchange.com/questions/277377/find-the-busiest-unfriendly-matrix/278389#278389">138 Aspe</a></td></tr>
<tr d-ix="1"><td>059</td><td>Charcoal</td><td>241226T000519Z</td><td><a href="https://codegolf.stackexchange.com/questions/277377/find-the-busiest-unfriendly-matrix/277399#277399">Neil</a></td></tr>
<tr d-ix="2"><td>1260</td><td>Python</td><td>241226T011219Z</td><td><a href="https://codegolf.stackexchange.com/questions/277377/find-the-busiest-unfriendly-matrix/277401#277401">138 Aspe</a></td></tr>
<tr d-ix="3"><td>1260</td><td>Rust</td><td>241226T010832Z</td><td><a href="https://codegolf.stackexchange.com/questions/277377/find-the-busiest-unfriendly-matrix/277400#277400">138 Aspe</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>C++, <code>n=12</code> in less than 60 seconds on my laptop.</h1>
<p><a href="https://tio.run/##rVhtb@O4Ef6eXzHNAYndOF57sdkCfsmHFu21wAG93t7hPgQ5HS2NbSISKZBSXlrkrzc3Q4oSJTvZFNd82JWp4XDmmeEzM0rL8jLNhdq9vHwjVZrXGcJKalsZFMX1Sbd2j2mlTbwi8p02str3xNK90UrHKxtZWaziFVIu1e765OTDB/gBq9ooC9Ue4e@iKOgFZNJWQqUIo1TXqgK9paXtFnkXsLoxbLB6QFRQPWhegVJUFZKe6UmtrNwpzEDSzr3XmASNo5pWP39KKhATaJ83Y/jPCdCfccZAkmxqmVdSJaUunQl5PhLwCwkuT54PzG6NLLWVldS0/LBHg7DR1b5nHdlzjyDgfH4@MDTVRaFVohXa32XjWWTjX/aY3lmQW4eS0Q8WRrE1YxBk5GmttkaiyvKn0wVva9G/BlUXGzTsmrcP2L7pyUbrHKRNup3vs/kgGiRMMtc9791acOFH0k8gU4zJ2QyEgu5MKATl0SNsnqCU6R3nhvNRKsjQpiTDS9pk3gOKlDQwv3RYTVn5JfzKGxKrTYXZr@QRhSYn21hc5Hk/dA@U6X0l4DdGpwW1yinj3GhszGSBFG6tgkS61xZJbK/zzEJaG4MUQe8JqSS7Bml9r2UGG5HeVYb@GTlYU0o1sqLKFgt/O1fuuRTSrEIQKBxRnl1fn0Hk88SpsfLfSNFSza9IXVBCu7zBvQ0URFMlUmX4@ObWDdqKDsxrvhteMrapEeDgR2o8jywWFslLgqgiBJNcFrI6JlShyJ6SNNfp3WLhREvN18qbyAsnIRcJ/39snTrAxxQxIxhITpdgUZh078LIgnRvRm@covTDaEyh7I6gRO6sDMd16b90vymvOyseiAxyw1o9MygXHApZmYkKXQIxNhDAY5uI@SglOhN9YKYcE7JnvQYVH90jGVsXDmZYw2zZimy1YaLlVBJ1pV2CwKIJeKzLwR5UXKyPUxBtHne6n9un9sHBGrRcd7EfntS@IGuD/PJQooVm3Vh87PDjAfje1AodPbqL@iiLumAOt3KTI8wtbI0uwDF5KpTSRGgoqnBZ3fGLoItdcjzpbAAPETSLnFyEy6VbJXri87Y1mYTjg9vQaEh4axumd4co2vz1AHl8Di3wpvUtaK68wUJIxbxKeUbJ30u@yNZGXHLsOpZY0sIqXiCIOo1nZ@51RE9BL1xcyNjLyEDyMtpwI2@nnjDe9pCCnbSBXvdQi5Qv2zvWk1@tjyft8ST70Txx/WJe9@XJJVWMgVYPwmTT94H3DnTo0H/VfFzK9d@pdOzkaAnEjuCe9m/j/4Xk3I0kLruLL2CXmFHy3tBtyiQzXELuTCC5hWEUl7E3ro9hS3v7uMJGzYArz1y0mxvosLYatsJ03rrG5V7kVErXUJka32DB0uB98hYVMnR/6HdBA8eCivFwK/8FM7Yit7g8eD2Ass9nzzE8VEcorsfRmPjE47gr6iqQuMtiP/rOjqGBzb0ua7tPuOnoezYe8HC/K4n/DnqN@E8dLsVdRg9rupjzw@UjncXREnL4athO9Gpc1zTEywOvA0S69AgdVL1n7mE920g14gdhdumENgrzR36@v7mNmpIf6N4Rpzp64H6YA5ZLKlCUmBluRZ1XTCRWF1hxk@IyNsOCU9aIyvWWIaZ8EJHFxzis/pajMbBawelPVuxwAaf8w5kyu3XrsFLXbtGJczItBwQH8wNuDQ2kI6yMOUTX@cipnd8SLsHFv5HF1MGX7MfnTxNufyivuPmiEosi3bu6RgVS0OtL7n8JNdyFboc0/IyU2nTJ8bHMeRNf@JaYP/6iunZ9tEXhl/15YqNrMnE9/zjucFLEZp8/vY4Se@TQUB4cbuq1hpxcQzeVkNkq1ZkrK6TJDafT9@IXnPoWFRru93reDEcAF2/lTwg7vzjkqJ0oaK9WOyszbGaUdiid@518CdvW9n8bGdguvvZN@9WOd64qeusIp/lP333noIragFaUdkeis2VvYRVr4nIWvYxjE8yYYlHmIkV/7yLhyasdT6tuPAT/C@HSYUyzZDQ7duPv3EbAMZSj1pgN7uh6jyeReSrj363dN7e9wkIDbvyTh@SQGqLpXrgvDo0MPEc36Gc8pxyxIeyD6WBLDmcwCiMsZ1A760@CCuaVbqtvUOf9Unl0juuT7fKwqYob9lln8hckT@MOZITT3XQCV1fQzHYT2Ml7xpu5jSZ9/tJDqnlu/zwbT98zE46urprIMqhxu7KGr7U3nal/DoXMGeOmwbcAieeNIzUw5ENXYKISNSx0s@7xlaJ2pJgdK2KD4hV598@6KokCOfYGbc23ZNd8n2gJ5a9MwhZzcvXwKwTTn/ZKhIXz2Yf5OYjUEGERL6VkcKHsK/zSPHs68WeO1ASG73htNj4ySPAV9t1yyx7@56oPV9QTtzK9cTgQUkdGvf037a7bQWvYGEJuxoZ0P5n46NR2YdhRNZ8d3OfCRuSy@TpIsFok1t1yZXOd23x60GkGg89gFJi2O@tYf@lRjhy6aeW5356/3VvGUzJf7uhblsuKJ/5v@tZw6qV7Y9tguJm1I81ro0x387l4r5xsbzoI6PT10MAyPwZJT9UpnH69ve7tGJT0BqKGuonxnl9eXq7@m25zsbMvlyS9Ti8u5n/6DQ" rel="nofollow noreferrer">Try it online!</a></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;bitset&gt;
#include &lt;string&gt;

// Returns the Hamming distance (count of differing bits) between two bit patterns.
unsigned int hamming_distance(uint64_t a, uint64_t b) {
    return __builtin_popcountll(a ^ b);
}

// Returns the count of positions where both bit patterns have a '1'.
unsigned int common_ones(uint64_t a, uint64_t b) {
    return __builtin_popcountll(a &amp; b);
}

// Checks if two rows (bit patterns) are &quot;unfriendly&quot;:
// distance &gt; number of common ones.
bool is_unfriendly(uint64_t a, uint64_t b) {
    return hamming_distance(a, b) &gt; common_ones(a, b);
}

// Tries to build an unfriendly matrix by picking rows in descending order of their 1-count.
// - `rows_sorted` is a list of all bit patterns with their 1-count sorted descending.
// - `n` is the matrix dimension.
// - `chosen` holds currently picked row bit patterns.
void backtrack(
    const std::vector&lt;std::pair&lt;uint64_t, unsigned int&gt;&gt;&amp; rows_sorted,
    size_t n,
    std::vector&lt;uint64_t&gt;&amp; chosen,
    size_t start_index,
    std::vector&lt;uint64_t&gt;&amp; best_solution,
    unsigned int&amp; best_ones,
    std::chrono::seconds time_limit,
    std::chrono::steady_clock::time_point start_time
) {
    // If time exceeded, stop searching.
    if (std::chrono::steady_clock::now() - start_time &gt; time_limit) {
        return;
    }

    // If we already have n rows, update the best solution if better.
    if (chosen.size() == n) {
        unsigned int sum_ones = 0;
        for (const auto&amp; row : chosen) {
            sum_ones += __builtin_popcountll(row);
        }
        
        if (sum_ones &gt; best_ones) {
            best_ones = sum_ones;
            best_solution = chosen;
        }
        return;
    }

    // Prune if the maximum possible 1s from here cannot beat current best:
    // (sum of chosen ones + sum of top row-ones in the future)
    unsigned int chosen_sum = 0;
    for (const auto&amp; row : chosen) {
        chosen_sum += __builtin_popcountll(row);
    }
    
    unsigned int future_sum = 0;
    size_t remaining = n - chosen.size();
    for (size_t i = start_index; i &lt; start_index + remaining &amp;&amp; i &lt; rows_sorted.size(); ++i) {
        future_sum += rows_sorted[i].second;
    }
    
    unsigned int max_possible = chosen_sum + future_sum;
    if (max_possible &lt;= best_ones) {
        return;
    }

    // Try to pick rows from start_index onward.
    for (size_t i = start_index; i &lt; rows_sorted.size(); ++i) {
        // Quick check for time limit again.
        if (std::chrono::steady_clock::now() - start_time &gt; time_limit) {
            break;
        }

        const auto&amp; [candidate_row, _] = rows_sorted[i];
        // Check if candidate_row is unfriendly with all chosen rows so far.
        bool valid = true;
        for (const auto&amp; prev_row : chosen) {
            if (!is_unfriendly(candidate_row, prev_row)) {
                valid = false;
                break;
            }
        }
        // If it is unfriendly with all, pick it and recurse.
        if (valid) {
            chosen.push_back(candidate_row);
            backtrack(
                rows_sorted,
                n,
                chosen,
                i + 1,
                best_solution,
                best_ones,
                time_limit,
                start_time
            );
            chosen.pop_back();
        }
    }
}

int main(int argc, char* argv[]) {
    // Read n from command line or default to something for demonstration.
    if (argc &lt; 2) {
        std::cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;n&gt;&quot; &lt;&lt; std::endl;
        return 1;
    }
    
    size_t n = std::stoul(argv[1]);

    // For n up to 64, we can store each row in a 64-bit integer.
    // We will explore all possible 2^n patterns (feasible up to about n=12).
    if (n &gt; 64) {
        std::cerr &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; &quot; is too large to be encoded in 64 bits.&quot; &lt;&lt; std::endl;
        return 1;
    }

    // Generate all possible row bit patterns for n bits.
    // Store them alongside their count of 1s for sorting.
    std::vector&lt;std::pair&lt;uint64_t, unsigned int&gt;&gt; all_rows;
    uint64_t max_pattern = 1ULL &lt;&lt; n;
    for (uint64_t row_pattern = 0; row_pattern &lt; max_pattern; ++row_pattern) {
        all_rows.emplace_back(row_pattern, __builtin_popcountll(row_pattern));
    }

    // Sort patterns by descending number of 1s.
    std::sort(all_rows.begin(), all_rows.end(), 
        [](const auto&amp; a, const auto&amp; b) { return a.second &gt; b.second; });

    // We'll store the best solution found (list of row patterns),
    // and the best sum of 1s so far.
    std::vector&lt;uint64_t&gt; best_solution;
    unsigned int best_ones = 0;

    // Set a time limit (e.g., 55 seconds, giving some buffer under 60).
    std::chrono::seconds time_limit(55);
    auto start_time = std::chrono::steady_clock::now();

    // Backtracking search.
    std::vector&lt;uint64_t&gt; chosen;
    backtrack(
        all_rows,
        n,
        chosen,
        0,
        best_solution,
        best_ones,
        time_limit,
        start_time
    );

    // Output the resulting matrix.
    // Each selected row bit pattern is output as '0/1' across n columns.
    std::vector&lt;std::vector&lt;int&gt;&gt; matrix(n, std::vector&lt;int&gt;(n, 0));
    for (size_t row_index = 0; row_index &lt; best_solution.size(); ++row_index) {
        uint64_t pattern = best_solution[row_index];
        for (size_t col_index = 0; col_index &lt; n; ++col_index) {
            // If the col_index-th bit is set, fill with 1.
            if (pattern &amp; (1ULL &lt;&lt; col_index)) {
                matrix[row_index][col_index] = 1;
            }
        }
    }

    // Print the matrix row by row.
    for (const auto&amp; row : matrix) {
        for (size_t i = 0; i &lt; row.size(); ++i) {
            std::cout &lt;&lt; row[i];
            if (i &lt; row.size() - 1) {
                std::cout &lt;&lt; &quot; &quot;;
            }
        }
        std::cout &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 59 bytes, <code>n=4</code> on ATO</h1>
<pre><code>Ｎθ≔ΦＥＸ²×θθ⪪﹪÷ιＸ²…⁰×θθ²θ⬤ι⬤…ιμ‹Σ×λνΣＥλ↔⁻π§νρη≔ＥηΣΣιζ⭆¹§η⌕ζ⌈ζ
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=VZDPSsQwEMbx6lOEPU0hC7p4EPa07LJQsFKsN_GQbWM7ME3_JFnXvoqXFRR9Jp_GJF26eAiTfF9-82Xy_pNXos8bQcfjlzUv89vfi02sWmvubb2TPXTR8nKlNZYKtkjGKYloIW1e3W7B2SPWUkPHWRdFnGUtoYGkKSw1ECuzwT0WEpCzCXgQqpRw9Z_07CI6NVkRecKX9VtOcl01rRdq591JrSGzNYw0caZC7qSkZIM85rkY8n5QJ0lFAQup1Xk8P1c19vILgz84P-1RGciMK6W_dO0eZ2JVyIO_v0VVwMBZIg5YO24InZefepfr05d-P83me5o9f9yM5z8" rel="nofollow noreferrer">Attempt This Online!</a> Link is to verbose version of code. Explanation: Just brute force, so although ATO can solve <code>n=4</code> in about half a minute, <code>n=5</code> would take several hours.</p>
<pre><code>Ｎθ
</code></pre>
<p>Input <code>n</code>.</p>
<pre><code>≔ΦＥＸ²×θθ⪪﹪÷ιＸ²…⁰×θθ²θ⬤ι⬤…ιμ‹Σ×λνΣＥλ↔⁻π§νρη
</code></pre>
<p>Enumerate all binary square matrices of size <code>n</code> and filter on those that are unfriendly.</p>
<pre><code>≔ＥηΣΣιζ⭆¹§η⌕ζ⌈ζ
</code></pre>
<p>Find and pretty-print the busiest of the unfriendly matrices.</p>
<p>86 bytes for a faster version that can do <code>n=5</code> in minutes rather than hours:</p>
<pre><code>Ｎθ≔ＥＸ²θ﹪÷ιＸ²⮌…⁰θ²ηＦη⊞υΦη‹Σ×ικΣ×⁺ιＸ⁰ι⁺Ｘ⁰κκ≔⟦⟦⟧⟧ζＦθ≔ΣＥηＥΦζ⬤μ№§υ↨ξ²κ⁺μ⟦κ⟧ζ≔ＥζΣΣιε⭆¹§ζ⌕ε⌈ε
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=VVHBSsQwEMWrXxH2NIUs6OJB8NRVhIIrZddb6aG7zW5D03TbJLX0V7xUUPSb_BpntrWLgWTIzLz35iVv37ssqXdlovr-09n9_Pbnog_00dlnV2xFDZV3d-kbIw8aVskRwvIVkwvOKo-zVZk6VUKg7YNsZCpAcjY1rEUjaiNgneiDgCtC4OJsQUeGrPuyZpB5LHQmA8fZo1QWoRlnT8IY2LgCXmQhDLHmBDpnQuXMWQy5JdVP2SmVeycYrclBFMUxZ92feOWxsUDUZA_FKYyjdJz5SkHB2X3ptAXfBjoVLQ27TNBaO7rJvUkee6M8Hpx2_5-uGxzQlqe6wHpYSyTeWAwHarpGyVGloyfRKQiaqZUF4sRg58Nsd2b8rq9oNm_ULH6_Ge6_" rel="nofollow noreferrer">Attempt This Online!</a> Link is to verbose version of code. Explanation:</p>
<pre><code>Ｎθ
</code></pre>
<p>Input <code>n</code>.</p>
<pre><code>≔ＥＸ²θ﹪÷ιＸ²⮌…⁰θ²η
</code></pre>
<p>Create all of the bit patterns for a single row.</p>
<pre><code>Ｆη⊞υΦη‹Σ×ικΣ×⁺ιＸ⁰ι⁺Ｘ⁰κκ
</code></pre>
<p>For each bit pattern, find those bit patterns that are unfriendly.</p>
<pre><code>≔⟦⟦⟧⟧ζＦθ≔ΣＥηＥΦζ⬤μ№§υ↨ξ²κ⁺μ⟦κ⟧ζ
</code></pre>
<p>Starting from an empty matrix, build up rows by adding those bit patterns that are unfriendly to all the rows so far.</p>
<pre><code>≔ＥζΣΣιε⭆¹§ζ⌕ε⌈ε
</code></pre>
<p>Find and pretty-print the busiest of the unfriendly matrices.</p>
</div>
<div id="pu2" class="pu"><h1>Python, <code>n=12</code> in less than 60 seconds on my laptop.</h1>
<pre class="lang-python prettyprint-override"><code>import sys
import time

def hamming_distance(a, b):
    &quot;&quot;&quot;
    Returns the Hamming distance (number of differing bits) between two integers a and b.
    &quot;&quot;&quot;
    return bin(a ^ b).count('1')

def common_ones(a, b):
    &quot;&quot;&quot;
    Returns the count of positions where a and b both have 1-bits.
    &quot;&quot;&quot;
    return bin(a &amp; b).count('1')

def is_unfriendly(a, b):
    &quot;&quot;&quot;
    Checks if two rows a and b (bit patterns) are 'unfriendly':
    Hamming distance &gt; number of positions where both have 1s.
    &quot;&quot;&quot;
    return hamming_distance(a, b) &gt; common_ones(a, b)

def backtrack(rows_sorted, n, chosen, start_idx, best_solution, best_ones, end_time):
    &quot;&quot;&quot;
    Recursively attempts to build an unfriendly matrix by picking rows in descending order of 1-count.

    rows_sorted: list of (row_bit_pattern, count_ones)
    n: target number of rows in the solution
    chosen: currently picked row patterns
    start_idx: next index in rows_sorted to try
    best_solution: global best set of rows found
    best_ones: global best number of 1s found
    end_time: cutoff time to stop searching
    &quot;&quot;&quot;
    # Check time limit
    if time.time() &gt; end_time:
        return

    # If we have n rows, see if it improves our best solution
    if len(chosen) == n:
        current_sum = sum(bin(r).count('1') for r in chosen)
        if current_sum &gt; best_ones[0]:
            best_ones[0] = current_sum
            best_solution[:] = chosen[:]
        return

    # Quick sum of chosen
    chosen_sum = sum(bin(r).count('1') for r in chosen)

    # Potential max if we pick the remaining top-ones rows
    # to see if we can beat the current best
    potential_max = chosen_sum + sum(v for _, v in rows_sorted[start_idx:start_idx + (n - len(chosen))])
    if potential_max &lt;= best_ones[0]:
        # Prune if we can't do better
        return

    for i in range(start_idx, len(rows_sorted)):
        if time.time() &gt; end_time:
            break
        row_val, _ = rows_sorted[i]

        # Check if it's unfriendly with all chosen rows
        valid = True
        for prev in chosen:
            if not is_unfriendly(row_val, prev):
                valid = False
                break

        # If valid, recurse
        if valid:
            chosen.append(row_val)
            backtrack(rows_sorted, n, chosen, i+1, best_solution, best_ones, end_time)
            chosen.pop()

def main():
    if len(sys.argv) &lt; 2:
        print(&quot;Usage: python unfriendly.py &lt;n&gt;&quot;)
        sys.exit(1)

    n = int(sys.argv[1])
    
    # For n up to 64, we can store each row in a 64-bit integer.
    # The method only remains feasible for n roughly up to 12 due to 2^n growth.
    if n &gt; 64:
        print(f&quot;{n} is too large to represent in 64 bits.&quot;)
        sys.exit(1)

    # Generate all possible row bit patterns (from 0 to 2^n - 1)
    # and store them with their count of ones
    all_rows = []
    for row_pattern in range(1 &lt;&lt; n):
        all_rows.append((row_pattern, bin(row_pattern).count('1')))

    # Sort rows by descending number of 1 bits
    all_rows.sort(key=lambda x: x[1], reverse=True)

    best_solution = []
    best_ones = [0]  # use list for mutability in function
    
    # You can adjust the search duration limit if desired
    start_time = time.time()
    time_limit_secs = 55
    end_time = start_time + time_limit_secs

    backtrack(all_rows, n, [], 0, best_solution, best_ones, end_time)

    # Convert the chosen row bit patterns into a 2D matrix
    matrix = []
    for row_val in best_solution:
        # build a list of bits '0' or '1'
        row_bits = [(row_val &gt;&gt; col) &amp; 1 for col in range(n)]
        # If you want bits in left-to-right order as standard reading, reverse them:
        # row_bits.reverse()
        matrix.append(row_bits)

    # Print the matrix row by row
    for row in matrix:
        print(&quot; &quot;.join(map(str, row)))

if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
</div>
<div id="pu3" class="pu"><h1>Rust, <code>n=12</code> in less than 60 seconds on my laptop.</h1>
<pre class="lang-rust prettyprint-override"><code>use std::time::Instant;

/// Returns the Hamming distance (count of differing bits) between two bit patterns.
fn hamming_distance(a: u64, b: u64) -&gt; u32 {
    (a ^ b).count_ones()
}

/// Returns the count of positions where both bit patterns have a '1'.
fn common_ones(a: u64, b: u64) -&gt; u32 {
    (a &amp; b).count_ones()
}

/// Checks if two rows (bit patterns) are &quot;unfriendly&quot;:
/// distance &gt; number of common ones.
fn is_unfriendly(a: u64, b: u64) -&gt; bool {
    hamming_distance(a, b) &gt; common_ones(a, b)
}

/// Tries to build an unfriendly matrix by picking rows in descending order of their 1-count.
/// - `rows_sorted` is a list of all bit patterns with their 1-count sorted descending.
/// - `n` is the matrix dimension.
/// - `chosen` holds currently picked row bit patterns.
fn backtrack(
    rows_sorted: &amp;[(u64, u32)],
    n: usize,
    chosen: &amp;mut Vec&lt;u64&gt;,
    start_index: usize,
    best_solution: &amp;mut Vec&lt;u64&gt;,
    best_ones: &amp;mut u32,
    time_limit: std::time::Duration,
    start_time: Instant,
) {
    // If time exceeded, stop searching.
    if Instant::now().duration_since(start_time) &gt; time_limit {
        return;
    }

    // If we already have n rows, update the best solution if better.
    if chosen.len() == n {
        let sum_ones: u32 = chosen
            .iter()
            .map(|&amp;r| r.count_ones())
            .sum();
        if sum_ones &gt; *best_ones {
            *best_ones = sum_ones;
            *best_solution = chosen.clone();
        }
        return;
    }

    // Prune if the maximum possible 1s from here cannot beat current best:
    // (sum of chosen ones + sum of top row-ones in the future)
    let chosen_sum: u32 = chosen.iter().map(|&amp;r| r.count_ones()).sum();
    let max_possible = chosen_sum
        + rows_sorted[start_index..]
            .iter()
            .take(n - chosen.len())
            .map(|&amp;(_, ones)| ones)
            .sum::&lt;u32&gt;();
    if max_possible &lt;= *best_ones {
        return;
    }

    // Try to pick rows from start_index onward.
    for i in start_index..rows_sorted.len() {
        // Quick check for time limit again.
        if Instant::now().duration_since(start_time) &gt; time_limit {
            break;
        }

        let (candidate_row, _) = rows_sorted[i];
        // Check if candidate_row is unfriendly with all chosen rows so far.
        let mut valid = true;
        for &amp;prev_row in &amp;*chosen {
            if !is_unfriendly(candidate_row, prev_row) {
                valid = false;
                break;
            }
        }
        // If it is unfriendly with all, pick it and recurse.
        if valid {
            chosen.push(candidate_row);
            backtrack(
                rows_sorted,
                n,
                chosen,
                i + 1,
                best_solution,
                best_ones,
                time_limit,
                start_time,
            );
            chosen.pop();
        }
    }
}

fn main() {
    // Read n from command line or default to something for demonstration.
    let args: Vec&lt;String&gt; = std::env::args().collect();
    if args.len() &lt; 2 {
        eprintln!(&quot;Usage: {} &lt;n&gt;&quot;, args[0]);
        return;
    }
    let n: usize = args[1].parse().expect(&quot;Invalid integer for n&quot;);

    // For n up to 64, we can store each row in a 64-bit integer.
    // We will explore all possible 2^n patterns (feasible up to about n=12).
    if n &gt; 64 {
        eprintln!(&quot;n = {} is too large to be encoded in 64 bits.&quot;, n);
        return;
    }

    // Generate all possible row bit patterns for n bits.
    // Store them alongside their count of 1s for sorting.
    let mut all_rows = Vec::new();
    for row_pattern in 0..(1u64 &lt;&lt; n) {
        all_rows.push((row_pattern, row_pattern.count_ones()));
    }

    // Sort patterns by descending number of 1s.
    all_rows.sort_by(|a, b| b.1.cmp(&amp;a.1));

    // We'll store the best solution found (list of row patterns),
    // and the best sum of 1s so far.
    let mut best_solution = Vec::new();
    let mut best_ones = 0;

    // Set a time limit (e.g., 55 seconds, giving some buffer under 60).
    let time_limit = std::time::Duration::from_secs(55);
    let start_time = Instant::now();

    // Backtracking search.
    let mut chosen = Vec::new();
    backtrack(
        &amp;all_rows,
        n,
        &amp;mut chosen,
        0,
        &amp;mut best_solution,
        &amp;mut best_ones,
        time_limit,
        start_time,
    );

    // Output the resulting matrix.
    // Each selected row bit pattern is output as '0/1' across n columns.
    let mut matrix = vec![vec![0; n]; n];
    for (row_index, &amp;pattern) in best_solution.iter().enumerate() {
        for col_index in 0..n {
            // If the col_index-th bit is set, fill with 1.
            // Note that bit 0 is the least significant bit, so we check that carefully.
            if (pattern &amp; (1 &lt;&lt; col_index)) != 0 {
                matrix[row_index][col_index] = 1;
            }
        }
    }

    // Print the matrix row by row.
    // If you want columns in &quot;left to right&quot; order matching bits from left to right:
    // you can invert the indexing in the loop above.
    for row in matrix {
        println!(
            &quot;{}&quot;,
            row.iter()
                .map(|&amp;bit| bit.to_string())
                .collect::&lt;Vec&lt;String&gt;&gt;()
                .join(&quot; &quot;)
        );
    }
}
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/277377/">277377</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




