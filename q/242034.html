<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::242034</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>097</td><td>05AB1E</td><td>220131T140857Z</td><td><a href="https://codegolf.stackexchange.com/questions/242034/find-the-biggest-chunk/242094#242094">Kevin Cr</a></td></tr>
<tr d-ix="1"><td>181</td><td>Pip r</td><td>220305T051719Z</td><td><a href="https://codegolf.stackexchange.com/questions/242034/find-the-biggest-chunk/243689#243689">DLosc</a></td></tr>
<tr d-ix="2"><td>108</td><td>BQN</td><td>220130T133826Z</td><td><a href="https://codegolf.stackexchange.com/questions/242034/find-the-biggest-chunk/242037#242037">ovs</a></td></tr>
<tr d-ix="3"><td>613</td><td>JavaScript Node.js</td><td>220131T083329Z</td><td><a href="https://codegolf.stackexchange.com/questions/242034/find-the-biggest-chunk/242069#242069">l4m2</a></td></tr>
<tr d-ix="4"><td>320</td><td>Python 3</td><td>220131T013756Z</td><td><a href="https://codegolf.stackexchange.com/questions/242034/find-the-biggest-chunk/242060#242060">Surculos</a></td></tr>
<tr d-ix="5"><td>051</td><td>Jelly</td><td>220130T225822Z</td><td><a href="https://codegolf.stackexchange.com/questions/242034/find-the-biggest-chunk/242054#242054">Jonathan</a></td></tr>
<tr d-ix="6"><td>211</td><td>JavaScript ES7</td><td>220130T232626Z</td><td><a href="https://codegolf.stackexchange.com/questions/242034/find-the-biggest-chunk/242055#242055">Arnauld</a></td></tr>
<tr d-ix="7"><td>305</td><td>Charcoal v</td><td>220130T223824Z</td><td><a href="https://codegolf.stackexchange.com/questions/242034/find-the-biggest-chunk/242053#242053">Neil</a></td></tr>
<tr d-ix="8"><td>167</td><td>Python SciPy</td><td>220130T144900Z</td><td><a href="https://codegolf.stackexchange.com/questions/242034/find-the-biggest-chunk/242038#242038">loopy wa</a></td></tr>
<tr d-ix="9"><td>518</td><td>JavaScript Node.js</td><td>220130T131346Z</td><td><a href="https://codegolf.stackexchange.com/questions/242034/find-the-biggest-chunk/242036#242036">ophact</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, score 1, <s>107</s> <s>101</s> 97 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>S ¶ ¡ ζ ζ ð Ê Ð U ˜ ƶ s g ä Δ 4 F ¬ a š ø í } 2 F ø € ü 3 } X * ε ε 1 è y ø 1 è « à ] ˜ 0 K D ¢ à
</code></pre>
<p><a href="https://tio.run/##HYwhC8JgFEX7fsVh0aTOoF0sRhEshoki8m0sPAwGi9FkMBpUDIIKFofB9D20CPsR/pH5bY8bDudeXiLhaDbJ8x42xR7I0iJ6R9fohj7fHZ8UYYqeyLY06GCvhLwP6BO9saTunOPf6oq@CJwZUCF7FKmhZxZFXZK9oHuGxdsqXdrYoxN57vt@GIkZx14oJgJJvDiWOTRb4uHOSD02JQYmksjt/w" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##NYy9SsRAGEV7n@IwWEkQTRRWGy1EkC0sRBGcLbJuFJlkVpiNkMLG0srC0sIVC39WsTFYWM2gjZCH8EViJotw4f58nG9o4v5JUot6B1tix1Sll3vDXeKu2OXnhu8SwzHunuqaJTaxE2K@xrgP3AvnhM3W5N@LCe6TqFn2maN691rEPVD4c5vsM@6Wnn@7QJcN7F0z1MKWXfton87Elj7NR6uIoAhmxHY@@m/2dX4vsOVafSBiESBipiZ168sxs02Edd@K3EjdgVBqIPJTFEa@SK2SlkuNGmQNYVQKZih1lpkcOiumZVAmzNQ0Ryo1qYeI@1IfMpA6ORK9Pw" rel="nofollow noreferrer">verify all test cases</a>.</p>
<p><strong>Explanation:</strong></p>
<p>Most of it is similar as <a href="https://codegolf.stackexchange.com/search?q=user%3A52210+05ab1e+flood-fill">my other 05AB1E flood-fill answers</a>, except that I've prevented using 2-byte builtins like <code>.ø</code> and <code>Ås</code>. (Also, <code>S¶¡ζζ</code> could have been <code>.B€S</code>, but <code>.B</code> is a 2-byte builtin as well.)</p>
<p>Step 1. Convert the input to a matrix of characters:</p>
<pre><code>S        # Convert the (implicit) input-string to a list of characters
 ¶¡      # Split it on newlines to a character-matrix
</code></pre>
<p>Step 2. Right-pad this input-matrix with spaces:</p>

<pre class="lang-none prettyprint-override"><code>ζ        # Zip/transpose the input-matrix; swapping rows/columns,
         # using a space as filler if the rows are of unequal length
 ζ       # Zip/transpose back
</code></pre>
<p>Step 3. Transform all spaces to <code>0</code> and all other characters to <code>1</code>:</p>
<pre class="lang-none prettyprint-override"><code>ðÊ       # Check for each character whether it's NOT a space
         # (0 if a space; 1 otherwise)
  Ð      # Triplicate the matrix
   U     # Pop and store a copy in variable `X`
</code></pre>
<p>Step 4. Create a matrix of the same size with unique positive integers:</p>
<pre class="lang-none prettyprint-override"><code>˜        # Flatten the matrix
 ƶ       # Multiply every 1 by its 1-based index
  s      # Swap so the matrix is at the top
   g     # Pop and push its length (amount of rows)
    ä    # Split the list into that many equal-sized parts
</code></pre>
<p>Step 5. Flood-fill this matrix based on the matrix of 0s/1s we stored in variable <code>X</code>:</p>
<pre class="lang-none prettyprint-override"><code>Δ        # Loop until the matrix no longer changes:
</code></pre>
<p>Step 5.1: Add a border of 0s around the matrix:</p>
<pre class="lang-none prettyprint-override"><code> 4F      #  Loop 4 times:
   ¬     #   Push the first row (without popping the matrix)
    a    #   Convert all values to 0 using an &quot;isLetter&quot; check
     š   #   Prepend that list of 0s to the matrix
      øí #   Rotate the matrix once clockwise:
      ø  #    Zip/transpose; swapping rows/columns
       í #    Reverse each inner row
  }      #  Close the loop
</code></pre>
<p>Step 5.2: Create overlapping 3x3 blocks of this matrix:</p>
<pre class="lang-none prettyprint-override"><code> 2F      #  Loop 2 times:
   ø     #   Zip/transpose; swapping rows/columns
    €    #   Map over each row:
     ü3  #    Pop and push its overlapping triplets
  }      #  Close the loop
</code></pre>
<p>Step 5.3: Transform the <code>0</code>s back, based on the matrix of variable <code>X</code>:</p>
<pre class="lang-none prettyprint-override"><code>   X*    #  Multiply the values at the same positions by matrix `X`
</code></pre>
<p>Step 5.4: For each 3x3 block, get the maximum of its center and its horizontal/vertical neighbors:</p>
<pre class="lang-none prettyprint-override"><code> εε      #  Nested map over the 3x3 blocks:
   1è    #    Get the middle row
   yø1è  #    As well as the middle column
   «     #    Merge these triplets together
   à     #    Pop and push the maximum of this list
]        #  Close the nested maps and until_no_changes loop
</code></pre>
<p>Step 6: Check which island is the largest:</p>
<pre class="lang-none prettyprint-override"><code>˜        # Flatten the matrix to a list
 0K      # Remove all 0s
   D     # Duplicate this list
    ¢    # Count each value
     à   # Pop and push the maximum
         # (after which it is output implicitly as result)
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/dloscutoff/pip" rel="nofollow noreferrer">Pip</a> <code>-r</code>, score 1, 181 bytes</h1>
<pre><code>g M : 1 - { _ Q s M a } + $ + : ^ 0 X # _ M g W J % : g { i : # : K 0 ~ J g ( g i / Y # @ g i % y ) : 2 L y + # g g : Z ( J * g ) R K 1 . 2 . K 1 2 X # _ Y 2 N J g I y &gt; x x : y } x
</code></pre>
<p>Takes input from stdin. <a href="https://ato.pxeger.com/run?1=LY_NasJAFIX3PsWHUfCHWBM3MYvSbbUKdmNVVALiECah4ihYir6IG0HaN-jD-DY9ROdymW_OPffOzPm6STe_s7K_Lc8vP_vd2o9uf4YBMQE-3ywZ4XROONKkooxZ0OYDT7UBhjE9qlKN3Kl2T9mX4yTdUFOmPDGR_lJwlS_q8oS8iZrSjSJmKm-PhrjOuyYEtORpFRQ-7puIhsXcV_U-c1DEoiOH--Mff7jcgiRzdpVDKXE2A_cpzHO3h6jrSmhZF-a2wI7NXHbv_Ac" rel="nofollow noreferrer">Attempt This Online!</a> (Runs all of the test cases easily, but times out if passed its own source code.)</p>
<h3>Explanation</h3>
<p>Several operators that would have been useful are two characters (<code>ZD</code>, <code>MM</code>, <code>MX</code>, <code>@?</code>), so we have to work around them.</p>
<pre><code>gM:1-{_QsMa}+$+:^0X#_Mg
g                        List of lines of stdin (due to -r flag)
 M:                      Map this function to each line in-place:
     {   Ma}              Map this function to each character of the line:
      _Qs                  Is it equal to space? (1 if so, 0 if not)
   1-                     Subtract each result from 1, swapping 1s with 0s
            +             Pad each line to the same length by adding the following:
                     Mg    Map this function to each line of the input:
                   #_       Length of the line
                 0X         String of that many zeros
                ^           Split into a list of digits
             $+:           Sum down the columns of the resulting list of lists
</code></pre>
<p>Here's a demonstration of how the padding logic works:</p>
<pre><code>         g  [&quot;ab&quot;; &quot;cde&quot;; &quot;&quot;; &quot;f&quot;]
      #_M   [2; 3; 0; 1]
    0X      [00; 000; &quot;&quot;; 0]
   ^        [[0; 0]; [0; 0; 0]; []; [0]]
$+:         [0; 0; 0]
</code></pre>
<p>When two lists of different lengths are added, the part of the longer one that sticks out past the end of the shorter one is included in the result unchanged. Thus, summing the list of lists gives us the longest list-of-zeros in it, and adding that list to each processed row from the input essentially right-pads it with zeros to match the length of the longest row.</p>
<pre><code>W J%:g{...}x
W             Loop while
     g         g, which is now a list of lists of integers
   %:          Take each of those numbers mod 2 in-place
  J            Join them together into a single string
              is truthy (i.e. not all 0s):
      {...}    (see below)
           x  After the loop, x holds the max chunk size; output it
</code></pre>
<p>The initial value of <code>x</code> is <code>&quot;&quot;</code>, which is equivalent to 0 in numeric contexts. Since the maximum chunk is of size at least 1, the value of <code>x</code> will always be updated, so we don't have to worry about the possibility of outputting its initial value.</p>
<p>Our flood-fill algorithm finds a chunk of 1s and turns them into 2s. The mod-2 operation at the beginning of the loop then turns these 2s into 0s. Once all chunks have been found, <code>g</code> is entirely 0s, at which point the loop halts.</p>
<p>Inside the loop, the first thing we do is find a 1 and change it to 2:</p>
<pre><code>i:#:K0~Jg (gi/Y#@gi%y):2
       Jg                 Join g into a single string
      ~                   Find the first regex match of
    K0                    0, zero or more times (equivalent to `0*`)
  #:                      Length of that match
                          This is the row-major flat index of the first nonzero entry in g
i:                        Store it in i
                @g        First row in g
               #          Length
              Y           Yank that value into y
          (g         )    Index into g at
            i/             Row: i/y
                  i%y      Column: i mod y
                      :2  Set the element at that location to 2
</code></pre>
<p>Then we flood-fill by changing every run of 1s adjacent to a 2 to a run of 2s, swapping rows for columns, and repeating several times:</p>
<pre><code>Ly+#g g:Z(J*g)R K1 .2.K1 2X#_
L                              Loop
 y                              Length of first row in g (width of grid)
  +                             Plus
   #g                           Length of g (height of grid)
                               times:
          J*g                   Join each row in g into a single string
         (   )R                 Replace each match of this regex:
                K1               1, zero or more times
                   .2            Followed by 2
                     .K1         Followed by 1, zero or more times
                                with this callback function:
                           #_    Length of match
                         2X      String of that many 2s
        Z                       Zip (transpose) the resulting list of strings
                                (note: it becomes a list of lists of digits again)
      g:                        Assign back to g
</code></pre>
<p>Finally, we get the size of the chunk we just found and update <code>x</code> if the chunk size is bigger:</p>
<pre><code>Y2N Jg Iy&gt;xx:y
    Jg          Join g into a single string
 2N             Count the number of 2s
Y               Yank that value into y
       I        If
        y&gt;x     y (chunk size) is greater than x (previous max chunk size):
           x:y   Set x to y
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/242034/">242034</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




