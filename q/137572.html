<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::137572</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>019</td><td>MATL</td><td>170804T153334Z</td><td><a href="https://codegolf.stackexchange.com/questions/137572/approximate-the-dottie-number-to-arbitrary-precision/137578#137578">Luis Men</a></td></tr>
<tr d-ix="1"><td>068</td><td>APLNARS</td><td>231220T220009Z</td><td><a href="https://codegolf.stackexchange.com/questions/137572/approximate-the-dottie-number-to-arbitrary-precision/268661#268661">Rosario</a></td></tr>
<tr d-ix="2"><td>188</td><td>Zephyr</td><td>250123T184846Z</td><td><a href="https://codegolf.stackexchange.com/questions/137572/approximate-the-dottie-number-to-arbitrary-precision/277838#277838">DLosc</a></td></tr>
<tr d-ix="3"><td>093</td><td>Maxima</td><td>231222T081416Z</td><td><a href="https://codegolf.stackexchange.com/questions/137572/approximate-the-dottie-number-to-arbitrary-precision/268693#268693">138 Aspe</a></td></tr>
<tr d-ix="4"><td>006</td><td>Vyxal</td><td>231220T063303Z</td><td><a href="https://codegolf.stackexchange.com/questions/137572/approximate-the-dottie-number-to-arbitrary-precision/268656#268656">emanresu</a></td></tr>
<tr d-ix="5"><td>033</td><td>Juby</td><td>221212T183607Z</td><td><a href="https://codegolf.stackexchange.com/questions/137572/approximate-the-dottie-number-to-arbitrary-precision/255424#255424">Jordan</a></td></tr>
<tr d-ix="6"><td>nan</td><td></td><td>221212T203336Z</td><td><a href="https://codegolf.stackexchange.com/questions/137572/approximate-the-dottie-number-to-arbitrary-precision/255427#255427">bigyihsu</a></td></tr>
<tr d-ix="7"><td>267</td><td>Haskell</td><td>211212T161011Z</td><td><a href="https://codegolf.stackexchange.com/questions/137572/approximate-the-dottie-number-to-arbitrary-precision/238433#238433">Benji</a></td></tr>
<tr d-ix="8"><td>035</td><td>PowerShell Core</td><td>211212T202930Z</td><td><a href="https://codegolf.stackexchange.com/questions/137572/approximate-the-dottie-number-to-arbitrary-precision/238443#238443">Julian</a></td></tr>
<tr d-ix="9"><td>047</td><td>Pari/GP</td><td>211209T113222Z</td><td><a href="https://codegolf.stackexchange.com/questions/137572/approximate-the-dottie-number-to-arbitrary-precision/238274#238274">alephalp</a></td></tr>
<tr d-ix="10"><td>042</td><td>Julia 1.0</td><td>211209T110238Z</td><td><a href="https://codegolf.stackexchange.com/questions/137572/approximate-the-dottie-number-to-arbitrary-precision/238273#238273">MarcMush</a></td></tr>
<tr d-ix="11"><td>019</td><td>Wolfram Language Mathematica</td><td>170804T230946Z</td><td><a href="https://codegolf.stackexchange.com/questions/137572/approximate-the-dottie-number-to-arbitrary-precision/137680#137680">ZaMoC</a></td></tr>
<tr d-ix="12"><td>030</td><td>GNU bc l</td><td>170804T182511Z</td><td><a href="https://codegolf.stackexchange.com/questions/137572/approximate-the-dottie-number-to-arbitrary-precision/137617#137617">Digital </a></td></tr>
<tr d-ix="13"><td>066</td><td>Factor + math.polynomials math.factorials</td><td>210305T041555Z</td><td><a href="https://codegolf.stackexchange.com/questions/137572/approximate-the-dottie-number-to-arbitrary-precision/220209#220209">Bubbler</a></td></tr>
<tr d-ix="14"><td>084</td><td>JavaScript Node.js</td><td>200311T121502Z</td><td><a href="https://codegolf.stackexchange.com/questions/137572/approximate-the-dottie-number-to-arbitrary-precision/200873#200873">Shieru A</a></td></tr>
<tr d-ix="15"><td>055</td><td>dzaima/APL</td><td>200309T175021Z</td><td><a href="https://codegolf.stackexchange.com/questions/137572/approximate-the-dottie-number-to-arbitrary-precision/200812#200812">dzaima</a></td></tr>
<tr d-ix="16"><td>054</td><td>Pyth</td><td>200309T160109Z</td><td><a href="https://codegolf.stackexchange.com/questions/137572/approximate-the-dottie-number-to-arbitrary-precision/200803#200803">Citty</a></td></tr>
<tr d-ix="17"><td>174</td><td>Axiom</td><td>170805T074529Z</td><td><a href="https://codegolf.stackexchange.com/questions/137572/approximate-the-dottie-number-to-arbitrary-precision/137713#137713">user5898</a></td></tr>
<tr d-ix="18"><td>042</td><td>Octave</td><td>170804T212006Z</td><td><a href="https://codegolf.stackexchange.com/questions/137572/approximate-the-dottie-number-to-arbitrary-precision/137662#137662">Sanchise</a></td></tr>
<tr d-ix="19"><td>044</td><td>Mathematica 44 Bytes</td><td>170804T193537Z</td><td><a href="https://codegolf.stackexchange.com/questions/137572/approximate-the-dottie-number-to-arbitrary-precision/137629#137629">Kelly Lo</a></td></tr>
<tr d-ix="20"><td>041</td><td>Perl 5</td><td>170804T193341Z</td><td><a href="https://codegolf.stackexchange.com/questions/137572/approximate-the-dottie-number-to-arbitrary-precision/137628#137628">theLambG</a></td></tr>
<tr d-ix="21"><td>050</td><td>PHP</td><td>170804T175308Z</td><td><a href="https://codegolf.stackexchange.com/questions/137572/approximate-the-dottie-number-to-arbitrary-precision/137612#137612">Alex Nei</a></td></tr>
<tr d-ix="22"><td>055</td><td>R +Rmpfr</td><td>170804T153840Z</td><td><a href="https://codegolf.stackexchange.com/questions/137572/approximate-the-dottie-number-to-arbitrary-precision/137581#137581">Giuseppe</a></td></tr>
<tr d-ix="23"><td>046</td><td>Mathics or Mathematica</td><td>170804T160033Z</td><td><a href="https://codegolf.stackexchange.com/questions/137572/approximate-the-dottie-number-to-arbitrary-precision/137584#137584">notjagan</a></td></tr>
<tr d-ix="24"><td>058</td><td>Python 3</td><td>170804T153302Z</td><td><a href="https://codegolf.stackexchange.com/questions/137572/approximate-the-dottie-number-to-arbitrary-precision/137577#137577">Dennis</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/lmendo/MATL" rel="nofollow noreferrer">MATL</a>, <s>34</s> <s>30</s> 19 bytes</h1>
<p><em>11 bytes off thanks to <a href="https://codegolf.stackexchange.com/users/32352/sanchises">Sanchises</a>!</em></p>
<pre><code>48i:&quot;'cos('wh41hGY$
</code></pre>
<p>The last decimal figures in the output may be off. However, the number of correct figures starting from the left increases with the input, and the result converges to the actual constant.</p>
<p><a href="https://tio.run/##y00syfn/38Qi00pJPTm/WEO9PMPEMMM9UuX/fyMDAwA" rel="nofollow noreferrer"><strong>Try it online!</strong></a></p>
<h3>Explanation</h3>
<p>For input <em>n</em>, and starting at <em>x</em>=1, this applies the function</p>
<p>              <em>x</em> ↦ cos(<em>x</em>)</p>
<p>with <em>n</em>-digit <a href="https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic" rel="nofollow noreferrer">variable-precision arithmetic</a> <em>n</em> times.</p>
<pre><code>48         % Push 48, which is ASCII for '1': initial value for x as a string
i:&quot;        % Do n times, where n is the input
  'cos('   %   Push this string
  w        %   Swap. Moves current string x onto the top of the stack
  h        %   Concatenate
  41       %   Push 41, which is ASCII for ')'
  h        %   Concatenate. This gives the string 'cos(x)', where x is the
           %   current number
  GY$      %   Evaluate with variable-precision arithmetic using n digits
           %   The result is a string, which represents the new x
           % End (implicit). Display (implicit). The stack contains the last x
</code></pre>
</div>
<div id="pu1" class="pu"><h1>APL(NARS), 68 chars</h1>
<pre><code>r←D w;e;v;⎕FPC
⎕FPC←4×w⋄e←1÷10x*w⋄v←1x
r←2○v⋄→0×⍳e&gt;∣v-r⋄v←r⋄→2

f←⍕∘D⍨
</code></pre>
<p>//15+24+23+6=68
It seems that is possible approssimate the number <code>c</code> where <code>cos(c)=c</code>, with the succession <code>{x_i}</code> that is build
in this way:</p>
<pre><code>x_1=1 and x_(i+1)=cos(x_i), and we know lim_(i-&gt;+oo)x_i=c.
</code></pre>
<p>All easy... the code for find the solution thru succession (is the <code>D</code> function that has argument the decimal precision)
and code for print the result (<code>f</code> function that has as argument the decimal precision).
<code>⎕FPC</code> is a local variable that not change outside the function <code>D</code>, it would represent the precision (in base 2 it seems)
of the float calculations we run inside the <code>D</code> function. One observation, the result of <code>D</code> function it seems a large obj enough for
contain the number that live outside the function, and <code>⍕</code> it seems can adjust inside the ⎕FPC variable, for print right the obj it recieve. Because it seems</p>
<pre><code>Ndigits_base_2(Number)=1+⌊Ndigits_base_10(Number) x 3.32192809  
</code></pre>
<p>I choose the 4 in <code>4×w</code> in D function, but in other functions that number is not enought...</p>
<p>Test:</p>
<pre><code>  f 1
0.7
  f 10
0.7390851332
  f 300
0.73908513321516064165531208767387340401341175890075746496568063577328465488354759459937610
  69317665318498012466439871630277149036913084203157804405746207786885249038915392894388
  45095234801335631276772231580956353776572451204373419936433512538409780034340646700479
  402143478080271801883771136138204206631
  ⎕FPC
128
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/dloscutoff/zephyr" rel="nofollow noreferrer">Zephyr</a>, 188 bytes</h1>
<pre><code>input n as Integer
set x to 1
for i from 1to n
set c to 1
for j from 1to i
set t to 1
for k from 1to j
set t to((t*((-x)*x))/((2*k)-1))/(2*k)
next
set c to c+t
next
set x to c
next
print x
</code></pre>
<p>Outputs as a rational number, which gets unwieldy very fast. <a href="https://tio.run/##Rc5BCsMwDATAu1@ho@wSggt9RJ9RjNI4obJxVHDzeTdxobqtdg6rnfL8Ka1Fzm8BhscGdxZ6UjEbCVSQBN5MqUCEqaQX@KPgbkFtUYvdRG1VW/6GKA5xqNZVa0fEq1vt4M94JsNURTfCRbTpH4XfnUvko2nt9gU" rel="nofollow noreferrer" title="Zephyr – Try It Online">Try it online!</a></p>
<p>Uses the same Taylor series approach as <a href="https://codegolf.stackexchange.com/a/220209/16766">Bubbler's Factor answer</a>. <code>x</code> is the number on which the cosine approximation is repeatedly applied; each term of the series is calculated in <code>t</code> and then added to the running total to get the cosine approximation <code>c</code>. Because Zephyr doesn't have factorials or exponentials, we have to calculate them using a loop (the <code>k</code> loop).</p>
</div>
<div id="pu3" class="pu"><h1><a href="http://maxima.sourceforge.net/" rel="nofollow noreferrer">Maxima</a>, 93 bytes</h1>
<p>A port of <a href="https://codegolf.stackexchange.com/a/238273/110802">@MarcMush's Julia 1.0 answer</a> in Maxima.</p>
<p>93 bytes, it can be golfed much more.</p>
<hr />
<p>Golfed version. <a href="https://tio.run/##NY69DoMwDIT3PIVHgqiAjmm79QG6Vx0gJMIq2CgJ/Xn6NBHFy8mf7k43dx@cu1iXcDUWyUAYDTijV@fxZcCupAMywRvDCMOXuhk1LMmAPuOyFrEvSKpLP7F@Fnd@VKzskh3VJooqp9ACnY@5nKC3E3chhczkzf5p9kUqOrRSyj3IlZPxJEQad3NI4b/Nr1PwYB3P0EJgaJumyUMsO0CV0OjWDQ4MhYB0S46nfpRSyFP8AQ" rel="nofollow noreferrer">Try it online!</a></p>
<pre><code>b(n):=block([o],o:fpprec,fpprec:n,r:if n&lt;2 then bfloat(n)else bfloat(cos(b(n-1))),fpprec:o,r)
</code></pre>
<p>Ungolfed version. <a href="https://tio.run/##fZHBTsQgEIbvfYo5lo1mW49Vbz6A0ePGGEqHlEihGWB3ffrKtLa7GxO5EIb/G/5/GOTZDHLa7@AFtXEIsUcgVImCOSLo5FQ03sHJxB66bycHo2DMAhO4vNsXbekENM/QWq@@ygLyOnjbfbLo424@5@7v8rj0zle3PAtWfQN65P2CYZypC0FoZWRr0cPGL1QDbgNfkbSnYYaVtCoxtebgosPTXx@EIdnYgNG59xM8sNJBq62XkWOiDbgelQ9lzn5fCyG2Z98wRE//JF2dromvyJjI/Y6fXdx6KsRjUXAuMi5eqQJo8gPUPI66qiqmcnAwTS71lJZi52H5mZHxbNsIkTtO0/QD" rel="nofollow noreferrer">Try it online!</a></p>
<pre><code>/* Define the recursive function with dynamic precision */
b(n) := block(
    [old_prec],
    /* Save the old precision */
    old_prec: fpprec,
    /* Set the precision relative to n */
    fpprec: n,
    /* Perform the calculation with the new precision */
    result: if n &lt; 2 then bfloat(n) else bfloat(cos(b(n-1))),
    /* Restore the old precision */
    fpprec: old_prec,
    /* Return the result */
    result
);

/* Print the results from 1 to 1000 */
for i:1 thru 1000 do (
    print(b(i))
);
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal/tree/version-2" rel="nofollow noreferrer">Vyxal</a>, 6 bytes</h1>
<pre><code>(∆c)$Ḟ
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/?v=2&amp;c=1#WyJBIiwiIiwiKOKIhmMpJOG4niIsIiIsIjVcbjEwXG4yMFxuNTBcbjEwMCJd" rel="nofollow noreferrer">Try it Online!</a></p>
<p>Uses sympy's arbitrary-precision cosine function. Since decimals are outputted to a fixed precision (although stored as arbitrary-precision) it has to be taken to n decimal places.</p>
<pre><code>(  )   # n times
 ∆c    # cosine
    $Ḟ # result to n decimal places
</code></pre>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/cyoce/J-uby" rel="nofollow noreferrer">J-uby</a>, 33 bytes</h1>
<p>Takes the desired precision as an argument.</p>
<pre class="lang-ruby prettyprint-override"><code>~:!~%(:&amp; &amp;~(:cos&amp;BigMath))&amp;0.to_d
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m700K740qfKmVbSSblFSZnpKanJmbmKOko4CCl8_N7EkA0OwtCQzRyl2kZvt0tKSNF2Lm4p1Vop1qhpWagpqdRpWyfnFak6Z6b5AnZqaagZ6JfnxKRCFywoU3KItYiGcBQsgNAA" rel="nofollow noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu6" class="pu">
<h1><a href="https://go.dev" rel="nofollow noreferrer">Go</a>, 71 bytes</h1>
<pre class="lang-go prettyprint-override"><code>import.&quot;math&quot;
func f(n int)(k float64){for;n&gt;=0;n--{k=Cos(k)}
return k}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=PY5NCoMwFIT3OcUjq0SqSCmlVOymi25LbxCKsY_oi8TnSjxJN1LoobxNtX-rgRnmm7k_Sj9OUWOuzpQF1AZJYN34wIlsOSCVrfwbtmb57NjGu-n082rDNylsR1ewigCJtXJgK294u9G99SGjQ55mFMe9y4--VU4PIhTcBQI3_HBvwLKuNPRibgHCPodgaH51KZrCsJKJXK3TJccoR3Ge33FFClfzMmotBvHFjeNHXw" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Input is the number of times to apply <code>cos</code>. Limited to 64-bit floating point precision.</p>
</div>
<div id="pu7" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, 267 bytes</h1>

<pre class="lang-hs prettyprint-override"><code>f d=(iterate(\(b,e)-&gt;r(\(x,y)(z,w)-&gt;(x*10^(2*d-y)+z*10^(2*d-w),2*d))(0,0)$takeWhile((/=0).fst)[r(\(x,y)(z,w)-&gt;(x*z,y+w))((-1)^n,0)[let z=2*e*n;s=max(z-d)0in(b^(2*n)`div`10^s,z-s),(10^d`div`product[2..2*n],d)]|n&lt;-[0..]])(7,1))#[];(h:t)#v|h`elem`v=h|0&lt;1=t#(h:v);r=foldr
</code></pre>
<p><a href="https://tio.run/##ZU/BboMwDP2VqOxgQ8gCl0prwxfstsMOjAq6BAWVhiqk0KL@O3N32GUXv/dsPz/ZNuPJ9P26tkwr6ILxTTDwBUduMC08sRu/Iyx8Jgm3OJMHyGOd3jFZ/sSMnAARJJf4EpqT@bRdbwBelUTRjgHL/5cWfk9m8kCa4cGRsexNYIvKYxO73ajOzQ2WVKPsHByfOQ5r3U01hY58SUfkQFT/9i5@0NfvUOZC0F7FNVYPt09LKURVIWx5hhiV1Q7sW8Boetja9OZcT8o@5D5TIaLBhDuv2qHXfj03nWOKedPod8eKQrHLNXwET0Iw2EixSRIkOtphJqAHn3Xdyh8" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
</div>
<div id="pu8" class="pu"><h1><a href="https://github.com/PowerShell/PowerShell" rel="nofollow noreferrer">PowerShell Core</a>, 35 bytes</h1>

<pre class="lang-powershell prettyprint-override"><code>1..&quot;$args&quot;|%{$x=[Math]::Cos($x)}
$x
</code></pre>
<p><a href="https://tio.run/##K8gvTy0qzkjNydFNzi9K/a@SZlv931BPT0klsSi9WKlGtVqlwjbaN7EkI9bKyjm/WEOlQrOWS6Xify0Xl5pKmoKhgYHBfwA" rel="nofollow noreferrer" title="PowerShell Core – Try It Online">Try it online!</a></p>
</div>
<div id="pu9" class="pu"><h1><a href="http://pari.math.u-bordeaux.fr/" rel="nofollow noreferrer">Pari/GP</a>, 47 bytes</h1>
<pre><code>f(n)=if(n,subst(Pol(cos(x+O(x^n))),x,f(n-1)),1)
</code></pre>
<p><a href="https://tio.run/##K0gsytRNL/j/P00jT9M2E0jqFJcmFZdoBOTnaCTnF2tUaPtrVMTlaWpq6lToAKV1DYEsQ83/aflFGnkKtgoGOgpmOgoFRZl5JUC@koKuHZAAGaap@R8A" rel="nofollow noreferrer" title="Pari/GP – Try It Online">Try it online!</a></p>
</div>
<div id="pu10" class="pu"><h1><a href="http://julialang.org/" rel="nofollow noreferrer">Julia 1.0</a>, 42 bytes</h1>

<pre class="lang-julia prettyprint-override"><code>!n=big(n&lt;2||setprecision(()-&gt;cos(!~-n),n))
</code></pre>
<p><a href="https://tio.run/##DcFNCoAgEAbQfafQ3QwUaMuo7tKPxYR8iha0iK5uvXdcXiZ7l6IxzLIT@vZ5sjtjcotkCSDiZlxCJv024BrMZQtJiRIo21ljTKV@MQlOD9LClcNaPg" rel="nofollow noreferrer" title="Julia 1.0 – Try It Online">Try it online!</a></p>
<p>sets the precision of <code>BigFloat</code>s to <code>n</code> bits and computes <span class="math-container">\$cos^{n-1}(1)\$</span> recursively</p>
</div>
<div id="pu11" class="pu"><h1><a href="https://www.wolfram.com/wolframscript/" rel="nofollow noreferrer">Wolfram Language (Mathematica)</a>, 19 bytes</h1>
<pre><code>Nest[Cos,0,9#]~N~#&amp;
</code></pre>
<p><a href="https://tio.run/##y00syUjNTSzJTE78n2773y@1uCTaOb9Yx0DHUjm2zq9OWe1/QFFmXomCQ3q0oYFB7P//AA" rel="nofollow noreferrer" title="Wolfram Language (Mathematica) – Try It Online">Try it online!</a></p>
<p>-3 bytes from @alephalpha</p>
</div>
<div id="pu12" class="pu"><h1>GNU bc -l, 30</h1>
<p>Score includes +1 for <code>-l</code> flag to <code>bc</code>.</p>
<pre><code>for(a=1;a/A-b/A;b=c(a))a=b
a

</code></pre>
<p>The final newline is significant and necessary.</p>
<p><a href="https://tio.run/##S0r@/z8tv0gj0dbQOlHfUTdJ39E6yTZZI1FTM9E2iSuR6////7o5AA" rel="nofollow noreferrer">Try it online</a>.</p>
<p><code>-l</code> does 2 things:</p>
<ul>
<li>enable the &quot;math&quot; library, including <code>c()</code> for cos(x)</li>
<li>sets precision (scale) to 20 decimal places (<code>bc</code> has arbitrary precision calculation)</li>
</ul>
<p>I'm not really clear on the precision requirement.  As it is, this program calculates to 20 decimal places.  If a different precision is required, then <code>scale=n;</code> needs to be inserted at the start of the program, where <code>n</code> is the number of decimal places.  I don't know if I should add this to my score or not.</p>
<p>Note also that for some numbers of decimal places (e.g. 21, but not 20), the calculation oscillates either side of the solution in the last digit.  Thus in the comparison of current and previous iterations, I divide both sides by 10 (<code>A</code>) to erase the last digit.</p>
</div>
<div id="pu13" class="pu"><h1><a href="https://factorcode.org/" rel="nofollow noreferrer">Factor</a> + <code>math.polynomials math.factorials</code>, 66 bytes</h1>
<pre><code>[| x | 1 x [ sq neg x [0,b) [ 2 * n! recip ] map polyval ] times ]
</code></pre>
<p><a href="https://tio.run/##NY0xC8IwFIT3/opzVEqx4qTgKi4u4lQ6pPG1BtMkTVKx0P8ek6LL8e7j3l3LuNc23G@X6/mAF1lFElJzJh165p@LFO2SEn9YGC0npfsEsgVYpjpyMJa8n4wVysPRMJLikR6zPaoyb@pQzfhgRhm1ghugqEvnNm/WEeywgVrBEhcGdVwySENvJqPzoo9VdUj0MRoU8eHUSs38L1qELw" rel="nofollow noreferrer" title="Factor – Try It Online">Try it online!</a></p>
<p>Factor has rational numbers, but no arbitrary-precision decimals. This answer tries to exploit it as much as possible: iterate the evaluation of the fist <code>n</code> terms of Taylor series (more precisely, Maclaurin series) <code>n</code> times, with the starting value of 1. The output is given as a rational number; the floating-point representation is also shown on TIO to check the value in human-readable form.</p>
<p>The function is very slow to calculate and very slow to converge, but in theory it must converge to the Dottie number as <code>n</code> increases, since the iterated function approaches the cosine function, the iteration count increases to infinity, and the whole computation is done in rationals (and therefore exact).</p>
<h3>How it works</h3>
<p>Given a positive integer <span class="math-container">\$n\$</span>, the code approximates the Dottie number as follows:</p>
<p><span class="math-container">$$
\cos{x} = \sum_{i=0}^{\infty}{\frac{(-1)^i}{(2i)!}x^{2i}}
\approx \sum_{i=0}^{n-1}{\frac{(-x^2)^i}{(2i)!}} \\
\text{Dottie number } = \cos{x} \text{ iterated } \infty \text{ times on } 1 \\
\approx \sum_{i=0}^{n-1}{\frac{(-x^2)^i}{(2i)!}} \text{ iterated } n \text{ times on } 1
$$</span></p>
<pre><code>[| x |  ! an anonymous function that takes one arg `x` as a local variable
  1 x [ ... ] times  ! repeat the inner function x times on the value 1...
    sq neg           !   val -&gt; -val^2
    x [0,b)          !   0..x-1
    [ 2 * n! recip ] map  ! convert each number `i` to 1/(2i)!
    polyval          !   evaluate the array as polynomial at the value of -val^2
]
</code></pre>
</div>
<div id="pu14" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 84 bytes</h1>



<pre class="lang-javascript prettyprint-override"><code>n=&gt;"0."+(F=(J,Z=c=0n)=&gt;J?F(J*-I*I/++c/++c/B/B,Z+J):I-Z&gt;&gt;2n?(I=Z,F(B)):I)(B=I=10n**n)
</code></pre>

<p><a href="https://tio.run/##Hcw9CsMwDEDhu2SS/JO4hS4FOeDBIB/BW3CT0hLk0oRc3w0d3vIN7z0d01a@r89upT7mtlAT8p3rOw2RIJlMhZwg@TRGSMqy4kHr8i8MwWSd8M42e3@VEZiyiRDwJIRATBcnSgm2UmWr69yv9QkL3M4jth8" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>

<p>Has a precision of roughly <code>n-1</code> digits. BigInt is used and <code>cos(x)</code> is calculated using its Taylor expansion. The <code>I-Z&gt;&gt;2n</code> part is used only to prevent looping forever (with a cost of 4 bytes and some precision). Although theoretical applicable for arbitrary precision, practical range is <code>n&lt;63</code> because of stack overflow.</p>

<h3>Shorter (82 bytes), no worries about stack overflow, but far fewer precision</h3>

<pre class="lang-javascript prettyprint-override"><code>n=&gt;"0."+eval("for(I=B=10n**n;n--;I=Z)for(Z=J=B,c=0n;J;)Z+=(J=J*-I*I/++c/++c/B/B)")
</code></pre>

<h3>Much shorter (80 bytes), larger range until stack overflow (<code>n&lt;172</code>), but same precision as the 82-byte.</h3>

<pre class="lang-javascript prettyprint-override"><code>n=&gt;"0."+(F=(J,Z=c=0n)=&gt;J?F(J*-I*I/++c/++c/B/B,Z+J):n--?(I=Z,F(B)):I)(B=I=10n**n)
</code></pre>

<h3>If arbitrary precision is not the main point, then 25 bytes:</h3>

<pre class="lang-javascript prettyprint-override"><code>F=n=&gt;n?Math.cos(F(n-1)):1
</code></pre>
</div>
<div id="pu15" class="pu"><h1><a href="https://github.com/dzaima/APL" rel="noreferrer">dzaima/APL</a>, 55 bytes</h1>



<pre class="lang-apl prettyprint-override"><code>⎕←⊃{⍵,⍨-/P,((P÷⍨×)/¨(2×⍳N)⍴¨⊃⍵)÷!2L×⍳N}⍣{⍵≢∪⍵}P←10L*N←⎕
</code></pre>

<p>Using big integer (no big decimals!) arithmetic (where <span class="math-container">\$10^N\$</span> is the equivalent of a <code>1</code>), iterate the first <span class="math-container">\$N\$</span> terms of the Taylor series (an overestimate, but that's fine) until a duplicate has been encountered. May be off by a bit due to lost precision in the end, but, as with other answers, those differences will disappear with higher <span class="math-container">\$N\$</span>.</p>

<p> No TIO link as TIO's dzaima/APL hasn't been updated to support bigintegers.</p>

<p>Example I/O:</p>

<pre class="lang-js prettyprint-override"><code>1
9L

10
7390851332L

100
7390851332151606416553120876738734040134117589007574649656806357732846548835475945993761069317665318L

200
73908513321516064165531208767387340401341175890075746496568063577328465488354759459937610693176653184980124664398716302771490369130842031578044057462077868852490389153928943884509523480133563127677224L
</code></pre>
</div>
<div id="pu16" class="pu"><h1><a href="https://github.com/isaacg1/pyth" rel="nofollow noreferrer">Pyth</a>, <strike>57</strike> 54 bytes</h1>

<pre><code>u_.tG1lX$globals()$"neg"$__import__("decimal").Decimal
</code></pre>

<p>This would be much shorter if we didn't need the Decimal to be up to spec, but it is what it is.</p>

<p>Edit 1: -3 bytes because we need a number anyways, so we can use <code>X</code>s returned copy of <code>globals()</code> length as our starting value, moving it to the end and removing a <code>$</code> and some whitespace.</p>

<p><a href="https://tio.run/##K6gsyfj/vzRer8TdMCdCJT0nPykxp1hDU0UpLzVdSSU@PjO3IL@oJD5eQyklNTkzNzFHSVPPBcL6//9ffkFJZn5e8X/dFAA" rel="nofollow noreferrer" title="Pyth – Try It Online">Try it online!</a></p>
</div>
<div id="pu17" class="pu"><h1>Axiom, 174 bytes</h1>
<pre><code>f(n:PI):Complex Float==(n&gt;10^4=&gt;%i;m:=digits(n+10);e:=10^(-n-7);a:=0;repeat(b:=a+(cos(a)-a)/(sin(a)+1.);if a~=0 and a-b&lt;e then break;a:=b);a:=floor(b*10^n)/10.^n;digits(m);a)
</code></pre>
<p>ungolfed and commented</p>
<pre><code>-- Input: n:PI numero di cifre
-- Output la soluzione x a cos(x)=x con n cifre significative dopo la virgola
-- Usa il metodo di Newton a_0:=a  a_(n+1)=a_n-f(a_n)/f'(a_n)
fo(n:PI):Complex Float==
  n&gt;10^4=&gt;%i
  m:=digits(n+10)
  e:=10^(-n-7)
  a:=0     -- Punto iniziale
  repeat
     b:=a+(cos(a)-a)/(sin(a)+1.)
     if a~=0 and a-b&lt;e then break
     a:=b
  a:=floor(b*10^n)/10.^n
  digits(m)
  a
</code></pre>
<p>results:</p>
<pre><code>(3) -&gt; for i in 1..10 repeat output[i,f(i)]
   [1.0,0.7]
   [2.0,0.73]
   [3.0,0.739]
   [4.0,0.739]
   [5.0,0.73908]
   [6.0,0.739085]
   [7.0,0.7390851]
   [8.0,0.73908513]
   [9.0,0.739085133]
   [10.0,0.7390851332]
                                                               Type: Void
           Time: 0.12 (IN) + 0.10 (EV) + 0.12 (OT) + 0.02 (GC) = 0.35 sec
(4) -&gt; f 300
   (4)
  0.7390851332 1516064165 5312087673 8734040134 1175890075 7464965680 635773284
  6 5488354759 4599376106 9317665318 4980124664 3987163027 7149036913 084203157
  8 0440574620 7786885249 0389153928 9438845095 2348013356 3127677223 158095635
  3 7765724512 0437341993 6433512538 4097800343 4064670047 9402143478 080271801
  8 8377113613 8204206631
                                                      Type: Complex Float
                                   Time: 0.03 (IN) + 0.07 (OT) = 0.10 sec
</code></pre>
<p>I would use the Newton method because it would be faster
than 'repeated cos(x) method'</p>
<pre><code> 800   92x
1000  153x
2000  379x
</code></pre>
<p>where in the first column there is the number of digit
and in the second column there is how much Newton method
is faster than use repeated cos(x) method, here.
Good Morning</p>
</div>
<div id="pu18" class="pu"><h1><a href="https://www.gnu.org/software/octave/" rel="nofollow noreferrer">Octave</a>, 42 bytes</h1>



<pre class="lang-matlab prettyprint-override"><code>@(n)digits(n)*0+vpasolve(sym('cos(x)-x'));
</code></pre>

<p><a href="https://tio.run/##y08uSSxL/Z9mq6en999BI08zJTM9s6QYyNAy0C4rSCzOzylL1SiuzNVQT84v1qjQ1K1Q19S0/p@mYWSo@R8A" rel="nofollow noreferrer" title="Octave – Try It Online">Try it online!</a></p>

<p>Pretty much a duplicate of <a href="https://codegolf.stackexchange.com/questions/126820/approximate-the-plastic-number">my answer to Approximate the Plastic Number</a>, but somewhat shorter due to more relaxed requirements.</p>
</div>
<div id="pu19" class="pu"><h2>Mathematica 44 Bytes</h2>

<pre><code>FindRoot[Cos@x-x,{x,0},WorkingPrecision-&gt;#]&amp;
</code></pre>

<p><code>FindRoot</code> uses Newton's method by default.</p>
</div>
<div id="pu20" class="pu"><h1>Perl 5, 41 Bytes</h1>
<pre><code>use bignum;sub f{$_[0]?cos(f($_[0]-1)):0}
</code></pre>
<p>Bignum is required for the arbitrary precision. Defines a function f that recursively applies cosine to 0 N times.</p>
<p>TIO doesn't seem to have bignum so no link :(</p>
</div>
<div id="pu21" class="pu"><h1><a href="https://php.net/" rel="nofollow noreferrer">PHP</a>, 50 bytes</h1>



<pre class="lang-php prettyprint-override"><code>$a=$argv[1];$i=$j=0;while($i&lt;$a){$j=cos($j);$i++;}
</code></pre>

<p><a href="https://tio.run/##K8go@G9jXwAkVRJtVRKL0suiDWOtVTJtVbJsDazLMzJzUjVUMm1UEjWrgSLJ@cUaKlmaQHltbeva/6nJGfkqWdb2dv//GxoAAQA" rel="nofollow noreferrer" title="PHP – Try It Online">Try it online!</a></p>
</div>
<div id="pu22" class="pu"><h1><a href="https://www.r-project.org/" rel="nofollow noreferrer">R</a> (+Rmpfr), 55 bytes</h1>

<pre class="lang-r prettyprint-override"><code>function(n,b=Rmpfr::mpfr(1,n)){for(i in 1:n)b=cos(b);b}
</code></pre>
<p>Dennis has now added Rmpfr to TIO so this will work; added some test cases.</p>
<h3>Explanation:</h3>
<p>Takes the code I wrote from <a href="https://codegolf.stackexchange.com/questions/137527/calculate-the-n-th-iterate-of-a-polynomial-for-a-specific-value-f%E2%81%BFx">this challenge</a> to evaluate <code>cos</code> <code>n</code> times starting at <code>1</code>, but first I specify the precision I want the values to be in by creating an object <code>b</code> of class <code>mpfr</code> with value <code>1</code> and precision <code>n</code>, <code>n&gt;=2</code>, so we get more precision as we go along.</p>
<p><a href="https://tio.run/##K/qfpmCj@z@tNC@5JDM/TyNPJ8k2KLcgrcjKCkRqGOrkaWpWp@UXaWQqZOYpGFrlaSbZJucXayRpWifV/i9OLCjIqdQwNIjTMLAy0dQ21EnT/A8A" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu23" class="pu"><h1><a href="http://mathics.github.io/" rel="nofollow noreferrer">Mathics</a> or Mathematica, 46 bytes</h1>

<pre><code>{$MaxPrecision=#}~Block~Cos~FixedPoint~N[1,#]&amp;
</code></pre>

<p><a href="https://tio.run/##y00sychMLv7/v1rFN7EioCg1ObM4Mz/PVrm2ziknPzm7zjm/uM4tsyI1JSA/M6@kzi/aUEc5Vu1/QBGQF60abWhgEBv7HwA" rel="nofollow noreferrer" title="Mathics – Try It Online">Try it online!</a></p>
</div>
<div id="pu24" class="pu"><h1><a href="https://docs.python.org/3/" rel="noreferrer">Python 3</a>, 58 bytes</h1>



<pre class="lang-python prettyprint-override"><code>lambda n:S('cos('*n+'0'+')'*n).evalf(n)
from sympy import*
</code></pre>

<p><a href="https://tio.run/##FcsxDoMwDADAGV7hzTZIVVA3pL6CtUtoSYlE7MhElfL6tGy3XK5lV7m3AA94tsOn9e1B5oXwpSfhICM6HJH/4tv29Ucg4T6YJjhryhViymplaEENBKKAeflsNDnHc99li1LoOtx@" rel="noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/137572/">137572</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




