<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::277950</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>023</td><td>Jelly</td><td>250127T213342Z</td><td><a href="https://codegolf.stackexchange.com/questions/277950/the-steps-of-sorting-a-stack-of-disks-on-three-pegs/277956#277956">Jonathan</a></td></tr>
<tr d-ix="1"><td>048</td><td>Charcoal</td><td>250127T231019Z</td><td><a href="https://codegolf.stackexchange.com/questions/277950/the-steps-of-sorting-a-stack-of-disks-on-three-pegs/277957#277957">Neil</a></td></tr>
<tr d-ix="2"><td>097</td><td>JavaScript ES6</td><td>250127T191414Z</td><td><a href="https://codegolf.stackexchange.com/questions/277950/the-steps-of-sorting-a-stack-of-disks-on-three-pegs/277955#277955">Arnauld</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 23 <a href="https://github.com/DennisMitchell/jelly/wiki/Code=page" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>NỤ&gt;&quot;;\§ạƲż’$ṭLFJḂƝżƊṛ/Ƈ
</code></pre>
<p>A monadic Link that accepts the disks as an unordered list of a prefix of the natural numbers and yields a list of instructions. Each instruction is:</p>
<pre><code>[[ToPeg, FromPeg], DiskCount]
</code></pre>
<p>where the initially full peg is <code>0</code> while <code>1</code> and <code>2</code> are the others (although we only use <code>0</code> and <code>1</code> anyway :p)</p>
<p><strong><a href="https://tio.run/##AToAxf9qZWxsef//TuG7pD4iO1zCp@G6ocayxbzigJkk4bmtTEZK4biCxp3FvMaK4bmW////WzEsNCwzLDJd" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></strong></p>
<h4>How?</h4>
<h5>The resulting algorithm</h5>
<p>Pick up all the disks from the &quot;Source Peg&quot; and put them on another peg, the &quot;Buffer Peg&quot;, then repeatedly (a) pick up as many disks as needed from the Buffer Peg to reach the largest disk and place them onto the Source Peg, and then, if possible, (b) pick up one less disk than in (a) from the Source Peg and place them on the Buffer Peg.</p>
<p>This results in many redundant moves for any initially sorted run :p</p>
<h5>Code</h5>
<pre><code>NỤ&gt;&quot;;\§ạƲż’$ṭLFJḂƝżƊṛ/Ƈ - Link: unordered list of [1..N], Disks
N                       - negate {Disks}
 Ụ                      - grade {that} up
                          -&gt; Places = Disk indices sorted by Disk value, descending
        Ʋ               - last four links as a monad - f(Places):
    ;\                  -   prefixes of {Places}
   &quot;                    -   zip with:
  &gt;                     -     {Place} greater than {Prefix} (vectorises)
      §                 -   sums -&gt; Counts
                              [count of values both earlier in Places and less than V
                               for V in Places] 
       ạ                -   {that} absolute difference {Places}
                            -&gt; counts of disks to pick up from the Buffer Peg at
                               each iteration.
           $            - last two links as a monad - f(X=that):
          ’             -   decrement -&gt; counts of disks to return to the Buffer Peg
         ż              -   {X} zip with {that} -&gt; PairsOfCounts
             L          - length {Disks} (the initial move count)
            ṭ           - {PairsOfCounts} tack {that}
              F         - flatten -&gt; AllCounts (plus a trailing zero)
                   Ɗ    - last three links as a monad - f(AllCounts):
               J        -   indices {AllCounts} -&gt; [1..AllCounts]

                 Ɲ      -   for neighbouring pairs:
                Ḃ       -     mod two
                            -&gt; [[1,0],[0,1],[1,0],[0,1],...]
                  ż     -   {that} zip with {AllCounts}
                      Ƈ - keep those for which:
                     /  -   reduce by:
                    ṛ   -     get right argument
                          (i.e. remove instructions where zero disks would be moved)
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 48 bytes</h1>
<pre><code>Ｗ⌈Φθ›κ⊕λ«≔⊕⌕θιη≔⁺⁺✂θηι¹…θη✂θιＬθ¹θ⟦⁺abι⁺baη⁺ba⁻ιη
</code></pre>
<p><a href="https://tio.run/##VY1LawIxEIDP7a8Y9pTACLX2JZ6KYBEqCB6XPcQ4mMFs7GZXayn97TGzgtQ5DPP45hvrTLR741P6duwJ1MKcuD7Uasa@o6gahI9IRsodwjzYSDWFjjbKawn4vb97b1veBvV/OeOwkVvWGsHpyRVa@kN7SSvPloRxGUMYZnD6Yz1N3f6rH8vpFcrEJ4Vt51SjBc6pEe0ycuhU2RsLsy7kJcKlXZtCNDftgkOuuddXWfCXUlkOER4RxggjhBeEV4Q3hCeE5/zpoarS4OjP" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Outputs in the format <code>[src][dest][#discs]</code>. Explanation:</p>
<pre><code>Ｗ⌈Φθ›κ⊕λ«
</code></pre>
<p>While at least one disc is out of place, get the highest valued such disc. Call this <code>i</code>.</p>
<pre><code>≔⊕⌕θιη
</code></pre>
<p>Get <code>i</code>s current index (1-indexed). Call this <code>h</code>.</p>
<pre><code>≔⁺⁺✂θηι¹…θη✂θιＬθ¹θ
</code></pre>
<p>Rearrange the discs in memory according to the following three movements, ready for the next iteration of the loop.</p>
<pre><code>⟦⁺abι⁺baη⁺ba⁻ιη
</code></pre>
<p>Move <code>i</code> discs from <code>a</code> to <code>b</code>, then <code>h</code> discs from <code>b</code> to <code>a</code>, then the remaining discs from <code>b</code> to <code>a</code>.</p>
</div>
<div id="pu2" class="pu"><h1>JavaScript (ES6), 97 bytes</h1>
<p>A silly algorithm using only two pegs. The I/O format is the one used in the challenge.</p>

<pre class="lang-none prettyprint-override"><code>f=(a,n=N=a.length)=&gt;n?`a${(i=a.indexOf(n))+1}b ${i?`b${i}a `:&quot;&quot;}`+f(a,n-1,a.splice(i,1)):`b${N}a`
</code></pre>
<p><a href="https://tio.run/##dY1LCoMwEED3PYUUFwmO0vjpR7DewB6gFDJqYlMkkSqlIJ7dxm3RzSzeezPzwg/21Vt1g69NLeZZZgRBZ0WGQSt0MzxpdtU5R3ckyjKla/G9SaIp9dhUOu6ocl7aOaHD0/1@4p5cDvgMMOi7VlWCKGCUpktVTMjnyujetCJoTUMkuYfAHpTu/mgEDMIVziCGaMOEkFgXrzj7YzGQbOxdrD3CCc5LA@xgs/kH" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<p>Or <strong><a href="https://tio.run/##dY1LCoMwGIT3PYWELhL8lcZHH9LoDewBSsGgiU0JiVQphdKzp3FbdDnzfcM8@IuP7VMNU2RsJ5yTDHMwrGY81sL0052w0lRY@axMJ94XiQ0hIQ2bMth@VKVCdA5QgdC3CeU8jSjweBy0agVWQAkpaq8g11ozWi1ibXss8TUBeiNk89emQCFZ6ClkkK6QBHLPsgXmP2YC@cru5OkeDnCcHaA7r7kf" rel="nofollow noreferrer">88 bytes</a></strong> with an alternate output format (<code>N&gt;</code> to move N discs from <em>a</em> to <em>b</em>, <code>N&lt;</code> to move N discs from <em>b</em> to <em>a</em>).</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/277950/">277950</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




