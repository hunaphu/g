<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::34276</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>005</td><td>Python</td><td>140710T081812Z</td><td><a href="https://codegolf.stackexchange.com/questions/34276/optimal-minesweeper-on-the-largest-board/34282#34282">isaacg</a></td></tr>
<tr d-ix="1"><td>nan</td><td></td><td>250201T025755Z</td><td><a href="https://codegolf.stackexchange.com/questions/34276/optimal-minesweeper-on-the-largest-board/278017#278017">138 Aspe</a></td></tr>
<tr d-ix="2"><td>nan</td><td></td><td>250131T071651Z</td><td><a href="https://codegolf.stackexchange.com/questions/34276/optimal-minesweeper-on-the-largest-board/278009#278009">138 Aspe</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Python, 4x5 board, 5 mines.</h1>
<p>This is the reference implementation, with fixes thanks to @138Aspen. I just thought I'd put it here to help give people ideas.</p>
<p>This implementation uses dynamic programming to prevent duplication of work, exploits mirror symmetries, and maintains a fist of all possible boards with a given revealed square status to check for guaranteed safe squares.</p>
<p>On my current laptop, when run using pypy, it can optimally solve the 4x5 board with 5 mines in 72 seconds.</p>
<pre class="lang-py prettyprint-override"><code># Minesweeper solver
# Class just contains partially revealed boards that all look the same
# from the outside

# This is a branch, that uses strings.

# Boards have every cell revealed.
# Revealed is partially revealed. Boards must match revealed on every
# cell that is revealed.

# Meanings:
# '0'-'8': Safe square with that # of surrounding mines
# '*'    : Mine
# '_'    : Unrevealed
import copy
import itertools
import time

class Position:
    def __init__(self, dimensions, revealed, boards):
        self.dim_r,self.dim_c=dimensions
        self.rev=revealed
        self.boards=boards
        assert len(revealed)==self.dim_r*self.dim_c

    def click(self,loc):
        # Takes a location, returns all possible revealed positions, with boards
        # split up accordingly
        try:
            assert self.rev[loc]=='_'
        except AssertionError:
            print(self,loc,self.rev)
            assert self.rev[loc]=='_'
        # Create all possible new boards, split up by revealed item.
        board_dict={}
        for board in self.boards:
            clicked_cell=board[loc]
            if clicked_cell in board_dict:
                board_dict[clicked_cell].append(board)
            else:
                board_dict[clicked_cell]=[board]
        new_positions=[]
        for rev_cell in board_dict.keys():
            # Make the new board without copying
            new_rev=''.join([self.rev[:loc],rev_cell,self.rev[loc+1:]])
            new_pos=Position((self.dim_r,self.dim_c),new_rev,board_dict[rev_cell])
            new_positions.append(new_pos)
        return new_positions

    def someBestClick(self):
        click_list=[]
        # Set of boards is all we know when outputting, may be smaller than
        # complete set
        # If we've clicked on a bomb, no way to win, no best click.
        if '*' in self.rev:
            return 0,[]
        unrevealed = [loc for loc in range(len(self.rev)) if self.rev[loc]=='_']
        # If there is only 1 possible board, you're done. The click list is every
        # unrevealed square on the board without a bomb under it.
        if len(self.boards)==1:
            return 1,[loc for loc in unrevealed if self.boards[0][loc]!='*']

        # If there is an unrevaled locaiton on the board that is bomb free in
        # every sub-board, use it.
        for loc in unrevealed:
            if all(board[loc]!='*' for board in self.boards):
                return sum(pos.memoBestClick()[0] for pos in self.click(loc)),[loc]

        # The broadest test - try everywhere.
        click_list=[]
        most_wins=0
        for loc in unrevealed:
            wins=sum(pos.memoBestClick()[0] for pos in self.click(loc) if pos.rev[loc]!='*')
            if wins&gt;=most_wins:
                if wins&gt;most_wins:
                    click_list=[]
                    most_wins=wins
                click_list.append(loc)
        return most_wins,click_list

    def memoBestClick(self):
        global memo
        global memo_counter
        memo_counter +=1
        if not self.rev in memo:
            # These lines check for mirror images of the board being in the memo table

            vert_reversed_memo_str=                                         \
            ''.join([self.rev[y*self.dim_c:(y+1)*self.dim_c]
                     for y in range(self.dim_r)][::-1])

            if vert_reversed_memo_str in memo:
                vert_reversed_output=memo[vert_reversed_memo_str]
                return vert_reversed_output[0],                             \
                        [(self.dim_r-1-loc//self.dim_c)*self.dim_c+loc%self.dim_c
                         for loc in vert_reversed_output[1]]

            horiz_reversed_memo_str=                                        \
            ''.join(self.rev[y*self.dim_c:(y+1)*self.dim_c][::-1]
                    for y in range(self.dim_r))

            if horiz_reversed_memo_str in memo:
                horiz_reversed_output=memo[horiz_reversed_memo_str]
                return horiz_reversed_output[0],                            \
                        [(loc//self.dim_c)*self.dim_c+loc%self.dim_c
                         for loc in horiz_reversed_output[1]]
            both_reversed_memo_str=self.rev[::-1]
            if both_reversed_memo_str in memo:
                both_reversed_output=memo[both_reversed_memo_str]
                return both_reversed_output[0],                             \
                        [len(self.rev)-1-loc
                         for loc in both_reversed_output[1]]

            global restart_counter
            global restart_memo

            if len(self.rev)-self.rev.count('_') &lt;= restart_max:
                restart_memo[self.rev]=self.someBestClick()
                memo[self.rev]=restart_memo[self.rev]
                return restart_memo[self.rev]
            # Needed because of memory issues
            if len(memo)&gt;5*10**6:
                memo=copy.deepcopy(restart_memo)
                restart_counter+=1
            memo[self.rev]=self.someBestClick()
        return memo[self.rev]

def makeBlankPosition(dimensions,mines):
    dim_r,dim_c=dimensions
    # Makes all locations on the board
    all_loc=itertools.product(range(dim_c),range(dim_r))
    # Makes all possible distributions of mines
    all_mine_layouts=itertools.combinations(all_loc,mines)
    boards=[]
    for mine_layout in all_mine_layouts:
        boards.append(makeBoardFromMines(dimensions,mine_layout))
    return Position(dimensions, '_'*dim_c*dim_r, boards)

def makeBoardFromMines(dimensions,mine_layout):
    dim_r,dim_c=dimensions
    def mineNum(loc):
        if (loc%dim_c,loc//dim_c) in mine_layout:
            return '*'
        return str(sum(((loc%dim_c+dif[0],loc//dim_c+dif[1]) in mine_layout) for dif in
                   [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]))
    return ''.join(map(mineNum,(loc for loc in range(dim_r*dim_c))))

def makePosition(dimensions,mines,revealed):
    blank_pos=makeBlankPosition(dimensions,mines)
    boards_subset=[]
    for board in blank_pos.boards:
        if all(revealed[cell_num]==board[cell_num] or revealed[cell_num]=='_' for cell_num in range(len(board))):
            boards_subset.append(board)
    return Position(dimensions, revealed, boards_subset)

def winRate(dimensions,mines,revealed):
    pos=makePosition(dimensions,mines,revealed)
    global memo
    memo={}
    wins=pos.memoBestClick()
    return wins[0],len(pos.boards),wins[1],memo

global memo_counter
memo_counter=0
global restart_counter
restart_counter=0
global restart_memo
restart_memo={}
global restart_max
restart_max=6
dimensions, mines, revealed = eval(input())
start_time=time.time()
wins, total_boards, moves, memo = winRate(dimensions, mines, revealed)
move_points=[(move//dimensions[1],move%dimensions[1]) for move in moves]
print(&quot;&quot;&quot;Best moves are %s.\n%i wins out of %i boards. Ratio of %f. %i 
positions searched.\n%f seconds taken.&quot;&quot;&quot;%(move_points, wins, total_boards,
wins/total_boards, len(memo),time.time()-start_time))
</code></pre>
</div>
<div id="pu1" class="pu"><h1>C++</h1>
<p>C++ port of @isaacg's Python answer.</p>
<p><a href="https://tio.run/##xVrdc@O2EX/XX4G6Ex8VUzr70vZBsv1wN0nTmXaaSTPNg3vDoUjYYk0RKkFa53j0t1/3AyABEvTZk3SqTM4SuVjsx28XiwWy/X6RlWl19/nz74sqK9tcisss1VrWzfXMebStVaXcJ4XSTS3TnftMBx41dVHduU/aStW5rGWe7NJ9@IWW3uQPMmtU7T5JyztVF83Wm6pp96W8ns1aDTOKKt1JvU8zKXSTr2ezt2/Fd6o@pHUucgkq12lTqGoG8rVZI35QusDfTPjnUm3SUuzkThW/EJ14SOsi3ZRSzzz5jX6x2KdFfVlUTSxYWvx@fX1NPNavHFNL3aR1k/BYeEhckky1VSNrcSXO@amlm3yxSz/Bwz@BUgM1xdNMwAdp82KX1DH9ydb0lMUDJg9rIcAa3e898JVVgz@arUQCmZYyB4K0kSKSabYV2TatV@JN8kbcqlq0lSWKBfxMYZq7osGvb75@I4rbjsecZjZmMJgRGwXe0muUgXjTb1Fo4HPblqX5rdomUzspUnzOQ2fEzSobkUli0jaLRaYq3VilTnv5@PlAhNMNS4afFdsqqufGXFEG34BB1GkRG5mjzdyYGD8cThHKMQfSpS5@kdFcXF0xQ/E1s5uz@Y8sPSidlUV2vxJ3xYOsQLdSZYxFYJTLT6iPwulh1jtZSQC0BBOAXSp56JTXltnmUeh9WTSd@1hSsUk1uBC4HrYpqJ@WrUQTd84tKqCGN5ksy6XrJTvDNctJVgYR58aQI/WB4w28/4h6Az7mDK5dC7Qb6SClG@cHDQIrHrjHQCTJi6xZd@MQeBELkbZgolPGycpo7HoGP8iYVYCZUEsIGaIkadcebT/djTvi43Lf6m2yScEMRDLvhx27byO7gZ@SvfVTP4IzFUO@cwMJBsS62BTgxcdYtPscw24QiYTqtMpFWYD@6tYovfStw3aBWK4frV1Iq6BtgLu1C41Y3ha1bnzDmIlRIyAHSsweHoV5ZSDQMR0TdRZxjNqFsputYsszNnJpCV7P50Hj17Jp6ypk8j7eNKSR95A6P6BrzQhMKpinITwAiitLCnZEIwjQpFENrBWHAkhva7WD1UVnsspTCIduprgfx0LCOIYDuQjmFDv1AOEbkaEhvotMak494VXCFzZyHQfT/OUWxN6o3UZsMS2WsCrnjzAP5JE@4VUKpcZgZ1yVskcJpGYMWHB1lUeQq@fid1fGyatVBfRDpBj7Pp3H4ul4DHkAxPqgyhJ0oCTVB3xvpmGooKYO4SDEMeEUtOjBn0sxSK/w8OxsKKVR66bospD3mrOOnc7BXzGf0AgM3SAw0IqqKh/hH9mZkwML0PkgIc4chfV/2rSWnFdhYKUa6y5a3MArFUYTQsJ3iQnmfgG5GGroWo4g5QdYZzgIQ4j8XqYhH3/Gm/OPHLiAAkLDmBg/NKFjNlwO1iPK42z6l4XRRczMPCRNGT6tXON2y6Q1r05vJS5j7AbdbhbGL62G581y9mrjbJQqie23yJIyAyaCupUBa798JfJs3q@V0/YeiXCbllqug7QbyAH3r3MGyuJPEZQYDKbb3c@YAKkCHRKE6wWJOZArhzBMnIUKAgqMZoZNGsPIcHaFAbjEktnJj6FFa6yxC0HDD/IZyOemNH@YD8v3tUpzTOcN/rMQuMAOsp3Fp6Zleo9LTbNVAMUD/essH7SmgBgIYijli11aOukAtwWwB0sOI8O7OYCMlmAxsH49zgsrxMivI586Yk@7deTSflTIq2DPbyvddpmyW9QOqVOg2kinSWNxABMqTqk5VK@NJg2WwUBDnHhl6deBBYHqIIXbnjYQWofXQW4cYMTgundlyBCun/HPWIzezcuslGkdzZ@leS5FH4UsMTFa2cAuzwr3UrbTRdlTxz92uB2H5ZlnXkzeuFbe9Vt10eAGHeoxkUHpjFWxbsvGuH6iihq4zFHP3XKfna29ZRjfcWmE2y@yED4BJEfzoYmw7NlKEHhX1DXgH6L4TuohycVS/BM2SUUGuiCya52WK/ONa3zaC2G1WKvDAM6m@AbaJjFD8oll/1HYTedCXKzh5zXVT4@LRci1HkdEOZVX7QYmjB7ttjX2dq/TQO@N5rGlynLafLSBxIxBg2Cvv28xw@CAG4/Px8mFh/JgU6eVBjPshqYJJERnKrunmFhzqLMA4uC4t24PJUSYGcKvvkRI2xrXUfB//Tw58r0yA41fxJmYmMOxhROyhs38NWukaynKdrHL/PgcJAD075bie1UXv0ByDcKed8DqEET7Fke@BO4Ib9gekDHh63hT4Pa81EG8BuVsCxIhQkE38q6oIuwKwQ/G83iALzmFlTq8PHr84S8NHx7lx4/P6TcMIHey/1sEZSaCMhNB2UsiyI0eYvK/jiDPVK8PoW@W4r1qthaEuRM8ULHU0gA7GEEbGNjDMNCyscj2CHuM@49DaPeB69G/FLc0yIetx@fXoBZdz90bE/PcOPgSuh2RvgDuMEx4Sgbla@Hizv0CtIy8MexBQ1hgiUO9nj55wQ/ySkwtEnF55Z4oTLsKtzywDd4WenE9aE@F0mZ/yHEDM2JTEDmMKb9MYawzfhmwAGHOaH8t/nhOn2DRjSXl1eAwZkqLQKE4dqSryBesNKqRu7G2Kj7yUdVisRDfy3IPteFtW2W8sUTAcqvBHAxgOwQo@XDLHCdAmpOVJnpqcOJuNIUqtZJJmT4CxkTUtyijTJUxLFNzotXzGDn1HVKezOSavnuNzcwYrY4FLHU2qR3JmzhuKxbUooGvS@T4d@zpHAotY/OCBqJtuZW928Dw/N8pbBoxdN2TCZPUdum9fI/SfFer3d9AGR31pT@lhF7vwZmPT3ctTh1bzIcnZry4GEY2FHnl8N5wgmCneQecpkUHU/xDGtSCAX6W1JXqelh80kMVglvXKdMIGDWY9pCfAmJ3C6jCXLcf7kxpEabSZ@8JTKBlCZewO6NTnKEg3amVt7KAA/g5fYVNNkVc6LjLS65UreGXS/9ojB76lRvFspGNcxjm0nGnrm@lIcqcCONt7rjhQcwSZB3oe/SWmixYejtPliqdzjniaAEbMfgCWZa@hAvUfkhmh2R2SBYeYq2Ek4Ai4vSUBsPXcJPj@UZHVyvVBo5nIGssKhQH1YWfUxUWyACjro0M8NV6F39l/Qvr9mxKm04Gs93xqrWJ2cNYqQgskwPYFB0Ohml9ep1@rp3qY/H8DcVPN8cw9/O/dmXjgDpSAv8Jlo4u2QNF1tYacnr5ODgGziBdFpXpNUaQeO2xEoEp2ypFFyXuIdXKncZzdEyyVJ0sZw@qyA0HiWn0r5RPNEGQljw@T7@P@yrKa62IUxCrlk7Dxeu7nHJzpkur4KB7hqbjeqZxKifD0lkn2T5uCvKOhkhSOh6y53QLcT86GTJsJ857QkYA113EYLkF/jHKd/oa1dZj/mrP7LuceXRWZF5DnVW5X5AZJ/0xP7m3O2UiCnvMS/gwz7pzNYGnTXZwjjclPGwoKKUZMc7h43LWXRahNbVMq/vuGPaZJZX60gjo32TJdEt0f0VwryJ40HJV86i4H86@4BcB157HLP3YrS7f@fqZ@yrhlRmH4yGGy8XB4EQN4qzlk/17ZBnq3P/6dQrP2SqqwX54bLaAhEzl0isRqQuLBHT5istEnNhPrc4IJ8ieLPExWPgaRPf0gdLOBZ5b9oSKkv6YIzKupVsobpqduGbg3mIyJ3fhXLxpizLHArcLne52Dd4iqJsCouyxP7rg4ogKXzw7NjdyqKhN72opxaGAvb13w4MuUEE6xytUyRu@lUCnHf0ZDgb7vdw3gwh@VfBOXZOyOOsVxLyAVypwdz7KE0P/2MAZhLWXEzjCQ8kgGG4JdupsBT194GrFXI6PXuk09yEti3x0iNtFGmbGpGp3XKF2vy5Zi/7J5JUDst6NJeODdPAflD3hl1wsdI@C3Xkj8sShb@DAN3QGg/IRp/m4WLHGnbjedJyKnXGO990Zi2FAmYm6uPqx21pyYoHChO6qVLdqJfikiPHDw2PnDk1MC2fe8rZ3OevhTqxGh0CEehBStbCYQsoF7j/CMvnbhkkfINOx0VvF2JdaFd5x3vgeaNd9oVIHa3G6qbtabYs77JJpVbY4XZJBlr9frSp1sMxoGNoy4btHwUNMh1TStaWX82eLdp5wxtpHl8boEbJesApzU6E7mcI5@WRR3f1rl0oSkz5ZDe@mjJfknxg@6IuEEBG5w2N3GotW6po5jaO4U2p@JMQSIFLsntmiR@nVSj9WWYIpPNFNXqiIAtUIkxXVsilkVLVluW9qeGpbAD8NlltaYiWEKEixbxvslYIz1KaB@dz4eBZQy5lzs/DD2Rmdk6datzs@XSTW2HAxl021c9MNDxyxUtDMtWOamMu27p3FT@kOxFmJk3finbgQCXxOuKLkbYl49@mdvRZ1Qfw4XG31qd37VzOnkqFQK61mw4vKzvUwMKzAO9QoNFWDJf1l0elytUs9GeQAo6d@2mPvng9pmbUlFuGYkLgaBwX6/LPsI4Z3AgxdyilfjnkH72b742CdmILD@5fBWrmPBMDdanUnm8vz6wjGzcf1sA39jvLCpezuniPuXap3LpUJ9AaUSxoIq8ql/MZSdgZUFR4bihL0T@tuk2L3HQhu7DKR4efwGmTQ3sXjUY0MKiRMN2gp4RtsiKGOw1YY5k96/5Y87DfDMvvyq8FLZy63koVaMTv697czLI8vL8XJ@/52J1ZmJ2v/9c2JbZRBFcIFkFuFuFdmjCpm/mEz7Hc02F/Fu1liO6/3NDrBP6YdaOn4kbmmis/mzlAroFNzHH19Pi7/VQ10JDzjO/5mGg00kYdXIjGJW/yI@ZXpepWAImK0zYnV2zGDJTPuUeuNPnE2xRrgl20hz4wEdpBMY9gYAE18xOTuinJuq5Y/0H/J4PP5c/j5fwE" rel="nofollow noreferrer">Try it online!</a></p>
<pre class="lang-cpp prettyprint-override"><code>#include &lt;cassert&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;tuple&gt;

using namespace std;

// Forward declaration
struct Position;

// Global memoization variables
unordered_map&lt;string, pair&lt;int, vector&lt;int&gt;&gt;&gt; memo;
unordered_map&lt;string, pair&lt;int, vector&lt;int&gt;&gt;&gt; restart_memo;
int memo_counter = 0;
int restart_counter = 0;
int restart_max = 6;

struct Position {
    int dim_r, dim_c;
    string rev;  // string representing the revealed state (each char: '_' for unrevealed, or a digit or '*' if revealed)
    vector&lt;string&gt; boards; // each board is a full board outcome as a string

    Position(int r, int c, const string &amp;revealed, const vector&lt;string&gt; &amp;b)
        : dim_r(r), dim_c(c), rev(revealed), boards(b) {
        assert((int)rev.size() == dim_r * dim_c);
    }

    // click: given a location (index into rev), generates all new Positions
    // by splitting the boards based on what value is revealed in that cell.
    vector&lt;Position&gt; click(int loc) const {
        assert(rev[loc] == '_');  // must be unrevealed
        unordered_map&lt;char, vector&lt;string&gt;&gt; board_dict;
        for (const auto &amp;board : boards) {
            char clicked_cell = board[loc];
            board_dict[clicked_cell].push_back(board);
        }
        vector&lt;Position&gt; new_positions;
        // For each revealed cell possibility, update the revealed string and list of boards.
        for (auto &amp;entry : board_dict) {
            char rev_cell = entry.first;
            string new_rev = rev;
            new_rev[loc] = rev_cell;
            new_positions.push_back(Position(dim_r, dim_c, new_rev, entry.second));
        }
        return new_positions;
    }

    // someBestClick returns a pair where:
    //   first  = total wins from descendant positions,
    //   second = vector of best moves (cell indices)
    pair&lt;int, vector&lt;int&gt;&gt; someBestClick() {
        // If a bomb has already been revealed, no win is possible.
        if (rev.find('*') != string::npos) {
            return {0, {}};
        }
        // Collect all unrevealed positions
        vector&lt;int&gt; unrevealed;
        for (int i = 0; i &lt; (int)rev.size(); i++) {
            if (rev[i] == '_')
                unrevealed.push_back(i);
        }
        // If there is only one possible board, every unrevealed square that is not a bomb is a winning move.
        if (boards.size() == 1) {
            vector&lt;int&gt; moves;
            for (int loc : unrevealed) {
                if (boards[0][loc] != '*') {
                    moves.push_back(loc);
                }
            }
            return {1, moves};
        }

        // If there is an unrevealed location that is safe in every sub-board, use it.
        for (int loc : unrevealed) {
            bool safeEverywhere = true;
            for (const auto &amp;board : boards) {
                if (board[loc] == '*') {
                    safeEverywhere = false;
                    break;
                }
            }
            if (safeEverywhere) {
                int sumWins = 0;
                vector&lt;Position&gt; clicked = click(loc);
                for (auto &amp;pos : clicked) {
                    sumWins += pos.memoBestClick().first;
                }
                return {sumWins, {loc}};
            }
        }

        // Broadest test - try all unrevealed locations and pick those whose descendant wins sum is maximal.
        int most_wins = 0;
        vector&lt;int&gt; click_list;
        for (int loc : unrevealed) {
            int wins = 0;
            vector&lt;Position&gt; descendant = click(loc);
            for (auto &amp;pos : descendant) {
                // Ensure that if a bomb was revealed on that click, we do not add its wins.
                if (pos.rev[loc] == '*')
                    continue;
                wins += pos.memoBestClick().first;
            }
            if (wins &gt; most_wins) {
                most_wins = wins;
                click_list.clear();
                click_list.push_back(loc);
            } else if (wins == most_wins) {
                click_list.push_back(loc);
            }
        }
        return {most_wins, click_list};
    }

    // memoBestClick uses a global memo table to cache results.
    pair&lt;int, vector&lt;int&gt;&gt; memoBestClick() {
        memo_counter++;
        if (memo.find(rev) == memo.end()) {
            // Check mirror images
            // 1. Vertical reversal: reverse the order of rows.
            string vert_reversed;
            for (int y = dim_r - 1; y &gt;= 0; y--) {
                vert_reversed += rev.substr(y * dim_c, dim_c);
            }
            if (memo.find(vert_reversed) != memo.end()) {
                auto vert_output = memo[vert_reversed];
                vector&lt;int&gt; transformed;
                for (int loc : vert_output.second) {
                    int r = loc / dim_c;
                    int c = loc % dim_c;
                    int new_r = dim_r - 1 - r;
                    int new_loc = new_r * dim_c + c;
                    transformed.push_back(new_loc);
                }
                return {vert_output.first, transformed};
            }
            // 2. Horizontal reversal: reverse each row.
            string horiz_reversed;
            for (int y = 0; y &lt; dim_r; y++) {
                string row = rev.substr(y * dim_c, dim_c);
                reverse(row.begin(), row.end());
                horiz_reversed += row;
            }
            if (memo.find(horiz_reversed) != memo.end()) {
                auto horiz_output = memo[horiz_reversed];
                vector&lt;int&gt; transformed;
                for (int loc : horiz_output.second) {
                    int r = loc / dim_c;
                    int c = loc % dim_c;
                    int new_c = dim_c - 1 - c;
                    int new_loc = r * dim_c + new_c;
                    transformed.push_back(new_loc);
                }
                return {horiz_output.first, transformed};
            }
            // 3. Both reversed: reverse entire string.
            string both_reversed = rev;
            reverse(both_reversed.begin(), both_reversed.end());
            if (memo.find(both_reversed) != memo.end()) {
                auto both_output = memo[both_reversed];
                vector&lt;int&gt; transformed;
                int total = rev.size();
                for (int loc : both_output.second) {
                    transformed.push_back(total - 1 - loc);
                }
                return {both_output.first, transformed};
            }

            if ((int)rev.size() - count(rev.begin(), rev.end(), '_') &lt;= restart_max) {
                auto best = this-&gt;someBestClick();
                restart_memo[rev] = best;
                memo[rev] = best;
                return best;
            }

            if (memo.size() &gt; 5000000) {
                memo = restart_memo;
                restart_counter++;
            }
            memo[rev] = this-&gt;someBestClick();
        }
        return memo[rev];
    }
};

// --- Helper functions for board generation ---

// Given a dimensions pair and a mine_layout (vector of (col,row) pairs),
// returns a board string. For each cell, if the cell has a bomb ('*') it is '*'.
// Otherwise, it is the count of bombs adjacent to that cell.
string makeBoardFromMines(pair&lt;int, int&gt; dimensions, const vector&lt;pair&lt;int, int&gt;&gt; &amp;mine_layout) {
    int dim_r = dimensions.first, dim_c = dimensions.second;
    unordered_set&lt;int&gt; mineSet;
    // We use location index = row * dim_c + col.
    for (const auto &amp;p : mine_layout) {
        int col = p.first;
        int row = p.second;
        mineSet.insert(row * dim_c + col);
    }
    string board;
    board.resize(dim_r * dim_c);
    for (int loc = 0; loc &lt; dim_r * dim_c; loc++) {
        if (mineSet.count(loc)) {
            board[loc] = '*';
        } else {
            int count_mines = 0;
            int row = loc / dim_c;
            int col = loc % dim_c;
            for (int dr = -1; dr &lt;= 1; dr++) {
                for (int dc = -1; dc &lt;= 1; dc++) {
                    if (dr == 0 &amp;&amp; dc == 0)
                        continue;
                    int nr = row + dr, nc = col + dc;
                    if (nr &gt;= 0 &amp;&amp; nr &lt; dim_r &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; dim_c) {
                        int nloc = nr * dim_c + nc;
                        if (mineSet.count(nloc))
                            count_mines++;
                    }
                }
            }
            board[loc] = '0' + count_mines;
        }
    }
    return board;
}

// This function recursively generates all combinations (as indices) for choosing k items out of total.
void combineMineLayouts(int start, int k, int total, vector&lt;int&gt; &amp;current, vector&lt;vector&lt;int&gt;&gt; &amp;result) {
    if (k == 0) {
        result.push_back(current);
        return;
    }
    for (int i = start; i &lt;= total - k; i++) {
        current.push_back(i);
        combineMineLayouts(i + 1, k - 1, total, current, result);
        current.pop_back();
    }
}

// Given board dimensions and a mine count, generate all possible mine boards.
// The mine positions are generated as combinations over all cell indices.
Position makeBlankPosition(pair&lt;int, int&gt; dimensions, int mines) {
    int dim_r = dimensions.first, dim_c = dimensions.second;
    int total = dim_r * dim_c;
    vector&lt;vector&lt;int&gt;&gt; combinations;
    vector&lt;int&gt; current;
    combineMineLayouts(0, mines, total, current, combinations);
    vector&lt;string&gt; boards;
    for (const auto &amp;comb : combinations) {
        vector&lt;pair&lt;int, int&gt;&gt; mine_layout;
        for (int loc : comb) {
            int row = loc / dim_c;
            int col = loc % dim_c;
            // In the Python code mine_layout uses the tuple (col, row)
            mine_layout.push_back({col, row});
        }
        boards.push_back(makeBoardFromMines(dimensions, mine_layout));
    }
    string unrevealed(total, '_');
    return Position(dim_r, dim_c, unrevealed, boards);
}

// This function builds a Position based on a partially revealed board.
// Only boards that agree with the revealed digits (or '_' where not revealed) are kept.
Position makePosition(pair&lt;int, int&gt; dimensions, int mines, const string &amp;revealed) {
    Position blank_pos = makeBlankPosition(dimensions, mines);
    int total = dimensions.first * dimensions.second;
    vector&lt;string&gt; boards_subset;
    for (const auto &amp;board : blank_pos.boards) {
        bool valid = true;
        for (int cell_num = 0; cell_num &lt; total; cell_num++) {
            if (revealed[cell_num] != '_' &amp;&amp; revealed[cell_num] != board[cell_num]) {
                valid = false;
                break;
            }
        }
        if (valid)
            boards_subset.push_back(board);
    }
    return Position(dimensions.first, dimensions.second, revealed, boards_subset);
}

// Returns a tuple of win info: wins, total boards, best moves, and duration.
pair&lt;int, tuple&lt;int, vector&lt;int&gt;, int, double&gt;&gt; winRate(pair&lt;int, int&gt; dimensions, int mines, const string &amp;revealed) {
    Position pos = makePosition(dimensions, mines, revealed);
    memo.clear();
    memo_counter = 0;
    auto start = chrono::high_resolution_clock::now();
    auto wins_moves = pos.memoBestClick();
    auto end = chrono::high_resolution_clock::now();
    double duration = chrono::duration&lt;double&gt;(end - start).count();
    int wins = wins_moves.first;
    int total_boards = pos.boards.size();
    return {wins, make_tuple(total_boards, wins_moves.second, (int)memo.size(), duration)};
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    // The Python code uses eval(input()) to obtain a tuple of (dimensions, mines, revealed).
    // For C++, we assume the input is given as:
    //   rows cols mines revealed_string
    // For example: &quot;2 2 1 ____&quot; indicates a 2x2 board, 1 mine, and all cells unrevealed.
    int rows, cols, mines;
    string revealed;
    cin &gt;&gt; rows &gt;&gt; cols &gt;&gt; mines &gt;&gt; revealed;
    pair&lt;int, int&gt; dimensions = {rows, cols};

    // Calculate win rate and best moves.
    auto result = winRate(dimensions, mines, revealed);
    int wins = result.first;
    auto tup = result.second;
    int total_boards = std::get&lt;0&gt;(tup);
    vector&lt;int&gt; moves = std::get&lt;1&gt;(tup);
    int memo_size = std::get&lt;2&gt;(tup);
    double time_taken = std::get&lt;3&gt;(tup);

    // Convert linear position indices to (row, col) points.
    vector&lt;pair&lt;int, int&gt;&gt; move_points;
    for (int move : moves) {
        int r = move / cols;
        int c = move % cols;
        move_points.push_back({r, c});
    }

    cout &lt;&lt; &quot;Best moves are &quot;;
    cout &lt;&lt; &quot;[&quot;;
    bool first = true;
    for (auto &amp;p : move_points) {
        if (!first)
            cout &lt;&lt; &quot;, &quot;;
        cout &lt;&lt; &quot;(&quot; &lt;&lt; p.first &lt;&lt; &quot;, &quot; &lt;&lt; p.second &lt;&lt; &quot;)&quot;;
        first = false;
    }
    cout &lt;&lt; &quot;].\n&quot;;
    cout &lt;&lt; wins &lt;&lt; &quot; wins out of &quot; &lt;&lt; total_boards &lt;&lt; &quot; boards. Ratio of &quot; 
         &lt;&lt; (double)wins / total_boards &lt;&lt; &quot;. &quot; &lt;&lt; memo_size 
         &lt;&lt; &quot; positions searched.\n&quot;;
    cout &lt;&lt; time_taken &lt;&lt; &quot; seconds taken.\n&quot;;

    return 0;
}

// 4 4 4 ________________
</code></pre>
</div>
<div id="pu2" class="pu"><h1>Rust</h1>
<p>Rust port of @isaacg's Python answer.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=b02948285cb65e7c68b14609ae22cd46" rel="nofollow noreferrer">Run it on Rust Playground!</a></p>
<pre class="lang-rust prettyprint-override"><code>use std::collections::{HashMap, HashSet};
use std::io;
use itertools::Itertools;

#[derive(Debug, Clone)]
struct Position {
    dim_r: usize,
    dim_c: usize,
    rev: String,       // Revealed cells string
    boards: Vec&lt;String&gt;,
}

#[derive(Default)]
struct Solver {
    /// Memo keyed by the revealed string, stores a tuple (wins, Vec&lt;click_locations&gt;)
    memo: HashMap&lt;String, (u64, Vec&lt;usize&gt;)&gt;,
    /// Another memo used when the number of revealed cells is within a certain threshold
    restart_memo: HashMap&lt;String, (u64, Vec&lt;usize&gt;)&gt;,
    /// Count how many times we've called memoBestClick
    memo_counter: usize,
    /// Count how many times we've restarted the memo
    restart_counter: usize,
    /// Maximum number of revealed cells difference to check for restarts
    restart_max: usize,
}

impl Solver {
    /// Create a new Solver with defaults pre-initialized
    fn new() -&gt; Self {
        let mut solver = Solver::default();
        solver.restart_max = 6;
        solver
    }

    /// Main &quot;memoBestClick&quot; logic
    fn memo_best_click(&amp;mut self, pos: &amp;Position) -&gt; (u64, Vec&lt;usize&gt;) {
        self.memo_counter += 1;
        if !self.memo.contains_key(&amp;pos.rev) {
            // ... same mirror checks as before ...

            let unrevealed_count = pos.rev.matches('_').count();
            let already_revealed = pos.rev.len() - unrevealed_count;
            if already_revealed &lt;= self.restart_max {
                // Fix #1 for move error: clone the result before storing
                let best = pos.some_best_click(self);
                self.restart_memo.insert(pos.rev.clone(), best.clone());
                self.memo.insert(pos.rev.clone(), best.clone());
                return best;
            }

            // If the memo grows too large, we &quot;restart&quot; it
            if self.memo.len() &gt; 5 * 10_usize.pow(6) {
                self.memo = self.restart_memo.clone();
                self.restart_counter += 1;
            }

            // Fix #2 for move error: clone the result before storing
            let best = pos.some_best_click(self);
            self.memo.insert(pos.rev.clone(), best.clone());
            return best;
        }
        // Return from memo
        self.memo[&amp;pos.rev].clone()
    }
}

/// Reverse the board vertically
fn vertical_reverse(s: &amp;str, rows: usize, cols: usize) -&gt; String {
    let mut lines: Vec&lt;&amp;str&gt; = Vec::new();
    for r in 0..rows {
        let start = r * cols;
        let end = start + cols;
        lines.push(&amp;s[start..end]);
    }
    lines.reverse();
    lines.into_iter().collect()
}

/// Reverse the board horizontally
fn horizontal_reverse(s: &amp;str, rows: usize, cols: usize) -&gt; String {
    let mut reversed = String::new();
    for r in 0..rows {
        let start = r * cols;
        let end = start + cols;
        let row_str: String = s[start..end].chars().rev().collect();
        reversed.push_str(&amp;row_str);
    }
    reversed
}

impl Position {
    fn new(dimensions: (usize, usize), revealed: String, boards: Vec&lt;String&gt;) -&gt; Self {
        let (dim_r, dim_c) = dimensions;
        assert_eq!(revealed.len(), dim_r * dim_c);
        Position {
            dim_r,
            dim_c,
            rev: revealed,
            boards,
        }
    }

    /// Equivalent to the Python &quot;click&quot; method
    fn click(&amp;self, loc: usize) -&gt; Vec&lt;Position&gt; {
        // Must be an unrevealed cell ('_') to click
        assert_eq!(self.rev.chars().nth(loc).unwrap(), '_');

        // Separate boards according to what's at the clicked location
        let mut board_dict: HashMap&lt;char, Vec&lt;String&gt;&gt; = HashMap::new();
        for board in &amp;self.boards {
            let clicked_cell = board.chars().nth(loc).unwrap();
            board_dict.entry(clicked_cell).or_default().push(board.clone());
        }

        // Build new positions by revealing the clicked cell with the char from each board set
        let mut new_positions = Vec::new();
        for (ch, boards_for_ch) in board_dict {
            let mut new_rev = self.rev.clone();
            // replace the single character
            unsafe {
                new_rev.as_mut_vec()[loc] = ch as u8;
            }
            let pos = Position::new((self.dim_r, self.dim_c), new_rev, boards_for_ch);
            new_positions.push(pos);
        }
        new_positions
    }

    /// Equivalent to Python's &quot;someBestClick&quot; method
    ///
    /// Returns:
    ///   (best_wins, best_click_list)
    fn some_best_click(&amp;self, solver: &amp;mut Solver) -&gt; (u64, Vec&lt;usize&gt;) {
        // If we've already got a revealed bomb, there's no winning scenario
        if self.rev.contains('*') {
            return (0, Vec::new());
        }

        let unrevealed: Vec&lt;usize&gt; = self
            .rev
            .chars()
            .enumerate()
            .filter_map(|(i, c)| if c == '_' { Some(i) } else { None })
            .collect();

        // If only one board is possible, reveal all non-bomb squares
        if self.boards.len() == 1 {
            let board = &amp;self.boards[0];
            let safe_squares = unrevealed
                .into_iter()
                .filter(|&amp;loc| board.chars().nth(loc).unwrap() != '*')
                .collect::&lt;Vec&lt;_&gt;&gt;();
            return (1, safe_squares);
        }

        // If there's a cell that's safe in ALL boards, click it
        for &amp;loc in &amp;unrevealed {
            if self.boards.iter().all(|b| b.chars().nth(loc).unwrap() != '*') {
                // Summation of wins after we click “loc”
                let mut sum_wins = 0;
                for new_pos in self.click(loc) {
                    // Only count if the revealed cell is not '*'
                    if new_pos.rev.chars().nth(loc).unwrap() != '*' {
                        let (wins, _) = solver.memo_best_click(&amp;new_pos);
                        sum_wins += wins;
                    }
                }
                return (sum_wins, vec![loc]);
            }
        }

        // Otherwise, try all possible unrevealed locations
        let mut click_list = Vec::new();
        let mut most_wins = 0u64;

        for &amp;loc in &amp;unrevealed {
            let mut sum_wins = 0;
            for new_pos in self.click(loc) {
                // Only count if the revealed cell is not '*'
                if new_pos.rev.chars().nth(loc).unwrap() != '*' {
                    let (wins, _) = solver.memo_best_click(&amp;new_pos);
                    sum_wins += wins;
                }
            }

            if sum_wins &gt; most_wins {
                most_wins = sum_wins;
                click_list.clear();
                click_list.push(loc);
            } else if sum_wins == most_wins {
                click_list.push(loc);
            }
        }

        (most_wins, click_list)
    }
}

/// Equivalent to Python's &quot;makeBlankPosition&quot;
fn make_blank_position(dimensions: (usize, usize), mines: usize) -&gt; Position {
    let (dim_r, dim_c) = dimensions;
    let mut boards = Vec::new();

    // All possible mine placements (combinations of loc)
    // Note: loc is used as a single index. We'll convert to (x, y) by (loc % dim_c, loc / dim_c).
    let all_locs = (0..dim_r * dim_c).collect::&lt;Vec&lt;_&gt;&gt;();
    for combo in all_locs.into_iter().combinations(mines) {
        let mine_set: HashSet&lt;usize&gt; = combo.into_iter().collect();
        let board = make_board_from_mines(dimensions, &amp;mine_set);
        boards.push(board);
    }

    let revealed = &quot;_&quot;.repeat(dim_r * dim_c);
    Position::new(dimensions, revealed, boards)
}

/// Equivalent to Python's &quot;makeBoardFromMines&quot;
fn make_board_from_mines(dimensions: (usize, usize), mine_layout: &amp;HashSet&lt;usize&gt;) -&gt; String {
    let (dim_r, dim_c) = dimensions;

    let mut board = String::new();
    for loc in 0..(dim_r * dim_c) {
        if mine_layout.contains(&amp;loc) {
            board.push('*');
        } else {
            // Count adjacent mines
            let r = loc / dim_c;
            let c = loc % dim_c;
            let mut count = 0;
            for (dr, dc) in [
                (-1, -1),
                (-1, 0),
                (-1, 1),
                (0, -1),
                (0, 1),
                (1, -1),
                (1, 0),
                (1, 1),
            ] {
                let nr = r as isize + dr;
                let nc = c as isize + dc;
                if nr &gt;= 0
                    &amp;&amp; nr &lt; dim_r as isize
                    &amp;&amp; nc &gt;= 0
                    &amp;&amp; nc &lt; dim_c as isize
                {
                    let adj_loc = (nr as usize) * dim_c + (nc as usize);
                    if mine_layout.contains(&amp;adj_loc) {
                        count += 1;
                    }
                }
            }
            board.push(std::char::from_digit(count, 10).unwrap());
        }
    }
    board
}

/// Equivalent to Python's &quot;makePosition&quot;
fn make_position(dimensions: (usize, usize), mines: usize, revealed: &amp;str) -&gt; Position {
    let blank = make_blank_position(dimensions, mines);
    let mut boards_subset = Vec::new();

    'outer: for board in &amp;blank.boards {
        for (i, ch) in revealed.chars().enumerate() {
            if ch != '_' &amp;&amp; ch != board.chars().nth(i).unwrap() {
                // This board doesn't match the &quot;revealed&quot; pattern
                continue 'outer;
            }
        }
        boards_subset.push(board.clone());
    }
    Position::new(dimensions, revealed.to_string(), boards_subset)
}

/// Note the added lifetime parameter 'a
fn win_rate&lt;'a&gt;(
    solver: &amp;'a mut Solver,
    dimensions: (usize, usize),
    mines: usize,
    revealed: &amp;'a str,
) -&gt; (u64, usize, Vec&lt;usize&gt;, &amp;'a HashMap&lt;String, (u64, Vec&lt;usize&gt;)&gt;) {
    let pos = make_position(dimensions, mines, revealed);
    solver.memo.clear();
    let (wins, moves) = solver.memo_best_click(&amp;pos);
    (wins, pos.boards.len(), moves, &amp;solver.memo)
}


fn main() {
    let dim_r: usize = 4;
    let dim_c: usize = 4;
    let mines_count: usize = 4;
    let revealed_str_clean= &quot;________________&quot;;

    // Now we run the solver
    let mut solver = Solver::new();
    let start_time = std::time::Instant::now();
    let (wins, total_boards, moves, memo_map) =
        win_rate(&amp;mut solver, (dim_r, dim_c), mines_count, revealed_str_clean);
    let duration = start_time.elapsed().as_secs_f64();

    // Convert move indexes into (row, col)
    let move_points: Vec&lt;(usize, usize)&gt; =
        moves.iter().map(|&amp;m| (m / dim_c, m % dim_c)).collect();

    println!(
&quot;Best moves are {:?}.
{} wins out of {} boards. Ratio of {}.
{} positions searched.
{} seconds taken.&quot;,
        move_points,
        wins,
        total_boards,
        wins as f64 / total_boards as f64,
        memo_map.len(),
        duration
    );
}
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/34276/">34276</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




