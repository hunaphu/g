<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::278146</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>018</td><td>JavaScript</td><td>250219T021806Z</td><td><a href="https://codegolf.stackexchange.com/questions/278146/find-the-boolean-logic-to-check-if-a-number-is-prime/278301#278301">DesmosEn</a></td></tr>
<tr d-ix="1"><td>nan</td><td></td><td>250223T161547Z</td><td><a href="https://codegolf.stackexchange.com/questions/278146/find-the-boolean-logic-to-check-if-a-number-is-prime/278359#278359">l4m2</a></td></tr>
<tr d-ix="2"><td>018</td><td>Rust</td><td>250223T104052Z</td><td><a href="https://codegolf.stackexchange.com/questions/278146/find-the-boolean-logic-to-check-if-a-number-is-prime/278352#278352">138 Aspe</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://playcode.io/javascript" rel="nofollow noreferrer">JavaScript</a>, 18 bits</h1>
<pre><code>let numBits = 23;
let smallestFactor = new Array(2**numBits + 1);
smallestFactor.fill(0);
let primes = [];
let str = &quot;&quot;;

for (let i = 2; i &lt;= 2**numBits; ++i) {
    if (smallestFactor[i] == 0) {
        smallestFactor[i] = i;
        primes.push(i);
        str += &quot;(&quot;
        for (let j = 0; j &lt; numBits; j++){
            if (i &amp; (1 &lt;&lt; j)){
                str += &quot;(¬&quot; + (numBits - j) + ((j != numBits - 1) ? &quot;)&amp;&quot; : &quot;))|&quot;);
            }else{
                str += (numBits - j) + ((j != numBits - 1) ? &quot;&amp;&quot; : &quot;)|&quot;);
            }
        }
    }
    for (let j = 0; i * primes[j] &lt;= 2**numBits; ++j) {
        smallestFactor[i * primes[j]] = primes[j];
    }
}
console.log(str.substring(0,str.length - 1));
</code></pre>
<p>The code works by filtering out the primes in the range <code>[0,2^numBits]</code>, using the <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" rel="nofollow noreferrer">Sieve of Eratosthenes</a>. It converts these primes to binary, and makes a sort of truth table, matching prime binary numbers to 1, and everything else to 0. I then used <a href="https://www.allaboutcircuits.com/textbook/digital/chpt-7/converting-truth-tables-boolean-expressions/" rel="nofollow noreferrer">SOP</a> to fit a boolean expression to this truth table. Here is an example of SOP on a 3-digit prime number table.</p>
<pre><code>Number | Is prime?
==================
000    |0
001    |0
010    |1
011    |1
100    |0
101    |1
110    |0
111    |1
</code></pre>
<p>Prime when number = 010 | 011 | 101 | 111</p>
<p>Checking if the number is just one of these cases, <code>010</code> for example, can be expanded to <code>(digit 1 = 0) &amp; (digit 2 = 1) &amp; (digit 3 = 0)</code>. This can be written more concisely as <code>((¬d1) &amp; d2 &amp; (¬d3))</code>. Doing this for each case, we get <code>((¬d1) &amp; d2 &amp; (¬d3)) | ((¬d1) &amp; d2 &amp; d3) | (d1 &amp; (¬d2) &amp; d3) | (d1 &amp; d2 &amp; d3)</code>.</p>
<p><em>Edit February 23rd:</em>
Used
<a href="https://cp-algorithms.com/algebra/prime-sieve-linear.html" rel="nofollow noreferrer">this</a> article to massively improve the time complexity of the algorithm.</p>
</div>
<div id="pu1" class="pu"><h1>30 bits</h1>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
const int N = 30;
char primes[1&lt;&lt;(N-1)];
template&lt;int k&gt;
void f(int x) {
    std::cout &lt;&lt; &quot;((&quot;&lt;&lt;k&lt;&lt;&quot;&amp;(&quot;;
    f&lt;k-1&gt;(x+(1&lt;&lt;(k-1)));
    std::cout &lt;&lt; &quot;))|(¬&quot;&lt;&lt;k&lt;&lt;&quot;&amp;(&quot;;
    f&lt;k-1&gt;(x);
    std::cout &lt;&lt; &quot;)))&quot;;
}
template&lt;&gt;
void f&lt;6&gt;(int x) {
    bool empty = 1;
    for (int i=0; i&lt;32; ++i) {
        if (!primes[i]) {
            if (!empty) std::cout &lt;&lt; '|';
            empty = 0;
            std::cout &lt;&lt; ((i&amp;16)?&quot;(6&quot;:&quot;((¬6)&quot;);
            std::cout &lt;&lt; ((i&amp;8)?&quot;&amp;5&quot;:&quot;&amp;(¬5)&quot;);
            std::cout &lt;&lt; ((i&amp;4)?&quot;&amp;4&quot;:&quot;&amp;(¬4)&quot;);
            std::cout &lt;&lt; ((i&amp;2)?&quot;&amp;3&quot;:&quot;&amp;(¬3)&quot;);
            std::cout &lt;&lt; ((i&amp;1)?&quot;&amp;2)&quot;:&quot;&amp;(¬2))&quot;);
        }
    }
    if (empty) std::cout &lt;&lt; &quot;(¬1))&quot;;
}
int main() {
    std::ios::sync_with_stdio(false);
    // 2 is a prime
    std::cout &lt;&lt; &quot;(2&quot;;
    for (int i=3; i&lt;=N; ++i) std::cout &lt;&lt; &quot;&amp;(¬&quot; &lt;&lt; i &lt;&lt; ')';
    std::cout &lt;&lt; &quot;)|(1&amp;(&quot;;
    // prime init
    primes[0] = 1;
    for (int i=1; i&lt;sizeof primes; ++i) {
        if (!primes[i]) { //std::cout &lt;&lt; 2*i+1 &lt;&lt; ',' &lt;&lt; i &lt;&lt; '\n';
            for (int j=i; (j+=2*i+1)&lt;sizeof primes; ) {
                primes[j] = 1;
            }}}
    f&lt;N&gt;(0);std::cout &lt;&lt; &quot;))&quot;;
}
</code></pre>
<p>Executing result</p>
<pre><code>$g++ -O2 278146.cpp &amp;&amp; time ./a.out | wc
      0       1 6513754292

real    0m54.601s
user    1m27.957s
sys 0m2.918s
</code></pre>
<p>Seems <code>time</code> also count time of <code>wc</code></p>
<p><a href="https://tio.run/##7VVLDoIwEN17CzcyjYpSKJIgnMQNgWpqCCVgCIl6I0/BxbAlEPm6dSFdvCZv3rxOp5P06mVe6icsvm0jHtCyPPMEmLO32RET016vGbovcodmXggK4BUULx1JNCokFZoVHiq0EHqAtgIAS8JBQqMgrUzhgoVyGNPljtFErJ9jTHgZAx/SOftbDA94vcONeRu1xpy4i9mrd4rHHa7xJCN@pJfTrksqxIPMvf9J7@v2z/M/z/@/zr9YiprQOPR8CrvitbtslKWCPtQpEFTuuOKnYK4L@VaTOQt2hhz5PEp5SNWQX4ChZ1m@AQ" rel="nofollow noreferrer">verifier for N=8</a></p>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.rust-lang.org/" rel="nofollow noreferrer">Rust</a>, 18 bits</h1>
<p>Rust port of @DesmosEnthusiast's JavaScript answer.</p>
<p>You can run <code>n=10</code> case at <a href="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=03da9c028b6ca31807197224ffc72b27" rel="nofollow noreferrer">RustPlayground</a>!</p>
<pre class="lang-rust prettyprint-override"><code>fn main() {
    let num_bits: i128 = 18;
    let mut primes: Vec&lt;Vec&lt;char&gt;&gt; = Vec::new();
    let mut not_prime: Vec&lt;i128&gt; = vec![0, 1];

    if num_bits &gt; 1 {
        // Use checked_pow for overflow protection
        let limit = match 2_i128.checked_pow(num_bits as u32) {
            Some(value) =&gt; value,
            None =&gt; {
                println!(&quot;2^{} overflows i128&quot;, num_bits);
                return;
            }
        };

        for i in 0..limit {
            if !not_prime.contains(&amp;i) {
                let mut binary: Vec&lt;char&gt; = format!(&quot;{:b}&quot;, i).chars().collect();
                if binary.len() &lt; num_bits as usize {
                    let mut filler = vec!['0'; num_bits as usize - binary.len()];
                    filler.append(&amp;mut binary);
                    binary = filler;
                }
                primes.push(binary);

                // Use checked_mul and checked_add for overflow protection
                let square = match i.checked_mul(i) {
                    Some(value) =&gt; value,
                    None =&gt; {
                        println!(&quot;Overflow in square calculation for {}&quot;, i);
                        continue;
                    }
                };
                
                let mut j = square;
                while j &lt; limit {
                    not_prime.push(j);
                    j = match j.checked_add(i) {
                        Some(value) =&gt; value,
                        None =&gt; {
                            println!(&quot;Overflow in increment for i={}&quot;, i);
                            break;
                        }
                    };
                }
            }
        }
    }

    let mut rule = String::new();
    for (i, prime) in primes.iter().enumerate() {
        let mut number_rule = String::from(&quot;(&quot;);
        for (j, &amp;digit) in prime.iter().enumerate() {
            if digit == '0' {
                number_rule.push_str(&amp;format!(&quot;(¬d{})&quot;, j + 1));
            } else {
                number_rule.push_str(&amp;format!(&quot;d{}&quot;, j + 1));
            }
            if j != num_bits as usize - 1 {
                number_rule.push_str(&quot; &amp; &quot;);
            }
        }
        rule.push_str(&amp;number_rule);
        rule.push(')');
        if i != primes.len() - 1 {
            rule.push_str(&quot; | &quot;);
        }
    }
    println!(&quot;{}&quot;, rule);
}
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/278146/">278146</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




