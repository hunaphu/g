<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::34926</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>003</td><td>Rust</td><td>250131T131532Z</td><td><a href="https://codegolf.stackexchange.com/questions/34926/write-a-fast-word-equation-solver/278011#278011">138 Aspe</a></td></tr>
<tr d-ix="1"><td>005</td><td>Python 3</td><td>221023T192554Z</td><td><a href="https://codegolf.stackexchange.com/questions/34926/write-a-fast-word-equation-solver/253665#253665">arrmansa</a></td></tr>
<tr d-ix="2"><td>nan</td><td>C++</td><td>220601T204041Z</td><td><a href="https://codegolf.stackexchange.com/questions/34926/write-a-fast-word-equation-solver/248064#248064">benrg</a></td></tr>
<tr d-ix="3"><td>003</td><td>Python3</td><td>220529T194154Z</td><td><a href="https://codegolf.stackexchange.com/questions/34926/write-a-fast-word-equation-solver/247972#247972">Ajax1234</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Rust, ~0.3ms</h1>
<p>Rust port of @benrg's C++ answer.</p>
<p><a href="https://ato.pxeger.com/run?1=nVrrbttGFv7vp5h6AZuKJUZyF0FLWwbsNO0WSDdFnLbYGoEwokYSNxSpHZK-xPaT7J_-2H2CfZv9tY-y5zJDzpCUk5YIHIqcOXPmXL5zGf7zX7oqyt9--3dVLkdf_ffZ_54_fy7OxVt4KLS60UmpRL4U5VqJVXKtMvHy6EjIdLuWG1UmsdhWHz-mShR5eq10uIez6c9PhVypiG6FiKVe5UJXmRiNxP7F-dHFxfTly5f79PpveQUDMrGVRSE2VVomWyDIdAsh4Z9eVRuVlUW4t7dXFbBYuYgilV2fNL_KZKOi6PusKGVWngDd-k282UbRG71QOslWJ3vwSnyTrJKy2CvvtorvxVQkXx6f7MU5EBAX55evovrFZMyTXquyVNrM4h_-tPPXP_7l_OLVu9nl97_C_KpIPioYcfyC579TemNm462dSyL4UWpgV4p4LbWMkXKSlTk8SHmdJFuoWxGMxTLX4vD8cCgmfHsBt6qMw0G4t0QJApkZzwniiMgNxOjMsnu_B7oQQYxCrb4SIzEHWgP8xQP2Hpmdt6qsdFaIUldKJKx8h7UCOZXbpJSpeJWt0qRYW0YDIBiG08NfD5mjpOhjZ57nqWEG3prdTYXh64Re8MOzKfEoDg7Mg1N88Ouh5fRlnoHZlcDQgtRFQmtYBYnBcodjEhjeTTx5gQg3spzR1GBhVE4cIgkrrjnMF0diwdyRuPB1l4US1QocgG0JOQePqMB3rmVaKVoNX8_geXAbkQXQQmQKvBAIGvYnxuJejG7Fo1Ap2MQ9PHts9FKAe6A7oqbBnGFR3EOVynCvAG3FJZuSGch041wtl0UkrnCtE99M3w9pyFarAhxstpHFB7DcL4-HRjlyAau4jx99gzWrW4TAn65_sxkTA0mcsAvj9HdrMCJ4qOISMCW9A0uTWYGzC0ASAJY1bi5NPiikBsK_uABrBYpgJeN9B2WMpVqcuYS5gSOBgcgzUVRxrIpiKP6aZwofkJuIpUzSSivHccxmAvN_JA5ApqSlN9syybNTh_KZES4s-4s6TFMRayVB3YBjUmt5hxI5fuFtHYSRlIlMARYWaCbjsPaATVUaNcEGr8ZtJQFKuCM72kKpnHhDOprjIQ3LKPH4g4grrYGUKJKFEsERo0qqluVQjPiHTlbrcuCziqMji2KTkw7VbSpjIGewPAFHREqZui0NTrTo0fiaIFJ3WUXpQhTSKN6bpFyjjAkMhmIOk28UUGaJFqXaihy80SxTYOBRyypN7yw5sFKcDS9BiqU4gn0OxZRBwVcHuDhqw_oX_Q4G4VapD3KeqmBgeDzMwc11JNI83xqjMGtdIjuTCMKoJPDYyOyu5gx-b_OiSIBUVE9q1IeDZoX6B3Dws4qjKFM3uKIdeLNOUsbkgjgCxjZyO8t1sJQAG0PxED844PssHgwc3sxSZolwWxXrgGmhjoBWld1ouQ0GzoqPe-7Wvl-i3Glj5FRabHKt7OaGsFX9gREh0RAaYbPGIpu9Atx94TABzKrNtrwL2owSXFhCdTwE4gAhMLFSGdga5A9ZXoq5Eh-VzpF2Uh7Wi4btnTM1Ix0QccPH1fj9SWt040niAcxdnJ76gdalZY3CYf5HnSP8gH-nKeAdWKo1gaXON-xfaLzodWF78rcgWXUrN5ARDREK98X0DBMA3sCQzRmygM7ECxVLTIFQB-yOFIgoeIPVrTLgo7t-1CYjeNGNAniGrHCNVkvUJkNx4f4cOy5kL3T6GHXlqhklNgi1uu4o2urGjLZZgSdrMGQKw5hbnXRmM4ReuQTei6Mp89gd7uJorVp3cs8U2u2zKeWI_uvHHa5CKHCM2Y-K2ScICJskBcVU4xDqO1tg9IDY4_kLZCrxWrhu2pIfhbfpWY9UgYtXLtHOAE1htBM-e0g1Yh72vnNl2j_CdajuiMfBLqniRQzG60H_Nq2EdrB9eHTYP6_mnZRrA1DfiMd-wqPPJDz63ZSnn6CM9gUxEfYMHoy2lcMfTTvg6JhnkF3lAJHhThoAlhT-KfXcOQovYyZoaCe49A-I-eUa4jGaHjKLyIIcc4qltM71Tor9W8aL2AFxTfplhdcf1dXsk_L8KdMqzlcZpWmNl37mplwRfSZbjzsMnu_q5P8cEFwnmHpw-LMlcrj3pyssbq9V8DKFZQfvbSnwc13DEPab-mbYFAWccvGDTZLBKDuGJDFGNJqIhdoCJGFCDrnzzVqRhbnhleZnEgpwU0cOWZJu8drswmsYoPVAPlmCIRV1BYEFhQS8svst6uLmkifxpuo0_ZJAjbeRVZsZzCtM_T0028cHkEedgkjOqIhJIKS2yGWCkizM9y9VunSsxBtnr9byJkXzEa3hZuy_qDnqTLNaNwnrc17c0TeJxpiZ1YYtB28gNppyB7Le0O6LZB0cUOoOOxta3mcgVqfKccpyvHBoaPUxdeeEZT7jSBK4CY-tC710lsO35ngyNRjdW2_NiA9fyAT4MJkQH_73pWgjnpEGp76NJE88Rrway-Uq5Kf-aC83aI133_mzvGSxNct95wvtO0lKtGkhuYTcbpXUbU9v78dMmUGmt9hRKWB2kSCdcRh6VWVL0hAFAm_TByKghCiB0uGLaW9scJfnKiJpmkk7A3mnksjypiqCgILUhgwwhEnJAnEIzO0aiudGBsCwt_7OAsK1jifqmU0dzDC36-EIaozDkn1JBOBuEH_mslDTyXiwm6tUZcDQGdO0mesfYPAy17W6xfwOSMUGlP1Ok-nEJLrVdXFIcUWtFVTmMdbUaGDUKS1wDa6wRVwBKG-AyAaMWAI-e0Vqsz-cM5vfBQ8HcigO5g_dKlNIRI-6-WVydFkL433LUHDKfN4zZb5zioTyfLMNDubzQSO-FjJdVEm6oJBI_Rkf5SxO16Wgq70TfyyOC2PwZt0GPxYst0DW-Y1IpV5hkyxTK4l9LjRjqPkTui-qDdewBtWpA67zRRUrlyakdVtdZaylUisK_mSDx104mOdVtuAW0lBAIYsE-BmUtVj61ZyYBJHfTehdwxm82_Pw48AWRYtbXP7Ag52uwnFYXVPjj_6KDYeSarH1yyqGwa3ym30TN2-ziTrtQIwwTmnq_qjLCrZAaDQsEnjwXOPb4tYgXJc9ToqwVb90Sd1DVlT3Z8duoPGthCCxycLcy2Rk424FRKLoPmZWus8572qE7Y943NnBOY_jXNNuTOVAqTugh5JYRBET2OORC4LfopqjYZc0dCNvkw3Yr21gcfO9ZbbGGIucA9oNmzhXwSBO23kEeMGmqOlK4DEPqnipJFEOPTu85oh4UEu4G8PgKcdzwNy-kIVuygjHBwZfkxXhyVYhjr5-xlOtRKpNZ37jMkdTZ7FnIiCEH4lJO-4ZO_ldnIy-fvZAhB8-g5fx5_OywxbeKtBGwZ34AoANDADFTXElybOiC3JFCWrjBhJyZ1sWtV4arR9qD89YzWh2tOvC7o-wEjuFJpqNeC91qwzbXT7gpbIo6yaRj-IjMWmBNiNm0MwBfBw2AnSgsIXp2HrMNbCagY3GOdSlMr2Rd4UJ2s0ZGReHlHyrBaQLnjes82q1RvUuclUgYAEPHHxtBi9raVMSv0R20O-y3Nk2rtUuD2rd2YqqSDYJSJP64bRrm0TiwS3uIKzn1jfn9oQ1qh8J9O7InLqZ4x3rsz8zedalM4NVSmEhgh3Nk5KQFmbfrBMwKqPytQRu50pllFihrSyldsik-Q1gGWkkokBahy3KhQ1gYABFRJkrZ2oFabM3tY5qT0y1FdKxWyLR7rmG9PdVTV4MOfl22aRCmh57LPA5371nuDbm1d5yBWu9Z-ftliyY11t39t-qLg0OEhT34ZYwmsEl4Fp-4IeAxd_xlB8l04A1Qn4BAmKJ8WwAZIKU0WRAwMB5C0k2z7zc0radjcl5nhO5A7ngYFGcivHAFRvCmYWyxYk_i8DUkfzusQxUCwNEOaXraolJ_kLZ5NnL22tmWmD9ac56Mf7TTD72ZI9-Wr4P7N-HYfhoDnyC0WiBZ-JqsA_0V0lMpQAdPTXS5aE8rnuW8pICMMfXJE3Ku07P_xfFXcMtHlyAfybLnmMBsAR3g6eQPnUHHftqPesd9OXAWFmVoYN1cjB6aStqytgWflTDkqvFCn4v0F4ZnwWOJ0MC2JAeiGl_iYtuQjDXynHs1XJArsGmyGJnKAaJvNi1kFmMkl3wrqQwYREctO77BdbnwGH6m-tAARx4q5OM_doGlf7ub40xJAd74nl1KA67J9B98yknezIjcy9nlavrEPPWpqAz_aX6Y4xrluSgf93-1i6dteHG86r0eolU0qJjybg5fYt27oiOrNzmlz37fWJvtj7gT12eGolXUyT5X-w8dbblXqTfL4L9-8f9oSdWrJ92yAyvnbnoTuLxU9R-h26IaJp9EfTQe5KrOsMxZ__gAaPJTmPO1I3thbme_uB4ev9-3CQRnXSEB5yW2tDFl6ELLH27aWXcbcD7IYdkhBJnRj36cGExguUkhWNMjTkat06tHYgbmXDir-4CXjOiDZWLXQA010p-2FUv4EVUJ2744r-wR8igNjLJahehto9emaY7N8jPQCkqu44ifBEMQnMebi0CWMMXpmF2Ko4dFlVtPvv8WaG4fxSn3755-8NPr88nZ_Xt8ZmAYAlmi5QgrXfUw-n6iZ898_E61rv2E8Oh6e81Tdeo3hA3kOlkyrQKEC2CpG6nDxA4aBPmlFtBRULfrXjYgVjRpwTs8n1Itry2zldabqi69wbFeQYmUqm2GvBqpES-a7lybAC3QaXbDL-XhI2YDyajKMu9rnH9pQ_XFFNzBNLpLuNHHObTTz5kqEVx32Kb5NaxnhbbUfgCOG84DFUqt-CBIEtZzAoVF7Pliz_X36U0iuTvwGgZekT9zC1_eRFF6hZCCr6DeY_8oav53vU_V_sv33zz6ui7N6-_nX739tX5u_335tX_AQ" rel="nofollow noreferrer">Attempt This Online!</a></p>
<pre class="lang-rust prettyprint-override"><code>/// A Rust rewrite of the given C++ alphametic puzzle solver.
/// 
/// Usage:
///   cargo run -- &quot;CODE+GOLF=GREAT&quot;
/// You can pass multiple puzzles as arguments.


use std::env;
use std::time::Instant;
//use std::cmp::Ordering;

// Digits
type Digit = i32;
const BASE: Digit = 10;

// Letters
type Letter = i32;
const ALPHABET_SIZE: usize = 26;

// Terms
type Term = i32;

/// Parse a character into a letter index (0 for 'A', 1 for 'B', etc.).
fn parse_letter(c: char) -&gt; Letter {
    (c as u8 - b'A') as Letter
}

/// Returns true if the character is a capital English letter ('A'..='Z').
fn is_letter(c: char) -&gt; bool {
    let index = c as u8;
    index &gt;= b'A' &amp;&amp; index &lt;= b'Z'
}

/// Convert a digit to a character (0 -&gt; '0', 1 -&gt; '1', etc.).
fn format_digit(d: Digit) -&gt; char {
    (b'0' + d as u8) as char
}

/// Convert a term to its absolute value.
fn term_abs(x: Term) -&gt; Term {
    if x &lt; 0 { -x } else { x }
}

/// Result of parsing a formula.
struct ParseResult {
    coeffs: [Term; ALPHABET_SIZE],
    present_mask: u32,
    leading_mask: u32,
}

/// Parse a formula of the form &quot;BA+BB=CCC&quot; into coefficients.
/// This effectively transforms something like &quot;BA + BB - CCC = 0&quot;.
/// 
/// Returns:
///   Some(ParseResult) on success, None on parse failure.
fn parse_formula(formula: &amp;str) -&gt; Option&lt;ParseResult&gt; {
    // We'll create an array of 26 coefficients initialized to 0.
    let mut coeffs = [0; ALPHABET_SIZE];

    let mut present_mask: u32 = 0;
    let mut leading_mask: u32 = 0;

    // We track current side (+1 for left, -1 for right).
    let mut side: Term = 1;
    // We track place (multiplier for next letter).
    let mut place: Term = side;

    // We'll iterate with an index, but we need to step over letters carefully
    // then interpret +, -, =, etc.
    let mut chars = formula.chars().peekable();

    'outer: loop {
        // Step 1: read as many letters as possible:
        let mut letter_seq = Vec::new();
        while chars.peek().map_or(false, |c| is_letter(*c)) {
            letter_seq.push(chars.next().unwrap());
        }

        // If we read one or more letters, mark the first as leading:
        if !letter_seq.is_empty() {
            // The first letter in this sequence cannot be zero if it's leading.
            let first_letter = letter_seq[0];
            leading_mask |= 1 &lt;&lt; parse_letter(first_letter);

            // Process collected letters from right to left.
            // For example, &quot;BA&quot; =&gt; 'A' first, then 'B'.
            // Because the place value is assigned from right to left:
            //   &quot;BA&quot; means A has place 1, B has place 10, etc.
            for c in letter_seq.iter().rev() {
                let letter_index = parse_letter(*c) as usize;
                coeffs[letter_index] += place;
                present_mask |= 1 &lt;&lt; letter_index;
                place *= BASE;
            }
        }

        // Step 2: check the next character for +, -, =, or end of string:
        match chars.next() {
            None =&gt; {
                // End of string
                return Some(ParseResult {
                    coeffs,
                    present_mask,
                    leading_mask,
                });
            }
            Some(ch) =&gt; {
                match ch {
                    '+' =&gt; {
                        place = side;
                    }
                    '-' =&gt; {
                        place = -side;
                    }
                    '=' =&gt; {
                        // Switch to the other side, but only once.
                        if side &lt; 0 {
                            return None; // More than one '=' sign =&gt; parse error
                        }
                        side = -1;
                        place = side;
                    }
                    _ =&gt; {
                        // Unrecognized character =&gt; parse error
                        return None;
                    }
                }
            }
        }
    }
}

/// A variable in the puzzle.
#[derive(Clone)]
struct Var {
    value: Digit,
    coeff: Term,
    minval: Digit,  // 0 or 1 depending on whether it's leading
    name: Letter,   // letter index
}

/// A puzzle solver that stores the formula and variables.
struct Solver {
    formula: String,
    num_vars: usize,
    vars: Vec&lt;Var&gt;,
}

impl Solver {
    fn new() -&gt; Self {
        Solver {
            formula: String::new(),
            num_vars: 0,
            vars: Vec::new(),
        }
    }

    /// Solve the puzzle and return whether parsing was successful.
    fn solve(&amp;mut self, formula_str: &amp;str) -&gt; bool {
        self.formula = formula_str.to_string();

        // Parse
        let parse_result = match parse_formula(formula_str) {
            Some(res) =&gt; res,
            None =&gt; return false,
        };
        let mut coeffs = parse_result.coeffs;
        let present_mask = parse_result.present_mask;
        let leading_mask = parse_result.leading_mask;

        // Gather letters that appear in the puzzle.
        let mut letters_used = Vec::new();
        for i in 0..ALPHABET_SIZE {
            if (present_mask &amp; (1 &lt;&lt; i)) != 0 {
                letters_used.push(i as Letter);
            }
        }

        // If no letters are used, it's invalid or trivial.
        if letters_used.is_empty() {
            return false;
        }

        // If more than BASE letters are used, can't solve (since base=10).
        if letters_used.len() &gt; BASE as usize {
            return false;
        }

        // Sort letters by ascending absolute value of their coefficients.
        // We'll replicate the std::sort with a custom comparator:
        letters_used.sort_by(|&amp;a, &amp;b| {
            let aa = term_abs(coeffs[a as usize]);
            let bb = term_abs(coeffs[b as usize]);
            aa.cmp(&amp;bb)
        });

        // Build Var array
        self.num_vars = letters_used.len();
        self.vars.clear();

        // We'll track how large a negative or positive sum this puzzle can produce
        // to prune the tree in solve2.
        let mut bounds = [0, 0]; // bounds[0] is negative side, bounds[1] is positive side

        for &amp;letter_idx in &amp;letters_used {
            let idx = letter_idx as usize;
            let coeff = coeffs[idx];
            // If the letter is leading, it can't be zero:
            let is_leading = (leading_mask &amp; (1 &lt;&lt; idx)) != 0;
            let minval = if is_leading { 1 } else { 0 };
            self.vars.push(Var {
                value: 0,
                coeff,
                minval,
                name: letter_idx,
            });
        }

        // According to the sign of each coeff, we add or subtract the maximum possible digit
        // to bounds so that we can check if current partial assignment is feasible.
        for var in &amp;self.vars {
            if var.coeff &gt; 0 {
                // With a digit 9, it gives +9*coeff to the sum
                bounds[1] += var.coeff * (BASE - 1);
            } else {
                // With a digit 9, it gives -9*|coeff| to the sum
                bounds[0] += var.coeff * (BASE - 1);
            }
        }

        // Recursively search for solutions
        // We'll start from the end of self.vars so that we're
        // assigning digits to the largest absolute-coeff letters first.
        let last_index = self.num_vars - 1;
        self.solve2(last_index, 0, bounds[0], bounds[1]);

        // The original code always returns true if parse succeeded,
        // though it doesn't indicate whether a solution was found or not.
        true
    }

    /// Recursive solver similar to solve2 in the C++ code.
    /// 
    /// Arguments:
    ///   pos: index of the current Var to assign
    ///   digits_used: a bitmask of which digits have been used so far
    ///   lower_bound: how negative the partial sum can be
    ///   upper_bound: how positive the partial sum can be
    fn solve2(&amp;mut self, pos: usize, digits_used: u16, mut lower_bound: Term, mut upper_bound: Term) {
        let coeff = self.vars[pos].coeff;
        let mut d = BASE - 1;
        let e = self.vars[pos].minval; // minimum digit (0 or 1)

        // Adjust the bounds so we assume the digit is (BASE-1) for this position.
        // Because in the original code:
        //   if (coeff &lt; 0) upper_bound += coeff * d;
        //   else lower_bound += coeff * d;
        // We'll do that once before descending.
        if coeff &lt; 0 {
            upper_bound += coeff * d;
        } else {
            lower_bound += coeff * d;
        }

        // We'll replicate the &quot;do {...} while (--d &gt;= e)&quot; logic by a loop:
        while d &gt;= e {
            // Check feasibility:
            // We only proceed if:
            //   1) lower_bound &lt;= 0
            //   2) upper_bound &gt;= 0
            //   3) digit unused
            let digit_mask = 1 &lt;&lt; d;
            if lower_bound &lt;= 0 &amp;&amp; upper_bound &gt;= 0 &amp;&amp; (digits_used &amp; digit_mask) == 0 {
                // Assign digit
                self.vars[pos].value = d;

                if pos == 0 {
                    // If this is the last variable (position 0),
                    // we print the solution.
                    let mut digit_chars = [' '; ALPHABET_SIZE];
                    for v in &amp;self.vars {
                        digit_chars[v.name as usize] = format_digit(v.value);
                    }
                    // Print out the formula with replaced letters:
                    for c in self.formula.chars() {
                        if is_letter(c) {
                            let idx = parse_letter(c) as usize;
                            print!(&quot;{}&quot;, digit_chars[idx]);
                        } else {
                            print!(&quot;{}&quot;, c);
                        }
                    }
                    println!();
                } else {
                    // Recurse with pos-1
                    let new_used = digits_used | digit_mask;
                    self.solve2(pos - 1, new_used, lower_bound, upper_bound);
                }
            }

            // Move from digit d to d-1, adjusting bounds.
            lower_bound -= coeff;
            upper_bound -= coeff;

            if d == 0 {
                break;
            }
            d -= 1;
        }
    }
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    if args.len() &lt; 2 {
        eprintln!(&quot;Usage: {} &lt;FORMULA1&gt; &lt;FORMULA2&gt; ...&quot;, args[0]);
        return;
    }

    // For each argument, solve the puzzle:
    let mut code = 0;
    for (i, formula) in args.iter().enumerate() {
        if i == 0 {
            // Skip the program name
            continue;
        }
        println!(&quot;{}&quot;, formula);

        let start_time = Instant::now();
        let mut solver = Solver::new();
        if !solver.solve(formula) {
            code = 1;
        }
        println!(&quot;{:.6}&quot;,start_time.elapsed().as_secs_f64());
    }

    // Return code
    std::process::exit(code);
}
</code></pre>
</div>
<div id="pu1" class="pu"><h1>Python 3, &lt;5ms</h1>
<pre><code>def solver(eqn, soln_format = &quot;eqn&quot;):
    #get weights
    weight = -1
    weights = {}
    for char in reversed(eqn):
        if char=='=':
            weight=1
            continue
        if char=='+':
            if weight&gt;0:
                weight=1
            else:
                weight=-1
            continue
        if char not in weights:
            weights[char] = 0
        weights[char]+= weight
        weight*=10
    
    assert len(weights) &lt;= 10
    weights_sorted = list(weights.values()) + [0]*(10-len(weights.values()))
    weights_sorted.sort()
    
    _, order = zip(*sorted(zip(weights_sorted, range(10)), key=lambda x: abs(x[0]), reverse=True)) #abs sorted order
    order_list = [num - sum(i&lt;num for i in order[:idx]) for idx, num in enumerate(order)] #because indexes change
    order_list = order_list[:len(weights.values())] #to ignore zeros
    order_list.reverse() #to pop and append like a stack
        
    for soln in backtrack(0, weights_sorted.copy(), order_list, list(reversed(range(10))), []):
        weights_copy = weights.copy()
        weight_soln_pair = [(weights_sorted[i],num) for i,num in zip(order, soln)]
        assert sum(i*j for i,j in weight_soln_pair) == 0, &quot;Major error&quot;
        final_soln = {}
        for weight_val, soln_val in weight_soln_pair:
            for char, weight in weights_copy.items():
                if weight == weight_val:
                    final_soln[char] = soln_val
                    del weights_copy[char]
                    break
                    
        if soln_format == &quot;eqn&quot;:
            #CONVERT TO EQN
            eqn_copy = eqn
            for k, v in final_soln.items():
                eqn_copy = eqn_copy.replace(k, str(v))
            yield eqn_copy
        elif soln_format == &quot;dict&quot;:
            yield final_soln
        
def backtrack(val, weights, test_order, remaining, soln):
    #Check if end
    if len(test_order)==0:
        if val==0: 
            yield soln
        return False
    #Check if possible
    if sum([i*j for i,j in zip(remaining, reversed(weights))]) + val &lt; 0: #max
        return False
    if sum([i*j for i,j in zip(remaining, weights)]) + val &gt; 0: #min
        return False
    #Backtrack for each digit
    order = test_order.pop()
    weight = weights.pop(order)
    for i, num in enumerate(remaining):
        del remaining[i]
        yield from backtrack(val+num*weight, weights, test_order, remaining, soln + [num])
        remaining.insert(i, num)
    weights.insert(order, weight)
    test_order.append(order)
    return False
</code></pre>
<p>does pretty much the same as benrg's answer, but in python and does not remove the solutions with leading zeros</p>
<pre><code>%%timeit -n 1 -r 1
print([*solver('CODE+GOLF=GREAT')])
</code></pre>
<hr />
<pre><code>['9428+1437=10865', '9438+1427=10865', '9265+1278=10543', '9275+1268=10543', '8653+0671=09324', '8673+0651=09324', '8643+0672=09315', '8673+0642=09315', '8612+0635=09247', '8632+0615=09247', '7642+0651=08293', '7652+0641=08293', '6918+0934=07852', '6938+0914=07852', '6918+0925=07843', '6928+0915=07843', '5928+0943=06871', '5948+0923=06871', '3857+0862=04719', '3867+0852=04719', '3612+0685=04297', '3682+0615=04297', '2918+0956=03874', '2958+0916=03874', '2918+0947=03865', '2948+0917=03865', '2846+0851=03697', '2856+0841=03697']
4.63 ms ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)
</code></pre>
<p>notebook <a href="https://github.com/arrmansa/fast-word-equation-solver/blob/main/fast-word-equation-solver.ipynb" rel="nofollow noreferrer">link</a></p>
</div>
<div id="pu2" class="pu"><h1>C++, 10000× faster (~20 µs)</h1>
<pre class="lang-cpp prettyprint-override"><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;algorithm&gt;

// digits
typedef int digit_t;
const digit_t BASE = 10;
typedef unsigned digit_mask_t;
inline char format_digit(digit_t d) { return '0' + d; }

// letters
typedef int letter_t;
const letter_t ALPHABETSIZE = 26;
typedef unsigned letter_mask_t;
inline bool is_letter(char c) { return unsigned(c - 'A') &lt; 26u; }
inline letter_t parse_letter(char c) { return letter_t(c - 'A'); }

// terms
typedef int term_t;
inline term_t term_abs(term_t x) { return x &lt; 0 ? -x : x; }


bool parse_formula(const char* formula, term_t coeffs[ALPHABETSIZE], letter_mask_t* ppresent, letter_mask_t* pleading) {
    // Convert BA+BB=CCC into A + 21*B - 111*C = 0.
    letter_mask_t present = 0, leading = 0;
    const char* p = formula;
    term_t side = +1, place = +1;
    for (;;) {
        const char* r;
        for (r = p; is_letter(*r); ++r) {}
        if (p &lt; r)
            leading |= letter_mask_t(1) &lt;&lt; parse_letter(*p);
        for (const char* q = r; q != p; --q) {
            letter_t l = parse_letter(q[-1]);
            coeffs[l] += place;
            present |= letter_mask_t(1) &lt;&lt; l;
            place *= BASE;
        }
        p = r;
        switch (*p++) {
            case 0:
                *ppresent = present; *pleading = leading; return true;
            case '+':
                place = +side; break;
            case '-':
                place = -side; break;
            case '=':
                if (side &lt; 0)
                    return false;
                place = side = -1;
                break;
            default:
                return false;
        }
    }
}

struct Var {
    digit_t value;
    term_t coeff;
    digit_t minval;  // 0 or 1
    letter_t name;
};

class Solver {
    const char* formula;
    letter_t num_vars;
    Var vars[BASE];
    void solve2(Var*, digit_mask_t, term_t, term_t);
public:
    bool solve(const char* formula);
};

bool Solver::solve(const char* formula) {
    this-&gt;formula = formula;
    term_t coeffs[ALPHABETSIZE] = {0};
    letter_mask_t present, leading;
    if (!parse_formula(formula, coeffs, &amp;present, &amp;leading))
        return false;
    // sort the used letters by magnitude of their coefficient
    letter_t letters[BASE];
    letter_t num_vars = 0;
    for (letter_t i = 0; i &lt; ALPHABETSIZE; ++i) {
        if (present &amp; (letter_mask_t(1) &lt;&lt; i)) {
            if (num_vars == BASE)
                return false;
            letters[num_vars++] = i;
        }
    }
    if (num_vars == 0)
        return false;
    this-&gt;num_vars = num_vars;
    std::sort(letters, letters + num_vars, [&amp;](letter_t a, letter_t b) { return term_abs(coeffs[a]) &lt; term_abs(coeffs[b]); });
    // initialize tables
    term_t bounds[2] = {0};
    for (letter_t i = 0; i &lt; num_vars; ++i) {
        vars[i].name = letters[i];
        vars[i].minval = digit_t((leading &gt;&gt; letters[i]) &amp; 1);
        term_t coeff = vars[i].coeff = coeffs[letters[i]];
        bounds[coeff &gt; 0] += coeff * (BASE - 1);
    }
    // call the recursive solver
    solve2(vars + num_vars - 1, 0, bounds[0], bounds[1]);
    return true;
}

void Solver::solve2(Var* pos, digit_mask_t digits_used, term_t lower_bound, term_t upper_bound) {
    term_t coeff = pos-&gt;coeff;
    digit_t d = BASE - 1, e = pos-&gt;minval;
    // adjust bounds to reflect a digit equal to BASE-1, instead of anything in [0,BASE)
    if (coeff &lt; 0)
        upper_bound += coeff * d;
    else
        lower_bound += coeff * d;
    do {
        if (lower_bound &lt;= 0 &amp;&amp; upper_bound &gt;= 0 &amp;&amp; !(digits_used &amp; (digit_mask_t(1) &lt;&lt; d))) {
            pos-&gt;value = d;
            if (pos == vars) {
                // print the solution
                char digit_chars[ALPHABETSIZE];
                for (letter_t i = 0; i &lt; num_vars; ++i)
                    digit_chars[vars[i].name] = format_digit(vars[i].value);
                for (const char* p = formula; *p; ++p)
                    putchar(is_letter(*p) ? digit_chars[parse_letter(*p)] : *p);
                putchar('\n');
            } else {
                solve2(pos - 1, digits_used | (digit_mask_t(1) &lt;&lt; d), lower_bound, upper_bound);
            }
        }
        lower_bound -= coeff;
        upper_bound -= coeff;
    } while (--d &gt;= e);
}


int main(int argc, char **argv) {
    int code = 0;
    for (int i = 1; i &lt; argc; ++i) {
        puts(argv[i]);
        clock_t t = clock();
        code |= !Solver().solve(argv[i]);
        t = clock() - t;
        printf(&quot;%f\n&quot;, double(t) / CLOCKS_PER_SEC);
    }
    return code;
}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=jVfBbttGED1Ll_7C2EUtUhQdyYeiMC0VtuqmRQ04iIMeqggCRa6kbSiS5pKO00Rf0ksuPfbUv-nXdGZ3uVwqEtCDIHJ2dnZm3szb4Z9_R3lSCfot1lH0-fNfVbnyv_v3K-9rnkZJFTO4EmXMs_PNpNuISr5lbUmYrLOCl5vtpNt98QJivual6JYfchazFfC0VKJFGXSjLBXmFW6uH25hDKNhYLSrVPB1ymKtsw3FO9rH04SnDKJNWMAqK7ZhuZAKTm0qduEjFKysihR6wx54EAewk_4krCxZ0XZIyRqP6ne4vnv10_XN7ZuHn38j1y6-PeCaVt7zbZllCXCxUKuOdDWyvKq3OxH40LvuuXCF5ivyUlswTuRhIdhRQ7WaMVQHitJtO0ySWC6qV_UXLoWj358t48_o1RC-B_8ZLuFZWu7KyJRPlPsqCR2VNXKtD1o2qM1HGVutxMzO5HzQTlof8rxggqXllwsJC2OertGnbgeDmmbpEyuoVrybm_F0OqXAMrhGhC9G_RtMwWg06k8Rq-F5t9MyBvoMWqNzpF16CbodO4AcZToIXNFRCI6lPQZvNECXwkg94zIqghME0r2WlQIX1WqBunlg1UK_QIw8r8BNO1TiK3ByzHPh4kun9uvTuJ0KZ4QVctWuhX7umlPssx_xxCLAvxN5su8_Kv86pqQS8sk29TjzR3NpraMBS-bgjVWwUlxn74hjiVKSuemPZS-ThALMpTv4IN7zMtoA-u152qMoFAyGl_TY6ecNQvopgH7eIKWfgro6y6JSvkkrPa-n7BiACLQAlgUL31lq_p6af1htrNUIHok-doJEqNPRx6_CRKjzjS1dJv5IiRub2IJhlZTK5P5-TNKui60lMKCohF-xwzE5NZc9hYkM0-6noFne8hQ1AgDsjiFgKYy6Dc5puMWtu6DbjZJQCHjIEmwfsn6gZQN7Y7VdPGGBoIzcoccZYTpHwVPGYxBk6cLBxf6gxc5149f_WFR5tUx4hLFL6pA7D1GGqzyVSsrRy8vjyhREueHCn2jJobY9RD6o93G4C46wg2EGVCDoT9pMZ9hNWR7Amdl3VlMVVckexIiNyJC2yg2DSphLQ8DyA2zDdcpLujqzFSnwQhnnEUe7FiZ6j8HhC7A0mUk-MItcSvHvqnWbEQNx1YSSgHTnnZmdre7mru5X0m2OU33uHizqTu1ure55lHpuCv4LW8MDiVMIWwFahYnTCBVIUWqXxcCk1TN6A5idzZtshIPmXl1aF525BHXFhHO6kPelyzndrq4ClCNqPEz4H3iThsuECVN1y6xKYzG7aErtKCQmnAYO2Wt8fk69C2ODOifIzaLqelzWNOA4NU1OJtYWFwEdSVq3GwK31Xbq95r0zU55mg5EKU1gKK8E9dYHR85rvrK_kymJwiSRNV6wqCoEf2Kq2wsES_GFRLFBh7YP6DrWJw3n5lFdRy2mR4qU3NMiB8VBkGeizUN68FxQu5lhJMneIwLyBCOr8ryWKVJpZwoN-5N90o1Blb7yn9VqmotlLsL490rUtQA4oxRslTCk91B5BuyxQgRxgQz5aIYjySGIRANh-gErH9HkKcyGA91l1DDKLX0XWa7byMToAcP-QQ0r4H2NODPdb2tdYW3C2ZmdFpho2YljJZW4wk64porYrblCpkTeXlSnQU0fKKZuJ_i1IqUrL-SEupEVU5U8S-WKHHfVKfS4R-Xqlv2fzaXubtuW3WlzfX2YT4l6UQbgWicdmxVxVKGDcn1QXpWk41hzX-7iKG07sD_NzXHK1kNdY6D3Nu0p0Q4IVZ0zXfyUTVmENjKfjiAzaDeAXfnqAD2x2fXgj83I0ao3S76D9xueMHB8X9YKpYu-FAjRbchThx7CYh0N1Cdbv48vTxJ8WokyOTSZq4tkhOJIoUgbLXrEtAiH9hO9kVNRkkXU7zQ2ymdHickqDqsnii0c91zNEvZWawsmsSSRrMOVc_rN6m16ilnNcHZhTukCfnvc3U9_eVi8un29eLidatbTBEWnYdDqm1l_Ov8zO53e_3Drvby_-3H88vXt9ZvTuV76Dw" rel="noreferrer">Attempt This Online!</a></p>
<p>This is roughly 10,000 times faster than JeffSB's solver and 2,500 times faster than Ajax1234's solver on my machine on the problem <code>CODE+GOLF=GREAT</code>. The speed ratio varies widely with the problem. For <code>FIFTY+STATES=AMERICA</code>, the JeffSB/me ratio is 25,000, while for <code>CORRECTS+REJECTED=MATTRESS</code> it's about 25.</p>
<p>The algorithm is quite different. Neither JeffSB nor Ajax1234 explained theirs, but it appears they both do digitwise addition from right to left. This program converts a problem like <code>TO+GO=OUT</code> into a formula like <span class="math-container">\$-98 O + 10 G - 10 U + 9 T = 0\$</span>, with the terms sorted by absolute value. For each term from left to right, for each possible value of that digit, it computes upper and lower bounds for the sum by assuming that every later digit is 0 or 9. If the bounds include 0 then it recurses.</p>
<p>Since it doesn't cost any time, this program supports a more general set of alphametics with arbitrarily many terms on both sides of the <code>=</code>, and subtraction as well as addition. It can very quickly solve problems like <code>NINETEEN+NINETEEN+TEN+TEN+TEN+TEN+NINE+NINE+NINE+NINE+NINE+ONE+ONE+ONE+...=THOUSAND</code> where there are 877 <code>ONE</code>s.</p>
<p>I tried computing slightly more sophisticated bounds, and rewriting the recursive function as an iterative one, but both changes only improved performance by 1-2%, and complicated the code, so I reverted them.</p>
<p><sup>(Sources for example problems: <a href="http://www.cadaeic.net/alphas.htm" rel="noreferrer">Mike Keith</a>, <a href="https://www.dr-mikes-math-games-for-kids.com/cryptarithms.html" rel="noreferrer">Michael Hartley</a>)</sup></p>
</div>
<div id="pu3" class="pu"><h1>Python3, 0.03 seconds:</h1>
<pre class="lang-py prettyprint-override"><code>def f(a, b, r, c = {}, s = [], k = 0, l = [], A = [], B = []):
   if not a and not b:
      yield f&quot;{''.join(map(str, A))}+{''.join(map(str, B))}={''.join(map(str, l))}&quot;
      return
   for x in c.get(a[-1], range(10)):
      if a[-1] in c or x not in s:
         _c, _s = {**c, a[-1]:[x]}, s+[x]
         for y in _c.get(b[-1], range(10)):
             if b[-1] in _c or y not in _s:
                n_c, v = {**_c, b[-1]:[y]}, k+x+y
                n_s = _s+[y]
                if a[:-1] and b[:-1]:
                    _v, _k = v%10, v//10
                    if [_v] == n_c.get(r[-1], [_v])and (r[-1] in n_c or _v not in n_s):
                        yield from f(a[:-1], b[:-1], r[:-1], {**n_c, r[-1]:[_v]}, n_s+[_v], _k, [_v]+l, [x]+A, [y]+B)
                else:
                    if len(str(v)) == len(r):
                        F = 1
                        for J, K in zip(r[::-1], str(v)[::-1]):
                            if n_c.get(J, [int(K)]) == [int(K)] and (J in n_c or int(K) not in n_s):
                               n_c[J] = [int(K)]
                               n_s = n_s + [int(K)]
                            else:
                               F = 0
                               break
                        if F: yield from f(a[:-1], b[:-1], '', n_c, n_s, 0, [v]+l, [x]+A, [y]+B) 
            
t = time.time()
result = [*f('CODE', 'GOLF', 'GREAT')]
print(time.time() - t)
print(result)
</code></pre>
<p><a href="https://tio.run/##jVRNb5tAEL3zK0aRKlhDHFu9REg@2I1dyWljKe0lQgiBvaTUeEELQaZWfrs7swu1G39yYHZnZ@a9eTuQ1@WvTHy@z@V2m6zyTJZQJituLHgMsRU6EDkgHZjDADbvDhRoPd@BJdqeA2mzHTZ2pCxzDQBIYhBZCSGEYqFWkXLjUyc8XUB8szHN7u8sEdYqzK2iRJghY@/2oXuE7sGhO0X3TVNT8vJNCtrEmYQ1JALm3VdeWqF320dmMhSv3Or3GGtZID91pkJBJRFL3BVtCD7B3IGAut50OrhUGa639kkLG@0uknBrSg80cHQKGP7hRy1@oAjULYGg@BCLjyAmlSZCy0gzqYnJ0l7b9ZEM4h0gzdo/OFTduwRP1xOp5SGoUqBCBei@q099vPLq7q7fOxqIJb2g8mEwILJKA6k1IDcjHO2gFoVuOajanpEtO05gb2RktqKpVGydhjVK3FhURqkktTQIitoIEgCX1IRmYqdo1749RFP79ogdoPK04O6pHlMuaPysijFqlbbyDPMJKtc/eUpDM3XgkRT4k@Soj6t70Qh6d6Z6w6nVG0t5iSitR@Yrcu1GXbI13RNeH1wn/m4CvakPu6qXE2gA6W1fl3Na9w@C9i4FRZKHS@OMYhP3/EyZpqM/OaTv0K/OOzI4/1c1jBKp0d@zSy@LGZIXbyk5vU5smV9mD2Osan6dfZso@zwe/jRRklySOHuJcAsla9y6BrtQ@8f46YFqfp89j7V9Gr9cW3u7/Qs" rel="nofollow noreferrer">Try it online!</a></p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/34926/">34926</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




