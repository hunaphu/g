<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::634</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>733</td><td>C gcc</td><td>210309T081712Z</td><td><a href="https://codegolf.stackexchange.com/questions/634/interpret-befunge-93/220438#220438">ceilingc</a></td></tr>
<tr d-ix="1"><td>323</td><td>Befunge93</td><td>210225T053413Z</td><td><a href="https://codegolf.stackexchange.com/questions/634/interpret-befunge-93/219764#219764">quintopi</a></td></tr>
<tr d-ix="2"><td>842</td><td>Delphi</td><td>110318T074437Z</td><td><a href="https://codegolf.stackexchange.com/questions/634/interpret-befunge-93/1687#1687">Patrickv</a></td></tr>
<tr d-ix="3"><td>1104</td><td>16bit MSDOS .COM File</td><td>110209T171223Z</td><td><a href="https://codegolf.stackexchange.com/questions/634/interpret-befunge-93/774#774">Skizz</a></td></tr>
<tr d-ix="4"><td>515</td><td>Perl</td><td>110207T164724Z</td><td><a href="https://codegolf.stackexchange.com/questions/634/interpret-befunge-93/661#661">J B</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>C (gcc), <s>853 815 801 787 770 748</s> 733 bytes</h1>

<pre class="lang-c prettyprint-override"><code>#define z(a,b);a(){b;}
#define Q s[1]
#define Z*--s
S[1&lt;&lt;20],*s=S,x,y,m,r,c=-1,t;M[25][80]z(b,*s=!*s)z(G,m=1)z(k,c+=x;r+=y)z(H,Z)z(E,Z%=Q)z(K,scanf(&quot;%d&quot;,++s))z(B,Z*=Q)z(A,Z+=Q)z(i,putchar(Q,Z))z(a,Z-=Q)z(I,printf(&quot;%d &quot;,Q,Z))z(d,Z/=Q)z(g,1[s++]=*s)z(L,x=-1;y=0)z(R,x=1;y=0)z(w,*s^=Q^=*s^=Q)z(U,x=0;y=-1)z(h,Z;Q?L():R())z(e,Z=*s&gt;Q)z(J,*s=M[*s][Z])z(j,M[*s][2[s-=3]]=Q)z(D,x=0;y=1)z(v,Z;Q?U():D())z(l,read(0,++s,1))F();(*f[])()={[33]=b,G,k,H,E,K,[42]=B,A,i,a,I,d,[58]=g,0,L,0,R,F,[92]=w,0,U,h,e,['g']=J,['p']=j,['v']=D,['|']=v,0,l}z(F,f[&quot;&gt;&lt;^v&quot;[rand()&amp;3]]())main(C,V)int**V;{for(t=open(V[1],0);read(t,&amp;C,1);)C-10?M[y][x++]=C:(x=!++y);for(R();m|t-64;m?t-34?*++s=t:(m=0):t&gt;47&amp;t&lt;58?*++s=t-48:f[t]&amp;&amp;f[t]())t=M[r=(r+y+25)%25][c=(c+x+80)%80];}
</code></pre>
<p><a href="https://tio.run/##jVNbU6NKEH7nV4zjJjtAo5DEcyJkcNd42YseK27pA1NkiwBBVEgKJjHR9be7DYmXU9ZW7VQxffv6656ZZhSUV09hIHu9w7NT4o7Gu@2t8GkzisdpHpN7FsBIdQKmPoycR@XZPSClsPwX09MMo1R@CKvXa5k@aCX/AQtYQgYFhNywQDqnorXji67p37NRBdjQSvWeHUPGLZQ3EOp84RQ6X6L1BTzcD8Fr8AEq36EMg3zMaCOioOulir598LQ6@Bk8vVZSmM5keBUUbIDpatW4Z9SRrzAt0lzWBITCOhyBt12HE7BEqes@rzs6gQU27Cy5icY5Gs/6HXY95IMhrwU6LjBoYtCoDnAFnjPYO2Gqfc4q9hg8BLoV7lt13FOhlb7wfLSvYWW0RGnwtu/XZAdrsoprXnNdINdBzXULRRxEzKzODpaqHjHVYdpY@CpT@YNot30@gmO4gS9wCN9BdFo@34fPkEIAXyECsdP1eQImnOB3DkcgdhFxh8YFXEEM4mPy0effUE5RXqOcozxA@QvlHHG3j/fsCMaCur3hnIoiyCOmNrF37C8L0pz14VLFK9a0S@dhPCmY5JNpnLNLHBIwVafuX0Kzj@07at@wzL1TsfTForr2vs0WfEPXl6pTpeL9OdkvafzTcbI9abQ7exqem0ubZfgOtnQ7/zZlb6e7dhudrj0W0m82qx37kXjXBWeFvtRbO2qjmrqQs1Bf6F1TbeAAOo9POOlKEoZkNezEmNQaUV5/AxmXcqtyKpZhJjb1qLE5//lh19JpOQ2KOyJn020ZH1PX3oSfH8j/15z8cXnKq@7alLzyxmEwLUmZFzMZF0TGCdk/O1vzz5V3lK5J/wDeQjaoIYrbtXVbs6ypZSVYpyoj0xHpkijOk7SkpmWsghsYpfmMupTERUDK29u4v6LD0m9ruy8cCH233HofvvdXWTfF5I5QsqmsYZUfbzObXZM4iQ5X5dD5ijU7Rrth6djbm4QijvI0yPDY8TyVQULnikvlJCcT/LuH5K/WmwSFxv89l66fty4dR5MsydNCliRPyacV4NNfUStKNV5b2/VIvczR028" rel="nofollow noreferrer" title="Bash â€“ Try It Online">Try it online!</a></p>
<p>The program is loaded into an array and the interpreter enters the main loop; the byte at the current program counter is the offset of an array of function pointers, each function performs the operation required by that instruction. String mode and numeric literals are special cases that are handled differently.</p>
<p>Slightly golfed less</p>
<pre class="lang-c prettyprint-override"><code>#define z(a,b);a(){b;}
#define Q s[1]
#define Z*--s
S[1&lt;&lt;20],*s=S,x,y,m,r,c=-1,t;M[25][80]
z(b,*s=!*s)                /* ! */
z(G,m=1)               /* string mode */
z(k,c+=x;r+=y)             /* # */
z(H,Z)                     /* $ */
z(E,Z%=Q)                  /* % */
z(K,scanf(&quot;%d&quot;,++s))       /* &amp; */
z(B,Z*=Q)                  /* * */
z(A,Z+=Q)                  /* + */
z(i,putchar(Q,Z))          /* , */
z(a,Z-=Q)                  /* - */
z(I,printf(&quot;%d &quot;,Q,Z))     /* . */
z(d,Z/=Q)                  /* / */
z(g,1[s++]=*s)             /* : */
z(L,x=-1;y=0)              /* &lt; */
z(R,x=1;y=0)               /* &gt; */
z(w,*s^=Q^=*s^=Q)          /* \ */
z(U,x=0;y=-1)              /* ^ */
z(h,Z;Q?L():R())           /* _ */
z(e,Z=*s&gt;Q)                /*\` */
z(J,*s=M[*s][Z])           /* g */
z(j,M[*s][2[s-=3]]=Q)      /* p */
z(D,x=0;y=1)               /* v */
z(v,Z;Q?U():D())           /* ~ */
z(l,read(0,++s,1))         /* | */
F();                       /* ? */
(*f[])()={[33]=b,G,k,H,E,K,[42]=B,A,i,a,I,d,[58]=g,0,L,0,R,F,[92]=w,0,U,h,e,['g']=J,['p']=j,['v']=D,['|']=v,0,l}
z(F,f[&quot;&gt;&lt;^v&quot;[rand()&amp;3]]()) /* ? */
main(C,V)int**V;{
 /* load */
 for(t=open(V[1],0);read(t,&amp;C,1);)
  C-10?M[y][x++]=C:(x=!++y);
 /* execute */
 for(R();m|t-64;m?t-34?*++s=t:(m=0):t&gt;47&amp;t&lt;58?*++s=t-48:f[t]&amp;&amp;f[t]())
  t=M[r=(r+y+25)%25][c=(c+x+80)%80];
}
</code></pre>
</div>
<div id="pu1" class="pu"><h1>Befunge-93 - <s>404</s> <s>371</s> <s>361</s> <s>352</s> <s>339</s> <s>337</s> 323 bytes</h1>
<pre><code>&lt;xyXYvp01&lt;&gt;110vv5_v#`0+1:_v#+!-&quot;g&quot;\&lt;v&quot;&lt;&quot;:::&lt;&gt;1v#p03-1_&gt;! g20gp00g1+0v25p
v2g02 &lt; p0 20p&lt;+vp020p01-10$_:&quot;p&quot;-!^&gt;&gt;-!\ v^ &lt;&gt;0p20pv|!*-&quot;;&quot;\+1::~p0&lt;
v2-10&lt;^v# ^#&lt;  &lt;&lt;$&lt;       &lt; ^+!-&quot;_&quot;\+!-&quot;?&quot;&lt;&gt;#^_10v4p&lt;:^00 _$20g1+20p^
v21p010&gt;#&lt;40g20v&gt;\%:40p5+g:92p:75*1--00g!\#^_\$0 v   &gt;91+-^
&lt;3+g01g 03p04+g&lt;^++g04g02:*54p03:%\++g03g01:&quot;P&quot;p0&lt;
</code></pre>
<p><a href="http://esolang.rutteric.com/fungejs/?initprog=JTNDeHlYWXZwMDElM0MlM0UxMTB2djVfdiUyMyU2MDAlMkIxJTNBX3YlMjMlMkIhLSUyMmclMjIlNUMlM0N2JTIyJTNDJTIyJTNBJTNBJTNBJTNDJTNFMXYlMjNwMDMtMV8lM0UhJTIwZzIwZ3AwMGcxJTJCMHYyNXAlMEF2MmcwMiUyMCUzQyUyMHAwJTIwMjBwJTNDJTJCdnAwMjBwMDEtMTAlMjRfJTNBJTIycCUyMi0hJTVFJTNFJTNFLSElNUMlMjB2JTVFJTIwJTNDJTNFMHAyMHB2JTdDISotJTIyJTNCJTIyJTVDJTJCMSUzQSUzQX5wMCUzQyUwQXYyLTEwJTNDJTVFdiUyMyUyMCU1RSUyMyUzQyUyMCUyMCUzQyUzQyUyNCUzQyUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQyUyMCU1RSUyQiEtJTIyXyUyMiU1QyUyQiEtJTIyJTNGJTIyJTNDJTNFJTIzJTVFXzEwdjRwJTNDJTNBJTVFMDAlMjBfJTI0MjBnMSUyQjIwcCU1RSUwQXYyMXAwMTAlM0UlMjMlM0M0MGcyMHYlM0UlNUMlMjUlM0E0MHA1JTJCZyUzQTkycCUzQTc1KjEtLTAwZyElNUMlMjMlNUVfJTVDJTI0MCUyMHYlMjAlMjAlMjAlM0U5MSUyQi0lNUUlMEElM0MzJTJCZzAxZyUyMDAzcDA0JTJCZyUzQyU1RSUyQiUyQmcwNGcwMiUzQSo1NHAwMyUzQSUyNSU1QyUyQiUyQmcwM2cwMSUzQSUyMlAlMjJwMCUzQyUwQSUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUzQiUwQTBfNzElM0FFbnRlciUyMGlucHV0JTIwcmVhZGluZyUyMHN1YnByb2dyYW0lMEEyXzU4JTNBbGVmdCUyMGlmJTIwbm90JTIwbmV3bGluZSUyQyUyMHJpZ2h0JTIwaWYlMjBuZXdsaW5lJTBBMV81MyUzQXVwJTIwaWYlMjBFT0YlMjBvciUyMCUzQiUyMGRvd24lMjBvdGhlcndpc2UlMEEwXzUzJTNBZXhpdCUyMGlucHV0JTIwcmVhZGluZyUwQTBfNTIlM0FiZWdpbiUyMGluaXRpYWxpemF0aW9uJTIwb2YlMjAoMCUyQzApJTIwdG8lMjAoNSUyQzApJTBBNF80OSUzQWVudHJ5JTIwdG8lMjBtYWluJTIwbG9vcCUwQTNfNDQlM0FyaWdodCUyMGlmJTIwbGFzdCUyMG9wJTIwd2FzJTIwJTIyJTIwbGVmdCUyMGFuZCUyMHVwJTIwb3RoZXJ3aXNlJTBBM180NiUzQXRocm93JTIwYXdheSUyMHB1c2hlZCUyMCUyMiUwQTNfNDclM0F1cGRhdGUlMjAoMCUyQzApJTIwd2l0aCUyMG5ldyUyMHN0cmluZyUyMG1vZGUlMjBmbGFnJTBBMl80NiUzQXJpZ2h0JTIwaWYlMjBzdHJpbmclMjBtb2RlJTJDJTIwbGVmdCUyMGFuZCUyMHVwJTIwb3RoZXJ3aXNlJTBBMF80MyUzQWVudGVyJTIwc3BlY2lhbCUyMGNhc2UlMjBwcm9jZXNzaW5nJTBBMV8yOCUzQWxlZnQlMjBpZiUyMGN1cnJlbnQlMjBvcCUyMGNvdWxkJTIwc2V0JTIwZGlyZWN0aW9uJTIwdG8lMjB3ZXN0JTIwKCUyMl8lMjIlMkMlMjAlMjIlM0YlMjIlMkMlMjBvciUyMCUyMiUzQyUyMiklMkMlMjBvdGhlcndpc2UlMjByaWdodCUwQTFfMjYlM0FzZXQlMjBkaXJlY3Rpb24lMjB0byUyMHdlc3QlMEEwXzI1JTNBbGVmdCUyMGlmJTIwY3VycmVudCUyMG9wJTIwaXMlMjAlMjJnJTIyJTIwb3IlMjAlMjJwJTIyJTJDJTIwcmlnaHQlMjBhbmQlMjBkb3duJTIwb3RoZXJ3aXNlJTBBMF8xNyUzQWxlZnQlMjBpZiUyMHklMjB2YWx1ZSUyMGlzJTIwbm9ubmVnYXRpdmUlMkMlMjByaWdodCUyMGFuZCUyMGRvd24lMjBvdGhlcndpc2UlMEEyXzE3JTNBcmVtb3ZlJTIwdGhlJTIwMCUyMHdlJTIwcHVzaGVkJTIwb24lMjBlaXRoZXIlMjBvZiUyMHRoZSUyMHR3byUyMGJyYW5jaGVzJTIwdGhhdCUyMGFycml2ZSUyMGhlcmUlMEExXzE1JTNBaW5jcmVhc2UlMjBub25uZWdhdGl2ZSUyMHklMjB2YWx1ZXMlMjBieSUyMDUlMjAodG8lMjBhdm9pZCUyMG1vZGlmeWluZyUyMHRoaXMlMjBpbnRlcnByZXRlciklMEEyXzE1JTNBYWxsJTIwc3BlY2lhbCUyMGNhc2UlMjBicmFuY2hlcyUyMGFyZSUyMHRvZ2V0aGVyJTIwbm93JTBBMl85JTNBZXhlY3V0ZSUyMHRoZSUyMGN1cnJlbnQlMjBvcCUyMGhlcmUlMEEwXzEwJTNBc2V0JTIwZGlyZWN0aW9uJTIwdG8lMjBlYXN0JTBBMV80JTNBcmVhZGluZyUyMGZyb20lMjAoMiUyQzApJTIwYW5kJTIwd3JpdGluZyUyMGl0JTIwYWdhaW4lMjBpcyUyMGElMjBub3AlMjB0byUyMGFsbG93JTIwYWxsJTIwYnJhbmNoZXMlMjB0byUyMGVuZCUyMHdpdGglMjAwcCUwQTJfNDclM0F3cml0aW5nJTIwMSUyMHRvJTIwKDAlMkMwKSUyMGV2ZW4lMjB0aG91Z2glMjBpdCUyMGlzJTIwYWxyZWFkeSUyMDElMjBhbGxvd3MlMjB0aGlzJTIwYnJhbmNoJTIwdG8lMjBlbmQlMjB3aXRoJTIwMHAlMEE0XzQ4JTNBYWxsJTIwNyUyMGJyYW5jaGVzJTIwdGhhdCUyMGV2ZW50dWFsbHklMjBtZXJnZSUyMGhlcmUlMjBhcmUlMjByZWFkeSUyMHRvJTIwd3JpdGUlMjB0byUyMHRoZSUyMGdyaWQlM0IlMjB0aGlzJTIwMHAlMjBpcyUyMGZvciUyMGFsbCUyMG9mJTIwdGhlbSUwQTBfOSUzQXNldCUyMGRpcmVjdGlvbiUyMHRvJTIwbm9ydGglMEEzXzYlM0FzZXQlMjBkaXJlY3Rpb24lMjB0byUyMHNvdXRoJTBBM18xMCUzQWluY3JlbWVudCUyMElQJTIwb25jZSUyMGZvciUyMHRyYW1wb2xpbmUlMjAobWFpbiUyMGxvb3AlMjB1cGRhdGUlMjB3aWxsJTIwaGFuZGxlJTIwd3JhcHBpbmclMjBpdCklMEEzXzI1JTNBZmV0Y2glMjBjdXJyZW50JTIwb3AlMEEzXzI2JTNBa2VlcCUyMGElMjBjb3B5JTIwb24lMjB0aGUlMjBzdGFjayUwQTNfMjklM0FwbGFjZSUyMHRoZSUyMG90aGVyJTIwaW4lMjB0aGUlMjBleGVjdXRpb24lMjBwZW4lMjBhdCUyMCg5JTJDMiklMEEzXzM2JTNBbWFrZSUyMHplcm8lMjBpZiUyMGN1cnJlbnQlMjBvcCUyMGlzJTIwJTIyJTBBM180MCUzQWZldGNoJTIwYW5kJTIwaW52ZXJ0JTIwc3RyaW5nJTIwbW9kZSUwQTNfNDElM0F0aGVuJTIwcHV0JTIwJTIyJTIwdGVzdCUyMGJhY2slMjBvbiUyMHRvcCUwQTBfMCUzQXdoZW4lMjBpbnB1dCUyMHJlYWRpbmclMkMlMjBjb2x1bW4lMjBudW1iZXIlM0IlMjBlbHNlJTIwc3RyaW5nbW9kZSUyMGZsYWclMEEwXzElM0F4JTIwaW5jcmVtZW50JTIwZm9yJTIwY3Vyc29yJTBBMF8yJTNBd2hlbiUyMGlucHV0JTIwcmVhZGluZyUyQyUyMHJvdyUyMG51bWJlciUzQiUyMGVsc2UlMjB5JTIwaW5jcmVtZW50JTIwZm9yJTIwY3Vyc29yJTBBMF8zJTNBeCUyMGNvb3JkaW5hdGUlMjBvZiUyMGN1cnNvciUyMChyZWxhdGl2ZSUyMHRvJTIwaW50ZXJwcmV0ZWQlMjBwcm9ncmFtKSUwQTBfNCUzQXklMjBjb29yZGluYXRlJTIwb2YlMjBjdXJzb3IlMjAocmVsYXRpdmUlMjB0byUyMGludGVycHJldGVkJTIwcHJvZ3JhbSk%3D" rel="noreferrer">Try It Online!</a></p>
<p>Input program must have at most 20 lines. Input can be provided in same file as Befunge program by placing it after a <code>;</code> character. Yes, it can interpret itself, but the <code>*54</code> in the bottom line should be replaced by <code>*53</code> if you do that. And if you ask that interpreted interpreter to interpret itself, change it to <code>*52</code> etc. If run in a Befunge-97 interpreter, it will also support the <code>a-f</code> commands (but not <code>'</code> or any new command that affects control flow or wrapping behavior).</p>
<p>Note that it basically asks the interpreter it runs in to handle all the stuff relating to I/O and stack, so its specific behavior is largely dependent on that of the interpreter running it. In other words, it is perfectly compliant if run in a compliant interpreter.</p>
<p>It works by reading in the program from input (until EOF or semicolon) directly into the playfield below it, then simulating the movement of a virtual instruction pointer through that program. It copies each command from the program into its own execution area (at position (9,2) on the grid) and runs its own instruction pointer through it after ensuring all of its own data has been removed from the stack (as all of the interpreted program's stack data is maintained at the bottom of the stack). This is the standard methodology for Befunge self-interpretation since the early 00s, but I don't think it has ever been done in such a small program.</p>
<p>A fuller explanation is in the annotations you can see by clicking the link above.</p>
</div>
<div id="pu2" class="pu"><h2>Delphi, <strike>970</strike> 842</h2>

<p>Since I did the Fish golf first, I just copied that and changed the interpretation to use Befunge-93 specs (which are simpler than Fish) so I mainly had to strip things away.</p>

<p>In the next revision I won 64 characters by implementing the movement code using 2 instead of 4 variables. Oh, and I inverted the stack, removing the need for a length variable.
Another nice win is the '?' (random direction) instruction - I just change it into one of the four directions and let them handle it.</p>

<pre><code>const X=80;var f:TextFile;c,s:String;i,p,d,A:Int16;procedure U(v:Int8);begin s:=Chr(v)+s;end;function O:Int8;begin if s=''then Exit(0);O:=Ord(s[1]);Delete(s,1,1)end;procedure E;begin i:=(p div X)+(d div X);p:=i*X+(p+d)mod X;i:=Ord(c[1+p])end;begin Assign(f,ParamStr(1));Reset(f);for A:=1to 26do begin ReadLn(f,s);c:=c+s+StringOfChar(' ',X-Length(s))end;d:=1;p:=-d;repeat E;A:=i;case i-32of1,63,92:A:=Ord(O=0);2:repeat E;U(i)until i=A;5,15,26,60:A:=O;31:i:=Ord('&lt;&gt;^v'[1+Random(4)]);71,80:A:=X*O+O+1;6:Read(A);94:Read(PChar(@A)^)end;if i=58then U(A);case i-32of 16..25:U(i-48);11:U(O+O);13:U(-O+O);10:U(O*O);15:U(O div A);5:U(O mod A);64:U(Ord(O&lt;O));28,30:d:=i-61;62:d:=-X;86:d:=X;63:d:=2*A-1;92:d:=2*A*X-X;2,4:O;60:s:=Chr(O)+Chr(A)+s;14:Write(O,' ');12:Write(Chr(O));3:E;80:c[A]:=Chr(O);71:U(Ord(c[A]));32:Exit;1,6,26,94:U(A)end;until 0=1;end.
</code></pre>

<p>Here the indented and commented code :</p>

<pre><code>{debug}uses Windows;{}
const
  X=80;
var
  // f is the source file
  f:TextFile;
  // c is the entire codebox (a 2-dimensional program)
  c,
  // s is the stack (kept as a string)
  s:String;
  // i is the current instruction read from the program
  i,
  // p is the position in the program
  p,
  // d is the delta for each step
  d,
  // A is a temporary variable (only uppercase var, to coincide with comments)
  A
  :Int16;

procedure U(v:Int8); // PUSH
begin
  // Push value onto the stack:
  s:=Chr(v)+s;
end;

function O:Int8; // POP
begin
  // Pop value from the stack :
  if s=''then Exit(0);
  O:=Ord(s[1]);
  Delete(s,1,1)
end;

procedure E; // STEP
begin
//{debug}Sleep(3);{}
  // Note : x-step needs to stay on same line, y-step needs to stay on same column
  i:=(p div X)+(d div X);
//  i:=i mod 25;// Enable this to wrap y-edge too
  p:=i*X+(p+d)mod X;
  i:=Ord(c[1+p])
end;

begin
  // Open file given at the command-line, and read &amp; expand it's lines into our program buffer :
  Assign(f,ParamStr(1));
  Reset(f);
  for A:=1to 26do
  begin
    ReadLn(f,s);
    c:=c+s+StringOfChar(' ',X-Length(s))
    {debug};SetLength(c,A*X)
  end;
  // s:=''; Since we read 1 line too many above, s should always be empty now
  d:=1;
  p:=-d;
  repeat
    // Take a step (which gives a new 'i'nstruction) and make a copy of the stack :
    E;

    // Prevent begin+end pairs by handling instructions in 3 consecutive case blocks; This is applied to
    // all situations where this saves 1 or more characters, justifying the cost for another case-block.

    // Shorten '"' (&gt;2) string-collecting, by remembering the quote character in A :
    A:=i;

    // Shorten a few cases by preparing variables so they can be shared with eachother and the 3rd case-block below :
    case i-32of // Note : The instruction is decreased by 32, resulting in less digits in the cases below!
      // Shorten '!' (&gt;1), '_' (&gt;63) and '|' (&gt;92), by remembering Ord(O=0) in A :
      1,63,92:A:=Ord(O=0);
      // Shorten '"' string-collecting, by pushing the entire string here (the opening quote was remembered in A) :
      2:repeat E;U(i)until i=A; // Note :  We stop at the closing character, so the next block will still handle 'i'!
      // These instructions all need to Pop A, so write it just once here :
      5,15,26,60:A:=O;
      // Shorten '?' (&gt;31): Choose a random direction instruction and let the 3rd case-block handle it :
      31:i:=Ord('&lt;&gt;^v'[1+Random(4)]);
      // Shorten 'g' (&gt;71) and 'p' (&gt;80): Calculate A so that the 3rd case-block doesn't need a begin+end pair :
      71,80:A:=X*O+O+1; // Note : This assumes Delphi evaluates leftmost call to O first!
      // Shorten '&amp;' by reading a number from the input into A :
      6:Read(A);
      // Shorten '!' Prevent begin+end for input retrieval, by reading the input into A here :
      94:Read(PChar(@A)^) // Note : This case is last, because it ends on ')', which avoids a closing ';'
    end;

    // Shorten ':' (&gt;58-32=26): Share implementation with '&amp;' (&gt;6) and '~' (&gt;94) by pushing first copy of A (read above) here
    if i=58then U(A);

    // This 3rd case-block contains the final code for all statements :
    case i-32of // Note : The instruction is decreased by 32, resulting in less digits in the cases below!
      //'0'..'9': Push this number on the stack
      16..25:U(i-48);
      //'+': Addition: Pop A then B, push A+B
      11:U(O+O); // Note : A and B are inverted, but order is irrelevant here
      //'-': Subtraction: Pop A then B, push B-A
      13:U(-O+O); // Note : Delphi evaluates left-to-right, so we need to reverse the operation
      //'*': Multiplication: Pop a then b, push a*b
      10:U(O*O); // Note : A and B are inverted, but order is irrelevant here
      //'/': Integer division: Pop A then B, push B/A, rounded down. If A is 0, result is undefined
      15:U(O div A); // if A=0then U(0)else U(O mod A);
      //'%': Modulo: Pop A then B, push the remainder of the integer division of B/A. If a is 0, result is undefined
       5:U(O mod A); // if A=0then U(0)else U(O mod A);
      //'`': Greater than: Pop A then B, push 1 if B&gt;A, otherwise 0.
      64:U(Ord(O&lt;O)); // Note : Delphi evaluates left-to-right, so we need to reverse the test
      //'&lt;': Start moving left
      //'&gt;': Start moving right
      28,30:d:=i-61;
      //'^': Start moving up
      62:d:=-X;
      //'v': Start moving down
      86:d:=X;
      //'_': Pop a value; move right if value=0, left otherwise
      63:d:=2*A-1; // Note : A is already determined as Ord(O=0) in 1st case block
      //'|': Pop a value; move down if value=0, up otherwise
      92:d:=2*A*X-X; // Note : A is already determined as Ord(O=0) in 1st case block
      //'"': Start string mode: push each character's ASCII value all the way up to the next "
      //'$': Pop value from the stack
      2,4:O;
      //'\': Swap two values on top of the stack
      60:s:=Chr(O)+Chr(A)+s; // Note : A was Popped in 1st case block
      //'.': Pop value and output as an integer
      14:Write(O,' ');
      //',': Pop value and output as ASCII character
      12:Write(Chr(O));
      //'#': Trampoline: Skip next cell
      3:E;
      //'p': A "put" call (a way to store a value for later use). Pop y then x then v, change the character at the position (x,y) in the program to the character with ASCII value v
      80:c[A]:=Chr(O); // Note : A was Popped in 1st and 2nd case block, calculating y*width+x
      //'g': A "get" call (a way to retrieve data in storage). Pop y then x, push ASCII value of the character at that position in the program
      71:U(Ord(c[A])); // Note : A was Popped in 1st and 2nd case block, calculating y*width+x
      //'@': Rotates the top 3 values on the stack clockwise, respectively. (eg. if your stack is 1,2,3,4, would result in 1,4,2,3)
      32:Exit;
      //'!': Logical NOT: Pop a value. If the value is 0, push 1; otherwise, push 0.
      //'&amp;':  Input a number from stdin and push its value
      //':': Duplicate value on top of the stack
      //'~':  Input a single character from stdin and push its ASCII value
      1,      // Note for '!' : A is already determined as Ord(O=0) in 1st case block
      6,
      26,     // Note for ':' : First A was already pushed once above
      94:U(A) // Note for '~' : Read() into A was done in 1st case block
    end;
  until 0=1;
end.
</code></pre>

<p>Output from compat.bf :</p>

<pre><code>OOB get returns 0
Cells are unsigned 8 bit
Edge jumps work
Negative remainders work
@ in stringmode works
</code></pre>

<p>Output from b93 :</p>

<pre><code>` works
: works
0-9 probably work
$ works
Westwards edge jump arrives at 79
0! is 1
5! is 0
</code></pre>

<p>Edit history:</p>

<p>(970-64=906) : Reimplemented movement, using 2 instead of 4 variables</p>

<p>(906-9=897) : Moved more calculations into 1st and 2nd case-blocks</p>

<p>(897-11=886) : Skip intermediate variable for all double-pop instructions</p>

<p>(886-6=880) : Read 1 input line extra to clear 's'tack</p>

<p>(880-14=866) : Simplified '?' by changing it into one of the 4 direction-instructions</p>

<p>(866-8=858) : Removed one case block</p>

<p>(858-13=845) : Fixed edge-jump, simplifying direction handling. Use 8 bit stack.</p>

<p>(845-3=842) : Combined left-right direction instruction into a single expression</p>
</div>
<div id="pu3" class="pu"><h2>16bit MSDOS .COM File - 1104 bytes</h2>

<p>This is Base64 encoded (<a href="http://www.motobit.com/util/base64-decoder-encoder.asp" rel="noreferrer">decoder here</a>), save decoded file as a .com and execute from command line with name of program file to run as the only argument. Tested in WinXP command prompt. </p>

<pre><code>yEAAADP/jNiAxBCJRv6JRvKAxBCJfuqJRuyJfvqJfviJfvSAxBCJRvbHRuiMAo7AM8C5AIDzq7Qs
zSGJVvC6RgWKHoAAMv+A6wF9Cei3ALQJzSHJw8aHggAAuAA9uoIAzSG6SAVy5YvYjkb+uQCAM8Dz
q7kBALpQBbQ/zSG6SgVyygvAdCWgUAU8CnQHPCBy4qrr34vHOkb5cgOIRvn+RviB5wD/gccAAevI
tD7NIQv/ukwFdJa4AwDNEDPb6FQAtAfNITxxdDk8cnQhPDF0DTwydBE8c3Xo6I8A6+CLRvaJRvLr
2ItG/olG8uvQi0b2iUby6B4A6HEAgH76AHTu67zoAgDJw7gAuI7AuCAHuQCA86vDYB6OXvK4ALiO
wLUZM/8z9rQHsVCsq/7JdfqBxrAA/s118FOLRvI7Rv6yz3QFi170svCA+1BzG4D/GXMWise0oPbk
ANiA1AAA2IDUAIv4R4rCqlsfYcOORv4migc8MHJVPDl3UbQALDDoKwD/ZugK23UDil75/svD/sM6
Xvl1+DLbwwr/dQOKfvj+z8P+xzp++HX4Mv/DBsR+6quJfuoHwwbEfuozwAv/dAmD7wImiwWJfuoH
w77uBIPGA4A8/3QOOAR19ItEAQvAdAP/4MO6TgXpZP7olP8migc8InSNtADos//r7+i4/4nB67To
9v8Dwel0/+ju/yvB6Wz/6Ob/9+npZP/o3v+Z9/npW//o1f+Z9/mLwulQ/+iF/wvAuAEAdAFI6UL/
6Lz/O8G4AQB/AUjpNP/HRuiMAukv/+hh/wvAdPHHRuiCAukg/+hS/wvAdAjHRuiWAukR/8dG6KAC
6Qn/i0bwuk189+IFGTaJRvAkBgWSA4vwrYlG6Ont/pYCoAKCAowC6Bf/6Ar/6dn+6FP/kegA/4nI
6c3+6AL/6cr+6Pz+C8B5CffYULAt6CYAWFO7UAUz0rkKAPfxgMIwiBdDC8B170uKB+gKAIH7UAV1
9Fvplf48CnQUBsR+9KqLxzxQdQSBx7AAiX70B8PGRvQA/kb1w+in/uja/+ls/uhp/ulm/ugOAOiV
/gaORv4miAQH6VX+6If+ik74C8B5BwLBgNQA6/X28YjhtQDocP5Rik75C8B5BwLBgNQA6/X28Yjg
WYjMi/DD6Mr/Bo5G/iaKBAe0AOkP/v928otG9olG8jP2Msnol/20B80hPC11CwrJdfH+wehc/+vq
PA11Do9G8ovGCsl0AvfY6dr9iMUsMDwJd9C0AFCwCvfmC9JadcT2xIB1vwHC9saAdbiJ1ojo6CH/
66//dvKLRvaJRvLoPf20B80hPCBy+FDoB/9YtACPRvLpkP3GRvoBwysAAy0IAyoQAy8YAyUhAyEs
A2A6Az5IAzxXA15mA3ZuAz92A19QA3xfAyLoAjqaA1yjAySvAy61AywKBCMTBHAZBGddBCZtBH7L
BEDsBCB/AgB/Av8xJDIkMyQ0JDUk
</code></pre>

<p>On startup, the display shows the program. Commands are:</p>

<ul>
<li>r - runs the program (switches to output screen)</li>
<li>s - single steps the program</li>
<li>q - quits the interpreter</li>
<li>1 - shows output screen (white cursor is current output position)</li>
<li>2 - shows program screen (red cursors is current program position)</li>
</ul>

<p>When an input command is executed, the display switches to the output screen. Input is echoed to the output screen. For ascii input, only characters in the range 32-255 are accepted. For numeric input, only values in the range -32768 to 32767 are allowed, press enter to complete input (sorry, no backspace).</p>

<p>I really should add a stack screen as well.</p>

<p><strong>Update</strong></p>

<p>Here's the original assembly source code, assembled using A86. It's quite long:</p>

<pre><code>  enter 64,0
  xor di,di
  mov ax,ds
  add ah,10h
  mov [bp-2],ax   ; program
  mov [bp-14],ax  ; current display
  add ah,10h
  mov w[bp-22],di ; stack off 
  mov [bp-20],ax  ; stack seg
  mov w[bp-6],di  ; exit status
  mov w[bp-8],di  ; size of field -8=lines,-7=columns
  mov w[bp-12],di ; output window position
  add ah,10h
  mov w[bp-10],ax; output segment
  mov w[bp-24],MoveRight

  ; clear output
  mov es,ax
  xor ax,ax
  mov cx,8000h
  rep stosw

  ; random seed
  mov ah,2ch
  int 21h
  mov w[bp-16],dx

  ; get filename
  mov dx,StrNoFile
  mov bl,[80h]
  xor bh,bh
  sub bl,1
  jge NoError

Error:
  call ClearScreen
  mov ah,9
  int 21h
  leave
  ret

NoError:  
  ; open file
  mov b[82h+bx],0
  mov ax,3d00h
  mov dx,82h
  int 21h
  mov dx,StrBadFile
  jc Error
  mov bx,ax
  ; clear program
  mov es,[bp-2]
  mov cx,8000h
  xor ax,ax
  rep stosw
  ; read file
ReadLoop:
  mov cx,1
  mov dx,EOP
  mov ah,3fh
  int 21h
  mov dx,StrBadRead
  jc Error
  or ax,ax
  jz EOF
  mov al,b[EOP]
  cmp al,10
  je EOL
  cmp al,32
  jb ReadLoop
  stosb
  jmp ReadLoop
EOL:
  mov ax,di
  cmp al,[bp-7]
  jb l9
  mov [bp-7],al
l9:
  inc b[bp-8]
  and di,0ff00h  
  add di,100h
  jmp ReadLoop
EOF:
  mov ah,3eh
  int 21h
  or di,di
  mov dx,StrEmptyFile
  jz Error
  ; initialise
  mov ax,3
  int 10h
  xor bx,bx ; PC
  ; execute
Redraw:  
  call DisplayProgram
WaitForInput:  
  mov ah,7
  int 21h
  cmp al,'q'
  je Quit
  cmp al,'r'
  je DoRun
  cmp al,'1'
  je ShowIO
  cmp al,'2'
  je ShowProgram
  cmp al,'s'
  jne WaitForInput
  ; single step
  call Execute
  jmp Redraw

ShowIO:
  mov ax,[bp-10]
  mov [bp-14],ax
  jmp Redraw  

ShowProgram:
  mov ax,[bp-2]
  mov [bp-14],ax
  jmp Redraw

DoRun:
  mov ax,[bp-10]
  mov [bp-14],ax
  call DisplayProgram
  call Execute
  cmp b[bp-6],0
  je DoRun
  jmp Redraw

Quit:
  call ClearScreen
  leave
  ret

ClearScreen:
  mov ax,0b800h
  mov es,ax
  mov ax,720h  
  mov cx,8000h
  rep stosw
  ret

DisplayProgram:
  pusha
  push ds
  mov ds,[bp-14]
  mov ax,0b800h
  mov es,ax
  mov ch,25
  xor di,di
  xor si,si
  mov ah,7
l1:
  mov cl,80
l2:
  lodsb
  stosw
  dec cl
  jnz l2
  add si,256-80
  dec ch
  jnz l1
  push bx
  mov ax,[bp-14]
  cmp ax,[bp-2]
  mov dl,0cfh
  je l33
  mov bx,[bp-12]
  mov dl,0f0h
l33:  
  cmp bl,80
  jae l3
  cmp bh,25
  jae l3
  mov al,bh
  mov ah,160
  mul ah
  add al,bl
  adc ah,0
  add al,bl
  adc ah,0
  mov di,ax
  inc di
  mov al,dl
  stosb
l3:  
  pop bx
  pop ds
  popa
  ret

Execute:
  mov es,[bp-2]
  mov al,es:[bx]

  cmp al,'0'
  jb NotPush
  cmp al,'9'
  ja NotPush

  ; push number
  mov ah,0
  sub al,'0'
PushValueUpdatePC:
  call PushValue
UpdatePC:
  jmp [bp-24]

MoveLeft:
  or bl,bl
  jnz MoveLeftNoWrap
  mov bl,[bp-7]
MoveLeftNoWrap:
  dec bl
  ret

MoveRight:
  inc bl
  cmp bl,[bp-7]
  jne ret
  xor bl,bl
  ret

MoveUp:
  or bh,bh
  jnz MoveUpNoWrap
  mov bh,[bp-8]
MoveUpNoWrap:
  dec bh
  ret

MoveDown:
  inc bh
  cmp bh,[bp-8]
  jne ret
  xor bh,bh
  ret

PushValue:
  push es
  les di,[bp-22]
  stosw
  mov [bp-22],di
  pop es
  ret

PopValue:
  push es
  les di,[bp-22]
  xor ax,ax
  or di,di
  jz PopValueZero
  sub di,2
  mov ax,es:[di]
  mov [bp-22],di
PopValueZero:
  pop es
  ret

NotPush:
  mov si,Functions-3
NextFunction:
  add si,3  
FindFunction:
  cmp b[si],255
  je Endsearch
  cmp b[si],al
  jne NextFunction
  mov ax,[si+1]
  or ax,ax
  je EndSearch
  jmp ax
  ret

EndSearch:
  mov dx,StrEndSearch
  jmp Error  

DoStringMode:
  call UpdatePC  
  mov al,es:[bx]
  cmp al,'"'
  je UpdatePC
  mov ah,0
  call PushValue
  jmp DoStringMode

PopTwoValues:
  call PopValue
  mov cx,ax
  jmp PopValue

DoAdd:
  call PopTwoValues
  add ax,cx
  jmp PushValueUpdatePC

DoSub:
  call PopTwoValues
  sub ax,cx
  jmp PushValueUpdatePC  

DoMultiply:
  call PopTwoValues
  imul cx
  jmp PushValueUpdatePC

DoDivide:
  call PopTwoValues
  cwd
  idiv cx
  jmp PushValueUpdatePC

DoModulo:
  call PopTwoValues
  cwd
  idiv cx
  mov ax,dx
  jmp PushValueUpdatePC

DoNot:
  call PopValue
  or ax,ax
  mov ax,1
  jz DoNotZero
  dec ax
DoNotZero:  
  jmp PushValueUpdatePC

DoGreaterThan:
  call PopTwoValues
  cmp ax,cx
  mov ax,1
  jg DoGreaterThanIs1
  dec ax
DoGreaterThanIs1:
  jmp PushValueUpdatePC  

DoMoveRight:
  mov [bp-24],MoveRight
  jmp UpdatePC

DoLeftRight:
  call PopValue
  or ax,ax
  jz DoMoveRight

DoMoveLeft:
  mov [bp-24],MoveLeft
  jmp UpdatePC

DoMoveUpDown:  
  call PopValue
  or ax,ax
  jz DoMoveDown

DoMoveUp:
  mov [bp-24],MoveUp
  jmp UpdatePC

DoMoveDown:
  mov [bp-24],MoveDown
  jmp UpdatePC

DoRandomDirection:
  mov ax,[bp-16]
  mov dx,31821
  mul dx
  add ax,13849
  mov [bp-16],ax
  and al,6
  add ax,Movements
  mov si,ax
  lodsw
  mov [bp-24],ax
  jmp UpdatePC    

Movements:
  dw MoveUp, MoveDown, MoveLeft, MoveRight  

DoDuplicate:
  call PopValue
  call PushValue
  jmp PushValueUpdatePC  

DoSwap:
  call PopTwoValues
  xchg ax,cx
  call PushValue
  mov ax,cx
  jmp PushValueUpdatePC  

DoPop:
  call PopValue
  jmp UpdatePC

DoPopPrint:
  call PopValue
  or ax,ax
  jns Positive
  neg ax
  push ax
  mov al,'-'
  call PrintChar
  pop ax  
Positive:  
  push bx
  mov bx,EOP
DivLoop:  
  xor dx,dx
  mov cx,10
  div cx
  add dl,'0'
  mov [bx],dl
  inc bx
  or ax,ax
  jnz DivLoop
PrintLoop:  
  dec bx
  mov al,[bx]
  call PrintChar
  cmp bx,EOP
  jne PrintLoop
  pop bx
  jmp UpdatePC

PrintChar:
  cmp al,10
  je AsciiCR
  push es
  les di,[bp-12]
  stosb
  mov ax,di
  cmp al,80
  jne NoLF
  add di,256-80
NoLF:
  mov [bp-12],di
  pop es
  ret
AsciiCR:
  mov b[bp-12],0
  inc b[bp-11]
  ret

DoPopAsciiPrint:  
  call PopValue
  call PrintChar
  jmp UpdatePC

DoTrampoline:
  call UpdatePC
  jmp UpdatePC

DoPut:
  call GetCoord
  call PopValue
  push es
  mov es,[bp-2]
  mov es:[si],al
  pop es
  jmp UpdatePC

GetCoord:
  call PopValue
  mov cl,[bp-8]
DoGet1:  
  or ax,ax
  jns DecrementY
  add al,cl
  adc ah,0
  jmp DoGet1
DecrementY:
  div cl
  mov cl,ah
  mov ch,0
  call PopValue ; x
  push cx
  mov cl,[bp-7]
DoGet2:  
  or ax,ax
  jns DecrementX
  add al,cl
  adc ah,0
  jmp DoGet2
DecrementX:
  div cl
  mov al,ah
  pop cx ; ax=x, cx=y
  mov ah,cl
  mov si,ax
  ret

DoGet:
  call GetCoord
  push es
  mov es,[bp-2]
  mov al,es:[si]
  pop es
  mov ah,0
  jmp PushValueUpdatePC

DoInput:
  push [bp-14]
  mov ax,[bp-10]
  mov [bp-14],ax
  xor si,si
  xor cl,cl
DoInput1:
  call DisplayProgram
  mov ah,7
  int 21h
  cmp al,'-'
  jne DoInputEnter
  or cl,cl
  jnz DoInput1
  inc cl
  call PrintChar
  jmp DoInput1

DoInputEnter:
  cmp al,13
  jnz DoInputDigit

  pop [bp-14]
  mov ax,si
  or cl,cl
  jz DoInput3
  neg ax
DoInput3:  
  jmp PushValueUpdatePC

DoInputDigit:
  mov ch,al
  sub al,'0'
  cmp al,9
  ja DoInput1
  mov ah,0
  push ax
  mov al,10
  mul si
  or dx,dx
  pop dx
  jnz DoInput1
  test ah,80h
  jnz DoInput1
  add dx,ax
  test dh,80h
  jnz DoInput1  
  mov si,dx
  mov al,ch
  call PrintChar
  jmp DoInput1  

DoInputAscii:
  push [bp-14]
  mov ax,[bp-10]
  mov [bp-14],ax
  call DisplayProgram
DoInputAscii1:
  mov ah,7
  int 21h
  cmp al,32
  jb DoInputAscii1
  push ax
  call PrintChar
  pop ax
  mov ah,0
  pop [bp-14]
  jmp PushValueUpdatePC

DoExit:
  mov b[bp-6],1
  ret  

Functions:
  db '+' ; Addition: Pop a then b, push a+b
  dw DoAdd
  db '-' ; Subtraction: Pop a then b, push b-a
  dw DoSub
  db '*' ; Multiplication: Pop a then b, push a*b
  dw DoMultiply
  db '/' ; Integer division: Pop a then b, push b/a, rounded down. If a is 0, result is undefined
  dw DoDivide
  db '%' ; Modulo: Pop a then b, push the remainder of the integer division of b/a. If a is 0, result is undefined
  dw DoModulo
  db '!' ; Logical NOT: Pop a value. If the value is 0, push 1; otherwise, push 0.
  dw DoNot
  db '`' ; Greater than: Pop a then b, push 1 if b&gt;a, otherwise 0.
  dw DoGreaterThan
  db '&gt;' ; Start moving right
  dw DoMoveRight
  db '&lt;' ; Start moving left
  dw DoMoveLeft
  db '^' ; Start moving up
  dw DoMoveUp
  db 'v' ; Start moving down
  dw DoMoveDown
  db '?' ; Start moving in a random cardinal direction
  dw DoRandomDirection
  db '_' ; Pop a value; move right if value=0, left otherwise
  dw DoLeftRight
  db '|' ; Pop a value; move down if value=0, up otherwise
  dw DoMoveUpDown
  db '"' ; Start string mode: push each character's ASCII value all the way up to the next "
  dw DoStringMode
  db ':' ; Duplicate value on top of the stack
  dw DoDuplicate
  db '\' ; Swap two values on top of the stack
  dw DoSwap
  db '$' ; Pop value from the stack
  dw DoPop
  db '.' ; Pop value and output as an integer
  dw DoPopPrint
  db ',' ; Pop value and output as ASCII character
  dw DoPopAsciiPrint
  db '#' ; Trampoline: Skip next cell
  dw DoTrampoline
  db 'p' ; A "put" call (a way to store a value for later use). Pop y then x then v, change the character at the position (x,y) in the program to the character with ASCII value v
  dw DoPut
  db 'g' ; A "get" call (a way to retrieve data in storage). Pop y then x, push ASCII value of the character at that position in the program
  dw DoGet
  db '&amp;' ; Input an integer (may be multiple characters and may be negative) and push it
  dw DoInput
  db '~' ; Input a single character from stdin and push its ASCII value
  dw DoInputAscii
  db '@' ; End program
  dw DoExit
  db ' ' ; NOP
  dw UpdatePC
  db 0 ; NOP
  dw UpdatePC
  db 255

StrNoFile:
  db "1$";"No File$"
StrBadFile:
  db "2$";"Bad File$"
StrBadRead:
  db "3$";"Bad Read$"
StrEmptyFile:
  db "4$";"Empty File$"
StrEndSearch:
  db "5$";"Bad Instruction$"
EOP:
</code></pre>
</div>
<div id="pu4" class="pu"><h2>Perl, 515 <s>525</s> <s>532</s></h2>

<p>Ok, so this might not be the most readable code I've ever written, but it does run all the examples in the reference implementation page properly, and use -1 as a <code>~</code>-didn't-have-a-reply value.  (the programs in the page exercise the empty stack behavior extensively)</p>

<p>As usual, Perl 5.10 or later.  In this instance, <code>-M5.010</code> is your best bet.  Newlines for presentation on CG.SE, you should remove them before trying.  (in this "edit 1.5" ragged-right version, it might actually work out of the box)</p>

<pre><code>@p=map[/./g],&lt;&gt;;$h=1;$_="for(;;){for(D_=P[Y][X]){
when('\"BS=!S}when(!!S){IordW0'||/\\d/){ID_W+BIO+
OW-BEO;IO-MW*BIO*OW/BEO;Iint(O/M)W%BEO;IO% MW!BI!
OW`BEO;I(M&lt;O)W?BD_=qw(&lt; &gt; ^ v)[rand 4]R_BD_=O?'&lt;'
:'&gt;'R|BD_=O?'^':'v'R&gt;BH=1;V=0W&lt;BH=-1;V=0W^BH=0;V
=-1WvBH=0;V=1W:BI0+S[-1]W\\\\BIO,OWDBOW.BsayOW,B
print chrOW#BFWpBEO;N=O;P[M][N]=chrOWgBEO;IordP[
M][O]W&amp;BIE&lt;&gt;W~BIord&lt;&gt;||-1WABexit}}F}";s/B/'){/g;
s/I/pushAs,/g;s/E/M=/g;s/F/X=(X+H)%A{P[0]};Y=(Y+
V)%Ap/g;s/O/(popAs)/g;s/R/;redoW/g;s/W/}when('/g
;y/DA/$@/;s/[A-Z]/\$\l$&amp;/g;eval
</code></pre>

<p>Improvements welcome :-D</p>

<p><em>Edit 1:</em> fix integer division (+2), reorganize (-9)</p>

<p><em>Edit <s>2</s> 1.5:</em> <s>read char by char (+4);</s> halt on division by zero (-10)</p>

<p>Still missing char by char input, I'm not clear yet how it parses numbers and I'm too tired to be able to do it now.</p>

<p>Not motivated enough to make the cell size unsigned 8-bit as suggested by the compatibility test, and not sure how negative remainders are expected in an unsigned environment.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/634/">634</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




