<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::277200</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>087</td><td>Python 2</td><td>241212T120359Z</td><td><a href="https://codegolf.stackexchange.com/questions/277200/longest-bitonic-subarray/277206#277206">tsh</a></td></tr>
<tr d-ix="1"><td>150</td><td>R</td><td>241213T024108Z</td><td><a href="https://codegolf.stackexchange.com/questions/277200/longest-bitonic-subarray/277223#277223">Eonema</a></td></tr>
<tr d-ix="2"><td>050</td><td>Charcoal</td><td>241212T171908Z</td><td><a href="https://codegolf.stackexchange.com/questions/277200/longest-bitonic-subarray/277212#277212">Neil</a></td></tr>
<tr d-ix="3"><td>101</td><td>JavaScript ES6</td><td>241212T170125Z</td><td><a href="https://codegolf.stackexchange.com/questions/277200/longest-bitonic-subarray/277210#277210">Arnauld</a></td></tr>
<tr d-ix="4"><td>015</td><td>05AB1E</td><td>241212T084928Z</td><td><a href="https://codegolf.stackexchange.com/questions/277200/longest-bitonic-subarray/277201#277201">Kevin Cr</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>, 87 bytes</h1>

<pre class="lang-none prettyprint-override"><code>def f(a,*p):i=iter(map(cmp,a[1:],a));return a*((-1in i)&gt;(1in i))or f(*p+(a[:-1],a[1:]))
</code></pre>
<p><a href="https://tio.run/##jVHBbsMgDL3nK3wDZ6QaTbNDJvIjWQ6oIxpSmyLCJu3rMwPJopw2IWSb955tbPcdPh7TeVnezQgj16J02Fplg/H8rh2/3p3QvWwHoRFfvQmffgJdcl5JO4HFjmeLD0/y0j1x3beVHLIIcQlmDlc9mxkUMMaKXg6gOiBT9JUUZyFFTfdCtxErlt@JUJOtCWtEnZhNjDPnAAwAlDiR/ynI9Ea8rMTn3Vv7O8KpmejHNDHRJSXLZ0Nkqnio@Qd92NomdK@bw6JvyK7/i9AeFjTJ0xy8dRxPs7vZwNnbxLAYaQ0BaCO/Y28LACvA0PjjPs2XvgkIm0h1DJEYztsp0AItglJgRHKXHw" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>
<p>Notice that this answer is in Python 2 instead of Python 3. They have several differences:</p>
<ul>
<li><code>cmp</code> is available in Python 2, but not in Python 3. Using <code>cmp</code>, it return <code>-1</code>, <code>0</code>, <code>1</code> based on its two operand. When both operand are <code>int</code>, it compare them, and return <code>-1</code> for less than, <code>1</code> for greater than. When one is <code>int</code> while the other is <code>None</code>, <code>None</code> is considered less than <code>int</code>.</li>
<li><code>map</code> is different in Python 2 and Python 3. Use <code>map(lambda *p:p, [2], [1, 2])</code> in Python 2, you will get <code>[(2, 1), (None, 2)]</code>. However, <code>list(map(lambda *p:p, [2], [1, 2]))</code> in Python 3 returns <code>[(2, 1)]</code>. Python 2 will padding extra <code>None</code>'s at end of the shorter one.</li>
<li>Then, <code>map(cmp, a[1:], a)</code> will return an array that compare each number with its next one, and always have an extra <code>-1</code> at the end of the return value. Since there is always a <code>-1</code>, an output is valid iff it contains no <code>1</code> after first <code>-1</code> occurred. Convert it to <code>iter</code> and <code>-1 in i</code> will consume the iter until first <code>-1</code> find (which will always be True as discussed above). And we try to find <code>1 in i</code>. Notice that here <code>i</code> is the part followed by <code>-1</code>, not the whole compare result. The array <code>a</code> is valid if no <code>1</code> found in the following part. So <code>1 in i</code> should be <code>False</code>. So <code>(-1 in i) &gt; (1 in i)</code> could be used to test if given array is valid.</li>
<li>If the given array is valid, <code>a*(...)(...)</code> returns <code>a</code>, and otherwise it return something falsy, and fallback to following searching. <code>f(*p+(a[:-1],a[1:]))</code> loop following possible substrings first by length, then by first occurrence. Sadly, you cannot use <code>f(*a,a[:-1],a[1:])</code> in Python 2, which is valid in Python 3.</li>
</ul>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.r-project.org" rel="nofollow noreferrer">R</a>, 150 bytes</h1>
<pre class="lang-r prettyprint-override"><code>\(x)`if`(length(x)-1,{y=rle(x)
p=rle(cumsum(c(T,diff(diff(y$v)&gt;0))&gt;0))
q=which.max(p$l)
r=cumsum(p$l)[q]+1
inverse.rle(lapply(y,`[`,(r-p$l[q]):r))},x)
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=jZBBTsMwEEXF1qewRBe26lQ1qRFCpKdgFyylCnETyalStymJENdgwyYseig4DWO7TQgbqmjiGc_7Mz_5-DTdUeGHAB_rvQruvt6fSEOTQiVEZ5v1Pocq4Oy1jYzOIEeVS9K63NUlSckjey6UIu7VTg50Oacu0DZ6yYs0n5WrhlQTTZGJTiJbxVs55ajYHDKzy2Z2ol5VlW5Jy5I4YcQEQAFE7w2lb6yh3t33Va1gKacUX-NoiWMukb0AhzeMsxBiASHYQPiWx0JIQyAECx0vbN2To57E2Em4k1wu60WC3Z7w-ZANvsfE2Z4t7Tw7ceGm-ufc4W773_3_KOSvDwFg5MHdeEBA6uz0QH8j_d_vOn_-AA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Two things I couldn't figure out (and would love if someone has ideas for):</p>
<ul>
<li>It failed for the first test case, so I added 20 bytes to handle the case where x is length 1. Is there a way to avoid having to handle this case specially?</li>
<li>It failed when there were repeated values at the end of the answer, which I solved by run-length encoding the input and converting back at the end. But converting back takes 27 bytes (on top of the 9 to encode). Is there a shorter way to un-encode it?</li>
</ul>
<p>Commented:</p>
<pre class="lang-r prettyprint-override"><code>\(x) `if`( # if statement to handle case where length(x) == 1
  length(x)-1, # F if length 1, T otherwise
  {
    # run-length encoding to avoid problems with repeated values
    y = rle(x) 
    # get lengths of bitonic stretches
    p = rle(
      # give a unique number to each potential bitonic stretch
      # i.e., increment group number whenever it starts increasing
      cumsum(c(T, diff(
        diff(y$v) &gt; 0
      )) &gt; 0)
    )
    # index of longest bitonic stretch in p
    q = which.max(p$l)
    # index of end of longest bitonic stretch in y
    r = cumsum(p$l)[q] + 1
    # inverse of run-length encoding
    inverse.rle(
      # lapply is needed to subset both the $length and $values of y
      lapply(y, `[`, 
        # indices of longest bitonic subarray in y
        (r-p$l[q]):r
      )
    )
  },
  x
)
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 50 bytes</h1>
<pre><code>≔⟦⟧θＦＡ«⊞θιＷ№⭆ＥΦθμ⁻λ§θμ⎇λ‹λ⁰ω10≔Φθμθ¿›ＬθＬυ≔⮌⮌θυ»⭆¹υ
</code></pre>
<p><a href="https://tio.run/##VU7LasMwEDzbXyFyWoEKcdOecgqFlEACoe3N@CDSjS1Q5FiPpKX029VdN32EQaw0MzuaXaf9rtc250UIpnVQN0oMcl7uey9g5Y4pgpTioyy2KXQwKGFILM6dsSjgoU8uwnP0xrUbfQQ@S2MjenYepBIb41IAq8Qirtwrvn3zkpQX9E77d9bWGEbPlOgza5NqOqFfL5WuE7lcYfYCHj1q5tfo2kjVJAeN1yT/lp/whD7g7xw4P1HGZ7ml2v/bVyzIec51PVMzdUvgeTfi/oIfpSLwmzxNk29O9gs" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Explanation:</p>
<pre><code>≔⟦⟧θＦＡ«
</code></pre>
<p>Start looping over the input values.</p>
<pre><code>⊞θι
</code></pre>
<p>Collect the next value.</p>
<pre><code>Ｗ№⭆ＥΦθμ⁻λ§θμ⎇λ‹λ⁰ω10
</code></pre>
<p>While the subarray contains a decreasing pair followed by an increasing pair...</p>
<pre><code>≔Φθμθ
</code></pre>
<p>... remove the first element from the subarray.</p>
<pre><code>¿›ＬθＬυ
</code></pre>
<p>If this subarray sets a new length record, then...</p>
<pre><code>≔⮌⮌θυ
</code></pre>
<p>... remember a clone of the subarray.</p>
<pre><code>»⭆¹υ
</code></pre>
<p>Pretty-print the first longest valid subarray.</p>
<p>Incorrect 55 byte version which allows both decreasing and increasing as well as increasing and decreasing, because I misread the question:</p>
<pre><code>≔⟦⟧θＦＡ«⊞θιＷ⬤⪪Ｉ⊕φ²№⭆ＥΦθξ⁻ν§θξ⎇ν‹ν⁰ωλ≔Φθμθ¿›ＬθＬυ≔⮌⮌θυ»⭆¹υ
</code></pre>
<p><a href="https://tio.run/##TU7LasMwEDzbX6HjClRokvaUkwmkBBIITW/GB@GsbYEi23okKaXfrq6ctA3DstLM7DB1J23dSx1j4ZxqDZSVYCNf5k1vGWzMEDxwzr7ybB9cB6NgisTs0imNDAqt4TBo5WElnSd7bfGExuMRGs4Fm9Os@mA8HLxVpt3JAdKslfZoU9qVHDtlggMjWOE35ojXG5/uP9AaaT@TtkU3eZ6JviRNk4PdS//nnfitfqYaBm8WZeK3aFpP5XmKmZ7h4fgdz2gd/u0xpQfK@M73VPqx@ywJfBljWS7EQswJab9MeL3jV5kR0p88VRWfzvoH" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Explanation: As above but allows either an increasing pair followed by a decreasing pair or a decreasing pair followed by an increasing pair but not both.</p>
</div>
<div id="pu3" class="pu"><h1>JavaScript (ES6), 101 bytes</h1>

<pre class="lang-none prettyprint-override"><code>a=&gt;(g=n=&gt;a.some((m,i)=&gt;!(b=a.slice(i,i+n)).some(p=v=&gt;(m=p&lt;m?m:p)&gt;p&amp;p&lt;(p=v)))/b[--n]?b:g(n))(a.length)
</code></pre>
<p><a href="https://tio.run/##lZHNboMwDIDvewp2mWItwDKaHaqGPkjFIbCUZSI/KlVfnzqkazW6tQUUKbHzfTbmWx5k3@y036fWfaphKwYpStIKK0qZ9c4oQgzVIMpnUguMdLpRRFP9agFi3osDEkb4lVmbpYfSv/hViAJAXm/S1FbretkSBIjMOmXb/RcMjbO961TWuZZsyYZVyYwHIMnzBKGniSZl9J0yWuBa4OL0pvekidCVq8BogRpOi1HKw7m64/qFXCnZqHxU@7CS04@T7O2yu6WcQH98esiEwqH0Yiwf358MGzuPvZ/7vAP8Mw68W8356WdoquMYjUOaobtAwxE" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 15 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>ŒRéR.ΔÔ¬š¥dÔJR!
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//6KSgwyuD9M5NOTzl0JqjCw8tTTk8xStI8f//aGMdIx1jHRMdUx0QyxBIA/mxAA" rel="nofollow noreferrer">(Don't) try it online</a> (it's too slow to even handle the example test case).<br />
<a href="https://tio.run/##yy9OTMpM/V9Waa@k8KhtkoKSfeX/o5OCDq8M0js35fCUQ2uOLjy0NOXwFK8gY71DixX/1@r8j442jNWJ1jXUMdIx1DEGYhMgNtUBCRoDxYyBfFMdY7CsKYgPFDcEi@OWM9Uxg4oaIFhg80BskD6QThOwbgiEyRiCTUK1B6gKyDYF0mCToOJGUJUQaAg2AeJ6CMSuzhyrOku4q4xjYwE" rel="nofollow noreferrer">Verify all test cases with a small addition of <code>3.£</code> to speed things up substantially.</a></p>
<p><strong>Explanation:</strong></p>

<pre class="lang-none prettyprint-override"><code>Œ               # Get all sub-lists of the (implicit) input-list
 R              # Reverse this list of sub-lists †
  é             # Then sort it from shortest to longest
   R            # Reverse that again so it's from longest to shortest
    .Δ          # Pop and find the first/longest sub-list that's truthy for:
      Ô         #  Connected-uniquify the sub-lists ††
       ¬š       #  Prepend its first item
                #  (edge case for inputs of length 1)
         ¥      #  Pop and get the forward-differences
          d     #  Check for each if they're non-negative (&gt;=0)
           Ô    #  Connected-uniquify this list of checks
            J   #  Join them together
             R  #  Reverse it
              ! #  Factorial †††
                #  (only 1 is truthy in 05AB1E, so this will only be truthy if the
                #  `ÔJR` was &quot;0&quot;, &quot;1&quot;, or &quot;01&quot; ††††, and falsey otherwise)
</code></pre>
<ul>
<li>† The <code>R</code> before the <code>éR</code> is to output the first instead of last longest bitonic sub-list if there are multiple valid ones of the same length.</li>
<li>†† The <code>Ô</code> is so we won't have any equal adjacent values for our checks, except for the one added by <code>¬š</code>.</li>
<li>††† <code>!</code> is the main bottleneck for why it's so slow, since the numbers can become very large for invalid sub-lists that go up and down a bunch of times. The <code>3.£</code> in the test suite link will only keep the last three digits after the <code>JR</code>, so we won't have to do the factorial on very large binary-strings.</li>
<li>†††† <code>0</code> are decreasing lists; <code>1</code> are increasing lists; <code>01</code> are first increasing and then decreasing lists.</li>
</ul>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/277200/">277200</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




