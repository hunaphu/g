<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::228937</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
  <!-- TXXX -->
<tr d-ix="0"><td>821</td><td>Python3</td><td>250201T024231Z</td><td><a href="https://codegolf.stackexchange.com/questions/228937/road-golf-through-the-mountains/278016#278016">Ajax1234</a></td></tr>
<tr d-ix="1"><td>052</td><td>05AB1E</td><td>210606T165810Z</td><td><a href="https://codegolf.stackexchange.com/questions/228937/road-golf-through-the-mountains/229136#229136">ovs</a></td></tr>
<tr d-ix="2"><td>029</td><td>Jelly</td><td>210607T203106Z</td><td><a href="https://codegolf.stackexchange.com/questions/228937/road-golf-through-the-mountains/229210#229210">caird co</a></td></tr>
<tr d-ix="3"><td>325</td><td>Python 3 + numpy</td><td>210607T173330Z</td><td><a href="https://codegolf.stackexchange.com/questions/228937/road-golf-through-the-mountains/229197#229197">ovs</a></td></tr>
<tr d-ix="4"><td>2984</td><td>Kotlin with JGraphT</td><td>210606T142252Z</td><td><a href="https://codegolf.stackexchange.com/questions/228937/road-golf-through-the-mountains/229128#229128">Hack5</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Python3, 821 bytes</h1>
<p>Long, but computes all test cases in &lt; 20 seconds on TIO.</p>
<pre class="lang-py prettyprint-override"><code>E=enumerate
def P(x,y,X,Y,D):
 q=[(x,y,[(x,y)])]
 for x,y,p in q:
  if(x,y)==(X,Y):return p
  for J,K in[(1,0),(0,1),(-1,0),(0,-1),(1,1),(-1,-1),(1,-1),(-1,1)]:
   if D.get(V:=(x+J,y+K),4)&lt;2 and V not in p:q+=[(*V,p+[V])]
def f(d):
 K=[[0]*(len(d[0])+2)]
 q,C=[(D:={(x,y):v for x,r in E(K+[[0]+i+[0]for i in d]+[*map(list,K)])for y,v in E(r)},[[i]for i in D if 1==D[i]])],{}
 while q:
  q=sorted(q,key=lambda x:sum(map(len,x[1])))
  D,M=q.pop(0)
  if len(M)==1:return len(M[0])-sum(D[i]==1 for i in D)
  for a,b in E(M):
   for A,B in E(M):
    if A&gt;a:
     Z=[]
     for t in b:
      for T in B:
       if(t,T)not in C:C[(t,T)]=P(*t,*T,D);C[(T,t)]=C[(t,T)]
       Z+=[(t,T)]
     L=C[min(Z,key=lambda x:len(C[x]))]
     Q,W=[],[]
     for J in M:
      if{*J}&amp;{*L}:Q+=J
      else:W+=[J]
     q+=[(D,[I:=[*{*Q,*L}]]+W)]
</code></pre>
<p><a href="https://tio.run/##bZNbb9owFICfl19h9WHYiakIvSqbJ7WhD4NmaiVEt3rRFBSzpoMkJKEDIX47O8dxgGoE5NjfuR@f5KvqJUvPrvNiu70TKl3MVBFVyorVhDzQJV/x7/wH7zHPInMhNdArC1lokUlWEEQ5SVIyBx2STLRUCAp2zCtUtShSkoMEdft8AJqSurzDOO1wF9Z2c2jjyW2YObXN0WUhugf/pHf6W1V05Am6dPp85QwYP2efuyRKYzIiaVZhMrk3dyBfe8RzR44wWaxoQmOsZCCk7IQ2naqUxrBjThermXMfTHqeWOsavDdTX4EO7@jAQSsncWBFQYI4Dh1pz6KcTpOy4gNoC4pW/K22KdiGS5ns9XtYgStEDyBkxdcbi/x9Saaqbt9clFlRqZjO@R@1EtNoNo4jsvTKxYzqKCrlS@mGjDHQ7vFAzE/zLKcdpntPsKIAuu82ndcAS2yjC4wKQrJPh5mbifi4zjhgus/IbvjtO4YBbr5E9Z48CxnWO9TVTR8bkSZDJLcNwcGo@JCZ6/E9X@pzKB6oXXF7CDP2CdiQV8AaYWP8jHd5QO5BY5ak9Pl9l7BYXy6hO0bvkT9Blvww0T6GD5q0ksna7m8@ru37jffoiL7Baloq7wmC9o2lHqYel189Ie21/cjBIAydJxZuS5cIcnJyYvnEt/Bddg8AIfA3/GzHgwadGxQEqBqgqBZc7ATmsQIffgSVAmJ@ekeaHT56Vz/Bga12ebkLT3Rivs6N1BnCWnOterWPbkFYa@fj2gi0na@Ng30Y34Q2bvCLq7Jf4ywqYlrCDH0wQynlukVaXoeTlt/yXHgFLa@7ka/6O3nFG0rC/ZBOkmmlCvotSxUn5WmZT5OKtn6mLbxny8qLJK0ojNculIufx/@4exyfHcfnx/HFcXx5HF8dx9eAt/8A" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E" rel="nofollow noreferrer">05AB1E</a>, <s>63</s> <s>54</s> 52 bytes</h1>
<p>Quite slow,  but after some optimisation, this can now run some testcases!</p>
<pre><code>2Føðδ.ø}©˜„ CSδQƶø0δK&lt;®øg‰`Uæé.ΔX«Dδ-nO3‹DvDδ*O}ßĀ}g
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/V9WqW59aKGek8uh3TqPmtYE/zdyO7zj8IZzW/QO76g9tPL0nEcN8xScg89tCTy27fAOg3NbvG0OrTu8I/1Rw4aE0MPLDq/UOzcl4tBql3NbdPP8jR817HQpA7K1/GsPzz/SUJv@X8nWTuHwfi4lnf/RSs4Kzko6CkDKF8Lw9XW2VlDwtQYKQLhAJlAISCvF/tfVzcvXzUmsqgQA" rel="nofollow noreferrer" title="05AB1E – Try It Online">Try it online!</a></p>
<p>The algorithm used has complexity <span class="math-container">\$\mathcal{O}\left(2^{(n+2)^2} (n+2)^6\right)\$</span> (for a grid of size <span class="math-container">\$n \times n\$</span>) and uses matrix multiplication (<code>øδ*O</code>), which is often incredibly slow in 05AB1E.</p>
<h3>How?</h3>
<p>A slightly different interpretation of the tasks helps explaining the approach: Instead of placing roads, we can also place additional cities into the grid until all cities are connected.<br />
The program tries all combinations of new cities in increasing order of new cities until it finds a valid solution.</p>
<p>To validate a given attempt we consider a graph where the vertices are cities and two cities are connected with an edge if they are vertically, horizontally or diagonally adjacent. Two cities are adjacent, iff their squared Euclidean distance is less than <span class="math-container">\$3\$</span>.<br />
This property can be used to calculate an adjacency matrix from a list of city coordinates. An undirected graph of <span class="math-container">\$n\$</span> vertices with adjacency matrix <span class="math-container">\$A\$</span> is connected, iff <span class="math-container">\$A^n\$</span> has no zeros. Example:</p>
<pre><code>map
 C
C C

city coordinates
[0,1], [1,0], [1,2]

pairwise squared Euclidean distances
0 2 2
2 0 4
2 4 0

adjacency matrix A
1 1 1
1 1 0
1 0 1

A^3
7 5 5
5 4 3
5 3 4

min(A^3) = 3 &gt; 0 =&gt; connected
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//0LJDK1y4lHITC7gO7@dS0uHiOrTt0EI9p0dNa4JdDq08PUfdOfBIo5aBt82hdYd3pD9q2OASyqWUnFlSqZCcn1@UkpmXWJJaDNRnqwTS7HJui26eP9DAgsTMovLM4lSF4sLSxKLUFAXX0uSczJTUxDyFlMziksS8ZLCuqPTiQ8uzDu3WAes2ftSwE6g3MSUrMTk1L7lSITexpCizQsERKAlTc2hlRLqN26F157Zo@de6cEWkKznGHd6PYVQ40E@ZeRqOcXmaCrYKIAX//yspKXE5OysoOHMpKEBIZ2cuoOB/Xd28fN2cxKpKAA" rel="nofollow noreferrer" title="05AB1E – Try It Online">Try your own example!</a></p>
<p><strong>Commented Code</strong>:</p>
<pre class="lang-python prettyprint-override"><code>                         # pad with spaces
2F     }                 # execute two times:
  ø                      #   transpose the grid
   ðδ.ø                  #   and surround every row with spaces


                         # get coordinates of cities and spaces
©                        # store the padded grid in the register
 ˜                       # flatten the grid
  „ CS                   # push [&quot; &quot;, &quot;C&quot;]
      δQ                 # equality table (== [[char==&quot; &quot;, char==&quot;C&quot;] for char in flat_grid])
        ƶ                # multiply each pair by its 1-based index
         ø               # tranpose
          0δK            # remove all zeros
             &lt;           # decrement by 1
                         # Now we have a two list of coordinates of spaces and cities in the flattened grid
              ®          # get the grid from the register
               øg        # get the height (length of the tranpose)
                 ‰       # divmod each flat index with this
                         # this results into the 2d-indices
                  `      # push cities and spaces seperately on the stack
                   U     # store coordinates of cities in variable X
                         # coordinates of spaces are now on top of the stack 

                         # try subsets of the spaces until we get a connected graph
æ                        # push the powerset (all subsets) of space coordinates
 é                       # sort by length
  .Δ                  }  # find the first value for which the following is truthy
    X«                   # append the existing cities to the current subset of spaces
      D                  # duplicate
       δ-                # subtraction table
         n               # square each difference
          O              # sum each pair of squared differences
           3‹            # for each number: is it less than 3?
                         # this is the adjacency matrix A
             D           # make a copy of the matrix
              v    }     # for each row in A:
               D         # duplicate current matrix
                δ*O      # matrix multiplication (for symmetric matrices)
                    ßĀ   # is the minimum not 0?

g                        # take the length of the result
</code></pre>
<hr />
<h1><a href="https://github.com/Adriandmen/05AB1E" rel="nofollow noreferrer">05AB1E</a>, 31 bytes</h1>
<p>Takes input as lists of 1-indexed coordinates of cities and mountains. Even less efficient if the input is not square.</p>
<pre><code>«Z&gt;ÝãsKæé.Δ¹«Dδ-nO3‹DvDδ*O}ßĀ}g
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//0Ooou8NzDy8u9j687PBKvXNTDu08tNrl3BbdPH/jRw07XcqAbC3/2sPzjzTUpv//Hx1tpKNgGKujAKKNY2O5oqMNoQJA2ghKG0MVgPnGUHljBB@o8b@ubl6@bk5iVSUA" rel="nofollow noreferrer" title="05AB1E – Try It Online">Try it online!</a></p>
<pre class="lang-python prettyprint-override"><code>«        # concatenate cities and mountains
 Z&gt;      # maximum integer in the list + 1 (0 and +1 for padding)
   Ý     # push range from 0 to this value
    ã    # cartesian square: all 2d coordinates with values in that range
     sK  # remove all cities and mountains, this leaves the coordinates of spaces
 ...     # same as above
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 29 bytes</h1>
<pre><code>;_þ`²§&lt;3æ*L$Ȧ
FṀ‘Żṗ2ḟẎŒPçƇḢḢL
</code></pre>
<p><a href="https://tio.run/##AV0Aov9qZWxsef//O1/DvmDCssKnPDPDpipMJMimCkbhuYDigJjFu@G5lzLhuJ/huo7FklDDp8aH4bii4biiTP/hu7Tigb5DTWnisa7isa7Fk@G6ueKxrjEsMsOH//9DTUM" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p>Uses <a href="https://codegolf.stackexchange.com/a/229197/66833">ovs' method</a>, be sure to give them an upvote!</p>
<p>Takes the input as a pair <code>[a, b]</code> where <code>a</code> is a list of 1 indexed co-ordinates of cities and <code>b</code> a list of 1 indexed co-ordinates of mountains</p>
<p>This is <em>stupidly</em> slow. For an <span class="math-container">\$n \times m\$</span> matrix with <span class="math-container">\$x\$</span> spaces, this has a lower bound of <span class="math-container">\$O(2^{\max(n,m)^2-x})\$</span>, and that doesn't factor in the speed of Jelly's matrix power, which isn't fast. This doesn't finish on TIO for any valid input</p>
<h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 36 bytes</h1>
<pre><code>;’_þ`²§&lt;3æ*L$Ȧ
Ż€ZUƊ4¡µœẹ0ŒPçƇœẹ1$ḢL
</code></pre>
<p><a href="https://tio.run/##y0rNyan8/9/6UcPM@MP7Eg5tOrTcxvjwMi0flRPLuI7uftS0Jir0WJfJoYWHth6d/HDXToOjkwIOLz/WDuYYqjzcscjn/8PdWx417nP2zXy0cR0QHW7//9/Z1xkA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p>Also <em>incredibly</em> slow. For an input of size <span class="math-container">\$n\times m\$</span> with <span class="math-container">\$x\$</span> spaces, this has an absolute lower bound of <span class="math-container">\$O(2^{2(n+m)+x})\$</span>, and that doesn't factor in the speed of Jelly's matrix power, or the fact that it has to calculate <span class="math-container">\$2^{2(n+m)+x}\$</span> Cartesian products with the number of cities in the input.</p>
<p>There are various optimisations you can do if you know the input before hand. For example, <a href="https://tio.run/##y0rNyan8/9/6UcPM@MP7Eg5tOrTcxvjwMi0flRPLuI7uftS0Jir0WJfRoYUPd047tPXo5Ie7dhocnRTwcEfX4eXH2sF8Q5WHOxb5/H@4e8ujxn3OvpmPNq4DosPt//8rgACXs4KvgjMA" rel="nofollow noreferrer">this</a> is a much faster version that works for inputs that can be constructed as going over the &quot;top&quot; of the mountains.</p>
<h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 34 bytes</h1>
<pre><code>;’_þ`²§&lt;3æ*L$Ȧ
Ż€ZUƊ4¡µœẹ0ŒPçƇŒṪḢL
</code></pre>
<p><a href="https://tio.run/##AVAAr/9qZWxsef//O@KAmV/DvmDCssKnPDPDpipMJMimCsW74oKsWlXGijTCocK1xZPhurkwxZJQw6fGh8WS4bmq4biiTP///1tbMSwgW10sIDFdXQ" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p>Exactly the same as the 36 byte version, but takes input as a matrix where <code>0</code> is a space, <code>1</code> is a city and <code>[]</code> is a mountain. For example, <code>C M C</code> is <code>[[1, 0, [], 0, 1]]</code></p>
<h2>How they work</h2>
<pre><code>;_þ`²§&lt;3æ*L$Ȧ - Helper link. Takes S (indices of spaces) and C (indices of cities)
;             - Concatenate
 _þ`          - Create a subtraction table
    ²         - Square each
     §        - Sums of each
      &lt;3      - Less than 3?
           $  - To this square matrix M:
          L   -   Get its length
        æ*    -   Raise it to that power
            Ȧ - Are all elements of the matrix non-zero?

FṀ‘Żṗ2ḟẎŒPçƇḢḢL - Main link. Takes [a, b] on the left
F               - Flatten
 Ṁ              - Maximum
  ‘             - Increment
   Ż            - Range from zero
    ṗ2          - Cartesian square
                   This gets all possible coordinates, including an outer border
       Ẏ        - Flatten the argument into a list of coords
      ḟ         - Remove the mountain + city coords from the list
        ŒP      - Powerset
            Ḣ   - Extract the list of city coords
          çƇ    - Keep the powerset elements that are truthy under the helper link
             ḢL - Take the shortest one and return its length
</code></pre>
<p>
<pre><code>;’_þ`²§&lt;3æ*L$Ȧ - Helper link. Takes S (indices of spaces) and C (indices of cities)
;              - Concatenate
 ’             - Decrement to zero index
  _þ`          - Create a subtraction table
     ²         - Square each
      §        - Sums of each
       &lt;3      - Less than 3?
            $  - To this square matrix M:
           L   -   Get its length
         æ*    -   Raise it to that power
             Ȧ - Are all elements of the matrix non-zero?

Ż€ZUƊ4¡µœẹ0ŒPçƇœẹ1$ḢL - Main link. Takes matrix M on the left
    Ɗ4¡               - Do the following 4 times:
Ż€                    -   Prepend a zero to each row
  Z                   -   Transpose
   U                  -   Reverse
       µ              - Begin a new link with this bordered matrix M' as the argument
        œẹ0           - Get the indices of zeros
           ŒP         - Powerset
                  $   - To M':
               œẹ1    -   Get the indices of ones
             çƇ       - Keep the powerset elements that are truthy under the helper link
                   ḢL - Take the shortest one and return its length
</code></pre>
<p>The third one takes advantage of the fact <code>[]</code> is both falsey and non-zero, and replaces <code>œẹ1$</code> with <code>ŒṪ</code> which gets the indices of all truthy elements in <code>M'</code></p>
</div>
<div id="pu3" class="pu"><h1><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python 3</a> + <a href="https://numpy.org/doc/stable/" rel="nofollow noreferrer">numpy</a>, 325 bytes</h1>
<p>A (slightly faster) port of my 05AB1E solution. The computational complexity is still the same, but especially the matrix operations are faster.</p>

<pre class="lang-python prettyprint-override"><code>from itertools import*
from numpy import*
def f(G):
 E=enumerate;k=[' '];p,c,*s=[k*len(G[0])],[]
 for y,r in E([k+r+k for r in p+G+p]):
  for x,v in E(r):[s,p,p,c][ord(v)%4]+=[y,x],
 for i in count():
  for N in combinations(s,i):
   v=array(c+[*N]);A=sum((v-v[:,None])**2,axis=2)&lt;3
   for _ in v:A=A@A
   if A.min():return i
</code></pre>
<p><a href="https://tio.run/##PZDRboMgFIbvfYpzswiKTdPtyo5kxjS9si9AyeIUN6ICATT16Z3YpOEC@M7//4eDWfyfVu/r2lk9gvTCeq0HB3I02vok2rGaRrO8UCs66NAV5xFcqNhqwtZenHvKYoj52ZCGJI6yPhmEQld25JgTxiPotIWFWJAKLoj1qU37ne3EpNfU8JC5sweZnzqLc@aI2VbDmbYtmvHbB08pW8iDk2eoDNJGT8qjV8DtycYfqWovtXLIEblXYaa1tfWCmpQlN47PBXXTiNCczSwnN60Ex0lyIvVDOnrCn@/BEyK/Q@ScF7T4KgKTHRSHUaqtqRV@sgrkGnReOB@k2mzzH/HBirpF@ODMID2K7yrLsruK97f8WtkCBTZI59EglcB7p3AKCSHp6QvEIbz9Ihgrt0E7FLwYryWU0ZYYVVUVlVW57@FeQvWqlJutCuQf" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
<p>Ungolfed full program:</p>

<pre class="lang-python prettyprint-override"><code>import itertools, sys
import numpy as np

grid = [list(line) for line in sys.stdin.read().splitlines()]
print(grid)
width = len(grid[0])

# pad with spaces on all sides
padding = [[' '] * width]
grid = [[' ', *row, ' '] for row in padding + grid + padding]

# get the coordinates of cities and empty spaces
cities = [[y, x] for y, row in enumerate(grid) for x, v in enumerate(row) if 'C' == v]
spaces = [[y, x] for y, row in enumerate(grid) for x, v in enumerate(row) if ' ' == v]

for i in range(len(spaces)):
  # Iterate over all combinations of i new cities
  for new_cities in itertools.combinations(spaces, i):
    vertices = np.array([*cities, *new_cities])
    adjacency = (np.sum((vertices - vertices[:, None])**2, axis=-1)&lt;3)
    if (np.linalg.matrix_power(adjacency, adjacency.shape[0]) &gt; 0).all():
      print(i)
      exit()
</code></pre>
<p><a href="https://tio.run/##rZJNbtswEIX3PMUDsjDpKELa7II6G6@ycC9gCAFr0fIUEkmQjG2d3h1KtNLuuxI5P98bPo0f08nZl9uNBu9CAiUTknN9rBDHKErUfg5@hI6wXoguUIsN9j3FJHuyRuHoAvIJZHNbHVNLtg5Gt1LV0feUcjZK1QgfyCaZGUpcqE0nRvXGTpH9c6OEeIDXLS7Eqej1wUQ4C933iNSaKDjJ8C5PsF9h1WCNidMsg@VwhXVwlwpTRR6Pb3m6e/cjpurHe6DJup1JSCeDg3OBgzpl7SMOlIhP2rYwg09jGUuUeFYcK1xnHT4VKcOumcCQ@bVT9lrh/G@OixXoiNV2hc0G50aUR/8nLO5YkQspVwVtOyOz6bOUUq8CeMB7mnrhziZMhh/c8CvbQM5ORhCsuRQ7uCMDOfBRfGDysj31361FpgJNQgDzE81vtL7WIehR7tczhn/cF5PXIdfr9jcD7GHkBskd8XOQcoE8Lbz9a4WfzppGrdffK@grxc3TN/XjZcawHbmbV1H3XT3oFOj64d3FBLkoVF9idTxpb/JO4g3PqmZHZHkAMK8xqXI1V0pS3W673U5sd1vB3z8" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
</div>
<div id="pu4" class="pu"><h1><a href="https://kotlinlang.org" rel="noreferrer">Kotlin</a> with <a href="https://jgrapht.org" rel="noreferrer">JGraphT</a>, <s>3009</s> 2984 (thanks to ophact) bytes (plus header/footer)</h1>
<pre class="lang-kotlin prettyprint-override"><code>import org.jgrapht.Graph
import org.jgrapht.GraphPath
import org.jgrapht.alg.connectivity.ConnectivityInspector
import org.jgrapht.alg.shortestpath.AllDirectedPaths
import org.jgrapht.alg.shortestpath.DijkstraManyToManyShortestPaths
import org.jgrapht.graph.DefaultDirectedGraph
import org.jgrapht.graph.DefaultEdge
import org.jgrapht.graph.DefaultUndirectedGraph
import org.jgrapht.graph.builder.GraphBuilder
import kotlin.streams.asStream

sealed class P
object C:P()
object M:P()
object E:P()
object R:P()
typealias D=Pair&lt;Int,Int&gt;
typealias L&lt;T&gt; =List&lt;T&gt;
typealias A&lt;T&gt; =Array&lt;T&gt;
typealias F=DefaultEdge
typealias G=BooleanArray
object H:ThreadLocal&lt;G&gt;(){override fun initialValue()=G(1 shl(B*2)){false}}
const val B=4
fun GraphPath&lt;D,F&gt;.v():A&lt;D&gt;{val r=arrayOfNulls&lt;D&gt;(edgeList.size+1)
r[0]=graph.getEdgeSource(edgeList.first())
edgeList.forEachIndexed{i,e-&gt;r[i+1]=graph.getEdgeTarget(e)}
return r as A&lt;D&gt;}
fun A&lt;GraphPath&lt;D,F&gt;&gt;.d()=sumOf{val table=if(B&lt;=3){G(1 shl(B*2)){false}}else{H.get().also{for(i in it.indices){it[i]=false}}}
it.v().sumOf{val hash=(it.first+1)or(it.second+1).shl(B)
if(table[hash]){0}else{table[hash]=true
1}.toInt()}}
fun j(b:GraphBuilder&lt;D,*,*&gt;,x:Int,y:Int){val others=(x-1..x+1).flatMap{z-&gt;(y-1..y+1).map{z to it}}
others.forEach{b.addEdge(x to y,it)}}
fun g(g:L&lt;L&lt;P&gt;&gt;):Pair&lt;Set&lt;D&gt;,Graph&lt;D,F&gt;&gt;{val b=DefaultDirectedGraph.createBuilder&lt;D,F&gt;(::DefaultEdge)
val c=mutableSetOf&lt;D&gt;()
g.forEachIndexed{y,r-&gt;r.forEachIndexed{x,p-&gt;when(p){C-&gt;{c+=x to y
j(b,x,y)}
E-&gt;j(b,x,y)
R-&gt;error(&quot;&quot;)}}}
val width=g[0].size
g.indices.forEach{y-&gt;if (g[y][0]==M)j(b,-1,y)
if (g[y].last()==M)j(b,width,y)}
(0 until width).forEach{x-&gt;if (g[0][x]==M)j(b,x,-1)
if (g.last()[x]==M)j(b,x,g.size)}
return c to b.buildAsUnmodifiable()}
fun t(c: Set&lt;D&gt;, g:Graph&lt;D,F&gt;):Set&lt;D&gt;{val d=DijkstraManyToManyShortestPaths(g).getManyToManyPaths(c,c)
val h=c.flatMap{o-&gt;c.map{o to it}}.filter{if(it.first.first==it.second.first)it.first.second&gt;it.second.second else it.first.first&gt;it.second.first}.associateWith{d.getPath(it.first,it.second)}.map{it.key to AllDirectedPaths(g).getAllPaths(it.key.first,it.key.second,true,it.value.length)}
val j=h.map{it.first}
val k=h.map{it.second}
val l=k.s{val m=DefaultUndirectedGraph.createBuilder&lt;D,F&gt;(::DefaultEdge)
m.addVertices(*c.toTypedArray())
it.mapIndexed{i,b-&gt;if(b)j[i]else null}.filterNotNull().forEach{m.addEdge(it.first,it.second)}
ConnectivityInspector(m.buildAsUnmodifiable()).isConnected}
return HashSet(l.asStream().parallel().map{it to it.d()}.min{n,o-&gt;n.second-o.second}.get().first.flatMap{it.v().asList()})}
fun a(a:String)=a.lines().map{it.map{when(it){'M'-&gt;M
'.',' '-&gt;E
'C'-&gt;C
'R'-&gt;R
else-&gt;null}}.filterNotNull()}.filter{it.isNotEmpty()}
fun l(data:L&lt;L&lt;P&gt;&gt;, route:Set&lt;D&gt;)=route.sumOf{if(it.second&lt;0||it.second&gt;data.lastIndex)return@sumOf 1
val row=data[it.second]
if(it.first&lt;0||it.first&gt;row.lastIndex)return@sumOf 1
if(row[it.first]==E)1.toInt()else 0}
inline fun&lt;reified T&gt;L&lt;L&lt;T&gt;&gt;.s(noinline test:(A&lt;Boolean&gt;)-&gt;Boolean)=List(size){listOf(false,true)}.c().filter(test).let{sequence{for(selection in it){yieldAll(filterIndexed { i, _-&gt;selection[i]}.c())}}}
inline fun &lt;reified T&gt;L&lt;L&lt;T&gt;&gt;.c()=sequence{if(isEmpty())return@sequence
val j=map{it.iterator()}.toTypedArray()
val v=j.map{it.next()}.toTypedArray()
yield(v.clone())
while(true){var i=0
while(!j[i].hasNext()){j[i]=get(i).iterator()
v[i]=j[i].next()
if(++i&gt;lastIndex)return@sequence}
v[i]=j[i].next()
yield(v.clone())}}

fun main() {
    val art = System.`in`.bufferedReader().readText()
    val data = a(art)
    val (cities, graph) = g(data)
    val route = t(cities, graph)
    println(&quot;Length: ${l(data, route)}&quot;)
}
</code></pre>
<p>Here is the original, prior to golfing:</p>
<pre class="lang-kotlin prettyprint-override"><code>import org.jgrapht.Graph
import org.jgrapht.GraphPath
import org.jgrapht.alg.connectivity.ConnectivityInspector
import org.jgrapht.alg.shortestpath.AllDirectedPaths
import org.jgrapht.alg.shortestpath.DijkstraManyToManyShortestPaths
import org.jgrapht.graph.DefaultDirectedGraph
import org.jgrapht.graph.DefaultEdge
import org.jgrapht.graph.DefaultUndirectedGraph
import org.jgrapht.graph.builder.GraphBuilder
import java.util.concurrent.atomic.AtomicLong
import kotlin.concurrent.thread
import kotlin.streams.asStream

sealed class Place
object City : Place()
object Mountain : Place()
object Empty : Place()
object Road : Place()

typealias Coord = Pair&lt;Int, Int&gt;

operator fun Coord.compareTo(other: Coord): Int {
    return first.compareTo(other.first).let {
        if (it == 0)
            second.compareTo(other.second)
        else
            it
    }
}

fun &lt;T&gt; Collection&lt;T&gt;.toHashSet() = HashSet(this)

object HashTable : ThreadLocal&lt;BooleanArray&gt;() {
    override fun initialValue(): BooleanArray {
        return BooleanArray(1 shl (MAX_DIMEN_BITS * 2)) { false }
    }
}

const val MAX_DIMEN_BITS = 4

inline fun &lt;reified V, E&gt; GraphPath&lt;V, E&gt;.getVertexListFast(): Array&lt;V&gt; {
    val ret = Array&lt;V?&gt;(edgeList.size + 1) { null }
    ret[0] = graph.getEdgeSource(edgeList.first())
    edgeList.forEachIndexed { i, edge -&gt;
        ret[i + 1] = graph.getEdgeTarget(edge)
    }
    @Suppress(&quot;UNCHECKED_CAST&quot;)
    return ret as Array&lt;V&gt;
}

fun Array&lt;GraphPath&lt;Coord, DefaultEdge&gt;&gt;.distinctSize() = sumOf { path -&gt;
    val table = if (MAX_DIMEN_BITS &lt;= 3) {
        BooleanArray(1 shl (MAX_DIMEN_BITS * 2)) { false }
    } else {
        HashTable.get().also {
            for (i in it.indices) {
                it[i] = false
            }
        }
    }
    path.getVertexListFast().sumOf {
        val hash = (it.first + 1) or (it.second + 1).shl(MAX_DIMEN_BITS)
        if (table[hash]) {
            0
        } else {
            table[hash] = true
            1
        }.toInt() /* stupid overload resolution */
    }
}

fun joinUp(builder: GraphBuilder&lt;Coord, *, *&gt;, x: Int, y: Int) {
    val others = (x - 1 .. x + 1).flatMap { otherX -&gt; (y - 1 .. y + 1).map { otherY -&gt; otherX to otherY } }
    others.forEach {
        builder.addEdge(x to y, it)
    }
}

fun createGraph(grid: List&lt;List&lt;Place&gt;&gt;): Pair&lt;Set&lt;Coord&gt;, Graph&lt;Coord, DefaultEdge&gt;&gt; {
    val builder = DefaultDirectedGraph.createBuilder&lt;Coord, DefaultEdge&gt; { DefaultEdge() }
    val cities = mutableSetOf&lt;Coord&gt;()
    grid.forEachIndexed { y, row -&gt;
        row.forEachIndexed { x, place -&gt;
            when (place) {
                City -&gt; {
                    cities += x to y
                    joinUp(builder, x, y)
                }
                Mountain -&gt; {
                }
                Empty -&gt; joinUp(builder, x, y)
                Road -&gt; error(&quot;Cannot pre-supply Roads&quot;)
            }
        }
    }
    val width = grid.first().size
    grid.indices.forEach { y -&gt;
        if (grid[y].first() == Mountain)
            joinUp(builder, -1, y)
        if (grid[y].last() == Mountain)
            joinUp(builder, width, y)
    }
    (0 until width).forEach { x -&gt;
        if (grid.first()[x] == Mountain)
            joinUp(builder, x, -1)
        if (grid.last()[x] == Mountain)
            joinUp(builder, x, grid.size)
    }
    return cities to builder.buildAsUnmodifiable()
}

fun joinCities(cities: Set&lt;Coord&gt;, graph: Graph&lt;Coord, DefaultEdge&gt;): Set&lt;Coord&gt; {
    val allPathsAlgo = AllDirectedPaths(graph)
    val dijkstraAlgo = DijkstraManyToManyShortestPaths(graph)
    val shortestPaths = dijkstraAlgo.getManyToManyPaths(cities, cities)
    val sourceTargets = cities.flatMap { outer -&gt; cities.map { outer to it } }.filter { it.first &gt; it.second }
    val shortestLengths = sourceTargets.associateWith {
        shortestPaths.getPath(it.first, it.second)
    }
    val allShortestPathsWithKey = shortestLengths.map {
        it.key to allPathsAlgo.getAllPaths(it.key.first, it.key.second, true, it.value.length)
    }
    val allShortestPathsKeys = allShortestPathsWithKey.map { it.first }
    val allShortestPaths = allShortestPathsWithKey.map { it.second }
    val i = AtomicLong()
    val (total, allPathsProduct) = allShortestPaths.selectiveCartesianProduct { selection -&gt;
        val builder = DefaultUndirectedGraph.createBuilder&lt;Coord, DefaultEdge&gt; { DefaultEdge() }
        builder.addVertices(*cities.toTypedArray())
        selection.mapIndexed { i, bool -&gt; if (bool) allShortestPathsKeys[i] else null }.filterNotNull().forEach { builder.addEdge(it.first, it.second) }
        val selectionGraph = builder.buildAsUnmodifiable()
        ConnectivityInspector(selectionGraph).isConnected
    }
    val startTime = System.currentTimeMillis()
    val counterThread = thread(true) {
        try {
            while (true) {
                Thread.sleep(1000)
                val progress = i.getOpaque()
                val percent = (progress.toDouble() / total.toDouble()) * 100f
                print(&quot;Progress: $progress\t/ $total\t($percent%)\t(${System.currentTimeMillis() - startTime} ms)\r&quot;)
            }
        } catch (e: InterruptedException) {
            println()
        }
    }
    val ret = allPathsProduct
        .asStream()
        .parallel()
        .map { (it to it.distinctSize()).also { i.incrementAndGet() } }
        .min { left, right -&gt; left.second - right.second }.get().first.flatMap { it.getVertexListFast().asIterable() }.toHashSet()
    counterThread.interrupt()
    counterThread.join()
    return ret
}

fun artToData(art: String) = art.lines().map {
    it.map { char -&gt;
        when (char) {
            'M' -&gt; Mountain
            '.', ' ' -&gt; Empty
            'C' -&gt; City
            'R' -&gt; Road
            else -&gt; null
        }
    }.filterNotNull()
}.filter { it.isNotEmpty() }

fun plotRoute(data: List&lt;List&lt;Place&gt;&gt;, route: Set&lt;Coord&gt;): List&lt;List&lt;Place&gt;&gt; {
    val width = data[0].size
    val emptyLine = List&lt;Place&gt;(width + 2) { Empty }
    val newData = mutableListOf(emptyLine.toMutableList(), *data.map { mutableListOf(Empty, *it.toTypedArray(), Empty) }.toTypedArray(), emptyLine.toMutableList())
    for (point in route) {
        if (newData[point.second + 1][point.first + 1] == Empty) {
            newData[point.second + 1][point.first + 1] = Road
        }
    }
    return newData
}

fun routeLength(data: List&lt;List&lt;Place&gt;&gt;, route: Set&lt;Coord&gt;): Int = route.sumOf { point -&gt;
    if (point.second &lt; 0 || point.second &gt; data.lastIndex) return@sumOf 1
    val row = data[point.second]
    if (point.first &lt; 0 || point.first &gt; row.lastIndex) return@sumOf 1
    if (row[point.first] == Empty) 1.toInt() /* needed due to overload ambiguity */ else 0
}

fun dataToArt(data: List&lt;List&lt;Place&gt;&gt;) = buildString {
    data.forEach { row -&gt;
        row.forEach { place -&gt;
            append(
                when (place) {
                    City -&gt; 'C'
                    Empty -&gt; '.'
                    Mountain -&gt; 'M'
                    Road -&gt; 'R'
                }
            )
        }
        append('\n')
    }
}

inline fun &lt;reified T&gt; List&lt;Collection&lt;T&gt;&gt;.selectiveCartesianProduct(noinline test: (Array&lt;Boolean&gt;) -&gt; Boolean): Pair&lt;Long, Sequence&lt;Array&lt;T&gt;&gt;&gt; {
    val selections = List(size) { listOf(false, true) }.cartesianProduct().filter(test)
    val total = selections.sumOf { selection -&gt;
        val selected = filterIndexed { i, _ -&gt; selection[i] }
        if (selected.isEmpty()) 0 else selected.fold(1L) { acc, value -&gt; acc * value.size }
    }
    return total to sequence {
        for (selection in selections) {
            yieldAll(filterIndexed { i, _ -&gt; selection[i] }.cartesianProduct())
        }
    }
}

inline fun &lt;reified T&gt; List&lt;Iterable&lt;T&gt;&gt;.cartesianProduct() = sequence {
    if (isEmpty()) return@sequence
    val iterators = map { it.iterator() }.toTypedArray()
    val values = iterators.map { it.next() }.toTypedArray()
    yield(values.clone())

    while (true) {
        var i = 0
        while (!iterators[i].hasNext()) {
            // reset current iterator, move on to check next one
            iterators[i] = get(i).iterator()
            values[i] = iterators[i].next()
            if (++i &gt; lastIndex)
                return@sequence
        }
        values[i] = iterators[i].next()
        yield(values.clone())
    }
}

fun main() {
    val art = System.`in`.bufferedReader().readText()
    val data = artToData(art)
    val (cities, graph) = createGraph(data)
    val route = joinCities(cities, graph)
    println(&quot;Length: ${routeLength(data, route)}&quot;)
    val newData = plotRoute(data, route)
    println(dataToArt(newData))
}
</code></pre>
<p>The algorithm is very intractable: with the sample with 6 cities, it takes ~300 minutes of CPU time on my high-end desktop</p>
<p>Note that if your input data is longer than 14 on any dimension, you have to increase MAX_DIMEN_BITS.</p>
<p>Input is sent to stdin followed by EOF (^D) as ASCII art.</p>
</div>
<!-- TYYY -->

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/228937/">228937</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




