<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::257998</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>088</td><td>tinylisp 2</td><td>230930T000040Z</td><td><a href="https://codegolf.stackexchange.com/questions/257998/recognize-a-counting-tree/265605#265605">DLosc</a></td></tr>
<tr d-ix="1"><td>147</td><td>Wolfram Language Mathematica</td><td>230324T080742Z</td><td><a href="https://codegolf.stackexchange.com/questions/257998/recognize-a-counting-tree/259421#259421">lesobrod</a></td></tr>
<tr d-ix="2"><td>013</td><td>Nekomata + e</td><td>230220T152646Z</td><td><a href="https://codegolf.stackexchange.com/questions/257998/recognize-a-counting-tree/258071#258071">alephalp</a></td></tr>
<tr d-ix="3"><td>065</td><td>Haskell</td><td>230220T124752Z</td><td><a href="https://codegolf.stackexchange.com/questions/257998/recognize-a-counting-tree/258065#258065">matteo_c</a></td></tr>
<tr d-ix="4"><td>064</td><td>JavaScript Node.js</td><td>230220T022001Z</td><td><a href="https://codegolf.stackexchange.com/questions/257998/recognize-a-counting-tree/258051#258051">tsh</a></td></tr>
<tr d-ix="5"><td>019</td><td>05AB1E</td><td>230220T094249Z</td><td><a href="https://codegolf.stackexchange.com/questions/257998/recognize-a-counting-tree/258060#258060">Kevin Cr</a></td></tr>
<tr d-ix="6"><td>023</td><td>Charcoal</td><td>230219T084522Z</td><td><a href="https://codegolf.stackexchange.com/questions/257998/recognize-a-counting-tree/258011#258011">Neil</a></td></tr>
<tr d-ix="7"><td>075</td><td>JavaScript ES6</td><td>230220T010245Z</td><td><a href="https://codegolf.stackexchange.com/questions/257998/recognize-a-counting-tree/258049#258049">Arnauld</a></td></tr>
<tr d-ix="8"><td>017</td><td>Vyxal</td><td>230219T113013Z</td><td><a href="https://codegolf.stackexchange.com/questions/257998/recognize-a-counting-tree/258020#258020">AndrovT</a></td></tr>
<tr d-ix="9"><td>061</td><td>Retina 0.8.2</td><td>230219T095019Z</td><td><a href="https://codegolf.stackexchange.com/questions/257998/recognize-a-counting-tree/258014#258014">Neil</a></td></tr>
<tr d-ix="10"><td>063</td><td>Python</td><td>230219T075103Z</td><td><a href="https://codegolf.stackexchange.com/questions/257998/recognize-a-counting-tree/258008#258008">loopy wa</a></td></tr>
<tr d-ix="11"><td>036</td><td>Curry PAKCS</td><td>230219T022813Z</td><td><a href="https://codegolf.stackexchange.com/questions/257998/recognize-a-counting-tree/258000#258000">alephalp</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/dloscutoff/tinylisp2" rel="nofollow noreferrer">tinylisp 2</a>, 88 bytes</h1>
<pre class="lang-lisp prettyprint-override"><code>(d F(\(L)(? L(*(&lt;(h L)(# L))(F(](h L)(t L)))(F([(h L)(t L))))1
(\(L)(*(F L)(=(h L)(#(t L
</code></pre>
<p>The submission is the anonymous function in the second line.</p>
<p>You can try it at <a href="https://replit.com/@dloscutoff/tinylisp2" rel="nofollow noreferrer">Replit</a>. Example session:</p>
<pre class="lang-lisp prettyprint-override"><code>tl2&gt; (d F(\(L)(? L(*(&lt;(h L)(# L))(F(](h L)(t L)))(F([(h L)(t L))))1
F
tl2&gt; (\(L)(*(F L)(=(h L)(#(t L
(() (L) (* (F L) (= (h L) (# (t L)))))
tl2&gt; (d G _)
G
tl2&gt; (G (list 5 2 1 0 1 0))
1
</code></pre>
<h3>Explanation</h3>
<p>Our recursive helper function, <code>F</code>, analyzes a list as follows:</p>
<ul>
<li>Is it empty? Return <code>1</code> (truthy).</li>
<li>Otherwise, split the list, conceptually, into head (first element) and tail (remaining elements).
<ul>
<li>Is the head greater than or equal to the list's total length? (This means the root of this subtree doesn't have enough children.) Return <code>0</code> (falsey).</li>
<li>Split the tail at the index given by the head. Recurse over each of these sublists. Return <code>1</code> if both results are <code>1</code>; otherwise return <code>0</code>.</li>
</ul>
</li>
</ul>
<pre class="lang-lisp prettyprint-override"><code>(d F(\(L)(? L ... 1)))
(d F                 ) ; Define F as
    (\(L)           )  ; Lambda function taking list L
         (? L      )   ; If L is nonempty
              ...      ; (see below)
                  1    ; Else, return 1

(*(&lt;(h L)(# L))(F(](h L)(t L)))(F([(h L)(t L))))
(*                                             ) ; Multiply these (logical AND):
  (&lt;(h L)(# L))                                  ; 1. Head of L &lt; length of L
               (F             )                  ; 2. Recursive call on:
                 (]          )                   ;    Take
                   (h L)                         ;    (head of L) elements
                        (t L)                    ;    from tail of L
                               (F             )  ; 3. Recursive call on:
                                 ([          )   ;    Drop
                                   (h L)         ;    (head of L) elements
                                        (t L)    ;    from tail of L
</code></pre>
<p><code>F</code> verifies that a list represents a &quot;forest&quot; of zero or more counting trees concatenated. Our main function also needs to verify that we have exactly one counting tree. To do so, we first call <code>F</code> on the list, and then check whether the head is exactly equal to the length of the tail.</p>
<pre class="lang-lisp prettyprint-override"><code>(\(L)(*(F L)(=(h L)(#(t L)))))
(\(L)                        ) ; Lambda function taking list L
     (*                     )  ; Multiply these (logical AND):
       (F L)                   ; 1. Call F on L
            (=             )   ; 2. These are equal:
              (h L)            ;    Head of L
                   (#(t L))    ;    Length of tail of L
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.wolfram.com/wolframscript/" rel="nofollow noreferrer">Wolfram Language (Mathematica)</a>, 147 bytes</h1>
<pre><code>(a=#;l=Length@a;And@@(IntervalMemberQ[#1,#2]||Length@IntervalIntersection[#1,#2]==0&amp;@@@Subsets[Interval@{#,#+a[[#]]}&amp;/@Range@l,{2}])&amp;&amp;a[[1]]==l-1)&amp;
</code></pre>
<p><a href="https://tio.run/##PYvLCoMwFET3/Y1AUHpLE/vYSOB2WWihj2XIItpgBE1B0240325FtMxiYM6ZWntrau3LXA9WDJEWJK3ExbjCW9Tpyb0Qo7Pzpvnq6mrqzDR3STiQRPX9rC146tbkvny72RGCUUR8frLW@FYuJnYEyFpLSZQKdIsP7QqDFXRJUDGlI@Bq/FYbHtPh1pTOo8XuAAnwMQxYWP3XIxxgD7uJsTD8AA" rel="nofollow noreferrer" title="Wolfram Language (Mathematica) – Try It Online">Try it online!</a></p>
<p>I was looking at the problem in terms of interval arithmetic, and it seems got  the same algorithm as @AndrovT. Unfortunately, Mathematica has almost no shorthands for cool functions, so code looks huge (</p>
<p>Explained:</p>
<pre>
(*Total logic And*)
And @@
 (*In True case intervals must be disjointed or nested*)
 (IntervalMemberQ[#1, #2] || 
     Length@IntervalIntersection[#1, #2] == 0 & @@@
   (*All subsets length 2*)
   Subsets[
    (*All intervals i + array[i]*)
    Interval@{#, # + a[[#]]} & /@ Range@l
    , {2}])
        (*Is first element equal length of the rest*)
        && a[[1]] == l - 1 &
</pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/AlephAlpha/Nekomata" rel="nofollow noreferrer">Nekomata</a> + <code>-e</code>, 13 bytes</h1>
<pre><code>qCᵉLR↔&lt;a*$h→L
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m70iLzU7PzexJHFNtJJurpKOgpJuqlLsgqWlJWm6FpsLnR9u7fQJetQ2xSZRSyXjUdsknyXFScnFUPkFN9dGm-oY6RhAYCwXmGeIwTOE8oyR5Mx0THVMgCJGUFkw1jHAMMsQiWeAxDNGMtkMzVaYPYZQfcZQOYirAQ" rel="nofollow noreferrer">Attempt This Online!</a></p>
<hr />
<p>Here is the original answer in an old version of Nekomata:</p>
<h2><a href="https://github.com/AlephAlpha/Nekomata/tree/07c871a41fe7a47b78da21b9fe1f06b1e5ded2c1" rel="nofollow noreferrer">Nekomata</a> + <code>-e</code>, 16 bytes</h2>
<pre><code>qCᵉLR↔$-ᵐP∀*$h→L
</code></pre>
<p>This is a new golfing language I'm working on. It's still in a very early stage of development.</p>
<p>I haven't made the first release, so the link above is to the latest commit.</p>
<p>This is a non-deterministic language inspired by <a href="https://curry.pages.ps.informatik.uni-kiel.de/curry-lang.org/" rel="nofollow noreferrer">Curry</a>, <a href="https://github.com/JCumin/Brachylog" rel="nofollow noreferrer">Brachylog</a> and other language. Functions in Nekomata may have multiple possible results, and the interpreter will choose the result via backtracking.</p>
<h2>Explanation</h2>
<p>A port of <a href="https://codegolf.stackexchange.com/a/258011/9288">@Neil's Charcoal answer</a>.</p>
<pre><code>qCᵉLR↔$-ᵐP∀*$h→L

                    # Take [5,2,0,0,0,0] as an example
                    # The stack is initialized with an infinite cycle of the input
q                   # Non-deterministically choose a contiguous subsequence of the input
                    # Take [2,0,0] as an example
                    # The stack is now ..., [5,2,0,0,0,0], [2,0,0]
 C                  # Uncons; pop a list and push the tail and the head
                    # The stack is now ..., [5,2,0,0,0,0], [0,0], 2
  ᵉL                # Check if the length of the tail is equal to the head
                    # The stack is still ..., [5,2,0,0,0,0], [0,0], 2 since the check passes
    R               # Range from 1 to n
                    # The stack is now ..., [5,2,0,0,0,0], [0,0], [1,2]
     ↔              # Reverse
                    # The stack is now ..., [5,2,0,0,0,0], [0,0], [2,1]
      $             # Swap
                    # The stack is now ..., [5,2,0,0,0,0], [2,1], [0,0]
       -            # Subtract
                    # The stack is now ..., [5,2,0,0,0,0], [2,1]
        ᵐP          # Check if all elements of the list are positive
                    # The stack is still ..., [5,2,0,0,0,0], [2,1] since the check passes
          ∀         # Find all possible results of a non-deterministic computation
                    # The stack is now ..., [5,2,0,0,0,0], [[3,4,3,2,1],[2,1],[],[],[],[]]
           *        # Multiply; this will fail if the two lists has different lengths
                    # The stack is now ..., [[15,20,15,10,5],[4,2],[],[],[],[]]
            $       # Swap
                    # Note that there are infinite many copies of the input on the stack
                    # The stack is now ..., [[15,20,15,10,5],[4,2],[],[],[],[]], [5,2,0,0,0,0]
             h      # Head of a list
                    # The stack is now ..., [[15,20,15,10,5],[4,2],[],[],[],[]], 5
              →     # Increment
                    # The stack is now ..., [[15,20,15,10,5],[4,2],[],[],[],[]], 6
               L    # Check if the length of the list is equal to the number
                    # The check passes, so there is a result
</code></pre>
<p>The flag <code>-e</code> set the interpreter to <code>CheckExistence</code> mode, which prints <code>True</code> if the computation has any result, and <code>False</code> otherwise. We don't care what the result really is.</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.haskell.org" rel="nofollow noreferrer">Haskell</a>, <s>85</s> 65 bytes</h1>
<p><em>-20 bytes thanks to <a href="https://codegolf.stackexchange.com/users/56656/wheat-wizard">@Wheat Wizard</a></em></p>
<pre class="lang-haskell prettyprint-override"><code>h(n:w)=f(n:take n w)&amp;&amp;h(drop n w)
h _=1&gt;0
f(n:w)=h w&amp;&amp;n==length w
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=jZG_CsIwEMZxzVPcIKWFKI3VIkIEFzc3wUGkBE1NscbSRAruPoWLi_hM-jQG459SKkjgjvvxcffl7nQVTG14mp7Pl72OW_3bSLhyUHg0NkmzDQcJhec4wl3lu-xZIAERJUMfxVYpoHAcSWnK5Vqbwja6N46aKx0tmeIKKAKYw7yHO9i3b2EItoTUElIiQUUT4h7uGtopqT4Z-7UzSIX4FRJUpoY1zt4-SKlP8NUsEGJSFTx_fXia7zn-GcYsVX9F03bLEgkUtiybRJDlidTQhEOSzRKzcdel1IM2xB6UVv5yYq_xPu8D" rel="nofollow noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu4" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 64 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>T=t=&gt;t.shift()!=t.length|C(t)
C=$=&gt;$&gt;C&amp;&amp;C($.splice($[0]+1))|T($)
</code></pre>
<p><a href="https://tio.run/##hY@9CoMwFIV336IQJJemIdHqFpe8gps4iI0/JSTShE6@e1oo7VKN3PE7H@eee/fsXP@YF38x9qbCIEItvKg8ddM8eAwn4alWZvTTKrGHRAokKlTJNJUYUbfouVcYNaw9c4C1xghCb42zWlFtRzzgpiAZYZ9rAZINyg8p36F5xC1JQa7vRLZl/6UZYYdf8ghlEZpHNpQH@78L@U5v/nPDCw" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<p>Code with comments:</p>
<pre class="lang-javascript prettyprint-override"><code>isTree = tree =&gt;
  tree[0] + 1 === tree.length &amp;&amp;
  isChildren(tree.slice(1))
isChildren = children =&gt;
  children.length === 0 ||
    isTree(children.slice(0, children[0] + 1)) &amp;&amp;
    isChildren(children.slice(children[0] + 1))
</code></pre>
<p>Changing <code>!=</code> into <code>-</code> makes it 64 bytes by returning truthy vs. falsy.</p>
<p><s>-1</s>-2 byte by l4m2.</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 19 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>ŒʒćsgQ}εāR‹}˜P*ćsgQ
</code></pre>
<p>Inspired by <a href="https://codegolf.stackexchange.com/a/258011/52210"><em>@Neil</em>'s top Charcoal</a>, which is a port of <a href="https://codegolf.stackexchange.com/a/258020/52210"><em>@AndrovT</em>'s Vyxal answer</a>.</p>
<p><a href="https://tio.run/##yy9OTMpM/f//6KRTk460F6cH1p7beqQx6FHDztrTcwK0wEL//0eb6RjpGOoYgGAsAA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/V9Waa@k8KhtkoKSfaXL/6OTTk060l6cHlh7buuRxqBHDTtrT88J0AIL/df5Hx1tqmOkYwCBsTpgniEGzxDKM0aSM9Mx1TEBihhBZYFYIdpAxwDDMEMkngESzxjJaDM0a2EWGUL1GUPlYgE" rel="nofollow noreferrer">verify all test cases</a>.</p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>Œ           # Get all sublists of the (implicit) input-list
 ʒ          # Filter it by:
  ć         #  Extract head; pop and push remainder-list and first item seperately
   s        #  Swap so the remainder-list is at the top of the stack
    g       #  Pop and push its length
     Q      #  Check if the length of the remainder-list and first item are equal
 }ε         # After the filter: map over each remaining sublist:
   ā        #  Push a list in the range [1,length] (without popping the list)
    R       #  Reverse it to [length,1]
     ‹      #  Element-wise less-than check: [a&lt;length,b&lt;length-1,...,y&lt;2,z&lt;1]
  }˜        # After the map: flatten the list of checks
    P       # Product to check if all were truthy
     *      # Multiply this 1/0 to each value in the (implicit) input-list
      ćsgQ  # Do a similar check as before within the filter on the input-list itself
            # (after which the result is output implicitly)
</code></pre>
<p>I've been unable to find anything shorter for <code>*ćsgQ</code> which works for both the <code>[0,0,0,0,0,0]</code> and <code>[6,2,1,0,0,0]</code> test cases. Checking whether the input-list is in the filtered list of sublists is an equal-bytes alternative:</p>
<pre class="lang-python prettyprint-override"><code>ŒéʒćsgQ}¤IÊªεāR‹}˜P
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//6KTDK09NOtJenB5Ye2iJ5@GuQ6vObT3SGPSoYWft6TkB//9Hm@kY6RjqGIBgLAA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/V9Waa@k8KhtkoKSfaXL/6OTDq88NelIe3F6YO2hJZWHuw6tOrf1SGPQo4adtafnBPzX@R8dbapjpGMAgbE6YJ4hBs8QyjNGkjPTMdUxAYoYQWWBWCHaQMcAwzBDJJ4BEs8YyWgzNGthFhlC9RlD5WIB" rel="nofollow noreferrer">verify all test cases</a>.</p>
<p><strong>Additional explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code> é          # Sort the sublists by length (shortest to longest)

  ¤         # Push the last sublist after the filter (without popping the list of lists)
   IÊ       # Check that it's NOT equals to the input-list
     ª      # Append this 0 or 1 to the list of sublists
            # (`āR‹` will succeed for 0 and fail for 1)
</code></pre>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, <s>28</s> 23 bytes</h1>
<pre><code>∧⁼§θ⁰⊖Ｌθ⬤θ⬤✂θ⁺ικκ±¹¬›λμ
</code></pre>
<p><a href="https://tio.run/##HYrBCsIwEER/JccNrNAKnjwFFBGkFDyWHkKytKHblKSp@PcxcWAYHm/MrKPZNOfcR@cTKG/hHg7NO6j09Ja@EFA0EsWNTKSVfCILL/JTmiFIWYRirp86b3aGKvR87OBQLMUvKDqadCJo673bEjwiFY7AKFb5zzXnYbjgGVtsascxnz78Aw" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Outputs a Charcoal boolean, i.e. <code>-</code> for a counting tree, nothing if not. Explanation: Based on @AndrovT's approach, the first element must be one less than the length, then given any element <code>e</code>, the next <code>e</code> elements must all be less than the sequence from <code>e</code> down to <code>1</code>, although the code actually extracts the elements in reverse so that within their slice they must not exceed their 0-based index.</p>
<pre><code>   θ                    Input array
  § ⁰                   First element
 ⁼                      Equals
       θ                Input array
      Ｌ                 Length
     ⊖                  Decremented
∧                       Logical And
         θ              Input array
        ⬤               All elements satisfy
            θ           Input array
           ✂            Sliced from
              ι         Current value
             ⁺          Plus
               κ        Current index
                κ       To current index
                 ±¹     In reverse
          ⬤             All elements satisfy
                     λ  Inner value
                   ¬›   Is not greater than
                      μ Inner index
                        Implicitly print
</code></pre>
<p>Example: For the input <code>[5,2,1,0,1,0]</code>, the length is <code>6</code> so the first element must be <code>5</code>, then the subsequent <code>5</code> elements must be less than <code>5,4,3,2,1</code>; the <code>2</code> elements after the <code>2</code> must be less than <code>2,1</code> and the <code>1</code> element after each <code>1</code> must be less than <code>1</code>. (Trivially the <code>0</code> elements after each <code>0</code> satisfy the property as well.)</p>
<p>Previous 28-byte approach:</p>
<pre><code>Ｆθ«⊞υιＷ∧υ¬↨υ⁰≧⁻¬⊟υυ¬υ»¿∨υ⊖ⅈ⎚
</code></pre>
<p><a href="https://tio.run/##JYw9C8IwFEXn5ldkfIEIVXDqVO1aLU5C6RDatHkQk5oPHcTfHhu8cOFyuJxRCTdaoVOaraPwZPRDii56BZFTZBUp3gq1pFCbKaOLDXASXuZdsi20FWvtPS7mhosK0KKJ/v/r7AqRMU5j9nQOTYDMN1aRL8GZwtVlUSNHJx/SBDnBHbL0rKVwwKqU@v7ID3zPy9xhSLuX/gE" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Outputs a Charcoal boolean, i.e. <code>-</code> for a counting tree, nothing if not. Explanation:</p>
<pre><code>Ｆθ«
</code></pre>
<p>Loop over the input integers.</p>
<pre><code>⊞υι
</code></pre>
<p>Push them to the predefined empty list.</p>
<pre><code>Ｗ∧υ¬↨υ⁰
</code></pre>
<p>While the list ends in <code>0</code>...</p>
<pre><code>≧⁻¬⊟υυ
</code></pre>
<p>... remove the trailing <code>0</code> and decrement the remaining elements.</p>
<pre><code>¬υ
</code></pre>
<p>Count the number of counting trees found.</p>
<pre><code>»¿∨υ⊖ⅈ⎚
</code></pre>
<p>Check that there was exactly one counting tree and that it ended with the last element.</p>
</div>
<div id="pu7" class="pu"><h1>JavaScript (ES6), 75 bytes</h1>
<p>Returns <span class="math-container">\$0\$</span> for valid, or <span class="math-container">\$1\$</span> for invalid.</p>

<pre class="lang-javascript prettyprint-override"><code>f=([v,...a],s=v)=&gt;v+1&amp;&amp;a.length!=s|f(a.slice(v=a[0]),s-++v)|f(a.slice(0,v))
</code></pre>
<p><a href="https://tio.run/##hZCxDoIwGIR338IF2vDTtCBsdfcFXGqHBgpimmIs6eS7V6PRYGIh/3bfXf7cXZRXrrkN1ym3Y6tD6DgSHgghSoLjHvO9z1iSKGK07afzlrt7hxRxZmg08lwJKjG4PMs8ngEKHuPQjNaNRhMz9igVR2WGVqZ4M5c7JCoogL5P4r@UrVIWoeVCtoYKdk9HEUm/tB8xPVlxsD7SgwJd7cEWKF2g5ULLemWhzwYs8rf8ZsMD" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
</div>
<div id="pu8" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal" rel="noreferrer">Vyxal</a>, 17 bytes</h1>
<pre><code>ʀėṠ:Ẋ'ɖ↔ꜝnF;?ḣL≠∨
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/#WyJBIiwiIiwiyoDEl+G5oDrhuoonyZbihpTqnJ1uRjs/4bijTOKJoOKIqCIsIiIsIls1LDIsMCwwLDAsMF1cbls1LDIsMSwwLDAsMF1cbls1LDIsMSwwLDEsMF1cbls1LDMsMSwwLDAsMF1cbls2LDUsNCwzLDIsMSwwXVxuWzBdXG5bMCwwLDAsMCwwLDBdXG5bNSwyLDEsMSwwLDBdXG5bNSwyLDAsMSwwLDBdXG5bNSwzLDEsMCwxLDBdXG5bNiwyLDEsMCwwLDBdXG5bNSwzLDEsMCwwLDFdXG5bNCwzLDEsMCwwLDBdIl0=" rel="noreferrer">Try it Online!</a></p>
<p>Outputs a falsy value if it is a counting tree and a truthy if it's not.</p>
<p>Uses the fact that it is a counting tree iff</p>
<ol>
<li>the first number is equal to the length of the rest of the list</li>
<li>for each pair of values <code>a</code>, <code>b</code> at indices <code>i</code>, <code>j</code> respectively the inclusive ranges <code>[i, i+a]</code> and <code>[j, j+b]</code> are either disjoint or one is a subset of the other</li>
</ol>
<p>Get all inclusive ranges.</p>
<pre><code>ʀ   # elementwise inclusive range from 0
 ė  # enumerate
  Ṡ # elementwise sum
</code></pre>
<p>Get all pairs and keep only those that don't satisfy 2.</p>
<pre><code>:         # duplicate
 Ẋ        # cartesian product
  '     ; # filter by:
          #                        [[1,2,3],[3,4]]
   ɖ↔     #   scan by intersection [[1,2,3],[3]]
     ꜝ    #   keep truthy          [[1,2,3],[3]]
      n   #   push argument        [[1,2,3],[3]], [[1,2,3],[3,4]]
       F  #   set difference       [[3]]
          #   empty are falsy, non-emtpy are truthy
</code></pre>
<p>Check if 1. is not satisfied and combine the two.</p>
<pre><code>?     # push input
 ḣ    # head extract
  L   # length
   ≠  # not equal
    ∨ # or
</code></pre>
</div>
<div id="pu9" class="pu"><h1><a href="https://github.com/m-ender/retina/wiki/The-Language/a950ad7d925ec9316e3e2fb2cf5d49fd15d23e3d" rel="nofollow noreferrer">Retina 0.8.2</a>, 61 bytes</h1>
<pre><code>\d+
$*
+%`^((1)*)1(1*),(\1(?!1)(?&lt;-2&gt;,1*)*)(?(2)^)
$4¶$3
^¶*$
</code></pre>
<p><a href="https://tio.run/##K0otycxL/K@q4Z7wPyZFm0tFi0tbNSFOQ8NQU0vTUMNQS1NHI8ZQw17RUFPD3kbXyE4HKKQFZGsYacZpcqmYHNqmYswVd2iblsr//6Y6RjoGEMgFYhuisQ3BbGO4uJmOqY4JkA@W5QJCHQM0/YZwtgGcbQw3ywzFDpi5hgA" rel="nofollow noreferrer" title="Retina 0.8.2 – Try It Online">Try it online!</a> Link includes test cases. Explanation: Port of @alephalpha's Curry answer.</p>
<pre><code>\d+
$*
</code></pre>
<p>Convert to unary.</p>
<pre><code>+%`^((1)*)1(1*),(\1(?!1)(?&lt;-2&gt;,1*)*)(?(2)^)
$4¶$3
</code></pre>
<p>Repeatedly split each rooted tree into its first branch and remaining branches.</p>
<pre><code>^¶*$
</code></pre>
<p>Check that there are only twigs left.</p>
</div>
<div id="pu10" class="pu"><h1><a href="https://www.python.org" rel="noreferrer">Python</a>, 63 bytes</h1>
<pre class="lang-python prettyprint-override"><code>f=lambda T,*t:T!=len(t)or T&gt;0&lt;f(T-(x:=t[0]+1),*t[x:])|f(*t[:x])
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m72soLIkIz9vwYKlpSVpuhY37dNscxJzk1ISFUJ0tEqsQhRtc1LzNEo084sUQuwMbNI0QnQ1KqxsS6INYrUNNYFKoiusYjVr0jSALKuKWE2oMappQA05Cpl5CvkFQP0GmlZcCgVFmXklGkCVqWWJORo5mppQxQtuLog21THSMYDAWC4wzxCDZwjlGSPJmemY6pgARYygsmCsY4BhliESzwCJZ4xkshmarTB7DGO5IA4FAA" rel="noreferrer">Attempt This Online!</a></p>
<p>Returns False for trees and True for fakes.</p>
</div>
<div id="pu11" class="pu"><h1><a href="https://www.informatik.uni-kiel.de/%7Epakcs/index.html" rel="noreferrer">Curry (PAKCS)</a>, 36 bytes</h1>
<pre><code>f[0]=1
f(a:b++c)=f b*f(a-length b:c)
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m706ubSoqDK-IDE7uXjBgqWlJWm6FjdV0qINYm0NudI0Eq2StLWTNW3TFJK0gDzdnNS89JIMhSSrZE2I2m25iZl5CrYKaQrRpjpGOgYQGAuRhBkIAA" rel="noreferrer">Attempt This Online!</a></p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/257998/">257998</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




