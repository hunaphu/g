<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::21438</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>050</td><td>APLNARS</td><td>250825T073910Z</td><td><a href="https://codegolf.stackexchange.com/questions/21438/shortest-program-to-solve-a-quartic-equation/283313#283313">Rosario</a></td></tr>
<tr d-ix="1"><td>148</td><td>Javascript/ES6</td><td>140311T102601Z</td><td><a href="https://codegolf.stackexchange.com/questions/21438/shortest-program-to-solve-a-quartic-equation/23735#23735">Michael </a></td></tr>
<tr d-ix="2"><td>132</td><td>Ruby —</td><td>140311T034822Z</td><td><a href="https://codegolf.stackexchange.com/questions/21438/shortest-program-to-solve-a-quartic-equation/23720#23720">O-I</a></td></tr>
<tr d-ix="3"><td>nan</td><td>C++ A fast and robust solution</td><td>140224T222027Z</td><td><a href="https://codegolf.stackexchange.com/questions/21438/shortest-program-to-solve-a-quartic-equation/22044#22044">Level Ri</a></td></tr>
<tr d-ix="4"><td>222</td><td>J</td><td>140222T063052Z</td><td><a href="https://codegolf.stackexchange.com/questions/21438/shortest-program-to-solve-a-quartic-equation/21729#21729">Eelvex</a></td></tr>
<tr d-ix="5"><td>nan</td><td>C</td><td>140220T001003Z</td><td><a href="https://codegolf.stackexchange.com/questions/21438/shortest-program-to-solve-a-quartic-equation/21478#21478">ASKASK</a></td></tr>
<tr d-ix="6"><td>nan</td><td>bc driven by bash</td><td>140219T205625Z</td><td><a href="https://codegolf.stackexchange.com/questions/21438/shortest-program-to-solve-a-quartic-equation/21459#21459">Digital </a></td></tr>
<tr d-ix="7"><td>340</td><td>C —</td><td>140219T202226Z</td><td><a href="https://codegolf.stackexchange.com/questions/21438/shortest-program-to-solve-a-quartic-equation/21455#21455">user1525</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>APL(NARS), 157 chars, score 132(+25 for numerical penality, -50 main function F ricorsive)</h1>
<pre><code>N←{⍵-(⍺⍺⍵)÷⍺⍺∂⍵}⋄F←{(k w)←⍵⋄e&gt;∣k-d←∣w-m←⍺⍺N w:m⋄k&lt;d:∅⋄⍺⍺F d,m}
r←f w;h;t;e
e←1e¯24⋄h←{⍵⊥w}⋄r←'0'⋄→0×⍳0=t←-h 0v⋄r←'n'⋄→0×⍳∅=t←h F∞,{e&lt;∣h∂⍵:⍵⋄∇⍵+⍵÷∣⍵}t⋄r←20⍕t
</code></pre>
<p>// +/63 12 82=157</p>
<p>f use Newton method and has as input one array of numbers that means one polynomial of degree at last 1, and return the string of one real root of that polynomial
or if it fails and return the string 'n'.Note that</p>
<pre><code>  (0÷∣0)
1
</code></pre>
<p>so it is not danger to use  (t÷∣t).</p>
<p>F has as argument in the left one function, if r=r_prec-(h r_prec)÷h∂r_prec in the right the distance |r_prec-r_prec_prec| calculated,
and r_prec.</p>
<p>f can find no solution, even if one solution could exist, and It is possible for some value of input
the function f give stack overflow or other ugly errors.</p>
<p>No input polinomy has to have some polynomial coefficient not zero, with abs in the interval (0,1e¯24)
because can happen {e&lt;∣h∂⍵:⍵⋄∇⍵+⍵÷∣⍵} could not return if 0&lt;∣h∂⍵&lt;e for each ⍵. For esample if h=e*x+c
h'=e so for h {e&lt;∣h∂⍵:⍵⋄∇⍵+⍵÷∣⍵}1 should not return.</p>
<p>Some test:</p>
<pre><code>f 1 0 ¯1 0 0.25
¯0.70710678118654752438
  f 1 ¯2 5 ¯12 4
0.38829144100474453558
  f 1 1 ¯2 ¯1 ¯1
1.37313285317645592754
  f ¯1 ¯1 ¯1 ¯1 ¯1
n
  f 1 2 0 0 1
¯1.00000000000000000000
  f 1 2 0 0 2
n
  f 1 2 0 0 ¯2
0.88503350364851765450
  f ¯1 2 3 4 ¯5
3.18247782305742776918
  f 1 2 3 4 ¯5
0.68412431945306971025
  f 1 2 3 4 5
n
  f 1 0 ¯2
1.41421356237309504880
  f 1 0 ¯2 2
¯1.76929235423863141524
  f 1 0 0 0 0
0
  f 1r3 0 ¯1 ¯1
2.10380340273553653316
  f 1r3 0 ¯1 1
¯2.10380340273553653316
  f 1r3 0 ¯9
5.19615242270663188058
  f 1r3 ¯9
27.00000000000000000000
  f 1 0 0.81  ¯0.47  0.06
0.20000000000000004596
  f 1 ¯8  18 0 ¯27
3.00000000000036766183
  f 1 0 0.81  ¯0.47  0.06v
0.20000000000000000000
  ⎕fpc
128
  ⎕fpc←256
  f 1 ¯8  18 0 ¯27
3.00000000000000000000
  f 1 0 0.81  ¯0.47  0.06
0.20000000000000004596
  f 1 0 0.81  ¯0.47  0.06v
0.20000000000000000000
</code></pre>
<p>are possible rounding errors that disappear if ⎕fpc is increased or the input array is rewritten as type floatv.</p>
<p>It seems rounding error depend of float representation of the input or if the polynomial has multiple
roots in the value of convergence. For example 1 ¯8  18 0 ¯27 has 3 roots in 3, value of convergence.</p>
</div>
<div id="pu1" class="pu"><h2>Javascript/ES6 148</h2>

<p>Since only <em>a</em> solution is required, I used a Newton solver.</p>



<pre class="lang-javascript prettyprint-override"><code>f=s=&gt;{a=s.split(' ');for(x=i=0;i++&lt;1e5;x-=y)z=x*x,y=(a[0]*z*z+a[1]*x*z+a[2]*z+a[3]*x+ +a[4])/(4*a[0]*z*x+3*a[1]*z+2*a[2]*x+ +a[3]);return y|0?'n':x}
</code></pre>

<p>If you don't have Firefox, you can test it without fat arrow :</p>

<pre class="lang-javascript prettyprint-override"><code>function f(s){a=s.split(' ');for(x=i=0;i++&lt;1e5;x-=y)z=x*x,y=(a[0]*z*z+a[1]*x*z+a[2]*z+a[3]*x+ +a[4])/(4*a[0]*z*x+3*a[1]*z+2*a[2]*x+ +a[3]);return y|0?'n':x}
</code></pre>

<p>Test : <code>f('1 -2 5 -12 4')</code> returns <code>0.3882914410047445</code></p>

<p><strong>Warning</strong> : <a href="http://en.wikipedia.org/wiki/Newton%27s_method#Failure_analysis" rel="nofollow">This <strong>can fail</strong> for some equations (if <code>d=0</code> for example).</a></p>
</div>
<div id="pu2" class="pu"><h3>Ruby — 132 characters + 25 numerical = 157</h3>

<pre><code>require'matrix';f=-&gt;a,b,c,d,e{a=-a.to_f;Matrix[[0,0,0,e/a],[1,0,0,d/a],[0,1,0,c/a],[0,0,1,b/a]].eigen.eigenvalues.find(&amp;:real?)||?n}
</code></pre>

<p>I think this toes the line of using native math libraries, but it's a pretty cool demonstration of what can be done with Ruby, as well as an intriguing way to look at solving univariate polynomial equations through the lens of linear algebra.</p>

<p>Basically, <code>f</code> just constructs the <a href="http://en.wikipedia.org/wiki/Companion_matrix" rel="nofollow">companion matrix</a> of the equivalent monic quartic and computes its eigenvalues, which is the same thing as finding the roots of the original quartic.</p>
</div>
<div id="pu3" class="pu"><h1>C++ A fast and robust solution, 704 chars + numeric - recursion = 679</h1>
<pre><code>#include &quot;stdafx.h&quot;
#include &quot;math.h&quot;
double a,b,c,e,j,k,l,p,q,t,z;void s(double x, int i){if(i==99)printf(&quot;%f\n&quot;,x);else s(x-((x+b)*x*x*x+c*x*x+l*x+e)/(4*x*x*x+j*x*x + k*x + l),i+1);}
void _tmain(){double r[8];scanf_s(&quot;%lf%lf%lf%lf%lf&quot;,&amp;a,&amp;b,&amp;c,&amp;l,&amp;e);b/=a;c/=a;l/=a;e/= a;j=3*b;k=2*c;p=(12*k-j*j)/48;q=(2*j*j*j-36*j*k+432*l)/1728;z=q*q/4+p*p*p/27;int u=0,v=0,g;
for(g=1;g&lt;4;g++){r[g]=z&gt;0|p==0?cbrt(-q/2+sqrt(z))+cbrt(-q/2-sqrt(z))-j/12:sqrt(-p/.75)*cos(acos(-q/sqrt(-p*p*p*4/27))/3-g*acos(-.5))-j/12;r[g+4]=(r[g]+b)*pow(r[g],3)+c*r[g]*r[g]+l*r[g]+e;if(r[g+4]&gt;r[g+3]|g==1)u=g;if(r[g + 4]&lt;r[g+3]|g==1)v=g;}
if(r[v+4]&gt;0)printf(&quot;n\n&quot;);if(r[v+4]==0)printf(&quot;%f\n&quot;,r[v]);if(r[v+4]&lt;0)s(2*r[v]-r[u]+(r[v]-r[u]==0),0);}
</code></pre>
<p>This is by no means the shortest answer, but so far no other answer has confirmed that it will work with curves with the full 3 stationary points (maxima/minima.) These correspond to curves with large values of b and c of opposite sign to a. None of the test data in the other solutions has local maxima/minima apart from the global one. The nearest is Eelvex's <code>1 2 0 0 1</code> which has a kink on one side where dy/dx falls to zero.</p>
<p>This program handles all the test data shown in other solutions, plus the following interesting examples, amongst others:</p>
<pre><code>1 0 1 0 0 --&gt; multiple root 0
1 0 -1 0 0 --&gt; multiple root at 0, but the program prefers the simple root at -1
1 0 -1 0 0.25 --&gt;  multiple roots at +/- 0.7071 = sqrt(0.5)
</code></pre>
<p>It cannot handle the case a=0, but that is not a quartic so it is out of scope. <s> The only problem I have found but not eliminated is b=c=d=0, but that is an easy problem to fix. I will do it when I golf the code (if I get round to that.) I expect it to come in around 700-800 chars.</s></p>
<p><strong>How it works</strong></p>
<p>The program divides the whole formula by <code>a</code> (which does not affect the roots, but ensures that we know that <code>y= +infinity</code> at <code>x = +/- infinity</code> )</p>
<p>It then calculates the formula for dy/dx (a cubic) and solves this analytically for dy/dx=0. The code to do this is quite short (the explanation in the comments is much longer than the code itself.)</p>
<p>It calculates the values of <code>y</code> at the up to 3 stationary points where dy/dx=0 and looks for the lowest (global minimum.) If this <code>y</code> is positive here , the whole curve is above the x axis and there are no roots.</p>
<p>If <code>y</code> is zero, then it is a root and this is reported directly. Such a root would be problematic for newton raphson.</p>
<p>If <code>y</code> is less than zero, the program makes a guess for the root on the opposite side of the global minimum from the other stationary points (to avoid getting trapped in the local maximum if there is one.)</p>
<p>Then it searches using newton-raphson (recursive, as you insisted.) This method is fast and simple, and once the right region of the curve has been identified, does not run the risk of dividing by zero.</p>
<p>I did run into other problems with it though. It quickly got very close to a solution (good enough for a human) but kept searching. With the rapid initial convergence, I assumed that the problem was that it couldn't get to f(x)==0 because f'(x) was large and f(x)/f'(x) was being rounded to zero in the calculation. So I put in an extra test condition for f(x)/f'(x) but it still did the same. Then I limited it to just 10 iterations, which is more than enough for all the tests I have done.</p>
<p>The current version goes up to 99 iterations. The ungolfed version has medium verbosity output (with uncommentable code for high verbosity) as seen in the screenshot and has its iterations terminated when f(x)==0. The golfed version has low verbosity (in accordance with specified requirements) and always runs to 99 iterations. The golfed version has other minor differences, such as no while loop and simplified (but less clear) expressions.</p>
<p>There are certainly other methods which might work better, but I think that might go into another answer (which I don't think I have time for.)</p>
<p><strong>Ungolfed version</strong></p>
<pre><code>#include &quot;stdafx.h&quot;
#include &quot;math.h&quot;

double a,b,c,d,e,j,k,l,p,q,t,z;
//explanation of variables
//dy/dx= i* x3 + j*x2 + k*x + l. No i variable needed as it is normalised to 4.
//depressed form of dy/dx: t3+pt+q. A subsitution is used to eliminate the squared term, see below.
//z=q2/4 + p3/27. z is proportional to the &quot;discriminant.&quot; The sign tells the number of roots of dy/dx
// +ve z means 1 real root, -ve z means 3 real roots, 0 means one simple root plus a double root. 

// recursive newton-raphson to depth i
void s(double x, int i){
    double m=(x + b)*x*x*x + c*x*x + d*x + e;
    if (m == 0 | i == 99)  printf(&quot;z= %f x= %f y= %f iteration %d\n&quot;, z,x,m,i); 
    else s(x-m/(4*x*x*x + j*x*x + k*x + l), i+1);
    
}

void _tmain(){
    while (true){
        
        double r[8];
        //r[1,2,3] and r[5,6,7] store x and y values of the maxima and minima.
        //r[0] and r[4] are dummies to handle [subscript-1] references.
        
        scanf_s(&quot;%lf %lf %lf %lf %lf&quot;, &amp;a, &amp;b, &amp;c, &amp;d, &amp;e);
        //uncomment for verbose output: printf(&quot;data for minima and maxima \n&quot;);
        //uncomment for verbose output: printf(&quot;   z       x       dy/x      y     hi/low \n&quot;);
        //hi/low indicate which y values are highest and lowest: 1st, 2nd, 3rd. 
        
        //Divide by a to give a &quot;monic polynomial&quot; with a=1. 
        //This does not affect the roots but saves a lot of typing of powers of a.
        // differentiate to i*x3 + j*x2 + k*x + l. As a=1, we know i=4.
        b /= a; c /= a; d /= a; e /= a;     
        j = 3*b; k = 2*c; l = d;
        
        // to prepare to solve this cubic, convert to depressed cubic t3+pt+q, eliminating x2. x=t-j/(3*i) 
        // p=(3*i*k - j2)/(3*i2) q=(2*j3 - 9*i*j*k + 27*i2*l)/27*i3. But we know i=4.
        p = (12 * k - j*j) / 48;
        q = (2 * j*j*j - 36 * j*k + 432 * l) / 1728;
        z = q*q / 4 + p*p*p / 27;
        
        //u and v indicate which of the stationary points are highest and lowest.
        //solve dy/dx, store the roots in r[1,2,3] and the y values in r[5,6,7].
        int u=0,v=0,g;      
        for (g = 1; g &lt; 4; g++){

            //if z&gt;0 or p==0 use cardano's method to store the one real root of dy/x three times in r[1,2,3] 
            //if z&lt;=0 use viete's trigonometric method to find the multiple real roots.
            //use of different methods for each case avoids the need to handle complex numbers.

            
            
            r[g] =z &gt; 0 | p==0? cbrt(-q / 2 + sqrt(z)) + cbrt(-q / 2 - sqrt(z)) - j / 12 :
                sqrt(-p / .75)*cos(acos(-q / sqrt(-p * p * p * 4 / 27)) / 3 - g*acos(-.5)) - j / 12;

            r[g+4] = (r[g]+b)*pow(r[g],3) + c*r[g]*r[g] + d*r[g] + e;
            
            if (r[g + 4]&gt;r[g+3]|g==1)u=g;
            if (r[g + 4]&lt;r[g+3]|g==1)v=g;

            // uncomment for verbose output
            //printf(&quot;%f %f %f %f %d %d \n  \n&quot;, z, r[g], 4 * pow(r[g], 3) + j*pow(r[g], 2) + k*r[g] + l, r[g+4], u, v);
        }
        
        //because we divided by a, the new a=1 and y tends to infinity at large |x|.
        //so if the lowest stationary point has y&gt;0, the whole curve is above the x axis and there is no solution.
        
        //if the lowest stationary point has y=0 it is tangent to the x axis and would cause problems for newton-raphson

        //if the lowest stationary point has y&lt;0, use newton raphson, 99 iterations. ensure 1st guess is on the side 
        //opposite the highest stationary point, just in case that point also has y&lt;0, to avoid getting trapped.
        //special case: if r[v]-r[u] == 0 (implies only one stationary point) then add 1!

        if (r[v+4] &gt;0) printf(&quot;n\n&quot;);
        if (r[v+4]==0) printf(&quot;z= %f x= %f multiple root&quot;, z,r[v]);
        if (r[v+4] &lt;0) s(r[v]+(r[v]-r[u])+(r[v]-r[u]==0),0);
    }       
}
</code></pre>
<p><strong>Output</strong></p>
<p>All data tested by other answers is here, as well as many additional examples. The sign of the value <code>z</code> is positive when there is only one stationary point where dy/dx=0, negative when there are three (2 minima and a maximum if a is positive), and zero when there are two (a minimum if a is positive, plus an inflexion.) This is the only answer so far that presents test cases for three stationary points.</p>
<p>The <code>y</code> values are shown for easy checking of the program. <code>y</code> is zero at the root, and as can be seen, an acceptable zero is always found.</p>
<p>The golfed version is low verbosity, displaying only the root per question spec.</p>
<p><img src="https://i.sstatic.net/yClwf.png" alt="enter image description here" /></p>
</div>
<div id="pu4" class="pu"><h1>J, 222</h1>

<p><em>247 - recursion + numerical</em></p>

<pre><code>NB. multiple lines for visibility
f=:[:-(]$:~[:}.[-%&amp;{.*],#&amp;0@l)`[@.(0&gt;l=:-&amp;#)
r=:1={.
s=:[:=/+/@(2=&amp;*/\])@(,.]*_1^i.@#)@({.@&gt;@(([;];f;j;f f j=.]f f)([:}:(i._5)*])))@|.
u=:0,0([(]*_1^r@k)&gt;:@]^:(1 1-:k=:[:*(0 p.~[)*(p.(,-)))^:_)~]
h=:{.@((n@],]{~[:r[:*p.*(p.n=:{.+-:@-~/))^:_ u)`('n'"_)@.s@|.
</code></pre>

<h3>Methods</h3>

<ul>
<li><p>Using Sturm's theorem to find number of roots.</p>

<p><code>f</code> is polynomial division (recursive)</p>

<p><code>s</code> is Sturm's theorem output: <code>0</code> for no real roots, <code>1</code> otherwise. It evaluates Sturm's polynomials <code>([;];f;j;f f j=.]f f)</code> and checks their behaviour at +/- infinity.</p></li>
<li><p>Using bisection method to avoid divisions by zero, local maxima etc.</p>

<p><code>u</code> scans from 0 to +/- infinity to find an appropriate interval</p>

<p><code>((n@],]{~[:r[:*p.*(p.n=:{.+-:@-~/))^:_ u)</code> evaluates the polynomial at the edges and midpoint then halfs the interval accordingly</p></li>
</ul>

<h3>Verification of results</h3>

<p>Using J's buildin polynomial root finder as <code>realRoots</code>:</p>

<pre><code>ti,&gt;([;h;realRoots) each samples
┌──────────────┬────────┬─────────────────┐
│a b c d e     │output  │all real roots   │
├──────────────┼────────┼─────────────────┤
│_1 2 3 4 5    │_1.11029│3.37192 _1.11029 │
├──────────────┼────────┼─────────────────┤
│_1 2 3 4 _5   │0.728727│3.18248 0.728727 │
├──────────────┼────────┼─────────────────┤
│1 2 3 4 5     │n       │                 │
├──────────────┼────────┼─────────────────┤
│1 1 2 _1 _1   │0.728262│0.728262 _0.52236│
├──────────────┼────────┼─────────────────┤
│1 2 3 4 0     │0       │_1.65063 0       │
├──────────────┼────────┼─────────────────┤
│1 2 0 0 1     │_1      │_1.83929 _1      │
├──────────────┼────────┼─────────────────┤
│_1 _1 _1 _1 _1│n       │                 │
└──────────────┴────────┴─────────────────┘
</code></pre>

<p><em>BTW, a simple implementation of Newton's method would be:</em></p>

<pre><code>f=:3 :'((-(y&amp;p.%y&amp;p.D.1))^:_)0'@|.
</code></pre>
</div>
<div id="pu5" class="pu"><h1>C, 182 + 25 = 207</h1>

<p>This is not the most eleant solution but it is certainly creative. Using iterger pointer conversions, it loops through every possibile value that a double can hold, tries it out, and checks if it equals 0.</p>

<pre><code>int main(int z,char **v){double a[5],f=0,r=1;int i=5;while(i--&gt;0)scanf("%lf",a+i);while(++(*(int*)&amp;f)&amp;&amp;r){i=5,r=0;while(i--&gt;0)r+=a[i]*pow(f,i);}if(r)printf(“%f",r);else printf("n");}
</code></pre>
</div>
<div id="pu6" class="pu"><h1>bc (driven by bash), score:137 (162 bytes -50 recursion bonus +25 numerical penalty)</h1>
<pre><code>bc -ql&lt;&lt;Q
n=0
define r(x){if(n++&gt;99){print &quot;n
&quot;;halt}
y=x-($1*x^4+$2*x^3+$3*x*x+$4*x+$5)/(4*$1*x^3+3*$2*x*x+2*$3*x+$4)
if(y==x){print x,&quot;
&quot;;halt}else r(y)}r(0)
Q
</code></pre>
<p>This is pretty much the same algorithm as the <a href="/questions/tagged/c" class="post-tag" title="show questions tagged &#39;c&#39;" rel="tag">c</a> answer, though it uses recursion to spice it up.</p>
<p>Run as follows:</p>
<pre><code>$ ./quartic.sh 1 2 3 4 5
n
$ ./quartic.sh -1 2 3 4 5
-1.11029075952058816917
$ ./quartic.sh 1 2 3 4 -5
.68412431945306971026
$ 
</code></pre>
<p>Of course Newton-Raphson has its limitations, and won't necessarily give all real roots in all cases where the exist.</p>
<p>According to WolframAlpha, this one has real roots at -1.9144 and 1.3731:</p>
<pre><code>$ ./quartic.sh 1 1 -2 -1 -1
n
$ 
</code></pre>
<p>Also there is a very real risk of divide-by-zero in some cases.  But this is code-golf, so who cares ;-)</p>
</div>
<div id="pu7" class="pu"><h1>C — 340 bytes + 25 points for numerical approximation = 365</h1>
<p>To compile <code>gcc -o quartic quartic.c -lm</code>, to run <code>./quartic a b c d e</code>. Uses Newton–Raphson method, no big whoop. Using deterministic methods, I can't see getting anywhere near this compact.</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#define C(x) atof(argv[x])
int main(int argc,char *argv[]){int i;double a,b,c,d,e,x,y;a=C(1);b=C(2);c=C(3);d=C(4);e=C(5);for(x=0,y=1,i=0;i&lt;100;x=y,i++){y=x-((((a*x+b)*x+c)*x+d)*x+e)/(((4*a*x+3*b)*x+2*c)*x+d);if(fabs(x-y)&lt;1e-09){printf(&quot;%.9f\n&quot;,y);return 0;}}printf(&quot;n\n&quot;);return 1;}
</code></pre>
<p>e.g.</p>
<pre><code>$ ./quartic 1 2 3 4 5
n

$ ./quartic -1 2 3 4 5
-1.110290760

$ ./quartic -1 2 3 4 -5
0.728726879
</code></pre>
<p>Verified via Wolfram|Alpha, results check out.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/21438/">21438</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




