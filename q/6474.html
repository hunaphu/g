<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::6474</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>041</td><td>Vyxal</td><td>240131T185711Z</td><td><a href="https://codegolf.stackexchange.com/questions/6474/generating-minesweeper-grids/269656#269656">emanresu</a></td></tr>
<tr d-ix="1"><td>037</td><td>Vyxal 3 j</td><td>240115T204008Z</td><td><a href="https://codegolf.stackexchange.com/questions/6474/generating-minesweeper-grids/269268#269268">pacman25</a></td></tr>
<tr d-ix="2"><td>050</td><td>05AB1E</td><td>240131T142108Z</td><td><a href="https://codegolf.stackexchange.com/questions/6474/generating-minesweeper-grids/269650#269650">Kevin Cr</a></td></tr>
<tr d-ix="3"><td>230</td><td>C++</td><td>210805T085855Z</td><td><a href="https://codegolf.stackexchange.com/questions/6474/generating-minesweeper-grids/233128#233128">ryno</a></td></tr>
<tr d-ix="4"><td>155</td><td>Haskell</td><td>210807T172108Z</td><td><a href="https://codegolf.stackexchange.com/questions/6474/generating-minesweeper-grids/233221#233221">lynn</a></td></tr>
<tr d-ix="5"><td>054</td><td>APL Dyalog Unicode</td><td>210806T150744Z</td><td><a href="https://codegolf.stackexchange.com/questions/6474/generating-minesweeper-grids/233167#233167">ovs</a></td></tr>
<tr d-ix="6"><td>896</td><td>brainfuck</td><td>191028T145852Z</td><td><a href="https://codegolf.stackexchange.com/questions/6474/generating-minesweeper-grids/194992#194992">Dorian</a></td></tr>
<tr d-ix="7"><td>280</td><td>Scala</td><td>120629T075219Z</td><td><a href="https://codegolf.stackexchange.com/questions/6474/generating-minesweeper-grids/6496#6496">Don Mack</a></td></tr>
<tr d-ix="8"><td>116</td><td>ECMAScript 2019 Modern Javascript</td><td>191023T193236Z</td><td><a href="https://codegolf.stackexchange.com/questions/6474/generating-minesweeper-grids/194778#194778">Peter Jo</a></td></tr>
<tr d-ix="9"><td>180</td><td>Python</td><td>120627T103649Z</td><td><a href="https://codegolf.stackexchange.com/questions/6474/generating-minesweeper-grids/6483#6483">ugoren</a></td></tr>
<tr d-ix="10"><td>nan</td><td></td><td>120626T175936Z</td><td><a href="https://codegolf.stackexchange.com/questions/6474/generating-minesweeper-grids/6476#6476">Gaffi</a></td></tr>
<tr d-ix="11"><td>137</td><td>Mathematica</td><td>120628T123438Z</td><td><a href="https://codegolf.stackexchange.com/questions/6474/generating-minesweeper-grids/6490#6490">Mr.Wizar</a></td></tr>
<tr d-ix="12"><td>175</td><td>K</td><td>120702T130551Z</td><td><a href="https://codegolf.stackexchange.com/questions/6474/generating-minesweeper-grids/6530#6530">tmartin</a></td></tr>
<tr d-ix="13"><td>691</td><td>C# 691 Chars</td><td>120702T103342Z</td><td><a href="https://codegolf.stackexchange.com/questions/6474/generating-minesweeper-grids/6529#6529">Aamir</a></td></tr>
<tr d-ix="14"><td>454</td><td>C++</td><td>120701T211005Z</td><td><a href="https://codegolf.stackexchange.com/questions/6474/generating-minesweeper-grids/6523#6523">Gaffi</a></td></tr>
<tr d-ix="15"><td>068</td><td>J</td><td>120627T124703Z</td><td><a href="https://codegolf.stackexchange.com/questions/6474/generating-minesweeper-grids/6484#6484">Gareth</a></td></tr>
<tr d-ix="16"><td>071</td><td>GolfScript</td><td>120626T210342Z</td><td><a href="https://codegolf.stackexchange.com/questions/6474/generating-minesweeper-grids/6478#6478">Cristian</a></td></tr>
<tr d-ix="17"><td>247</td><td>Mathematica</td><td>120626T192250Z</td><td><a href="https://codegolf.stackexchange.com/questions/6474/generating-minesweeper-grids/6477#6477">DavidC</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal/tree/version-2" rel="nofollow noreferrer">Vyxal</a>, 41 bytes</h1>
<pre><code>⌈⌊2ẇḣ$2+Þm$R(n1ÞȦ)2(3vl∩)⟑ƛf4ǔṫß×∑\x$∨;ṅ,
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/?v=2&amp;c=1#WyIiLCIiLCLijIjijIoy4bqH4bijJDIrw55tJFIobjHDnsimKTIoM3Zs4oipKeKfkcabZjTHlOG5q8Ofw5fiiJFcXHgk4oioO+G5hSwiLCIiLCJcIjMgNCAzIDEgMSA0IDIgMyAzIDJcIiJd" rel="nofollow noreferrer">Try it Online!</a> (would be 28ish with looser I/O)</p>
<pre><code>⌈⌊                                        # Parse integers from input
  2ẇ                                      # Group into pairs
    ḣ                                     # Remove the first pair (dimensions)
     $2+                                  # Add 2 to each
        Þm                                # Create a matrix of 0s with those dimensions
          $R(    )                        # Over each remaining coordinate pair (with x and y swapped)
               ÞȦ                         # Place in the matrix
              1                           # A 1
             n                            # At those coordinates
                  2(    )                 # Twice
                    3vl                   # Get all sliding windows of length 3 of each
                       ∩                  # Transpose
                         ⟑ƛ           ;   # Over each cell
                           f              # Flatten into a 9-element array
                            4ǔ            # Rotate so the centre (current cell) is at the end
                              ṫ           # Extract the last element (current cell)
                               ß×         # If that is truthy, push a mine
                                 ∑        # Sum to get number of nearby mines
                                  \x$∨    # If 0, replace with x
                                       ṅ, # Concatenate each row and print it
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal/tree/version-3" rel="nofollow noreferrer">Vyxal 3</a> <code>j</code>, 37 bytes</h1>
<pre><code>2ẆVḤ\ðYY$v•ÞẠ:Þȯᵛƛ•C]ZᵗZᵛᵛ₳•c[•]0'xr“
</code></pre>
<p><a href="https://vyxal.github.io/latest.html#WyJqIiwiIiwiMuG6hlbhuKRcXMOwWVkkduKAosOe4bqgOsOeyK/htZvGm+KAokNdWuG1l1rhtZvhtZvigrPigKJjW+KAol0wJ3hy4oCcIiwiIiwiWzUgNSAxIDMgMyA1IDIgNF0iLCIzLjQuMiJd" rel="nofollow noreferrer">Try it Online!</a>
-12 from Using reduce lambdas on zipped list instead of the weird index method.
-1 because i didnt need a map lambda at the end</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 50 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>#2ôć¬UPL&lt;s&lt;íXδβ©såXô2Fø0δ.ø}2Fø€ü3}OOJJ'*®ǝ0'x:Xô»
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f9f2ejwliPth9aEBvjYFNscXhtxbsu5TYdWFh9eGnF4i5Hb4R0G57boHd5RC2I@alpzeI9xrb@/l5e61qF1x@caqFdYAZUd2v3/v7GCiYKxgiEQmigYAVnGCkYA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/V@m5JlXUFpipaBkX6nDpeRfWgLh6VT@VzY6vOVI@6E1oQE@NsU2h9dGnNtybtOhlcWHl0Yc3mLkdniHwbkteod31IKYj5rWHN5jXOvv7@WlrnVo3fG5BuoVVkBlh3b/1zm0zf5/tJKpgqmCoYIxEJoqGCmYKOkoGSuYAHmGQGgCFAHJGCnFAgA" rel="nofollow noreferrer">verify both test cases</a>.</p>
<p><strong>Explanation:</strong></p>

<p>05AB1E lacks multi-dimensional index builtins and uses 0-based indexing, so we mostly work with the flattened list and lower all indices by 1 (before converting it back to a matrix to calculate the amount of surrounding mines per cell).</p>
<pre class="lang-python prettyprint-override"><code>#              # Split the (implicit) input-string on spaces
 2ô            # Split it into parts of size 2
   ć           # Extract head; pop and push remainder-list and first pair
    ¬          # Get the first item of this first pair (without popping)
     U         # Pop and store it in variable `X`
    P          # Take the product of this first pair
     L&lt;        # Pop and push a list in the range [0,value)
    s          # Swap so the list of pairs is at the top again
     &lt;         # Decrease each inner value by 1 to make things 0-based
      í        # Reverse each inner pair, to reverse column,row to row,column
        δ      # Map over each reversed and lowered pair:
       X β     #  Convert it from base-`X` to an integer,
               # (which are all flattened 0-based indices of the mines)
          ©    # Store this list in variable `®` (without popping)
           s   # Swap so the [0,value)-ranged list is at the top
            å  # Check for each value whether its in the indices-list,
               # resulting in a list of 0s and 1s, with 1s at the mine-positions
Xô             # Split it into `X`-sized parts to a matrix
  2Fø0δ.ø}     # Add a border of 0s around the matrix:
  2F     }     #  Loop 2 times:
    ø          #   Zip/transpose; swapping rows/columns
      δ        #   Map over each inner list:
     0 .ø      #    Surround it with a leading/trailing 0
  2Fø€ü3}      # Convert it to a matrix of overlapping 3x3 blocks:
  2F    }      #  Loop 2 times again:
    ø          #   Zip/transpose; swapping rows/columns
     €         #   Map over each inner list:
      ü3       #    Convert it to a list of overlapping triplets
  OO           # Sum each inner 3x3 block
    JJ         # Join all these digits together to a single string
      '*®ǝ    '# Replace the digit at the `®`-indices with &quot;*&quot;s
      0'x:    '# Replace all 0s with &quot;x&quot;s
      Xô       # Split it into `X`-sized parts again to a list of rows
        »      # Join it by newlines
               # (after which the result is output implicitly)
</code></pre>
</div>
<div id="pu3" class="pu"><h1>C++, 230 chars</h1>
<pre><code>#import&lt;iostream&gt;
int*p,n,m,x,y,i,j,k,a[999][999];main(){for(std::cin&gt;&gt;m&gt;&gt;n;std::cin&gt;&gt;y&gt;&gt;x;)for(i=2;~i--;)for(j=2;~j--;*p+=i|j&amp;&amp;~*p?:~*p)p=a[x+i]+y+j;for(;k&lt;n*m;std::cout&lt;&lt;char(x?~x?x+48:42:120)&lt;&lt;(j&lt;m)+&quot;\n&quot;)x=a[k/m+1][j=k++%m+1];}
</code></pre>
<p>-11 bytes thanks to <code>ceilingcat</code></p>
<p>-15 bytes thanks again to <code>ceilingcat</code>. Truly bigbrain</p>
<p>-14 bytes thanks to <code>ceilingcat</code> and I</p>
<p>-8 bytes thanks to <code>ceilingcat</code> and I</p>
<p><a href="https://tio.run/##RYzdaoQwGETv@xRhSxdjIq3Ri5rE@CDWi@D254skBjeFSFtf3ca2UAYOc2CY0fvidRz3/Rasn5cgYb6G5VlbdQMu5J46ammkKwVq6ER13zTN8ANhNbgMf7zMS3YNF85HcEpZpZz411WpKPAxgZaJDYri18xhJlnuSQuf5nzect/xBOxb3UcCA1mJEcdWTNLl9u90fg9Sjm96yWK3xS6S@pHXjJfsAUuZGWkxOT25E47pZbq3pBx6006E3B1VfO17hWpUoTKlRiy1CrFv" rel="nofollow noreferrer">Try it online</a></p>
</div>
<div id="pu4" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, 155 bytes</h1>

<pre class="lang-hs prettyprint-override"><code>main=interact$f.map read.words
f(x:y:a)=unlines[[&quot;x12345678*&quot;!!min((i,j)#a)9|i&lt;-[1..x]]|j&lt;-[1..y]]
p@(a,b)#(x:y:z)=div 9(9^max(abs$a-x)(abs$b-y))+p#z
_#_=0
</code></pre>
<p><a href="https://tio.run/##JczdDkMwGIDhc1fR4aDdkFH7IZPsPqSTz1RWoxO1rcS9m1jek@fofYB68rqe5waETITseQf33i69BlrUcSi876srlFFiHQ8xkOQtayG5SlNT@wEND8fTeWtuNo2QGAunIhaQaBIXN/U9TzM2VX8OjBntFYOTE2tdjSQpxAdFOLo1oDHkygZXkxW5OxCya63RyKws2c8zRSGiyF8KUbCIouAH" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
</div>
<div id="pu5" class="pu"><h1><a href="https://www.dyalog.com/" rel="nofollow noreferrer">APL (Dyalog Unicode)</a>, <s>59</s> <s>57</s> 54 <a href="https://github.com/abrudz/SBCS" rel="nofollow noreferrer">bytes</a></h1>
<p>With a more flexible input format this could be <a href="https://tio.run/##SyzI0U2pTMzJT///v1q9wtDI2MTUzNxCSz1ao1pbX@dR79baRz27jBWMH/V0WD7qmHF4uqahA1D0UdeiR727HvVuMYit/Z/2qG3Co96@R31TPf0fdTUfWm/8qG0ikBcc5AwkQzw8g/9D5NomGHCZKpgqpCk86tl7aIXCofWGCtoKGoYKxpoKGsYKpkDSSMFEk@tR7xouEwVjdHXGCoaaINUmYHUQPUaaAA" rel="nofollow noreferrer">39 bytes</a></p>

<pre class="lang-apl prettyprint-override"><code>{⍉{5⌷,⍵:'*'⋄×r←+/,⍵:⍕r⋄'x'}⌺3 3⊢1@(1↓⍵)⊢0⍴⍨⊃⍵}⊢⊂⍨2|⍳∘≢
</code></pre>
<p><a href="https://tio.run/##SyzI0U2pTMzJT///v/pRb2e16aOe7TqPerdaqWupP@puOTy96FHbBG19sNCj3qlFQDH1CvXaRz27jBWMH3UtMnTQMHzUNhkorQnkGTzq3fKod8WjrmagQC1Q4FFXE5BvVPOod/OjjhmPOhf9TwOa96i371HfVE9/oLpD640ftU0E8oKDnIFkiIdn8P80BVMgNFQA2gCkjRRMuB71ruFKA/JMgNgQCE2AoiBZIwA" rel="nofollow noreferrer" title="APL (Dyalog Unicode) – Try It Online">Try it online!</a></p>
<p>The whole structure is a train, first <code>⊢⊂⍨2|⍳∘≢</code> splits the input into pairs, then the large <em>dfn</em> is called on the list of pairs:</p>
<p><code>0⍴⍨⊃⍵</code> Create a matrix of 0's where the dimensions are given by the first pair.</p>
<p><code>1↓⍵</code> all but the first pair<br />
<code>1@(...)</code> at those indices place 1's in the matrix.</p>
<p><code>{ ... }⌺3 3</code> apply the left function on each 3×3 neighborhood (padded with zeros):</p>
<p><code>5⌷,⍵</code> If the value at index 5 of the flattened neighborhood (the center) is 1, return <code>'*'</code><br />
<code>×r←+/,⍵</code> If the sum of the neighborhood is positive, return it as a string <code>⍕r</code><br />
Otherwise return <code>'x'</code></p>
<p><code>⍉</code> transpose the matrix because the order of axis is different in APL and the challenge.</p>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/TryItOnline/brainfuck" rel="noreferrer">brainfuck</a>, <s>1001</s> 896 bytes</h1>

<pre><code>,[&gt;,]-[&lt;]&gt;&gt;++[&lt;[&lt;+&lt;+&gt;&gt;-]&lt;[&gt;+&lt;-]&gt;[&gt;]&gt;[&gt;&gt;[&gt;&gt;&gt;&gt;]&gt;]++[-&lt;+]-[&lt;]&lt;++[&gt;&gt;[&gt;]&gt;[&gt;&gt;[&gt;&gt;&gt;&gt;]&gt;]+&lt;++[-&lt;+]-[&lt;]&lt;-]&gt;&gt;&gt;-]&gt;[&gt;]&gt;[&gt;&gt;[&gt;&gt;&gt;&gt;]&lt;&lt;&lt;-&gt;&gt;&gt;&gt;]+[-&lt;+]-[&lt;]&gt;&gt;[[&gt;]&gt;--&lt;&lt;[&lt;]&gt;&gt;[[&gt;]+[-&gt;+]+&gt;&gt;[&gt;&gt;&gt;&gt;]&gt;--&lt;+[-&lt;+]-[&lt;]&gt;&gt;-]&gt;[&gt;]+[-&gt;+]+&gt;&gt;--&lt;+[-&lt;+]-[&lt;]&lt;[&gt;&gt;[&gt;]+[-&gt;+]+&gt;&gt;&gt;&gt;--&lt;+[-&lt;+]-[&lt;]&lt;-]&gt;&gt;[&gt;]+[-&gt;+]+&gt;++[-&lt;+]-[&lt;]&gt;&gt;]&gt;[+&gt;&gt;[&gt;&gt;&gt;&gt;]&gt;]&lt;&lt;&lt;&lt;&lt;[&lt;&lt;&lt;&lt;]&gt;&gt;-&lt;+[-&lt;+]&gt;&gt;&gt;&gt;[&gt;&gt;&gt;&gt;]&gt;[-[--&lt;&lt;&lt;&lt;&lt;[&lt;&lt;&lt;&lt;]&gt;&gt;&gt;&gt;--[&gt;&gt;&gt;&gt;]&gt;&gt;&gt;[&gt;&gt;&gt;&gt;]&gt;&gt;&gt;--&lt;+[-&lt;+]++&gt;&gt;&gt;&gt;&gt;&gt;[&gt;[&lt;--&lt;&lt;&lt;[-[&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;+&lt;-]&gt;+&lt;]&gt;[&lt;+&gt;-]&gt;&gt;&gt;&gt;+++[&lt;&lt;&lt;+[-&lt;+]-&gt;[-[+[-&gt;+]-&gt;&gt;&gt;+&lt;&lt;&lt;&lt;+[-&lt;+]-&gt;&gt;+&lt;-]&gt;+&lt;]&gt;[&lt;+&gt;-]+[-&gt;+]-&gt;&gt;-[&lt;&lt;&lt;+[-&lt;+]+&gt;&gt;&gt;&gt;--&gt;+[-&gt;+]-&gt;&gt;[&lt;&lt;&lt;+&gt;&gt;&gt;-]]&lt;&lt;&lt;[&gt;&gt;&gt;+&lt;&lt;&lt;-]&gt;&gt;&gt;]&lt;&lt;&lt;+[-&lt;+]+&lt;&lt;&lt;&lt;--&gt;+[-&gt;+]-&gt;&gt;&gt;&gt;&gt;[-[&lt;&lt;+&gt;&gt;&gt;+&lt;-]&gt;+&lt;]&gt;[&lt;+&gt;-]&lt;&lt;&lt;&lt;+++[+[-&gt;+]-&gt;[-[&lt;&lt;+[-&lt;+]-&gt;&gt;&gt;++[-&gt;+]-&gt;&gt;+&lt;-]&gt;+&lt;]&gt;[&lt;+&gt;-]&lt;&lt;&lt;+[-&lt;+]-&gt;&gt;-[+[-&gt;+]+&gt;&gt;&gt;&gt;--&lt;+[-&lt;+]-&gt;&gt;[&lt;&lt;&lt;+&gt;&gt;&gt;-]]&lt;&lt;&lt;[&gt;&gt;&gt;+&lt;&lt;&lt;-]&gt;&gt;&gt;]+[-&gt;+]+&lt;&lt;&lt;&lt;--&lt;+[-&lt;+]-&gt;-[&gt;&gt;[-]&lt;&lt;++++++[&gt;++++++&lt;-]&gt;.[-]+&lt;&lt;&lt;]&lt;[&gt;&gt;&gt;[&lt;++++++[&gt;++++++++&lt;-]&gt;.[-]&lt;]&lt;&lt;&lt;[&lt;++++++++[&lt;+++++++++++&gt;-]&lt;.[-]&gt;]&lt;]&gt;&gt;&gt;&gt;+&lt;&lt;++&gt;]&gt;[&lt;+&gt;-]&gt;&gt;]-&gt;+[-&gt;+]++[-&lt;+]++++++++++.[-]]&gt;]
</code></pre>

<p><a href="https://tio.run/##fVL/rpsgFA4qAkKUNtpa294X4HKfgPAihD@2JUuWJftjyZ6/OwdFbe8yUlPk@3E@zvHr7y8/fn3/8@3n4/Ee/Hu0wUXvjQkuOOOM9za64I2z0QePD/487CJwrDNJ4GDvP@FuzwA9ej2TnHM2bTYiQEix1rn1DVBvolmtAdwLZteV9IS6OdcKvsIYa4ebvS/YbjUxK0aChSUXD8QWQrABQ@9IWGsBV9auvklxEAkuKcPMhu4nm9RzA0YwCJ/aB/EMmi8hseQc3GZRRvyLeKXZTb90w69YgtKU8LJh8UyV46bCMnsV3gBdjf9UNSWCyJk783LE1Gz/r7T7i@Qrvszu/2kXyRx1lWB7A7qbtIKf/1HzAedIT98LpnhibByXarl8vO1gYXDkQLPiMkU43MYXc9NMnn9eqALZ4/GmORNMVw27F1IMSjLdya7jVHf1vWIFbYaWlBc1lkMlCtZN9YUNstclmei1rlRFJj1WRXGmd3LQrRgbVit2a2t@kLdaCKUaeSoHchQtb/hRSXlqe3LWV8LpjdGyIIzcVQ9GY9fogzjXI6G851dBqJYTn2QpatlS1fR0ELSq9ZEJ1VRv7KInMTGij3Lkp@Iv" rel="noreferrer" title="brainfuck – Try It Online">Try it online!</a> or <a href="https://tio.run/##fVPBqtwwDPwV3/1cYmeTzYLwj4Qc2kKhFHoo9Pu3MyPbyduFmhBkaUYaScm3P19//v7x9/uv5/NjrxFnt9ROTUc0Od2Hu/m9HUtH3S3CXyusireZfRxpN3hIQxRxEsET3IHEwjqASRZFMNj1LW5XBOvUM0lN5jgUTd2gwj25dTQuY/ISc@aDk5lSAqffEK3xiEMBgleCFx@gT1Fz@SP4Gmb5Szxe8yLtWbO1oQ7YpANhDcSedqq@oFisBQfqIiAqO9dIjiOxIaXQXqKdq6y@cuviWc5Vp04ag30hD1g6@W0UdcQU0iYPrctz@nZOFstcWeyLWWN9qypFkNyxjhu7jyPHO2@geosvi/u/2kZxqYPC8eoT9L@k/zHkfNmT4PpYqOIT4sSYall3nxYOhRODYR1ti3Be/sQ@tNh33w9ZoD2f8xTyGsoWcg55DvkWyhLuoTzwys2Cv@Tw4KuEDJfwM@O50AuosiwByFmpJj3gMHgjQZmB8ucGv8otMDcaxC/MlpUMtYghqii@MUy5lJDhXsWSbGnNErJCaKZaCppZNQfBbsLgXoLrWMKjcXOTXO4upqg7PIETuNF/ZzL1S6i6ml3arL4mdjOFrQ/RhXAYksk@Kd8pa@9RrI29Sg@rySh9UIXz32RSDjVSdQkK@FSmJin7plakcEGTj0g56ddmNs1w4Rj43tpU8vwP" rel="noreferrer" title="brainfuck – Try It Online">try the old version with integer input</a></p>

<p>One day of programming and three days of bugfixing ^^</p>

<p>This uses a few parts of my Game Of Life code. Instead of counting living cells, this counts bombs.
Since input as codepoints is allowed by the general rules, this uses them instead of "readable" integers.</p>

<pre><code>[
Data: colCount, rowCount, {BombCoordinates}, -1 (start of arrays/"soa"), 0, {RowData}
BombCoordinates: bombCol, bombRow
RowData: rowFlag, 0, {CellData}, 0
CellData: cellFlag, cellState, temp, bombCount

rowFlag: 0=EOF, 1=inactive (all cells inactive), 2=active
cellFlag: -1=marker for finding cell (cell to be counted or current cell), 0=EOF, 1=normal
cellState: 0=inactive, 1=normal, 2=bomb
temp: helper to exit if-statements
bombCount: count of neighbor cells that contain bombs
inactive cells or rows will not be printed. They are only used for an easier counting algorithm.
]

#### input values as codepoints ####
,[&gt;,]

#### setup two dimensional array ####
-                   set soa
[&lt;]&gt;&gt;               go to rowCount
++                  add two inactive rows
[                   for each row
  &lt;[&lt;+&lt;+&gt;&gt;-]          copy colCount two times to the next left cells
  &lt;[&gt;+&lt;-]             move one of the copies back to the original cell
  &gt;[&gt;]&gt;[&gt;&gt;[&gt;&gt;&gt;&gt;]&gt;]    go to new row position
  +                   set rowFlag (only 1 while initialization)
  +[-&lt;+]-[&lt;]&lt;         go to copy of colCount
  ++                  add two inactive cells per row
  [                   for each col
    &gt;&gt;[&gt;]&gt;[&gt;&gt;[&gt;&gt;&gt;&gt;]&gt;]   go to new cell position
    +&lt;+                 set cellFlag and cellState = normal
    +[-&lt;+]-[&lt;]&lt;         return to copy of colCount
    -                   decrement
  ]
  &gt;&gt;&gt;-                decrement rowCount
]

#### setup active/inactive flags of cells ####
&gt;[&gt;]&gt;[              for each row
  &gt;&gt;[&gt;&gt;&gt;&gt;]&lt;&lt;&lt;-        set last cell inactive
  &gt;&gt;&gt;&gt;                go to next row
]

#### mark the bombs ####
+[-&lt;+]-[&lt;]&gt;&gt;        go to bombRow
[                   while there are bombRow values left
  [&gt;]&gt;--              set rowFlag of first row = neg 1 (as a marker)
  &lt;&lt;[&lt;]&gt;&gt;             return to bombRow
  [                   for each bombRow
    [&gt;]+[-&gt;+]           find first marker after soa
    +                   set rowFlag = 1
    &gt;&gt;[&gt;&gt;&gt;&gt;]&gt;           go to next rowFlag
    --                  make a marker of it
    &lt;+[-&lt;+]-[&lt;]&gt;&gt;       return to bombRow
    -                   decrement
  ]
  &gt;[&gt;]+[-&gt;+]          go to selected rowFlag
  +                   set rowFlag = 1
  &gt;&gt;--                set cellFlag of first cell = marker
  &lt;+[-&lt;+]-[&lt;]&lt;        go to bombCol
  [                   for each bombCol
    &gt;&gt;[&gt;]+[-&gt;+]         find first marker after soa
    +                   set cellState = 1
    &gt;&gt;&gt;&gt;                go to next cellState
    --                  set it neg 1 (as a marker)
    &lt;+[-&lt;+]-[&lt;]&lt;        return to bombCol
    -                   decrement
  ]
  &gt;&gt;[&gt;]+[-&gt;+]         find first marker after soa
  +                   set cellFlag = normal
  &gt;+                  set cellState = bomb
  +[-&lt;+]-[&lt;]&gt;&gt;        go to next bombRow
]

#### setup active/inactive flags of rows ####
&gt;[                  for each row
  +                   set rowFlag = 2 (active)
  &gt;&gt;[&gt;&gt;&gt;&gt;]&gt;           go to next rowFlag
]
&lt;&lt;&lt;&lt;&lt;[&lt;&lt;&lt;&lt;]&gt;&gt;-      set rowFlag of last row = 1 (inactive)

#### count bombs in neighborhood ####
&lt;+[-&lt;+]&gt;&gt;&gt;&gt;[&gt;&gt;&gt;&gt;]&gt;  go to second row
[                   for each row
  -[                  if active
    --                  set it neg 1 (marker)
    &lt;&lt;&lt;&lt;&lt;[&lt;&lt;&lt;&lt;]&gt;&gt;&gt;&gt;     go to cellFlag of first cell in previous row
    --                  set it neg 1 (marker)
    [&gt;&gt;&gt;&gt;]&gt;&gt;&gt;[&gt;&gt;&gt;&gt;]&gt;&gt;&gt;  go to cellFlag of first cell in next row
    --                  set it neg 1 (marker)
    &lt;+[-&lt;+]             return to rowFlag
    ++                  set rowFlag = 2 (active)

    &gt;&gt; &gt;&gt;&gt;&gt;[            for each cell (starting with second)
      &gt;[                  if active
        &lt;--                 set cellFlag = neg 1 (marker)

        # check if cell to the left is a bomb
        &lt; &lt;&lt;                go to cellState of previous cell
        [                   if active
          -[                  if bomb
            &gt;&gt; &gt;&gt;&gt;&gt;+            increment bombCount
            &lt;&lt;&lt;&lt; &lt;              go back to checked cell
            +                   set temp = 1
            &lt;-                  set cellState = 0 to exit if
          ]
          &gt;+&lt;                 increment temp
        ]
        &gt;[&lt;+&gt;-]             restore cellState

        # check if cells on top are bombs
        &gt; &gt;&gt;&gt;               go to temp of current cell
        +++[                do three times
          &lt;&lt;&lt;+[-&lt;+]-          go to next marker to the left
          &gt;[                  if active
            -[                  if bomb
              +[-&gt;+]-             return to current cell
              &gt;&gt;&gt;+                increment bombCount
              &lt;&lt;&lt;&lt;+[-&lt;+]-&gt;        return to counted cell
              &gt;+                  set temp = 1
              &lt;-                  set cellState = 0 to exit if
            ]
            &gt;+&lt;                 increment temp
          ]
          &gt;[&lt;+&gt;-]             restore cellState
          +[-&gt;+]-             go to current cell
          &gt;&gt;-                 decrement temp
          [                   if temp != 0
            &lt;&lt;&lt;+[-&lt;+]           go to marked cell
            +                   set cellFlag = normal
            &gt;&gt;&gt;&gt;--              set cellFlag of next cell = marker
            &gt;+[-&gt;+]-&gt;&gt;          return to currentCell temp
            [&lt;&lt;&lt;+&gt;&gt;&gt;-]          store value of temp in previous cell bombCount (to exit if)
          ]
          &lt;&lt;&lt;[&gt;&gt;&gt;+&lt;&lt;&lt;-]&gt;&gt;&gt;    restore temp value
        ]
        &lt;&lt;&lt;+[-&lt;+]           go to marked cell
        +                   set cellFlag = normal
        &lt;&lt;&lt;&lt;--              set previous cellFlag = marker
        &gt;+[-&gt;+]-            return to current cell

        # check if cell to the right is a bomb
        &gt;&gt;&gt; &gt;&gt;              go to cellState of next cell
        [                   if active
          -[                  if bomb
            &lt;&lt;+                 increment bombCount
            &gt;&gt;&gt;                 go back to checked cell
            +                   set temp = 1
            &lt;-                  set cellState = 0 to exit if
          ]
          &gt;+&lt;                 increment temp
        ]
        &gt;[&lt;+&gt;-]             restore cellState

        # check if cells below are bombs
        &lt;&lt;&lt; &lt;               go to currentCell temp
        +++[                do three times
          +[-&gt;+]-         go to next marker to the right
          &gt;[              if active
            -[              if bomb
              &lt;&lt;+[-&lt;+]-       return to current cell
              &gt;&gt;&gt;+            increment bombCount
              +[-&gt;+]-&gt;        return to counted cell
              &gt;+              set temp = 1
              &lt;-              set cellState = 0 to exit if
            ]
            &gt;+&lt;             increment temp
          ]
          &gt;[&lt;+&gt;-]         restore cellState
          &lt;&lt;&lt;+[-&lt;+]-      go to current cell
          &gt;&gt;-             decrement temp
          [               if temp != 0
            +[-&gt;+]          go to marked cell
            +               set cellFlag = normal
            &gt;&gt;&gt;&gt;--          set cellFlag of next cell = marker
            &lt;+[-&lt;+]-&gt;&gt;      return to currentCell temp
            [&lt;&lt;&lt;+&gt;&gt;&gt;-]      store value of temp in previous cell bombCount (to exit if)
          ]
          &lt;&lt;&lt;[&gt;&gt;&gt;+&lt;&lt;&lt;-]&gt;&gt;&gt;restore temp value
        ]
        +[-&gt;+]          go to marked cell
        +               set cellFlag = normal
        &lt;&lt;&lt;&lt;--          set previous cellFlag = marker
        &lt;+[-&lt;+]-        return to current cell

        # print
        &gt;-[             if bomb
          &gt;&gt;[-]&lt;&lt;         delete bombCount
          ++++++[&gt;++++++&lt;-]&gt;.print "*"
          [-]+            set temp = 1
          &lt;&lt;&lt;             use previous cell bombCount as exitIf
        ]
        &lt;[              else
          &gt;&gt;&gt;[            if bombCount != 0
            &lt;++++++[&gt;++++++++&lt;-]add 48 to get ascii number
            &gt;.              print
            [-]             set number = 0 (for use as exitIf from next cell)
            &lt;               go to temp for exit if
          ]
          &lt;&lt;&lt;[            else
            &lt;++++++++[&lt;+++++++++++&gt;-]&lt;.print "X"
            [-]             delete value (for use as exitIf from next cell)
            &gt;               go to exitIf
          ]
          &lt;               go to exitElse
        ]
        &gt; &gt;&gt;&gt;+          increment temp
        &lt;&lt;++&gt;           set cellFlag = normal
      ]
      &gt;[&lt;+&gt;-]         restore cellState
      &gt;&gt;              go to cellFlag of next cell
    ]
    -               set marker
    &gt;+[-&gt;+]         go to next marker
    +               set cellFlag = normal
    +[-&lt;+]          return to marker
    +++++ +++++.[-] print newline
  ]
  &gt;               go to next row
]
</code></pre>
</div>
<div id="pu7" class="pu"><h1>Scala, 280 chars</h1>

<pre><code>val n=readLine split" "map{_.toInt}
val b=Array.fill(n(1),n(0))(0)
n drop 2 sliding(2,2)foreach{case Array(x,y)=&gt;b(y-1)(x-1)=9
for{i&lt;-(x-2 max 0)to(x min n(0)-1);j&lt;-(y-2 max 0)to(y min n(1)-1)}b(j)(i)+=1}
b.map{r=&gt;println(r.map{case 0=&gt;"x"case x if x&gt;8=&gt;"*"case x=&gt;""+x}mkString)}
</code></pre>
</div>
<div id="pu8" class="pu"><p><strong>ECMAScript 2019 (Modern Javascript) - 116 bytes</strong></p>

<pre><code>m.map((r,i)=&gt;r.map((c,j)=&gt;c=='X'?c:[,...m].splice(i,3).map(r=&gt;[,...r].splice(j,3)).flat().filter(v=&gt;v=='X').length))
</code></pre>

<p><strong>ungolfed version</strong></p>

<pre><code>m.map(
  (r,i) =&gt; r.map(
    (c,j) =&gt; c=='X' ? c :
      [,...m].splice(i,3).map(r=&gt;[,...r].splice(j,3)).flat().filter(v=&gt;v=='X').length
  )
)
</code></pre>

<p><em>this solution doesn't strictly adhere to the input/output format but demonstrates a succinct algorithm.</em></p>

<p>example:
<a href="https://gist.github.com/missinglink/ee02084cfb523665e8c9d34c24f01537" rel="nofollow noreferrer">https://gist.github.com/missinglink/ee02084cfb523665e8c9d34c24f01537</a></p>
</div>
<div id="pu9" class="pu"><h2>Python, <strike>192</strike> <strike>182</strike> 180 chars</h2>

<p>I could save some if the input was comma-separated. Then the first line would be <code>d=input()</code> and the length 171 chars.<br>
Having the mine coordinates 0-based rather than 1-based would also help. It cost me 8 chars to overcome.</p>

<pre><code>d=map(int,raw_input().split())
m=zip(d[2::2],d[3::2])
for y in range(d[1]):print"".join((str(sum(abs(a-x-1)|abs(b-y-1)&lt;2for a,b in m)or'x')+'*')[(x+1,y+1)in m]for x in range(d[0]))
</code></pre>

<p>Ungolfed version:</p>

<pre class="lang-py prettyprint-override"><code>d=map(int,raw_input().split())          # Read whitespace terminated numbers into a list of numbers
xsize,ysize = d[:2]                     # The first two numbers are the board size
mines=zip(d[2::2],d[3::2])              # Convert items 3,4,5,6... to pairs (3,4),(5,6) representine mine coordinates

def dist(point,mine):                   # Distance between point (0-based coordinates) and mine (1-based coordinates)
    dx = abs(mine[0]-(point[0]+1))
    dy = abs(mine[1]-(point[1]+1))
    return dx | dy                      # Should be max(dx,dy), but this is close enough. Wrong for d&gt;=2, but returns &gt;=2 in this case.

for y in range(ysize):                  # Print lines one by one
    line_chars = [
        (str(
            sum(dist((x,y),(a,b))&lt;2 for a,b in mines)   # Number of neighboring mines
            or 'x'                                  # 'x' instead of 0
        )
        +'*')                                       # For a single neighbor, we get "1*"
        [(x+1,y+1)in mines]                         # If a mine, get the '*', else the neighbor number
        for x in range(xsize)
    ]
    print "".join(line_chars)
</code></pre>
</div>
<div id="pu10" class="pu"><p></p>

<h2>VBA - 298 chars</h2>

<pre class="lang-vb prettyprint-override"><code>Sub m(x,y,ParamArray a())
On Error Resume Next:ReDim b(x,y):For i=0 To (UBound(a)-1) Step 2:c=a(i):d=a(i+1):b(c,d)="*":For e=c-1 To c+1:For f=d-1 To d+1:v=b(e,f):If v&lt;&gt;"*" Then b(e,f)=v+1
Next:Next:Next:For f=1 To y:For e=1 To x:v=b(e,f):s=s &amp; IIf(v&lt;&gt;"",v,"x")
Next:s=s &amp; vbCr:Next:MsgBox s
End Sub
</code></pre>

<p>Skipping over errors with <code>On Error Resume Next</code> saved me some characters, but this still isn't nearly as good as some of the other answers. :-/</p>
</div>
<div id="pu11" class="pu"><h2><em>Mathematica</em>, <s>140</s> <s>139</s> 137</h2>

<pre><code>Grid[(ListConvolve[BoxMatrix@1,#,2,0]/. 0-&gt;x)(1-#)/. 0-&gt;"*"]&amp;@Transpose@SparseArray[{##2}-&gt;1,#]&amp;@@#~Partition~2&amp;@@#~ImportString~"Table"&amp;
</code></pre>

<p>Writing that in a more readable form:</p>

<pre><code>"5 5 1 3 3 5 2 4"

ImportString[%, "Table"][[1]] ~Partition~ 2

Transpose @ SparseArray[{##2} -&gt; 1, #]&amp; @@ %

ListConvolve[BoxMatrix@1, %, 2, 0]

(% /. 0 -&gt; x) (1 - %%) /. 0 -&gt; "*" // Grid
</code></pre>
</div>
<div id="pu12" class="pu"><h1>K, 175</h1>

<pre><code>f:{g::(y;x)#(x*y)#"x";{.[`g;x;:;"*"]}@'-1+|:'(_(#z)%2;2)#z;{if[~"0"~z;$["x"=g .(x;y);.[`g;(x;y);:;z];]]}.'i,'$s:+/'{"*"=g . x}''{,/((x-1)+!3),\:/:(y-1)+!3}.'i:,/(!x),\:/:!y;g}
</code></pre>

<p>.</p>

<pre><code>k)f[5;5;1 3 3 5 2 4]
"xxxxx"
"11xxx"
"*21xx"
"2*21x"
"12*1x"
k)f[3;4;3 1 1 4 2 3 3 2]
"x2*"
"13*"
"2*2"
"*21"
</code></pre>
</div>
<div id="pu13" class="pu"><p><strong>C# (691 Chars)</strong></p>

<pre><code>using System;namespace M{class P{static char C(char[][] g,int r,int c){int n=0;for(int i=r-1;i&lt;=r+1;i++){if(i&lt;0||i&gt;=g.Length)continue;for(int j=c-1;j&lt;=c+1;j++){if((j&lt;0||j&gt;=g[0].Length)||(i==r&amp;&amp;j==c))continue;if(g[i][j]=='*')n++;}}return n==0?'x':(char)(n+48);}static char[][] G(int[] p){char[][] r=new char[p[1]][];for(int i=0;i&lt;r.Length;i++)r[i]=new char[p[0]];for(int i=2;i&lt;p.Length;){r[p[i+1]-1][p[i]-1]='*';i+=2;}for(int i=0;i&lt;r.Length;i++)for(int j=0; j&lt;r[0].Length;j++)if(r[i][j]!='*')r[i][j]=C(r,i,j);for(int i=0;i&lt;r.Length;i++){for(int j=0;j&lt;r[0].Length;j++)Console.Write(r[i][j]);Console.WriteLine();}return r;}static void Main(string[] args){G(new int[]{3,4,3,1,1,4,2,3,3,2});}}}
</code></pre>

<p>Non-golfed Version:</p>

<pre><code>using System;
namespace M
{
    class P
    {
        static char C(char[][] g, int r, int c)
        {
            int n = 0;
            for (int i = r - 1; i &lt;= r + 1; i++)
            {
                if (i &lt; 0 || i &gt;= g.Length) continue;
                for (int j = c - 1; j &lt;= c + 1; j++)
                {
                    if ((j &lt; 0 || j &gt;= g[0].Length) || (i == r &amp;&amp; j == c)) continue;
                    if (g[i][j] == '*') n++;
                }
            }
            return n == 0 ? 'x' : (char)(n + 48);
        }

        static char[][] G(int[] p)
        {
            char[][] r = new char[p[1]][];
            for (int i = 0; i &lt; r.Length; i++)
                r[i] = new char[p[0]];
            for (int i = 2; i &lt; p.Length; )
            {
                r[p[i + 1] - 1][p[i] - 1] = '*';
                i += 2;
            }
            for (int i = 0; i &lt; r.Length; i++)
                for (int j = 0; j &lt; r[0].Length; j++)
                    if (r[i][j] != '*') r[i][j] = C(r, i, j);
            for (int i = 0; i &lt; r.Length; i++)
            {
                for (int j = 0; j &lt; r[0].Length; j++)
                    Console.Write(r[i][j]);
                Console.WriteLine();
            } return r;
        } 
        static void Main(string[] args) 
        { 
            G(new int[] { 3, 4, 3, 1, 1, 4, 2, 3, 3, 2 }); 
        }
    }
}
</code></pre>
</div>
<div id="pu14" class="pu"><h2>C++ - 454 chars</h2>

<p>This is worse than my VBA answer, which probably means I don't know what I'm doing in C++. However, I am trying to build on what I know of C++, so here it is. If anyone has any suggestions for improvement, I'd be grateful to hear them!</p>

<pre><code>#define Z for(int i=
#define Y for(int j=
#define X d[i][j]
#define W Z 0;i&lt;x;i++){
#define V Y 0;j&lt;y;j++){
#define U cout&lt;&lt;
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main(){using namespace std;int x,y,a,b;cin&gt;&gt;y&gt;&gt;x;string c[x][y];int d[x][y];W V X=0;}}while(cin&gt;&gt;b&gt;&gt;a){c[--a][--b]="*";Z a-1;i&lt;=a+1;i++){Y b-1;j&lt;=b+1;j++){if(x&gt;i&amp;&amp;i&gt;=0&amp;&amp;y&gt;j&amp;&amp;j&gt;=0){X=X+1;}}}}W V if(c[i][j]!="*"){if(X&gt;0){U X;}else{U"x";}}else{U"*";}}U endl;}return 0;}
</code></pre>
</div>
<div id="pu15" class="pu"><h2>J, <strike>124</strike> <strike>116</strike> <strike>112</strike> <strike>101</strike> <strike>87</strike> <strike>86</strike> <strike>85</strike> <strike>84</strike> <strike>83</strike> <strike>82</strike> <strike>79</strike> <strike>76</strike> <strike>75</strike> <strike>72</strike> 68 characters</h2>

<pre><code>'0x'charsub|:1":3 3(+/@,+9*4&amp;{@,);._3[1(}.x)}0$~2+&gt;{.x=._2&lt;\".1!:1[1
</code></pre>

<p>Found what I was looking for - a way to get rid of the spaces (<code>1":</code>) - and finally I'm competitive. Now I just need to figure out the empty set of mines problem.</p>

<p>Takes input from the keyboard.</p>

<p><strong>Edit</strong></p>

<p>New version makes use of a side effect of <code>1":</code> - numbers larger than 9 are replaced by <code>*</code>.</p>
</div>
<div id="pu16" class="pu"><h3>GolfScript <s>122 98 94 93 91 88 87 85 82 81 80</s> 71</h3>

<pre><code>~]2/(\:m;~\:w*,{[.w%)\w/)]:^m\?)42{m{^*~-.*@@-.*+3&lt;},,72or 48+}if}%w/n*
</code></pre>

<p><strong>Online demos:</strong></p>

<p>Test Case 1: <a href="http://golfscript.apphb.com/?c=OyI1IDUgMSAzIDMgNSAyIDQiCgp%2BXTIvKFw6bTt%2BXDp3Kix7Wy53JSlcdy8pXTpebVw%2FKTQye217Xip%2BLS4qQEAtLiorMzx9LCw3Mm9yIDQ4K31pZn0ldy9uKg%3D%3D&amp;run=true">link</a></p>

<p>Test Case 2: <a href="http://golfscript.apphb.com/?c=OyIzIDQgMyAxIDEgNCAyIDMgMyAyIgoKfl0yLyhcOm07flw6dyose1sudyUpXHcvKV06Xm1cPyk0Mntte14qfi0uKkBALS4qKzM8fSwsNzJvciA0OCt9aWZ9JXcvbio%3D&amp;run=true">link</a></p>
</div>
<div id="pu17" class="pu"><h1>Mathematica - 247 chars</h1>
<pre><code>s[q_] :=
  Module[{d, r},
    d = ToExpression@Partition[Cases[Characters@q, Except@&quot; &quot;], 2];
    r = Rest@d;
    StringJoin @@@ 
    ReplacePart[
    Table[ToString@
       Count[ChessboardDistance[{i, j}, #] &amp; /@ Reverse /@ r, 1], {i,d[[1, 2]]}, 
       {j, d[[1, 1]]}] /. {&quot;0&quot; -&gt; &quot;x&quot;}, # -&gt; &quot;*&quot; &amp; /@ Reverse /@ r] // TableForm]
</code></pre>
<p>Examples:</p>
<pre><code>s@&quot;5 5 1 3 3 5 2 4&quot;
s@&quot;3 4 3 1 1 4 2 3 3 2&quot;
</code></pre>
<p>Output:</p>
<p><img src="https://i.sstatic.net/SOq1Y.png" alt="output" /></p>
<p><code>ChessboardDistance</code> computes how far each cell is from a mine, where 1 corresponds to &quot;next to a mine&quot;.  The <code>Count</code> of 1's yields the cell's number. Then mines (*) are inserted into array.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/6474/">6474</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




