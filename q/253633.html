<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::253633</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td>Rust</td><td>250210T124501Z</td><td><a href="https://codegolf.stackexchange.com/questions/253633/the-smallest-area-of-a-convex-grid-polygon/278190#278190">138 Aspe</a></td></tr>
<tr d-ix="1"><td>442</td><td>Python</td><td>230914T172220Z</td><td><a href="https://codegolf.stackexchange.com/questions/253633/the-smallest-area-of-a-convex-grid-polygon/265224#265224">G&#252;n</a></td></tr>
<tr d-ix="2"><td>447</td><td>Rust</td><td>230918T235824Z</td><td><a href="https://codegolf.stackexchange.com/questions/253633/the-smallest-area-of-a-convex-grid-polygon/265355#265355">colt_bro</a></td></tr>
<tr d-ix="3"><td>323</td><td>Fortran n=17</td><td>221029T125913Z</td><td><a href="https://codegolf.stackexchange.com/questions/253633/the-smallest-area-of-a-convex-grid-polygon/253908#253908">Hugo Pfo</a></td></tr>
<tr d-ix="4"><td>010</td><td>Python with restricted conditions n=26</td><td>221024T215157Z</td><td><a href="https://codegolf.stackexchange.com/questions/253633/the-smallest-area-of-a-convex-grid-polygon/253721#253721">arrmansa</a></td></tr>
<tr d-ix="5"><td>nan</td><td>Rust + itertools + fasthash</td><td>221027T091656Z</td><td><a href="https://codegolf.stackexchange.com/questions/253633/the-smallest-area-of-a-convex-grid-polygon/253808#253808">corvus_1</a></td></tr>
<tr d-ix="6"><td>162</td><td>C++ gcc</td><td>221026T165707Z</td><td><a href="https://codegolf.stackexchange.com/questions/253633/the-smallest-area-of-a-convex-grid-polygon/253788#253788">jdt</a></td></tr>
<tr d-ix="7"><td>019</td><td>JavaScript Node.js</td><td>221023T151044Z</td><td><a href="https://codegolf.stackexchange.com/questions/253633/the-smallest-area-of-a-convex-grid-polygon/253655#253655">Arnauld</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Rust, <span class="math-container">\$n=16\$</span> in ~ 2.65 seconds</h1>
<p>Rust port of @jdt's C++ answer.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=8a5c0c3f6b2f39281e44c5046c3c0316" rel="nofollow noreferrer">Run it on RustPlayground!</a></p>
<pre class="lang-rust prettyprint-override"><code>use std::time::{Instant};

#[derive(Clone, Copy, Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn create_polygon_jit(
    points: &amp;mut [Point],
    n: usize,
    target_n: usize,
    gridsize: i32,
    curr_area: i32,
    min_area: &amp;mut i32,
    soln: &amp;mut [Point],
) -&gt; bool {
    if n &gt;= 3 {
        let x1 = points[n - 3].x - points[n - 2].x;
        let y1 = points[n - 3].y - points[n - 2].y;
        let x2 = points[n - 1].x - points[n - 2].x;
        let y2 = points[n - 1].y - points[n - 2].y;

        if x1 * y2 - x2 * y1 &lt;= 0 {
            return false;
        }
        if x1 * x2 + y1 * y2 &gt; 0 {
            return false;
        }
        if points[1].x == 0 &amp;&amp; points[n - 1].x == 0 {
            return true;
        }

        let add_area = points[n - 1].x * points[n - 2].y - points[n - 1].y * points[n - 2].x;
        if add_area &lt;= 0 {
            return true;
        }

        let curr_area = curr_area + add_area;
        if curr_area &gt;= *min_area {
            return true;
        }

        if n == target_n {
            *min_area = curr_area;
            soln.copy_from_slice(&amp;points[..target_n]);
            return true;
        }

        let min_i = (points[n - 1].x - 3).max(0);
        let max_i = (points[n - 1].x + 4).min(gridsize);
        let min_j = (points[n - 1].y - 3).max(-gridsize / 2);
        let max_j = (points[n - 1].y + 4).min(gridsize / 2 + 1);

        if x2 &gt; 0 {
            if y2 &gt; 0 {
                if x2 &gt; y2 {
                    for j in min_j..max_j {
                        for i in (min_i..max_i).rev() {
                            points[n] = Point { x: i, y: j };
                            if !create_polygon_jit(points, n + 1, target_n, gridsize, curr_area, min_area, soln) {
                                break;
                            }
                        }
                        if points[n].x == max_i - 1 {
                            break;
                        }
                    }
                } else {
                    for j in (min_j..max_j).rev() {
                        for i in (min_i..max_i).rev() {
                            points[n] = Point { x: i, y: j };
                            if !create_polygon_jit(points, n + 1, target_n, gridsize, curr_area, min_area, soln) {
                                break;
                            }
                        }
                        if points[n].x == max_i - 1 {
                            break;
                        }
                    }
                }
            } else {
                if x2 &gt; -y2 {
                    for i in (min_i..max_i).rev() {
                        for j in min_j..max_j {
                            points[n] = Point { x: i, y: j };
                            if !create_polygon_jit(points, n + 1, target_n, gridsize, curr_area, min_area, soln) {
                                break;
                            }
                        }
                        if points[n].y == min_j {
                            break;
                        }
                    }
                } else {
                    for i in min_i..max_i {
                        for j in min_j..max_j {
                            points[n] = Point { x: i, y: j };
                            if !create_polygon_jit(points, n + 1, target_n, gridsize, curr_area, min_area, soln) {
                                break;
                            }
                        }
                        if points[n].y == min_j {
                            break;
                        }
                    }
                }
            }
        } else {
            if y2 &gt; 0 {
                if -x2 &gt; y2 {
                    for i in min_i..max_i {
                        for j in (min_j..max_j).rev() {
                            points[n] = Point { x: i, y: j };
                            if !create_polygon_jit(points, n + 1, target_n, gridsize, curr_area, min_area, soln) {
                                break;
                            }
                        }
                        if points[n].y == max_j - 1 {
                            break;
                        }
                    }
                } else {
                    for i in (min_i..max_i).rev() {
                        for j in (min_j..max_j).rev() {
                            points[n] = Point { x: i, y: j };
                            if !create_polygon_jit(points, n + 1, target_n, gridsize, curr_area, min_area, soln) {
                                break;
                            }
                        }
                        if points[n].y == max_j - 1 {
                            break;
                        }
                    }
                }
            } else {
                if -x2 &gt; -y2 {
                    for j in (min_j..max_j).rev() {
                        for i in min_i..max_i {
                            points[n] = Point { x: i, y: j };
                            if !create_polygon_jit(points, n + 1, target_n, gridsize, curr_area, min_area, soln) {
                                break;
                            }
                        }
                        if points[n].x == min_i {
                            break;
                        }
                    }
                } else {
                    for j in min_j..max_j {
                        for i in min_i..max_i {
                            points[n] = Point { x: i, y: j };
                            if !create_polygon_jit(points, n + 1, target_n, gridsize, curr_area, min_area, soln) {
                                break;
                            }
                        }
                        if points[n].x == min_i {
                            break;
                        }
                    }
                }
            }
        }
    } else {
        let min_i = (points[n - 1].x - 3).max(0);
        let max_i = (points[n - 1].x + 4).min(gridsize);
        let min_j = (points[n - 1].y - 3).max(-gridsize / 2);
        let max_j = (points[n - 1].y + 4).min(gridsize / 2);

        for i in min_i..max_i {
            for j in min_j..max_j {
                points[n] = Point { x: i, y: j };
                create_polygon_jit(points, n + 1, target_n, gridsize, curr_area, min_area, soln);
            }
        }
    }
    points[n] = Point { x: 0, y: 0 };
    true
}

fn main() {
    let start = Instant::now();

    const N: usize = 16;
    let mut points = [Point { x: 0, y: 0 }; N];
    let gridsize = 11;
    let mut min_area = gridsize * gridsize;
    let mut result = [Point { x: 0, y: 0 }; N];

    create_polygon_jit(&amp;mut points, 1, N, gridsize, 0, &amp;mut min_area, &amp;mut result);

    println!(&quot;Result: &quot;);
    for p in &amp;result {
        println!(&quot;({}, {})&quot;, p.x, p.y);
    }
    println!(&quot;Area: {}&quot;, min_area);

    let duration = start.elapsed();
    println!(&quot;Time: {:?} seconds.&quot;, duration.as_secs_f64());
}
</code></pre>
</div>
<div id="pu1" class="pu"><h1>Python, <em>n</em>=44 in under 2 minutes</h1>
<p>This can go up to 44-gons in under 2 minutes, using pypy on my laptop.
CPython is slightly slower (2'45'').</p>
<p>The approach is rigorous. It uses the
dynamic programming
algorithm in the following paper:</p>
<ul>
<li><p>David Eppstein, Mark Overmars, Günter Rote und Gerhard Woeginger,
Finding minimum area k-gons.
<em>Discrete and Computational Geometry</em> <strong>7</strong> (1992), 45-58.
<a href="https://doi.org/10.1007/BF02187823" rel="nofollow noreferrer">https://doi.org/10.1007/BF02187823</a></p>
</li>
<li><p>see also:
Joseph S. B. Mitchell, Günter Rote, Gopalakrishnan Sundaram,
and Gerhard Woeginger,
Counting convex polygons in planar point sets.
<em>Information Processing Letters</em> <strong>56</strong> (1995), 45-49.
<a href="http://page.mi.fu-berlin.de/rote/Papers/abstract/Counting+k-subsets+and+convex+k-gons+in+the+plane.html" rel="nofollow noreferrer">http://page.mi.fu-berlin.de/rote/Papers/abstract/Counting+k-subsets+and+convex+k-gons+in+the+plane.html</a></p>
</li>
</ul>
<p>The algorithm is also explained in the comments of the code.</p>
<p>Here are some smallest polygons:</p>
<ul>
<li>20-gon, area=242/2: [(0,0),(3,1),(5,2),(6,3),(7,5),(7,6),(6,8),(5,9),(3,10),(0,11),(-1,11),(-4,10),(-6,9),(-7,8),(-8,6),(-8,5),(-7,3),(-6,2),(-4,1),(-1,0)]</li>
<li>21-gon, area=289/2: [(0,0),(2,1),(5,3),(6,4),(8,7),(9,9),(10,12),(10,13),(9,14),(7,15),(6,15),(3,14),(1,13),(-2,11),(-3,10),(-4,8),(-5,5),(-5,4),(-4,2),(-3,1),(-1,0)]</li>
<li>22-gon, area=328/2: [(0,0),(3,1),(5,2),(8,4),(9,5),(10,7),(10,8),(9,10),(8,11),(6,12),(3,13),(2,13),(-1,12),(-3,11),(-6,9),(-7,8),(-8,6),(-8,5),(-7,3),(-6,2),(-4,1),(-1,0)]</li>
<li>23-gon, area=387/2: [(0,0),(3,1),(5,2),(6,3),(7,5),(8,8),(8,9),(7,11),(6,12),(4,13),(1,14),(0,14),(-4,13),(-7,12),(-9,11),(-10,10),(-11,8),(-11,7),(-10,5),(-9,4),(-6,2),(-4,1),(-1,0)]</li>
<li>24-gon, area=420/2: [(0,0),(3,1),(5,2),(8,4),(9,5),(11,8),(12,10),(13,13),(13,14),(12,16),(11,17),(9,18),(8,18),(5,17),(3,16),(0,14),(-1,13),(-3,10),(-4,8),(-5,5),(-5,4),(-4,2),(-3,1),(-1,0)]</li>
<li>25-gon, area=497/2: [(0,0),(3,1),(5,2),(8,4),(9,5),(10,7),(11,10),(11,11),(10,13),(9,14),(7,15),(4,16),(3,16),(-1,15),(-4,14),(-6,13),(-9,11),(-10,10),(-11,8),(-11,7),(-10,5),(-9,4),(-6,2),(-4,1),(-1,0)]</li>
<li>26-gon, area=548/2: [(0,0),(3,1),(5,2),(8,4),(9,5),(11,8),(12,10),(13,13),(13,14),(12,16),(11,17),(9,18),(6,19),(5,19),(2,18),(0,17),(-3,15),(-4,14),(-6,11),(-7,9),(-8,6),(-8,5),(-7,3),(-6,2),(-4,1),(-1,0)]</li>
<li>27-gon, area=625/2: [(0,0),(3,1),(5,2),(8,4),(9,5),(11,8),(12,10),(13,13),(14,17),(14,18),(13,20),(12,21),(10,22),(9,22),(6,21),(4,20),(1,18),(-3,15),(-4,14),(-6,11),(-7,9),(-8,6),(-8,5),(-7,3),(-6,2),(-4,1),(-1,0)]</li>
<li>28-gon, area=690/2: [(0,0),(4,1),(7,2),(9,3),(12,5),(13,6),(15,9),(16,11),(17,14),(17,15),(16,17),(15,18),(13,19),(10,20),(9,20),(5,19),(2,18),(0,17),(-3,15),(-4,14),(-6,11),(-7,9),(-8,6),(-8,5),(-7,3),(-6,2),(-4,1),(-1,0)]</li>
<li>29-gon, area=783/2: [(0,0),(3,1),(5,2),(8,4),(9,5),(12,9),(14,12),(15,14),(16,17),(16,18),(15,20),(14,21),(12,22),(9,23),(8,23),(4,22),(1,21),(-1,20),(-4,18),(-5,17),(-7,14),(-8,12),(-9,9),(-9,8),(-8,5),(-7,3),(-6,2),(-4,1),(-1,0)]</li>
<li>30-gon, area=860/2: [(0,0),(4,1),(7,2),(9,3),(12,5),(13,6),(15,9),(16,11),(17,14),(17,15),(16,18),(15,20),(14,21),(12,22),(9,23),(8,23),(4,22),(1,21),(-1,20),(-4,18),(-5,17),(-7,14),(-8,12),(-9,9),(-9,8),(-8,5),(-7,3),(-6,2),(-4,1),(-1,0)]</li>
<li>31-gon, area=967/2: [(0,0),(4,1),(7,2),(9,3),(12,5),(13,6),(15,9),(16,11),(17,14),(18,18),(18,19),(17,22),(16,24),(15,25),(13,26),(12,26),(8,25),(5,24),(3,23),(0,21),(-4,18),(-5,17),(-7,14),(-8,12),(-9,9),(-9,8),(-8,5),(-7,3),(-6,2),(-4,1),(-1,0)]</li>
<li>32-gon, area=1046/2: [(0,0),(3,1),(5,2),(8,4),(9,5),(11,8),(12,10),(13,13),(13,14),(12,17),(11,19),(9,22),(8,23),(5,25),(3,26),(0,27),(-1,27),(-4,26),(-6,25),(-9,23),(-10,22),(-12,19),(-13,17),(-14,14),(-14,13),(-13,10),(-12,8),(-10,5),(-9,4),(-6,2),(-4,1),(-1,0)]</li>
<li>33-gon, area=1177/2: [(0,0),(3,1),(5,2),(8,4),(12,7),(13,8),(16,12),(18,15),(19,17),(20,20),(21,24),(21,25),(20,27),(19,28),(17,29),(14,30),(13,30),(9,29),(6,28),(4,27),(1,25),(-3,22),(-4,21),(-6,18),(-7,16),(-8,13),(-9,9),(-9,8),(-8,5),(-7,3),(-6,2),(-4,1),(-1,0)]</li>
<li>34-gon, area=1264/2: [(0,0),(4,1),(7,2),(9,3),(12,5),(13,6),(15,9),(16,11),(17,14),(17,15),(16,18),(15,20),(13,23),(12,24),(9,26),(7,27),(4,28),(3,28),(-1,27),(-4,26),(-6,25),(-9,23),(-10,22),(-12,19),(-13,17),(-14,14),(-14,13),(-13,10),(-12,8),(-10,5),(-9,4),(-6,2),(-4,1),(-1,0)]</li>
<li>35-gon, area=1409/2: [(0,0),(4,1),(7,2),(9,3),(12,5),(13,6),(15,9),(16,11),(17,14),(17,15),(16,18),(15,20),(13,23),(12,24),(10,25),(7,26),(3,27),(2,27),(-3,26),(-7,25),(-10,24),(-12,23),(-15,21),(-16,20),(-17,18),(-18,15),(-18,14),(-17,11),(-16,9),(-14,6),(-13,5),(-10,3),(-8,2),(-5,1),(-1,0)]</li>
<li>36-gon, area=1498/2: [(0,0),(4,1),(7,2),(9,3),(12,5),(13,6),(15,9),(16,11),(17,14),(17,15),(16,18),(15,20),(13,23),(12,24),(9,26),(7,27),(4,28),(0,29),(-1,29),(-5,28),(-8,27),(-10,26),(-13,24),(-14,23),(-16,20),(-17,18),(-18,15),(-18,14),(-17,11),(-16,9),(-14,6),(-13,5),(-10,3),(-8,2),(-5,1),(-1,0)]</li>
<li>37-gon, area=1671/2: [(0,0),(4,1),(7,2),(9,3),(12,5),(13,6),(16,10),(18,13),(19,15),(20,18),(20,19),(19,22),(18,24),(17,25),(14,27),(12,28),(9,29),(5,30),(4,30),(-1,29),(-5,28),(-8,27),(-10,26),(-13,24),(-14,23),(-16,20),(-17,18),(-18,15),(-18,14),(-17,11),(-16,9),(-14,6),(-13,5),(-10,3),(-8,2),(-5,1),(-1,0)]</li>
<li>38-gon, area=1780/2: [(0,0),(4,1),(7,2),(9,3),(12,5),(13,6),(15,9),(16,11),(17,14),(18,18),(18,19),(17,22),(16,24),(14,27),(13,28),(10,30),(8,31),(5,32),(1,33),(0,33),(-4,32),(-7,31),(-9,30),(-12,28),(-13,27),(-15,24),(-16,22),(-17,19),(-18,15),(-18,14),(-17,11),(-16,9),(-14,6),(-13,5),(-10,3),(-8,2),(-5,1),(-1,0)]</li>
<li>39-gon, area=1955/2: [(0,0),(4,1),(7,2),(9,3),(12,5),(13,6),(15,9),(16,11),(17,14),(18,18),(18,19),(17,22),(16,24),(14,27),(13,28),(10,30),(8,31),(5,32),(1,33),(0,33),(-5,32),(-9,31),(-12,30),(-14,29),(-17,27),(-18,26),(-20,23),(-21,21),(-22,18),(-22,17),(-21,14),(-20,12),(-18,9),(-17,8),(-13,5),(-10,3),(-8,2),(-5,1),(-1,0)]</li>
<li>40-gon, area=2078/2: [(0,0),(4,1),(7,2),(9,3),(12,5),(13,6),(15,9),(16,11),(17,14),(18,18),(18,19),(17,23),(16,26),(15,28),(13,31),(12,32),(9,34),(7,35),(4,36),(0,37),(-1,37),(-5,36),(-8,35),(-10,34),(-13,32),(-14,31),(-16,28),(-17,26),(-18,23),(-19,19),(-19,18),(-18,14),(-17,11),(-16,9),(-14,6),(-13,5),(-10,3),(-8,2),(-5,1),(-1,0)]</li>
</ul>
<p>The target value of N can be given on the command line.</p>
<h2>The minimum area of a convex polygon of given lattice width</h2>
<p>The correctness of the program (knowing when one can stop) depends crucially on two lemmas that relate area to <em>lattice width</em>. The first lemma is about centrally symmetric polygons (arising when <em>n</em> is even), and the second lemma about arbitrary polygons.</p>
<p><strong>Definition:</strong>
The <em>lattice width</em> of a lattice polygon P <em>in a given lattice direction</em>
(a,b) in Z² is one less than the number of lattice lines orthogonal to (a,b)
intersecting P.
The <em>lattice width</em> of P is the smallest number lattice width over
all lattice directions.</p>
<h3>Lemma 3:</h3>
<blockquote>
<p>A centrally symmetric convex polygon P of lattice width w has area
at least w²/2.</p>
</blockquote>
<p>Proof:
[ A weaker bound of w²/4 is given in the following paper
(p.175, before remark 2):</p>
<ul>
<li>Imre Bárány and Norihide Tokushige, The minimum area of convex lattice n-gons.
<em>Combinatorica</em> <strong>24</strong> (No. 2, 2004), 171-185.
<a href="https://www.renyi.hu/%7Ebarany/cikkek/94.pdf" rel="nofollow noreferrer">https://www.renyi.hu/~barany/cikkek/94.pdf</a>.</li>
</ul>
<p>Our proof uses the same setup but refines the argument in the end.
The improvement to w²/2 speeds up the computations by a factor 5-6. ]</p>
<ol>
<li><p>We assume that the lattice width direction is vertical.
Thus P touches two horizontal lines H+: y=b and H-: y=-b, with b=w/2.
Let (a,0) be the intersection of P with the positive x-axis.</p>
</li>
<li><p>If a&gt;=b, then the area is at least 2b²=w²/2, and we are done.
Thus, let us assume a&lt;b.</p>
</li>
<li><p>By horizontal shearing, we assume that the tangent at (a,0)
(or some supporting line) is not vertical and has slope s at least +1.
(Since horizontal lattice-preserving shearing changes the &quot;inverse
slope&quot; 1/s in increments of 1, the inverse slope can always be brought into
the interval (0,1].)</p>
</li>
<li><p>The lattice width in direction (1,0) is b'&gt;=b. Thus
P touches two vertical lines V+: x=b' and V-: x=-b'</p>
</li>
<li><p>The lattice width in direction (1,-1) is b&quot;&gt;=b. Thus
P touches two diagonal lines D+: y-x=b&quot; and D-: y-x=-b&quot;
(Draw a picture!)</p>
</li>
<li><p>If (a,0) had tangent of slope 1, P could not touch D-, since a&lt;b&quot;.</p>
<p>Thus the slope s is strictly larger than 1, and P must touch V+
in the upper half-plane, and P must touch D- in the lower half-plane.</p>
</li>
<li><p>If the intersection of V+ and D- is below the x-axis,
we swap the roles of V+ and D- by a horizontal shearing transformation
combined with a vertical reflection: Each point (x,y) is mapped to (x-y,-y).
This turns V+ into a line of slope 1 and makes D- vertical.
Point on the x-axis are fixed.</p>
<p>Thus we can assume that the intersection of V+ and D- is above or
on the x-axis, at (b',c) with c&gt;=0.</p>
</li>
<li><p>Pick a point where P touches each of the six lines, in a symmetric way.
Denote them by B,BR,R (Bottom, Bottom-Right, and Right) and the reflected
points by T,TL,L. (Draw a picture!)
Replace P by the convex hull of these points (making the area smaller).</p>
</li>
<li><p>Holding L,B,R, and T fixed, we can move the points BR and TL on their
respective lines D- and D+, keeping them symmetric.
The area depends linearly on the movement.</p>
<p>If the are would decrease when BR is moved towards R and towards V+,
we can stop this movement at the point (b&quot;,0) where D- intersects
the x-axis. The convex hull of (b&quot;,0),(-b&quot;,0),T,B has area 2b&quot;b&gt;w²/2.</p>
</li>
<li><p>Thus we are left with the case that we can decrease the area by
moving BR towards H-, reaching the point B'=(d,-b) with d := b&quot;-1&gt;=0.
Then we consider the convex hull of B', R, and their two
symmetric points. R has coordinates R=(b',e) with e&gt;=c&gt;=0.
The determinant of (d,-b) and (b',e) is bb'+de&gt;=bb'&gt;=b², and we are done.</p>
</li>
</ol>
<p>QED.</p>
<h3>Lemma 4:</h3>
<blockquote>
<p>A (not necessarily symmetric) convex polygon P of lattice width w
has area at least w²/3.
The inequality is strict except when P is a triangle.</p>
</blockquote>
<p>Proof:
The polygon P and the symmetrized version Q = 1/2 * (P-P)
(which is half the &quot;difference body&quot; P-P={ a-b | a,b in P }),
have the same width in every direction, and Q is centrally
symmetric. We can apply Lemma 3 to Q.
The area of Q is at most 3/2 times the area of P, and
equality holds only when P is a triangle.
See any of the following papers. QED</p>
<ul>
<li>Hans Rademacher, Über den Vektorenbereich eines konvexen ebenen Bereiches.
<em>Jahresbericht d. Deutschen Math.-Verein.</em> <strong>34</strong> (1926): 64-78. <a href="http://eudml.org/doc/145705" rel="nofollow noreferrer">http://eudml.org/doc/145705</a></li>
<li>Theodor Estermann. Zwei neue Beweise eines Satzes von Blaschke und Rademacher.
<em>Jahresbericht d. Deutschen Math.-Verein.</em> <strong>36</strong> (1927): 197-200. <a href="http://eudml.org/doc/145763" rel="nofollow noreferrer">http://eudml.org/doc/145763</a></li>
<li>Theodor Estermann. Über den Vektorenbereich eines konvexen Körpers.
<em>Math Z.</em> <strong>28</strong> (1928), 471-475. <a href="https://doi.org/10.1007/BF01181177" rel="nofollow noreferrer">https://doi.org/10.1007/BF01181177</a></li>
<li>C. A. Rogers and G. C. Shephard, The difference body of a convex body.
<em>Arch. Math.</em> <strong>8</strong> (1957), 220-233. <a href="https://doi.org/10.1007/BF01899997" rel="nofollow noreferrer">https://doi.org/10.1007/BF01899997</a></li>
</ul>
<p>I believe the true factor for Lemma 4 might be 3/8, and it is sharp for
the triangle (-w/2,-w/2),(w/2,0),(0,w/2), for the case of even w.
(By analogy with the ordinary width, <em>not</em> lattice width:
&quot;It is well-known that of all convex sets of a given width, the
equilaterial triangle has the smallest area.&quot;)</p>
<p>In the proof, we would consider the 8-gon formed as the
intersection of a horizontal slab of width w, a vertical slab
of width w1&gt;=1, and two slabs of directions 45° and -45° of
<em>vertical</em> widths w3&gt;=w and w4&gt;=w, respectively. (Their Euclidean
widths are &gt;=w/sqrt(2).)</p>
<p>Some sides of the 8-gon may degenerate into
a point, in case several lines are concurrent.
The body must touch each of these edges (even if they are degenerated to a point).</p>
<h1>Possible further improvements</h1>
<h3>Lemma 5.</h3>
<p>A) For three successive vertices v,v',v&quot; of P, the triangle vv'v&quot; contains
no interior point.</p>
<p>B) If n is even, then there cannot even be points on the diagonal vv&quot;.</p>
<p>Proof:
A) Otherwise v' could be replaced by that point, reducing the area.</p>
<p>B) Bárány and Tokushige proved that the set E of edge vectors is
convex in the following sense: Every vector e in the convex hull of E
that is a primitive vector, must belong to E.
Let e=v-&gt;v' and e'=v'-&gt;v&quot;. If vv&quot;=e+e' would have gcd d&gt;2 the vector
(e+e')/d, which is in the convex hull of e,e',-e,-e', is missing
from E, a contradiction.
QED</p>
<p>This Lemma could be used to shortcut the propagation process.
Property B is really strong. It seems that it holds also
in the odd case, but I cannot prove it.</p>
<p>Property B means the following. Consider a pair (q,f). Then the
outgoing edges q-&gt;p that need to be considered end on the next
lattice line parallel to f. The points q form an arithmetic progression
p0, p0+f, p0+2f, ....
When considering a range of diameter D (roughly the maximum height),
then these are about D/|f| successor points altogether (on all levels py).</p>
<p>Under Property A, we have to consider in addition all multiples of the vectors
(q-f)-&gt;(p0+t<em>f).
I.e.,
p = (q-f) + s</em>(p0+t<em>f-(q-f))
= s</em>p0 - (s-1)<em>q + (s</em>t-s-1)<em>f
This would be D/|f| log(D</em>|f|) ~ D log D/|f| points.
Typically, the average length of the lists (the number of
vectors f for a point q) is very small,
(about 4 for height py=100), and |f| is usually not very short.</p>
<p>(By contrast, currently, every point p gets O(D²) inputs, one from every other
point q (looking at the propagation from the incoming side).)</p>
<p>Some further possible improvements are mentioned in
the comments in the program.</p>
<p>Now here comes finally the program:</p>
<pre><code>N_target = 44

&quot;&quot;&quot;
Lemma 1: Every edge is a primitive vector.

Lemma 2: If n is even, then P can be assumed to be centrally symmetric.

Lemma 3: A centrally symmetric convex polygon P of lattice width w has area
at least w²/2.

Lemma 4: A (not necessarily symmetric) convex polygon P of lattice width w
has area at least w²/3.
The inequality is strict except when P is a triangle.

&quot;&quot;&quot;
# Since we use &quot;volume&quot;, which is TWICE the area, the following constants
# are twice as big as the constants in the lemmas.

lattice_width_factor_even = 1
lattice_width_factor_odd  = 2/3 + 0.00001
# +0.00001 is because of the strict inequality (except for triangles, but
# those are found in the first iteration.)

def lower_bound(k,w):
    &quot;lower bound on vol (=2*area) for k-gon of lattice width w &quot;
    if k%2:
        lattice_width_factor = lattice_width_factor_odd
    else:
        lattice_width_factor = lattice_width_factor_even
    LB = ceil( w**2 * lattice_width_factor )
    if k%2 != LB%2:
        LB +=1 # vol must be odd for odd k and even for even k
    return LB

&quot;&quot;&quot;
===================================================
Also in the algorithm, we make the assumption
that the lattice width direction is vertical.
(The smallest number of parallel lattice lines intersecting P
are the horizontal lines.)

We assume that the lowest point (or one of the two lowest points)
is the origin O=(0,0).


=====================================================

For each pair of points p and q and every k, we remember the smallest
counterclockwise k-gon (0,0), .... , q, p

Restriction:
* The successive points move strictly upwards.
  (Thus, p is the top point, and there is a &quot;long edge&quot; from O to p.)

Polygons with one or two horizontal edges will be treated specially.

By horizontal lattice-preserving shearing transformations, it suffices to
store results only for the range 0 &lt;= px &lt; py
(The answer for any point p in the plane can then be figured out
by an appropriate shearing transformation.)

The area is roughly n^3, and by Lemma 4 the maximum height H=py can be bounded by
H=n^1.5 (omitting all constant factors). Thus the number of points p is n^3.
The points q can be bounded only very loosely in the horizontal
direction, by n^2, however, in practice, it turns out they go only up to
(1+alpha)n, where alpha grows very slowly (less than 4 for height 120.)

Thus, the number of points q that are considered is also roughly of the order n^3.
This gives an estimated runtime of O(n^3*n^3*n)=O(n^7) for all triples (p,q,k).
One could say O(n^6) for each new value of n.

===========================

In the end we put together a counterclockwise k-gon ending in p
with a counterclockwise k'-gon starting in O or in (-1,0) and
ending in p or in p-(1,0).

Main data structure:
====================
min_gon is a dictionary
min_gon[(px,py)] is a dictionary

min_gon[(px,py)][k] is a list of pairs (f,vol)=((fx,fy),vol), where
the incoming edge f=(fx,fy)=q-p is a primitive vector (pointing upwards, fy&gt;0)
and vol = 2 * min-area of a k-gon ((0,0), .... ,q,p).
In the list, the vectors f are sorted clockwise by direction,
and the corresponding values &quot;vol&quot; are strictly increasing.
(If pairs don't fit this order, we can eliminate one of them, as DOMINATED.)

We fill this dictionary row by row, increasing py.

[ If we want to enumerate ALL optimal solutions, we should allow
the &quot;vol&quot; values to be weakly increasing. We should then use the
weaker lower bound also for even k, in case we are interested in solutions
that are not centrally symmetric.
Another possibility is COUNTING the number of solutions. (For each height
separately. Every solution has up to 2k representations with at least
one flat edge, and infinitely many without flat edge.)
We should consider all solutions of height up until the value is confirmed. ]
[ We should have proceeded from left to right, swapping x and y.
Then the notion of slope could have been used more naturally. ]

&quot;vol&quot; is TWICE the area.

https://oeis.org/A070911
1,2,5,6,13,14,21,28,43,48,65,80,103,118, / 151,174,213,242,289,328,387,420,497
The odd values after the slash were unconfirmed according to OEIS.
&quot;&quot;&quot;

known_value = {i+3:v for i,v in enumerate((
    1,2,5,6,13,14,21,28,43,48,65,80,103,118,151,174,213,242,289,
    328,387,420,497,548,625,690,783,860,967,1046,1177,1264,1409,
    ))} # just for guidance; not used by the algorithm

from math import tan,pi,gcd,sqrt,ceil
import itertools
import sys

if len(sys.argv)&gt;1:
    N_target = int(sys.argv[1])

min_gon = dict()
record_vol = [n**3 for n in range(N_target+1)] # loose upper bound as start value
min_height = [0 for n in range(N_target+1)] # smallest height of a min-area polygon
max_height = [0 for n in range(N_target+1)]
# largest height of a min-area polygon with at least one horizontal edge,
# AS FOUND BY THE PROGRAM, not definite

confirmed = [True]*2 + [False]*(N_target+1-2) # checks which entries are confirmed.
how_achieved = [None]*(N_target+1)

# Auxiliary procedures to construct the solution, once the optimal
# area has been determined
def find_polygon(px,py,k,alpha0=0):
    # find the smallest k-gon ending in (px,py) by backtracing
    # 0&lt;px&lt;py. The two points (0,0),(1,0) are not produced.
    alphaT = alpha0
    result = [(px+alphaT*py,py)]
    (fx,fy),vol = min_gon[px,py][k][0]
    for k in range (k-1,1,-1):
        qx,qy = px-fx,py-fy
        vol -= qx*py-qy*px
        alpha =  qx//qy
        px,py = qx-alpha*qy,qy
        alphaT += alpha # alpha is accumulated
        result.append((px+alphaT*py,py))
        for (fx,fy),vol2 in min_gon[px,py][k]:
            if vol2==vol: # this must be the right entry, recognition by vol is easiest
                break
        else:
            error(&quot;not found&quot;,k,px,py)
    return result

def print_solution(k,how_achieved,vol):
    how,px,py,k1,k2 = how_achieved
    #print(f&quot;{(k,how,px,py,k1,k2)=}&quot;)
    p1 = find_polygon(px,py,k1)
    p1.reverse()
    if how==&quot;1 FLAT&quot;:
        top_point = px-1
    else:
        top_point = px
    ppx = (-top_point)%py
    alpha0 = (-top_point - ppx) // py # usually, alpha0==-1
    leftshift = 1 if how==&quot;2 FLAT&quot; else 0
    p2 = [(-x-leftshift,y) for x,y in find_polygon(ppx,py,k2,alpha0)]
    #print(f&quot;-- {how=} {alpha0=}, {p2[0][0]=},{top_point=},{ppx=},{px=},{py=},{k=}&quot;)
    assert p2[0][0]==top_point-leftshift
    if how==&quot;DIAGONAL&quot;:
        p2 = p2[1:] #eliminate the common point
    last = [(-1,0)] if how==&quot;2 FLAT&quot; else []
    print (&quot;--- a smallest %d-gon,&quot;%k, &quot;area = %d/2:&quot;%vol,
           [(0,0)]+p1+p2+last) # counterclockwise

## Start the computation

for py in itertools.count(1): # for py = 1,2,...
    # proceed row by row
    for px in range(py): # 2-gons are the base case.
        min_gon[px,py]={2:[((px,py),0)]}
        # or perhaps rather start 2-gons?

    work = num_work = 0
    sum_alpha = num_alpha = 0
    visited_p = visited_q = 0
    for k in range(2,N_target):
        collect=[[] for px in range(py)]
        # We will first *collect* the contributions to row py
        # for k+1 before sorting and processing them.         
        for qy in range(1,py):
            # Generate all contributions from point q on row qy to points p on row py.
            # We look at each starting point (qx0,qy) with 0&lt;=qx0&lt;qy&lt;py, for which we
            # have min_gon[qx0,qy] stored.
            # Then we consider the series of affine images
            #    (qx0,qy), (qx0+qy,qy), (qx0+2*qy,qy), ..., (qx0+alpha*qy,qy), ...
            # until we are sure that there are no more contributions to row py
            # to be expected.
            #
            # These are two crucial pieces of the algorithm:
            # 1. The simultaneous clockwise sweep around each point (qx,qy)
            # with the incoming directions (fx,fy) and with the outgoing edges
            # to the points on row py.
            # 2. The logic to determine when no more progress can be expected from
            # advancing alpha.
            #            
            Delta_y = py-qy # &gt;0
            for qx0 in range(qy):
                if k not in min_gon[qx0,qy]:
                    continue
                sides = min_gon[qx0,qy][k]
                assert(sides)
                for alpha in itertools.count(0): # for alpha = 0,1,2,...
                    qx = qx0+alpha*qy # apply shearing by alpha
                    visited_q += 1 # statistics
                    
                    px = 0
                    row_py_finished = False # for exit from nested loops
                    exhausted = True
                    for (fx0,fy),vol in sides:
                        # sweep clockwise around q; vol is increasing.
                        # simultaneously sweep the point p on
                        # row py from left to right, clockwise around q.
                        fx = fx0+alpha*fy # apply the reverse shearing by -alpha
                        while (# vector q-&gt;p is counterclockwise from (fx,fy):
                                # Delta_x/Delta_y &lt; fx/fy 
                                (px-qx) * fy &lt; fx * Delta_y ):
                            # store this:
                            Delta_x = px-qx
                            if gcd(Delta_x,Delta_y)==1:
                                collect[px].append(
                                    (vol + qx*py-qy*px, Delta_x,Delta_y))
                            if px&gt;=py-1: # py-1 is largest value of px
                                row_py_finished = True
                                break
                            px += 1
                        if row_py_finished: break
                        
                        # Not all points on row py could be reached
                        # from the first incoming vector in q:
                        exhausted = False
                        
                    if exhausted:
                        # All points up to the maximum px have been reached
                        # by extending the FIRST incoming edge in &quot;sides&quot;.
                        # Further increase of alpha would only produce a larger
                        # area of Opq, and could not lead to an improvement.
                        sum_alpha += alpha # statistics
                        num_alpha += 1
                        break
                    # [ There might be additional possibilities of shortcutting:
                    # For example, the volume of Opq is too big in
                    # order to be useful for anything. Indeed the lists in &quot;collect&quot;
                    # accumulate thousands of elements (from every point q),
                    # of which only 2-3 remain on average. ]

        # Now, consolidate the lists
        for px,triples in enumerate(collect):
            if not triples:
                continue
            visited_p += 1
            work += len(triples)
            num_work += 1 # statistics

            # This is one more crucial piece of the program:
            # We should keep only those incoming edges that are not DOMINATED.
            # If (fx',fy') enters clockwise from (fx,fy) and has larger volume,
            # then it cannot be part of a minimum-area solution.
            # If it has equal volume, it could be useful, but in any situation it
            # could always be replaced by (fx,fy).
            #
            # We solve this but looking at the entries sorted by slope.
            #
            result = []
            prev_fx, prev_fy = -1,0 # ensure that test is true at the first iteration
            prev_vol = -1
            for vol,fx,fy in (sorted(triples)):
                # smallest area first &lt;==&gt; result should be ordered clockwise.
                if (# this is the first time OR (fx,fy) is clockwise from prev:
                    # fx/fy &gt; prev_fx/prev_fy
                      fx*prev_fy &gt; prev_fx*fy):
                    if vol!=prev_vol:                   
                        result.append(((fx,fy),vol))
                    else: # replace the last entry:
                        result[-1] = ((fx,fy),vol)
                        # adjust this treatment when generating ALL solutions:
                        # Then multiple vol-entries should be kept, but SORTED BY SLOPE.
                    prev_fx,prev_fy,prev_vol = fx,fy,vol
                    
            min_gon[px,py][k+1]=result
            if 0:
                #print(f&quot;p=({px},{py}) {k=}&quot;)
                for t in result: print(&quot;  &quot;,t)

    # compute new record areas
    improved = [False]*(N_target+1)

    def check_record(k, vol, how, text=&quot;&quot;):        
        if k&gt;N_target:
            return
        if vol&lt;record_vol[k]:
            #if text: print(text)
            assert not confirmed[k]

            if k in known_value and vol&lt;known_value[k]:
                # then something must be wrong:
                print(&quot;BETTER THAN KNOWN VALUE&quot;,100*&quot;!!&quot;)
                print_solution(k,how,vol)
                exit()              
            
            record_vol[k] = vol
            how_achieved[k] = how
            min_height[k] = py
            improved[k] = True
        if vol==record_vol[k] and how[0] != &quot;DIAGONAL&quot;:
            # DIAGONAL case not counted: Without a flat edge, height is unbounded.
            max_height[k] = py

    # Combine &quot;right&quot; k1-gons with &quot;left&quot; k2-gons
    for px in range(py):
        ppx0 = (-px)%py  # A) exact match along long edge (0,0)-(px,py)
        ppx1 = (1-px)%py # B) horizontal edge of length 1 at the top
        for k1,best1 in min_gon[px,py].items():
            _,vol1 = best1[0]
            for k2,best2 in min_gon[ppx0,py].items():
                _,vol2 = best2[0]
                check_record(k1+k2-2,
                             vol1+vol2, (&quot;DIAGONAL&quot;,px,py,k1,k2))
                check_record(k1+k2,
                             vol1+vol2+2*py, (&quot;2 FLAT&quot;,px,py,k1,k2))
                 #f&quot;DIAG k={k1+k2-3} {k1=} {k2=} {vol1=} {vol2=} p=({px},{py})&quot;)
            for k2,best2 in min_gon[ppx1,py].items():
                _,vol2 = best2[0]
                check_record(k1+k2-1, vol1+vol2+py, (&quot;1 FLAT&quot;,px,py,k1,k2))
                 #f&quot;EDGE k={k1+k2-2} {k1=} {k2=} {vol1=} {vol2=} p=({px},{py})&quot;)

    target_height = 0 # how high we still have to go
    for k in range(2,N_target+1):
        if not confirmed[k]:
            if lower_bound(k,py+1)&gt;=record_vol[k]:
                # evaluated for increased py in the next iteration
                #print(&quot;LB&quot;,k,py+1,LB)
                confirmed[k] = True
                print_solution(k,how_achieved[k],record_vol[k])
            else:
                # find necessary target height to confirm the current record:
                t_k = py+2
                while lower_bound(k,t_k)&lt;record_vol[k]:  t_k += 1
                target_height = max(target_height,t_k-1) 
                                
    print(&quot;N=%d, height %d&quot;%(N_target,py) +
          (&quot;.\nRESULT:&quot; if target_height==0 else &quot;-&gt;%d:&quot;%target_height),
          &quot;,&quot;.join((&quot;*&quot; if improved[k] else &quot;&quot;)+
                   str(record_vol[k])+
                   (&quot;-&quot; if k in known_value and record_vol[k]&gt;known_value[k]
                    else &quot;&quot; if confirmed[k] else &quot;?&quot;)
              for k in range(3,N_target+1)),
          #
          # Meaning of the signs:
          # - if there is a smaller known value
          # ? if still unconfirmed
          # * if has just been improved
          #
          &quot;work=%d&quot;%work, # work done in this step, total items in &quot;collect&quot;
          &quot;&quot; if num_work==0 else &quot;avg=%.2f&quot;%(work/num_work), # average list size in &quot;collect&quot;
          &quot;&quot; if num_alpha==0 else (&quot;av_alpha=%.2f&quot;% (sum_alpha/num_alpha)),
          flush=True)
    if py%10==0:
        print(&quot;smallest heights:&quot;,*(&quot;%2d&quot;%x for x in min_height[3:]))
        print(&quot;largest heights: &quot;,*(&quot;%2d&quot;%x for x in max_height[3:]))
        print(&quot;2n-gons:&quot;, &quot;,&quot;.join(str(record_vol[k]//2)
                                   +(&quot;&quot; if confirmed[k] else &quot;?&quot;)
                           for k in range(4,N_target+1,2)))

    if all(confirmed):
        break
    
print(&quot;smallest heights:&quot;,*(&quot;%2d&quot;%x for x in min_height[3:]))
print(&quot;largest heights: &quot;,*(&quot;%2d&quot;%x for x in max_height[3:]))
# &quot;largest heights&quot; are preliminary, since the algorithm stops
# too early to find the largest heights.

# There is quite a large variation of heights, in line with the
# result of Bárány and Tukushige that, in the limit,
# the shapes resemble ellipses that are more and more oblong.

print(&quot;2n-gons:&quot;, &quot;,&quot;.join(str(record_vol[k]//2)
                           for k in range(4,N_target+1,2)))
</code></pre>
</div>
<div id="pu2" class="pu"><h1>Rust, <em>n</em>=44 in ~7 seconds</h1>
<p>This is merely an abridged port of <a href="https://codegolf.stackexchange.com/a/265224">Günter Rote's solution</a>, no original contribution.</p>
<pre><code>
const LWF_EVEN: f64 = 1.0;
const LWF_ODD: f64  = 2.0/3.0 + 0.00001;

fn lower_bound(k: usize, w: usize) -> usize {
    let lattice_width_factor = if k%2 == 1 {
        LWF_ODD
    } else {
        LWF_EVEN
    };
    let mut lb = ( (w*w) as f64 * lattice_width_factor ) as usize;
    if k%2 != lb%2 {
        lb += 1;
    };
    lb
}

fn gcd(mut x: isize, mut y: isize) -> isize {
    while y != 0 {
        let t = y;
        y = x % y;
        x = t;
    }
    x
}

fn check_record(k: usize, vol: usize, py: usize, n_target: usize,
    record_vol: &mut [usize], min_height: &mut [usize], max_height: &mut [usize], improved: &mut [bool], diagonal: bool) {
    if k > n_target {
        return
    }
    if vol &lt; record_vol[k] {
        record_vol[k] = vol;
        min_height[k] = py;
        improved[k] = true;
    }
    if vol==record_vol[k] && !diagonal {
        max_height[k] = py;
    }
}

use std::collections::HashMap;

fn main() {
    #[allow(non_snake_case)]
    let mut N_target = 44;
    if let Some(s) = std::env::args().skip(1).next() {
        if let Ok(x) = s.parse() {
            N_target = x;
        }
    };
    let mut min_gon = HashMap::new();
    let mut record_vol = Vec::new();
    for n in 0..=N_target {
        record_vol.push(n*n*n);
    };
    let mut min_height = vec![0; N_target+1];
    let mut max_height = vec![0; N_target+1];
    let mut confirmed = vec![false; N_target+1];
    confirmed[0] = true; confirmed[1] = true;
    for py in 1usize.. {
        for px in 0usize..py {
            min_gon.insert((px, py), HashMap::from([(2, vec![((px as isize, py as isize), 0)])]));
        };

        let mut _work = 0;
        let mut _num_work = 0;
        let mut _sum_alpha = 0;
        let mut _num_alpha = 0;
        let mut _visited_p = 0;
        let mut _visited_q = 0;
        for k in 2usize..N_target {
            let mut collect = Vec::new();
            for _px in 0..py {
                collect.push(Vec::new());
            };
            for qy in 1..py {
                let delta_y = (py-qy) as isize;
                for qx0 in 0..qy {
                    let sides = match min_gon[&(qx0,qy)].get(&k) {
                        Some(x) => x,
                        None => continue
                    };
                    for alpha in 0.. {
                        let qx = qx0+alpha*qy;
                        _visited_q += 1;
                        let mut px = 0usize;
                        let mut exhausted = true;
                        'a: for ((fx0,fy),vol) in sides {
                            let fx = fx0+alpha as isize*fy;
                            while (px as isize - qx as isize) * fy &lt; fx * delta_y {
                                let delta_x = px as isize - qx as isize;
                                if gcd(delta_x.abs(), delta_y) == 1 {
                                    collect[px].push(
                                        (vol + qx*py-qy*px, delta_x, delta_y));
                                };
                                if px>=py-1 {
                                    break 'a
                                }
                                px += 1;
                            }
                            exhausted = false;
                        }
                        if exhausted {
                            _sum_alpha += alpha;
                            _num_alpha += 1;
                            break
                        }
                    }
                }
            }
            for (px, mut triples) in collect.into_iter().enumerate() {
                if triples.is_empty() {
                    continue
                };
                _visited_p += 1;
                _work += triples.len();
                _num_work += 1;
                let mut result = Vec::new();
                let mut first_time = true;
                let (mut prev_fx, mut prev_fy) = (0, 0);
                let mut prev_vol = 0;
                triples.sort();
                for (vol,fx,fy) in triples.into_iter() {
                    if first_time || fx*prev_fy > prev_fx*fy {
                        if first_time || vol != prev_vol {
                            result.push(((fx,fy),vol));
                            first_time = false;
                        } else {
                            let i = result.len()-1;
                            result[i] = ((fx,fy),vol);
                        };
                        prev_fx = fx; prev_fy = fy; prev_vol = vol;
                    }
                };
                min_gon.get_mut(&(px,py)).expect("min_gon[px,py] has to be initialized").insert(k+1, result);
            }
        }
        let mut improved = vec![false; N_target+1];
        for px in 0..py {
            let ppx0 = (py - px) % py;
            let ppx1 = (py + 1 - px) % py;
            for (k1,best1) in min_gon[&(px,py)].iter() {
                let vol1 = best1[0].1;
                for (k2,best2) in min_gon[&(ppx0,py)].iter() {
                    let vol2 = best2[0].1;
                    check_record(k1+k2-2, vol1+vol2, py, N_target, &mut record_vol, &mut min_height, &mut max_height, &mut improved, true);
                    check_record(k1+k2, vol1+vol2+2*py, py, N_target, &mut record_vol, &mut min_height, &mut max_height, &mut improved, false);
                }
                for (k2,best2) in min_gon[&(ppx1,py)].iter() {
                    let vol2 = best2[0].1;
                    check_record(k1+k2-1, vol1+vol2+py, py, N_target, &mut record_vol, &mut min_height, &mut max_height, &mut improved, false);
                }
            }
        }
        let mut target_height = 0;
         for k in 2..=N_target {
            if !confirmed[k] {
                if lower_bound(k,py+1) >= record_vol[k] {
                    confirmed[k] = true;
                } else {
                    let mut t_k = py+2;
                    while lower_bound(k,t_k) &lt; record_vol[k] { t_k += 1 };
                    target_height = std::cmp::max(target_height, t_k-1);
                }
            }
        }
        if confirmed.iter().all(|x| *x) {
            break
        }
    };
    println!("{:?}", &record_vol[3..]);
}
</code></pre>
</div>
<div id="pu3" class="pu"><h1>Fortran n=17, 323 s</h1>
<pre><code>C Find strictly convex polygons of minimum area on square grid
C Author: Hugo Pfoertner, 2018
      implicit integer (A-Z)
      parameter (vlarge=2147483647)
C Number of vertices
      parameter (n=17)
C Number of coordinate pairs to be used as polygon edges,
C read from external list 
      parameter (ms=2048)
C Length of lists for segments, coordinates, areas
C Must be extended for n&gt;nm
      parameter (nm=25)
      dimension xd(ms), yd(ms), x(nm), y(nm), a(nm), as(nm), nn(nm)
      equivalence
     &amp;  (n1,nn(1)),(n2,nn(2)),(n3,nn(3)),(n4,nn(4)),(n5,nn(5)),
     &amp;  (n6,nn(6)),(n7,nn(7)),(n8,nn(8)),(n9,nn(9)),(n10,nn(10)),
     &amp;  (n11,nn(11)),(n12,nn(12)),(n13,nn(13)),(n14,nn(14)),
     &amp;  (n15,nn(15)),(n16,nn(16)),(n17,nn(17)),(n18,nn(18)),
     &amp;  (n19,nn(19)),(n20,nn(20)),(n21,nn(21)),(n22,nn(22)),
     &amp;  (n23,nn(23)),(n24,nn(24)),(n25,nn(25))
C Number of polygons with minimal area found
      integer*8 count
C File names of external files, command argument
      character*15 bspirx, bspiry, carg
C Progress indicator line
      character pline*150
C CPU time
      real cptime
C function to calculate d^2 of enclosing circle,
C to be replaced by function encirc
C if exact enclosing circle is needed
      integer diamet
      external diamet
C variables  needed in diameter calculation
      doubleprecision xc, yc, rc, d, diamin, diamax
C Some choices for OEIS files describing spirals
C Square spiral
C      data bspirx, bspiry /'b174344.txt', 'b274923.txt' /
C Circular rings (Sloane)
C      data bspirx, bspiry /'b283307.txt', 'b283308.txt' /
C Circular rings
      data bspirx, bspiry /'../b305575.txt', '../b305576.txt' /
C Statement function: Double area of triangle
      triar(x1,y1, x2,y2, x3,y3) =
     &amp;      x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)
C Progress indicator
      pline = '....+....1....+....2....+....3....+....4....+....5' //
     &amp;  '....+....6....+....7....+....8....+....9....+....A' //
     &amp;  '....+....B....+....C....+....D....+....E....+....F'
C
C read external files with coordinates of points in spiral
C X
      open ( unit=10, file=bspirx, status='old',
     &amp;       form='formatted', iostat=ios)
      if ( ios .ne. 0 ) stop 'Error opening bfile spiral x'
      do 1 i = 1, ms
      read (10,*,end=999) k, xd(i)
1     continue
      close (unit=10)
C Y
      open ( unit=10, file=bspiry, status='old',
     &amp;       form='formatted', iostat=ios)
      if ( ios .ne. 0 ) stop 'Error opening bfile spiral y'
      do 2 i = 1, ms
      read (10,*,end=999) k, yd(i)
2     continue
      close (unit=10)
C
C For convenience: write first nonnegative (x,y) pairs to terminal
      do 3 i = 2, 120
      if (xd(i) .ge. 0 .and. yd(i) .ge. 0 ) write (*,1003)i,xd(i),yd(i)
1003  format ( 3 i3 )
3     continue
C
C preset minimum area
      ami = vlarge
C if an upper bound is known: least area + 1
C      ami = 183
C preset diameter extreme values
      diamin = 1.0D20
      diamax = 0.0D0
C Total number of polygons with same minimum area
      count = 0
C get number of list items from first parameter of program call
      CALL get_command_argument(1, carg)
      read (carg, *) m
      if ( m .gt. ms ) stop 'm exceeds length of segment list'
      write (*,*) 'Segments used:', m
C get index of
      CALL get_command_argument(2, carg)
      read (carg, *) n2first
      if ( xd(n2first) .lt. 0  .or. yd(n2first) .lt. 0 )
     &amp;   stop 'illegal negative start step'
C limit range, assuming first coordinate pair on files is (0,0)
      n2first = max(2,min (m,n2first))
      write (*,*) 'First start step:', xd(n2first), yd(n2first)
C
C Start building the polygon
C
C Freeze first point
      x(1) = 0
      y(1) = 0
      n1 = 0
C
C loop over second point
      do 20 n2 = n2first, m
      L = 2
      x(L) = xd(nn(L))
      y(L) = yd(nn(L))
C
C Limit to angle 0 &lt;= Pi/2
      if ( x(L) .lt. 0 .or. y(L) .lt. 0 .or. y(L) .gt. x(L) ) goto 20
C
C optional: Exclusion of extremely long segments
C      if (dble(x(L)**2 + y(L)**2) .gt. diamin) goto 20
      write (*,1006) count, n2, xd(nn(L)), yd(nn(L))
1006  format (/,'Min area polygons found so far: ', i0,
     &amp; ', next n2 = ', i0, ' (',i0,',',i0,')')
C if wanted: progress indicator 
      WRITE(*, 1004, ADVANCE='NO') pline(1:1)
1004  format (A1)

C loop over third point
      do 30 n3 = 2, m
C Progress indicator
      WRITE(*, 1004, ADVANCE='NO') pline(n3:n3)
      L = 3
      x(L) = x(L-1) + xd(nn(L))
      y(L) = y(L-1) + yd(nn(L))
      a(L) = triar (x(1),y(1), x(L-1),y(L-1), x(L),y(L))
      as(L) = a(L)
      if ( a(L) .le. 0 ) goto 30
      if ( a(L) .gt. ami-n+L ) goto 30
C The following blocks are repeated in code with adaptation for
C current segment number (code easily generated by a small script
C or preprocessor)
      do 40 n4 = 2, m
      L = 4
C try extension by segment from list
      x(L) = x(L-1) + xd(nn(L))
      y(L) = y(L-1) + yd(nn(L))
C area contribution
      a(L) = triar (x(1),y(1), x(L-1),y(L-1), x(L),y(L))
      if ( a(L) .le. 0 ) goto 40
C left turn?
      if (triar(x(L-2),y(L-2), x(L-1),y(L-1), x(L),y(L)) .le. 0) goto 40
C start point still left of straight line through endpoints of segment?
      if ( triar(x(1),y(1), x(2),y(2), x(L),y(L)) .le. 0 ) goto 40
      as(L) = as(L-1) + a(L)
      if ( as(L) .gt. ami-n+L ) goto 40
C
      do 50 n5 = 2, m
      L = 5
      x(L) = x(L-1) + xd(nn(L))
      y(L) = y(L-1) + yd(nn(L))
      a(L) = triar ( x(1),y(1), x(L-1),y(L-1), x(L),y(L))
      if ( a(L) .le. 0 ) goto 50
      if (triar(x(L-2),y(L-2), x(L-1),y(L-1), x(L),y(L)) .le. 0) goto 50
      if ( triar (x(L),y(L), x(1),y(1), x(2),y(2)) .le. 0 ) goto 50
      as(L) = as(L-1) + a(L)
      if ( as(L) .gt. ami-n+L ) goto 50
C
      do 60 n6 = 2, m
      L = 6
      x(L) = x(L-1) + xd(nn(L))
      y(L) = y(L-1) + yd(nn(L))
      a(L) = triar (x(1),y(1), x(L-1),y(L-1), x(L),y(L))
      if ( a(L) .le. 0 ) goto 60
      if (triar(x(L-2),y(L-2), x(L-1),y(L-1), x(L),y(L)) .le. 0) goto 60
      if ( triar (x(L),y(L), x(1),y(1), x(2),y(2)) .le. 0 ) goto 60
      as(L) = as(L-1) + a(L)
      if ( as(L) .gt. ami-n+L ) goto 60
C
      do 70 n7 = 2, m
      L = 7
      x(L) = x(L-1) + xd(nn(L))
      y(L) = y(L-1) + yd(nn(L))
      a(L) = triar (x(1),y(1), x(L-1),y(L-1), x(L),y(L))
      if ( a(L) .le. 0 ) goto 70
      if (triar(x(L-2),y(L-2), x(L-1),y(L-1), x(L),y(L)) .le. 0) goto 70
      if ( triar (x(L),y(L), x(1),y(1), x(2),y(2)) .le. 0 ) goto 70
      as(L) = as(L-1) + a(L)
      if ( as(L) .gt. ami-n+L ) goto 70
C
      do 80 n8 = 2, m
      L = 8
      x(L) = x(L-1) + xd(nn(L))
      y(L) = y(L-1) + yd(nn(L))
      a(L) = triar (x(1),y(1), x(L-1),y(L-1), x(L),y(L))
      if ( a(L) .le. 0 ) goto 80
      if (triar(x(L-2),y(L-2), x(L-1),y(L-1), x(L),y(L)) .le. 0) goto 80
      if ( triar (x(L),y(L), x(1),y(1), x(2),y(2)) .le. 0 ) goto 80
      as(L) = as(L-1) + a(L)
      if ( as(L) .gt. ami-n+L ) goto 80
C
      do 90 n9 = 2, m
      L = 9
      x(L) = x(L-1) + xd(nn(L))
      y(L) = y(L-1) + yd(nn(L))
      a(L) = triar (x(1),y(1), x(L-1),y(L-1), x(L),y(L))
      if ( a(L) .le. 0 ) goto 90
      if (triar(x(L-2),y(L-2), x(L-1),y(L-1), x(L),y(L)) .le. 0) goto 90
      if ( triar (x(L),y(L), x(1),y(1), x(2),y(2)) .le. 0 ) goto 90
      as(L) = as(L-1) + a(L)
      if ( as(L) .gt. ami-n+L ) goto 90
C
      do 100 n10 = 2, m
      L = 10
      x(L) = x(L-1) + xd(nn(L))
      y(L) = y(L-1) + yd(nn(L))
      a(L) = triar (x(1),y(1), x(L-1),y(L-1), x(L),y(L))
      if ( a(L) .le. 0 ) goto 100
      if (triar(x(L-2),y(L-2), x(L-1),y(L-1), x(L),y(L)) .le. 0)goto 100
      if ( triar (x(L),y(L), x(1),y(1), x(2),y(2)) .le. 0 ) goto 100
      as(L) = as(L-1) + a(L)
      if ( as(L) .gt. ami-n+L ) goto 100
C 
      do 110 n11 = 2, m
      L = 11
      x(L) = x(L-1) + xd(nn(L))
      y(L) = y(L-1) + yd(nn(L))
      a(L) = triar (x(1),y(1), x(L-1),y(L-1), x(L),y(L))
      if ( a(L) .le. 0 ) goto 110
      if (triar(x(L-2),y(L-2), x(L-1),y(L-1), x(L),y(L)) .le. 0)goto 110
      if ( triar (x(L),y(L), x(1),y(1), x(2),y(2)) .le. 0 ) goto 110
      as(L) = as(L-1) + a(L)
      if ( as(L) .gt. ami-n+L ) goto 110
C
      do 120 n12 = 2, m
      L = 12
      x(L) = x(L-1) + xd(nn(L))
      y(L) = y(L-1) + yd(nn(L))
      a(L) = triar (x(1),y(1), x(L-1),y(L-1), x(L),y(L))
      if ( a(L) .le. 0 ) goto 120
      if (triar(x(L-2),y(L-2), x(L-1),y(L-1), x(L),y(L)) .le. 0)goto 120
      if ( triar (x(L),y(L), x(1),y(1), x(2),y(2)) .le. 0 ) goto 120
      as(L) = as(L-1) + a(L)
      if ( as(L) .gt. ami-n+L ) goto 120
C
      do 130 n13 = 2, m
      L = 13
      x(L) = x(L-1) + xd(nn(L))
      y(L) = y(L-1) + yd(nn(L))
      a(L) = triar (x(1),y(1), x(L-1),y(L-1), x(L),y(L))
      if ( a(L) .le. 0 ) goto 130
      if (triar(x(L-2),y(L-2), x(L-1),y(L-1), x(L),y(L)) .le. 0)goto 130
      if ( triar (x(L),y(L), x(1),y(1), x(2),y(2)) .le. 0 ) goto 130
      as(L) = as(L-1) + a(L)
      if ( as(L) .gt. ami-n+L ) goto 130
C
      do 140 n14 = 2, m
      L = 14
      x(L) = x(L-1) + xd(nn(L))
      y(L) = y(L-1) + yd(nn(L))
      a(L) = triar (x(1),y(1), x(L-1),y(L-1), x(L),y(L))
      if ( a(L) .le. 0 ) goto 140
      if (triar(x(L-2),y(L-2), x(L-1),y(L-1), x(L),y(L)) .le. 0)goto 140
      if ( triar (x(L),y(L), x(1),y(1), x(2),y(2)) .le. 0 ) goto 140
      as(L) = as(L-1) + a(L)
      if ( as(L) .gt. ami-n+L ) goto 140
C
      do 150 n15 = 2, m
      L = 15
      x(L) = x(L-1) + xd(nn(L))
      y(L) = y(L-1) + yd(nn(L))
      a(L) = triar (x(1),y(1), x(L-1),y(L-1), x(L),y(L))
      if ( a(L) .le. 0 ) goto 150
      if (triar(x(L-2),y(L-2), x(L-1),y(L-1), x(L),y(L)) .le. 0)goto 150
      if ( triar (x(L),y(L), x(1),y(1), x(2),y(2)) .le. 0 ) goto 150
      as(L) = as(L-1) + a(L)
      if ( as(L) .gt. ami-n+L ) goto 150
C
      do 160 n16 = 2, m
      L = 16
      x(L) = x(L-1) + xd(nn(L))
      y(L) = y(L-1) + yd(nn(L))
      a(L) = triar (x(1),y(1), x(L-1),y(L-1), x(L),y(L))
      if ( a(L) .le. 0 ) goto 160
      if (triar(x(L-2),y(L-2), x(L-1),y(L-1), x(L),y(L)) .le. 0)goto 160
      if ( triar (x(L),y(L), x(1),y(1), x(2),y(2)) .le. 0 ) goto 160
      as(L) = as(L-1) + a(L)
      if ( as(L) .gt. ami-n+L ) goto 160
C
      do 170 n17 = 2, m
      L = 17
      x(L) = x(L-1) + xd(nn(L))
      y(L) = y(L-1) + yd(nn(L))
      a(L) = triar (x(1),y(1), x(L-1),y(L-1), x(L),y(L))
      if ( a(L) .le. 0 ) goto 170
      if (triar(x(L-2),y(L-2), x(L-1),y(L-1), x(L),y(L)) .le. 0)goto 170
      if ( triar (x(L),y(L), x(1),y(1), x(2),y(2)) .le. 0 ) goto 170
      as(L) = as(L-1) + a(L)
C in last line of repeated code part n=L
c      if ( as(L) .gt. ami-n+L ) goto 170
C example how to continue for n&gt;17
c      do 180 n18 = 2, m
c      L = 18
c      x(L) = x(L-1) + xd(nn(L))
c      y(L) = y(L-1) + yd(nn(L))
c      a(L) = triar (x(1),y(1), x(L-1),y(L-1), x(L),y(L))
c      if ( a(L) .le. 0 ) goto 180
c      if (triar(x(L-2),y(L-2), x(L-1),y(L-1), x(L),y(L)) .le. 0)goto 180
c      if ( triar (x(L),y(L), x(1),y(1), x(2),y(2)) .le. 0 ) goto 180
c      as(L) = as(L-1) + a(L)
c      if ( as(L) .gt. ami-n+L ) goto 180
C ...
C ...
C
C Update minimum
      if ( as(L) .lt. ami ) then
        count = 0
        ami = as(L)
C
C alternative with exact enclosing circle
C        call encirc ( 1, n, x, y, xc, yc, rc )
C        diamin = 4*rc**2
        call cpu_time (cptime)
C type cast assumed to work diamin (real*8) = diamet (integer)
        diamin = diamet (n,x,y)
        write (*,1000) n, as(L), diamin, (x(k),y(k),k=1,n)
1000    format (/,i2, 1X, i0, f14.6, 2x, 25('(',i0,',',i0,')',:,',') )
        write (*,1001) cptime, nn(2:n)
1001    format ( F12.4,' s: ',i0, 25(1X,i0,:) )
      endif
C
C check for multiple solutions with same mimimum area
      if ( as(L) .eq. ami ) then
        call cpu_time (cptime)
        d = diamet(n,x,y)
C        call encirc ( 1, n, x, y, xc, yc, rc )
C        d = 4*rc**2
        count = count + 1
        if ( d .lt. diamin ) then
          diamin = d
          write (*,1000) n, as(L), diamin, (x(k),y(k),k=1,n)
          write (*,1001) cptime, nn(2:n)
        endif
        if ( d .gt. diamax ) then
          diamax = d
          write (*,1000) n, as(L), -diamax, (x(k),y(k),k=1,n)
          write (*,1001) cptime, nn(2:n)
        endif
      endif
250   continue
240   continue
230   continue
220   continue
210   continue
200   continue
190   continue
180   continue
170   continue
160   continue
150   continue
140   continue
130   continue
120   continue
110   continue
100   continue
90    continue
80    continue
70    continue
60    continue
50    continue
40    continue
30    continue
20    continue
C
      call cpu_time ( cptime )
      write (*,1007) cptime, count
1007  format (/,'CPU time: ', f12.4, ' s',/,
     &amp;        'Number of polygons with minimum area: ', i0)
999   continue
      end
C
C Maximum of mutual point distance sufficient as an estimate.
C Exact enclosing circle needs a more sophisticated method,
C e.g., Welz's algorithm
      integer function diamet (n, x, y)
      integer n, x(*), y(*)
      id = 0
      do 10 i = 1, n-1
      do 20 j = i+1, n
      jd = (x(i)-x(j))**2 + (y(i)-y(j))**2
      id = max (id,jd)
20    continue
10    continue
      diamet = id
      end
</code></pre>
<p>This is essentially the first version of the program I started with in 2018 just for illustration with no tweaks. It's more to have a place to make some general notes on pitfalls of this problem that I think are important. When those are scattered in comments on individual answers, it's hard to keep track of.
The program only handles the case n=17, which I chose because it is the smallest n without a proof of optimality. In order to run the program, 2 external files are required, namely the b-files of the OEIS sequences <a href="https://oeis.org/A305575" rel="nofollow noreferrer">A305575</a> and <a href="https://oeis.org/A305576" rel="nofollow noreferrer">A305576</a>, which should be one directory above the program.
A typical output looks like this:</p>
<pre><code>.\17.exe 56 1
  2  1  0
  3  0  1
...
114  6  1
115  1  6
 Segments used:          56
 First start step:           1           0

Min area polygons found so far: 0, next n2 = 2 (1,0)
...
17 185    373.000000  (0,0),(1,0),(1,1),(0,3),(-1,4),(-4,6),(-6,7),(-9,8),(-13,9),(-14,9),(-16,8),(-17,7),(-17,6),(-16,5),(-13,3),(-11,2),(-8,1)
      0.0469 s: 2 3 16 7 41 17 33 53 4 18 8 5 9 45 21 37

17 185   -373.000000  (0,0),(1,0),(1,1),(0,3),(-1,4),(-4,6),(-6,7),(-9,8),(-13,9),(-14,9),(-16,8),(-17,7),(-17,6),(-16,5),(-13,3),(-11,2),(-8,1)
      0.0469 s: 2 3 16 7 41 17 33 53 4 18 8 5 9 45 21 37

17 178    370.000000  (0,0),(1,0),(1,1),(0,3),(-2,5),(-5,7),(-7,8),(-10,9),(-14,10),(-15,10),(-16,9),(-16,8),(-15,6),(-14,5),(-11,3),(-9,2),(-6,1)
      0.0938 s: 2 3 16 23 41 17 33 53 4 8 5 20 9 45 21 37

17 159    306.000000  (0,0),(1,0),(1,1),(0,3),(-2,6),(-3,7),(-5,8),(-8,9),(-12,10),(-13,10),(-14,9),(-14,8),(-13,6),(-12,5),(-9,3),(-7,2),(-4,1)
      0.1094 s: 2 3 16 40 7 17 33 53 4 8 5 20 9 45 21 37

17 159    296.000000  (0,0),(1,0),(1,1),(0,3),(-2,6),(-3,7),(-6,9),(-8,10),(-11,11),(-12,11),(-13,10),(-13,9),(-12,7),(-10,4),(-9,3),(-7,2),(-4,1)
      0.1094 s: 2 3 16 40 7 41 17 33 4 8 5 20 44 9 21 37

17 157    265.000000  (0,0),(1,0),(1,1),(0,4),(-1,6),(-3,9),(-4,10),(-6,11),(-9,12),(-10,12),(-11,11),(-11,10),(-10,7),(-9,5),(-8,4),(-5,2),(-3,1)
      0.2969 s: 2 3 32 16 40 7 17 33 4 8 5 36 20 9 45 21
.+.
17 157    232.000000  (0,0),(1,0),(2,1),(2,2),(1,4),(0,5),(-3,7),(-5,8),(-8,9),(-9,9),(-11,8),(-12,7),(-12,6),(-11,4),(-10,3),(-8,2),(-5,1)
      0.9844 s: 2 6 3 16 7 41 17 33 4 18 8 5 20 9 21 37

17 151    202.000000  (0,0),(1,0),(2,1),(2,2),(1,4),(-1,7),(-2,8),(-5,10),(-7,11),(-8,11),(-9,10),(-10,8),(-10,7),(-9,5),(-8,4),(-5,2),(-3,1)
      1.0469 s: 2 6 3 16 40 7 41 17 4 8 19 5 20 9 45 21

17 151    193.000000  (0,0),(1,0),(2,1),(2,2),(1,5),(0,7),(-1,8),(-3,9),(-6,10),(-7,10),(-9,9),(-10,8),(-10,7),(-9,5),(-8,4),(-5,2),(-3,1)
      1.1406 s: 2 6 3 32 16 7 17 33 4 18 8 5 20 9 45 21

17 151    137.000000  (0,0),(1,0),(2,1),(3,3),(3,4),(2,7),(1,9),(0,10),(-2,11),(-3,11),(-5,10),(-6,9),(-7,7),(-7,6),(-6,4),(-5,3),(-2,1)
      2.1562 s: 2 6 15 3 32 16 7 17 4 18 8 19 5 20 9 45
...1....+....2....+....3....+....4....+....5....+.
Min area polygons found so far: 24, next n2 = 6 (1,1)
....+....1....+....2....+....3....+....4....+....5....+.
Min area polygons found so far: 48, next n2 = 10 (2,0)
....+....1....+....2....+....3....+....4....+....5....+.
Min area polygons found so far: 48, next n2 = 14 (2,1)
....+....1....+....2....+....3....+....4....+....5....+.
Min area polygons found so far: 65, next n2 = 22 (2,2)
....+....1....+....2....+....3....+....4....+....5....+.
Min area polygons found so far: 65, next n2 = 26 (3,0)
....+....1....+....2....+....3....+....4....+....5....+.
Min area polygons found so far: 65, next n2 = 30 (3,1)
....+....1....+....2....+....3....+....4....+....5....+.
Min area polygons found so far: 70, next n2 = 38 (3,2)
....+....1....+....2....+....3....+....4....+....5....+.
Min area polygons found so far: 76, next n2 = 46 (4,0)
....+....1....+....2....+....3....+....4....+....5....+.
Min area polygons found so far: 76, next n2 = 50 (4,1)
....+....1....+....2....+....3....+....4....+....5....+.
CPU time:     323.0781 s
Number of polygons with minimum area: 76
</code></pre>
<p>For n=17 there is not only the <a href="http://antiton.de/PolygonalAreas/index.html?(8,1),(9,1),(10,2),(11,4),(11,5),(10,8),(9,10),(8,11),(6,12),(5,12),(3,11),(2,10),(1,8),(1,7),(2,5),(3,4),(6,2)" rel="nofollow noreferrer">compact solution</a> found by everyone, but also exotic needle-shaped solutions, like <a href="http://antiton.de/PolygonalAreas/index.html?(31,1),(32,1),(32,2),(31,3),(27,6),(24,8),(16,13),(11,16),(4,20),(2,21),(1,21),(2,20),(6,17),(13,12),(16,10),(24,5),(29,2)" rel="nofollow noreferrer">Squared diameter 1361</a>.
<a href="https://i.sstatic.net/7reqI.png" rel="nofollow noreferrer"><img src="https://i.sstatic.net/7reqI.png" alt="n=17,2*Area=151,31X20" /></a>
This is the one I've known so far with the largest diameter. As far as I know, it has not been proven that no extreme solutions of this kind with a smaller area exist. If one could show that there are no other solutions with even greater stretching, then that would be an important step towards a proof of optimality for this n.</p>
<h2>Heavily stretched polygons</h2>
<p>I don't want to spoil anyone's good mood, but if you all only find the solutions that I gave 4 years ago, the doubts remain whether we are making things too easy for ourselves when searching. I have already pointed out the existence of very strongly stretched polygons with likewise minimal areas. As a test case for your programs, you can try to find at least one even slimmer solution than the following at n=19:
<a href="http://antiton.de/PolygonalAreas/index.html?(31,1),(32,1),(32,2),(31,3),(29,4),(24,6),(16,9),(13,10),(6,12),(2,13),(1,13),(1,12),(2,11),(5,9),(7,8),(12,6),(15,5),(22,3),(26,2)" rel="nofollow noreferrer">n=19, 2*Area=213, Diameter^2=1105</a>
My program finds the shown and -intentionally undisclosed- slimmer solutions (squared diameters = 5*prime number, prime, ..) after about 200 s (17700 s for the prime squared diameter) using 1000 points from the spiral files.</p>
<p>If other programs also find these solutions, then that would increase my confidence considerably.</p>
<h3>Update</h3>
<p>In the meantime I have found that all of the strongly distorted and needle-shaped polygons found by my programs can be reduced to the already known slightly deformed shapes by applying shear transformations. So far I haven't found any exceptions to this observation. Apparently, allowing longer polygon sides does not bring any advantage in terms of further reducing the area. In a way, this contradicts the asymptotic elliptical shape described in the work of <a href="https://doi.org/10.1007%2Fs00493-004-0012-0" rel="nofollow noreferrer">Bárány, I., Tokushige, N. (2004)</a> or <a href="http://www.renyi.hu/%7Ebarany/cikkek/94.pdf" rel="nofollow noreferrer">version without paywall</a> with semi-axes <span class="math-container">\$a=0.003573 n^2\$</span> and <span class="math-container">\$b=1.656 n\$</span>, which at <span class="math-container">\$n=27\$</span> gives an axis ratio of about <span class="math-container">\$1/15\$</span>. The observed ratio of the solution with <span class="math-container">\$2*A(27)=625\$</span>, which has meanwhile also been found by my own program, is only about <span class="math-container">\$1/2\$</span>.</p>
<h1>Fortran revised, n=17, 8.8 s</h1>
<p>See <a href="https://github.com/HugoPfoertner/Lattice-Polygons" rel="nofollow noreferrer">Lattice-Polygons</a> on GitHub. Another faster version exists (approx. 70% of run time), with explicit expansion of the inner loops, similar to code shown above, but the GitHub version is cleaner.</p>
</div>
<div id="pu4" class="pu"><h1>Python (with restricted conditions) n=26, 10 seconds</h1>
<p>Uses backtracking. <br />
Numba for speed. <br />
notebook <a href="https://github.com/arrmansa/smallest-area-of-a-convex-grid-polygon/blob/main/Attempt%2019%20-%20one%20half%20is%20bigger.ipynb" rel="nofollow noreferrer">link</a></p>
<pre><code>10.49 seconds, 548 area
points: [[0, 0], [0, 1], [1, 3], [2, 4], [4, 5], [7, 6], [8, 6], [11, 5], [13, 4], [16, 2], [17, 1], [19, -2], [20, -4], [21, -7], [21, -8], [20, -10], [19, -11], [17, -12], [14, -13], [13, -13], [10, -12], [8, -11], [5, -9], [4, -8], [2, -5], [1, -3]]
</code></pre>
<h1>Fast O(n^2) upper bounds for high n (&lt;10% error for n&lt;=36, slightly better than n^3/27 when n&lt;1e5, sometimes better for n&gt;1e5)</h1>
<p>Assuming the solution to be close to circular. We can make circle-like shapes where sides made of the smallest n vectors where i and j are coprime. This gives a polygon of size n*4. I think this should have the optimal minimum perimeter as well. <a href="https://github.com/arrmansa/smallest-area-of-a-convex-grid-polygon/blob/main/choose%20small%20vectors.ipynb" rel="nofollow noreferrer">github notebook link</a></p>
<p>The calculated upper bound is (slightly) better than n^3/27 for n upto 10000.</p>
<p><a href="https://i.sstatic.net/crL8G.png" rel="nofollow noreferrer"><img src="https://i.sstatic.net/crL8G.png" alt="min double area vs n" /></a></p>
<p><a href="https://i.sstatic.net/v95UI.png" rel="nofollow noreferrer"><img src="https://i.sstatic.net/v95UI.png" alt="first 40 points" /></a></p>
<p>(Old extra method - best solution found in 15s for n upto 44 <a href="https://github.com/arrmansa/smallest-area-of-a-convex-grid-polygon/blob/main/Attempt%2020%20-%20half_bigger-round-opt.ipynb" rel="nofollow noreferrer">link</a> . At these high numbers, it's basically just oneshot generations but still somewhat interesting)</p>
<h2>Old code links n = 14, 80s</h2>
<hr />
<pre><code>88.12 seconds, 80 area, points: [[0, 0], [0, 1], [1, 2], [3, 3], [4, 3], [6, 2], [7, 1], [8, -1], [8, -2], [7, -3], [5, -4], [4, -4], [2, -3], [1, -2]]
</code></pre>
<p>notebook <a href="https://github.com/arrmansa/smallest-area-of-a-convex-grid-polygon/blob/main/Attempt%203.ipynb" rel="nofollow noreferrer">link</a></p>
<hr />
<p>another way to get it to generate 1 valid, pretty optimal output very early is to sort the points in order of distance to previous point, but it doesn't help in overall speed. <a href="https://github.com/arrmansa/smallest-area-of-a-convex-grid-polygon/blob/main/Attempt%202.ipynb" rel="nofollow noreferrer">link</a></p>
<hr />
<p>if we assume point n+1 must be in a 7x7 grid centered at point n, the max manhattan distance between points is &lt;6 and that the angle between formed by n-1, n and n+1 is &gt;= 90, we get the output for n=18, gridsize=14 in 360 seconds</p>
<pre><code>362.6 seconds, 174 area, points: [[0, 0], [0, 1], [1, 3], [2, 4], [4, 5], [5, 5], [7, 4], [8, 3], [9, 1], [10, -2], [10, -3], [9, -5], [8, -6], [6, -7], [5, -7], [3, -6], [2, -5], [1, -3]]
</code></pre>
<p>notebook <a href="https://github.com/arrmansa/smallest-area-of-a-convex-grid-polygon/blob/main/Attempt%204.ipynb" rel="nofollow noreferrer">link</a></p>
<hr />
<p>reducing the number of wasted calculations and function calls since cross product is the area of a triangle and taking into account that p0 = 0,0 we get:</p>
<pre><code>from numba import jit
import numpy as np

@jit
def create_polygon_jit(points, n, target_n, gridsize, curr_area, min_area, soln):
    if n &gt;= 3:
        if points[1,0]==0 and points[n-1,0]==0:
            return False
        if (points[n-3][0]-points[n-2][0])*(points[n-1][1]-points[n-2][1])&lt;=\
        (points[n-3][1]-points[n-2][1])*(points[n-1][0]-points[n-2][0]):
            return False
        add_area = points[n-1][0]*points[n-2][1]-points[n-1][1]*points[n-2][0]
        if add_area &lt;= 0:
            return False
        curr_area += add_area
        if curr_area &gt;= min_area[0]:
            return False
    if n == target_n:
        min_area[0] = curr_area
        soln[:] = points.copy()
        return False
    for i in range(gridsize):
        for j in range(-gridsize//2, gridsize//2):
            points[n] = (i,j)
            result = create_polygon_jit(points, n+1, target_n, gridsize, curr_area, min_area, soln)
    points[n] = (0,0)
    return False
</code></pre>
<p>which only does 4 seconds better at 84.4 sec
notebook <a href="https://github.com/arrmansa/smallest-area-of-a-convex-grid-polygon/blob/main/Attempt%205.ipynb" rel="nofollow noreferrer">link</a></p>
<hr />
<p>pypy 3 tio <a href="https://tio.run/##lVRNc5wwDL3zKzQ5GWISYC@dTOixf2LLMAS8G@@A7bFhpvTPb2WD@dhtk5STZUnvSXoyauzfpTjEalTj9Ro07AS1ZlXPSiXb8SxFeeE9UZKL3lAQFPpKn1lf4umseWP4b0ahHrQuK0yj0HExn4xsRfgSAH78BAK@53CYzPlqAj2mxTEp8jyBSjT@TsT@ds2wn2b9oAX8qFrDtlBkyTvYvHgxM2uGEdnipnt/WoSv@c8FbQd1H7qHuqf6Qr1V07gRQX7TbrTnivdFR3umbfsL4msOX5nYohc85kvyFnANQNW8pEj6CbbTOc@XHVnDNxjY9gK/@O2yTL6py6daqpGEwT@pTlIDBy5AV@LMiN/FzfxtxGWNiH3I83O27i4aN5L5KdtaCKeX8KZlM7S9beGDR/KY/u8zCe6YE5pMt7vOA94pqXvoeYfG9FilMUrLZqixgtQiNxSU7@pXR2HswIrY4HydG3dpi0wwzY4@xmC73hn60Ri7MLYebziPDwsddyOHt5a5PubmZ9YZuXozxAwd2dc4dWlrmY8c93s1ivBWW5SrZcIz4BfgkkGaBdMNno9uXEUkAj9svPwWTGK5gCKwc7YnfDkGxbEa2ik@KaZPZS0H0TONC1d@rG3q/oGrpAmFo7eiKCu8nua9UrYIawVKYzLRyNGQv3DGrh4KWUjhwbBaisbQB7obr0NF97QzUzUvGON4wuv1Dw" rel="nofollow noreferrer">link</a></p>
<hr />
<p>restricted conditions with quadrant/octant optimization suggested by @HugoPfoertner, n=19 works, and n=18 is done in 180 seconds</p>
<pre><code>438.59 seconds, 213 area, points: [[0, 0], [0, 1], [1, 3], [2, 4], [4, 5], [5, 5], [8, 4], [10, 3], [11, 2], [12, 0], [13, -3], [13, -4], [12, -6], [11, -7], [10, -7], [7, -6], [5, -5], [2, -3], [1, -2]]
</code></pre>
<p>notebook <a href="https://github.com/arrmansa/smallest-area-of-a-convex-grid-polygon/blob/main/Attempt%206.ipynb" rel="nofollow noreferrer">link</a></p>
</div>
<div id="pu5" class="pu"><h1>Rust + itertools + fasthash, n = 26 in ~423s</h1>
<p>This is a rust port of <a href="https://codegolf.stackexchange.com/a/253655">Arnauld's answer</a>, with a few iterations of performance improvement.</p>
<p>I use <code>Vec&lt;Option&lt;_&gt;&gt;</code> for sparse arrays and reference counting for the cache. I also use <code>128 * w + h</code> as a hash for coordinate pairs, and use SeaHash from the <a href="https://crates.io/crates/fasthash" rel="nofollow noreferrer">fasthash crate</a></p>
<p>Obviously needs to be build with <code>--release</code>.</p>
<p>It is around 40 times faster for n=16, taking only 2.5s instead of 100s in Javascript.</p>
<pre class="lang-rust prettyprint-override"><code>use std::collections::{HashMap, HashSet};
use std::hash::{Hash, Hasher};
use std::iter::once;
use std::rc::Rc;
use std::time::{Duration, Instant};

use fasthash::sea::Hash64;
use itertools::Itertools;

struct Solution {
    w: i32,
    h: i32,
    y0: i32,
    res: [Vec&lt;(i32, i32)&gt;; 4],
}

#[derive(Clone, Debug)]
struct AreaPath {
    area: i32,
    path: Vec&lt;(i32, i32)&gt;,
}

#[derive(Eq, PartialEq)]
struct Coord(i32, i32);

#[allow(clippy::derive_hash_xor_eq)]
impl Hash for Coord {
    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H) {
        state.write_i32(128 * self.0 + self.1);
    }
}

type PathCache = HashMap&lt;Coord, Rc&lt;Vec&lt;Option&lt;AreaPath&gt;&gt;&gt;, Hash64&gt;;

fn main() {
    const MAX_N: i32 = 99;
    const MAX_TIME: Duration = Duration::from_secs(600);

    let mut pathCache: PathCache = HashMap::with_hasher(Hash64);

    let mut getPaths = |w: i32, h: i32| -&gt; Rc&lt;Vec&lt;Option&lt;AreaPath&gt;&gt;&gt; {
        let cached: Option&lt;&amp;Rc&lt;Vec&lt;Option&lt;AreaPath&gt;&gt;&gt;&gt; = pathCache.get(&amp;Coord(w, h));
        return match cached {
            Some(p) =&gt; Rc::clone(p),
            None =&gt; {
                let mut set: HashSet&lt;usize&gt; = HashSet::new();
                let mut list = vec![None; 11];

                fn search(
                    x: i32,
                    y: i32,
                    pw: i32,
                    ph: i32,
                    area: i32,
                    path: Vec&lt;(i32, i32)&gt;,
                    w: i32,
                    h: i32,
                    set: &amp;mut HashSet&lt;usize&gt;,
                    list: &amp;mut Vec&lt;Option&lt;AreaPath&gt;&gt;,
                ) {
                    let len: usize = path.len();
                    if x == w &amp;&amp; y == h {
                        let outerArea = w * h * 2 - area;

                        if !set.contains(&amp;len) || outerArea &gt; list[len].as_ref().unwrap().area {
                            set.insert(len);

                            list[len] = Some(AreaPath {
                                area: outerArea,
                                path: path.clone(),
                            });
                        }
                    }

                    for w0 in 1..=(w - x) {
                        for h0 in 1..=(h - y) {
                            if h0 * pw &lt; w0 * ph {
                                let mut path_clone = Vec::with_capacity(len + 1);
                                path_clone.extend(path.clone());
                                path_clone.push((w0, h0));
                                search(
                                    x + w0,
                                    y + h0,
                                    w0,
                                    h0,
                                    area + ((w - x) * 2 - w0) * h0,
                                    path_clone,
                                    w,
                                    h,
                                    set,
                                    list,
                                );
                            }
                        }
                    }
                }

                search(0, 0, 0, 1, 0, vec![], w, h, &amp;mut set, &amp;mut list);
                let list = Rc::new(list);
                pathCache.insert(Coord(w, h), Rc::clone(&amp;list));
                pathCache.insert(
                    Coord(h, w),
                    Rc::new(
                        list.iter()
                            .map(|o| {
                                o.as_ref().map(|a| AreaPath {
                                    area: a.area,
                                    path: a.path.iter().rev().map(|&amp;(dx, dy)| (dy, dx)).collect(),
                                })
                            })
                            .collect(),
                    ),
                );

                list
            }
        };
    };

    let mut solveRectangle = |part: &amp;[[i32; 4]],
                              w: i32,
                              h: i32,
                              y0: i32,
                              x0: i32,
                              y1: i32,
                              x1: i32|
     -&gt; (f32, Option&lt;[Vec&lt;(i32, i32)&gt;; 4]&gt;) {
        let mut best = f32::INFINITY;
        let mut solution = None;

        for p in part {
            if let Some(Some(p0)) = getPaths(x0, h - y0 - 2).get((p[0] - 1) as usize) {
                if let Some(Some(p1)) = getPaths(w - x0 - 2, h - y1 - 1)
                    .get((p[1] - 1) as usize)
                {
                    if let Some(Some(p2)) = getPaths(w - x1 - 1, y1 - 1)
                        .get((p[2] - 1) as usize)
                    {
                        if let Some(Some(p3)) =
                            getPaths(x1 - 1, y0).get((p[3] - 1) as usize)
                        {
                            let outerArea = p0.area + p1.area + p2.area + p3.area;
                            let score = (w - 1) * (h - 1) * 2 - outerArea;
                            let score = score as f32;

                            if score &lt; best {
                                best = score;
                                solution = Some([
                                    p0.path.clone(),
                                    p1.path.iter().rev().copied().collect(),
                                    p2.path.clone(),
                                    p3.path.iter().rev().copied().collect(),
                                ]);
                            }
                        }
                    }
                }
            }
        }
        return (best, solution);
    };

    let mut solve = |n: i32, min: i32, max: i32| -&gt; (f32, Solution) {
        let part: Vec&lt;[i32; 4]&gt; = partitionsInFour(n);
        let mut rect = vec![];
        let mut best = f32::INFINITY;
        let mut solution = None;

        for w in min..=max {
            for h in min..=w {
                rect.push((w, h));
            }
        }

        for (w, h) in rect {
            for y0 in 0..(h - 1) {
                for x0 in 0..(w - 1) {
                    for y1 in 1..h {
                        for x1 in 1..w {
                            let (score, res) = solveRectangle(&amp;part, w, h, y0, x0, y1, x1);
                            if score &lt; best {
                                best = score;
                                solution = Some(Solution {
                                    w: w,
                                    h: h,
                                    y0: y0,
                                    res: res.unwrap(),
                                });
                            }
                        }
                    }
                }
            }
        }
        return (best, solution.unwrap());
    };

    let ts = Instant::now();
    let mut min = 4;
    let mut max = 4;

    for n in 7..=MAX_N {
        println!(&quot;n = {n}&quot;);

        let (score, solution) = solve(n, min, max);
        let w = solution.w - 1;
        let h = solution.h - 1;

        println!(&quot;Area * 2 = {score}&quot;);
        println!(&quot;Enclosing rectangle: {w} x {h}&quot;);
        displaySolution(&amp;solution);

        let time = ts.elapsed();
        println!(&quot;Total time: {time:?}&quot;);

        if time &gt;= MAX_TIME {
            break;
        }
        min = solution.h;
        max = solution.w + 2;
    }

    fn partitionsInFour(n: i32) -&gt; Vec&lt;[i32; 4]&gt; {
        let mut list = vec![];
        fn search(n: i32, i: i32, l: Vec&lt;i32&gt;, list: &amp;mut Vec&lt;[i32; 4]&gt;) {
            if n != 0 {
                if i &lt;= n &amp;&amp; l.len() != 4 {
                    search(n - i, 1, once(i).chain(l.iter().copied()).collect(), list);
                    search(n, i + 1, l, list);
                }
            } else if let Ok(a) = l.try_into() {
                list.push(a);
            }
        }

        search(n, 1, vec![], &amp;mut list);
        return list;
    }

    fn displaySolution(solution: &amp;Solution) {
        let mut m = vec![vec![&quot;--&quot;.to_owned(); solution.w as usize]; solution.h as usize];
        let mut x = 0;
        let mut y;
        let mut i = 1;

        let mut mark = |x: i32, y: i32| {
            let x = x as usize;
            let y = y as usize;
            if m[y][x] == &quot;--&quot; {
                m[y][x] = format!(&quot;{:&gt;02}&quot;, i);
            }
            i += 1;
        };

        y = solution.y0;
        mark(0, y);
        y += 1;
        mark(x, y);
        for (dx, dy) in &amp;solution.res[0] {
            x += dx;
            y += dy;
            mark(x, y)
        }
        x += 1;
        mark(x, y);
        for (dx, dy) in &amp;solution.res[1] {
            x += dx;
            y -= dy;
            mark(x, y)
        }
        y -= 1;
        mark(x, y);
        for (dx, dy) in &amp;solution.res[2] {
            x -= dx;
            y -= dy;
            mark(x, y)
        }
        x -= 1;
        mark(x, y);
        for (dx, dy) in &amp;solution.res[3] {
            x -= dx;
            y += dy;
            mark(x, y)
        }

        println!(&quot;{}&quot;, m.into_iter().map(|r| r.join(&quot; &quot;)).join(&quot;\n&quot;));
    }
}
</code></pre>
</div>
<div id="pu6" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C++ (gcc)</a>, n=16 ~2 seconds</h1>
<p>C++ port of @arrmansa's optimized version.</p>

<pre class="lang-cpp prettyprint-override"><code>#include &lt;array&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;

struct point {
    int x;
    int y;
};

template&lt;std::size_t N&gt;
bool create_polygon_jit(std::array&lt;point, N&gt;&amp; points, int n, int target_n, int gridsize, int curr_area, int&amp; min_area, std::array&lt;point, N&gt;&amp; soln)
{
    if (n &gt;= 3)
    {
        int x1 = points[n - 3].x - points[n - 2].x, y1 = points[n - 3].y - points[n - 2].y;
        int x2 = points[n - 1].x - points[n - 2].x, y2 = points[n - 1].y - points[n - 2].y;
        if (x1 * y2 - x2 * y1 &lt;= 0) // Angle &gt; 180
            return false;
        if (x1 * x2 + y1 * y2 &gt; 0)  // Angle &gt;= 90
            return false;
        if (points[1].x == 0 and points[n - 1].x == 0)
            return true;

        int add_area = points[n - 1].x * points[n - 2].y - points[n - 1].y * points[n - 2].x;
        if (add_area &lt;= 0)
            return true;

        curr_area += add_area;
        if (curr_area &gt;= min_area)
            return true;

        if (n == target_n)
        {
            min_area = curr_area;
            soln = points;
            return true;
        }

        int min_i = std::max(0, points[n - 1].x - 3);
        int max_i = std::min(gridsize, points[n - 1].x + 4);

        int min_j = std::max(-gridsize / 2, points[n - 1].y - 3);
        int max_j = std::min(gridsize / 2 + 1, points[n - 1].y + 4);

        if (x2 &gt; 0)
        {
            if (y2 &gt; 0)
            {
                if (x2 &gt; y2)
                {
                    for (int j = min_j; j &lt; max_j; j++) {
                        for (int i = max_i - 1; i &gt; min_i - 1; i--) {
                            points[n].x = i;
                            points[n].y = j;
                            if (!create_polygon_jit(points, n + 1, target_n, gridsize, curr_area, min_area, soln))
                                break;
                        }
                        if (points[n].x == max_i - 1)
                            break;
                    }
                }
                else
                {
                    for (int j = max_j - 1; j &gt; min_j - 1; j--)
                    {
                        for (int i = max_i - 1; i &gt; min_i - 1; i--)
                        {
                            points[n].x = i;
                            points[n].y = j;

                            if (!create_polygon_jit(points, n + 1, target_n, gridsize, curr_area, min_area, soln))
                                break;
                        }
                        if (points[n].x == max_i - 1)
                            break;
                    }
                }
            }
            else
            {
                if (x2 &gt; -y2)
                {
                    for (int i = max_i - 1; i &gt; min_i - 1; i--)
                    {
                        for (int j = min_j; j &lt; max_j; j++)
                        {
                            points[n].x = i;
                            points[n].y = j;

                            if (!create_polygon_jit(points, n + 1, target_n, gridsize, curr_area, min_area, soln))
                                break;
                        }
                        if (points[n].y == min_j)
                            break;
                    }
                }
                else
                {
                    for (int i = min_i; i &lt; max_i; i++)
                    {
                        for (int j = min_j; j &lt; max_j; j++)
                        {
                            points[n].x = i;
                            points[n].y = j;
                            ;
                            if (!create_polygon_jit(points, n + 1, target_n, gridsize, curr_area, min_area, soln))
                                break;
                        }
                        if (points[n].y == min_j)
                            break;
                    }
                }
            }
        }
        else
        {
            if (y2 &gt; 0)
            {
                if (-x2 &gt; y2)
                {
                    for (int i = min_i; i &lt; max_i; i++)
                    {
                        for (int j = max_j - 1; j &gt; min_j - 1; j--)
                        {
                            points[n].x = i;
                            points[n].y = j;

                            if (!create_polygon_jit(points, n + 1, target_n, gridsize, curr_area, min_area, soln))
                                break;
                        }
                        if (points[n].y == max_j - 1)
                            break;
                    }
                }
                else
                {
                    for (int i = max_i - 1; i &gt; min_i - 1; i--)
                    {
                        for (int j = max_j - 1; j &gt; min_j - 1; j--)
                        {
                            points[n].x = i;
                            points[n].y = j;

                            if (!create_polygon_jit(points, n + 1, target_n, gridsize, curr_area, min_area, soln))
                                break;
                        }
                        if (points[n].y == max_j - 1)
                            break;
                    }
                }
            }
            else
            {
                if (-x2 &gt; -y2)
                {
                    for (int j = max_j - 1; j &gt; min_j - 1; j--)
                    {
                        for (int i = min_i; i &lt; max_i; i++)
                        {
                            points[n].x = i;
                            points[n].y = j;

                            if (!create_polygon_jit(points, n + 1, target_n, gridsize, curr_area, min_area, soln))
                                break;
                        }
                        if (points[n].x == min_i)
                            break;
                    }
                }
                else
                {
                    for (int j = min_j; j &lt; max_j; j++)
                    {
                        for (int i = min_i; i &lt; max_i; i++)
                        {
                            points[n].x = i;
                            points[n].y = j;

                            if (!create_polygon_jit(points, n + 1, target_n, gridsize, curr_area, min_area, soln))
                                break;
                        }
                        if (points[n].x == min_i)
                            break;
                    }
                }

            }
        }
    }
    else
    {
        int min_i = std::max(0, points[n - 1].x - 3);
        int max_i = std::min(gridsize, points[n - 1].x + 4);

        int min_j = std::max(-gridsize / 2, points[n - 1].y - 3);
        int max_j = std::min(gridsize / 2, points[n - 1].y + 4);

        for (int i = min_i; i &lt; max_i; i++)
        {
            for (int j = min_j; j &lt; max_j; j++)
            {
                points[n].x = i;
                points[n].y = j;
                create_polygon_jit(points, n + 1, target_n, gridsize, curr_area, min_area, soln);
            }
        }
    }
    points[n].x = 0;
    points[n].y = 0;
    return true;
}

int main() {
    using namespace std::chrono;
    auto t1 = steady_clock::now();

    const int n = 16;
    std::array&lt;point, n&gt; points = { 0 };

    int gridSize = 11;
    int minArea = gridSize * gridSize;

    std::array&lt;point, n&gt; result;


    create_polygon_jit(points, 1, n, gridSize, 0, minArea, result);

    std::cout &lt;&lt; "Result: ";
    for (point&amp; p : result)
        std::cout &lt;&lt; "(" &lt;&lt; p.x &lt;&lt; ", " &lt;&lt; p.y &lt;&lt; ") ";
    std::cout &lt;&lt; "\nArea: " &lt;&lt; minArea &lt;&lt; "\n";

    auto t2 = steady_clock::now();
    auto time_span = duration_cast&lt;duration&lt;double&gt;&gt;(t2 - t1);
    std::cout &lt;&lt; "Time:" &lt;&lt; time_span.count() &lt;&lt; " seconds.\n";
}


</code></pre>
<p><a href="https://tio.run/##7Vnbbts4EH3XV8xmgcCKrcR2iqJryQL6A11gs29tYTAS48qRKUOi0GiD/Hq9Q1I3Wpc4TgKkgfVgc6iZM8OZQ4oSvc3GWnredvtnwLww9Sk4JI5J5hpVh/cjjlhU7wmihMeUrF3DwEbqcdhEAeNwbwBeonVnl83MNh5sw@B0vQkJp07C/dksCf6jCw5fXOM6ikLwEI3TxSYKs2XEFquAD6SajMWR4CNUPlV@kpEEZuqPk3hJ@SKXlnHgC3AleWkcLwiCS/EU1gHLxXb4JAqZaeTDuIEBA3cOl6aUVW85wAnM82i@MrDg8vv5Hf7VeqbYM4KsqZc19DJbx57qNpMu7KZePzaOCOM@E4aW8HImwnPmMDbh4gI@s2VIwYXJp3FpIq6Y8jRmcEPChLaAIc5Q4EhYV2DVwObw175gedhysHOMCQjzG1kQN8w2QKQh4mlpJL4vi92SzLPdJOlpk4nc1bnTwy3RnT1DKrkIw3kZm45ZqWDiCq7uNVzJVUxOMRkqo3vNvADFnJTObE1DTIEyY3a376LzQU@6cBCgvZxfa3I3GI9aqHxp6oxHxZpVwAbVNN41HsIH0276XNV9WoU5XMB01DJF2vyv2vwLAHQ5aYLsxiGmg@J/R@qFRraj0dTSsLKp2bjZVBfXTRTDQIxEjELmw8amowaGzeHQ7LDUrEUNVC1wlDaKbl5QJVpWH4q4iizJuQqBvadyhsqrfmWRlD9anhPFE4GpMlVPg4pCtadA7QEglnqz16W4rlH5tjuyB6MvXi0btcz2u@1x2XTX7KG4sh7EGjkHZKFXed0LEeveav8ijOrEeE2mHan2XKrpUoN0PauadcCydiCN9iBo94J5JObLEjOTxBSpfnPrX5CTIBDUUiQQzS4S/H606lO2j5x7mYWwamkcfM420Dp0H/hKjH76HuG4YD6TvEXK3@ai@XrP5CPV3h/VDto0WgfvGl/5tWb/5fXIzGe@zohUv8235v33eEdavX9a9e4M1W/JtPv3/uH00Y@mT@G9zvOnzsHmLHl0Zjz6DvXS3Lf3II8e9dg2mpHmndrHeiSmqhZWqPiEmyYBWwIja5psiEdVCdVZn0IgKY@AT2R1KfGzhRdG3u1sxqKfg6KKXsQSrk7jUG/yUVk2D9eYm0eJWvcwhofcvjiyuxKUQYBJdW6I2fmsTipKhbOymZu3OoppkoYcNYxHqoQVyktzJUszHhVORzmIWffjRSkHx4GTf@S9GZyoYCUXJeYpbGBWmJb1040HJ@Jvg/UT0ghyMZOiWWDqNt9kUDOlW@RF3TjJI1TFmnYVq1IJ1nSBBRfl8tOY8ACT4pGEO4Xk@FF6HVLXHXBxTMgnZltI/yLOTMZTIp7jTcaRX@I@JBS54SfnMkTk33b7y7sJyTLZWn9f/g8" rel="nofollow noreferrer" title="C++ (gcc) – Try It Online">Try it online!</a></p>
</div>
<div id="pu7" class="pu"><h1><a href="https://nodejs.org" rel="noreferrer">JavaScript (Node.js)</a>, <span class="math-container">\$n=19\$</span></h1>
<p>This is a very early attempt. Given 10 minutes, it is only able to compute up to <span class="math-container">\$n=19\$</span> on my laptop and finds the same values as the ones listed in A070911.</p>
<p>It assumes <span class="math-container">\$n\ge7\$</span> in order to avoid some edge cases. Although the code could be updated to support <span class="math-container">\$n&lt;7\$</span>, I'm not sure it's worth the effort.</p>
<p>A few assumptions are made about the shape of the <span class="math-container">\$n\$</span>-gon and the size of its enclosing rectangle. The later one should probably be relaxed to make sure that no shorter solution is missed.</p>
<p>Each solution comes with an <a href="/questions/tagged/ascii-art" class="post-tag" title="show questions tagged &#39;ascii-art&#39;" aria-label="show questions tagged &#39;ascii-art&#39;" rel="tag" aria-labelledby="ascii-art-container">ascii-art</a> representation.</p>
<h3>Code</h3>
<pre class="lang-javascript prettyprint-override"><code>const MAX_N    = 13;
const MAX_TIME = 600;

let pathCache = {},
    ts = Date.now(),
    min = 4, max = 4;

for(let n = 7; n &lt;= MAX_N; n++) {
  console.log(`n = ${n}`);

  let [ score, solution ] = solve(n, min, max),
      w = solution.w - 1,
      h = solution.h - 1;

  console.log(`Area * 2 = ${score}`);
  console.log(`Enclosing rectangle: ${w} x ${h}`);
  displaySolution(solution);

  let time = Math.round((Date.now() - ts) / 1000);

  console.log(`Total time: ${time}s\n`);

  if(time &gt;= MAX_TIME) {
    break;
  }
  min = solution.h;
  max = solution.w + 2;
}

function solve(n, min, max) {
  let part = partitionsInFour(n),
      rect = [],
      best = Infinity,
      solution;

  for(let w = min; w &lt;= max; w++) {
    for(let h = min; h &lt;= w; h++) {
      rect.push([ w, h ]);
    }
  }

  for(let [ w, h ] of rect) {
    for(let y0 = 0; y0 &lt; h - 1; y0++) {
      for(let x0 = 0; x0 &lt; w - 1; x0++) {
        for(let y1 = 1; y1 &lt; h; y1++) {
          for(let x1 = 1; x1 &lt; w; x1++) {
            let [ score, res ] = solveRectangle(part, w, h, y0, x0, y1, x1);

            if(score &lt; best) {
              best = score;
              solution = { w: w, h: h, y0: y0, res: res };
            }
          }
        }
      }
    }
  }
  return [ best, solution ]
}

function solveRectangle(part, w, h, y0, x0, y1, x1) {
  let best = Infinity,
      solution;

  for(let p of part) {
    let p0, p1, p2, p3;

    if(
      (p0 = getPaths(x0,         h - y0 - 2)[p[0] - 1]) &amp;&amp;
      (p1 = getPaths(w - x0 - 2, h - y1 - 1)[p[1] - 1]) &amp;&amp;
      (p2 = getPaths(w - x1 - 1, y1 - 1    )[p[2] - 1]) &amp;&amp;
      (p3 = getPaths(x1 - 1,     y0        )[p[3] - 1])
    ) {
      let outerArea = p0.area + p1.area + p2.area + p3.area,
          score = (w - 1) * (h - 1) * 2 - outerArea;

      if(score &lt; best) {
        best = score;
        solution = [
          p0.path,
          [...p1.path].reverse(),
          p2.path,
          [...p3.path].reverse()
        ];
      }
    }
  }
  return [ best, solution ];
}

function getPaths(w, h) {
  if(pathCache[[ w, h ]]) {
    return pathCache[[ w, h ]];
  }

  let set = new Set(), list = [];

  function search(x = 0, y = 0, pw = 0, ph = 1, area = 0, path = []) {
    if(x == w &amp;&amp; y == h) {
      let len = path.length,
          outerArea = w * h * 2 - area;

      if(!set.has(len) || outerArea &gt; list[len].area) {
        set.add(len);

        list[len] = {
          area: outerArea,
          path: path
        }
      }
    }

    for(let w0 = 1; w0 &lt;= w - x; w0++) {
      for(let h0 = 1; h0 &lt;= h - y; h0++) {
        if(h0 * pw &lt; w0 * ph) {
          search(
            x + w0, y + h0, w0, h0,
            area + ((w - x) * 2 - w0) * h0, [ ...path, [ w0, h0 ]]
          );
        }
      }
    }
  }

  search();
  pathCache[[ w, h ]] = list;
  pathCache[[ h, w ]] = list.map(o =&gt; ({
    area: o.area,
    path: [...o.path].reverse().map(([ dx, dy ]) =&gt; [ dy, dx ])
  }));

  return list;
}

function partitionsInFour(n) {
  let list = [];

  (function search(n, i = 1, l = []) {
    if(n) {
      if(i &lt;= n &amp;&amp; l.length != 4) {
        search(n - i, 1, [i, ...l]);
        search(n, i + 1, l);
      }
    }
    else if(l.length == 4) {
      list.push(l);
    }
  })(n);

  return list;
}

function displaySolution(solution) {
  let m = [...Array(solution.h)].map(_ =&gt; [...Array(solution.w)].fill('--')),
      x, y, i = 1;

  function mark(x, y) {
    if(m[y][x] == '--') {
      m[y][x] = i.toString().padStart(2, '0');
    }
    i++;
  }

  mark(x = 0, y = solution.y0);
  mark(x, ++y);
  solution.res[0].forEach(([ dx, dy ]) =&gt; mark(x += dx, y += dy));
  mark(++x, y);
  solution.res[1].forEach(([ dx, dy ]) =&gt; mark(x += dx, y -= dy));
  mark(x, --y);
  solution.res[2].forEach(([ dx, dy ]) =&gt; mark(x -= dx, y -= dy));
  mark(--x, y);
  solution.res[3].forEach(([ dx, dy ]) =&gt; mark(x -= dx, y += dy));

  console.log(m.map(r =&gt; r.join(' ')).join('\n'));
}
</code></pre>
<p><a href="https://tio.run/##lVdtj5tGEP7uX7GVqtwSMMV21Up2HClqUykfUlW9fKhEUEJs7iDBiwU42Er826/PzMKyYOfNUrLD7rzPM7N77@OPcbUps309VcU2eXjYFKqqxctn/735W@C3FrPFatJvvnrx8jk2fwuC1WSSJ7XYx3X6R7xJE@x@OnsTEqorfPwZ14mvikY6enOXKez@6oldfCQC8ndFKUkHHfy@wvJkrS2Ddl1HfIIgmS7yxM@Le/mWGH/@pM5vHUgLQbKhqDZFmXgCXIc6K5SIwISPj4lUHllli60TQjT6lFn9RkzFrDtJ7ZOUTtjIwIFnZRKLx2LOfrBh9mXE9Vxt8qLK1L0ok00dq/s8WYK/OYsjlrQV2WbVPo9Pt61J2dnuY6uzHaX1JVLsl8VBbaXsswoH68oRv4hZEATOpauvijrOWQXZpvVcvVZt5rI7ycqfrk1VdbqFeIcQP5B/50lXtD4rtK/rZ@XQFfPV5IxyHtSGK3CZfdat4VLWkKYlI97qhfqrOJRSmQJRysARRt3Gu6SijRfqLlNZfeq2Owc4ng5JVF0YXYEAlmAZVIeknivtuFLiarD2PNoBf3@oUhmKxgNPxOXSCTnb1rpzUdyx1NjOKYChYEXrE6ERBdq21XEeW84jcTaa8zjgtLTOqCtXtEIrrUM@S2vLeSTOhtYx56iHyqTq2@ffDruSquVxrB789@AZ1hnWmUZT/wOuWBXsUdnGxkwxmWk1OjMdjEkimiUbXGqbS7YL95bs43koep5cozvqbBWPqlsfSoWQyRN7alwi@LsSYJD9IzDdE2JIaZcg3oTSPZTu5/i3aBOLhLaK5J4wcp/U/2AcVJJc6H4ELWBsKuZOuA@DiPATOeLRIyM6s0UJX0dm97TojARIdHZFdH4hyuxeK0ZMJDq/IroYONyK0Q/Otj8SXbSiLNdDhnJSHOqk5KGLmRH4MVEusmSouaEWTHkWFDQS14K9RqUeC5l21ByEUW5A/BX4XgeuBdnQsgxX6V60nQl934fftB35ZfIxKatEOjYHYrkqtBgLGYZo9WMQH07pvqiAgQ4V8Zv7POymW9SlodV7hWPVTUaqWZVQolTSiNukRogizyo90XUPmB5L4nKTSrpMqJ30sm/alWY00BLr2tMOzLKWzh04C1nMb0COxNddFB148kTxVYPbE@T9MLU2shoAIm1BEY/w8BPC8dO4Qt8qR3z@bAk@5chCHESMPRsuJBVvtyxlzUgjQDPO8obEl73qASzg/5L//@JkG1w6TaCHPla63Khh6eParZO2rCmz8iigj@ElgRzg/DFV5gkpBZUO53pbyMFIPqIlGy6rC40e01gHPG3nSj1Vuq5sAqJIJhQEf2oJumlZAbBmqXBWXx32E@MaM17BLcKnioxPYbDpT/1dvJeFWD8VUkfdFsuaN7pG1K3FuFlZGi@J7dET2xPeEqQInyd8HgUPvbOjIdL2l/bI7tQrryVz7QybS467C@@vTHdSPm4e1VcRXxlBQFEr5W23iJ/wSh9iWqtEkTKPVIZYEHMeWYWw7bps17mcUkIkeZWQWWNsPTDGeec3WG4/vhypvpGqLz6qTcJ2lAd4/aws45Psn7ZOxKV6w/W5PG9wfpflubyZTm8cM7hR1VOb4uF028XlB0mnVsZ34SkKjxHFylpMuOZAZH5d3NYl/nYAdPbx9rZG7SUu6pvgxsoE1LmumbraVj9HjdOnwFmZc0@47om/zTneUngu@JgHzwH9C5i2et01b5@YODm9StflAC9Uzr5f5XSkEpvT6RWV82@qnH5J5XR63cvF96s0gY/@yNoxZEoSKf33RabkjQA4WvK1uiGZ88PD/w" rel="noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a> (up to <span class="math-container">\$n=13\$</span>)</p>
<h3>Output</h3>
<pre><code>n = 7
Area * 2 = 13
Enclosing rectangle: 3 x 3
01 07 -- --
02 -- -- 06
-- -- -- 05
-- 03 04 --
Total time: 0s

n = 8
Area * 2 = 14
Enclosing rectangle: 3 x 3
-- 08 07 --
01 -- -- 06
02 -- -- 05
-- 03 04 --
Total time: 0s

n = 9
Area * 2 = 21
Enclosing rectangle: 4 x 4
01 09 -- -- --
02 -- -- 08 --
-- -- -- -- 07
-- 03 -- -- 06
-- -- 04 05 --
Total time: 0s

n = 10
Area * 2 = 28
Enclosing rectangle: 5 x 4
-- 10 09 -- -- --
01 -- -- -- 08 --
02 -- -- -- -- 07
-- 03 -- -- -- 06
-- -- -- 04 05 --
Total time: 0s

n = 11
Area * 2 = 43
Enclosing rectangle: 6 x 5
-- 11 10 -- -- -- --
01 -- -- -- -- 09 --
02 -- -- -- -- -- 08
-- -- -- -- -- -- 07
-- 03 -- -- -- 06 --
-- -- 04 05 -- -- --
Total time: 1s

n = 12
Area * 2 = 48
Enclosing rectangle: 6 x 6
-- 12 11 -- -- -- --
01 -- -- -- 10 -- --
02 -- -- -- -- 09 --
-- -- -- -- -- -- --
-- 03 -- -- -- -- 08
-- -- 04 -- -- -- 07
-- -- -- -- 05 06 --
Total time: 4s

n = 13
Area * 2 = 65
Enclosing rectangle: 8 x 6
-- 13 12 -- -- -- -- -- --
01 -- -- -- -- 11 -- -- --
02 -- -- -- -- -- -- 10 --
-- -- -- -- -- -- -- -- 09
-- 03 -- -- -- -- -- -- 08
-- -- 04 -- -- -- -- 07 --
-- -- -- -- 05 06 -- -- --
Total time: 7s

n = 14
Area * 2 = 80
Enclosing rectangle: 8 x 7
-- -- -- 13 12 -- -- -- --
-- 14 -- -- -- -- 11 -- --
01 -- -- -- -- -- -- 10 --
02 -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- 09
-- 03 -- -- -- -- -- -- 08
-- -- 04 -- -- -- -- 07 --
-- -- -- -- 05 06 -- -- --
Total time: 22s

n = 15
Area * 2 = 103
Enclosing rectangle: 9 x 8
-- -- 14 13 -- -- -- -- -- --
-- 15 -- -- -- -- 12 -- -- --
-- -- -- -- -- -- -- -- 11 --
01 -- -- -- -- -- -- -- -- 10
02 -- -- -- -- -- -- -- -- 09
-- -- -- -- -- -- -- -- -- --
-- 03 -- -- -- -- -- -- 08 --
-- -- 04 -- -- -- -- 07 -- --
-- -- -- -- 05 06 -- -- -- --
Total time: 38s

n = 16
Area * 2 = 118
Enclosing rectangle: 9 x 9
-- -- -- -- 14 13 -- -- -- --
-- -- 15 -- -- -- -- 12 -- --
-- 16 -- -- -- -- -- -- 11 --
-- -- -- -- -- -- -- -- -- --
01 -- -- -- -- -- -- -- -- 10
02 -- -- -- -- -- -- -- -- 09
-- -- -- -- -- -- -- -- -- --
-- 03 -- -- -- -- -- -- 08 --
-- -- 04 -- -- -- -- 07 -- --
-- -- -- -- 05 06 -- -- -- --
Total time: 70s

n = 17
Area * 2 = 151
Enclosing rectangle: 11 x 10
-- -- -- 16 15 -- -- -- -- -- -- --
-- 17 -- -- -- -- -- 14 -- -- -- --
01 -- -- -- -- -- -- -- -- 13 -- --
02 -- -- -- -- -- -- -- -- -- 12 --
-- -- -- -- -- -- -- -- -- -- -- --
-- 03 -- -- -- -- -- -- -- -- -- 11
-- -- -- -- -- -- -- -- -- -- -- 10
-- -- -- -- -- -- -- -- -- -- -- --
-- -- -- 04 -- -- -- -- -- -- 09 --
-- -- -- -- 05 -- -- -- -- 08 -- --
-- -- -- -- -- -- 06 07 -- -- -- --
Total time: 98s

n = 18
Area * 2 = 174
Enclosing rectangle: 12 x 10
-- -- -- -- 16 15 -- -- -- -- -- -- --
-- -- 17 -- -- -- -- -- 14 -- -- -- --
-- 18 -- -- -- -- -- -- -- -- 13 -- --
-- -- -- -- -- -- -- -- -- -- -- 12 --
01 -- -- -- -- -- -- -- -- -- -- -- --
02 -- -- -- -- -- -- -- -- -- -- -- 11
-- -- -- -- -- -- -- -- -- -- -- -- 10
-- 03 -- -- -- -- -- -- -- -- -- -- --
-- -- 04 -- -- -- -- -- -- -- -- 09 --
-- -- -- -- 05 -- -- -- -- -- 08 -- --
-- -- -- -- -- -- -- 06 07 -- -- -- --
Total time: 202s

n = 19
Area * 2 = 213
Enclosing rectangle: 13 x 12
-- -- 18 17 -- -- -- -- -- -- -- -- -- --
-- 19 -- -- -- -- 16 -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- 15 -- -- -- -- --
01 -- -- -- -- -- -- -- -- -- -- -- -- --
02 -- -- -- -- -- -- -- -- -- -- 14 -- --
-- -- -- -- -- -- -- -- -- -- -- -- 13 --
-- -- -- -- -- -- -- -- -- -- -- -- -- --
-- 03 -- -- -- -- -- -- -- -- -- -- -- 12
-- -- -- -- -- -- -- -- -- -- -- -- -- 11
-- -- 04 -- -- -- -- -- -- -- -- -- -- --
-- -- -- 05 -- -- -- -- -- -- -- -- 10 --
-- -- -- -- -- 06 -- -- -- -- -- 09 -- --
-- -- -- -- -- -- -- -- 07 08 -- -- -- --
Total time: 436s
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/253633/">253633</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




