<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::215</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>073</td><td>C++ gcc</td><td>250815T052641Z</td><td><a href="https://codegolf.stackexchange.com/questions/215/compute-modular-inverse/283114#283114">SnowCove</a></td></tr>
<tr d-ix="1"><td>057</td><td>Python 3</td><td>210122T003433Z</td><td><a href="https://codegolf.stackexchange.com/questions/215/compute-modular-inverse/217860#217860">EasyasPi</a></td></tr>
<tr d-ix="2"><td>005</td><td>Jelly</td><td>210121T120110Z</td><td><a href="https://codegolf.stackexchange.com/questions/215/compute-modular-inverse/217831#217831">caird co</a></td></tr>
<tr d-ix="3"><td>009</td><td>GolfScript</td><td>200305T135629Z</td><td><a href="https://codegolf.stackexchange.com/questions/215/compute-modular-inverse/200606#200606">Mathgeek</a></td></tr>
<tr d-ix="4"><td>025</td><td>Python 3.8 prerelease</td><td>200304T135538Z</td><td><a href="https://codegolf.stackexchange.com/questions/215/compute-modular-inverse/200540#200540">Mukundan</a></td></tr>
<tr d-ix="5"><td>023</td><td>GolfScript</td><td>140612T135901Z</td><td><a href="https://codegolf.stackexchange.com/questions/215/compute-modular-inverse/31621#31621">Peter Ta</a></td></tr>
<tr d-ix="6"><td>039</td><td>GAP</td><td>170928T201002Z</td><td><a href="https://codegolf.stackexchange.com/questions/215/compute-modular-inverse/143995#143995">ahulpke</a></td></tr>
<tr d-ix="7"><td>009</td><td>Pyth</td><td>170928T194454Z</td><td><a href="https://codegolf.stackexchange.com/questions/215/compute-modular-inverse/143990#143990">Mr. Xcod</a></td></tr>
<tr d-ix="8"><td>042</td><td>Haskell</td><td>160716T145211Z</td><td><a href="https://codegolf.stackexchange.com/questions/215/compute-modular-inverse/85517#85517">Anders K</a></td></tr>
<tr d-ix="9"><td>029</td><td>Python</td><td>160716T144343Z</td><td><a href="https://codegolf.stackexchange.com/questions/215/compute-modular-inverse/85515#85515">Anders K</a></td></tr>
<tr d-ix="10"><td>022</td><td>Mathematica</td><td>140612T102256Z</td><td><a href="https://codegolf.stackexchange.com/questions/215/compute-modular-inverse/31614#31614">sanchez</a></td></tr>
<tr d-ix="11"><td>088</td><td>Ruby</td><td>110130T065544Z</td><td><a href="https://codegolf.stackexchange.com/questions/215/compute-modular-inverse/230#230">Nemo157</a></td></tr>
<tr d-ix="12"><td>089</td><td>Python</td><td>110130T000936Z</td><td><a href="https://codegolf.stackexchange.com/questions/215/compute-modular-inverse/217#217">Alexandr</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>C++ (gcc), 73 bytes</h1>
<pre class="lang-cpp prettyprint-override"><code>using l=unsigned;p(l a,l n){l r=1,t=1&lt;&lt;n;for(;n--;a*=a)r=r*a;return r%t;}
</code></pre>
<p>for larger n, there's a 85-byte solution:</p>
<pre class="lang-cpp prettyprint-override"><code>using l=unsigned __int128;p(l a,l n){l r=1,t=l(1)&lt;&lt;n;for(;n--;a*=a)r=r*a;return r%t;}
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://docs.python.org/3.8/" rel="nofollow noreferrer">Python 3</a>, <s>77</s> 57 bytes</h1>

<pre class="lang-python prettyprint-override"><code>f=lambda x,n,b=1,i=1:n and f(x,n-1,b-(b&amp;i)*~-x,i+i)or b%i
</code></pre>
<p>Outgolfed all you snek users (except for the <code>pow(x, -1, 2**n)</code> cheapshots) with nothing but pure algorithm.</p>
<p><a href="https://tio.run/##XU7tboMgFP3vU9y4rMWONgo2oIkPAxPbu1gkwrb2z17dgWbJUpL7weFwznGPcJ0sl25elqEb1U33Cu7UUt1VFLuqtaBsDwOJ2LGi@kj0DovDz/FO8Q2LaQb9igve3DQH8A@fvYBbJYGfJKCHj08fYIi8cDWQm7sz78HnWUJGtAbQpm8nH3q0bQbxKAoaOrgpR9AGutJO3o0YSFGsDDfHB/In1kJOQe2qNaibvomiMSk7HHSKl9spRJMvMwfUo8mpsX23p3CZQgv7TS9Eu4Ek3@2OQ4I6KLdA/yyfxDa6Gb15ZoZiqUo4Z2ItVmaiTL3hsmaiil3WggvBZFrPMg4m2VnUgjWsKXkt05S8qaUAyfgv" rel="nofollow noreferrer" title="Python 3.8 (pre-release) – Try It Online">Try it online!</a> (Only uses Python 3.8 for comparison against <code>pow(a,-1,2**n)</code>)</p>
<p>Ungolfed version:</p>
<pre class="lang-python prettyprint-override"><code>def func(value, shift, acc = 1, mask = 1):
    if value != 0:
        return func(value, shift - 1, acc - (acc &amp; mask) * (value - 1), mask &lt;&lt; 1)
    else:
        return acc &amp; (mask - 1)
</code></pre>
<p>Or, as a loop with size hacks removed:</p>
<pre class="lang-python prettyprint-override"><code>def func(value, exponent):
    value -= 1
    acc = 1
    for i in range(exponent):
        if acc &amp; (1 &lt;&lt; i):
            acc -= value &lt;&lt; i
    return acc &amp; ((1 &lt;&lt; i) - 1)
</code></pre>
<h2>Explanation</h2>
<p>The function is a lambda called <code>f</code>. It takes two positive integers, and returns either the multiplicative modular inverse or zero.</p>
<p>You may be wondering what the heck is going on. This uses a different, faster, and smaller algorithm for modular inverse for powers of 2 instead of the Euclidian approach.</p>
<p>I'm not going to go too far into the details of <em>why</em> it works, as it is really complex and explained better by others. <sub>Translation: even I don't fully understand it.</sub></p>
<p>This set of algorithms is explained <a href="https://algassert.com/post/1709" rel="nofollow noreferrer">here on algassert</a> with a related algorithm explained <a href="https://crypto.stackexchange.com/questions/47493/how-to-determine-the-multiplicative-inverse-modulo-64-or-other-power-of-two">here on Crypto SE </a> with some interesting papers linked.</p>
<p>This algorithm actually uses no true multiplication (just shifts), the multiplication is just a shortcut for size.</p>
<p>This naturally returns <code>0</code> for even numbers, as the <em>odd</em> subtraction (we start with <code>x - 1</code>) causes a chain reaction of trailing with <code>0b0</code>, which, when masked off, turns the result to zero. No need for a manual sentinel.</p>
<pre class="lang-python prettyprint-override"><code>0000 0001 - 0000 1101 -&gt; 1111 0010
1111 0010 - 0001 1010 -&gt; 1110 0000
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 5 bytes</h1>
<pre><code>2*æi@
</code></pre>
<p><a href="https://tio.run/##y0rNyan8/99I6/CyTIf/1kqHlzvoP2pa4/7/f7ShgY6CaayOQrQ5gjYyADMMwCwA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p>Takes input with <span class="math-container">\$n\$</span> first and <span class="math-container">\$x\$</span> second, returns <span class="math-container">\$0\$</span> if no such inverse exists. The Footer in the TIO link reverses the input for you and formats the test cases.</p>
<h2>How it works</h2>
<pre><code>2*æi@ - Main link. Takes n on the left and x on the right
2*    - Yield 2*n
  æi@ - Modular inverse of x, modulo 2*n, or if none exists, 0.
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="http://www.golfscript.com/golfscript/" rel="nofollow noreferrer">GolfScript</a>, <strike>10</strike> 9 bytes</h1>

<pre><code>2\?:q(?q%
</code></pre>

<p><a href="https://tio.run/##S8/PSStOLsosKPlvrGDy3yjG3qpQw75Q9f9/AA" rel="nofollow noreferrer" title="GolfScript – Try It Online">Try it online!</a></p>

<p>A port of Mr. XCoder's solution, to GS. Stack manipulation is a little messy, could probably be done with a little tomfoolery. Takes in input as X N.</p>

<p>V 1.1 : Improved stack manip, it sucks a lot less now.</p>

<pre><code>2\?:q(?q% #Multiplicative Inverse
2\        #Move "2" to the second pos on the stack. X 2 N
  ?       #Exponentiate. X 2^N
   :q     #Remember, q is 2^N.
     (    #Decrement. X 2^N-1
      ?   #Exponentiate. X^(2^N-1)
       q? #Mod by 2^N.

# X^([2^N] -1) % 2^N is the multiplicative inverse, since
# X^([2^N] -1)*X = X^(2^N)
# which is 1 mod 2^N if X and 2^N are coprime.
</code></pre>

<p>If there is no M.I., it will return 0.</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://docs.python.org/3.8/" rel="nofollow noreferrer">Python 3.8 (pre-release)</a>, 25 bytes</h1>



<pre class="lang-python prettyprint-override"><code>lambda a,b:pow(a,-1,2**b)
</code></pre>

<p><a href="https://tio.run/##XY3PCsIwDMbvfYqwUzfq2CaiDDz6Cp68tK7DQteWNP7Z09duigc/SAhffl8SZrp5tz0ETCMc4ZKsnNQgQQrVB//kUmxa0VWVKpOZgkeCOEfGRo9gjdNg3GLUkQbjegZZhPNnWCQFqHx2koEbR2LN1DFYQ7wsf1TAvOQjX@ivrV9XHQjO0t71CdFj/0cXzlP@/tBIRlldlKltYMf2a3UN2ze5vwE" rel="nofollow noreferrer" title="Python 3.8 (pre-release) – Try It Online">Try it online!</a></p>
</div>
<div id="pu5" class="pu"><h2>GolfScript (23 chars)</h2>

<pre><code>{:^((1${\.**2^?%}+*}:f;
</code></pre>

<p>The sentinel result for a non-existent inverse is <code>0</code>.</p>

<p>This is a simple application of <a href="http://en.wikipedia.org/wiki/Euler&#39;s_theorem" rel="nofollow noreferrer">Euler's theorem</a>. \$x^{\varphi(2^n)} \equiv 1 \pmod {2^n}\$, so \$x^{-1} \equiv x^{2^{n-1}-1} \pmod {2^n}\$</p>

<p>Unfortunately that's rather too big an exponential to compute directly, so we have to use a loop and do modular reduction inside the loop. The iterative step is \$x^{2^k-1} = \left(x^{2^{k-1}-1}\right)^2 \times x\$ and we have a choice of base case: either <code>k=1</code> with</p>

<pre><code>{1\:^(@{\.**2^?%}+*}:f;
</code></pre>

<p>or <code>k=2</code> with</p>

<pre><code>{:^((1${\.**2^?%}+*}:f;
</code></pre>

<hr>

<p>I'm working on another approach, but the sentinel is more difficult.</p>

<p>The key observation is that we can build the inverse up bit by bit: if \$xy \equiv 1 \pmod{2^{k-1}}\$ then \$xy \in \{ 1, 1 + 2^{k-1} \} \pmod{2^k}\$, and if \$x\$ is odd we have \$x(y + xy-1) \equiv 1 \pmod{2^k}\$. (If you're not convinced, check the two cases separately). So we can start at any suitable base case and apply the transformation \$y' = (x+1)y - 1\$ a suitable number of times.</p>

<p>Since \$0x \equiv 1 \pmod {2^0}\$ we get, by induction</p>

<p>\$x\left(\frac{1 - (x+1)^n}{x}\right) \equiv 1 \pmod {2^n}\$</p>

<p>where the inverse is the sum of a geometric sequence. I've shown the derivation to avoid the rabbit-out-of-a-hat effect: given this expression, it's easy to see that (given that the bracketed value is an integer, which follows from its derivation as a sum of an integer sequence) the product on the left must be in the right equivalence class if \$x+1\$ is even.</p>

<p>That gives the 19-char function</p>

<pre><code>{1$)1$?@/~)2@?%}:f;
</code></pre>

<p>which gives correct answers for inputs which have an inverse. However, it's not so simple when \$x\$ is even. One potentially interesting option I've found is to add <code>x&amp;1</code> rather than <code>1</code>.</p>

<pre><code>{1$.1&amp;+1$?@/~)2@?%}:f;
</code></pre>

<p>This seems to give sentinel values of either \$0\$ or \$2^{n-1}\$, but I haven't yet proved that.</p>

<p>Taking that one step further, we can ensure a sentinel of \$0\$ for even numbers by changing the expression \$1 - (x+1)^n\$ into \$1 - 1^n\$:</p>

<pre><code>{1$.1&amp;*)1$?@/~)2@?%}:f;
</code></pre>

<p>That ties with the direct application of Euler's theorem for code length, but is going to have worse performance for large \$n\$. If we take the arguments the other way round, as <code>n x f</code>, we can save one character and get to <strong>22 chars</strong>:</p>

<pre><code>{..1&amp;*)2$?\/~)2@?%}:f;
</code></pre>
</div>
<div id="pu6" class="pu"><h1>GAP, 39 bytes</h1>

<pre class="lang-GAP prettyprint-override"><code>f:=function(x,n)return 1/x mod 2^n;end;
</code></pre>

<p><code>f(x,n)</code> returns the inverse of <code>x</code> modulo <code>2^n</code> and gives an error message</p>

<pre><code>Error, ModRat: for &lt;r&gt;/&lt;s&gt; mod &lt;n&gt;, &lt;s&gt;/gcd(&lt;r&gt;,&lt;s&gt;) and &lt;n&gt; must be coprime
</code></pre>

<p>if no inverse exists.</p>
</div>
<div id="pu7" class="pu"><h1><a href="https://github.com/isaacg1/pyth" rel="nofollow noreferrer">Pyth</a>, 9 bytes</h1>
<pre><code>.^Et^2Q^2
</code></pre>
<p><a href="https://pyth.herokuapp.com/?code=.%5EEt%5E2Q%5E2&amp;input=9%0A5&amp;debug=0" rel="nofollow noreferrer">Try it here!</a></p>
<p>Takes input in reverse order. Or, 9 bytes too: <code>.^EtK^2QK</code>.</p>
<h1>Explanation</h1>
<pre>
.^Et^2Q^2  - Full program.

.^         - Pow function. The same in Python (pow).
  E        - The second input.
    ^2Q    - And 2 ^ first input.
   t       - Decremented.
       ^2  - And 2 ^ first input again.
</pre>
</div>
<div id="pu8" class="pu"><h1>Haskell, 42 bytes</h1>

<pre class="lang-hs prettyprint-override"><code>_!1=1
x!n|r&lt;-x!div(n+1)2=(2-r*x)*r`mod`2^n
</code></pre>

<p>Using an <a href="http://arxiv.org/abs/1209.6626" rel="nofollow">algorithm based on Hensel’s lemma</a> that doubles the number of digits in every iteration, this runs in under a second for <em>n</em> up to about 30 <em>million</em>!</p>
</div>
<div id="pu9" class="pu"><h1>Python, 29 bytes</h1>

<pre class="lang-py prettyprint-override"><code>lambda x,n:pow(x,2**n-1,2**n)
</code></pre>

<p>This returns 0 for even <em>x</em>. It uses Euler’s theorem, with the observation that 2^<em>n</em> − 1 is divisible by 2^(<em>n</em> − 1) − 1, via Python’s builtin fast modular exponentiation. This is plenty fast enough for <em>n</em> up to 7000 or so, where it starts taking more than about a second.</p>
</div>
<div id="pu10" class="pu"><h2>Mathematica - 22</h2>
<pre><code>f=PowerMod[#,-1,2^#2]&amp;
</code></pre>
<p><code>f[x,n]</code> returns <code>y</code> with <code>x*y=1 mod 2^n</code>, otherwise <code>x is not invertible modulo 2^n</code></p>
</div>
<div id="pu11" class="pu"><h2>Ruby - 88 characters</h2>

<p>Use the function <code>f</code>.</p>

<pre><code>def e a,b;a%b==0?[0,1]:(x,y=e(b,a%b);[y,x-(y*(a/b))])end
def f x,n;e(x,2**n)[0]*(x%2)end
</code></pre>

<p>Simply the recursive function from the linked wiki page, returns 0 on error.</p>
</div>
<div id="pu12" class="pu"><h2>Python <strike>95</strike> 89</h2>

<p><code>c</code> is your function. Returns 0 if there is no inverse (i.e. when x is even).</p>

<pre><code>p=lambda x,y,m:y and p(x,y/2,m)**2*x**(y&amp;1)%m or 1
c=lambda x,n:[0,p(x,2**n-1,2**n)][x%2]
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/215/">215</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




