<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::284076</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>163</td><td>JavaScript V8</td><td>251011T110513Z</td><td><a href="https://codegolf.stackexchange.com/questions/284076/dna-reading-frame/284087#284087">Arnauld</a></td></tr>
<tr d-ix="1"><td>102</td><td>Charcoal</td><td>251013T213633Z</td><td><a href="https://codegolf.stackexchange.com/questions/284076/dna-reading-frame/284103#284103">Neil</a></td></tr>
<tr d-ix="2"><td>084</td><td>05AB1E</td><td>251013T093958Z</td><td><a href="https://codegolf.stackexchange.com/questions/284076/dna-reading-frame/284097#284097">Kevin Cr</a></td></tr>
<tr d-ix="3"><td>148</td><td>Retina</td><td>251011T125836Z</td><td><a href="https://codegolf.stackexchange.com/questions/284076/dna-reading-frame/284089#284089">Neil</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://v8.dev/" rel="nofollow noreferrer">JavaScript (V8)</a>, 163 bytes</h1>
<p>Expects a string and prints each match on a single space-separated line, using the field order described in the challenge.</p>

<pre class="lang-javascript prettyprint-override"><code>s=&gt;[1,k=-1].map(r=&gt;[...S=s].map((c,i)=&gt;S.slice(i).replace(/^ATG(...)*?T(AA|AG|GA)/,s=&gt;print(k,k+~-s.length*r,r*i%3+r,s),k+=r,s=q[q.search(c)^1]+s),s=q=&quot;CGAT&quot;,k++))
</code></pre>
<p><a href="https://tio.run/##TU9da8MgFH3Pr5DAqDbWUvYyVuwQGbLn@hZaEEnbrFmSataXdfvr2UnTjcq9es@X4rs7u@hD2Xaz81O/k32Uq3zBj3K22IgP19IALIRYyzhi6nnJ5GotYlX6gpZMhKKtHMb5VllD4WXTF0uVuihzMYrNOa5sQ1l39MiP2c8siqqo991hGniYlg@PWeCRQZE45Sk/iVi44A/Us@1ik0ECK1NtlE3hyhjrl3lCSKos3tMGZRUmtNIgAMBZiBCMVtZqBK8BuEb3EITFqFGAWSv7N9/WLXO9YmiE0P8s6h7qAeoRpskmEbsmvDr8IhK5Il/EN3VsqkJUzZ5O3ur2s3smE5KRyJZkR4f93gH4zZb9Lw" rel="nofollow noreferrer" title="JavaScript (V8) – Try It Online">Try it online!</a></p>
<h3>Commented</h3>
<pre class="lang-javascript prettyprint-override"><code>s =&gt;                            // s = input string
[1, k = -1]                     // k = ORF starting position, initialized to -1
.map(r =&gt;                       // for r = 1 and r = -1:
  [...S = s]                    //   S = copy of s
  .map((c, i) =&gt;                //   for each character c at index i in S:
    S.slice(i)                  //     take the substring of S starting at i
    .replace(                   //     search for:
      /^ATG(...)*?T(AA|AG|GA)/, //       a valid ORF at the start of this substring
      s =&gt;                      //       if found, store it in s and
      print(                    //       print:
        k,                      //         starting position k
        k + ~-s.length * r,     //         ending position: k + (s.length - 1) * r
        r * i % 3 + r,          //         frame: (r * i) % 3 + r
        s                       //         matched sequence s
      ),                        //       end of print()
      k += r,                   //       update the starting position
      s =                       //       build the reverse sequence in s
        q[                      //       by prepending the complement base
          q.search(c) ^ 1       //       using c and the lookup string q
        ] + s                   //
    ),                          //     end of replace()
    s = q = &quot;CGAT&quot;,             //     set the lookup string q and reset s for the
                                //     reverse sequence (*)
    k++                         //     increment k
  )                             //   end of inner map()
)                               // end of outer map()
</code></pre>
<p><em><sub>(*) This is safe because <code>C</code> is put in front and cannot accidentally complete a 'stop' codon.</sub></em></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 102 bytes</h1>
<pre><code>Ｆ²«≔⭆⮌θ§ACGT⌕TGCκθＦ⌕ＡθATG«≔⪪✂θκＬθ¹¦³η≔⌊ΦＥ⁺T⪪×²AAG²⊕⌕ηλλζ¿ζ⟦⪫⟦⎇ι⊕κ⁻Ｌθκ⎇ι⁺κ×³ζ⊕⁻Ｌθ⁺κ×³ζ⁺§-+ι⊕﹪κ³⪫…ηζω⟧; 
</code></pre>
<p><a href="https://tio.run/##bVFPa8IwFD/rpwg9vbB6mB49hcCKY4LM3MRDaZ82NE01jW46/OzdS2Ti3CAvpO/l9y8tqtwVbW76ftM6BmPOvoYD0XV6a2Hpnbbbeb6Ddzyi6xD2PGXCz2yJn5AImakkZS/alpCoTNK55pxu7Pl0OIh0YSaMgX3KEqGyhEf6G//OaA9LowsMN@qUvaHd@irKPFNNqKpA9oOYa6ubQ0O8xqODYG1hDh3Jk/iVTukGOxgHQUGCKRsHSzNbOGzQeiyjKahSZqJZE7ZzFNEbBmfOFpTaw@q11RZWCp3N3Qn0b46aQGSGpO8s14HqDhCtUaqrpUmQebDyh@I/SLQZB7enHz1RXv1I1pYH0wb0JEJiAHkqDMqq3YXEZ@p@8DW9zZQlfB1CX4aXvheKfo7MaClBJyohqUEf1FM0pEEmhVJS9aOj@QY" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Explanation:</p>
<pre><code>Ｆ²«
</code></pre>
<p>Loop twice, once for the reverse complement.</p>
<pre><code>≔⭆⮌θ§ACGT⌕TGCκθ
</code></pre>
<p>Take the reverse complement of the string. (So on the second pass, we recover the original input.)</p>
<pre><code>Ｆ⌕ＡθATG«
</code></pre>
<p>Loop over all occurrences of <code>ATG</code> in the string.</p>
<pre><code>≔⪪✂θκＬθ¹¦³η
</code></pre>
<p>Split the suffix of the string into groups of three.</p>
<pre><code>≔⌊ΦＥ⁺T⪪×²AAG²⊕⌕ηλλζ
</code></pre>
<p>Search the groups of three for each of <code>TAA</code>, <code>TGA</code> and <code>TAG</code>, and take the lowest codon count, if any.</p>
<pre><code>¿ζ⟦⪫⟦⎇ι⊕κ⁻Ｌθκ⎇ι⁺κ×³ζ⊕⁻Ｌθ⁺κ×³ζ⁺§-+ι⊕﹪κ³⪫…ηζω⟧; 
</code></pre>
<p>If a match was found then output the details of the match.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 84 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>Â.•∍–•uÂ‡‚εDŒʒg3Öy…ATGÅ?y.•5ʒŒΩœ •u3ôÅ¿àP}©kDU&gt;X®€g+‚NiIgα&gt;}`X3%Ni(&lt;ë&gt;}®)ø.γн}€н}í€`
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//cJPeo4ZFjzp6HzVMBjJKDzc9alj4qGHWua0uRyedmpRufHha5aOGZY4h7odb7StBak1PTTo66dzKo5MVQOqND2853Hpo/@EFAbWHVma7hNpFHFr3qGlNujbQDL9Mz/RzG@1qEyKMVf0yNWwOr7arPbRO8/AOvXObL@ytBSoDkofXAumE//8dQ4B2OLsDUYgjkAXEjs5AASAHKBYClARKuDs7hoQ4hwAA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/V9Waa@k8KhtkoKSfaVL2P/DTXqPGhY96uh91DAZyCg93PSoYeGjhlnntrocnXRqUrrx4WmVjxqWOYa4H261rwSpNT016eikcyuPTlYAqTc@vOVw66H9hxcE1B5ame0SahdxaN2jpjXp2kAz/DIj089ttKtNiDBW9cvUsDm82q720DrNwzv0zm2@sLcWqAxIHl4LpBP@6/yPVnIMAVrj7A5EIY5AFhA7OgMFgBygWAhQEijh7uwYEuIcoqSjBFICUQrSBZR3dwSKApUBVYAZUABSCtYGwkC1QAwRAiI42xnEdlaKBQA" rel="nofollow noreferrer">verify all test cases</a>.</p>
<p>If we're allowed to output a pair of quartets where the regular and reversed DNA-ORFs are separated, the trailing 4 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a> can be removed:<br />
<a href="https://tio.run/##yy9OTMpM/f//cJPeo4ZFjzp6HzVMBjJKDzc9alj4qGHWua0uRyedmpRufHha5aOGZY4h7odb7StBak1PTTo66dzKo5MVQOqND2853Hpo/@EFAbWHVma7hNpFHFr3qGlNujbQDL9Mz/RzG@1qEyKMVf0yNWwOr7arPbRO8/AOvXObL@ytBSq7sPf/f8cQoOHO7kAU4ghkAbGjM1AAyAGKhQAlgRLuzo4hIc4hAA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/V9Waa@k8KhtkoKSfaVL2P/DTXqPGhY96uh91DAZyCg93PSoYeGjhlnntrocnXRqUrrx4WmVjxqWOYa4H261rwSpNT016eikcyuPTlYAqTc@vOVw66H9hxcE1B5ame0SahdxaN2jpjXp2kAz/DIj089ttKtNiDBW9cvUsDm82q720DrNwzv0zm2@sLcWqOzC3v@1Ov@jlRxDgBY4uwNRiCOQBcSOzkABIAcoFgKUBEq4OzuGhDiHKOkogZRAlIJ0AeXdHYGiQGVAFWAGFICUgrWBMFAtEEOEgAjOdgaxnZViAQ" rel="nofollow noreferrer">verify all test cases</a>.</p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>Â                # Bifurcate the (implicit) input; aka, Duplicate &amp; Reverse copy
 .•∍–•           # Push compressed string &quot;acgt&quot;
   u             # Uppercase it
    Â            # Bifurcate it as well
     ‡           # Transliterate (&quot;A&quot; to &quot;T&quot;; &quot;C&quot; to &quot;G&quot;; &quot;G&quot; to &quot;C&quot;; &quot;T&quot; to &quot;A&quot;)
      ‚          # Pair the two strings together
ε                # Map over this pair:
 D               #  Duplicate the current string
  Œ              #  Pop and push its substrings
   ʒ             #  Filter this list by:
    g            #   Check that its length
     3Ö          #   is divisible by 3
    y    Å?      #   Check that it starts with
     …ATG        #   string &quot;ATG&quot;
    y      Å¿à   #   Check that it ends with any of these three:
     .•5ʒŒΩœ •   #    Push compressed string &quot;taatagtga&quot;
        u        #    Uppercase it
         3ô      #    Split into triplets: [&quot;TAA&quot;,&quot;TAG&quot;,&quot;TGA&quot;]
    P            #   Take the product of the stack to verify all are truthy
   }©            #  After the filter(s): store it in variable `®` (without popping)
     k           #  Get the 0-based index of each in the full string
      DU         #  Store a copy of these indices in variable `X`
      &gt;          #  +1 to make it a 1-based index
     X           #  Push 0-based indices `X` again
      ®          #  Push the list of substrings `®` again
       €g        #  Get the length of each substring
         +       #  Add it to the 0-based indices
     ‚           #  Pair these two lists together
      Ni         #  If the 0-based map-index is 1 (aka, it's the reversed string):
        Ig       #   Push the input-length
          α      #   Take its absolute difference with each value
           &gt;     #   Increase each value by 1
       }`        #  After the if-statement: push both lists to the stack again
         X       #  Push 0-based indices `X` again
          3%     #  Modulo-3 each
            Ni   #  If the map-index is 1 (aka, it's the reversed string)
              (  #   Negate each
               &lt; #   Then decrease each by 1
             ë   #  Else (it's the regular string):
              &gt;  #   Increase each by 1 instead
             }   #  Close the if-else statement
       ®         #  Push the list of substrings `®` again
        )        #  Wrap all four lists on the stack into a list
         ø       #  Zip/transpose; swapping rows/columns
          .γ     #  Group each quartet by:
            н    #   Its first value, the 1-based index
           }€н   #  After the group-by: keep the first quartet of each group
}                # After the map:
  €`             # Flatten the pair of lists one level down
 í               # (without changing its order)
                 # (after which the result is output implicitly)
</code></pre>
<p><a href="https://codegolf.stackexchange.com/a/166851/52210">See this 05AB1E tip of mine (section <em>How to compress strings not part of the dictionary?</em>)</a> to understand why <code>.•∍–•</code> is <code>&quot;acgt&quot;</code> and <code>.•5ʒŒΩœ •</code> is <code>&quot;taatagtga&quot;</code>.</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/m-ender/retina/wiki/The-Language" rel="nofollow noreferrer">Retina</a>, 148 bytes</h1>
<pre><code>$
¶$`
O$^`\G.

T`ACGT`Ro`^.+
Lv$`(?&lt;=(¶(.*)))?(?&lt;=(.*)(...)*)ATG(...)*?T(AA|AG|GA)(?=((.*)¶))?
$.($1$8$#8*$&amp;); $.($7$2$#2*$&amp;); $#2*+$#8*-$.($3_); $&amp;
</code></pre>
<p><a href="https://tio.run/##LY5BCsIwEEX3OYXQsUxaDLQuLGgJQxazEQSZpdS4cOFGQcRVz9UD9GJ1YhsS8v9/f0Le98/jeaumNXKcwIwDRHOCLl7YGSORAks8v2LnSnP8QkR/aHEc0BXWWv93KtE5ZwtLwrPygkQ9cc9k0beYOuOgAwYcQgUNZE0Bud2vkt9BDVm9eBVloptEttcU5f9/TST6fmDdQqr0UNBAjWaiUAEHEgliUmEuphmlTEYrSvVa1g8" rel="nofollow noreferrer" title="Retina – Try It Online">Try it online!</a> Link includes test cases. Explanation:</p>
<pre><code>$
¶$`
</code></pre>
<p>Duplicate the input line.</p>
<pre><code>O$^`\G.

T`ACGT`Ro`^.+
</code></pre>
<p>Reverse the first line and switch <code>A</code> with <code>T</code> and <code>C</code> with <code>G</code>.</p>
<pre><code>Lv$`(?&lt;=(¶(.*)))?(?&lt;=(.*)(...)*)ATG(...)*?T(AA|AG|GA)(?=((.*)¶))?
</code></pre>
<p>Match all overlapping sequences, plus also capture the suffix or prefix respectively depending on whether this is the first or second line. <code>$.1</code> = length of prefix + <code>1</code>; <code>$.2</code> = length of prefix; <code>$#2</code> = <code>1</code> on the second line, <code>0</code> on the first; <code>$.3</code> = frame - <code>1</code>; <code>$.7</code> = length of suffix + <code>1</code>; <code>$.8</code> = length of suffix; <code>$#8</code> = <code>1</code> on the first line, <code>0</code> on the second.</p>
<pre><code>$.($1$8$#8*$&amp;); $.($7$2$#2*$&amp;); $#2*+$#8*-$.($3_); $&amp;
</code></pre>
<p>Output the positions of the first and last character, the frame and the sequence. If the match is on the first line, the start position is the length of the suffix plus the length of the string, otherwise it is one more than the length of the prefix. Similarly if the match is on the second line then the end position is the length of the prefix plus the length of the string, otherwise it is one more than the length of the suffix.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/284076/">284076</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




