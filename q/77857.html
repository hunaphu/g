<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::77857</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>061</td><td>MATL</td><td>160415T193507Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/77868#77868">Luis Men</a></td></tr>
<tr d-ix="1"><td>069</td><td>Uiua</td><td>240908T201054Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/275423#275423">nyxbird</a></td></tr>
<tr d-ix="2"><td>111</td><td>JavaScript</td><td>240910T102147Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/275451#275451">Shaggy</a></td></tr>
<tr d-ix="3"><td>039</td><td>Japt R</td><td>240909T142727Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/275436#275436">Shaggy</a></td></tr>
<tr d-ix="4"><td>125</td><td>JavaScript ES6</td><td>160415T192712Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/77865#77865">Conor O&</a></td></tr>
<tr d-ix="5"><td>037</td><td>V</td><td>160419T062556Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/78054#78054">DJMcMayh</a></td></tr>
<tr d-ix="6"><td>115</td><td>Clojure</td><td>170101T215710Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/105297#105297">NikoNyrh</a></td></tr>
<tr d-ix="7"><td>180</td><td>C</td><td>160418T014104Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/77994#77994">tucuxi</a></td></tr>
<tr d-ix="8"><td>196</td><td>C</td><td>160417T073956Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/77960#77960">homersim</a></td></tr>
<tr d-ix="9"><td>047</td><td>Vim</td><td>160415T191558Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/77862#77862">DJMcMayh</a></td></tr>
<tr d-ix="10"><td>143</td><td>PHP</td><td>160418T132144Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/78013#78013">Xanderha</a></td></tr>
<tr d-ix="11"><td>105</td><td>PowerShell v2+</td><td>160415T194836Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/77874#77874">AdmBorkB</a></td></tr>
<tr d-ix="12"><td>nan</td><td>Perl 5.10</td><td>160417T161036Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/77974#77974">nwellnho</a></td></tr>
<tr d-ix="13"><td>101</td><td>Julia</td><td>160415T190221Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/77860#77860">Alex A.</a></td></tr>
<tr d-ix="14"><td>188</td><td>D</td><td>160416T184216Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/77951#77951">Ben Perl</a></td></tr>
<tr d-ix="15"><td>047</td><td>Pip</td><td>160416T034314Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/77919#77919">DLosc</a></td></tr>
<tr d-ix="16"><td>280</td><td>C</td><td>160417T190721Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/77983#77983">bnf679</a></td></tr>
<tr d-ix="17"><td>088</td><td>Ruby</td><td>160415T185559Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/77859#77859">Value In</a></td></tr>
<tr d-ix="18"><td>069</td><td>Retina</td><td>160415T193303Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/77867#77867">daavko</a></td></tr>
<tr d-ix="19"><td>044</td><td>Pyth</td><td>160415T191542Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/77861#77861">Maltysen</a></td></tr>
<tr d-ix="20"><td>044</td><td>Pyth</td><td>160415T202657Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/77882#77882">isaacg</a></td></tr>
<tr d-ix="21"><td>129</td><td>bash</td><td>160416T185259Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/77952#77952">bnf679</a></td></tr>
<tr d-ix="22"><td>116</td><td>Python 3</td><td>160416T072428Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/77926#77926">xnor</a></td></tr>
<tr d-ix="23"><td>100</td><td>JavaScript ES6</td><td>160415T212945Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/77890#77890">Neil</a></td></tr>
<tr d-ix="24"><td>101</td><td>Awk</td><td>160415T204012Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/77884#77884">muru</a></td></tr>
<tr d-ix="25"><td>133</td><td>Python 3.6 prerelease</td><td>160415T200128Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/77878#77878">vaultah</a></td></tr>
<tr d-ix="26"><td>159</td><td>Python 2</td><td>160415T184942Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/77858#77858">user4594</a></td></tr>
<tr d-ix="27"><td>047</td><td>05AB1E</td><td>160415T192216Z</td><td><a href="https://codegolf.stackexchange.com/questions/77857/expand-a-c-array/77863#77863">Adnan</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/lmendo/MATL" rel="nofollow noreferrer">MATL</a>, 61 bytes</h1>
<p><em>Thank you to <a href="https://codegolf.stackexchange.com/users/58974/shaggy">@Shaggy</a> for pointing out a mistake, now corrected.</em></p>
<pre><code>'[-\w]+'XX2:H#)XKxXIZc'['KnV'];'v!K&quot;I2X)'['X@qV'] = '@g';'6$h
</code></pre>
<p>This isn't C, <s>but it does use C-like <code>sprintf</code> function</s> Nah, that was wasting 4 bytes.</p>
<p><a href="https://tio.run/##y00syfn/Xz1aN6Y8Vls9IsLIykNZM8K7IsIzKlk9Wt07L0w91lq9TNFbydMoQhMoEuFQCBRSsFVQd0hXt1Y3U8kAai9JLSrKTMpJjc/Jz0uPL6ksSI3PS8xNVUgsTyvNiU8sKkqsBAtEgzRWm@so6FroKBgaGwNZBiBGrToA" rel="nofollow noreferrer"><strong>Try it online!</strong></a></p>
<pre><code>            % Take input implicitly
'[-\w]+'XX  % Find substrings that match regex '\w+'. Gives a cell array
2:H#)       % Split into a subarray with the first two substrings (type and name),
            % and another with the rest (numbers that form the array)
XKx         % Copy the latter (numbers) into clipboard K. Delete it
XI          % Copy the former (type and name) into clipboard I
Zc          % Join the first two substrings with a space
'['         % Push this string
K           % Paste array of numbers
nV          % Get its length. Convert to string
'];'        % Push this string
v!          % Concatenate all strings up to now. Gives first line of the output
K&quot;          % For each number in the array
  I2X)      %   Get name of array as a string
  '['       %   Push this string
  X@qV      %   Current iteration index, starting at 0, as a string
  '] = '    %   Push this string
  @g        %   Current number of the array, as a string
  ';'       %   Push this string
  5$h       %   Concatenate top 6 strings. This is a line of the output
            % Implicitly end for each
            % Implicitly display
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://uiua.org" rel="nofollow noreferrer">Uiua</a>, 69 bytes</h1>
<pre><code>⊂⊃(□$&quot;_ _[_];&quot;|⍚$&quot;_[_] = _;&quot;¤⋅⊙⊓⇡∘)⊙⊙(⊸⧻⊜□≥@0.)°$&quot;_ _[] = {_};&quot;
</code></pre>
<p><a href="https://www.uiua.org/pad?src=0_13_0-dev_2__ZiDihpAg4oqC4oqDKOKWoSQiXyBfW19dOyJ84o2aJCJfW19dID0gXzsiwqTii4XiipniipPih6HiiJgp4oqZ4oqZKOKKuOKnu-KKnOKWoeKJpUAwLinCsCQiXyBfW10gPSB7X307IgpmICJpbnQgZm9vW10gPSB7NCwgOCwgMTUsIDE2LCAyMywgNDJ9OyIKZiAic2hvcnQgYXJyYXlbXSA9IHs0LCAzLCAyLCAxfTsiCmYgInNwYW0gRUdHU1tdID0gezQyfTsiCmYgInRlcnJpYmxlX2xvbmdfdHlwZV9uYW1lIGF3ZnVsX2FycmF5X25hbWVbXSA9IHs3LCDCrzgsIDEzMzcsIDAsIDEzfTsiCg==" rel="nofollow noreferrer">Try it!</a></p>
</div>
<div id="pu2" class="pu"><h1>JavaScript, 111 bytes</h1>
<p>A recursive approach that didn't work out quite as well as I hoped but nowhere near as bad as I feared.</p>

<pre class="lang-javascript prettyprint-override"><code>f=(s,[x,y,...a]=s.match(/-?\w+\[?/g),n)=&gt;y?(n?`;
${x+~-n}] = `+y:x+` ${y+a.length}]`)+f(s,[n?x:y,...a],-~n):`;`
</code></pre>
<p><a href="https://tio.run/##LY1LDoIwFAD3nqILFm36QeNCA8EeBAl9kvIxUEmpQkPw6ijG3WQWM3d4wVDYpnf8dV7XMsEDSyfmmRACsmQQHbiixiGX15FeUxlWhBmSXLzERqp4F8wTfXOzZChBivpoogoFs6cgWm0qVy@ZIrTcokZO0T/L@NuQSMVqHW3jNC6xctra5tbqvH2YKne@17mBTiMYy2ebg7XgfyLdRvOJIX5m6HA8fmm/wRIrQtYP" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/ETHproductions/japt" rel="nofollow noreferrer">Japt</a> <a href="https://codegolf.meta.stackexchange.com/a/14339/"><code>-R</code></a>, <s>41</s> <s>40</s> 39 <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" rel="nofollow noreferrer">bytes</a></h1>
<p>This started out horrible, and got progressively worse over a few hours! And, <em>just</em> as I had it down to a byte count I was somewhat happy with at least, I spotted the inclusion of the <code>;</code> on each line of output and it got even more horrible!</p>
<p>Took a break for a bit, tried a fresh approach, and ended up with <del><em>a one-liner that has</em></del> * a better score than my original attempt. It's still a horrible solution, though!</p>
<pre><code>f&quot;-?%d+&quot; £¸ÅÎ¸p¥ÅXÃpU¸v2)£ÌiX¸r']ÈiT°
é
</code></pre>
<p><a href="https://petershaggynoble.github.io/Japt-Interpreter/?v=1.4.6&amp;flags=LVI&amp;code=ZiItPyVkKyIgo7jFzrhwpcVYw3BVuHYyKaPMaVi4ciddyGlUsArp&amp;input=InRlcnJpYmxlX2xvbmdfdHlwZV9uYW1lIGF3ZnVsX2FycmF5X25hbWVbXSA9IHs3LCAtOCwgMTMzNywgMCwgMTN9OyI" rel="nofollow noreferrer">Try it</a></p>
<p><sub><sup>* That didn't last long!</sup></sub></p>
<pre><code>f&quot;...&quot; £¸ÅÎ¸p¥ÅXÃpU¸v2)£ÌiX¸r']ÈiT°\né     :Implicit input of string U
f                                          :Match
 &quot;...&quot;                                     :  RegEx /-?[0-9]+/g
       £                                   :Map each X
        ¸                                  :  Split U on spaces
         Å                                 :  Slice off the first element
          Î                                :  Get the first element
           ¸                               :  Split on spaces
            p                              :  Push
             ¥                             :    &quot;==&quot;
              Å                            :      Slice off the first character
               X                           :    And X
                Ã                          :End map
                 p                         :Push
                  U¸                       :  Split U on spaces
                    v2                     :  Pop the first 2 elements
                      )                    :End push
                       £                   :Map each X
                        Ì                  :  Last character of U
                         i                 :  Prepend
                          X¸               :    X joined with spaces
                            r']            :    Replace &quot;]&quot; by
                               È           :    Passing through a function
                                i          :      Prepend
                                 T°        :        Postfix incremented T (initially 0)
                                   \n      :End map
                                     é     :Rotate right
                                           :Implicit output joined with newlines
</code></pre>
</div>
<div id="pu4" class="pu"><h1>JavaScript ES6, <s>134</s> <s>132</s> <s>130</s> <s>129</s> 125 bytes</h1>
<p>Saved 1 byte thanks to Neil. Fixed, thanks to l4m2 for noticing!</p>
<pre class="lang-js prettyprint-override"><code>x=&gt;(s=(m=x.match(/(\w+) (\w+).+{(.+)}/))[3].split`,`.map(e=&gt;`${t=m[2]}[${i++}] = ${+e};`,i=0).join`
`,m[1]+` ${t}[${i}];
`+s)
</code></pre>
<p><a href="https://tio.run/##HY3LjsIgAEX3fgWLLiAg6nThJA3@CJLCVOpgeDSArxC@vdZubk7uPcm9qYdKQzRT3vpw0fPI5hc7wcSgYy/qVB7@4Q6enxiBNSkukGJUdwjxVtA0WZMlkYs5Qc1OsimZOf4jKm@KwbgKwEBTsK6dJIbtEb0F4@VGEscPAstly6taRbeROKG5G4JPwWpqwxWOUGYdo/mzurfBX/v8nnTvldNAPce77VWM6r0W/PtUjgRsfwk4tO1C@y8sxwjNHw" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu5" class="pu"><h1>V, 37 Bytes</h1>
<pre><code>2Eé0òYp6ldf ò$dT]ddÎdwf{xwC;
gg&quot;1P
</code></pre>
<p>V is a 2D, string based golfing language that I wrote, designed off of vim. This works as of <a href="https://github.com/DJMcMayhem/V/commit/3e52ff77850f2d7897167eb9a20a859ca0169968" rel="noreferrer">commit 17</a>.</p>
<p>Explanation:</p>
<p>This is pretty much a direct translation of <a href="https://codegolf.stackexchange.com/a/77862/31716">my vim answer</a>, albeit significantly shorter.</p>
<pre><code>2E                               &quot;Move to the end of 2 words forward.
  é0                             &quot;Insert a single '0'
    ò       ò                    &quot;Recursively do:
     Yp6ldf                      &quot;Yank, paste, move 6 right, delete until space.
             $dT]                &quot;Move to the end of line, delete backwards until ']'
                 dd              &quot;Delete this line
                   Î             &quot;Apply the following to every line:
                    dwf{xwC;&lt;\n&gt; &quot;Delete word, move to '{' and delete it, Change to end of line, and enter ';'
</code></pre>
<p>Then we just have:</p>
<pre><code>gg&quot;1P     &quot;Move to line 1, and paste buffer '1' behind us.
</code></pre>
<p>Since this unicode madness can be hard to enter, you can create the file with this reversible hexdump:</p>
<pre><code>00000000: 3245 e930 f259 7001 366c 6466 20f2 2464  2E.0.Yp.6ldf .$d
00000010: 545d 6464 ce64 7766 7b78 7743 3b0d 6767  T]dd.dwf{xwC;.gg
00000020: 2231 500a                                &quot;1P.
</code></pre>
<p>This can be run by installing V and typing:</p>
<pre><code>python main.py c_array.v --f=file_with_original_text.txt
</code></pre>
</div>
<div id="pu6" class="pu"><h2>Clojure, 115 bytes</h2>

<pre><code>#(let[[t n &amp; v](re-seq #"-?\w+"%)](apply str t" "n\[(count v)"];\n"(map(fn[i v](str n"["i"] = "v";\n"))(range)v))))
</code></pre>

<p>I wasn't able to nicely merge <code>awful_array_name[5];</code> and <code>awful_array_name[0] = 7;</code> parts so that they'd re-use code :/</p>
</div>
<div id="pu7" class="pu"><h1>C, <s>195</s> 180 bytes</h1>

<p>195-byte original:</p>
<p>golfed:</p>
<pre class="lang-c prettyprint-override"><code>char*a,*b,*c,*d;j;main(i){scanf(&quot;%ms %m[^]]%m[^;]&quot;,&amp;a,&amp;b,&amp;c);
for(d=c;*d++;i+=*d==44);printf(&quot;%s %s%d];\n&quot;,a,b,i);
for(d=strtok(c,&quot;] =,{}&quot;);j&lt;i;j++,d=strtok(0,&quot; ,}&quot;))printf(&quot;%s%d] = %s;\n&quot;,b,j,d);}
</code></pre>
<p>ungolfed:</p>
<pre class="lang-c prettyprint-override"><code>char*a,*b,*c,*d;
j;
main(i){
    scanf(&quot;%ms %m[^]]%m[^;]&quot;,&amp;a,&amp;b,&amp;c); // m-modifier does its own mallocs
    for(d=c;*d++;i+=*d==44);            // count commas
    printf(&quot;%s %s%d];\n&quot;,a,b,i);        // first line
    for(d=strtok(c,&quot;] =,{}&quot;);j&lt;i;j++,d=strtok(0,&quot; ,}&quot;))
        printf(&quot;%s%d] = %s;\n&quot;,b,j,d);  // each array value
}
</code></pre>
<p>The two shortcuts are using the <code>m</code> modifier to  to get scanf's <code>%s</code> to allocate its own memory (saves declaring char arrays), and using <code>strtok</code> (which is also available by default, without includes) to do the number-parsing part.</p>
<hr />
<p>180-byte update:</p>
<pre class="lang-c prettyprint-override"><code>char*a,*b,*c,e[999];i;main(){scanf(&quot;%ms %m[^]]%m[^}]&quot;,&amp;a,&amp;b,&amp;c);
for(c=strtok(c,&quot;] =,{}&quot;);sprintf(e,&quot;%s%s%d] = %s;\n&quot;,e,b,i++,c),
c=strtok(0,&quot; ,&quot;););printf(&quot;%s %s%d];\n%s&quot;,a,b,i,e);}
</code></pre>
<p>ungolfed:</p>
<pre class="lang-c prettyprint-override"><code>char*a,*b,*c,e[999];
i;
main(){
    scanf(&quot;%ms %m[^]]%m[^}]&quot;,&amp;a,&amp;b,&amp;c);
    for(c=strtok(c,&quot;] =,{}&quot;);sprintf(e,&quot;%s%s%d] = %s;\n&quot;,e,b,i++,c),c=strtok(0,&quot; ,&quot;););
    printf(&quot;%s %s%d];\n%s&quot;,a,b,i,e);
}
</code></pre>
<p>Uses <a href="https://codegolf.stackexchange.com/a/77983/41288">bnf679's</a> idea of appending to a string to avoid having to count commas.</p>
</div>
<div id="pu8" class="pu"><h1>C, <strike>215 bytes</strike>, 196 bytes</h1>

<p><em>19 bytes saved thanks to @tucuxi!</em></p>

<p><strong>Golfed:</strong></p>

<pre><code>char i[99],o[999],b[99],z[99];t,x,n,c;main(){gets(i);sscanf(i,"%s %[^[]s",b,z);while(sscanf(i+t,"%*[^0-9]%d%n",&amp;x,&amp;n)==1)sprintf(o,"%s[%d] = %d;\n",z,c++,x),t+=n;printf("%s %s[%d];\n%s",b,z,c,o);}
</code></pre>

<p><strong>Ungolfed:</strong></p>

<pre><code>/*
 *  Global strings:
 *   i: input string
 *   o: output string
 *   b: input array type
 *   z: input array name
*/
char i[ 99 ], o[ 999 ], b[ 99 ], z[ 99 ];

/* Global ints initialized to zeros */
t, x, n, c;

main()
{
    /* Grab input string from stdin, store into i */
    gets( i );

    /* Grab the &lt;type&gt; &lt;array_name&gt; and store into b and z */
    sscanf( i, "%s %[^[]s", b, z );

    /* Grab only the int values and concatenate to output string */
    while( sscanf( i + t, "%*[^0-9]%d%n", &amp;x, &amp;n ) == 1 )
    {
        /* Format the string and store into a */
        sprintf( o, "%s[%d] = %d;\n", z, c++, x );

        /* Get the current location of the pointer */
        t += n;
    }

    /* Print the &lt;type&gt; &lt;array_name&gt;[&lt;size&gt;]; and output string */
    printf( "%s %s[%d];\n%s", b, z, c, o );
}
</code></pre>

<p><strong>Link:</strong></p>

<p><a href="http://ideone.com/h81XbI" rel="nofollow">http://ideone.com/h81XbI</a></p>

<p><strong>Explanation:</strong></p>

<p>To get the <code>&lt;type&gt; &lt;array_name&gt;</code>, the <code>sscanf()</code> format string is this:</p>

<pre><code>%s          A string delimited by a space
    %[^[]   The character set that contains anything but a `[` symbol
         s  A string of that character set
</code></pre>

<p>To extract the int values from the string <code>int foo[] = {4, 8, 15, 16, 23, 42};</code>, I essentially tokenize the string with this function:</p>

<pre><code>while( sscanf( i + t, "%*[^0-9]%d%n", &amp;x, &amp;n ) == 1 )
</code></pre>

<p>where:</p>

<ul>
<li><code>i</code> is the input string (a <code>char*</code>)</li>
<li><code>t</code> is the pointer location offset of <code>i</code></li>
<li><code>x</code> is the actual <code>int</code> parsed from the string</li>
<li><code>n</code> is the total characters consumed, including the found digit</li>
</ul>

<p>The <code>sscanf()</code> format string means this:</p>

<pre><code>%*            Ignore the following, which is..
  [^0-9]      ..anything that isn't a digit
        %d    Read and store the digit found
          %n  Store the number of characters consumed
</code></pre>

<p>If you visualize the input string as a char array:</p>

<pre><code>int foo[] = {4, 8, 15, 16, 23, 42};
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
00000000001111111111222222222233333
01234567890123456789012345678901234
</code></pre>

<p>with the <code>int</code> <code>4</code> being located at index 13, <code>8</code> at index 16, and so on, this is what the result of each run in the loop looks like:</p>

<pre><code>Run 1)  String: "int foo[] = {4, 8, 15, 16, 23, 42};"
        Starting string pointer: str[ 0 ]
        Num chars consumed until after found digit: 14
        Digit that was found: 4
        Ending string pointer: str[ 14 ]

Run 2)  String: ", 8, 15, 16, 23, 42};"
        Starting string pointer: str[ 14 ]
        Num chars consumed until after found digit: 3
        Digit that was found: 8
        Ending string pointer: str[ 17 ]

Run 3)  String: ", 15, 16, 23, 42};"
        Starting string pointer: str[ 17 ]
        Num chars consumed until after found digit: 4
        Digit that was found: 15
        Ending string pointer: str[ 21 ]

Run 4)  String: ", 16, 23, 42};"
        Starting string pointer: str[ 21 ]
        Num chars consumed until after found digit: 4
        Digit that was found: 16
        Ending string pointer: str[ 25 ]

Run 5)  String: ", 23, 42};"
        Starting string pointer: str[ 25 ]
        Num chars consumed until after found digit: 4
        Digit that was found: 23
        Ending string pointer: str[ 29 ]

Run 6)  String: ", 42};"
        Starting string pointer: str[ 29 ]
        Num chars consumed until after found digit: 4
        Digit that was found: 42
        Ending string pointer: str[ 33 ]
</code></pre>
</div>
<div id="pu9" class="pu"><h1>Vim, <s>54, 52, 49</s> 47 keystrokes</h1>
<hr />
<pre><code>2wa0&lt;esc&gt;qqYp&lt;c-a&gt;6ldf @qq@q$dT]dd:%norm dwf{xwC;&lt;CR&gt;gg&quot;0P
</code></pre>
<p>Explanation:</p>
<pre><code>2wa0&lt;esc&gt;                     'Move 2 words forward, and insert a 0.
         qq                   'Start recording in register Q
           Yp                 'Duplicate the line
             &lt;c-a&gt;6l          'Increment the next number then move 6 spaces right
                    df        'Delete until the next space
                       @qq@q  'Recursively call this macro
</code></pre>
<p>Now our buffer looks like this:</p>
<pre><code>int foo[0] = {4, 8, 15, 16, 23, 42};
int foo[1] = {8, 15, 16, 23, 42};
int foo[2] = {15, 16, 23, 42};
int foo[3] = {16, 23, 42};
int foo[4] = {23, 42};
int foo[5] = {42};
int foo[6] = {42};
</code></pre>
<p>and our cursor is on the last line.</p>
<p>Second half:</p>
<pre><code>$                           'Move to the end of the line
 dT]                        'Delete back until we hit a ']'
    dd                      'Delete this whole line.
      :%norm         &lt;CR&gt;   'Apply the following keystrokes to every line:
             dw             'Delete a word (in this case &quot;int&quot;)
               f{x          '(f)ind the next '{', then delete it.
                  wC;       'Move a word, then (C)hange to the end of this line, 
                            'and enter a ';'
                             
</code></pre>
<p>Now everything looks good, we just need to add the original array-declaration. So we do:</p>
<pre><code>gg        'Move to line one
  &quot;0P     'Print buffer '0' behind us. Buffer '0' always holds the last deleted line,
          'Which in this case is &quot;int foo[6];&quot;
</code></pre>
</div>
<div id="pu10" class="pu"><h2>PHP, 143 bytes</h2>

<p><strong>Golfed</strong></p>

<pre><code>&lt;?$t=count($n=explode(' ',preg_replace('/[^\s\w]/','',$argv[1])))-3;echo"$n[0] {$n[1]}[$t];";for($i=2;$t&gt;$j=++$i-3;)echo$n[1]."[$j] = $n[$i];";
</code></pre>

<p><strong>Ungolfed</strong></p>

<pre><code>&lt;?  
$t = count(                                  // Get the number of elements for our array...
    $n = explode(' ',                            // After split the input on whitespace...
    preg_replace('/[^\s\w]/','',$argv[1])))-3;  // After removing all special characters.
echo "$n[0] {$n[1]}[$t];";                     // First line is type, name, and count.
for($i=2;                                        // Loop through array elements
    $t &gt; $j = ++$i-3;)                         // Assign j to be the actual index for our new array
    echo $n[1]."[$j] = $n[$i];";                // Print each line
</code></pre>

<p>Input is taken through command line argument. Sample:</p>

<pre><code>C:\(filepath)&gt;php Expand.php "int foo[] = {4,8,15,16,23,42};"
</code></pre>

<p>Output:</p>

<pre><code>int foo[6];foo[0] = 4;foo[1] = 8;foo[2] = 15;foo[3] = 16;foo[4] = 23;foo[5] = 42;
</code></pre>
</div>
<div id="pu11" class="pu"><h2>PowerShell v2+, <s>114</s> 105 bytes</h2>

<pre><code>$a,$b,$c,$d=-split$args-replace'\[]';"$a $b[$(($d=-join$d|iex|iex).length)];";$d|%{"$b[$(($i++))] = $_;"}
</code></pre>

<p>Takes input string <code>$args</code> and <code>-replace</code>s the square bracket with nothing, then performs a <code>-split</code> on whitespace. We store the first bit into <code>$a</code>, the second bit into <code>$b</code>, the <code>=</code> into <code>$c</code>, and the array elements into <code>$d</code>. For the example below, this stores <code>foo</code> into <code>$a</code> and <code>bar</code> into <code>$b</code>, and all of the array into <code>$d</code>.</p>

<p>We then output our first line with <code>"$a ..."</code> and in the middle transform <code>$d</code> from a an array of strings of form <code>{1,</code>,<code>2,</code>,...<code>100};</code> to a regular int array by <code>-join</code>ing it together into one string, then running it through <code>iex</code> twice (similar to <code>eval</code>). We store that resultant array back in <code>$d</code> before calling the <code>.length</code> method to populate the appropriate number in between the <code>[]</code> in the output line.</p>

<p>We then send <code>$d</code> through a loop with <code>|%{...}</code>. Each iteration we output <code>"$b..."</code> with a counter variable <code>$i</code> encapsulated in brackets and the current value <code>$_</code>. The <code>$i</code> variable starts uninitialized (equivalent to <code>$null</code>) but the <code>++</code> will cast it to an <code>int</code> before the output, so it will start output at <code>0</code>, all before incrementing <code>$i</code> for the next loop iteration.</p>

<p>All output lines are left on the pipeline, and output to the terminal is implicit at program termination.</p>

<h3>Example</h3>

<pre><code>PS C:\Tools\Scripts\golfing&gt; .\expand-a-c-array.ps1 "foo bar[] = {1, 2, 3, -99, 100};"
foo bar[5];
bar[0] = 1;
bar[1] = 2;
bar[2] = 3;
bar[3] = -99;
bar[4] = 100;
</code></pre>
</div>
<div id="pu12" class="pu"><h2>Perl 5.10, <strike>73</strike> <strike>72</strike> <strike>68</strike> 66 + 1 (for -n switch) = 67 bytes</h2>

<pre><code>perl -nE '($t,$n,@a)=/[-[\w]+/g;say"$t $n".@a."];";say$n,$i++,"] = $_;"for@a'
</code></pre>

<p>This is a nice challenge for Perl and the shortest among general-purpose languages so far. Equivalent to</p>

<pre><code>($t, $n, @a) = /[-[\w]+/g;
say "$t $n" . @a . "];";
say $n, $i++, "] = $_;" for @a;
</code></pre>
</div>
<div id="pu13" class="pu"><h1>Julia, <s>154</s> <s>134</s> 101 bytes</h1>



<pre class="lang-default prettyprint-override"><code>f(s,c=matchall(r"-?\w+",s),n=endof(c)-2)=c[]" "c[2]"[$n];
"join([c[2]"[$i] = "c[i+3]";
"for i=0:n-1])
</code></pre>

<p>This is a function that accepts a string and returns a string with a single trailing newline.</p>

<p>Ungolfed:</p>

<pre class="lang-default prettyprint-override"><code>function f(s, c = matchall(r"-?\w+", s), n = endof(c) - 2)
    c[] " " c[2] "[$n];\n" join([c[2] "[$i] = " x[i+3] ";\n" for i = 0:n-1])
end
</code></pre>

<p>We define <code>c</code> to be an array of matches of the input on the regular expression <code>-?\w+</code>. It caputres the type, array name, then each value. We store <code>n</code> as the length of <code>c</code> - 2, which is the number of values. The output is constructed as the type, name and length string interpolated, combined with each definition line separated by newlines. For whatever reason, <code>c[]</code> is the same as <code>c[1]</code>.</p>

<p>Saved 32 bytes with help from Dennis!</p>
</div>
<div id="pu14" class="pu"><h1>D, <strike>197</strike>, 188 bytes</h1>

<pre><code>import std.array,std.stdio;void main(){string t,n,e;readf("%s %s] = {%s}",&amp;t,&amp;n,&amp;e);auto v=e.replace(",","").split;writeln(t,' ',n,v.length,"];");foreach(i,c;v)writeln(n,i,"] = ",c,";");}
</code></pre>

<p>or ungolfed:</p>

<pre><code>import std.array, std.stdio;

void main() {
    string type, nameAndBracket, elems;
    readf("%s %s] = {%s}", &amp;type, &amp;nameAndBracket, &amp;elems);

    // remove all commas before splitting the string into substrings
    auto vector = elems.replace(",","").split();

    // writeln is shorter than fln by 1 char when filled in
    writeln(type, ' ', nameAndBracket, vector.length, "];");

    // print each element being assigned
    foreach(index, content; vector)
        writeln(nameAndBraket, index, "] = ", content, ";");
}
</code></pre>
</div>
<div id="pu15" class="pu"><h1><a href="https://github.com/dloscutoff/pip" rel="nofollow noreferrer">Pip</a>, <s>48</s> 47 bytes</h1>
<pre><code>qR`(\S+)(. = ).(.+)}`{[b#Yd^k']';.n.b.,#y.c.y]}
</code></pre>
<p>Takes input from stdin and prints to stdout.</p>
<h3>Explanation</h3>
<p><strong>Tl;dr:</strong> Does a regex replacement, using capture groups and a callback function to construct the result.</p>
<p>The <code>q</code> special variable reads a line of input. The regex is <code>(\S+)(. = ).(.+)}</code>, which matches everything except the type (including trailing space) and the final semicolon. Using the first example from the question, the capturing groups get <code>foo[</code>, <code>] = </code>, and <code>4, 8, 15, 16, 23, 42</code>.</p>
<p>The replacement is the return value of the unnamed function <code>{[b#Yd^k']';.n.b.,#y.c.y]}</code>, which is called with the whole match plus the capturing groups as arguments. Thus, within the function, <code>b</code> gets capture group 1, <code>c</code> gets group 2, and <code>d</code> gets group 3.</p>
<p>We construct a list, the first three items of which will be <code>&quot;foo[&quot;</code>, <code>6</code>, and <code>&quot;]&quot;</code>. To get the <code>6</code>, we split <code>d</code> on the built-in variable <code>k</code> = <code>&quot;, &quot;</code>, <code>Y</code>ank the resulting list of integers into the <code>y</code> variable for future use, and take the length (<code>#</code>). <code>']</code> is a character literal.</p>
<p>What remains is to construct a series of strings of the form <code>&quot;;\nfoo[i] = x&quot;</code>. To do so, we concatenate the following: <code>';</code>, <code>n</code> (a built-in for newline), <code>b</code> (1st capture group), <code>,#y</code> (equivalent to Python <code>range(len(y))</code>), <code>c</code> (2nd capture group), and <code>y</code>. Concatenation works itemwise on lists and ranges, so the result is a list of strings. Putting it all together, the return value of the function will be a list such as this:</p>
<pre><code>[&quot;foo[&quot; 6 &quot;]&quot;
 [&quot;;&quot; n &quot;foo[&quot; 0 &quot;] = &quot; 4]
 [&quot;;&quot; n &quot;foo[&quot; 1 &quot;] = &quot; 8]
 [&quot;;&quot; n &quot;foo[&quot; 2 &quot;] = &quot; 15]
 [&quot;;&quot; n &quot;foo[&quot; 3 &quot;] = &quot; 16]
 [&quot;;&quot; n &quot;foo[&quot; 4 &quot;] = &quot; 23]
 [&quot;;&quot; n &quot;foo[&quot; 5 &quot;] = &quot; 42]
]
</code></pre>
<p>Since this list is being used in a string <code>R</code>eplacement, it is implicitly cast to a string. The default list-to-string conversion in Pip is concatenating all the elements:</p>
<pre><code>&quot;foo[6];
foo[0] = 4;
foo[1] = 5;
foo[2] = 15;
foo[3] = 16;
foo[4] = 23;
foo[5] = 42&quot;
</code></pre>
<p>Finally, the result (including the type and the final semicolon, which weren't matched by the regex and thus remain unchanged) is auto-printed.</p>
</div>
<div id="pu16" class="pu"><h2>C,<s>278</s> 280 bytes</h2>

<p>golfed:</p>

<pre><code>x,e,l,d;char *m,*r,*a;char i[999];c(x){return isdigit(x)||x==45;}main(){gets(i);m=r=&amp;i;while(*r++!=32);a=r;while(*++r!=93);l=r-a;d=r-m;for(;*r++;*r==44?e++:1);printf("%.*s%d];\n",d,m,e+1);r=&amp;i;while(*r++){if(c(*r)){m=r;while(c(*++r));printf("%.*s%d] = %.*s;\n",l,a,x++,r-m,m);}}}
</code></pre>

<p>ungolfed:</p>

<pre><code>/* global ints
 * x = generic counter
 * e = number of elements
 * l = length of the array type
 * d = array defination upto the first '['
 */
x,e,l,d;
/* global pointers
 * m = memory pointer
 * r = memory reference / index
 * a = pointer to the start of the array type string
 */
char *m,*r,*a;
/* data storage for stdin */
char i[999];
c(x){return isdigit(x)||x=='-';}
main(){
    gets(i);
    m=r=&amp;i;
    while(*r++!=32);                // skip first space
    a=r;
    while(*++r!=93);                // skip to ']'
    l=r-a;
    d=r-m;
    for(;*r++;*r==44?e++:1);        // count elements
    printf("%.*s%d];\n",d,m,e+1);   // print array define
    r=&amp;i;
    while(*r++) {                   // print elements
        if(c(*r)) {                 // is char a - or a digit?
            m=r;
            while(c(*++r));         // count -/digit chars
            printf("%.*s%d] = %.*s;\n",l,a,x++,r-m,m);
        }
    }
}
</code></pre>

<p>While working on this someones posted a shorter version using sscanf for the parsing rather than using data pointers... nice one!</p>

<p>UPDATE:
Spotted missing spaces around the equals in the element printing, IDE online link:  <a href="http://ideone.com/KrgRt0" rel="nofollow">http://ideone.com/KrgRt0</a> . Note this implementation does support negative numbers...</p>
</div>
<div id="pu17" class="pu"><h1>Ruby, <s>127</s> <s>110</s> <s>108</s> <s>99</s> 88 bytes</h1>
<p><s>Anonymous function with a single argument as input.</s> Full program, reads the input from STDIN. (If you pipe a file in, the trailing newline is optional.) <s>Returns</s> Prints the output string.</p>
<p>Took @TimmyD bragging about their solution beating all other non-esolangs as a challenge, and finally overcome the (at the time of writing) 114 byte Powershell solution they had posted. <s>Cᴏɴᴏʀ O'Bʀɪᴇɴ's trick with splitting on <code>]</code> and splicing the second half to get the numbers helped.</s></p>
<p>I need to use the splat operator more. It's so useful!</p>
<p>Borrowed a trick from @Neil's JavaScript ES6 answer to save more bytes by scanning for words instead of using <code>gsub</code> and <code>split</code>..</p>
<pre><code>t,n,*l=gets.scan /-?\w+/;i=-1
puts t+&quot; #{n}[#{l.size}];&quot;,l.map{|e|n+&quot;[#{i+=1}] = #{e};&quot;}
</code></pre>
</div>
<div id="pu18" class="pu"><h1>Retina, <s>108</s> <s>104</s> <s>100</s> 69 bytes</h1>

<p>Byte count assumes ISO 8859-1 encoding.</p>

<pre><code>].+{((\S+ ?)+)
$#2];$1
+`((\w+\[).+;(\S+ )*)(-?\d+).+
$1¶$2$#3] = $4;
</code></pre>

<p>Beat this, PowerShell...</p>

<h2>Code explanation</h2>

<p><strong>First line:</strong> <code>].+{((\S+ ?)+)</code></p>

<p>First, we need to keep the type, array name, and opening bracket (it saves a byte), so we don't match them. So we match the closing bracket, any number of characters, and an opening curly brace: <code>].+{</code>. Then we match the number list. Shortest I've been able to find so far is this: <code>((\S+ ?)+)</code>. We match any number of non-space characters (this includes numbers, possible negative sign, and possible comma), followed by a space, that may or may not be there: <code>\S+ ?</code>. This group of characters is then repeated as many times as needed: <code>(\S+ ?)+</code> and put into the large capturing group. Note that we don't match the closing curly brace or semicolon. Third line explanation tells why.</p>

<p><strong>Second line:</strong> <code>$#2];$1</code></p>

<p>Since we only matched a part of input, the unmatched parts will still be there. So we put the length of the list after the unmatched opening bracket: <code>$#2</code>. The replace modifier <code>#</code> helps us with that, as it gives us the number of matches a particular capturing group made. In this case capturing group <code>2</code>. Then we put a closing bracket and a semicolon, and finally our whole list.</p>

<p>With input <code>short array[] = {4, 3, 2, 1};</code>, the internal representation after this replacing is:</p>

<pre>short array[4];4, 3, 2, 1};</pre>

<p>(note the closing curly brace and semicolon)</p>

<p><strong>Third line:</strong> <code>+`((\w+[).+;(\S+ )*)(-?\d+).+</code></p>

<p>This is a looped section. That means it runs until no stage in the loop makes a change to the input. First we match the array name, followed by an opening bracket: <code>(\w+\[)</code>. Then an arbitrary number of any characters and a semicolon: <code>.+;</code>. Then we match the list again, but this time only numbers and the comma after each number, which have a space following them: <code>(\S+ )*</code>. Then we capture the last number in the list: <code>(-?\d+)</code> and any remaining characters behind it: <code>.+</code>.</p>

<p><strong>Fourth line:</strong> <code>$1¶$2$#3] = $4;</code></p>

<p>We then replace it with the array name and list followed by a newline: <code>$1¶</code>. Next, we put the array name, followed by the length of previously matched list, without the last element (essentially <code>list.length - 1</code>): <code>$2$#3</code>. Followed by a closing bracket and assigment operator with spaces, and this followed by the last element of our number list: <code>] = $4;</code></p>

<p>After first replacing, the internal representation looks like this:</p>

<pre><code>short array[4];4, 3, 2, 
array[3] = 1;
</code></pre>

<p>Note that the closing curly brace and the semicolon disappeared, thanks to the <code>.+</code> at the end of third line.
After three more replacings, the internal representation looks like this:</p>

<pre><code>short array[4];
array[0] = 4;
array[1] = 3;
array[2] = 2;
array[3] = 1;
</code></pre>

<p>Since there's nothing more to match by third line, fourth doesn't replace anything and the string is returned.</p>

<p><strong>TL;DR:</strong> First we change up the int list format a bit. Then we take the last element of the list and the name, and put them after the array initialization. We do this until the int list is empty. Then we give the changed code back.</p>

<p><a href="http://retina.tryitonline.net/#code=XS4reygoXFMrID8pKykKJCMyXTskMQorYCgoXHcrXFspLis7KFxTKyApKikoLT9cZCspLisKJDHCtiQyJCMzXSA9ICQ0Ow&amp;input=dGVycmlibGVfbG9uZ190eXBlX25hbWUgYXdmdWxfYXJyYXlfbmFtZVtdID0gezcsIC04LCAxMzM3LCAwLCAxM307" rel="noreferrer">Try it online!</a></p>
</div>
<div id="pu19" class="pu"><h1>Pyth - <s>53</s> <s>50</s> <s>46</s> <s>45</s> 44 bytes</h1>
<p><em>2 bytes saved thanks to @FryAmTheEggman.</em></p>
<pre><code>+Jhcz\[+`]lKcPecz\{d\;j.es[ecJd`]kd\=dPb\;)K
</code></pre>
<p><a href="http://pyth.herokuapp.com/?code=%2BJhcz%5C%5B%2B%60%5DlKcPecz%5C%7Bd%5C%3Bj.es%5BecJd%60%5Dkd%5C%3DdPb%5C%3B%29K&amp;input=int+foo%5B%5D+%3D+%7B4%2C+8%2C+15%2C+16%2C+23%2C+42%7D%3B&amp;test_suite=1&amp;test_suite_input=int+foo%5B%5D+%3D+%7B4%2C+8%2C+15%2C+16%2C+23%2C+42%7D%3B%0Ashort+array%5B%5D+%3D+%7B4%2C+3%2C+2%2C+1%7D%3B%0Aspam+EGGS%5B%5D+%3D+%7B42%7D%3B%0Aterrible_long_type_name+awful_array_name%5B%5D+%3D+%7B7%2C+-8%2C+1337%2C+0%2C+13%7D%3B&amp;debug=0" rel="nofollow noreferrer">Test Suite</a>.</p>
</div>
<div id="pu20" class="pu"><h1>Pyth, 44 bytes</h1>

<pre><code>++Khcz\]lJ:z"-?\d+"1"];"VJs[ecKd~hZ"] = "N\;
</code></pre>

<p><a href="https://pyth.herokuapp.com/?code=%2B%2BKhcz%5C%5DlJ%3Az%22-%3F%5Cd%2B%221%22%5D%3B%22VJs%5BecKd~hZ%22%5D+%3D+%22N%5C%3B&amp;input=int+foo%5B%5D+%3D+%7B4%2C+8%2C+15%2C+16%2C+23%2C+42%7D%3B&amp;test_suite=1&amp;test_suite_input=int+foo%5B%5D+%3D+%7B4%2C+8%2C+15%2C+16%2C+23%2C+42%7D%3B%0Ashort+array%5B%5D+%3D+%7B4%2C+3%2C+2%2C+1%7D%3B%0Aspam+EGGS%5B%5D+%3D+%7B42%7D%3B%0Aterrible_long_type_name+awful_array_name%5B%5D+%3D+%7B7%2C+-8%2C+1337%2C+0%2C+13%7D%3B&amp;debug=0">Test suite</a></p>

<p>Regular expression and string chopping. Not particularly clever.</p>

<p>Explanation:</p>

<pre><code>++Khcz\]lJ:z"-?\d+"1"];"VJs[ecKd~hZ"] = "N\;
                                                Implicit: z = input()
    cz\]                                        Chop z on ']'
   h                                            Take string before the ']'
  K                                             Store it in K
 +                                              Add to that
         :z"-?\d+"1                             Find all numbers in the input
        J                                       Store them in J
       l                                        Take its length.
+                  "];"                         Add on "];" and print.
                       VJ                       For N in J:
                         s[                     Print the following, concatenated:
                            cKd                 Chop K on spaces.
                           e                    Take the last piece (array name)
                               ~hZ              The current interation number
                                  "] = "        That string
                                        N       The number from the input
                                         \;     And the trailing semicolon.
</code></pre>
</div>
<div id="pu21" class="pu"><h2>bash, <s>133</s> 129 bytes</h2>
<pre class="lang-bsh prettyprint-override"><code>read -a l
d=&quot;${l[@]:0:2}&quot;
e=(&quot;${l[@]:3}&quot;)
echo &quot;${d%?}${#e[@]}];&quot;
for i in &quot;${!e[@]}&quot;
{
echo &quot;${l[0]}[$i] = ${e[$i]//[!0-9]/};&quot;
}
</code></pre>
<p>First attempt, sure its posible to get it shorter.</p>
</div>
<div id="pu22" class="pu"><h2>Python 3, 116 bytes</h2>

<pre class="lang-python prettyprint-override"><code>t,v,_,*l=input().split();v=v[:-1]+'%s]'
print(t,v%len(l)+';');i=0
for x in l:print(v%i,'= %s;'%x.strip('{,};'));i+=1
</code></pre>
<p>Splits the input into the type, name, and the list of numbers. After printing the array declaring, prints the elements by manually enumerating through the numbers, removing excess punctuation that attached to the first and last one.</p>
<p>A different approach in Python 2 came out to 122 bytes:</p>
<pre class="lang-python prettyprint-override"><code>a,b=input()[:-2].split('] = {')
l=eval(b+',')
print a+`len(l)`+&quot;];&quot;
for y in enumerate(l):print a.split()[1]+'%s] = %s;'%y
</code></pre>
<p>The idea is to <code>eval</code> the list of numbers as a tuple, with a comma at the end so that a single number is recognized as a type. The enumerated list of numbers provides tuples to string-format in.</p>
</div>
<div id="pu23" class="pu"><h2>JavaScript (ES6), 100 bytes</h2>

<pre><code>(s,[t,n,...m]=s.match(/-?\w+/g))=&gt;t+` ${n}[${m.length}];`+m.map((v,i)=&gt;`
${n}[${i}] = ${v};`).join``
</code></pre>

<p>Since only the words are important, this works by just matching all the words in the original string, plus leading minus signs, then building the result. (I originally thought I was going to use <code>replace</code> but that turned out to be a red herring.)</p>
</div>
<div id="pu24" class="pu"><h1>Awk, 101 bytes</h1>

<pre><code>{FS="[^[:alnum:]_-]+";printf"%s %s[%d];\n",$1,$2,NF-3;for(i=3;i&lt;NF;i++)printf$2"[%d] = %d;\n",i-3,$i}
</code></pre>

<p>More readably:</p>

<pre><code>{
FS="[^[:alnum:]_-]+"
printf "%s %s[%d];\n", $1, $2, NF - 3
for (i=3; i &lt; NF; i++)
    printf $2"[%d] = %d;\n", i-3, $i
}
</code></pre>

<ul>
<li>I set the field separator to everything except alphabets, digits, the underscore and <code>-</code>. So, the fields would be the type name, the variable name, and the numbers.</li>
<li>The number of fields will be 1 (for the type) + 1 (for the name) + N (numbers) + 1 (an empty field after the trailing <code>};</code>). So, the size of the array is <code>NF - 3</code>.</li>
<li>Then it's just printing a special line for the declaration, and looping over the numbers.</li>
<li>I <em>should</em> assign <code>FS</code> either when invoking awk (using <code>-F</code>) or in a <code>BEGIN</code> block. In the interests of brevity, ….</li>
</ul>
</div>
<div id="pu25" class="pu"><h2>Python 3.6 (pre-release), 133</h2>
<pre class="lang-python prettyprint-override"><code>m,p=str.split,print;y,u=m(input(),'[');t,n=m(y);i=m(u[5:-2],', ')
l=len(i);p(t,n+f'[{l}];')
for x in range(l):p(n+f'[{x}] = {i[x]};')
</code></pre>
<p>Makes heavy use of <a href="https://www.python.org/dev/peps/pep-0498/" rel="noreferrer">f-strings</a>.</p>
<p>Ungolfed version:</p>
<pre class="lang-python prettyprint-override"><code>y, u = input().split('[')
t, n = y.split()
i = u[5:-2].split(', ')
l = len(i)
print(t, n + f'[{l}];')
for x in range(l):
    print(n + f'[{x}] = {i[x]};')
</code></pre>
</div>
<div id="pu26" class="pu"><h2>Python 2, 159 bytes</h2>
<pre class="lang-py prettyprint-override"><code>s=input().split()
t,n,v=s[0],s[1][:-2],''.join(s[3:])
a=v[1:-2].split(',')
print'%s %s[%d];'%(t,n,len(a))
for i in range(len(a)):print'%s[%d] = %s;'%(n,i,a[i])
</code></pre>
<p><a href="http://ideone.com/fork/mm2tbz" rel="nofollow noreferrer">Try it online</a></p>
<p>Thanks Kevin Lau for some golfing suggestions</p>
</div>
<div id="pu27" class="pu"><h1><a href="http://github.com/Adriandmen/05AB1E" rel="nofollow noreferrer">05AB1E</a>, <s>52</s> <s>50</s> 47 bytes</h1>
<p>Code:</p>
<pre><code>… = ¡`¦¨¨ð-',¡©gr¨s«„];«,®v¹ð¡¦¬s\¨N&quot;] = &quot;y';J,
</code></pre>
<p>Uses <strong>CP-1252</strong> encoding. <a href="http://05ab1e.tryitonline.net/#code=4oCmID0gwqFgwqbCqMKow7AtJyzCocKpZ3LCqHPCq-KAnl07wqsswq52wrnDsMKhwqbCrHNcwqhOIl0gPSAieSc7Siw&amp;input=aW50IGZvb1tdID0gezQsIDgsIDE1LCAxNiwgMjMsIDQyfTs" rel="nofollow noreferrer">Try it online!</a>.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/77857/">77857</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




