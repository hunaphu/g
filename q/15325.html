<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::15325</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>275</td><td>Python3</td><td>251006T190640Z</td><td><a href="https://codegolf.stackexchange.com/questions/15325/optimizing-my-spell-casts/284014#284014">Ajax1234</a></td></tr>
<tr d-ix="1"><td>131</td><td>Mathematica</td><td>131127T001458Z</td><td><a href="https://codegolf.stackexchange.com/questions/15325/optimizing-my-spell-casts/15450#15450">DavidC</a></td></tr>
<tr d-ix="2"><td>143</td><td>Haskell GHC</td><td>131124T122649Z</td><td><a href="https://codegolf.stackexchange.com/questions/15325/optimizing-my-spell-casts/15388#15388">FireFly</a></td></tr>
<tr d-ix="3"><td>055</td><td>GolfScript</td><td>131123T093017Z</td><td><a href="https://codegolf.stackexchange.com/questions/15325/optimizing-my-spell-casts/15377#15377">Howard</a></td></tr>
<tr d-ix="4"><td>nan</td><td>Ruby</td><td>131119T150340Z</td><td><a href="https://codegolf.stackexchange.com/questions/15325/optimizing-my-spell-casts/15329#15329">John Dvo</a></td></tr>
<tr d-ix="5"><td>087</td><td>APL</td><td>131119T173246Z</td><td><a href="https://codegolf.stackexchange.com/questions/15325/optimizing-my-spell-casts/15334#15334">marinus</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Python3, 275 bytes</h1>
<pre class="lang-py prettyprint-override"><code>def f(Y,s):
 q,r=[(0,[])],[]
 for i,a in q:
  r+=[((Y-sum(u for _,u in a),sum(u for u,_ in a)),a)]
  if i&gt;=len(s):continue
  q+=[(i+1,a)];A=a+[(i,s[i])]
  if sum(u for _,u in A)&lt;=Y:q+=[(i+1,A)]
 m=min(r,key=lambda x:x[0])[0]
 return{tuple(u for _,u in b)for a,b in r if a==m}
</code></pre>
<p><a href="https://tio.run/##bZDhasIwFIV/26e4/5qr2WhXtzm7DHwMKUXS2bKwNk3TBJSxZ3c36iZDCQnce757ThKzdx@9zhbGHg7buoGGrfmIywgGbkXBEl6UWNIRQdNbUFyC0jCQDnZGOlvfjb5j/qhuuA@qRH7peb459ZBLJBdQDag30daaUcx7r53Svqb@EOzULA1YvhJyRhUfC1X@Tl3lrPBVrJd/c6sAdqJTmln@We9FK7tqK2G33BVJibQjsLXzVn85b9r6v1mFoZC8CoUNeVKI7vv4J67fKG3CfaOJ5FCBgPF@NK1yLM5jjCYnW5p0jB5fTDtpGBWEnjGku0XGBqBh07NfPM9TeICM1jM8xYh4jWSEZPBIWJrcJhb5HFJ4uS2eEigjyIcf" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1>Mathematica 131</h1>
<p>There must be shorter ways, but this is what I was able to come up with.</p>
<pre><code>l=Length;
f[{a_,b_}]:=Select[t=Cases[s=SortBy[Union@Cases[Subsets[b],x_/;0&lt;Tr@x&lt;a+1:&gt;{x,Tr@x}],Last],
{x_,s[[-1,2]]}:&gt; x],l@#==l@t[[1]]&amp;]
</code></pre>
<hr />
<pre><code>f[{4, {1, 2, 3, 7, 6}}]
</code></pre>
<blockquote>
<p>{{1, 3}}</p>
</blockquote>
<hr />
<pre><code>f[{3, {1, 3, 5, 2, 10}}]
</code></pre>
<blockquote>
<p>{{3}}</p>
</blockquote>
<hr />
<pre><code>f[{8, {4, 1, 9}}]
</code></pre>
<blockquote>
<p>{{4, 1}}</p>
</blockquote>
<hr />
<pre><code>f[{4, {1, 2, 2, 3}}]
</code></pre>
<blockquote>
<p>{{1, 3}, {2, 2}}</p>
</blockquote>
</div>
<div id="pu2" class="pu"><h3>Haskell (GHC), <s>172 167</s> 143 chars</h3>



<pre><code>import Data.List
import GHC.Exts
f(x:y)=head.groupWith length.last.groupWith sum.filter((&lt;=x).sum).nub$subsequences y
main=interact$show.f.read
</code></pre>

<p>Deobfuscated:</p>

<pre><code>import Data.List
import GHC.Exts

f (x:xs) = head
         . groupWith length
         . last
         . groupWith sum
         . filter ((&lt;= x) . sum)
         . nub
         $ subsequences xs

main = interact (show . f . read)
</code></pre>

<ul>
<li>Input format: bracketed list with head as available mana, tail as avaliable spells (e.g. <code>[4,1,2,3,3,7,6]</code>).</li>
<li>Output format: bracketed list of lists, each sublist representing one possible set of spells.</li>
</ul>

<p>Straightforward solution: grab the powerset of the input, then reduce that down by filtering for combinations we have sufficient mana for, etc.</p>
</div>
<div id="pu3" class="pu"><h3>GolfScript, 55 characters</h3>
<pre><code>[[]]\{{+}+1$%|}/.@{1$0+{+}*.@&gt;!*100*\,-~}+:s%$0={\s=}+,
</code></pre>
<p>Try it <a href="http://golfscript.apphb.com/?c=ewoKW1tdXVx7eyt9KzEkJXx9Ly5AezEkMCt7K30qLkA%2BISoxMDAqXCwtfn0rOnMlJDA9e1xzPX0rLAoKfTpDOwoKNCBbMSAxIDIgMyAzIDcgNl0gQyBwCjMgWzEgMyA1IDIgMTBdIEMgcAo4IFs0IDEgOV0gQyBwCjQgWzEgMiAyIDNdIEMgcAo%3D&amp;run=true" rel="nofollow noreferrer">online</a>.</p>
<pre><code>&gt; 4 [1 1 2 3 3 7 6]
[[1 3]]

&gt; 3 [1 3 5 2 10]
[[3]]

&gt; 8 [4 1 9]
[[4 1]]

&gt; 4 [1 2 2 3]
[[2 2] [1 3]]
</code></pre>
</div>
<div id="pu4" class="pu"><h3>Ruby, <del>114</del> 113 characters</h3>

<pre><code>x,y=eval gets
(d=0..10).find{|r|d.find{|c|s=y.sort.combination(c).select{|s|s.reduce(:+)==x-r}.uniq
p s if s[0]}}
</code></pre>

<p>Input: a two-element array of the wizard mana and the spell list, formatted a one-line JSON.</p>

<p>Output: a 2D array of the spell lists, formatted as a one-line JSON, or <code>nil</code> if the wizard can cast no spell.</p>

<p>I especially love <code>x,y = eval gets</code>. So dangerous and evil, yet so powerful and simple. Perfect for golfing.</p>

<p>Both <code>sort</code> and <code>uniq</code> are neccessary. Otherwise, this will produce duplicates for input like <code>[4, [1, 3, 1]]</code>. I'm not happy about this.</p>

<p><code>find</code> is a useful method for control flow. Its return value is not as useful here, though. Length-wise, it comes on par with <code>any?</code>, which return value is even less useful.</p>

<p>Examples:</p>

<pre><code>&gt; [4, [1, 2, 3, 3, 7, 6]]
# [[1, 3]]
&gt; [3, [1, 3, 5, 2, 10]]
# [[3]]
&gt; [8, [4, 1, 9]]
# [[1, 4]]
&gt; [4, [1, 2, 2, 3]]
# [[1, 3], [2, 2]]
&gt; [4, [5, 6, 7]]
# nil
</code></pre>
</div>
<div id="pu5" class="pu"><h2>APL (87)</h2>

<pre><code>↑∪m/⍨t=⌊/t←⊃∘⍴¨m←m/⍨t=⌈/t←+/¨m←{a/⍨⊃i≥+/a←k[⍵]}¨⊃,/g,{z/⍨∧/¨2&gt;/¨z←,⍳⍵/⍴k}¨1↓g←⍳⍴k←1↓i←⎕
</code></pre>

<p>The input format is an APL list, where the first element is the mana pool and the rest of the elements are the spells. The output has each possible combination of spells on a separate line.</p>

<pre><code>⎕:    4, 1 2 3 3 7 6
3 1
⎕:    3, 1 3 5 2 10
3
⎕:    8, 4 1 9
1 4
⎕:    4, 1 2 2 3
2 2
3 1
</code></pre>

<p>Explanation:</p>

<ul>
<li><code>k←1↓i←⎕</code>: read a list from the input, and store it in <code>i</code>. Drop the first element (mana) and store the rest in <code>k</code>.</li>
<li><code>1↓g←⍳⍴k</code>: generate a list from <code>1</code> to the length of <code>k</code>, and store it in <code>g</code>. Drop the first element, giving <code>[2..len k]</code>.</li>
<li><code>{</code>...<code>}¨</code>: For each of these, get the indices of each unique combination in <code>k</code> of length <code>⍵</code>:
<ul>
<li><code>z←,⍳⍵/⍴k</code>: get a <code>⍵</code>-dimensional matrix of indices of length <code>k</code>, flatten it, and store it in <code>z</code>.</li>
<li><code>∧/¨2&gt;/¨</code>: for each coordinate in each index, see if all coordinates for the <code>N</code>th dimension are higher than those for the <code>N-1</code>th dimension.</li>
<li><code>z/⍨</code>: select from <code>z</code> those elements for which the above holds true</li>
</ul></li>
<li><code>⊃,/g,</code>: because the above does not work for one-dimensional vectors, add <code>g</code> to the front. We now have a list of lists of lists (because of the foreach) of all unique indices into <code>k</code>. Concatenate the lists together and de-enclose (so we end up with a list of lists).</li>
<li><code>{</code>...<code>}¨</code>: for each possible list of coordinates, look up the corresponding combination of values in <code>k</code>, and filter out those that are too expensive:
<ul>
<li><code>a←k[⍵]</code>: look up the current combination in <code>k</code> and store it in <code>a</code>.</li>
<li><code>a/⍨⊃i≥+/a</code>: select <code>a</code> only if the first item in <code>i</code> (the mana pool) is equal to or greater than the sum of the elements of <code>a</code>.</li>
</ul></li>
<li><code>m←</code>: store all combinations of spells that do not exceed the mana limit in <code>m</code>.</li>
<li><code>m←m/⍨t=⌈/t←+/¨m</code>: select from <code>m</code> only those combinations whose sum is equal to the sum of the most expensive combination, and store it in <code>m</code> again.</li>
<li><code>m/⍨t=⌊/t←⊃∘⍴¨m</code>: select from <code>m</code> only those combinations whose length is equal to the length of the shortest combination.</li>
<li><code>↑∪</code>: remove any duplicates, and convert to a matrix (to display each combination on a separate line).</li>
</ul>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/15325/">15325</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




