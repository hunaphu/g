<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::283193</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>010</td><td>05AB1E</td><td>250819T082203Z</td><td><a href="https://codegolf.stackexchange.com/questions/283193/pennies-to-dollars/283202#283202">Kevin Cr</a></td></tr>
<tr d-ix="1"><td>013</td><td>Jelly</td><td>250820T114129Z</td><td><a href="https://codegolf.stackexchange.com/questions/283193/pennies-to-dollars/283239#283239">Jonathan</a></td></tr>
<tr d-ix="2"><td>084</td><td>JavaScript ES6</td><td>250819T094002Z</td><td><a href="https://codegolf.stackexchange.com/questions/283193/pennies-to-dollars/283205#283205">Arnauld</a></td></tr>
<tr d-ix="3"><td>083</td><td>Wolfram Language Mathematica</td><td>250820T024216Z</td><td><a href="https://codegolf.stackexchange.com/questions/283193/pennies-to-dollars/283232#283232">Greg Mar</a></td></tr>
<tr d-ix="4"><td>256</td><td>Python3</td><td>250819T152255Z</td><td><a href="https://codegolf.stackexchange.com/questions/283193/pennies-to-dollars/283212#283212">Ajax1234</a></td></tr>
<tr d-ix="5"><td>045</td><td>Charcoal</td><td>250819T091020Z</td><td><a href="https://codegolf.stackexchange.com/questions/283193/pennies-to-dollars/283203#283203">Neil</a></td></tr>
<tr d-ix="6"><td>011</td><td>Nekomata</td><td>250819T033049Z</td><td><a href="https://codegolf.stackexchange.com/questions/283193/pennies-to-dollars/283198#283198">alephalp</a></td></tr>
<tr d-ix="7"><td>013</td><td>Vyxal</td><td>250819T004348Z</td><td><a href="https://codegolf.stackexchange.com/questions/283193/pennies-to-dollars/283194#283194">lyxal</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 10 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>Ã£OÊ’Ã£OÑ‚/Â¹QÃ 
</code></pre>
<p>Inputs in the order <span class="math-container">\$B,list\$</span>. Output isn't sorted and contains possibly duplicated values.</p>
<p><a href="https://tio.run/##yy9OTMpM/f//8GL/U5OAxMUm/UM7A/XOTfn/34gr2lBHwUhHwVRHwdAAyAJiUwMQ2yAWAA" rel="nofollow noreferrer">(Don't) try it online.</a> (Will time out for every test case..)</p>
<p>Replacing the <code>Ã </code> with <code>.Î”</code>, allows it to at least output for the example test case to verify it works: <a href="https://tio.run/##yy9OTMpM/f//8GL/U5OAxMUm/UM7A/XOTfn/34gr2lBHwUhHwVRHwdAAyAJiUwMQ2yAWAA" rel="nofollow noreferrer">Try it online</a>. (All other test cases will still time out..)</p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>Ã£          # Cartesian product, to get all (implicit) first input B-sized lists
           # using values of the (implicit) second input-list
 O         # Sum each inner B-sized list
  Ê’        # Filter this list of A's by:
   Ã£       #  Cartesian product again, to get all A-sized lists using values
           #  of the (implicit) second input-list
    O      #  Sum each inner A-sized list again
     Ñ‚/    #  Divide each by 100
       Â¹Q  #  Check if it equals the first input-integer
         Ã  #  Check if any is truthy within this list for size A
           # (after which the filtered list is output implicitly as result)
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 13 <a href="https://github.com/DennisMitchell/jelly/wiki/Code-page" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>á¹—Â§QÂ³á¹—Â§Ã·È·2iÊ‹É—Æ‡
</code></pre>
<p>A full program that accepts the list of denominations and the initial coin count <span class="math-container">\$B\$</span> and prints a list of all valid coin counts <span class="math-container">\$A\$</span> (to only print one, add <code>á¸¢</code> for 1 byte).</p>
<p><a href="https://tio.run/##y0rNyan8///hzumHlgce2gymD28/sd0o81T3yenH2v///x9tpKNgrKNgZBz73wgA" rel="nofollow noreferrer" title="Jelly â€“ Try It Online">Don't try it online!</a>, but <strong><a href="https://tio.run/##y0rNyan8///o5CPdh5YHHtoMYRzefmK7Ueap7pPTj7X////fSEfBWEfByPi/EQA" rel="nofollow noreferrer" title="Jelly â€“ Try It Online">this is a touch faster</a></strong> (using combinations-with replacement in place of Cartesian powers).</p>
<h4>How?</h4>
<pre><code>á¹—Â§QÂ³á¹—Â§Ã·È·2iÊ‹É—Æ‡ - Main Link: L, B
á¹—             - {L} Cartesian power {B} -&gt; all B-coin collections
 Â§            - sums
  Q           - deduplicate -&gt; possible B-coin sums
            Æ‡ - keep those for which:
           É—  -   last three links as a dyad - f(CoinSum, B):
   Â³          -     program's first argument -&gt; L
    á¹—         -     Cartesian power {CoinSum} -&gt; all CoinSum-coin collections
          Ê‹   -     last four links as a dyad - f(CoinSum-coinCollections, B):
     Â§        -       sums -&gt; possible CoinSum-coin sums
      Ã·       -       divide all of {those} by...
       È·2     -       ...10^2 = 100
         i    -       first 1-index of {B} in that or 0
              - implicit print
</code></pre>
</div>
<div id="pu2" class="pu"><h1>JavaScript (ES6), 84 bytes</h1>
<p>Expects <code>(L)(B)</code> and returns the first solution found.</p>

<pre class="lang-javascript prettyprint-override"><code>L=&gt;B=&gt;(g=(v,n,[q,...b]=L)=&gt;q*v&gt;0?g(v,n,b)||g(v-q,-~n):~~v?0:v?n*g(n):n==B)(100*B+.5)
</code></pre>
<p><a href="https://tio.run/##lVLdaoMwFL7fU@QycdHmV10hCl73DcSLtmtlo8S5Dq@Kr@5OooOuSzcmBL7kfD85J75uh@15//7y9hHb7vkwHc20MUVlCtwaPFBL654mSbJrzIaYoo@GgpWtL@zI5QIo7mk8WrIex6Fk66G0UYtha42pCOaMRdVjosm07@y5Ox2SU9fiI641RZw1BOeEoMC3WqGcPdxoBEVfMhGQgUb8ppFhjQxpJEVC3s@pBZiKlCKVNvcSgRC6qVO7Igcedy6OCNg5SsCK/eUoQ46OkF25qdlRZLOrdD1p5w4LsAKsAac/0ziorgJnHrzj0ovv3g8IImAC2Uzk/HtL8Mu4A1fR3udfQWoJUr4@p@QUPd1kySVHOrXUfnqsmT4B" rel="nofollow noreferrer" title="JavaScript (Node.js) â€“ Try It Online">Try it online!</a></p>
<h3>Commented</h3>
<p>The recursive function <span class="math-container">\$g\$</span> is called a first time to find a list of <span class="math-container">\$n\$</span> coins that sum to <span class="math-container">\$100B\$</span> (with no constraint on <span class="math-container">\$n\$</span>) and a second time to find a list of <span class="math-container">\$B\$</span> coins that sum to <span class="math-container">\$n\$</span>. We add <span class="math-container">\$0.5\$</span> to the target sum in the first pass to distinguish it from the second.</p>
<pre class="lang-javascript prettyprint-override"><code>L =&gt;            // outer function taking the list L[]
B =&gt; (          // inner function taking B
g = (           // g = recursive function taking:
  v,            //   v = target value
  n,            //   n = counter
  [ q,          //   q = next value from L[]
    ...b ] = L  //   b[] = remaining values in L[]
) =&gt;            //
q * v &gt; 0 ?     // if q is defined and v is positive:
  g(v, n, b) || //   1st recursive call with q ignored,
                //   using b[] for the next values
  g(v - q, -~n) //   2nd recursive call with q subtracted
                //   from v and n incremented, restarting
                //   from L[]
:               // else (end of pass):
  ~~v ?         //   if floor(v) is not 0:
    0           //     target not reached: do nothing
  :             //   else:
    v ?         //     if v is still equal to 0.5 (1st pass):
      n * g(n)  //       recursive call with n as the target
                //       the result is multiplied by n
    :           //     else (2nd pass):
      n == B    //       test whether n is equal to B
)(100 * B + .5) // initial call with 100*B+0.5 as the target
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.wolfram.com/wolframscript/" rel="nofollow noreferrer">Wolfram Language (Mathematica)</a>, 83 bytes</h1>
<pre><code>e=Exponent[#,x,List]&amp;;L_~f~B_:=SelectFirst[e@(p=Tr[x^L]^#&amp;)@B,MemberQ[e@p@#,100B]&amp;]
</code></pre>
<p><a href="https://tio.run/##y00syUjNTSzJTE78/z/V1rWiID8vNa8kWlmnQscns7gkVs3aJ74urc4p3so2ODUnNbnELbOouCQ61UGjwDakKLoizic2TllN08FJxzc1Nym1KBAoVeCgrGNoYOAUqxb7P6AoE2icQlq0QrUpULBWR8FCITaWC0nYSAcqYYRLwhhDwljHyBinDh0jAwJy6AYa6sBldUwNQG7HYgBWRSYgRf8B" rel="nofollow noreferrer" title="Wolfram Language (Mathematica) â€“ Try It Online">Try all test cases online!</a> Defines a named function <code>f</code> that takes the list <code>L</code> as the first argument and the number <code>B</code> as the second argument.</p>
<p>I was motivated by trying to find code that finished quickly, and the approach uses generating functions. Using the third test case as an example: the exponents of the polynomial <span class="math-container">\$(x^2+x^5+x^{10})^3 = x^6 + 3 x^9 + 3 x^{12} + 3 x^{14} + x^{15} + 6 x^{17} + 3 x^{20} + 3 x^{22} + 3 x^{25} + x^{30}\$</span>, namely 6,9,12,14,15,17,20,22,25,30, are the values that can be made with 3 coins from the list {2,5,10}. (The coefficients record how many ways this can be done, but we're ignoring that here.) We then want to look at the polynomials <span class="math-container">\$(x^2+x^5+x^{10})^6\$</span>, <span class="math-container">\$(x^2+x^5+x^{10})^9\$</span>, <span class="math-container">\$(x^2+x^5+x^{10})^{12}\$</span>, â€¦Â in turn to see if the exponent 300 ever appears.</p>
<p>In the code, <code>e</code> is a helper function that produces the list of exponents of a polynomial in <code>x</code>, while <code>p</code> is a helper function that computes polynomials of the form <span class="math-container">\$(x^2+x^5+x^{10})^3\$</span> where the exponents of <code>x</code> are from <code>L</code> and the power at the end is the argument of <code>p</code>. Then <code>e@p@B</code> is the list of possible candidates for <span class="math-container">\$A\$</span>, which we need to examine by seeing whether <code>100B</code> is one of the exponents of <code>e@p@#</code> where <code>#</code> is the candidate. <code>SelectFirst</code> finds and returns the first successful candidate, both abiding by the spec and also making the code terminate much faster.</p>
</div>
<div id="pu4" class="pu"><h1>Python3, 256 bytes</h1>
<pre class="lang-py prettyprint-override"><code>def C(l,b,a):
 q=[(l,[])]
 for l,L in q:
  if len(L)==b:
   if a==-1 or sum(L)==a:yield L
   continue
  if l:q+=[(l[1:],K)for i in range(b-len(L)+1)if sum(K:=L+[l[0]]*i)&lt;=a or a==-1]
def f(l,b):
 for L in C(l,b,-1):
  for _ in C(l,O:=sum(L),100*b):return O
</code></pre>
<p><a href="https://tio.run/##fY/BbsMgEETv/oo9QowlSFopQuXUYyzlAxCqcINTJIptah/y9S5rJ1WrNr2xb2Znh/4yvnVxt@/TPJ9cC88ksIZZKgsYlM6DNtQU0HYJAqvBRxiyBL6F4CKpqVINzgisUpWAbPyY3hfFyot34QQ1Gl67OPo4ueuyHEqM10IadqAY7zE82Xh2pKnW8FLQ7MW4g1R1qYPmxmw8fVIW7ywHTYG1W6yNpTFpqbl@pBIIF/pyo0ep1oZMcL7JW8mNU4pwnPvk40haoh8ZCG4Y7CktvuCWwY1v7/DdXzzb7@5ctR97IsNvcn5yfP/K@Mf3QOn8CQ" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 45 bytes</h1>
<pre><code>ï¼¦ï¼¥ï¼¸ï¼¬Î¸Î·Î£ï¼¥Î·Â§Î¸Ã·Î¹ï¼¸ï¼¬Î¸Î»Â¿Â¬â…ˆÂ¿â„–ï¼¥ï¼¸ï¼¬Î¸Î¹Î£ï¼¥Î¹Â§Î¸Ã·Îºï¼¸ï¼¬Î¸Î¼Ã—Â¹â°â°Î·ï¼©Î¹
</code></pre>
<p><a href="https://tio.run/##dc5RC4JADADgv7LHCQtOyaeewl6ECqEeAvFB9MyReqmn9e@vMwmCbDDY2Ma3rEy7TKWVMYXqAA/pHSP1kB3uZXPVJbYOQWnzNNTvYUmw1WGTyye2BGGjdzxyLpEJfu4qZw7gAvCoNF7w0wVqaPSyxl8a/9FuC1o9YwRnrmWPrhDT59aLOrZWkPYa2XE2xsSxS@AR@ASuXfJs@mKqRUKwTsxqrF4" rel="nofollow noreferrer" title="Charcoal â€“ Try It Online">Try it online!</a> Link is to verbose version of code. Stupidly slow, so only finishes for the last two test cases on TIO. Explanation:</p>
<pre><code>ï¼¦ï¼¥ï¼¸ï¼¬Î¸Î·Î£ï¼¥Î·Â§Î¸Ã·Î¹ï¼¸ï¼¬Î¸Î»
</code></pre>
<p>Get all sums of lists of <code>B</code> elements of <code>L</code>.</p>
<pre><code>Â¿Â¬â…ˆ
</code></pre>
<p>Stop once an answer is found.</p>
<pre><code>Â¿â„–ï¼¥ï¼¸ï¼¬Î¸Î¹Î£ï¼¥Î¹Â§Î¸Ã·Îºï¼¸ï¼¬Î¸Î¼Ã—Â¹â°â°Î·
</code></pre>
<p>Get all sums of lists of <code>A</code> elements of <code>L</code>, and see if any of them contain <code>100B</code>.</p>
<pre><code>ï¼©Î¹
</code></pre>
<p>If so then output <code>A</code>.</p>
<p>49 bytes for a much faster version which can solve all of the test cases on ATO:</p>
<pre><code>âŠÏ…ï¼¥âŠ•Ã—Â¹â°â°Î·Â¬Î¹ï¼¦âŒŠÏ…Â«â‰”âŒŠÏ…Î¶âŠÏ…ï¼¥Î¶âŠ™Î¸âˆ§Ã·Î»Î¼Â§Î¶â»Î»Î¼Â»ï¼©âŒ•ï¼¡Ã—ï¼¥Ï…Â§Î¹Â±Â¹Â§Ï…Î·Â¹
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=TZCxasMwEIbn-CmOTCdQwEkpFDyZhECGlAzdjAfVUuIDSU4tKSQpfZIuGVravU_TB-leuTHUtxz8fPfff_f6WdWirRqhL5f34LeTu--fTXA1Bg5rsceVrVpllPVK4gMZ5XCaphxqxjjcNx6JMZYl26YFXJMlEwwGxuA5GeXO0c4OVA7niI6G7mcOuT3hU9dk3OUXdCCpUHMwkc_9ykp17LBoE9xV_6sseUk2LVmPc-E8LsnKXOs-Ymcd_scpRlU74RVOGRvYhv6OTs3e3GPl-hd8FOPJQY_Lr6KYcbiNRDx5lpYcbsor8Qs" rel="nofollow noreferrer" title="Charcoal â€“ Attempt This Online">Attempt This Online!</a> Link is to verbose version of code. Explanation: Uses @alephalpha's polynomial trick to calculate which potential sums are possible and intersects the sums for <code>B</code> elements with the sums for <code>A</code> elements that sum to <code>100B</code>.</p>
<pre><code>âŠÏ…ï¼¥âŠ•Ã—Â¹â°â°Î·Â¬Î¹
</code></pre>
<p>Start with the sums for <code>0</code> elements. We're only interested in sums that go up to <code>100B</code>.</p>
<pre><code>ï¼¦âŒŠÏ…Â«â‰”âŒŠÏ…Î¶âŠÏ…ï¼¥Î¶âŠ™Î¸âˆ§Ã·Î»Î¼Â§Î¶â»Î»Î¼Â»
</code></pre>
<p>Calculate <code>100B</code> more sets of sums, using saturation so that the values are either <code>0</code> or <code>1</code>. (Interpolating <code>Minimum(u)</code> would reduce the byte count by a further <code>4</code> but makes the code too slow for the last test case to finish on ATO.)</p>
<pre><code>ï¼©âŒ•ï¼¡Ã—ï¼¥Ï…Â§Î¹Â±Â¹Â§Ï…Î·Â¹
</code></pre>
<p>Output those sums of <code>B</code> that can have sums of <code>100B</code>. These are the <code>1</code> entries in the vectorised product of the <code>B</code>th row and <code>100B</code>th column.</p>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/AlephAlpha/Nekomata" rel="nofollow noreferrer">Nekomata</a>, 11 bytes</h1>
<pre><code>$Å§âˆ‘áµ–{Å§âˆ‘'d/=
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m70iLzU7PzexJHFNtJJurpKOgpKuoVLsgqWlJWm6FptVji5_1DHx4dZp1WCGeoq-7ZLipORiqPyCm7rRhjpGOqY6hgY6RgY6pgZAhkGsghEXVmETiC4A" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Extremely slow. Time out for almost every test case.</p>
<pre><code>$Å§âˆ‘áµ–{Å§âˆ‘'d/=     Input: L, B
$Å§              Find a B-tuple of elements of L
  âˆ‘             Sum
   áµ–{           Check that the sum A satisfies:
     Å§              Find an A-tuple of elements of L
      âˆ‘             Sum
       'd/          Divide by 100
          =         Check that it is equal to B
</code></pre>
<p>By default, Nekomata will find all possible solutions, possibly with duplicates. You can use the <code>-1</code> flag to find only the first solution. Even with this flag, it still times out for all test cases except the last two.</p>
<hr />
<h1><a href="https://github.com/AlephAlpha/Nekomata" rel="nofollow noreferrer">Nekomata</a>, 16 bytes</h1>
<pre><code>Å§âˆ‘Å©Â§Ä¦vÅ™Ê³Ã—Â§'d*@ZÂ¿
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m70iLzU7PzexJHFTtJJurpKOgpJuDog0NFCKXbC0tCRN12L30eWPOiYeXXlo-ZFlZUdnntp8ePqh5eopWg5Rh_YvKU5KLoaqW3Azw0Ih2lTH0CCWy0gh2kgHwjRGMOGiOkbIEmAeUM5QB87XMTUAMoDCJliFIRYCAA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Longer but faster. At least it can find some (not all) solutions in a reasonable time for all test cases.</p>
<p>If you have a list of positive integers <span class="math-container">\$L = [a_1, a_2, \ldots, a_n]\$</span>, and you want to check if there is a <span class="math-container">\$k\$</span>-tuple of elements of <span class="math-container">\$L\$</span> that sums to <span class="math-container">\$m\$</span>, a fast way to do this is to take the <span class="math-container">\$k\$</span>-th power of the polynomial <span class="math-container">\$x^{a_1} + x^{a_2} + \cdots + x^{a_n}\$</span>, and check if the coefficient of <span class="math-container">\$x^m\$</span> is nonzero.</p>
<pre><code>Å§âˆ‘Å©Â§Ä¦vÅ™Ê³Ã—Â§'d*@ZÂ¿        Input: B, L
Å§                       Find a B-tuple of elements of L
 âˆ‘                      Sum
  Å©                     Uniquify the possible results
                        (This is not necessary, but it speeds up the search)
                        Let's say the sum is A
   Â§Ä¦                   Make a histogram of the elements of L
                        e.g., [2,5,10] -&gt; [0,0,1,0,0,1,0,0,0,0,1]
     vÅ™                 Replicate the histogram A times
       Ê³Ã—               Fold by convolution
         Â§'d*           Multiply B by 100
             @          Take the n-th element of the result of the convolution
              Z         Check that it is nonzero
               Â¿        If so, return A
</code></pre>
<p>The last two test cases will time out if you are trying to find all solutions. You can add the flag <code>-l 10</code> to find at most 10 solutions.</p>
</div>
<div id="pu7" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal/tree/version-2" rel="nofollow noreferrer">Vyxal</a>, 13 bytes</h1>
<pre><code>â†”á¹ 'Â¹â†”á¹ â°â‚*=a;h
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/?v=2&amp;c=1#WyIiLCIiLCLihpThuaAnwrnihpThuaDigbDigoEqPWE7aCIsIiIsIlsyLCA1LCAxMF1cbjIiXQ==" rel="nofollow noreferrer">Try it Online!</a></p>
<p>Will time out online for <em>every</em> test case, so you'll have to read the explanation to verify correctness. Takes <code>L</code> then <code>B</code>.</p>
<h2>Explained</h2>
<pre><code>â†”á¹ 'Â¹â†”á¹ â°â‚*=a;hÂ­â¡â€‹â€â€âªâ¡âªâ âªâ¡âªâ€â âªâªâ€â€‹â¡â â¡â€Œâ¢â€‹â€â€âªâ¡âªâ âªâ¢âªâ€â€â€‹â¡â â¡â€Œâ£â€‹â€â€âªâ¡âªâ âªâ£âªâ€â â€âªâ¡âªâ âªâ£â¤âªâ€â€â€‹â¡â â¡â€Œâ¤â€‹â€â€âªâ¡âªâ âªâ¤âªâ€â â€âªâ¡âªâ âªâ¢â¡âªâ€â€â€‹â¡â â¡â€Œâ¢â¡â€‹â€â€âªâ¡âªâ âªâ¢â¢âªâ€â€â€‹â¡â â¡â€Œâ¢â¢â€‹â€â€âªâ¡âªâ âªâ¢â£âªâ€â â€âªâ¡âªâ âªâ¢â¤âªâ€â â€âªâ¡âªâ âªâ£â¡âªâ€â â€âªâ¡âªâ âªâ£â¢âªâ€â€â€‹â¡â â¡â€Œâ¢â£â€‹â€â€âªâ¡âªâ âªâ£â£âªâ€â€â€‹â¡â â¡â€Œâ¢â¤â€‹â€â€âªâ¡âªâ âªâ¤â¡âªâ€â€â€‹â¡â â¡â€ŒÂ­
â†”              # â€â¡Generate all B-sized combinations of L with replacement
 á¹              # â€â¢Summate each combination - this gives candidates for values of A
  '        ;   # â€â£Keep A's where the result of the following is truthy:
   Â¹â†”          # â€â¤  Generate all A-sized combinations of L with replacement (this is why it'll time out for everything)
     á¹          # â€â¢â¡  Summate each of those combinations
      â°â‚*=     # â€â¢â¢  Check whether each sum equals 100 * B
          a    # â€â¢â£  And return whether any do
            h  # â€â¢â¤Output the first valid A
ğŸ’
</code></pre>
<p>Created with the help of <a href="https://vyxal.github.io/Luminespire" rel="nofollow noreferrer">Luminespire</a>.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/283193/">283193</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




