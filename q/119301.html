<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::119301</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>021</td><td>APLNARS</td><td>250627T160043Z</td><td><a href="https://codegolf.stackexchange.com/questions/119301/implement-eulers-method/282429#282429">Rosario</a></td></tr>
<tr d-ix="1"><td>042</td><td>Octave</td><td>170506T234609Z</td><td><a href="https://codegolf.stackexchange.com/questions/119301/implement-eulers-method/119336#119336">Luis Men</a></td></tr>
<tr d-ix="2"><td>007</td><td>Actually</td><td>170507T103923Z</td><td><a href="https://codegolf.stackexchange.com/questions/119301/implement-eulers-method/119388#119388">Leaky Nu</a></td></tr>
<tr d-ix="3"><td>029</td><td>APL Dyalog</td><td>170507T044653Z</td><td><a href="https://codegolf.stackexchange.com/questions/119301/implement-eulers-method/119357#119357">user4180</a></td></tr>
<tr d-ix="4"><td>010</td><td>Pyth</td><td>170507T033906Z</td><td><a href="https://codegolf.stackexchange.com/questions/119301/implement-eulers-method/119353#119353">Leaky Nu</a></td></tr>
<tr d-ix="5"><td>012</td><td>Brachylog</td><td>170507T030650Z</td><td><a href="https://codegolf.stackexchange.com/questions/119301/implement-eulers-method/119350#119350">Leaky Nu</a></td></tr>
<tr d-ix="6"><td>051</td><td>Python</td><td>170507T023630Z</td><td><a href="https://codegolf.stackexchange.com/questions/119301/implement-eulers-method/119348#119348">xnor</a></td></tr>
<tr d-ix="7"><td>005</td><td>Jelly</td><td>170507T000728Z</td><td><a href="https://codegolf.stackexchange.com/questions/119301/implement-eulers-method/119338#119338">fireflam</a></td></tr>
<tr d-ix="8"><td>082</td><td>Python 3 with Numpy</td><td>170507T001045Z</td><td><a href="https://codegolf.stackexchange.com/questions/119301/implement-eulers-method/119339#119339">Luis Men</a></td></tr>
<tr d-ix="9"><td>012</td><td>CJam</td><td>170506T233341Z</td><td><a href="https://codegolf.stackexchange.com/questions/119301/implement-eulers-method/119335#119335">Luis Men</a></td></tr>
<tr d-ix="10"><td>045</td><td>Haskell</td><td>170506T194935Z</td><td><a href="https://codegolf.stackexchange.com/questions/119301/implement-eulers-method/119303#119303">nimi</a></td></tr>
<tr d-ix="11"><td>058</td><td>Python</td><td>170506T213611Z</td><td><a href="https://codegolf.stackexchange.com/questions/119301/implement-eulers-method/119324#119324">Graviton</a></td></tr>
<tr d-ix="12"><td>009</td><td>MATL</td><td>170506T222212Z</td><td><a href="https://codegolf.stackexchange.com/questions/119301/implement-eulers-method/119328#119328">Luis Men</a></td></tr>
<tr d-ix="13"><td>038</td><td>Haskell</td><td>170506T200132Z</td><td><a href="https://codegolf.stackexchange.com/questions/119301/implement-eulers-method/119305#119305">xnor</a></td></tr>
<tr d-ix="14"><td>041</td><td>JavaScript ES6</td><td>170506T202044Z</td><td><a href="https://codegolf.stackexchange.com/questions/119301/implement-eulers-method/119311#119311">Neil</a></td></tr>
<tr d-ix="15"><td>032</td><td>Mathematica</td><td>170506T191211Z</td><td><a href="https://codegolf.stackexchange.com/questions/119301/implement-eulers-method/119302#119302">Doorknob</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>APL(NARS), 21 chars</h1>
<pre><code>{⍺≤0:↑⍵⋄(⍺-1)∇2+/⍵,0}
</code></pre>
<p>I follow what is seen in the table and other apl solution. Test:</p>
<pre><code>  f←{⍺≤0:↑⍵⋄(⍺-1)∇2+/⍵,0}
  1 f 1 1
2
  10 f 1 2 3 4 5 6
3198
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.gnu.org/software/octave/" rel="nofollow noreferrer">Octave</a>, 42 bytes</h1>

<pre class="lang-matlab prettyprint-override"><code>@(a,x)conv(a,diag(flip(pascal(x+1))))(x+1)
</code></pre>
<p>This defines an anonymous function. <a href="https://tio.run/nexus/octave#S1OwVdDT0/vvoJGoU6GZnJ9XBmSkZCama6TlZBZoFCQWJyfmaFRoG2oCAZj@n6YRbaKjoGuqo2AMpAxjdRQsNLmAgoY6CkZgMaAsUNIMKGFoAJMxBiNzoJgRREwXIoKDAuk1hekFWQG0FwA" rel="nofollow noreferrer" title="Octave – TIO Nexus">Try it online!</a></p>
<h3>Explanation</h3>
<p>The solution could be computed by repeatedly convolving the input array and the resulting arrays with <code>[1, 1]</code>. But convolving twice, or thrice, or ... with <code>[1, 1]</code> corresponds to convolving once with <code>[1, 2 ,1]</code>, or <code>[1, 3, 3, 1]</code>, or ...; that is, with a row of the Pascal triangle. This is obtained as the anti-diagonal of the Pascal matrix of order <code>x+1</code>.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/Mego/Seriously" rel="nofollow noreferrer">Actually</a>, 7 bytes</h1>

<pre><code>;lr(♀█*
</code></pre>

<p><a href="https://tio.run/nexus/actually#@2@dU6TxaGbDo2kdWv//W3BFm@go6JrqKBgDKcNYAA" rel="nofollow noreferrer" title="Actually – TIO Nexus">Try it online!</a></p>

<h2>How it works</h2>

<pre><code>;lr(♀█*  input:
         8, [4, -5, 3, -1]
         top of stack at the right
;        duplicate
         8, [4, -5, 3, -1], [4, -5, 3, -1]
 l       length
         8, [4, -5, 3, -1], 4
  r      range
         8, [4, -5, 3, -1], [0, 1, 2, 3]
   (     rotate stack
         [4, -5, 3, -1], [0, 1, 2, 3], 8
    ♀█   map "n choose r"
         [4, -5, 3, -1], [1, 8, 28, 56]
      *  dot product
         -8
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.dyalog.com/" rel="nofollow noreferrer">APL (Dyalog)</a>, 29 bytes</h1>



<pre class="lang-apl prettyprint-override"><code>{0=⍺:⊃⍵
(⍺-1)∇(+/¨2,/⍵),¯1↑⍵}
</code></pre>

<p><a href="https://tio.run/nexus/apl-dyalog#@@/4qG1CtYHto95dVo@6mh/1buXSALJ1DTUfdbRraOsfWmGkow8U1dQ5tN7wUdtEILP2/38LBQVHBROFQ@tNFYyBpCGXoQFQwFDBCMg1UTBVMOMygggYA6E5l6EpkHNovTFYMRaSy1ABrNoQAA" rel="nofollow noreferrer" title="APL (Dyalog Unicode) – TIO Nexus">Try it online!</a></p>

<p>This is a recursive dfn, but it turns out to be too verbose. Golfing in progress...</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/isaacg1/pyth" rel="nofollow noreferrer">Pyth</a>, 10 bytes</h1>

<pre><code>s.e*b.cQkE
</code></pre>

<p><a href="http://pyth.herokuapp.com/?code=s.e%2ab.cQkE&amp;test_suite=1&amp;test_suite_input=8%0A%5B4%2C+-5%2C+3%2C+-1%5D%0A10%0A%5B1%2C+2%2C+3%2C+4%2C+5%2C+6%5D%0A20%0A%5B1%2C+3%2C+3%2C+7%5D%0A15%0A%5B-3%2C+3%2C+-3%2C+3%2C+-3%2C+3%2C+-3%2C+3%2C+-3%5D%0A1%0A%5B1%2C+1%5D&amp;debug=0&amp;input_size=2" rel="nofollow noreferrer">Test suite.</a></p>

<h2>How it works</h2>

<pre><code>s.e*b.cQkE
 .e      E   for (b,k) in enumerated(array):
     .cQk        (input) choose (k)
   *b            * b
s            sum
</code></pre>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/JCumin/Brachylog" rel="nofollow noreferrer">Brachylog</a>, <s>13</s> 12 bytes</h1>

<pre><code>{,0s₂ᶠ+ᵐ}ⁱ⁾h
</code></pre>

<p><a href="https://tio.run/nexus/brachylog2#@1@tY1D8qKnp4bYF2g@3Tqh91LjxUeO@jP//o6NNdBTiTXUUjIGUYayOgkXs/ygA" rel="nofollow noreferrer">Try it online!</a></p>

<h2>How it works</h2>

<pre><code>{,0s₂ᶠ+ᵐ}ⁱ⁾h
{       }ⁱ⁾   iterate the previous predicate
              to the array specified by first element of input
              as many times as the second element of input
           h  and get the first element

              example input to predicate: [4, _5, 3, _1]
 ,0           append 0: [4, _5, 3, _1, 0]
   s₂ᶠ        find all substrings with length 2:
              [[4, _5], [_5, 3], [3, _1], [_1, 0]]
      +ᵐ      "add all the elements" mapped to each subarray:
              [_1, _2, _2, _1]
</code></pre>

<h2>Previous 13-byte solution</h2>

<pre><code>{b,0;?z+ᵐ}ⁱ⁾h
</code></pre>

<p><a href="https://tio.run/nexus/brachylog2#@1@dpGNgbV@l/XDrhNpHjRsfNe7L@P8/OtpERyHeVEfBGEgZxuooWMT@jwIA" rel="nofollow noreferrer">Try it online!</a></p>

<h3>How it works</h3>

<pre><code>{b,0;?z+ᵐ}ⁱ⁾h
{        }ⁱ⁾   iterate the previous predicate
               to the array specified by first element of input
               as many times as the second element of input
            h  and get the first element

               example input to predicate: [4, _5, 3, _1]
 b             remove the first element: [_5, 3, _1]
  ,0           append 0: [_5, 3, _1, 0]
    ;?         pair with input: [[_5, 3, _1, 0], [4, _5, 3, _1]]
      z        zip: [[_5, 4], [3, _5], [_1, 3], [0, _1]]
       +ᵐ      "add all the elements" mapped to each subarray:
               [_1, _2, _2, _1]
</code></pre>
</div>
<div id="pu6" class="pu"><h1><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python</a>, 51 bytes</h1>



<pre class="lang-python prettyprint-override"><code>f=lambda l,n:n and f(l,n-1)+f(l[1:]+[0],n-1)or l[0]
</code></pre>

<p><a href="https://tio.run/nexus/python3#dY3BCsIwEETvfsUcE7qBbGtVCn5JyCFSAkKMUvr/cZOCaEEYmGHesFviNYXHbQ5IlKeMkGdEJdmw7iQ4nnznrG/Fc0GSXF7LPa8qKnckmJEwiLEnXLQ@fBgT@oZkJJuTcLa7wdB0FtT/ILOBP1YvjbtL9T1/d5ZQtdXlDQ" rel="nofollow noreferrer" title="Python 3 – TIO Nexus">Try it online!</a></p>

<p>This is a port of my <a href="https://codegolf.stackexchange.com/a/119305/20260">Haskell answer</a>.</p>
</div>
<div id="pu7" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, <s>6</s> 5 bytes</h1>

<pre><code>Ḋ+$¡Ḣ
</code></pre>

<p><a href="https://tio.run/nexus/jelly#@/9wR5e2yqGFD3cs@v//v6GOMRCa/zcyAAA" rel="nofollow noreferrer" title="Jelly – TIO Nexus">Try it online!</a></p>

<p><em>-1 byte thanks to @Doorknob</em></p>

<p><strong>Explanation</strong></p>

<pre><code>Ḋ+$¡Ḣ  - Main dyadic link. First input list, second x
       - (implicit) on the previous iteration (starting at input list)
Ḋ      - Dequeue. e.g. [-5,3,-1]
 +     - Add this to
       - (implicit) the previous iteration. e.g. [4+(-5),-5+3,3+(-1),-1+0]
  $¡   - apply this successively x times
    Ḣ  - get the first element from the resultant list
</code></pre>
</div>
<div id="pu8" class="pu"><h1><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python 3</a> with <a href="http://www.numpy.org/" rel="nofollow noreferrer">Numpy</a>, 82 bytes</h1>



<pre class="lang-python prettyprint-override"><code>import numpy
def f(a,x):
 for n in range(x):a=numpy.convolve(a,[1,1])
 return a[x]
</code></pre>

<p>Similar to my <a href="https://codegolf.stackexchange.com/a/119328/36398">MATL answer</a>, but using full-size convolution, and thus the result is the <code>x</code>-th entry of the final array.</p>

<p><a href="https://tio.run/nexus/python3#dY1BCsIwEEX3OcUsE0jFtFZF8CQli6CJBOwkhLTU08dpBMGCMPDhv8ef4scYUgacxvhid@vAcSMXcWHgQgIEj5AMPiynzlyrtrsFnMNztmQOSiotGCSbp4RghkWXmDxm7vhwkND0EjoKpSWchWBfpiS0FZFEzpG42m@Ert6JUPuDmg/4E@tSv1la3yshyhs" rel="nofollow noreferrer" title="Python 3 – TIO Nexus">Try it online!</a></p>
</div>
<div id="pu9" class="pu"><h1><a href="https://sourceforge.net/p/cjam" rel="nofollow noreferrer">CJam</a>, 12 bytes</h1>
<pre><code>q~{_(;.+}*0=
</code></pre>
<p><a href="https://tio.run/nexus/cjam#@19YVx2vYa2nXatlYPv/f7ShgpGCsYKJgqmCWayCoQEA" rel="nofollow noreferrer" title="CJam – TIO Nexus">Try it online!</a></p>
<h3>Explanation</h3>
<p>The code directly implements the procedure described in the challenge.</p>
<pre><code>q~            e# Read input and evaluate. Pushes the array and the number x
  {     }*    e# Do the following x times
   _          e# Duplicate array
    (;        e# Remove first element
      .+      e# Vectorized sum. The last element in the first array, which doesn't 
              e# have a corresponding entry in the second, will be left as is
          0=  e# Get first element. Implicitly display
</code></pre>
</div>
<div id="pu10" class="pu"><h2>Haskell, <s>52</s> 45 bytes</h2>

<pre><code>l#n=iterate(zipWith(+)=&lt;&lt;tail.(++[0]))l!!n!!0
</code></pre>

<p>Usage example: <code>[-3,3,-3,3,-3,3,-3,3,-3] # 15</code> -> <code>-9009</code>. <a href="https://tio.run/nexus/haskell#@5@jnGebWZJalFiSqlGVWRCeWZKhoa1pa2NTkpiZo6ehrR1tEKupmaOomKeoaPA/NzEzT8FWoaAoM69EQUUh2lBHwRiMzGMVlBWMDP4DAA" rel="nofollow noreferrer" title="Haskell – TIO Nexus">Try it online!</a></p>

<p>How it works</p>

<pre><code>iterate(      )l          -- apply the function again and again starting with l
                          -- and collect the intermediate results in a list
                          -- the function is
          (++[0])         -- append a zero 
  zipWith(+)=&lt;&lt;tail       -- and build list of neighbor sums
                     !!0  -- take the first element from
                  !!n     -- the nth result
</code></pre>

<p>Edit: @xnor saved 7 bytes. Thanks!  </p>
</div>
<div id="pu11" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python</a>, <strike>80</strike> 58 bytes</h1>

<p>Love the math for this challenge.
</p>

<pre class="lang-python prettyprint-override"><code>f=lambda a,x:x and f(map(sum,zip(a,a[1:]+[0])),x-1)or a[0]
</code></pre>

<p>How it works (only works with python 2):</p>

<pre class="lang-python prettyprint-override"><code>f=lambda a,x:                                              - new lambda function
             x and                                         - iterate itself x times
                     map(sum,zip(a,a[1:]+[0]))             - e.g; f(a) = f(a-1) + f'(a-1)
                   f(                         ,x-1)        - iterate new array into itself
                                                   or a[0] - return first element
</code></pre>

<p><a href="https://tio.run/nexus/python2#S7SNNtFR0DXVUTAGUoaxXBW2Fv/TbHMSc5NSEhUSdSqsKhQS81IU0jRyEws0iktzdaoyCzQSdRKjDa1itaMNYjU1dSp0DTXzixQSgbz/BUWZeSUaaUAVFZqa/wE" rel="nofollow noreferrer" title="Python 2 – TIO Nexus">Try it online!</a></p>

<p><strong>100 byte alternate with use of pascals triangle</strong></p>

<pre class="lang-python prettyprint-override"><code>from math import factorial as F
f=lambda a,x:sum([(a+[0]*x)[i]*F(x)/(F(x-i)*F(i))for i in range(x)])
</code></pre>

<p>How it works (works for python 2 and 3):</p>

<pre class="lang-python prettyprint-override"><code>sum([                                                ]) - take the sum of array
     (a+[0]*x)                                        - append x zeros
              [i]*F(x)/(F(x-i)*F(i))                  - multiply each element by x choose i
                                    for i in range(x) - do this for every element
</code></pre>

<p>This formula works by mapping the coefficients of row <code>x</code> of <a href="https://en.wikipedia.org/wiki/Pascal%27s_triangle" rel="nofollow noreferrer">pascals triangle</a> onto the array. Each element of pascals triangle is determined by the choose function of the row and index. The sum of this new array is equivalent to the output at <code>x</code>. It's also intuitive as the iterated process of newtons method (shown in the example) acts exactly as the construction of pascals triangle.</p>

<p><a href="https://tio.run/nexus/python3#DYzNCsIwEITvfYo5ZmuLigpS6LUvEXJYf6ILTVK2EfL2MZcZvvlgGDPsdcB4G3BpdXZdadO9ek0BgfMXErakGZ6fOanwCt6xdH5eOTxeDB7KtP@CsYYP9uT6QlZcv5hCR9NyFGogRD4pBBKhHD/vph3VTSVm4037IKp/" rel="nofollow noreferrer" title="Python 3 – TIO Nexus">Try it online!</a></p>

<p>Big thanks to <a href="https://codegolf.stackexchange.com/users/64121/ovs">ovs</a> for reducing 22 bytes by converting loop into a recursive function</p>
</div>
<div id="pu12" class="pu"><h1><a href="https://github.com/lmendo/MATL" rel="nofollow noreferrer">MATL</a>, 9 bytes</h1>

<pre><code>:"TTZ+]1)
</code></pre>

<p><a href="https://tio.run/nexus/matl#@2@lFBISpR1rqPn/v6EBV7ShjoKRjoKxjoKJjoKpjoJZLAA" rel="nofollow noreferrer" title="MATL – TIO Nexus">Try it online!</a> Or <a href="https://tio.run/nexus/matl#S/hvpRQSEqUda6j53yXkvwVXtImOgq6pjoIxkDKM5TI04Io21FEwAgsApYAyZrFcRhBRYzAyB6oy5YrWhfBwUEA1YC2GsQA" rel="nofollow noreferrer" title="MATL – TIO Nexus">verify all test cases</a>.</p>

<h3>Explanation</h3>

<pre><code>:"      % Implicitly input x. Do the following x times
  TT    %   Push [1 1]
  Z+    %   Convolution, keeping size. Implicitly inputs array the first time
]       % End
1)      % Get first entry. Implictly display
</code></pre>
</div>
<div id="pu13" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, 38 bytes</h1>



<pre class="lang-hs prettyprint-override"><code>l%n|n&lt;1=l!!0|m&lt;-n-1=l%m+tail(l++[0])%m
</code></pre>

<p><a href="https://tio.run/nexus/haskell#Dck7CsAgEAXAPqd4gQgJrqD5VXoSsbAU1iUEy9zd2A1MZyWfeBd4nu1XvREzrKpuufDKWkebNlU7IyA6wk44CCfhItxpqrnImOct0rCAoeBs/wE" rel="nofollow noreferrer" title="Haskell – TIO Nexus">Try it online!</a></p>

<p>Improved from 39 bytes:</p>

<pre class="lang-hs prettyprint-override"><code>l%0=l!!0
l%n=l%(n-1)+tail(l++[0])%(n-1)
</code></pre>

<p>Recursively expresses the output <code>l%n</code>. Moving up corresponds to decrementing <code>n</code>, and moving right corresponds to taking <code>tail l</code> to shift all list elements one space left. So, the output <code>l%n</code> is the value above <code>l%(n-1)</code>, plus the value above and to the right <code>(tail l)%(n-1)</code></p>

<p>The base case <code>n==0</code> is to take the first list element.</p>

<p>Ideally, the input would be padded with infinitely many zeroes to the right, since the derivatives of a polynomial eventually become zero. We simulate this by appending a <code>0</code> when we take the <code>tail</code>.</p>

<p>Weird alt 41:</p>

<pre class="lang-hs prettyprint-override"><code>(iterate(\q l-&gt;q l+q(tail l++[0]))head!!)
</code></pre>
</div>
<div id="pu14" class="pu"><h2>JavaScript (ES6), 41 bytes</h2>

<pre><code>f=(a,x,[b,...c]=a)=&gt;x--?f(a,x)+f(c,x):b|0
</code></pre>

<p>Port of @xnor's excellent Haskell answer. Previous 47-byte solution.</p>

<pre><code>f=(a,x)=&gt;x--?f(a.map((e,i)=&gt;e+~~a[i+1]),x):a[0]
</code></pre>
</div>
<div id="pu15" class="pu"><h2>Mathematica, 32 bytes</h2>

<pre><code>#&amp;@@Nest[#+Rest@#~Append~0&amp;,##]&amp;
</code></pre>



<pre><code>                               &amp;  make a pure function
    Nest[                 &amp;,##]   call inner function as many times as specified
           Rest@#                 drop the first element of the list
                 ~Append~0        and add a 0 to get [b,c,d,0]
         #+                       add original list to get [a+b,b+c,c+d,d]
#&amp;@@                              take the first element after x iterations
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/119301/">119301</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




