<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::277408</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>261</td><td>Python</td><td>241227T114654Z</td><td><a href="https://codegolf.stackexchange.com/questions/277408/determine-if-two-trees-are-equal-in-the-free-quandle/277418#277418">Albert.L</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.python.org" rel="nofollow noreferrer">Python</a>, 261 bytes</h1>
<pre class="lang-python prettyprint-override"><code>import re
l=lambda a,b:f'{a} {b} {a[::-1]}'
g=lambda b,a:f'{a[::-1]} {b} {a}'
f=lambda P,o=' ':f(P[1:],o[::-1]+eval(re.sub('(\\d+)','&quot;\\1.&quot;',P[0]))+' ')if P else o!=(o:=re.sub(r&quot; (\.?)(\d)&quot;+8*r&quot;(\d?)&quot;+r&quot;(?:\. \.| )\9\8\7\6\5\4\3\2\1 &quot;,&quot; &quot;,o))and f([],o)or' '==o
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=lVFBjptAENQecplXdLjQE2PWA46DUbA_sAffPZY1xOAgsQwCHCVy_JJcfMn-Jg_I_iP39AwgWUmkVQ5Y1dVV3TXtb0_1l-6jrq7X76cun0bPd6-Kx1o3HTQZK5NSPaYHBcpL49w9qwucU_rUNo6nYndx2XFUpJ6yiqEz6EiRj4qNpxMX3DjHzVbEO0_30kn2SZXYZH57StFFKQ8T7nquI6XwHdfbbGc7zidk5EUOG8jKNgP9OkEdJ4OpcQClv-YoD9yZRG8ah9CaIIF1LH2Q_lfgcikj-U4u5Fs5l6EMpADHc-jTnKvqADluKRPXDa1KEt1f4-evD6VqW1Cnz9h2DY8ZHLIc9vuy2--xJX3cZN2pqawid0o8txfvrC_c4aP0-G_p8Vaa6wYeoKhA11mFM7OHTg4JmCfWZdGhA35CYf-6kxlmbuVQ8cB9ClnUyGm5IjdVaM-rDJPeMqlh6qaoOqRNnjtduR6dgDCdu3_89fnuh5jBe0AR0G_IIUkIG0YE3PIzyzMUsDL9FSx7jUGmxNAiZvwWB3ZIyPqRc6MhRNScza01HOmQichsigwtIhYsjd3OD5Z_DsQhINUMEQRVNqGwIUxpFYIPb7ghSP-SHKla9c3h3TcKawl6n-lzJuCeEgdMjFIyGcYgJnq53UUkxV2MYxeGWIz9xUvJ7v8nmRkz_K2_AQ" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Takes positive integers as atoms and a Polish-ish function notation <code>l(a,b) ~ (a&lt;b) ; g(a,b) ~ (a&gt;b)</code> to represent the input trees.</p>
<p>I'm sure the code can be streamlined ...</p>
<h3>How?</h3>
<p>Wikipedia says one example of this structure is group conjugation (in the free group). So I translate inputs like <span class="math-container">\$(a &lt; b)\$</span> to something like <span class="math-container">\$ab a^{-1}\$</span>. What we gain by this is that expression normlisation is extremely simple: adjacent inverses cancel and that's it.</p>
<p>Products are written as space separated juxtaposition.
I'm adding a dot at the end of each integer. That way the inverse in the free group can be represented by string reversal for both single integers and products. And normalisation can be done by finding and eliminating two word palindromes.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/277408/">277408</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




