<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::179422</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>012</td><td>Jelly</td><td>241228T042426Z</td><td><a href="https://codegolf.stackexchange.com/questions/179422/a-well-linked-challenge/277424#277424">Unrelate</a></td></tr>
<tr d-ix="1"><td>082</td><td>Regex ECMAScript 2018 or .NET</td><td>190204T043601Z</td><td><a href="https://codegolf.stackexchange.com/questions/179422/a-well-linked-challenge/179454#179454">Deadcode</a></td></tr>
<tr d-ix="2"><td>016</td><td>Brachylog</td><td>190512T084616Z</td><td><a href="https://codegolf.stackexchange.com/questions/179422/a-well-linked-challenge/185478#185478">Zgarb</a></td></tr>
<tr d-ix="3"><td>034</td><td>J</td><td>190204T005741Z</td><td><a href="https://codegolf.stackexchange.com/questions/179422/a-well-linked-challenge/179450#179450">Jonah</a></td></tr>
<tr d-ix="4"><td>066</td><td>Python 3.8 prerelease</td><td>190205T055823Z</td><td><a href="https://codegolf.stackexchange.com/questions/179422/a-well-linked-challenge/179508#179508">xnor</a></td></tr>
<tr d-ix="5"><td>198</td><td>C# Visual C# Interactive Compiler</td><td>190204T013201Z</td><td><a href="https://codegolf.stackexchange.com/questions/179422/a-well-linked-challenge/179451#179451">dana</a></td></tr>
<tr d-ix="6"><td>096</td><td>Retina</td><td>190203T014515Z</td><td><a href="https://codegolf.stackexchange.com/questions/179422/a-well-linked-challenge/179426#179426">Neil</a></td></tr>
<tr d-ix="7"><td>078</td><td>Perl 5 p</td><td>190203T174522Z</td><td><a href="https://codegolf.stackexchange.com/questions/179422/a-well-linked-challenge/179442#179442">Nahuel F</a></td></tr>
<tr d-ix="8"><td>076</td><td>Perl 6</td><td>190204T101401Z</td><td><a href="https://codegolf.stackexchange.com/questions/179422/a-well-linked-challenge/179461#179461">Jo King</a></td></tr>
<tr d-ix="9"><td>020</td><td>05AB1E</td><td>190204T084735Z</td><td><a href="https://codegolf.stackexchange.com/questions/179422/a-well-linked-challenge/179459#179459">Kevin Cr</a></td></tr>
<tr d-ix="10"><td>074</td><td>Python 2</td><td>190204T070416Z</td><td><a href="https://codegolf.stackexchange.com/questions/179422/a-well-linked-challenge/179457#179457">xnor</a></td></tr>
<tr d-ix="11"><td>108</td><td>Python 2</td><td>190203T111626Z</td><td><a href="https://codegolf.stackexchange.com/questions/179422/a-well-linked-challenge/179435#179435">Erik the</a></td></tr>
<tr d-ix="12"><td>020</td><td>Jelly</td><td>190203T011050Z</td><td><a href="https://codegolf.stackexchange.com/questions/179422/a-well-linked-challenge/179423#179423">Doorknob</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 12 bytes</h1>
<pre><code>Q‚Åº√æ¬µ^\¬µ‚ÅºQ^√æ\
</code></pre>
<p><a href="https://tio.run/##y0rNyan8/z/wUeOew/sObY2LObQVyAyMO7wv5v/D3VsObT06@eHOxY8a5ijo2ik8apj7cMeiw@2akf//JyYlJyUmg0RDikpTuRKTkpIhXLfEnOJUriQgQPASgUqTkBUD9QIxikByIkI9NufAFAMA" rel="nofollow noreferrer" title="Jelly ‚Äì Try It Online">Try it online!</a></p>
<p>I felt oh so clever for coming up with this until I scrolled past xnor's solution on the way to post, caught a <code>^</code> out of the corner of my eye, and realized it's the exact same thing üôÉ Regardless, it still feels good to satisfy the source restriction without extra characters for comments.</p>
<pre><code>Q               Uniquify the input
 ‚Åº√æ             and table that by equality with the full input.
   ¬µ            Then,
    ^\          scan the columns by XOR.
       ‚Åº        Is that equal to
      ¬µ Q       itself uniquified?
           \    Scan the scalar Boolean result (treated as length 1, hence a no-op)
         ^√æ     by tabling XOR.
</code></pre>
<p>Before accounting for the source restriction, I had <code>=√æ`^\Q∆ë</code>, and also toyed with <code>ƒã‚±Æ∆§Q·∏ÇQ∆ë</code>.</p>
<p>A contiguous substring is a suffix of a prefix, or equivalently a prefix with a smaller prefix removed. Hence, a substring has all-even counts if and only if the difference in each count between a pair of distinct prefixes is even, which is to say that the parity of the counts in each prefix is equal. Jelly's scan doesn't generate a cumulative result corresponding to the empty prefix, so the improper prefix consisting of the entire input is uniquely all-even so long as no other prefix is, and everything wraps itself up nicely with a bow.</p>
</div>
<div id="pu1" class="pu"><h1>Regex (ECMAScript 2018 or .NET), <s>140</s> <s>126</s> <s>118</s> <s>100</s> <s>98</s> 82 bytes</h1>
<p><code>^(?!(^.*)(.+)(.*$)(?&lt;!^\2|^\1(?=(|(&lt;?(|(?!\8).)*(\8|\3$){1}){2})*$).*(.)+\3$)!?=*)</code></p>
<p>This is much slower than the 98 byte version, because the <code>^\1</code> is left of the lookahead and is thus evaluated after it. See below for a simple switcheroo that regains the speed. But due to this, the two TIOs below are limited to completing a smaller test case set than before, and the .NET one is too slow to check its own regex.</p>
<p><a href="https://tio.run/##rVRNb9tGEL3zV1ASLe6Q9JJSgCCgtaLjwCmMoKhiGUgAUXT4saJZ80MmqUQGRR9yaHxq0Rx6NnLuqUCA1Meo8TH/Qfkj7pJyG/tQIIcS2J3ZmbdvFrNv@aP90s7cNJjmm3Hi0euMaFsp2af@7nyKhnkaxD5O7Vcvri1kNJCFJUBYZkMSABm9hmV2F5bZQQZBC9Qz2GQ0zAeAQULmg4V5T4CiU0LRLYFtwBLCIFfBhkEkuH6BszBwKeoomx2ArZSezIKUIjGlthcGMRUBu8zP6V6c03RiM2gRxNNZrk/TxKVZhrPcC@IScBIjsd6hhKRfcDwfTHjUCPnFgg9vimhKFwgRVVUEluf5WxTJLMev0iCnCGWGaMaiLoogh7DFgDTM6LfhUYgjO3ePUApG8yCdUZ3nm3rzsc0YdL65JsxIZ6uEa1XlKwSf0yznXTujGWc7rmO7zNiu465XbHAcg9YUd7GOy7AO@2qka9e470@rU/qpHWXc/39ddYkf8iOaZiL/0g4D72u1vy5Wl@erD69Xlx9Wlz@t/vxt@ebL699Xlxdffvn5Vo6t7qa5fyO3UFd/XL25@vW/M9ynt5/ff3w3WF6UTz693Xvy@f1wb/jx3fJ8UC4vlucckloiVrROt73YPmuJQDotPNIVNNIlVSNVtKXiMzCxyYV25Hg2HyoOKQKv1EMaoyLLU@ToxLEKt4RJkiIXgpgPS@hV6RBaSs@aRHGS5UXZ4pwo1siE3DBlyoAUWql4ZDTWs16TbwYTNODZfg8qKckTlI0mvUwfKwOryEaapY1LZTQYyx5wEnaTyBlZ0nMZWRIwOU0rO8Z@SqeoEA7bo/YYCYfAFB8nMcU7tl9IZe1vdFuSJT/fSZxuSt2NFhdtYhkZhfB0QbZP2n46VQRzQYQ2PREOrUbFKKuW2kbbERF8cqaaT4VD1QcFsZXQBhbBql8y1TRgsyzWevoqJxDuyElHllHNTE33KzWxuRbRWmB1iDlYNu9jqRIUE1bRUUrzXsWv9MCAf67CUyih8SyiKXv3ehTEKLLnyBuFeig7Y9agWZyjY9joVhdzDHVjmcs7ilt1mTJolzW3WwdDZXITBB5aDk/0uYxZp7g56Tfm@Ls0mU13TpFL@i7gh/Ep8knfx4/qGqxEX4N2Y3d9GCekeJ9O2d8IzdcI5cZKNxbwM/Y2KGLCRaESAOkHG2Ffa7NCw@NgigI1BHxgH1PE4vAtxRnTOgOq1G8kpw/jR9puRNlZ9qVnR8FQPZDUvwE" rel="nofollow noreferrer" title="JavaScript (Node.js) ‚Äì Try It Online">Try it online! (ECMAScript 2018)</a><br />
<a href="https://tio.run/##dZLPT9swFMfv@SvcFFE7hDTpLiitFyS0SQgQaEXaoVklx3VLJDepbJcxpeHAYXDaNA47V5x3moTEeqSDI/9D@Uc6p90mOGDJv973856f7UflOk0Fmyekz@SAUAaan6Ri/Wwo46QHDtmJct6x3pAT8eZkIJiUcZrIOuVEStDPpCIqpuA4jTtgj8QJgCg7JgJIvGnO2zAowbZjIeis6W6tIBg0Su2wNmqHHgwwHMFGoIegFG4gB1kw3BiFr1ZQ5uUoq@VIOzgWdNBaYSwF2EJzs15EFzhhH4FOi51A6TSHkVRCZws9Wzq7LOmpo/Uashf6/kAVCTtbaX8Qc9ZB9SULeL2bChgnCnSxW4ccb2ks5UzflnR244RBhEo4GXINYg9lcRd2X7voH/VexIotsboBQNwFkP89G2N3NOIt9wPGlWpldZW3vOUSaRCAZxGgmbm5afNFEMYlewHRT2LawtmWe0TRI8hRYB6KIfMBMH3zLdGOPliGyXWbV6ugkIFiUgFKJJMGiWhEqJ4Ijehyp7thaHTh/5yNqGYj3RYkJQtuXx0xISvgmHD93QOR9gTpS@P3eDa5mN2czSY3s8nn2a/v0/PHsx@zyfjx65cnmt49l43/lifU/c/78/tvLyvG3eXD9e3VwXSc79xdbu88XDe3m7dX04uDfDqeXhjQKlcc2/Vqq6PN03IFYa/stHwbtnyr6uLCWq46pyh0QoOTftQhgNsRzuJO7nOWQF3QAkY@jtoZzVFRIRTpquY5ahQyR2W70e72k1SqLC//AQ" rel="nofollow noreferrer" title="C# (.NET Core) ‚Äì Try It Online">Try it online! (.NET)</a></p>
<p>To drop 18 bytes (118 ‚Üí 100), I shamelessly stole a really nice optimization from <a href="https://codegolf.stackexchange.com/revisions/179426/2">Neil's regex</a> that avoids the need to put a lookahead inside the negative lookbehind (yielding an 80 byte unrestricted regex). Thank you, Neil!</p>
<p>That became obsolete when it dropped an incredible 16 more bytes (98 ‚Üí 82) thanks to <a href="https://codegolf.stackexchange.com/users/75057/jaytea">jaytea</a>'s ideas which led to a 69 byte unrestricted regex! It's much slower, but that's golf!</p>
<p>Note that the <code>(|(</code> no-ops for making the regex well-linked have the result of making the it evaluate very slowly under .NET. They do not have this effect in ECMAScript because <a href="https://github.com/Davidebyzero/RegexMathEngine/issues/1" rel="nofollow noreferrer">zero-width optional matches are treated as non-matches</a>.</p>
<p>ECMAScript prohibits quantifiers on assertions, so this makes golfing the <a href="/questions/tagged/restricted-source" class="post-tag" title="show questions tagged &#39;restricted-source&#39;" rel="tag">restricted-source</a> requirements harder. However, at this point it's so well-golfed that I don't think lifting that particular restriction would open up any further golfing possibilities.</p>
<p>Without the extra characters needed to make it pass the restrictions (<s>101</s> 69 bytes):</p>
<p><code>^(?!(.*)(.+)(.*$)(?&lt;!^\2|^\1(?=((((?!\8).)*(\8|\3$)){2})*$).*(.)+\3))</code></p>
<p>It's slow, but this simple edit (for just 2 extra bytes) regains all the lost speed and more:</p>
<p><code>^(?!(.*)(.+)(.*$)(?&lt;!^\2|(?=\1((((?!\8).)*(\8|\3$)){2})*$)^\1.*(.)+\3))</code></p>
<pre><code>^
(?!
    (.*)               # cycle through all starting points of substrings;
                       # \1 = part to exclude from the start
    (.+)               # cycle through all ending points of non-empty substrings;
                       # \2 = the substring
    (.*$)              # \3 = part to exclude from the end
    (?&lt;!               # Assert that every character in the substring appears a total
                       # even number of times.
        ^\2            # Assert that our substring is not the whole string. We don't
                       # need a $ anchor because we were already at the end before
                       # entering this lookbehind.
    |                  # Note that the following steps are evaluated right to left,
                       # so please read them from bottom to top.
        ^\1            # Do not look further left than the start of our substring.
        (?=
            # Assert that the number of times the character \8 appears in our
            # substring is odd.
            (
                (
                    ((?!\8).)*
                    (\8|\3$) # This is the best part. Until the very last iteration
                             # of the loop outside the {2} loop, this alternation
                             # can only match \8, and once it reaches the end of the
                             # substring, it can match \3$ only once. This guarantees
                             # that it will match \8 an odd number of times, in matched
                             # pairs until finding one more at the end of the substring,
                             # which is paired with the \3$ instead of another \8.
                ){2}
            )*$
        )
        .*(.)+         # \8 = cycle through all characters in this substring
        # Assert (within this context) that at least one character appears an odd
        # number of times within our substring. (Outside this negative lookbehind,
        # that is equivalent to asserting that no character appears an odd number
        # of times in our substring.)
        \3             # Skip to our substring (do not look further right than its end)
    )
)
</code></pre>
<p>I wrote it using molecular lookahead (<s>103</s> 69 bytes) before converting it to variable-length lookbehind:</p>
<p><code>^(?!.*(?*(.+)(.*$))(?!^\1$|(?*(.)+.*\2$)((((?!\3).)*(\3|\2$)){2})*$))</code></p>
<pre><code>^
(?!
    .*(?*(.+)(.*$))       # cycle through all non-empty substrings;
                          # \1 = the current substring;
                          # \2 = the part to exclude from the end
    (?!                   # Assert that no character in the substring appears a
                          # total even number of times.
        ^\1$              # Assert that our substring is not the whole string
                          # (i.e. it's a strict substring)
    |
        (?*(.)+.*\2$)    # \3 = Cycle through all characters that appear in this
                          # substring.
        # Assert (within this context) that this character appears an odd number
        # of times within our substring.
        (
            (
                ((?!\3).)*
                (\3|\2$)
            ){2}
        )*$
    )
)
</code></pre>
<p>And to aid in making my regex itself well-linked, I've been using a variation of the above regex:</p>
<p><code>(?*(.+)(.*$))(?!^\1$|(?*(.)+.*\2$)((((?!\3).)*(\3|\2$)){2})*$)\1</code></p>
<p>When used with <a href="https://github.com/Davidebyzero/RegexMathEngine" rel="nofollow noreferrer"><code>regex -xml,rs -o</code></a>, this identifies a strict substring of the input that contains an even number of every character (if one exists). Sure, I could have written a non-regex program to do this for me, but where would be the fun in that?</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/JCumin/Brachylog" rel="nofollow noreferrer">Brachylog</a>, 16 bytes</h1>

<pre><code>s·∂†b‚àãp~j&amp;s·∂†b‚àãp~j&amp;
</code></pre>

<p><a href="https://tio.run/##SypKTM6ozMlPN/r/v/jhtgVJjzq6C@qy1JDZ//8rJSYlJiclKwEA" rel="nofollow noreferrer" title="Brachylog ‚Äì Try It Online">Try it online!</a></p>

<p>Prints <code>false.</code> for truthy instances and <code>true.</code> for falsy instances.
The TIO version is too slow to handle itself, but it's clearly well-linked since it's a string with unique characters repeated twice.</p>

<h2>Explanation</h2>

<pre><code>    Input is a string: "abcacbaa"
s·∂†  Find all substrings: ["abcacbaa","abcacba","abcacb",..,"a"]
b   Behead (now the proper substrings remain): ["abcacba","abcacb",..,"a"]
‚àã   Take one of them: "abcacb"
p   Permute it: "abcabc"
~j  It is some string repeated twice: "abc"
&amp;   Get the input again: "abcacbaa"
    Then repeat the above.
    If the constraints can be satisfied, the result is true, otherwise false.
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="http://jsoftware.com/" rel="nofollow noreferrer">J</a>, 34 bytes</h1>

<pre><code>2:@':.,|~*'&gt;1(#.,)*/@(1&gt;2|#/.~)\.\
</code></pre>

<p><a href="https://tio.run/##y/qvpKeepmBrpaCuoKNgoGAFxLp6Cs5BPm7/jawc1K30dGrqtNTtDDWU9XQ0tfQdNAztjGqU9fXqNGP0Yv5rcqUmZ@QrGCrYKqQpqCcmJSYnJaujiSUngTBU1AAmmpScmIwqlgQE6KqAxiWqc3EVp@ak2eopqINcBHMSLjehWA/S@B8A" rel="nofollow noreferrer" title="J ‚Äì Try It Online">Try it online!</a></p>

<p><em>-8 bytes thanks to FrownyFrog</em></p>

<h1>original</h1>

<h1><a href="http://jsoftware.com/" rel="nofollow noreferrer">J</a>, 42 bytes</h1>

<pre><code>(*#'.,012&amp;|@~#')=1#.[:,([:*/0=2&amp;|@#/.~)\.\
</code></pre>

<p><a href="https://tio.run/##fY6xCsIwFEX3fMXDgK8p8TVxDAQKgpOTa7skjwYRwcFV@utpAgq2gxfucrhczj3vCBN4BwgaDLjSA8HpejnnppVI2tjj/t3PEpW3kganm8G1nfGVyo5mNdKYlZj49gQLHhJgiIEj44ZxrP1Q86WRA69ZLNmuyl1AIV7TI3kCrGa/av/cVhr1IC8" rel="nofollow noreferrer" title="J ‚Äì Try It Online">Try it online!</a></p>

<h2>explanation</h2>

<pre><code>(*#'.,012&amp;|@~#') = 1 #. [: , ([: */ 0 = 2&amp;|@#/.~)\.\

(*#'.,012&amp;|@~#')                                       NB. this evaluates to 1
                                                       NB. while supplying extra
                                                       NB. chars we need.  hence...
                 =                                     NB. does 1 equal...
                   1 #.                                NB. the sum of...
                        [: ,                           NB. the flatten of...
                             (                  )\.\   NB. the verb in parens applied
                                                       NB. to every suffix of every
                                                       NB. prefix, ie, all contiguous 
                                                       NB. substrings
                             ([: */ 0 = 2&amp;|@#/.~)      NB. def of verb in paren:
                                             /.~       NB. when we group by each
                                                       NB. distinct char...
                              [: */                    NB. is it the case that
                                                       NB. every group...
                                           @#          NB. has a length...
                                    0 = 2&amp;|            NB. divisible by 2...
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://docs.python.org/3.8/" rel="nofollow noreferrer">Python 3.8 (pre-release)</a>, 66 bytes</h1>



<pre class="lang-python prettyprint-override"><code>lambda l,b={id}:len({str(b:=b^{c})for(c)in l})&lt;len(l)#,&lt;^fmnost{}#
</code></pre>

<p><a href="https://tio.run/##NY3RCsMgDEWf168Q@qBCt5e9jNLuUwomrUywKiqDIX57F@kWCJzk5t6ET355d3@EeKBfNzYzzvlh1Q6rYnaAuZi1jnZzoqQcBYwzLAWr1D4KlMYxW@XUZCv7YVr07nzKpfYHxdzIYYKQXacpd3srK9qPNvvIEiM3V4CgkA@NAE8CqnOjEH4aXVH/GRVRyxq7S4jGZZFIuT5pq0WS8vgC" rel="nofollow noreferrer" title="Python 3.8 (pre-release) ‚Äì Try It Online">Try it online!</a></p>

<p>The Era of Assignment Expressions is upon us. With <a href="https://www.python.org/dev/peps/pep-0572/" rel="nofollow noreferrer">PEP 572</a> included in Python 3.8, golfing will never be the same. You can install the early developer preview 3.8.0a1 <a href="https://www.python.org/downloads/release/python-380a1/" rel="nofollow noreferrer">here</a>.</p>

<p>Assignment expressions let you use <code>:=</code> to assign to a variable inline while evaluating to that value. For example, <code>(a:=2, a+1)</code> gives <code>(2, 3)</code>. This can of course be used to store variables for reuse, but here we go a step further and use it as an accumulator in a comprehension.</p>

<p>For example, this code computes the cumulative sums <code>[1, 3, 6]</code></p>

<pre class="lang-python prettyprint-override"><code>t=0
l=[1,2,3]
print([t:=t+x for x in l])
</code></pre>

<p>Note how with each pass through the list comprehension, the cumulative sum <code>t</code> is increased by <code>x</code> and the new value is stored in the list produced by the comprehension.</p>

<p>Similarly, <code>b:=b^{c}</code> updates the set of characters <code>b</code> to toggle whether it includes character <code>c</code>, and evaluates to the new value of <code>b</code>. So, the code <code>[b:=b^{c}for c in l]</code> iterates over characters <code>c</code> in <code>l</code> and accumulates the set of characters seen an odd number of times in each non-empty prefix. </p>

<p>This list is checked for duplicates by making it a set comprehension instead and seeing if its length is smaller than that of <code>s</code>, which means that some repeats were collapsed. If so, the repeat means that in the portion of <code>s</code> seen in between those times every character encountered an even number of numbers, making the string non-well-linked. Python doesn't allow sets of sets for being unhashable, so the inner sets are converted to strings instead.</p>

<p>The set <code>b</code> is initialized as an optional arguments, and successfully gets modified in the function scope. I was worried this would make the function non-reusable, but it seems to reset between runs.</p>

<p>For the source restriction, unpaired characters are stuffed in a comment at the end. Writing <code>for(c)in l</code> rather than <code>for c in l</code> cancels the extra parens for free. We put <code>id</code> into the initial set <code>b</code>, which is harmless since it can start as any set, but the empty set can't be written as <code>{}</code> because Python will make an empty dictionary. Since the letters <code>i</code> and <code>d</code> are among those needing pairing, we can put the function <code>id</code> there.</p>

<p>Note that the code outputs negated booleans, so it will correctly give <code>False</code> on itself.</p>
</div>
<div id="pu5" class="pu"><h1><a href="http://www.mono-project.com/docs/about-mono/releases/5.0.0/#csc" rel="nofollow noreferrer">C# (Visual C# Interactive Compiler)</a>, <s>208</s> <s>206</s> <s>200</s> 198 bytes</h1>



<pre class="lang-cs prettyprint-override"><code>x=&gt;!x.GroupBy(c=&gt;c).Any(g=&gt;g.Count()%2&gt;0)&amp;!Enumerable.Repeat(x.Count,x.Count*x.Count).Where(
(l,i)=&gt;i%l&gt;0&amp;!x.Skip(i/l).Take(i%l).GroupBy(c=&gt;c).Any(g=&gt;g.Count()%2&gt;0)
).Any()/*&gt;!oyAnC0EmeablR*WhiS/T*/
</code></pre>

<p><a href="https://tio.run/##3ZHBisIwEEDv/QpbUJJSk7JXTdgquizsYdGC52SINhibkjbQfn03oAcXFux5B4aB4Q1vhoF2Ca0e976G9eeXbrs1VMLxTFpr@JmNPeNxTz6c9c1mQMA4YFLUA7owfiFb6@sO4fkbz/Ei3tX@ppyQRpGDapToUH8nskdNHxWTU6WcQhEymcaM67nh@SJojlfdIE0NJqW4KhT6eIo6uvcxTXlsh6Le5rubCnsc0lOlj7RM6biKom@nw8QZJUKCFJCQ0hbOiTCH8WpG6ax0Xj1TEv6i9sK0T5gM8RISwScnGMNeIadwIF5J35P/8brfd44/" rel="nofollow noreferrer" title="C# (Visual C# Interactive Compiler) ‚Äì Try It Online">Try it online!</a></p>

<p>-2 bytes thanks to @KevinCruijssen!</p>

<p>Finally got it below 200, so I might be done golfing for now :) I ended up creating a second TIO to test things out based on a previous answer.</p>

<p><a href="https://tio.run/##jVHRasIwFH3PV9iCkrRdWvdoTTYnsoftYajgc1eipomtxDpa3b69SxopqHsYhJzLzb3nHE7Sw0N64M1XonoVeXabilCnwq@qOO5fapgSmiI8yWu4IXSDp8UxLyHqP9IIDZxZftwxlXxKhudsz5ISVnYiuKB3QYRXW6YYBFAGHBHK@5JGAy2zEHwPeSgRXiaCQd1H/5EGto9CjzpFPcmn0WzHtI@5t9ryRbj0wsbFS8V3EMUAfCiuNw@lBkOTp63Raxnr704IL5hkaWkf3liNkCHUdD1OoiAjtzR2944mEHryneWbctv54b47cv2svYVhXRcKxnwsPBFznwzRGQDzKTXpYhJdTOImptjOSpL5Q11nPnFqG9G3xROhpytLT9HITPI1zAiRqHe@2GplWlOtTFvdRveHHZPLDzDH0mTjIYqbXw" rel="nofollow noreferrer" title="C# (Visual C# Interactive Compiler) ‚Äì Try It Online">Try it online!</a></p>

<p>Things that made this task tricky:</p>

<ul>
<li>Equality operator <code>==</code> was not allowed</li>
<li>Increment/assign operator <code>++</code> was not allowed</li>
<li>Linq <code>All()</code> function was not allowed</li>
</ul>

<p>Commented code below:</p>

<pre class="lang-cs prettyprint-override"><code>// anonymous function that takes an IList as input
x=&gt;
  // the first condition makes sure the string even
  // counts of each character
  !x.GroupBy(c=&gt;c).Any(g=&gt;g.Count()%2&gt;0)&amp;
  // the second condition generates all proper substrings of x
  // and tests for any that contain even character counts
  // the string length `l` is repeated `l*l` times
  !Enumerable.Repeat(x.Count,x.Count*x.Count)
    .Where((l,i)=&gt;
      // check that the substring length is greater than 0
      i%l&gt;0&amp;
      // use skip/take to generate a substring
      // and check for a character count thats odd
      // negate the result meaning we have found
      // a substring that invalidates the input
      !x.Skip(i/l).Take(i%l)
        .GroupBy(c=&gt;c).Any(g=&gt;g.Count()%2&gt;0)
    )
    // if any invalid substrings are found
    // then the result in invalid
    // the comment string at the end is needed
    // to make the program well-linked
    .Any()/*&gt;!oyAnC0EmeablR*WhiS/T*/
</code></pre>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/m-ender/retina/wiki/The-Language" rel="nofollow noreferrer">Retina</a>, <s>150</s> 96 bytes</h1>

<pre><code>^(?!(.*)(.+)(.*)$(?&lt;!^\2|^\1(?:(^?(?:(?!\6).)*\6){2})*(|(?!\6).)*(?!.+\6.*\3$)(.){1,}\3)(?!,&lt;)?)
</code></pre>

<p><a href="https://tio.run/##tY4xCsMwDEX33MKQguQEgRPIUAIaewlhIpkMXTqUbknO7spLb1CB/v88wUfv/fN8aao3eGw1AwegiEADNu@B15BlOrMk4DtkbspBFiSMrsd0YYTzhzzQIAtFmXtvwCONl8zoeFyRsVa1Ylo6NStu5uNZizXkF9/u3098AQ" rel="nofollow noreferrer" title="Retina ‚Äì Try It Online">Try it online!</a> Link includes test cases, including itself. Edit: Golfed down the original regex a fair bit with help from @Deadcode, then padded back up slightly less extravagently to maintain the source layout. Explanation:</p>

<pre><code>^(?!(.*)(.+)(.*)$
</code></pre>

<p>Assert that no substring <code>\3</code> exists that matches the following constraints.</p>

<pre><code>(?&lt;!^\2|
</code></pre>

<p>Assert that the substring is not the whole original string.</p>

<pre><code>^\1(?:(^?(?:(?!\6).)*\6){2})*(|(?!\6).)*(?!.+\6.*\3$)(.){1,}\3)(?!,&lt;)?)
</code></pre>

<p>Assert that there is no character <code>\6</code> such that:</p>

<ul>
<li>it does not appear between the character itself (exclusive) and the end of the substring</li>
<li>it appears an even number of times between the start of the substring and itself (exclusive)</li>
</ul>

<p>In order to pass the source layout constraint, I replaced <code>((((</code> with <code>(?:(^?(?:(</code> and <code>((</code> with <code>(|(</code>. I still had one source constraint <code>))</code> left and the characters <code>!()1&lt;{}</code> left over, so I changed a <code>+</code> into <code>{1,}</code> and inserted the useless <code>(?!,&lt;)?</code> to consume the rest.</p>
</div>
<div id="pu7" class="pu"><h1>Perl 5 <code>-p</code>, <s>94,</s> <s>86,</s> 78 bytes</h1>
<pre><code>m-.+(?{$Q|=@q&amp;grp,$\|=$&amp;eq$_^!grep+/^/&amp;(@m=$g=~/\Q$_/g),($g=$&amp;)=~/./g})(?!)-}{
</code></pre>
<p>ouput 0 if well-linked 1 otherwise.</p>
<p><a href="https://tio.run/##rVBBboMwELz7FZvEIqAEaA45IRo@0EPuKMg4DqAY7KyNSEXSp5ea9NIH9LQzs9LOzGqBcj@twCowtRpAnc/Aa4aMW4EGhlp0jgt@bboKjOqRC0BhLDbcNqojK6BVSovEsE@3RgsVCj1m99TJX3F@pEVcJdnd2z1fQuQYIS87JqXzcwD7Di4Koe2lbbQU0HS6t6BsLXBojAAH4NJLCRpVhayFQeHVgOq4IM6X5tGS0ALS92VCaJ6u18nUhtHGP4z0@Eizm1eh3tL8kVJP3GhxWswZN/Ep9vys/Rs02PpzGy/4TfoM/MMiCJ/jNLGSl4wTVpbcjf@9/q30/EozhVpO4cc@etv9AA" rel="nofollow noreferrer">78 bytes</a></p>
<p><a href="https://tio.run/##K0gtyjH9r1Jka2D9P1dHT1vDvlol3VZFzVqlqAZIpRaqxMcpphelFlQ7VNgCZer0YwJV4vXTrR0q1AxrwQJ6@um1mhr2ipo61irxtipF1spq2oa5BYVF8XE1yjGB//8nJiUnJSZzJSYlJQMp2tjyL7@gJDM/r/i/bkHOf11fUz0DQwA" rel="nofollow noreferrer">86 bytes</a></p>
<p><a href="https://tio.run/##tY0xCoMwFED3nsLgJyao0QxOIegFOrgLmgQJgtaQdhDUHr2p9A6dHjwePDf6uQrgZSnCkrGU1DtYCViAPyQiESIwMEhoRDGyfnR7s8kreBddC31hRbNhfv4EK@xJSY1oJqCX4EWME5byYVycP@KuDUFpo5W5Ka3Nhf/ePqt7TevjGXI3h/xesZJ/AQ" rel="nofollow noreferrer">94 bytes</a></p>
<p>How it works</p>
<ul>
<li><code>-p</code> with <code>}{</code> ending trick to output <code>$\</code> at the end</li>
<li><code>m-.+(?{</code> .. <code>})(?!)-</code>, to execute code over all non-empty substring (<code>.+</code> matches the whole string first, and after executing code between <code>(?{</code> ..<code>})</code> backtracks because of failed forced <code>(?!)</code></li>
<li><code>$Q|=@q&amp;grp,</code> garbage because of source restriction</li>
<li><code>$\|=</code> integer bitwise or assignment, if there's almost one 1, <code>$\</code> will be 1 (true), by default it is empty (false)</li>
<li><code>$&amp;eq$_</code> the case where the sbustring is the whole string is bitwise xored <code>^</code> with &quot;no odd character occurence&quot;</li>
<li><code>($g=$&amp;)=~/./g</code> to copy the matched substring into <code>$g</code> (because will be overwirtten after next regex match) and return the array of character of substring.</li>
<li><code>/^/</code> garbage which evaluates to 1</li>
<li><code>grep</code> 1 <code>&amp;(@m=$g=~/\Q$_/g),</code> for each character in substring get the array of character in <code>$g</code> matching itself, array in scalar evaluates to its size and <code>grep</code> to filter the chracters with odd occurence <code>1&amp;x</code> is equivalent to <code>x%2==1</code></li>
</ul>
</div>
<div id="pu8" class="pu"><h1><a href="https://github.com/nxadm/rakudo-pkg" rel="nofollow noreferrer">Perl 6</a>, 76 bytes</h1>



<pre class="lang-perl6 prettyprint-override"><code>*.comb[^*X+(^*).map(^*)].grep({$_&amp;[&amp;]($_)}).none.Bag{*}.none%2#*^+XBob2rec%#
</code></pre>

<p><a href="https://tio.run/##rZDBaoQwEIbPzVMMuGoSt6H1sJdSCx76BD0IosskxMWuGondgojPbuNK2fbcBobMZL5/5ie9ts1haUcIKniGhQtlWpmXPItoyZlosV/vQpys7um0OwZ5UNDdkc1MdKbTIsXTxOdr7sceL6MsNTK2Wvne8kRIZSw0daeHJBFD39QfNIT7BEIGE7kbcISXior8oWB72Bp7EPljAWQmxFv74V8deSr1TSZ1GdsovM5aiU3NxSc2F4cxZ@@sR/Fu6m5BqSSq1c2bvWiCUqqtfMVm0ES6c6vQofIn7LQufj0ovPH/@cHfS74A" rel="nofollow noreferrer" title="Perl 6 ‚Äì Try It Online">Try it online!</a></p>

<p>A Whatever lambda that returns a None Junction of None Junctions that can be boolified to a truthy/falsey value. I would recommend not removing the <code>?</code> that boolifies the return result though, otherwise the output gets rather <a href="https://tio.run/##rZDBaoQwEIbPzVMMuGoSt0PrYS9LPXjoE/QgiC5JiIutGondgojPbuNK2fbcDQyZmXz/zE96bZvD0o4QVPACC0dlWpmXPItoyRm2ol/vAs9W93TanYI8KOjuxGaGnek0puI88fma@7HHyyhLjYytVr63HAmpjIWm7vSQJDj0Tf1JQ3hMIGQwkYdBjFBRzJ8KtoetvwfMnwsgMyHe@hz@15CnUt9kUpexjcLrrJXY1By/RHNxGHPuPvSI76buFiGVFGp182Yvmggp1Va@imbQRLpzq4RD5W/YaV38aShx4@/5vz9LvgE" rel="nofollow noreferrer">large</a>. </p>

<p>This solution is a little more complex than needed, due to several involved functions being unlinked, e.g. <code>..</code>, <code>all</code>, <code>&gt;&gt;</code>, <code>%%</code> etc. Without the source restriction, this could be 43 bytes:</p>



<pre class="lang-perl6 prettyprint-override"><code>*.comb[^*X.. ^*].grep(?*).one.Bag{*}.all%%2
</code></pre>

<p><a href="https://tio.run/##VYvLCoMwFETXzVfcjVWDvbRduClV6KJf0EVBFG5CFCE@SNqFiN@epgh9DMxiZs6MyujUdRNsaziD4yiHThQVvyNCxUtsjBqjnMc49Aov1Mx8QdI6CI7uxFg9GNBtr2yWoR11@4hC2GUQxjCzjaUJ8jrCYl/GCaxDAlgcSmCLIyEFyXd5M0/FSAi5xitpq5jw@ibyqPiF/df7r5D04V8" rel="nofollow noreferrer" title="Perl 6 ‚Äì Try It Online">Try it online!</a></p>

<h3>Explanation:</h3>

<pre class="lang-perl6 prettyprint-override"><code>*.comb                     # Split the string to a list of characters
      [^*X+(^*).map(^*)]   # Get all substrings, alongside some garbage
                        .grep({$_&amp;[&amp;]($_)})        # Filter out the garbage (empty lists, lists with Nil values)
                                           .none                 # Are none of
                                                .Bag{*}          # The count of characters in each substring
                                                       .none%2   # All not divisible by 2

                                               #*^+XBob2rec%#    And garbage to even out character counts
</code></pre>
</div>
<div id="pu9" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, <s>22</s> 20 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>≈íŒµ¬¢P√†}K≈íIKŒµSIS¬¢√àP}√†√à
</code></pre>
<p>Outputs <code>1</code> if the string is well-linked, and <code>0</code> if the string is not well-linked.</p>
<p><a href="https://tio.run/##yy9OTMpM/f//6KRzWw8tCji8oNb76CRP73Nbgz2DDy063BFQe3jB4Q5C8gA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/V9WeXjC4Qmh9koKunYKSvb/j046t/XQooDDC2q9j06K8D63NTgi@NCiwx0BtYcXHO74r/M/WglFiSdIiSeSEiUdpcSk5KTEZDAjKRnMSAICMD8xOSkZpiIpOQXKTE5UigUA" rel="nofollow noreferrer">verify all test cases</a>.</p>
<p><strong>Explanation:</strong></p>

<p>The base program is <code>≈ísKŒµsS¬¢√àP}√†</code> (<strong>11 bytes</strong>), which outputs <code>0</code> if well-linked and <code>1</code> if not well-linked. The trailing <code>√à</code> (is_even) is a semi no-op that inverts the output, so <code>1</code> for well-linked strings and <code>0</code> for not well-linked strings. The other parts are no-ops to comply to the challenge rules.</p>
<pre class="lang-python prettyprint-override"><code>≈íŒµ¬¢P√†}K         # No-ops: substrings, map, count, product, maximum, close map, remove
                # Due to the last remove, we're back at the (implicit) input again
≈í               # Take the substrings of the input
 IK             # Remove the input itself from that list of substrings
   Œµ            # Map each substring to:
    S           #  No-op: transform the substring into a list of characters
     IS         #  Get the input-string as a list of characters
       ¬¢        #  Count the occurrence of each character in the current substring
        √à       #  Check which counts are even (1 if truthy; 0 if falsey)
         P      #  Take the product of that
          }√†    # After the map: check if any are truthy by taking the maximum
            √à   # Semi no-op: check if this maximum is even (0 becomes 1; 1 becomes 0)
                # (and output the result implicitly)
</code></pre>
</div>
<div id="pu10" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>, 74 bytes</h1>



<pre class="lang-python prettyprint-override"><code>bmn0=f=lambda s,P={0},d=[]:s&lt;" "if(P in d)else+f(s[f&lt;s:],P^{s[0^0]},[P]+d)
</code></pre>

<p><a href="https://tio.run/##XY3LasMwEEX3@opBUCxhE9wsTbTqD3jRnesUPYmKIxmPQltCvt2V7C5KBUKXO2eO5u90ieG46misoJSu6hpa4cQkr8pIwKYX9/bRGDGMHZ4oUO9YDz6A4XZCWzuGgzthNzb9@Y5De27HRzP0Y234mnUHTIufGSf2y2oonxASjXnXF7kgCMjER/SBaXBxAV3EGJdkDUObWOE5B@@2zYOOt5BL/nTkZF58SEBfcg@z9Is1HW2gZn/kxf4fRLRYQLe79yl9C7mirxYTaLkR5PPiJwvP3b7umA/zLTHO10oqraSuSA5Sqz3kJt/fqOUW8luGKp/qBw" rel="nofollow noreferrer" title="Python 2 ‚Äì Try It Online">Try it online!</a></p>

<p>Iterates through the string, keeping track in <code>P</code> of the set of characters seen an odd number of times so far. The list <code>d</code> stores all past values of <code>P</code>, and if see the current <code>P</code> already in <code>d</code>, this means that in the characters seen since that time, each character has appeared an even number of times. If so, check if we've gone through the entire input: if we have, accept because the whole string is paired as expected, and otherwise reject.</p>

<p>Now about the source restriction. Characters needing pairing are stuffed into various harmless places, underlined below: </p>

<pre class="lang-python prettyprint-override"><code>bmn0=f=lambda s,P={0},d=[]:s&lt;" "if(P in d)else+f(s[f&lt;s:],P^{s[0^0]},[P]+d)
_____              _              _      _    _    ___        ___    
</code></pre>

<p>The <code>f&lt;s</code> evaluates to <code>0</code> while pairing off an <code>f</code>, taking advantage of the function name also being <code>f</code> so that it's defined (by the time the function is called.) The <code>0^0</code> absorbs an <code>^</code> symbol.</p>

<p>The <code>0</code> in <code>P={0}</code> is unfortunate: in Python <code>{}</code> evaluates to an empty dict rather than an empty set as we want, and here we can put in any non-character element and it will be harmless. I don't see anything spare to put in though, and have put in a <code>0</code> and duplicated it in <code>bmn0</code>, costing 2 bytes. Note that initial arguments are evaluated when the function is defined, so variables we define ourselves can't be put in here.</p>
</div>
<div id="pu11" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>, 108 bytes</h1>



<pre class="lang-python prettyprint-override"><code>lambda d,e=enumerate:min(max(d[l:l+b].count(k)%2for(k)in d)for b,c in e(d[2:],2)for l,f in e(d) )#b =:x+.%2#
</code></pre>

<p><a href="https://tio.run/##vY1BCsMgFESv8iGE@Ilk4VLwJG0WGpVK9StBITm9ldIzdDVvHgNT7vrKJLpXzx51MlaD5U45asmdujqZArGkL2YfUcbV7NuRG1X2xln4fI4MBBYHguEHjOLGVMidi6@M3P8kAk4GlLzWbRZTL2egCp4FKq0yxL788375AA" rel="nofollow noreferrer" title="Python 2 ‚Äì Try It Online">Try it online!</a></p>

<p>-2 thanks to <a href="https://codegolf.stackexchange.com/users/66041/%c3%98rjan-johansen">√òrjan Johansen</a>.</p>
</div>
<div id="pu12" class="pu"><h2>Jelly, 20 bytes</h2>

<pre><code>ƒ†·∫à·∏Ç·∫∏·∫Ü·πñ√á‚Ç¨·∫†
ƒ†·∫à·∏Ç·∫∏
·∫Ü·πñ√á‚Ç¨·∫†
</code></pre>

<p><a href="https://tio.run/##y0rNyan8///Igoe7Oh7uaHq4a8fDXW0Pd0473P6oac3DXQu4kGS4UKX@k6cNAA" rel="noreferrer">Try it online!</a></p>

<p>The first line is ignored. It's only there to satisfy the condition that every character appear an even number of times.</p>

<p>The next line first <code>ƒ†</code>roups indices by their value. If we then take the length of each sublist in the resulting list (<code>·∫à</code>), we get the number of times each character appears. To check whether any of these are non-even, we get the last <code>·∏Ç</code>it of each count and ask whether there <code>·∫∏</code>xists a truthy (nonzero) value.</p>

<p>Therefore, this helper link returns whether a substring <em>cannot</em> be circled.</p>

<p>In the main link, we take all substrings of the input (<code>·∫Ü</code>), <code>·πñ</code>op off the last one (so that we don't check whether the entire string can be circled), and run the helper link (<code>√á</code>) on <code>‚Ç¨</code>ach substring. The result is then whether <code>·∫†</code>ll substrings cannot be circled.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/179422/">179422</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




