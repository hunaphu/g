<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::6596</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td></td><td>250109T210227Z</td><td><a href="https://codegolf.stackexchange.com/questions/6596/tips-for-golfing-in-j/277568#277568">Conor O&</a></td></tr>
<tr d-ix="1"><td>nan</td><td></td><td>180725T194734Z</td><td><a href="https://codegolf.stackexchange.com/questions/6596/tips-for-golfing-in-j/169255#169255">Conor O&</a></td></tr>
<tr d-ix="2"><td>nan</td><td></td><td>210701T024004Z</td><td><a href="https://codegolf.stackexchange.com/questions/6596/tips-for-golfing-in-j/230827#230827">Bubbler</a></td></tr>
<tr d-ix="3"><td>nan</td><td></td><td>200528T073719Z</td><td><a href="https://codegolf.stackexchange.com/questions/6596/tips-for-golfing-in-j/205356#205356">Bubbler</a></td></tr>
<tr d-ix="4"><td>nan</td><td></td><td>181008T085417Z</td><td><a href="https://codegolf.stackexchange.com/questions/6596/tips-for-golfing-in-j/173657#173657">Bubbler</a></td></tr>
<tr d-ix="5"><td>nan</td><td></td><td>200409T064604Z</td><td><a href="https://codegolf.stackexchange.com/questions/6596/tips-for-golfing-in-j/203218#203218">Bubbler</a></td></tr>
<tr d-ix="6"><td>nan</td><td>& is your friend</td><td>191115T011859Z</td><td><a href="https://codegolf.stackexchange.com/questions/6596/tips-for-golfing-in-j/195891#195891">Bubbler</a></td></tr>
<tr d-ix="7"><td>nan</td><td></td><td>171230T230127Z</td><td><a href="https://codegolf.stackexchange.com/questions/6596/tips-for-golfing-in-j/152191#152191">cole</a></td></tr>
<tr d-ix="8"><td>004</td><td>Getting numbers from 0 to</td><td>171118T170952Z</td><td><a href="https://codegolf.stackexchange.com/questions/6596/tips-for-golfing-in-j/148499#148499">FrownyFr</a></td></tr>
<tr d-ix="9"><td>nan</td><td></td><td>160826T043241Z</td><td><a href="https://codegolf.stackexchange.com/questions/6596/tips-for-golfing-in-j/91176#91176">miles</a></td></tr>
<tr d-ix="10"><td>nan</td><td></td><td>160315T165503Z</td><td><a href="https://codegolf.stackexchange.com/questions/6596/tips-for-golfing-in-j/75585#75585">Conor O&</a></td></tr>
<tr d-ix="11"><td>nan</td><td>Consider using explicit definition instead of writing a tacit verb sure the 3 ' and ' cost 5 bytes</td><td>150305T180944Z</td><td><a href="https://codegolf.stackexchange.com/questions/6596/tips-for-golfing-in-j/47449#47449">Omar</a></td></tr>
<tr d-ix="12"><td>nan</td><td>The most important thing when golfing in J is to not only understand the problem</td><td>150224T145727Z</td><td><a href="https://codegolf.stackexchange.com/questions/6596/tips-for-golfing-in-j/47034#47034">FUZxxl</a></td></tr>
<tr d-ix="13"><td>nan</td><td>There are a number of subtleties to squeezing out the last few characters in J. For the following</td><td>140318T183742Z</td><td><a href="https://codegolf.stackexchange.com/questions/6596/tips-for-golfing-in-j/24471#24471">algorith</a></td></tr>
<tr d-ix="14"><td>nan</td><td></td><td>120711T235525Z</td><td><a href="https://codegolf.stackexchange.com/questions/6596/tips-for-golfing-in-j/6599#6599">Gareth</a></td></tr>
<tr d-ix="15"><td>nan</td><td></td><td>120714T172429Z</td><td><a href="https://codegolf.stackexchange.com/questions/6596/tips-for-golfing-in-j/6622#6622">Gareth</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Builtin Constants</h1>
<p>I find myself constantly looking for the same specific predefined verbs and nouns useful for golfing. Although much of this information can be found <a href="https://code.jsoftware.com/wiki/Standard_Library/Overview" rel="nofollow noreferrer">on the Standard Library page</a> (as referenced in <a href="https://codegolf.stackexchange.com/users/6710/miles">@miles</a>'s <a href="https://codegolf.stackexchange.com/a/91176/31957">answer</a>), and I imagine many seasoned J golfers know many, if not all of these builtins, this quick reference should be a bit more accessible than dredging through all of the functions. I will also include an example of using each, where applicable.</p>
<p>If you're curious how I obtained these from a more &quot;reverse engineering perspective&quot;, especially the <code>j</code> locale, see the &quot;General  Method&quot; section after the quick reference.</p>
<p><code>z</code> locale (always accessible):</p>
<ul>
<li><a href="https://code.jsoftware.com/wiki/Standard_Library/stdlib#hfd" rel="nofollow noreferrer"><code>hfd</code></a> (hex from decimal) and <a href="https://code.jsoftware.com/wiki/Standard_Library/stdlib#dfh" rel="nofollow noreferrer"><code>dfh</code></a> (decimal from hex)
<ul>
<li><code>'7f' -: hfd 127</code></li>
<li><code>(,127) -: ~.dfh&amp;&gt; '7F';'7f';'07f'</code></li>
</ul>
</li>
<li><code>CR</code> (carriage return <code>\r</code>), <code>LF</code> (line feed <code>\n</code>), <code>TAB</code> (tab <code>\t</code>), <code>CRLF</code> (both concatenated), and <code>LF2</code> (two consecutive line feeds).</li>
<li>Many people know <a href="https://code.jsoftware.com/wiki/Standard_Library/stdlib#echo" rel="nofollow noreferrer"><code>echo</code></a> (basically an alias for <code>1!:2&amp;2</code>, printing to the screen) and <a href="https://code.jsoftware.com/wiki/Standard_Library/stdlib#stdout" rel="nofollow noreferrer"><code>stdout</code></a> (alias for <code>1!:2&amp;4</code>, printing raw bytes/strings to STDOUT), but many <a href="https://code.jsoftware.com/wiki/Vocabulary/Foreigns" rel="nofollow noreferrer">Foreigns</a> have aliases, listed in the linked table and their linked subsections.</li>
<li>Various libraries (like <a href="https://code.jsoftware.com/wiki/Standard_Library/strings" rel="nofollow noreferrer"><code>string</code></a> and <a href="https://code.jsoftware.com/wiki/Guides/Regular_Expressions/Verbs" rel="nofollow noreferrer"><code>regex</code></a>) are loaded into the <code>z</code> locale, often making an explicit <code>load</code> or <code>require</code> call unnecessary.</li>
<li>Bitwise verbs <a href="https://code.jsoftware.com/wiki/Standard_Library/stdlib#AND" rel="nofollow noreferrer"><code>AND</code></a>, <a href="https://code.jsoftware.com/wiki/Standard_Library/stdlib#OR" rel="nofollow noreferrer"><code>OR</code></a>, and <a href="https://code.jsoftware.com/wiki/Standard_Library/stdlib#XOR" rel="nofollow noreferrer"><code>XOR</code></a> corresponding to <code>&amp;</code>, <code>|</code>, and <code>^</code> in many languages, including a monadic case for a list of numbers
<ul>
<li><code>2b1001 -: 2b1011 AND 2b1101</code></li>
<li><code>13 -: OR 2b1000 2b0100 2b0001</code></li>
</ul>
</li>
<li><a href="https://code.jsoftware.com/wiki/Standard_Library/stdlib#cutLF" rel="nofollow noreferrer"><code>cutLF</code></a> to split on line feeds (not carriage returns), ignoring blank lines
<ul>
<li><code>('a b c';'what';'asdf') -: cutLF LF,'a b c',LF,'what',LF,LF,'asdf'</code></li>
</ul>
</li>
<li><a href="https://code.jsoftware.com/wiki/Standard_Library/stdlib#cutopen" rel="nofollow noreferrer"><code>cutopen</code></a> to intelligently split on a delimiter (dyadic) or on line feeds (or spaces if no line feeds appear in input)</li>
<li><a href="https://code.jsoftware.com/wiki/Standard_Library/stdlib#tolower" rel="nofollow noreferrer"><code>tolower</code></a> and <a href="https://code.jsoftware.com/wiki/Standard_Library/stdlib#toupper" rel="nofollow noreferrer"><code>toupper</code></a> for case conversion.</li>
</ul>
<p><code>j</code> locale (requires <code>_j_</code> suffix to specify the locale):</p>
<ul>
<li><code>Alpha_j_</code>: <code>'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'</code></li>
<li><code>AlphaNum_j_</code>: <code>'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'</code></li>
<li><code>Num_j_</code>: <code>'0123456789'</code>, shorter than <code>1&quot;:i.10</code> (and does not require parentheses)</li>
</ul>
<h2>Dubiously useful constants</h2>
<p><code>z</code> locale:</p>
<ul>
<li>The <a href="https://code.jsoftware.com/wiki/Standard_Library/stdlib#bind" rel="nofollow noreferrer"><code>bind</code></a> conjunction; <code>u bind n</code> equivalent to <code>u@(n&quot;_)</code>, meant to be used to create a monadic verb which ignores its input and takes <code>n</code> instead. Given the spaces required, it might not work out in your favor for golfing, but it could be useful in some niche circumstances.
<ul>
<li><code>stdout bind'-'&amp;&gt;3;4;5;6</code> outputs <code>----</code> to the console (same byte count as <code>stdout@('-'&quot;_)&amp;&gt;3;4;5;6</code>)</li>
</ul>
</li>
<li><a href="https://code.jsoftware.com/wiki/Standard_Library/stdlib#boxopen" rel="nofollow noreferrer"><code>boxopen</code></a> which boxes a noun if not already boxed, saves at least 4 bytes over the naive <code>&lt;`[@.(*@L.)</code>, and even more over the given implementation.</li>
</ul>
<p><code>j</code> locale:</p>
<ul>
<li><code>boxdraw_j_</code>, which sets the current box drawing characters to the <code>N</code>th tile set defined in <code>Boxes_j_</code>
<ul>
<li><a href="https://tio.run/##y/r/Pym/IqUosTw@K17BQEFBwc9JT8ElNS2xNKdEIT9PIcTTnys1OSNfwdjahAtJqSGm0tzEvEqF4sriktTcYrie//8B" rel="nofollow noreferrer">See TIO example</a></li>
</ul>
</li>
<li><code>browse_j_</code> opens the browser to the (fully specified) webpage
<ul>
<li><code>browse_j_ 'https://www.google.com/'</code></li>
</ul>
</li>
<li><code>isURL</code>, which tests if <code>'://'</code> is present as a substring in the input</li>
</ul>
<h2>General Method</h2>
<p>The predefined <code>names</code> method gives all variables defined in the current <a href="https://code.jsoftware.com/wiki/Vocabulary/Locales" rel="nofollow noreferrer">locale</a>. For example:</p>
<pre><code>   a =: b =: 3
   names ''
a b
   bob =: jill =: +
   names ''
a    b    bob  jill
</code></pre>
<p>The default locale is <code>base</code>, and the standard library is contained in the <code>z</code> locale, and is always visible, no matter the locale. There is a little known locale, the <code>j</code> locale, which contains many nouns and verbs which seem to be relevant to the J environment itself, but are also useful for golf.</p>
<p>To see all the variables defined in a specific locale, you can either use <code>cocurrent 'locale'</code> before using <code>names</code> (e.g. <code>names cocurrent 'j'</code>), or you can specify the locale explicitly, e.g., <code>names_j_ ''</code>. There are lots of niche functions and constants in both <code>names_z_ ''</code> and <code>names_j_ ''</code>, and I would recommend perusing them at your own leisure, especially for restricted source challenges. Something that surprised me was the inclusion of various <code>IF</code> constants in the <code>z</code> locale corresponding to the executing platform, e.g. <code>1 -: IFWIN</code> iff the user is on a Windows system, and similarly for <code>IFUNIX</code>.</p>
</div>
<div id="pu1" class="pu"><h1>Shorter ways to mess with ranks</h1>
<p>Sometimes, you'll have code like <code>&lt;&quot;0 i.3 3</code>, where you want to apply a verb <code>v</code> at rank <code>r</code>. However, if you use a noun (like <code>0</code>), you'll often have to include a space. To avoid this, you can use another verb <code>u</code> of equivalent rank and use <code>u&quot;v</code> instead. For example, since <code>+</code> has rank <code>0 0 0</code>, we can use <code>&lt;&quot;+</code> instead of <code>&lt;&quot;0</code>.</p>
<p><strong>Rank mini-lesson:</strong> This 3-element rank notation is <code>monadic dyad-left dyad-right</code>. For example, <code>=</code> has rank <code>_ 0 0</code>, so <code>(v&quot;=) x</code> is equivalent to <code>(v&quot;_) x</code> (applying <code>v</code> to all of <code>x</code>), but <code>x (v&quot;_) y</code> is equivalent to <code>x (v&quot;0 0) y</code>, applying <code>v</code> pairwise to all cells in <code>x</code> and <code>y</code>.</p>
<p>Here is a table of all verbs and their ranks (obtainable by using <code>v b. 0</code>):</p>
<h2>New J (e.g. J9.4)</h2>
<p>Edit 2024: Some of the ranks changed and new verbs have been added. In particular, <code>~. {: }: L.</code> were changed from <code>_ 0 0</code> to <code>_ _ _</code>. No new shortest representations were added/removed, though.</p>
<pre><code>0 0 0     &gt; + * - % ^ | ! ? &lt;. &lt;: &gt;. &gt;: +. +: *. *: %: ^. j. o. q: r.
0 _ _     -. -: E. i: p:
1 0 1     p..
1 0 _     { A.
1 1 0     p.
1 1 1     #.
1 1 _     C.
1 _ _     ;: &quot;. i. I.
2 _ 2     %.
_ 0 0     = &lt; ~: ?.
_ 1 0     #:
_ 1 _     $ # |. |: {. }. &quot;: {::
_ _ _     , ; [ ] _: $. $: ,. ,: /: \: [: e. s: u: x: 0:
          ~. {: }: L. T. Z: u. v. {{}}
</code></pre>
<h2>Old J (e.g. TIO J)</h2>
<pre><code>0 0 0     &gt; + * - % ^ | ! ? &lt;. &lt;: &gt;. &gt;: +. +: *. *: %: ^. j. o. q: r.
0 _ _     -. -: E. i: p:
1 0 1     p..
1 0 _     { A.
1 1 0     p.
1 1 1     #.
1 1 _     C.
1 _ _     ;: &quot;. i. I.
2 _ 2     %.
_ 0 0     = &lt; ~. ~: {: }: ?. L.
_ 1 0     #:
_ 1 _     $ # |. |: {. }. &quot;: {::
_ _ _     , ; [ ] _: $. $: ,. ,: /: \: [: e. s: u: x: 0:
</code></pre>
<p>To use this table, find the desired rank <code>r</code> on the left hand side, then choose an appropriate verb <code>v</code> from the right hand side. E.g., if I need to vectorize a verb <code>v</code> at depth <code>2 _ 2</code>, then I find that rank on the left and choose <code>%.</code> from the right. Then I use <code>v&quot;%.</code> instead of <code>v&quot;2 _ 2</code>.</p>
</div>
<div id="pu2" class="pu"><h1>Know (and abuse) J's truthy/falsy (<a href="/questions/tagged/decision-problem" class="post-tag" title="show questions tagged &#39;decision-problem&#39;" rel="tag">decision-problem</a>)</h1>
<p>When truthy/falsy is not defined by the language spec, it is defined as the one that is accepted by an <code>if</code> statement. Truthy ones are those that make the <code>if</code> clause run, and falsy ones are the opposite.</p>
<p>Unlike APL (where only 1/0 are truthy/falsy respectively), J is quite liberal. J's <code>if.</code> clause accepts any array, and evaluates to falsy if and only if the array is nonempty and its first atom is a numeric zero. Any other arrays (including empty arrays, character or boxed arrays) are truthy.</p>
<p>Demonstration:</p>
<pre><code>f =: 3 : 0
if. 0         do. echo 'yes 0' end.
if. 1         do. echo 'yes 1' end.
if. 2         do. echo 'yes 2' end.
if. 0 1 2 3 4 do. echo 'yes 3' end.
if. 2 0 0 1 3 do. echo 'yes 4' end.
if. 0$0       do. echo 'yes 5' end.
if. 'abcd'    do. echo 'yes 6' end.
if. '';'def'  do. echo 'yes 7' end.
)
f ''
</code></pre>
<p>Output:</p>
<pre><code>yes 1
yes 2
yes 4
yes 5
yes 6
yes 7
</code></pre>
<p><code>yes 0</code> and <code>yes 3</code> were not printed because the array is nonempty and the first element is zero. Having zeros at any other positions does not affect the truthy/falsy interpretation. <a href="https://tio.run/##ddCxCoNAEITh3qeYQhjSHOudRjD4MMa7I6aIRSqfXo0YWC9x649/YJ/zHNE2cGgg2RANBN/zo0HoHyM4hTeECC9vNlOcmEIZe2KsMrKW7LpdJsYdOrI5l5hSd3L5u1Upw@7ee/6aqza80YfI1NS7uXy@RS4" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu3" class="pu"><h1>Miscellaneous ideas</h1>

<p><a href="https://codegolf.stackexchange.com/a/205354/78410">Cross-post of my own APL tip</a>, because APL and J are so closely related that the two can share many ideas.</p>

<h2>If you're facing <code>[:-~/</code>, use <code>_1#.</code> instead</h2>

<p>A common reason to use <code>-~/</code> is to reverse-subtract over a length-2 axis, e.g. given a 2-element array <code>x y</code>, compute <code>y-x</code>.</p>

<p>If this is the case, <code>_1#.</code> is an equivalent expression; just like <code>2#.x y</code> computes <code>2x+y</code>, <code>_1#.x y</code> computes <code>-x+y</code>. While <code>-~/</code> most likely requires the use of <code>[:</code> (capped fork) or <code>@</code> (atop), <code>_1#.</code> is likely to fit just well in trains as-is.</p>

<p>Note that, if you apply it to longer axis, <code>_1#.</code> gives you more similar result to <code>-/</code> (alternating sum), with negated result when the length is even.</p>

<h2>Construct a boolean square matrix where the border is ones/zeros and the interior is the opposite</h2>

<p>This is mainly for large fixed-size matrices, say 6 by 6.</p>

<p>The matrix</p>

<pre><code>1 1 1 1 1 1
1 0 0 0 0 1
1 0 0 0 0 1
1 0 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
</code></pre>

<p>can be generated by <code>+./~</code> -ing the boolean vector <code>1 0 0 0 0 1</code>. The shortest known way to generate that vector is <code>#:33</code>, so we can get the matrix above in just <strong>8 bytes</strong>:</p>

<pre><code>+./~#:33
</code></pre>

<p>If we're to put this in a train, a constant function <code>+./~@#:@33</code> and parenthesized noun left arg <code>(+./~#:33)</code> have equal length of <strong>10 bytes</strong>. The two forms have their own pros and cons: the former can be placed at the right end of a train, while the latter may serve better by not messing up with something that comes on its right (e.g. <code>33e.</code> is a syntax error).</p>

<p>We can also get negation of it at no extra cost, by swapping <code>+.</code> with <code>+:</code>! (Remember that J, like APL, has NOR <code>+:</code> and NAND <code>*:</code>; they are rarely needed, but definitely are a byte saver when we do need them.)</p>
</div>
<div id="pu4" class="pu"><h1>Tacit programming</h1>

<h2>Basics</h2>

<h3>Dyadic verb</h3>

<pre><code>x (F G H) y == (x F y) G (x H y)
x (F G) y == x F (G y)
x ([: G H) y == G (x H y)  NB. G is called monadically

NB. Verbs are grouped from the right by units of 3.
NB. For the following, think like G, I, K are replaced by the results of (x G y) etc.
NB. and then the sentence is run as usual.
x (F G H I J K) y == x (F (G H (I J K))) y
                  == x F ((x G y) H ((x I y) J (x K y)))

NB. Using conjunctions for dyadic verb
x F@G y == F (x G y)  NB. Atop; Same as x ([: F G) y; Consider as golfing alternatives
x F&amp;G y == (G x) F (G y)  NB. Compose; G is applied monadically to both arguments
</code></pre>

<h3>Monadic verb</h3>

<pre><code>(F G H) y == (F y) G (H y)
(G H) y == y G (H y)  NB. Note that this is different from APL
([: G H) y == G (H y)
(F G H I J K) y == (F (G H (I J K))) y
                == y F ((G y) H ((I y) J (K y)))
F@G y == F (G y)
</code></pre>

<h3>Misc</h3>

<pre><code>x&amp;F y == x F y
F&amp;y x == x F y
y F~ x == x F y
F~ y == y F y
</code></pre>

<h2>Tricks</h2>

<h3><code>(F x) G (H y)</code></h3>

<p>Tacit solution: <code>(G~F)~H</code>; depending on the actual verbs, consider rearranging the left and right arguments to remove <code>~</code>.</p>

<pre><code>x ((G~F)~H) y
x (G~F)~ (H y)
(H y) (G~F) x
(H y) G~ (F x)
(F x) G (H y)
</code></pre>

<h3>Monadic-Dyadic replacements</h3>

<pre><code>&gt;:y == 1+y
&lt;:y == 1-~y or _1+y
+:y == 2*y
-.y == 1-y
-:y == 2%~y
*:y == 2^~y
#.y == 2#.y
#.inv y == 2#.inv y  NB. #: doesn't work this way
{.y == 0{y
{:y == _1{y
}.y == 1}.y
+/y == 1#.y  NB. Vectors only
+/"1 y == 1#.y  NB. Higher-dimension arrays
</code></pre>
</div>
<div id="pu5" class="pu"><h1><code>x$y</code> does something different than you think</h1>

<p>Dyadic <code>$</code> is called <em>reshape</em>. If you're coming from APL, you'd know <code>⍴</code> under the same name which lists down all elements of <code>y</code> before creating the <code>x</code>-shaped array.</p>

<p>J handles it differently: it does not flatten <code>y</code>; instead it uses <code>y</code>'s items, or major cells, to fill in each cell of the <code>x</code>-shaped array. So the resulting shape becomes <code>x,}.$y</code>. It doesn't look very useful by this description.</p>

<p>There is one use case where this becomes useful in code golf: when <code>x</code> is a positive singleton. Then <code>x$y</code> acts like a <strong>take</strong> or <strong>repeated overtake</strong>.</p>

<ul>
<li>When <code>x &lt;: #y</code> (<code>x</code> is smaller than or equal to length of <code>y</code>), the result of <code>x $ y</code> is exactly same as <code>x {. y</code>, directly shaving one byte no matter what. The verb ranks are identical (<code>1 _</code>), so the replacement is safe even in a rank-sensitive context (e.g. <code>@</code>/<code>&amp;</code>).</li>
<li>When <code>x &gt; #y</code>, the result becomes <code>y</code> cyclically extended to length <code>x</code>. This is different from <code>x {. y</code> (which would fill the missing places with zeros/blanks), but it could have its own uses.</li>
</ul>

<p>Note that, in both cases, the result <em>is</em> equivalent to using the individual elements to fill in <code>x,}.$y</code>-shaped array.</p>
</div>
<div id="pu6" class="pu"><h1><code>&amp;</code> is your friend, use it wisely</h1>

<p><code>v</code> is a verb, <code>n</code> is a noun, <code>x</code> and <code>y</code> are left and right arguments, respectively.</p>

<h3>Monad <code>&amp;</code>: Introduce <code>~</code> inside adverb/conjunction chain</h3>

<p>An adverb/conjunction chain evaluates from the left. So something like <code>_2&amp;+/\&amp;.&gt;</code> won't work because it parses like <code>(_2&amp;+)/\&amp;.&gt;</code> while we want <code>_2&amp;(+/\)&amp;.&gt;</code>. In this case, swapping the left/right of <code>+/\</code> can save a byte, as in <code>+/\~&amp;_2&amp;.&gt;</code> because this one parses as <code>((+/\)~)&amp;_2&amp;.&gt;</code>. To see why this works:</p>

<pre><code>+/\~&amp;_2 y
is equivalent to
y +/\~ _2
is equivalent to
_2 +/\ y
is equivalent to
_2&amp;(+/\) y
</code></pre>

<h3>Dyad <code>&amp;</code>: Repeat <code>x</code> times</h3>

<p>Did you know that <a href="https://code.jsoftware.com/wiki/Vocabulary/ampm" rel="nofollow noreferrer">if you give a left argument <code>x</code> to <code>&amp;</code>, the function applies it <code>x</code> times to <code>y</code></a>? Quite a few challenges ask you to do certain operation <code>x</code> times. It is mainly achievable in two ways:</p>

<ul>
<li>Use the power operator <code>^:</code> without right operand</li>
</ul>

<p>If the operation is <code>v</code>, then <code>v^:</code> becomes an adverb train that, when given a left operand, becomes a monadic verb. So <code>v</code> is applied to <code>y</code>, <code>x</code> times.</p>

<pre><code>x(v^:)y
is equivalent to
(v^:x)y
</code></pre>

<ul>
<li>Use the dyadic <code>&amp;</code> as the outermost conjunction</li>
</ul>

<p>To use this, you need to identify a constant <code>n</code> and a dyadic verb <code>u</code>, so that either <code>n u y</code> or <code>y u n</code> is equivalent to <code>v</code>. Then you can write <code>n&amp;u</code> or <code>u&amp;n</code> to solve the entire task. This form is most effective when the choice of the constant is obvious, e.g. 3 in <code>3 u:</code> (convert chars to ASCII values).</p>

<p>Also, <code>u&amp;n</code> is slightly preferred over <code>n&amp;u</code> when the outermost structure of <code>u</code> is a conjunction or adverb (in which case <code>n&amp;u</code> should be <code>n&amp;(u)</code>; you can do <code>u~&amp;n</code> instead).</p>

<p>Note that you can place the dyadic <code>&amp;</code> anywhere in a train to achieve repeating arbitrary function to arbitrary argument, in the similar sense to dynamic <code>^:</code>.</p>
</div>
<div id="pu7" class="pu"><h1>Some (fairly) common tricks I've seen</h1>

<p>I'm sharing a few things that have come in handy for me. Basically all of these are tips I've received myself, but I don't have credits for most.</p>

<h3>Sum of a rank one array</h3>

<p>Instead of using <code>+/@:(FGH)</code> use <code>(1#.FGH)</code>. This means debase to base 1, which effectively means summing an array. Although it's longer than <code>+/</code>, it doesn't require a cap or composition, which often makes it much shorter than using <code>+/</code>.</p>

<h3>Counting trailing truths</h3>

<p>If you have a boolean list and you want to count the number of trailing truths, use <code>#.~</code>. <a href="https://codegolf.stackexchange.com/a/98765/42833">See here</a>. The <a href="https://codegolf.stackexchange.com/a/98764/42833">APL answer</a> provides a good explanation for how this works. Granted, this has only been helpful to me twice but I figured I'd share it anyways.</p>

<h3>Under (&amp;.)</h3>

<p>Not a specific trick, but just a general suggestion: the adverb <code>&amp;.</code>-under often leads to elegant and (more importantly) short solutions. Keep it in mind when you're golfing.</p>

<p>Often times it's useful for <a href="/questions/tagged/binary" class="post-tag" title="show questions tagged &#39;binary&#39;" rel="tag">binary</a> and other base conversion challenges, e.g. this code which removes the most significant bit from a number: <code>}.&amp;.#:</code> (convert to list of binary digits, remove the first digit, then undo the conversion to a list of binary digits and convert back to decimal). The straightforward solution is two more bytes: <code>#.@}.@#:</code>.</p>

<p>Under is also helpful for challenges where you need to work with decimal digits, since you can use <code>u&amp;.":</code>. For example, the short way miles gives to split to decimal digits uses under: <code>,.&amp;.":</code>.</p>

<p>A final example is finding the magnitude of a vector: <code>+/&amp;.:*:</code>, note that you need to collect all of the results from <code>*:</code>-square with <code>&amp;.:</code>-under since <code>*:</code>-square is rank zero.</p>
</div>
<div id="pu8" class="pu"><h3>Getting numbers from 0 to 4</h3>
<p>If there’s a restriction on using numbers in your code:</p>
<p><strong>0</strong> <code>%_</code>: one divided by infinity.<br />
<strong>1</strong> <code>#_</code>: how many infinities?<br />
<strong>2</strong> <code>#_ _</code>: two infinities.<br />
<strong>3</strong> <code>verb</code>: there’s a built-in.<br />
<strong>4</strong> <code>dyad</code>: another built-in.</p>
<h3>Getting numbers from 10 to 35</h3>
<p>Base-inifinity literals: <strong>11</strong>:<code>_bb</code>, <strong>26</strong>:<code>_bq</code> etc.</p>
</div>
<div id="pu9" class="pu"><h2>Using iteration to compute sequences</h2>

<p>Typically, solving an OEIS sequence challenge will require using one of the formulas given on its page. Some of these adapt well for J, and others not so much. Recursive formulas are straight-forward, however, iteration might not be simple. A pattern I've begun to use is</p>

<pre><code>(s(]f)^:[~]) n
          ]  Gets n
 s           The first value in the sequence
         ~   Commute the argument order, n is LHS and s is RHS
        [    Gets n
      ^:     Nest n times with an initial argument s
  (]f)         Compute f s
             Returns (f^n) s
</code></pre>

<p>where <code>s</code> is the first value in the sequence, <code>f</code> is a verb that will compute the next term given the previous term, and <code>n</code> is the zero-based index of the term you want to compute. This method relies on the fact that when computing the power of a dyad, the LHS is bound to the dyad to form a new monad, and that monad is nested on the initial value. The dyad given to the power adverb is a hook where <code>(]f)</code> is given the index <code>n</code> on the LHS and the value of a term in the sequence <code>s</code>. The hook will apply <code>f</code> on <code>s</code> as a monad, and then ignore <code>n</code> to return the result of <code>f s</code>.</p>

<h2>Standard library</h2>

<p>Sometimes, you might find that J will have support for a verb in its <a href="http://www.jsoftware.com/help/user/library.htm" rel="nofollow noreferrer">standard library</a>. For example, most of the bitwise integer operations are bound to names which are shorter than using the primitive call.</p>

<pre><code>AND =: (17 b.) NB. it is actually '$:/ :(17 b.)'
</code></pre>

<p>Date and time builtins are also available.</p>

<h2>Ranges</h2>

<p>If you have a set of values <code>[a, b, c]</code> and you want to form a range based on their product like <code>[0, 1, 2, ..., a*b*c-1]</code>, the typical approach would be to find their product and then form a range which might be <code>[:i.*/</code> which costs 6 bytes. A shorter way is <code>,@i.</code> for 4 bytes since <code>i.</code> can form multidimensional arrays while still counting up, and flattening it will produce an equivalent range.</p>

<h1>Printing continuously</h1>

<p>A tacit way to print a value and continue to use it without an explicit loop is <code>([echo)</code> for a monadic case. <code>echo</code> is a verb in the standard library that prints its contents to <code>stdout</code> in the same format used in the interpreter. The hook then passes the same input value out using the left <code>[</code> verb.</p>

<h1>Base 10 digits of an integer</h1>

<p>The standard way of acquiring the base 10 digits of an integer is <code>10#.inv]</code> which costs 8 bytes, too much! An alternative is to convert it to a string and parse it at rank 0 <code>"."0@":</code> which saves a byte, but an even better way is <code>,.&amp;.":</code> which saves another byte making the final cost 6 bytes instead of 8.</p>
</div>
<div id="pu10" class="pu"><h1><a href="http://www.jsoftware.com/docs/help602/user/script_strings.htm" rel="nofollow"><code>strings</code></a> library: golfing tips</h1>

<p>The strings library is vastly helpful for doing anything with string manipulation. Sure, it takes <code>include'strings'</code> (which is very costly, considering J), but you may at times reap the benefits.</p>

<h2><code>stringreplace</code></h2>

<p>Find yourself using string replace? Observe that <code>A stringreplace B</code> is the same as <code>B rplc A</code>.</p>

<p>In fact, this is how <code>rplc</code> is implemented:</p>

<pre><code>   rplc
 stringreplace~
</code></pre>

<h2><code>cuts</code></h2>

<p>The verb <code>cuts</code> provides thus:</p>

<blockquote>
<pre>cut y at x (conjunction)
string (verb cuts n) text
  n=_1  up to but not including string
  n= 1  up to and including string
  n=_2  after but not including string
  n= 2  after and including string</pre>
</blockquote>

<p>So it's really slicing a string.</p>
</div>
<div id="pu11" class="pu"><p>Consider using <a href="http://www.jsoftware.com/help/phrases/explicit_def.htm" rel="noreferrer">explicit definition</a> instead of writing a tacit verb; sure the <code>3 :'</code> and <code>'</code> cost 5 bytes, but you can save a lot of <code>@</code>, <code>@:</code> and <code>[:</code> that way.</p>
</div>
<div id="pu12" class="pu"><p>The most important thing when golfing in J is to not only understand the problem, but to reduce the problem to a series of array transformations. You need to understand this way of thinking to have any success with J code.</p>

<p>For example, a recent challenge asked to solve the <em><a href="https://codegolf.stackexchange.com/q/3059/134">largest subarray problem</a>.</em> The stock algorithm to solve this problem is Kadane's algorithm has the following informal description:</p>

<blockquote>
  <p>Go through the array and at each position and find the sum of the largest subarray ending here, which is the maximum of 0 or the value at the current index plus the sum of the largest subarray ending at the previous position. Compute the maximum of these subarrays as you go to find the largest subarray in the entire array.</p>
</blockquote>

<p>A translation into imperative code is straightforward:</p>

<ol>
<li>let A be the input array.</li>
<li><em>h</em> ← <em>m</em> ← <em>i</em> ← 0.</li>
<li><strong>if</strong> <em>i</em> &ge; len(A) <strong>return</strong> <em>m</em>.</li>
<li><em>h</em> ← max(0, <em>h</em> + A[<em>i</em>]).</li>
<li><em>m</em> ← max(<em>m</em>, <em>h</em>).</li>
<li><em>i</em> ← <em>i</em> + 1.</li>
<li><strong>goto</strong> 3.</li>
</ol>

<p>This algorithms seems complicated for J at a glance as there is an explicit loop that doesn't look like a reduction at first. If you realize what the algorithm is doing you can untangle the individual steps and see that it actually performs two simple array operations:</p>

<ol>
<li><em>Scan</em> through the array to compute the lengths of the largest subarrays ending at each index.</li>
<li><em>Reduce</em> these lengths with the max function to find the maximum.</li>
</ol>

<p>Now these two steps are very easy to implement in J. Here is a translation:</p>

<ol>
<li><code>(0 &gt;. +)/\. y , 0</code> – This step operates from the other end of the array to better fit J's paradigm. <code>0 &gt;. +</code> is tacit for <code>0 &gt;. x + y</code>.</li>
<li><code>&gt;./ y</code></li>
</ol>

<p>Put together, we get a very terse implementation of the algorithm:</p>

<pre><code>&gt;./ (0 &gt;. +)/\. y , 0
</code></pre>

<p>If you learn this way of approaching the implementation of algorithms, your solutions will be as terse as this code.</p>

<p>Here are some tricks I accumulated over time. This list will be expanded as I get more knowledge in J golfing.</p>

<ul>
<li>Learn the dictionary. It contains a lot of really obscure verbs that don't make any sense until you see how useful they are. For instance, monadic <code>=</code> is strange at first but is very useful in ASCII art challenges.</li>
<li>Use dyadic <code>&amp;</code> in tacit contexts when you want a power conjunction. The vocabulary suggests <code>u@[&amp;0</code> as a tacit replacement to <code>4 : 'u^:x y</code> and so do I.</li>
<li>In many cases you can avoid a <code>[:</code> or <code>@:</code> in a sequence like <code>u@v</code> by choosing a variant of <code>u</code> that has a left argument. For instance, to drop the first item of the result of <code>v</code>, use <code>1}.v</code> instead of <code>[:}.v</code> if <code>}.@v</code> isn't possible for some reason.</li>
<li><code>] v</code> is often shorter than <code>v@]</code> if you want to use monadic <code>v</code> in a dyadic context. This comes in useful especially when <code>v</code> is a long train of verbs.</li>
<li>Sometimes you can write <code>m (n v w) y</code> instead of <code>(n v m&amp;w) y</code>. This may make it possible to avoid spaces and parentheses.</li>
<li><code>#\</code> instead of <code>&gt;:@i.@#</code>.</li>
<li><code>u &amp;. v</code> is useful when <code>v</code> has an obverse. When not, you might want to use <code>[: vinv u &amp; v</code> or <code>u &amp; (v :. vinv)</code> instead.</li>
<li>Understand rank and how to use it. Try to fiddle around with the rank conjunction until you get something that fits. It helps understanding how rank influences your code.</li>
<li><code>^:_</code> is extremely useful for algorithms where you want to reach convergence, like a flood-fill or simulations.</li>
<li>Know your standard library. It contains very useful functions that save you tons of characters.</li>
<li>The copulæ <code>=.</code> and <code>=:</code> can be embedded anywhere in a phrase. Use this to make one-liners where tacit notation isn't enough.</li>
<li>Use monadic <code>,</code> instead of multiple reductions when reducing multi-dimensional arrays.</li>
<li>Understand what phrases are supported by special code when the challenge imposes runtime boundaries. Some useful things operate in O(<em>n</em>) instead of O(<em>n</em><sup>2</sup>) counter-intuitively.</li>
<li>Boxes are useful for trees.</li>
</ul>
</div>
<div id="pu13" class="pu"><p>There are a number of subtleties to squeezing out the last few characters in J. For the following, assume that each capital letters is a primitive verb (i.e. I am removing the spaces that would otherwise be required to delimit names).</p>

<ul>
<li><p>When you have a train going, and you need to apply a function atop another partway through, <code>([:FLGR)</code> and <code>(LF@:GR)</code> have the same number of characters, but <code>(LF@GR)</code> saves one. If the frame of G is greater than or equal to the monad rank of F, this is a valid transformation. Notably, all trains have infinite rank, as do <code>, ,. ,: ~. /: \: [ ]</code> and most uses of <code>#</code> and <code>|.</code>.</p></li>
<li><p>If you have to pick strings out of a list, and these strings have no spaces, use <code>&gt;i{ab`cd`ef</code>. It's dirty, but it saves characters for each new string you have to deal with, unless you're just pulling single characters, and even then the charlist has to be length 4 to be shorter. What's happening is that undefined names are treated as references to verbs, and when you take the gerunds of those verbs you get a boxed string of the name. Any names that are already defined as having type noun, adverb, or conjunction cannot be used in this fashion, because those names get resolved before <code>`</code> can have at them.</p></li>
<li><p>If you're lucky enough to have an expression to work with and not just a tacit verb, it's almost always worth it to assign any bits you reuse to variables, be they nouns, verbs, or adverbs. The parens will sometimes pay themselves back by fitting right into where you had spaces before, and most such definitions are worth it if they're reused even once more.</p></li>
<li><p>Conjunctions like <code>(FGH)^:(u`v`w)</code> can be rewritten <code>u`v`w(FGH^:)</code>. This works for any length of train, even 1, though you only save anything if this trick removes parens from the right argument. This trick only works when you preload the left operand. (Have no idea what just happened? Look up 'tacit adverbs', and study the <a href="http://www.jsoftware.com/help/dictionary/dicte.htm">Parsing and Execution</a> section of the J Dictionary.)</p></li>
<li><p>Don't use <code>a.&amp;i.</code>, use <code>u:</code>! <code>{&amp;a.</code> and <code>3&amp;u:</code> are equivalent on length, though, and the former might be more useful in a conjunction (depending on the conjunction).</p></li>
<li><p>Things like <code>(2%~F)</code> and <code>(F%2:)</code> are equivalent in length. This is useful because sometimes, depending on what the rest of your train looks like, you can restructure it with <code>@</code> tricks as written in the first point, to save some desperate characters. (And of course, if <code>F</code> is <code>]</code> and the train is a monad, using <code>%&amp;2</code> saves a char, duh.)</p></li>
<li><p>Hook-like trains with <code>]</code> or <code>[</code> as the leftmost verb, e.g. <code>(]FGH)</code>.</p>

<ul>
<li><code>]</code> lets you break up a dyadic application and use the right argument only. (Swap to left with <code>(]FGH)~</code>, at a penalty of at least 1 character, maybe more.) Saves a char over <code>(FGH)@]</code>, and is very handy in gerunds!</li>
<li><code>[</code> in a hook applied monadically allows you to do something for the side effects on the right side, then return the argument again. Most common usage is with <code>1!:2</code>, possibly with formatting junk.</li>
</ul></li>
<li><p>I/O sucks. Speed up the process by making loops out of everything you can. <code>1!:1</code> has rank <code>0</code>, and both of <code>1!:2 3</code> have rank <code>_ 0</code>, for example, so utilise this by making arrays of 1s and run <code>1!:1</code> directly over them. Note that <code>".</code> also has rank 1, so you can usually just put that directly after <code>1!:1</code>, too, and not have to attach it via <code>@</code> or rank shenanigans.</p></li>
<li><p>It's not easy to find places to put this, but <code>::</code> can be useful.</p>

<ul>
<li><p><code>::]^:_</code> is a particularly powerful combination, for example, that lets you do something dangerous until you can't do it anymore. (Subject to the usual <code>^:_</code>-as-a-loop caveats.)</p></li>
<li><p>This also lets you use <code>{</code> on lists that don't have the desired index, because it throws a domain error when that happens. Useful to e.g. take the head of a list only if it exists (try using <code>::]</code> to return the empty list, or <code>::_1:</code> to return an error code, and so on).</p></li>
</ul></li>
<li><p><code>]`($:@u)@.v</code> can usually be made shorter than <code>u^:v^:_</code>, especially on definitions of <code>u</code> and <code>v</code> that can be played around with. A similar case holds for the conditional-like <code>u^:(1-v)</code> vs. <code>]`u@.v</code>. Consider your options, especially when you have lots of named verbs floating about. It's also a little more flexible, but remember, if using <code>$:</code>, there is a recursion depth that it's easy to bump up against. (Usually something like 1800 iterations?)</p></li>
</ul>
</div>
<div id="pu14" class="pu"><p><strong>Input</strong></p>

<p><code>1!:1[1</code> will take one line of input terminated by pressing the enter key.</p>

<p><code>1!:1[3</code> will take a number of lines of input (terminated by Ctrl-D on my Mac, Ctrl-C on Windows).</p>

<p>If you're trying to input numbers, using <code>".</code> will evaluate the string and return a list of numbers ready to be manipulated. If you're taking in one number but need to operate on the digits individually, <code>".,.</code> (thanks to Jan Dvorak's comment for this) or <code>"."0</code> will split the string into separate digits:</p>

<pre><code>   "."0[1!:1[1
12345
1 2 3 4 5

   ".,.1!:1[1
12345
1 2 3 4 5
</code></pre>

<p>If you're reading in strings, the shortest way to get a boxed list of separate strings is to use <code>;:</code>. This works best for space separated strings:</p>

<pre><code>   ;:1!:1[1
hello world
┌─────┬─────┐
│hello│world│
└─────┴─────┘
</code></pre>
</div>
<div id="pu15" class="pu"><p><strong>Be wary of using loops.</strong></p>

<p>While J has looping structures (<code>for. do. end.</code>, <code>while. do. end.</code> and variations), if you find yourself using them there's a possibility that your algorithm is not playing to J's golfing strengths and that there are character savings to be made.</p>

<p><code>^:</code> the power conjunction is your friend. To execute a verb <code>x</code> times:</p>

<pre><code>verb^:x
</code></pre>

<p>If you need the result of each iteration in a list:</p>

<pre><code>verb^:(i.x)
</code></pre>

<p>You can also use <code>^:</code> to execute a verb conditionally:</p>

<pre><code>  +:^:(3&lt;])"0[ 1 2 3 4 5 6
1 2 3 8 10 12
</code></pre>

<p>Double <code>+:</code> if <code>^:</code> the item is greater than 3 <code>3&lt;]</code> (the <code>"0</code> changes the rank of the verb so it works an item at a time).</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/6596/">6596</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




