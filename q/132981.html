<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::132981</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td></td><td>180329T181850Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/160712#160712">qwr</a></td></tr>
<tr d-ix="1"><td>nan</td><td></td><td>210920T132614Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/235553#235553">ecm</a></td></tr>
<tr d-ix="2"><td>nan</td><td>Useful onebyte instructions</td><td>240909T151426Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/275437#275437">qwr</a></td></tr>
<tr d-ix="3"><td>nan</td><td></td><td>240908T012122Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/275411#275411">qwr</a></td></tr>
<tr d-ix="4"><td>nan</td><td>Use 32bit x86 instead of 64bit x8664</td><td>240907T055727Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/275400#275400">qwr</a></td></tr>
<tr d-ix="5"><td>nan</td><td></td><td>230518T214846Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/261057#261057">l4m2</a></td></tr>
<tr d-ix="6"><td>nan</td><td></td><td>190312T184356Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/181407#181407">640KB</a></td></tr>
<tr d-ix="7"><td>nan</td><td></td><td>210218T035601Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/219283#219283">EasyasPi</a></td></tr>
<tr d-ix="8"><td>nan</td><td></td><td>221221T102102Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/255818#255818">l4m2</a></td></tr>
<tr d-ix="9"><td>nan</td><td>"Free bypass" If you already have an instruction with an immediate on a register that you only care about the low part of</td><td>220322T075050Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/245416#245416">m90</a></td></tr>
<tr d-ix="10"><td>nan</td><td>Use specialcase shortform encodings for AL/AX/EAX</td><td>180329T204407Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/160739#160739">Peter Co</a></td></tr>
<tr d-ix="11"><td>nan</td><td></td><td>220123T082031Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/241625#241625">m90</a></td></tr>
<tr d-ix="12"><td>nan</td><td>Entry point doesn't necessarily have to be first byte of submission</td><td>210127T212048Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/218097#218097">640KB</a></td></tr>
<tr d-ix="13"><td>nan</td><td></td><td>210616T224202Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/229867#229867">EasyasPi</a></td></tr>
<tr d-ix="14"><td>nan</td><td></td><td>210326T181723Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/221430#221430">Noah</a></td></tr>
<tr d-ix="15"><td>nan</td><td></td><td>180518T050305Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/165020#165020">Peter Co</a></td></tr>
<tr d-ix="16"><td>nan</td><td></td><td>210201T042639Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/218351#218351">EasyasPi</a></td></tr>
<tr d-ix="17"><td>nan</td><td></td><td>210128T213521Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/218188#218188">EasyasPi</a></td></tr>
<tr d-ix="18"><td>nan</td><td></td><td>210127T231808Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/218104#218104">EasyasPi</a></td></tr>
<tr d-ix="19"><td>nan</td><td></td><td>201207T151942Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/216076#216076">anatolyg</a></td></tr>
<tr d-ix="20"><td>nan</td><td></td><td>170718T100833Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/133048#133048">anatolyg</a></td></tr>
<tr d-ix="21"><td>nan</td><td></td><td>200520T120134Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/205020#205020">Kamila S</a></td></tr>
<tr d-ix="22"><td>nan</td><td>Try XLAT for byte memory access</td><td>200212T153212Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/199390#199390">640KB</a></td></tr>
<tr d-ix="23"><td>nan</td><td>Try AAM or AAD for byte division operations</td><td>200212T152834Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/199389#199389">640KB</a></td></tr>
<tr d-ix="24"><td>003</td><td>To copy a 64bit register</td><td>190822T161356Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/190636#190636">Peter Co</a></td></tr>
<tr d-ix="25"><td>nan</td><td>Save on jmp bytes by arranging into if/then rather than if/then/else</td><td>190517T170122Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/185740#185740">Daniel S</a></td></tr>
<tr d-ix="26"><td>nan</td><td></td><td>180406T195922Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/161497#161497">qwr</a></td></tr>
<tr d-ix="27"><td>128</td><td>Subtract 128 instead of add</td><td>180518T054321Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/165022#165022">l4m2</a></td></tr>
<tr d-ix="28"><td>nan</td><td></td><td>180414T161507Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/162248#162248">qwr</a></td></tr>
<tr d-ix="29"><td>nan</td><td></td><td>171111T024026Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/147775#147775">peter fe</a></td></tr>
<tr d-ix="30"><td>nan</td><td>The loop and string instructions are smaller than alternative instruction sequences. Most useful is loop <label> which is smaller than the two instruction sequence dec ECX and jnz <label></td><td>170718T174647Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/133095#133095">user2301</a></td></tr>
<tr d-ix="31"><td>nan</td><td></td><td>170717T220148Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/132985#132985">ბიმო</a></td></tr>
<tr d-ix="32"><td>nan</td><td></td><td>180329T174303Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/160702#160702">qwr</a></td></tr>
<tr d-ix="33"><td>nan</td><td>To add or subtract 1</td><td>170718T174137Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/133094#133094">user2301</a></td></tr>
<tr d-ix="34"><td>nan</td><td></td><td>180329T180504Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/160708#160708">qwr</a></td></tr>
<tr d-ix="35"><td>nan</td><td></td><td>180329T175749Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/160707#160707">qwr</a></td></tr>
<tr d-ix="36"><td>nan</td><td>You can fetch sequential objects from the stack by setting esi to esp</td><td>171114T002925Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/147968#147968">peter fe</a></td></tr>
<tr d-ix="37"><td>001</td><td>In a lot of cases</td><td>170717T214734Z</td><td><a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/132983#132983">Govind P</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><code>lea</code> for multiplications by particular small constants</h1>
<p>This is probably one of the first things one learns about x86, but I leave it here as a reminder. <code>lea</code> can be used to do multiplication by 2, 3, 5, or 9 (and store in a new register) in 3 bytes, optionally adding an offset for 1 additional byte. All examples assume 32-bit mode.</p>
<p>For example, to calculate <code>ebx = 9 * eax</code> in 3 bytes:</p>
<pre><code>8d 1c c0                lea    ebx, [eax, 8*eax]
</code></pre>
<p><code>ebx = 9*eax + 3</code> in 4 bytes:</p>
<pre><code>8d 5c c0 03             lea    ebx, [eax + 8*eax + 3]
</code></pre>
<p>For multiplication by 2, it saves 1 byte compared to <code>shl</code>/<code>mov</code>:</p>
<pre><code>8d 1c 00                lea    ebx, [eax + eax]

89 c3                   mov    ebx, eax
d1 e3                   shl    ebx, 1
</code></pre>
<p>Of course, if you can overwrite the original register, you only need <code>shl</code>.</p>
<p>Interestingly, <code>lea</code> multiplication by 4 or 8 isn't size efficient at all because it ends up using 0x00000000 as an absolute displacement.</p>
<pre><code>8d 1c 85 00 00 00 00    lea     ebx, [4*eax]

89 c3                   mov     ebx, eax
c1 e3 02                shl     ebx, 2
</code></pre>
<p>If you are using eax and okay with clobbering your original register, maybe you can use <code>xchg</code> with eax which is a single byte.</p>
<p>More info on x86's addressing modes:
<a href="https://blog.yossarian.net/2020/06/13/How-x86_64-addresses-memory" rel="nofollow noreferrer">https://blog.yossarian.net/2020/06/13/How-x86_64-addresses-memory</a></p>
</div>
<div id="pu1" class="pu"><h1>Skipping instructions</h1>
<p>Skipping instructions are opcode fragments that combine with one or more subsequent opcodes. The subsequent opcodes can be used with a different entrypoint than the prepended skipping instruction. Using a skipping instruction instead of an unconditional short jump can save code space, be faster, and set up incidental state such as <code>NC</code> (No Carry).</p>
<p>My examples are all for 16-bit Real/Virtual 86 Mode, but a lot of these techniques can be used similarly in 16-bit Protected Mode, or 32- or 64-bit modes.</p>
<p>Quoting <a href="https://pushbx.org/ecm/doc/acegals.htm#skipping" rel="nofollow noreferrer">from my ACEGALS guide</a>:</p>
<blockquote>
<h2>11: Skipping instructions</h2>
<p>The constants __TEST_IMM8, __TEST_IMM16, and __TEST_OFS16_IMM8 are defined to the respective byte strings for these instructions. They can be used to skip subsequent instructions that fit into the following 1, 2, or 3 bytes. However, note that they modify the flags register, including always setting NC. The 16-bit offset plus 16-bit immediate test instruction is not included for these purposes because it might access a word at offset 0FFFFh in a segment. Also, the __TEST_OFS16_IMM8 as provided should only be used in 86M, to avoid accessing data beyond a segment limit. After the db instruction using one of these constants, a parenthetical remark should list which instructions are skipped.</p>
</blockquote>
<p>The 86 Mode defines <a href="https://hg.pushbx.org/ecm/lmacros/file/323cc150061e/lmacros1.mac#l246" rel="nofollow noreferrer">in lmacros1.mac 323cc150061e (2021-08-29 21:45:54 +0200)</a>:</p>
<pre><code>%define __TEST_IMM8 0A8h                        ; changes flags, NC
%define __TEST_IMM16 0A9h                       ; changes flags, NC
                                        ; Longer NOPs require two bytes, like a short jump does.
                                        ; However they execute faster than unconditional jumps.
                                        ; This one reads random data in the stack segment.
                                        ;  (Search for better ones.)
%define __TEST_OFS16_IMM8 0F6h,86h              ; changes flags, NC
</code></pre>
<p>The <code>0F6h,86h</code> opcode in 16-bit modes is a <code>test byte [bp + disp16], imm8</code> instruction. I believe I am not using this one anywhere actually. (A stack memory access might actually be slower than an unconditional short jump, in fact.)</p>
<p><code>0A8h</code> is the opcode for <code>test al, imm8</code> in any mode. The <code>0A9h</code> opcode changes to an instruction of the form <code>test eax, imm32</code> in 32- and 64-bit modes.</p>
<p>Two use cases <a href="https://hg.pushbx.org/ecm/ldosboot/file/07f4ba0ef8cd/boot32.asm" rel="nofollow noreferrer">in ldosboot boot32.asm 07f4ba0ef8cd (2021-09-10 22:45:32 +0200)</a>:</p>
<p>First, chain two different entrypoints for a common function which both need to initialise a byte-sized register. The <code>mov al, X</code> instructions take 2 bytes each, so <code>__TEST_IMM16</code> can be used to skip one such instruction. (This pattern can be repeated if there are more than two entrypoints.)</p>
<pre><code>error_fsiboot:
        mov al,'I'

        db __TEST_IMM16 ; (skip mov)
read_sector.err:
        mov al, 'R'     ; Disk 'R'ead error

error:
</code></pre>
<p>Second, a certain entrypoint that needs two bytes worth of additional teardown but can otherwise be shared with the fallthrough case of a later code part.</p>
<pre><code>                mov bx, [VAR(para_per_sector)]
                sub word [VAR(paras_left)], bx
                jbe @F          ; read enough --&gt;

                loop @BB
                pop bx
                pop cx

                call clust_next
                jnc next_load_cluster
                inc ax
                inc ax
                test al, 8      ; set in 0FFF_FFF8h--0FFF_FFFFh,
                                ;  clear in 0, 1, and 0FFF_FFF7h
                jz fsiboot_error_badchain
                db __TEST_IMM16
@@:
                pop bx
                pop cx
                call check_enough
                jmp near word [VAR(fsiboot_table.success)]
</code></pre>
<p>Here's a use case <a href="https://hg.pushbx.org/ecm/inicomp/file/4d568330924c/lz4.asm#l491" rel="nofollow noreferrer">in inicomp lz4.asm 4d568330924c (2021-09-03 16:59:42 +0200)</a> where we depend on the <code>test al, X</code> instruction clearing the Carry Flag:</p>
<pre><code>.success:
        db __TEST_IMM8                  ; (NC)
.error:
        stc
        retn
</code></pre>
<p>Further, here's a very similar use of a skipping instruction in <a href="http://adoxa.altervista.org/doslfn/" rel="nofollow noreferrer">DOSLFN Version 0.41c (11/2012)</a>. Instead of <code>test ax, imm16</code> they're using <code>mov cx, imm16</code> which has no effect on the status flags but clobbers the <code>cx</code> register instead. (Opcode <code>0B9h</code> is <code>mov ecx, imm32</code> in non-16-bit modes, and writes to the full <code>ecx</code> or <code>rcx</code> register.)</p>
<pre><code>;THROW-Geschichten... [english: THROW stories...]
SetErr18:
        mov     al,18
        db      0B9h            ;mov cx,nnnn
SetErr5:
        mov     al,5
        db      0B9h            ;mov cx,nnnn
SetErr3:
        mov     al,3
        db      0B9h            ;mov cx,nnnn
SetErr2:
        mov     al,2
SetError:
</code></pre>
<p>Finally, the FAT12 boot loader released on 2002-11-26 as fatboot.zip/fat12.asm by Chris Giese (which I based my FAT12, FAT16, and FAT32 loaders on) uses <code>cmp ax, imm16</code> as a skipping instruction <a href="https://hg.pushbx.org/ecm/ldosboot/file/13cf6bb0b5f5/boot.asm#l215" rel="nofollow noreferrer">in its error handler</a>. This is similar to my lDOS boot error handlers but <code>cmp</code> leaves an indeterminate Carry Flag state rather than always setting up No Carry. Also note the comment referring to &quot;Microsoft's Color Computer BASIC&quot;:</p>
<pre><code>    mov al,'F'  ; file not found; display blinking 'F'

; 'hide' the next 2-byte instruction by converting it to CMP AX,NNNN
; I learned this trick from Microsoft's Color Computer BASIC :)
    db 3Dh
disk_error:
    mov al,'R'  ; disk read error; display blinking 'R'
error:
</code></pre>
</div>
<div id="pu2" class="pu"><h1>Useful one-byte instructions</h1>
<p>WIP. Most are listed <a href="http://xxeo.com/single-byte-or-small-x86-opcodes" rel="nofollow noreferrer">here</a>. This answer will assume x86 (32-bit), with some notes for x86-64 (<a href="https://codegolf.stackexchange.com/a/275400/17360">usually more bytes</a>). I checked these with Compiler Explorer (godbolt.org) running NASM.</p>
<h2>Stack Operations</h2>
<ul>
<li><code>PUSH</code>/<code>POP</code>: push/pop any of the eight +rd registers: EAX, ECX, EDX, EBX, ESI, EDI, EBP, ESP.
<ul>
<li>In 64-bit mode, you can't use registers R8-R15. <a href="https://codegolf.stackexchange.com/a/218188/17360">Avoid registers that need prefixes</a></li>
</ul>
</li>
<li><code>PUSHAD</code>/<code>POPAD</code>: push/pop all of the 8 general-purpose registers.
<ul>
<li>*Not available in 64-bit mode!</li>
</ul>
</li>
</ul>
<h2>Register / Integer Operations</h2>
<ul>
<li><code>CWDE</code>: EAX := sign-extend of AX.
<ul>
<li>In 64-bit mode, <code>CDQE</code> : RAX := sign-extend of EAX takes an extra REX.W prefix byte.</li>
</ul>
</li>
<li><code>CDQ</code>: EDX:EAX := sign-extend of EAX. If EAX doesn't have sign bit, this is useful to zero EDX.
<ul>
<li>In 64-bit mode, <code>CQO</code>: RDX:RAX := sign-extend of RAX takes an extra byte.</li>
</ul>
</li>
<li><code>INC</code>/<code>DEC</code>: increment/decrement any of the +rd registers.
<ul>
<li>In 64-bit mode, takes 2 bytes for 32-bit register, 3 bytes for 64-bit register</li>
</ul>
</li>
<li><code>XCHG</code>: Exchange any +rd register with EAX. Other sizes take 2 bytes.
<ul>
<li>In 64-bit mode, the default operation size is still 32 bits. 64-bit exchange with RAX takes an extra byte.</li>
</ul>
</li>
</ul>
<h2>String Operations</h2>
<ul>
<li><code>MOVSB</code>/<code>MOVSD</code>: Move byte/dword from address ESI to EDI, then inc/dec both registers based on DF.</li>
<li><code>LODSB</code>/<code>LODSD</code>: Load byte/dword from address ESI into AL/EAX, and inc/dec ESI based on DF direction flag. This is very useful in iterating over strings/arrays.</li>
<li><code>STOSB</code>/<code>STOSD</code>: Store byte/dword from AL/EAX into address EDI, then inc/dec EDI based on DF.</li>
<li><code>CMPSB</code>/<code>CMPSD</code>: Compare byte/dword in address ESI with byte/dword in address EDI, set flags according to result, and inc/dec registers.</li>
<li><code>SCASB</code>/<code>SCASD</code>: Compare AL/EAX with byte/dword at EDI, set flags according to result, and inc/dec EDI.</li>
</ul>
<p>Word (16-bit) versions of the instructions take 2 bytes. In 64-bit mode, defaults to 64-bit operands, and qword versions also take 2 bytes.</p>
<h2>Opcode Prefixes (technically one byte)</h2>
<ul>
<li><code>REP</code>: Repeat the following string instruction, decrementing counter ECX until ECX = 0. REP can only prefix <code>MOVS</code>, <code>LODS</code>, and <code>STOS</code>.</li>
<li><code>REPZ</code>/<code>REPNZ</code>: Repeat the following string instruction, decrementing ECX, terminating when ECX = 0 OR termination condition (ZF = 0 / ZF = 1). Can only prefix  <code>CMPS</code> (find (non-)matching bytes) and <code>SCAS</code> (find (non-)matching AL).</li>
</ul>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.felixcloutier.com/x86/loop:loopcc" rel="nofollow noreferrer"><code>LOOP</code></a> according to ECX</h1>
<p>This is the <a href="https://stackoverflow.com/questions/35742570/why-is-the-loop-instruction-slow-couldnt-intel-have-implemented-it-efficiently">famously slow</a> instruction that decrements CX/ECX/RCX as a counter, then short jumps if not zero, all in 2 bytes! <code>LOOPcc</code> variants also check ZF. Compare this to regular short branching, which takes 3 bytes:</p>
<pre><code>E2 cb   loop    label   ; cb is rel8
</code></pre>
<pre><code>4A      dec     ecx     ; sets ZF
75 cb   jnz     label   
</code></pre>
<h1><a href="https://www.felixcloutier.com/x86/jcc" rel="nofollow noreferrer"><code>JECXZ</code></a> according to ECX</h1>
<p><code>JCXZ</code>/<code>JECXZ</code>/<code>JRCXZ</code> are weird instructions in the <code>Jcc</code> family that jump short based on if CX/ECX/RCX is 0, in 2 bytes. If you had an instruction before that sets ZF such as <code>dec</code>, you could use a standard <code>JZ</code>.</p>
</div>
<div id="pu4" class="pu"><h1>Use 32-bit x86 instead of 64-bit x86-64, if you can</h1>
<p>This is a bit silly, but many code golf challenges only require 32-bit inputs, and 32-bit programs execute just fine on x86-64 processors (<a href="https://stackoverflow.com/questions/32868293/x86-32-bit-opcodes-that-differ-in-x86-x64-or-entirely-removed">almost all instructions work</a>, <a href="https://www.tortall.net/projects/yasm/manual/html/arch-x86-registers.html" rel="nofollow noreferrer">you can't use the lower 8 bits SIL, DIL, SPL, BPL</a>). Assemble with <code>nasm -f elf32</code> and link with <code>ld -m elf_i386</code>. You avoid extra bytes from REX prefixes without even thinking about it. MUL can multiply two 32-bit numbers and puts the full result in EDX:EAX, and DIV can divide a 64-bit dividend by r/m32.</p>
<h1>...or 16-bit DOS, if you can</h1>
<p>NASM can assemble raw COM files with <code>-f bin</code>. You'll need an emulator like <a href="https://github.com/dmsc/emu2" rel="nofollow noreferrer">emu2</a> or DOSBox to run these, so it won't run natively on a modern system, which is half the fun of x86.</p>
</div>
<div id="pu5" class="pu"><h1>AND to clear memory</h1>
<pre><code>0:  c7 01 00 00 00 00       mov    DWORD PTR [ecx],0x0
6:  31 c0 89 01             xor    eax,eax / mov DWORD PTR [ecx],eax
a:  83 21 00                and    DWORD PTR [ecx],0x0 
</code></pre>
</div>
<div id="pu6" class="pu"><h1>CPU registers and flags are in known startup states</h1>
<p>For a full/standalone program, we can assume that the CPU is in a known and documented default state based on platform and OS.</p>
<p>For example:</p>
<p>DOS
<a href="http://www.fysnet.net/yourhelp.htm" rel="nofollow noreferrer">http://www.fysnet.net/yourhelp.htm</a></p>
<p>Linux x86 ELF
<a href="http://asm.sourceforge.net/articles/startup.html" rel="nofollow noreferrer">http://asm.sourceforge.net/articles/startup.html</a> - in <code>_start</code> in a static executable, most registers are zero other than the stack pointer, to avoid leaking info into a fresh process.  <code>pop</code> will load <code>argc</code> which is a small non-negative integer, <code>1</code> if run normally from a shell with no args.</p>
<p>Same applies for x86-64 processes on Linux.</p>
</div>
<div id="pu7" class="pu"><h1>Use a good assembler</h1>
<p>There are dozens of x86 assemblers out there, and they are <strong>not</strong> created equal.</p>
<p>Not only can a bad assembler be painful to use, but <strong>they might not always output the most optimal code.</strong></p>
<p>Most x86 instructions have multiple valid encodings, some shorter than others.</p>
<p>For example, I saw one user with a 16-bit assembler that emitted different code depending on the order of <code>xchg</code>'s operands. It is a commutative operation, it shouldn't make a difference.</p>
<pre><code>87 D8   xchg    ax, bx
93      xchg    bx, ax
</code></pre>
<p>Life is too short for bad assemblers, and it should <strong>not</strong> be the thing getting in the way of golfing.</p>
<p>The three assemblers I would suggest are:</p>
<ul>
<li><a href="http://www.nasm.us/" rel="nofollow noreferrer">nasm</a> is the first one I would recommend to everyone (and I wish I had learned it first).
<ul>
<li>It fully supports 16-bit, 32-bit, <em>and</em> 64-bit code</li>
<li>It can easily assemble all sorts of object formats, as well as raw binaries/<code>.com</code> files (a multi-step ritual with GAS).</li>
<li><strong>It is officially supported on DOS</strong> as well as all modern OSes.</li>
<li>While it doesn't support C macros, it has a god-tier preprocessor that is much better than C.</li>
<li>The way it handles local labels is really nice.</li>
<li>Good error messages, mostly fairly beginner-friendly pointing you in the direction of why an instruction isn't allowed or what it doesn't like about a source line.</li>
</ul>
</li>
<li><a href="https://sourceware.org/binutils/docs/as/index.html" rel="nofollow noreferrer">GAS</a> (<a href="https://gcc.gnu.org" rel="nofollow noreferrer">GCC</a>'s assembler) is another fairly good assembler.
<ul>
<li>It is the assembler used by GCC and Clang. You might recognize it if you use Godbolt or <code>gcc -S</code>.</li>
<li>It supports AT&amp;T syntax which some might prefer</li>
<li>With <code>.intel_syntax noprefix</code>, you can switch to Intel syntax</li>
<li>While its built-in preprocessor is pretty limited, it can be easily combined with a C preprocessor.</li>
<li>For x87, beware of <a href="https://sourceware.org/binutils/docs/as/i386_002dBugs.html" rel="nofollow noreferrer">the AT&amp;T syntax design bug</a> that interchanges <code>fsubr</code> with <code>fsub</code> in some cases, same for <code>fdiv[r]</code>.  Older GAS versions applied the same swap in Intel-syntax mode, and so did older binutils <code>objdump -d</code> versions.  (This is AT&amp;T's fault, not GNU's, and current GAS versions do as well as possible, but is an inherent downside in using AT&amp;T syntax for x87.)</li>
<li>Error messages are less helpful than NASM about why an instruction is invalid</li>
<li>Ambiguous instructions other than <code>mov</code> default to dword operand-size instead of being an error in AT&amp;T syntax, such as <code>add $123, (%rdi)</code> assembling as <code>addl</code>.  Clang, and GAS in Intel syntax mode, error on this.</li>
</ul>
</li>
<li><a href="https://clang.llvm.org" rel="nofollow noreferrer">Clang</a> is, in most cases, completely exchangeable for GAS.
<ul>
<li>It has much more helpful error messages and doesn't silently treat x86_64 registers as symbols in 32-bit mode.</li>
<li>While AT&amp;T syntax is fully supported, Intel syntax currently has a few bugs.
<ul>
<li>It is the <strong>only</strong> reason I am recommending GAS over Clang. 😔</li>
<li>It still works as a solid linter.</li>
</ul>
</li>
<li>It also supports C macros.</li>
</ul>
</li>
</ul>
<p>I haven't used enough of the other assemblers to give a good opinion, as I am more than satisfied with those three.</p>
<p><a href="https://flatassembler.net/" rel="nofollow noreferrer">FASM</a> is also well-regarded, using very nearly the same syntax as NASM, and is supported on <a href="https://TIO.run/" rel="nofollow noreferrer">https://TIO.run/</a> ; It's able to make 32-bit executables on TIO, unlike with other assemblers, using the directive <code>format ELF executable 3</code> to emit a 32-bit ELF executable, not a <code>.o</code> object file that would need linking.</p>
<p><a href="https://euroassembler.eu/eadoc/" rel="nofollow noreferrer">EuroAssembler</a> is also open-source; its maintainer is <a href="https://stackoverflow.com/users/2581418/vitsoft">active on Stack Overflow</a> in the [assembly] and [x86] tags.</p>
</div>
<div id="pu8" class="pu"><h1>pop ax and throw a value from stack</h1>
<pre><code>pop eax
</code></pre>
<h1>push word 0; push word 8</h1>
<pre><code>push dword 8
</code></pre>
<h1>push dword 9999</h1>
<pre><code>push word 0
push word 9999
</code></pre>
</div>
<div id="pu9" class="pu"><p>&quot;Free bypass&quot;: If you already have an instruction with an immediate on a register that you only care about the low part of, making the immediate longer than necessary could allow you to insert into its high part other instructions that can be jumped to (but don't execute when coming from before). This works because of little-endianness. <a href="https://codegolf.stackexchange.com/a/244118/104752">Example</a>; <a href="https://codegolf.stackexchange.com/a/245361/104752">another example</a>.</p>
</div>
<div id="pu10" class="pu"><p><strong>Use special-case short-form encodings for AL/AX/EAX, and other short forms and single-byte instructions</strong></p>
<p>Examples assume 32 / 64-bit mode, where the default operand size is 32 bits.  An operand-size prefix changes the instruction to AX instead of EAX (or the reverse in 16-bit mode).</p>
<ul>
<li><strong><code>inc/dec</code> a register</strong> (other than 8-bit): <code>inc eax</code> / <code>dec ebp</code>.   (Not x86-64: the <code>0x4x</code> opcode bytes were repurposed as REX prefixes, so <code>inc r/m32</code> is the only encoding.)</li>
</ul>
<p>8-bit <code>inc bl</code> is 2 bytes, using the <a href="http://felixcloutier.com/x86/INC.html" rel="noreferrer"><code>inc r/m8</code> opcode + ModR/M operand encoding</a>.  So <strong>use <code>inc ebx</code> to increment <code>bl</code>, if it's safe.</strong> (e.g. if you don't need the ZF result in cases where the upper bytes might be non-zero).</p>
<ul>
<li><p><code>scasd</code>: <code>e/rdi+=4</code>, requires that the register points to readable memory.  Sometimes useful even if you don't care about the FLAGS result (like <code>cmp eax,[rdi]</code> / <code>rdi+=4</code>).  And <strong>in 64-bit mode, <code>scasb</code> can work as a 1-byte <code>inc rdi</code></strong>, if lodsb or stosb aren't useful.</p>
</li>
<li><p><strong><a href="http://felixcloutier.com/x86/XCHG.html" rel="noreferrer"><code>xchg eax, r32</code></a></strong>: this is where 0x90 NOP came from: <code>xchg eax,eax</code>.  Example: re-arrange 3 registers with two <code>xchg</code> instructions in a <code>cdq</code> / <code>idiv</code> loop <a href="https://codegolf.stackexchange.com/questions/77270/greatest-common-divisor/77364#77364">for GCD in 8 bytes</a> where most of the instructions are single-byte, including an abuse of <code>inc ecx</code>/<code>loop</code> instead of <code>test ecx,ecx</code>/<code>jnz</code></p>
</li>
<li><p><a href="http://felixcloutier.com/x86/CWD:CDQ:CQO.html" rel="noreferrer"><code>cdq</code></a>: sign-extend EAX into EDX:EAX, i.e. copying the high bit of EAX to all bits of EDX.  To create a zero with known non-negative, or to get a 0/-1 to add/sub or mask with.  <a href="https://stackoverflow.com/questions/37743476/assembly-cltq-and-movslq-difference/37746322#37746322">x86 history lesson: <code>cltq</code> vs. <code>movslq</code></a>, and also AT&amp;T vs. Intel mnemonics for this and the related <code>cdqe</code>.</p>
</li>
<li><p><a href="http://felixcloutier.com/x86/LODS:LODSB:LODSW:LODSD:LODSQ.html" rel="noreferrer">lodsb/d</a>: like <code>mov eax, [rsi]</code> / <code>rsi += 4</code> without clobbering flags.  (Assuming DF is clear, which standard calling conventions require on function entry.)  Also stosb/d, sometimes scas, and more rarely movs / cmps.</p>
</li>
<li><p><a href="http://felixcloutier.com/x86/PUSH.html" rel="noreferrer"><code>push</code></a>/<a href="http://felixcloutier.com/x86/POP.html" rel="noreferrer"><code>pop reg</code></a>.  e.g. in 64-bit mode, <code>push rsp</code> / <code>pop rdi</code> is 2 bytes, but <code>mov rdi, rsp</code> needs a REX prefix and is 3 bytes.</p>
</li>
</ul>
<p><a href="http://felixcloutier.com/x86/XLAT:XLATB.html" rel="noreferrer"><code>xlatb</code></a> exists, but is rarely useful.  A large lookup table is something to avoid.  I've also never found a use for AAA / DAA or other packed-BCD or 2-ASCII-digit instructions, except for a <a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/193842#193842">hacky use of DAS as part of converting a 4-bit integer to an ASCII hex digit</a>, thanks to Peter Ferrie.</p>
<p>1-byte <code>lahf</code> / <code>sahf</code> are rarely useful.  You <em>could</em> <code>lahf</code> / <code>and ah, 1</code> as an alternative to <code>setc ah</code>, but it's typically not useful.</p>
<p>And for CF specifically, there's <code>sbb eax,eax</code> to get a 0/-1, or even <strong>un-documented but universally supported 1-byte <code>salc</code> (set AL from Carry)</strong> which effectively does <code>sbb al,al</code> without affecting flags. (Removed in x86-64).  I used SALC in <a href="https://codegolf.stackexchange.com/questions/123194/user-appreciation-challenge-1-dennis/123458#123458">User Appreciation Challenge #1: Dennis ♦</a>.</p>
<p>1-byte <code>cmc</code> / <code>clc</code> / <code>stc</code> (flip (&quot;complement&quot;), clear, or set CF) are rarely useful, although I did find <a href="https://codegolf.stackexchange.com/questions/133618/extreme-fibonacci/135618#135618"><strong>a use for <code>cmc</code></strong> in extended-precision addition</a> with base 10^9 chunks.  To unconditionally set/clear CF, usually arrange for that to happen as part of another instruction, e.g. <code>xor eax,eax</code> clears CF as well as EAX.  There are no equivalent instructions for other condition flags, just DF (string direction) and IF (interrupts).  The carry flag is special for a lot of instructions; shifts set it, <code>adc al, 0</code> can add it to AL in 2 byte, and I mentioned earlier the undocumented SALC.</p>
<p><strong><code>std</code> / <code>cld</code> rarely seem worth it</strong>.  Especially in 32-bit code, it's better to just use <code>dec</code> on a pointer and a <code>mov</code> or memory source operand to an ALU instruction instead of setting DF so <code>lodsb</code> / <code>stosb</code> go downward instead of up.  Usually if you need downward at all, you still have another pointer going up, so you'd need more than one <code>std</code> and <code>cld</code> in the whole function to use <code>lods</code> / <code>stos</code> for both.  Instead, just use the string instructions for the upward direction.  (The standard calling conventions guarantee DF=0 on function entry, so you can assume that for free without using <code>cld</code>.)</p>
<hr />
<h3>8086 history: why these encodings exist</h3>
<p>In original 8086, AX was very special: instructions like <code>lodsb</code> / <code>stosb</code>, <code>cbw</code>, <code>mul</code> / <code>div</code> and others use it implicitly.  That's still
the case of course; current x86 hasn't dropped any of 8086's opcodes (at least not any of the officially documented ones, <a href="https://stackoverflow.com/questions/32868293/x86-32-bit-opcodes-that-differ-in-x86-x64-or-entirely-removed">except</a> in <a href="https://stackoverflow.com/questions/44089163/is-x86-32-bit-assembly-code-valid-x86-64-bit-assembly-code">64-bit mode</a>).  But later CPUs added new instructions that gave better / more efficient ways to do things without copying or swapping them to AX first.  (Or to EAX in 32-bit mode.)</p>
<p>e.g. 8086 lacked later additions like <code>movsx</code> / <code>movzx</code> to load or move + sign-extend, or 2 and 3-operand <a href="http://felixcloutier.com/x86/IMUL.html" rel="noreferrer"><code>imul cx, bx, 1234</code></a> that don't produce a high-half result and don't have any implicit operands.</p>
<p>Also, <strong>8086's main bottleneck was instruction-fetch, so optimizing for code-size was important for performance back then</strong>.  8086'<a href="https://retrocomputing.stackexchange.com/questions/5121/why-are-first-four-x86-gprs-named-in-such-unintuitive-order#comment11346_5128">s ISA designer (Stephen Morse)</a> spent a lot of opcode coding space on special cases for AX / AL, <a href="https://stackoverflow.com/questions/38019386/what-is-the-significance-of-operations-on-the-register-eax-having-their-own-opco">including special (E)AX/AL-destination opcodes for all the basic immediate-src ALU- instructions</a>, just opcode + immediate with no ModR/M byte.  2-byte <code>add/sub/and/or/xor/cmp/test/... AL,imm8</code> or <code>AX,imm16</code> or (in 32-bit mode) <code>EAX,imm32</code>.</p>
<p>But there's no special case for <code>EAX,imm8</code>, so the regular ModR/M encoding of <code>add eax,4</code> is shorter.</p>
<p>The assumption is that if you're going to work on some data, you'll want it in AX / AL, so swapping a register with AX was something you might want to do, maybe even more often than <em>copying</em> a register to AX with <code>mov</code>.</p>
<p>Everything about 8086 instruction encoding supports this paradigm, from instructions like <code>lodsb/w</code> to all the special-case encodings for immediates with EAX to its implicit use even for multiply/divide.</p>
<hr />
<p>Don't get carried away; it's not automatically a win to swap everything to EAX, especially if you need to use immediates with 32-bit registers instead of 8-bit.  Or if you need to interleave operations on multiple variables in registers at once.  Or if you're using instructions with 2 registers, not immediates at all.</p>
<p>But always keep in mind: am I doing anything that would be shorter in EAX/AL?  Can I rearrange so I have this in AL, or am I currently taking better advantage of AL with what I'm already using it for.</p>
<p>Mix 8-bit and 32-bit operations freely to take advantage whenever it's safe to do so (you don't need carry-out into the full register or whatever).</p>
</div>
<div id="pu11" class="pu"><h1>Combinations with CDQ for certain piecewise-linear functions</h1>
<p><code>CDQ</code> sign-extends EAX into EDX, making EDX 0 if EAX is nonnegative and -1 (all 1s) if EAX is negative. This can be combined with several other instructions to apply certain piecewise-linear functions to a value in EAX in 3 bytes:</p>
<p><code>CDQ</code> + <code>AND</code> → <span class="math-container">\$ \min(x, 0) \$</span> (in either EAX or EDX). (I have used this <a href="https://codegolf.stackexchange.com/a/241451/104752">here</a>.)</p>
<p><code>CDQ</code> + <code>OR</code> → <span class="math-container">\$ \max(x, -1) \$</span>.</p>
<p><code>CDQ</code> + <code>XOR</code> → <span class="math-container">\$ \max(x, -x-1) \$</span>.</p>
<p><code>CDQ</code> + <code>MUL EDX</code> → <span class="math-container">\$ \max(-x, 0) \$</span> in EAX and <span class="math-container">\$ \left\{ \begin{array}{ll} 0 &amp; : x \ge 0 \\ x - 1 &amp; : x &lt; 0 \end{array} \right.\$</span> in EDX.</p>
</div>
<div id="pu12" class="pu"><h1>Entry point doesn't necessarily have to be first byte of submission</h1>
<p>I came across <a href="https://codegolf.stackexchange.com/questions/118444/stay-away-from-zero/151115#151115">this answer</a>, and didn't understand it at first until I realized that the intention is:</p>
<pre><code>; ---- example calling code starts here -------------

                MOV     ECX, 1
                CALL    entry
                RET

; ---- code golf answer code starts here (5 bytes) --

       41       INC     ECX
entry: E3 FD    JECXZ   SHORT $-1
       91       XCHG    EAX,ECX
       C3       RETN

; ---- code golf answer code ends here -------------
</code></pre>
<p>Does not seem to conflict with any of the conditions of &quot;<a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/132983#132983">Choose your calling convention</a>&quot; and is otherwise valid assembly language.</p>
</div>
<div id="pu13" class="pu"><h1>Use interrupts and syscalls wisely</h1>
<p>In general, unlike the C calling conventions, most syscalls and interrupts will preserve your registers and flags unless noted otherwise, except for a return value usually in AL/EAX/RAX depending on the OS.  (e.g. the x86-64 <code>syscall</code> instruction itself <a href="https://stackoverflow.com/questions/47983371/why-do-x86-64-linux-system-calls-modify-rcx-and-what-does-the-value-mean">destroys RCX and R11</a>)</p>
<h4>Linux specific:</h4>
<ul>
<li>If exiting with a crash is okay, <code>int3</code>, <code>int1</code>, or <code>into</code> can usually do the job in one byte. Don't try this on DOS though, it will lock up.
<ul>
<li>Note that the error messages like <code>Segmentation fault (core dumped)</code> or <code>Trace/breakpoint trap</code> are actually printed by your <em>shell</em>, not the program/kernel. Don't believe me? Try running <code>set +m</code> before your program or redirecting stderr to a file.</li>
</ul>
</li>
<li>You can use <code>int 0x80</code> in 64-bit mode. <a href="https://stackoverflow.com/questions/46087730/what-happens-if-you-use-the-32-bit-int-0x80-linux-abi-in-64-bit-code">It will use the 32-bit ABI though</a> (eax, ebx, ecx, edx), so make sure all pointers are in the low 32 bits. On the small code model, this true for all code stored in your binary. Keep this in mind for <a href="/questions/tagged/restricted-source" class="post-tag" title="show questions tagged &#39;restricted-source&#39;" rel="tag">restricted-source</a>.
<ul>
<li>Additionally, <code>sysenter</code> and <code>call dword gs:0x10</code> can also do syscalls in 32-bit mode, although the calling convention is quite....weird for the former.</li>
</ul>
</li>
</ul>
<h4>DOS/BIOS specific:</h4>
<ul>
<li>Use <code>int 29h</code> instead of <code>int 21h:02h</code> for printing single bytes to the screen. <code>int 29h</code> doesn't need <code>ah</code> to be set and <em>very</em> conveniently uses <code>al</code> instead of <code>dl</code>. It writes directly to the screen, so you can't just redirect to a file, though.</li>
<li>DOS also has <code>strlen</code> and <code>strcmp</code> interrupts (see <a href="http://www.fysnet.net/undoc.htm" rel="nofollow noreferrer">this helpful page for this and other undocumented goodies</a>)</li>
<li>Unless you modified <code>cs</code>, <strong>don't</strong> use <code>int 20h</code> or <code>int 21h:4Ch</code> for exiting, just <code>ret</code> from your <code>.com</code> file. Alternatively, if you happen to have <code>0x0000</code> on the top of your stack, you can also <code>ret</code> to that.</li>
<li>In the rare case that you need to call helper functions more than 4 times, consider registering them to the <code>int1</code>, <code>int3</code>, or <code>into</code> interrupts. Make sure to use <code>iret</code> instead of <code>ret</code>, though.</li>
</ul>
<pre class="lang-lisp prettyprint-override"><code>        ; AH: 0x25 (set interrupt)
        ; AL: 0x03 (INT3)
        ; Use 0x2504 for INTO, or 0x2501 for INT1
        mov     ax, 0x2503
        ; DX: address to function (make sure to use IRET instead of RET)
        mov     dx, my_interrupt_func
        int     0x21

        ; Now instead of this 3 byte opcode...
        call    my_func
        ; ...just do this 1 byte opcode.
        int3 ; or int1, into
</code></pre>
<ul>
<li><a href="/questions/tagged/restricted-source" class="post-tag" title="show questions tagged &#39;restricted-source&#39;" rel="tag">restricted-source</a> tip: Your interrupt vector table is a table of far pointers at <code>0000:0000</code> (so for example, <code>int 21h</code> is at <code>0000h:0084h</code>).</li>
</ul>
</div>
<div id="pu14" class="pu"><h2>Align Registers to by Power of 2 Value with or/inc</h2>
<p>Say you want to aligned a pointer for a load. I.e saying aligning for <code>xmm</code> load:</p>
<p>This is a pretty common idiom:</p>
<pre><code>addq $16, %rdi   // 4b
andq $-16, %rdi  // 4b
</code></pre>
<p>A cheaper way:</p>
<pre><code>orq $15, %rdi    // 4b
incq %rdi        // 3b
</code></pre>
<p>If your pointer is in RAX, the special 2-byte <code>op al, imm8</code> no-modrm encoding is useful.  Writing a byte or word register leaves the upper bytes untouched.  On older Intel CPUs (before Sandybridge) <a href="https://stackoverflow.com/questions/41573502/why-doesnt-gcc-use-partial-registers">this can cause a partial-register stall</a>, but even for performance it's safe on modern CPUs.</p>
<pre><code>or  $0xf, %al     // 2b   (leave upper bytes untouched)
inc %rax          // 3b   (carry into the upper bytes is possible)

or  $0xf, %dl     // 3b
inc %rdx          // 3b

or  $0xf, %dil    // 4b  REX + opcode + modrm + imm8
inc %rdi          // 3b  no savings
</code></pre>
<p>Also works with <code>and $0xf0, %al</code> to round down to the previous alignment boundary.</p>
<hr />
<p>Also worth noting the <code>or</code> alone will round to value minus 1 so it can be used to keep address offsets in <code>imm8</code> short encoding range i.e:</p>
<pre><code>andq $-16, %rdi
// Stuff on (%rdi)[0, 79]
vmovdqa 80(%rdi), %xmm0
</code></pre>
<p>vs.</p>
<pre><code>orq $15, %rdi
// Stuff on -15(%rdi)[0, 79]
vmovdqa 65(%rdi), %xmm0
# vmovdqa 80 - 15(%rdi), %xmm0   # same thing, but with the -15 in the asm source
</code></pre>
</div>
<div id="pu15" class="pu"><h1>Choose your calling convention to put args where you want them.</h1>
<p><strong>The language of your answer is asm (actually machine code), so treat it as part of a program written in asm, not C-compiled-for-x86.</strong>  Your function doesn't have to be easily callable from C with any standard calling convention.  That's a nice bonus if it doesn't cost you any extra bytes, though.</p>
<p>In a pure asm program, it's normal for some helper functions to use a calling convention that's convenient for them and for their caller.  Such functions document their calling convention (inputs/outputs/clobbers) with comments.</p>
<p>In real life, even asm programs do (I think) tend to use consistent calling conventions for most functions (especially across different source files), but any given important function could do something special.  In code-golf, you're optimizing the crap out of one single function, so obviously it's important/special.</p>
<hr />
<p><strong>To test your function from a C program, you can write a wrapper</strong> that puts args in the right places, saves/restores any extra registers you clobber, and puts the return value into <code>e/rax</code> if it wasn't there already.</p>
<hr />
<h3>The limits of what's reasonable: anything that doesn't impose an unreasonable burden on the caller:</h3>
<ul>
<li><p><code>esp</code>/<code>rsp</code> must be call-preserved<sup>1</sup>; other integer regs are fair game for being call-clobbered.  (<code>rbp</code> and <code>rbx</code> are usually call-preserved in normal conventions, but you <em>could</em> clobber both.)</p>
</li>
<li><p>Any arg in any register (except <code>rsp</code>) is reasonable, but asking the caller to copy the same arg to multiple registers is not.</p>
</li>
<li><p>Requiring <code>DF</code> (string direction flag for <code>lods</code>/<code>stos</code>/etc.) to be clear (upward) on call/ret is normal.  Letting it be undefined on call/ret would be ok.  Requiring it to be cleared or set on entry but then leaving it modified when you return would be weird.</p>
</li>
<li><p>Returning FP values in x87 <code>st0</code> is reasonable, but returning in <code>st3</code> with garbage in other x87 registers isn't.  The caller would have to clean up the x87 stack.  Even returning in <code>st0</code> with non-empty higher stack registers would also be questionable (unless you're returning multiple values).</p>
</li>
<li><p>Your function will be called with <code>call</code>, so <code>[rsp]</code> is your return address.  You <em>can</em> avoid <code>call</code>/<code>ret</code> on x86 using a link register like <code>lea rbx, [ret_addr]</code>/<code>jmp function</code> and return with <code>jmp rbx</code>, but that's not &quot;reasonable&quot;.  That's not as efficient as <code>call</code>/<code>ret</code>, so it's not something you'd plausibly find in real code.</p>
</li>
<li><p>Clobbering unlimited memory above <code>rsp</code> is not reasonable, but clobbering your function args on the stack is allowed in normal calling conventions.  x64 Windows requires 32 bytes of shadow space above the return address, while x86-64 System V gives you a 128 byte red-zone below <code>rsp</code>, so either of those are reasonable.  (Or even a much larger red-zone, especially in a stand-alone program rather than function.)</p>
</li>
</ul>
<p>Note 1: or have some well-defined sensible rule for how RSP is modified: e.g. callee-pops stack args like with <code>ret 8</code>. (Although stack args and a larger <code>ret imm16</code> encoding are usually not what you want for code-golf).  Or even returning an array by value on the stack is an unconventional but usable calling-convention.  e.g. pop the return address into a register, then push in a loop, then <code>jmp reg</code> to return. Probably only justifiable with a size in a register, else the caller would have to save the original RSP somewhere.  RBP or some other reg would have to be call-preserved so a caller could use it as a frame pointer to easily clean up the result.  Also probably not smaller than using <code>stos</code> to write an output pointer passed in RDI.</p>
<p>Borderline cases: write a function that produces a sequence in an array, given the first 2 elements <em>as function args</em>.  <a href="https://codegolf.stackexchange.com/questions/101145/stewies-sequence/102741#102741">I chose</a> to have the caller store the start of the sequence into the array and just pass a pointer to the array.  This is definitely bending the question's requirements.  I considered taking the args packed into <code>xmm0</code> for <code>movlps [rdi], xmm0</code>, which would also be a weird calling convention and ever harder to justify / more of a stretch.</p>
<hr />
<h3>Return a boolean in FLAGS (condition codes)</h3>
<p>OS X system calls do this (<code>CF=0</code> means no error): <a href="https://stackoverflow.com/questions/48381234/is-it-considered-bad-practice-to-use-the-flags-register-as-a-boolean-return-valu">Is it considered bad practice to use the flags register as a boolean return value?</a>.</p>
<p>Any condition that can be checked with one <code>jcc</code> is perfectly reasonable, especially if you can pick one that has any semantic relevance to the problem.  (e.g. a compare function might set flags so <code>jne</code> will be taken if they weren't equal).</p>
<hr />
<h3>Require narrow args (like a <code>char</code>) to be sign or zero extended to 32 or 64 bits.</h3>
<p>This is not unreasonable; using <code>movzx</code> or <code>movsx</code> <a href="https://stackoverflow.com/questions/41573502/why-doesnt-gcc-use-partial-registers">to avoid partial-register slowdowns</a> is normal in modern x86 asm.  In fact clang/LLVM already makes code that depends on an undocumented extension to the x86-64 System V calling convention: <a href="https://stackoverflow.com/questions/36706721/is-a-sign-or-zero-extension-required-when-adding-a-32bit-offset-to-a-pointer-for/36760539#36760539">args narrower than 32 bits are sign or zero extended to 32 bits by the caller</a>.</p>
<p>You can document/describe extension to 64 bits by writing <code>uint64_t</code> or <code>int64_t</code> in your prototype if you want, e.g. so you can use a <code>loop</code> instruction, which uses the whole 64 bits of <code>rcx</code> unless you use an address-size prefix to override the size down to 32 bit <code>ecx</code> (yes really, address-size not operand-size).</p>
<p>Note that <code>long</code> is only a 32-bit type in the Windows 64-bit ABI, and <a href="https://en.wikipedia.org/wiki/X32_ABI" rel="noreferrer">the Linux x32 ABI</a>; <code>uint64_t</code> is unambiguous and shorter to type than <code>unsigned long long</code>.</p>
<hr />
<h3>Existing calling conventions:</h3>
<ul>
<li><p>Windows 32-bit <code>__fastcall</code>, <a href="https://codegolf.stackexchange.com/questions/132981/tips-for-golfing-in-x86-x64-machine-code/133048#133048">already suggested by another answer</a>: integer args in <code>ecx</code> and <code>edx</code>.</p>
</li>
<li><p><strong>x86-64 System V</strong>: passes lots of args in registers, and has lots of call-clobbered registers you can use without REX prefixes.  More importantly, it was <a href="https://stackoverflow.com/questions/63891991/whats-the-best-way-to-remember-the-x86-64-system-v-arg-register-order">actually chosen</a> to allow compilers to inline (or implement in libc) <code>memcpy</code> or <code>memset</code> as <code>rep movsb</code> easily: the first 6 integer/pointer args are passed in <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, and <code>r9</code>.</p>
<p>If your function uses <code>lodsd</code>/<code>stosd</code> inside a loop that runs <code>rcx</code> times (with the <code>loop</code> instruction), you can say &quot;callable from C as <code>int foo(int *rdi, const int *rsi, int dummy, uint64_t len)</code> with the x86-64 System V calling convention&quot;.  <a href="https://codegolf.stackexchange.com/questions/132719/the-chroma-key-to-success/132757#132757">example: chromakey</a>.</p>
</li>
<li><p>32-bit GCC <code>regparm</code>: <strong>Integer args in <code>eax</code></strong>, <code>ecx</code>, and <code>edx</code>, return in EAX (or EDX:EAX).  Having the first arg in the same register as the return value allows some optimizations, <a href="https://codegolf.stackexchange.com/questions/160100/the-repetitive-byte-counter/160236#160236">like this case with an example caller and a prototype with a function attribute</a>.  And of course AL/EAX is special for some instructions.</p>
</li>
<li><p>The Linux x32 ABI uses 32-bit pointers in long mode, so you can save a REX prefix when modifying a pointer (<a href="https://codegolf.stackexchange.com/questions/101145/stewies-sequence/102741#102741">example use-case</a>).  You can still use 64-bit address-size, unless you have a 32-bit negative integer zero-extended in a register (so it would be a large unsigned value if you did <code>[rdi + rdx]</code>, going outside the low 32 bits of address space.).</p>
<p>Note that <code>push rsp</code>/<code>pop rax</code> is 2 bytes, and equivalent to <code>mov rax, rsp</code>, so you can still <em>copy</em> full 64-bit registers in 2 bytes.</p>
</li>
</ul>
</div>
<div id="pu16" class="pu"><h1>Use <code>shr</code> for first occurrence lookup tables</h1>
<p>Often times you need to do something like this to check whether a byte has been encountered:</p>
<pre class="lang-cpp prettyprint-override"><code>bool found[256]={false};
for (uint8_t x : data) {
    // Check for first occurrence
    if (!found[x]) {
        // mark it as encountered
        found[x] = true;
        // do something
        func(x);
    }
}
</code></pre>
<p>There is a very easy way to do this in x86, and that is via <code>shr</code>.</p>
<h3>Setup</h3>
<p>Setting it up is easy thanks to <code>push -1</code> which can create a block of 1 bits. I use x86_64 here, but it is the same on x86.</p>
<p>You can switch it to <code>rep stos</code> if you have that set up, but it isn't worth it to set up just for that loop.</p>
<pre class="lang-python prettyprint-override"><code>        push    TABLE_SIZE/8
        pop     rcx
.Lpush_loop:
        push    -1
        loop    .Lpush_loop
</code></pre>
<h3>Usage</h3>
<p><code>shr</code> will both mark the occurrence <strong>and</strong> indicate that it was unique by setting <code>OF</code>.</p>
<pre class="lang-python prettyprint-override"><code>.Lloop:
        lodsb # example

        # 3 bytes (2 bytes if you use RDI/RBX/RBP/RSI or a register src)
        shr     byte ptr [rsp + rax]
        # OF == first occurrence
        jno     .Lfound

.Lfirst_occurrence:
        ...
.Lfound:
        loop    .Lloop # example
</code></pre>
<p>Magic.</p>
<p>See my answer for <a href="https://codegolf.stackexchange.com/a/217678/94093">Type uniqchars!</a> where I thoroughly explain it.</p>
</div>
<div id="pu17" class="pu"><h1>Avoid registers which need prefixes</h1>
<p>Quite a simple tip I haven't seen mentioned before.</p>
<p><strong>Avoid <code>r8-r15</code> (as well as <code>dil</code>, <code>sil</code>, <code>bpl</code>, and <code>spl</code>) on x86_64 like the plague.</strong> Even just thinking about these registers requires an extra REX prefix. The only exception is if you are using them exclusively for 64-bit arithmetic (which also needs REX prefixes). Even still, you are usually better off using a low register since some operations can be done using the implicit zero extension.</p>
<p>Note that this tip also applies to ARM Thumb-2.</p>
<p>Additionally, be careful when using 16-bit registers in 32/64-bit mode (as well as 32-bit registers in 16-bit mode, but this is rare), as these need a prefix byte as well.</p>
<p>However, unlike the extra x86_64 registers, 16-bit instructions can be useful: Many instructions which would otherwise need a full 32-bit immediate argument will only use a 16-bit argument. So, if you were to bitwise and <code>eax</code> by <code>0xfffff00f</code>, <code>and ax, 0xf00f</code> would be smaller.</p>
</div>
<div id="pu18" class="pu"><h1>Take advantage of the x86_64 code model</h1>
<p>Linux's default code model will put all of your code and globals in the low 31 bits of memory, so 32-bit pointer arithmetic here is perfectly safe. The stack, libraries, and any dynamically allocated pointers are not, though. <a href="https://tio.run/##tZHbigIxDIbv@xRB8EotnvDCZ9g3WEUytc4WMm1Jqoy@/DieZkZQ2IW1l8n3fyUJitgio@MoN6aqdE4hIyjQeaWdT5Y2cvQJS/Ahst25Ul16SwX3F/fyA4xlUyCLwFs3hG92EQagvyLXop0kXjdQEQ7AUkM12RQNEsENfrZJ18ZhiwnXf/vvd@qPiTORf/DGEJ82zTapTri9iUYx7gS9/niyICpXvte2xJrkggd926N6LLSTpuBzmE1fZO6JN3zL1fOq69Qd6mQ5wFxV1Rk" rel="nofollow noreferrer" title="Assembly (gcc, x64, Linux) – Try It Online">Try it online!</a></p>
<p>Make sure to still use the entire 64 bits in memory operands (<strong>including lea</strong>), because using <code>[eax]</code> requires a <code>67</code> prefix byte.</p>
</div>
<div id="pu19" class="pu"><h1>Use multiplication for hashing</h1>
<p><a href="https://c9x.me/x86/html/file_module_x86_id_138.html" rel="nofollow noreferrer">IMUL</a>, multiplication by an immediate signed number, is a powerful instruction which can be used for hashing.</p>
<p>The regular multiplication instruction hard-codes one of the input operands and the output operand to be in <code>eax</code> (or <code>ax</code> or <code>al</code>). This is inconvenient; it requires instructions for setup and sometimes also to save and restore <code>eax</code> and <code>edx</code>. But if one of the operands is a constant, the instruction becomes much more versatile:</p>
<ul>
<li>No need to load the constant into a register</li>
<li>The other operand can be in any register, not only <code>eax</code></li>
<li>The result can be in any register, not necessarily overwriting the input!</li>
<li>The result is 32-bit, not a pair of registers</li>
<li>If the constant is between -128 and 127, it can be encoded by only one byte</li>
</ul>
<p>I used this many times (I hope I can be excused for these shameless plugs: <a href="https://codegolf.stackexchange.com/a/193500/25315">1</a> <a href="https://codegolf.stackexchange.com/a/205522/25315">2</a> <a href="https://codegolf.stackexchange.com/a/187720/25315">3</a> ...)</p>
</div>
<div id="pu20" class="pu"><h1>Use <code>fastcall</code> conventions</h1>

<p>x86 platform has <a href="https://en.wikipedia.org/wiki/X86_calling_conventions" rel="nofollow noreferrer">many calling conventions</a>. You should use those that pass parameters in registers. On x86_64, the first few parameters are passed in registers anyway, so no problem there. On 32-bit platforms, the default calling convention (<code>cdecl</code>) passes parameters in stack, which is no good for golfing - accessing parameters on stack requires long instructions.</p>

<p>When using <code>fastcall</code> on 32-bit platforms, 2 first parameters are usually passed in <code>ecx</code> and <code>edx</code>. If your function has 3 parameters, you might consider implementing it on a 64-bit platform.</p>

<p>C function prototypes for <code>fastcall</code> convention (taken from <a href="https://codegolf.stackexchange.com/a/119057/25315">this example answer</a>):</p>

<pre><code>extern int __fastcall SwapParity(int value);                 // MSVC
extern int __attribute__((fastcall)) SwapParity(int value);  // GNU   
</code></pre>

<hr>

<p>Note: you can also use other calling conventions, including custom ones. I never use custom calling conventions; for any ideas related to these, see <a href="https://codegolf.stackexchange.com/a/165020/25315">here</a>.</p>
</div>
<div id="pu21" class="pu"><h1>(way too many) ways of zeroing a register</h1>

<p>I remember being taught these by a certain person (I "invented" some of these myself); I don't remember who did I get them from, anyways these are the most interesting; possible use cases include restricted source code challenges or other bizzare stuff.</p>

<p><code>=&gt;</code> Zero mov:</p>

<pre><code>mov reg, 0
; mov eax, 0: B800000000
</code></pre>

<p><code>=&gt;</code> <code>push</code>+<code>pop</code>:</p>

<pre><code>push [something equal to zero]
pop reg
; push 0 / pop eax: 6A0058

; note: if you have a register equal to zero, it will be
; shorter but also equal to a mov.
</code></pre>

<p><code>=&gt;</code> <code>sub</code> from itself:</p>

<pre><code>sub reg, reg
; sub eax, eax: 29C0
</code></pre>

<p><code>=&gt;</code> <code>mul</code> by zero:</p>

<pre><code>imul reg, 0
; imul eax, 0: 6BC000
</code></pre>

<p><code>=&gt;</code> <code>and</code> by zero:</p>

<pre><code>and reg, 0
; and eax, 0: 83E000
</code></pre>

<p><code>=&gt;</code> <code>xor</code> by itself:</p>

<pre><code>xor reg, reg
; xor eax, eax: 31C0

; possibly the best way to zero an arbitrary register,
; I remembered this opcode (among other).
</code></pre>

<p><code>=&gt;</code> <code>or</code> and <code>inc</code> / <code>not</code>:</p>

<pre><code>or reg, -1
inc reg     ; or not reg

; or eax, -1 / inc eax: 83C8FF40
</code></pre>

<p><code>=&gt;</code> reset <code>ECX</code>:</p>

<pre><code>loop $

; loop $: E2FE
</code></pre>

<p><code>=&gt;</code> flush <code>EDX</code>:</p>

<pre><code>shr eax, 1
cdq

; D1E899
</code></pre>

<p><code>=&gt;</code> zero <code>AL</code> (<code>AH = AL, AL = 0</code>)</p>

<pre><code>aam 1
; D401
</code></pre>

<p><code>=&gt;</code> reset <code>AH</code>:</p>

<pre><code>aad 0
; D500
</code></pre>

<p><code>=&gt;</code> Read 0 from the port</p>

<pre><code>mov dx, 81h
in al, dx
; 66BA8100EC
</code></pre>

<p><code>=&gt;</code> Reset <code>AL</code></p>

<pre><code>stc
setnc al
; F90F93C0
</code></pre>

<p><code>=&gt;</code> Use the zero descriptor from <code>gdt</code>:</p>

<pre><code>sgdt [esp-6]
mov reg, [esp-4]
mov reg, [reg]
; with eax: 0F014424FA8B4424FC8B00
</code></pre>

<p><code>=&gt;</code> Read zero from the <code>fs</code> segment (PE <code>exe</code> only)</p>

<pre><code>mov reg, fs:[10h]
; with eax: 64A110000000
</code></pre>

<p><code>=&gt;</code> The brainfuck way</p>

<pre><code>inc reg
jnz $-1
; with eax: 4075FD
</code></pre>

<p><code>=&gt;</code> Utilize the coprocessor</p>

<pre><code>fldz
fistp dword ptr [esp-4]
mov eax, [esp-4]
; D9EEDB5C24FC8B4424FC
</code></pre>

<p>Another possible options:</p>

<ul>
<li>Read zero using the builtin random number generator.</li>
<li>calculate sine from <code>pi * n</code> (use <code>fmul</code>).</li>
</ul>

<p>There are way cooler and potentially useful ways to execute this operation; although I didn't come up with them, therefore I'm not posting.</p>
</div>
<div id="pu22" class="pu"><h1>Try <code>XLAT</code> for byte memory access</h1>
<p><a href="https://www.felixcloutier.com/x86/xlat:xlatb" rel="nofollow noreferrer"><code>XLAT</code></a> is a <strong>one byte</strong> instruction that is equivalent to <code>AL = [BX+AL]</code>.  Yes, that's right, it lets you use <code>AL</code> as an index register for memory access.</p>
</div>
<div id="pu23" class="pu"><h1>Try <code>AAM</code> or <code>AAD</code> for byte division operations</h1>
<p>If you are working with only 8 bit values, using the <a href="https://www.felixcloutier.com/x86/aam" rel="nofollow noreferrer"><code>AAM</code></a> instruction can sometimes save several bytes over <a href="https://www.felixcloutier.com/x86/div" rel="nofollow noreferrer"><code>DIV reg8</code></a> since it will take an <code>imm8</code> and returns remainder and quotient in opposite <code>AH/AL</code> registers as <code>DIV</code>.</p>
<pre><code>D4 0A    AAM        ; AH = AL / 10, AL = AL % 10
</code></pre>
<p>It can also accept any byte value as the divisor as well by altering the second byte.</p>
<pre><code>D4 XX    AAM  XX    ; AH = AL / XX, AL = AL % XX
</code></pre>
<p>And <code>AAD</code> is the inverse of this, which is two operations in one.</p>
<pre><code>D5 XX    AAD  XX    ; AL = AH * XX + AL
</code></pre>
</div>
<div id="pu24" class="pu"><p><strong>To copy a 64-bit register, use <code>push rcx</code> ; <code>pop rdx</code></strong> instead of a 3-byte <code>mov</code>.<br>
The default operand-size of push/pop is 64-bit without needing a REX prefix.</p>

<pre><code>  51                      push   rcx
  5a                      pop    rdx
                vs.
  48 89 ca                mov    rdx,rcx
</code></pre>

<p>(An operand-size prefix can override the push/pop size to 16-bit, but <a href="https://stackoverflow.com/questions/45127993/how-many-bytes-does-the-push-instruction-push-onto-the-stack-when-i-dont-specif">32-bit push/pop operand-size is not encodeable in 64-bit mode</a> even with REX.W=0.)</p>

<p>If either or both registers are <code>r8</code>..<code>r15</code>, use <code>mov</code> because push and/or pop will need a REX prefix.  Worst case this actually loses if both need REX prefixes.  Obviously you should usually avoid r8..r15 anyway in code golf.</p>

<hr>

<p>You can keep your source more readable while developing with this <strong>NASM macro</strong>.  Just remember that it steps on the 8 bytes below RSP.  (In the red-zone in x86-64 System V).  But under normal conditions it's a drop-in replacement for 64-bit <code>mov r64,r64</code> or <code>mov r64, -128..127</code></p>

<pre><code>    ; mov  %1, %2       ; use this macro to copy 64-bit registers in 2 bytes (no REX prefix)
%macro MOVE 2
    push  %2
    pop   %1
%endmacro
</code></pre>

<p>Examples:</p>

<pre><code>   MOVE  rax, rsi            ; 2 bytes  (push + pop)
   MOVE  rbp, rdx            ; 2 bytes  (push + pop)
   mov   ecx, edi            ; 2 bytes.  32-bit operand size doesn't need REX prefixes

   MOVE  r8, r10             ; 4 bytes, don't use
   mov   r8, r10             ; 3 bytes, REX prefix has W=1 and the bits for reg and r/m being high

   xchg  eax, edi            ; 1 byte  (special xchg-with-accumulator opcodes)
   xchg  rax, rdi            ; 2 bytes (REX.W + that)

   xchg  ecx, edx            ; 2 bytes (normal xchg + modrm)
   xchg  rcx, rdx            ; 3 bytes (normal REX + xchg + modrm)
</code></pre>

<p>The <code>xchg</code> part of the example is because sometimes you need to get a value into EAX or RAX and don't care about preserving the old copy.  push/pop doesn't help you actually exchange, though.</p>
</div>
<div id="pu25" class="pu"><h1>Save on <code>jmp</code> bytes by arranging into if/then rather than if/then/else</h1>

<p>This is certainly very basic, just thought I would post this as something to think about when golfing.  As an example, consider the following straightforward code to decode a hexadecimal digit character:</p>

<pre><code>    cmp $'A', %al
    jae .Lletter
    sub $'0', %al
    jmp .Lprocess
.Lletter:
    sub $('A'-10), %al
.Lprocess:
    movzbl %al, %eax
    ...
</code></pre>

<p>This can be shortened by two bytes by letting a "then" case fall into an "else" case:</p>

<pre><code>    cmp $'A', %al
    jb .digit
    sub $('A'-'0'-10), %eax
.digit:
    sub $'0', %eax
    movzbl %al, %eax
    ...
</code></pre>
</div>
<div id="pu26" class="pu"><h1>Use whatever calling conventions are convenient</h1>
<p>System V x86 uses the stack and System V x86-64 uses <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, etc. for input parameters, and <code>rax</code> as the return value, but it is perfectly reasonable to use your own calling convention. <a href="https://msdn.microsoft.com/en-us/library/6xa169sk.aspx" rel="nofollow noreferrer">__fastcall</a> uses <code>ecx</code> and <code>edx</code> as input parameters, and <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#List_of_x86_calling_conventions" rel="nofollow noreferrer">other compilers/OSes use their own conventions</a>. Use the stack and whatever registers as input/output when convenient.</p>
<p>Example: <a href="https://codegolf.stackexchange.com/a/160236/17360">The repetitive byte counter</a>, using a clever calling convention for a 1 byte solution.</p>
<p>Meta: <a href="https://codegolf.meta.stackexchange.com/a/8508/17360">Writing input to registers</a>, <a href="https://codegolf.meta.stackexchange.com/a/8509/17360">Writing output to registers</a></p>
<p>Other resources: <a href="http://agner.org/optimize/calling_conventions.pdf" rel="nofollow noreferrer">Agner Fog's notes on calling conventions</a></p>
</div>
<div id="pu27" class="pu"><h1>Subtract -128 instead of add 128</h1>

<pre><code>0100 81C38000      ADD     BX,0080
0104 83EB80        SUB     BX,-80
</code></pre>

<p>Samely, add -128 instead of subtract 128</p>
</div>
<div id="pu28" class="pu"><h1>Use do-while loops instead of while loops</h1>

<p>This is not x86 specific but is a widely applicable beginner assembly tip. If you know a while loop will run at least once, rewriting the loop as a do-while loop, with loop condition checking at the end, often saves a 2 byte jump instruction. In a special case you might even be able to use <a href="https://codegolf.stackexchange.com/a/133095/17360"><code>loop</code></a>. </p>
</div>
<div id="pu29" class="pu"><h3>Create 3 zeroes with <code>mul</code> (then <code>inc</code>/<code>dec</code> to get +1 / -1 as well as zero)</h3>

<p>You can zero eax and edx by multiplying by zero in a third register.</p>

<pre><code>xor   ebx, ebx      ; 2B  ebx = 0
mul   ebx           ; 2B  eax=edx = 0

inc   ebx           ; 1B  ebx=1
</code></pre>

<p>will result in EAX, EDX, and EBX all being zero in just four bytes.
You can zero EAX and EDX in three bytes:</p>

<pre><code>xor eax, eax
cdq
</code></pre>

<p>But from that starting point you can't get a 3rd zeroed register in one more byte, or a +1 or -1 register in another 2 bytes.  Instead, use the mul technique.</p>

<p>Example use-case: <a href="https://codegolf.stackexchange.com/questions/160857/binary-fibonacci/160894#160894">concatenating the Fibonacci numbers in binary</a>.</p>

<p>Note that after a <code>LOOP</code> loop finishes, ECX will be zero and can be used to zero EDX and EAX; you don't always have to create the first zero with <code>xor</code>.</p>
</div>
<div id="pu30" class="pu"><p>The loop and string instructions are smaller than alternative instruction sequences. Most useful is <code>loop &lt;label&gt;</code> which is smaller than the two instruction sequence <code>dec ECX</code> and <code>jnz &lt;label&gt;</code>, and <code>lodsb</code> is smaller than <code>mov al,[esi]</code> and <code>inc si</code>.</p>
</div>
<div id="pu31" class="pu"><h2><code>mov</code>-immediate is expensive for constants</h2>

<p>This might be obvious, but I'll still put it here. In general it pays off to think about the bit-level representation of a number when you need to initialize a value.</p>

<h3>Initializing <code>eax</code> with <code>0</code>:</h3>

<pre><code>b8 00 00 00 00          mov    $0x0,%eax
</code></pre>

<p>should be shortened (<a href="https://stackoverflow.com/questions/33666617/what-is-the-best-way-to-set-a-register-to-zero-in-x86-assembly-xor-mov-or-and/33668295#33668295">for performance as well as code-size</a>) to</p>

<pre><code>31 c0                   xor    %eax,%eax
</code></pre>

<h3>Initializing <code>eax</code> with <code>-1</code>:</h3>

<pre><code>b8 ff ff ff ff          mov    $-1,%eax
</code></pre>

<p>can be shortened to</p>

<pre><code>31 c0                   xor    %eax,%eax
48                      dec    %eax
</code></pre>

<p>or</p>

<pre><code>83 c8 ff                or     $-1,%eax
</code></pre>

<hr>

<p>Or more generally, <strong>any 8-bit sign-extended value can be created in 3 bytes with <code>push -12</code> (2 bytes) / <code>pop %eax</code> (1 byte).</strong>  This even works for 64-bit registers with no extra REX prefix; <code>push</code>/<code>pop</code> default operand-size = 64.</p>

<pre><code>6a f3                   pushq  $0xfffffffffffffff3
5d                      pop    %rbp
</code></pre>

<p>Or given a known constant in a register, you can create another nearby constant using <code>lea 123(%eax), %ecx</code> (3 bytes).  This is handy if you need a zeroed register <em>and</em> a constant; xor-zero (2 bytes) + <code>lea-disp8</code> (3 bytes).</p>

<pre><code>31 c0                   xor    %eax,%eax
8d 48 0c                lea    0xc(%eax),%ecx
</code></pre>

<p>See also <a href="https://stackoverflow.com/questions/45105164/set-all-bits-in-cpu-register-to-1-efficiently">Set all bits in CPU register to 1 efficiently</a></p>
</div>
<div id="pu32" class="pu"><h1>The <a href="https://en.wikipedia.org/wiki/FLAGS_register" rel="noreferrer">FLAGS</a> are set after many instructions</h1>

<p>After many arithmetic instructions, the Carry Flag (unsigned) and Overflow Flag (signed) are set automatically (<a href="https://stackoverflow.com/questions/791991/about-assembly-cfcarry-and-ofoverflow-flag">more info</a>). The Sign Flag and Zero Flag are set after many arithmetic and logical operations. This can be used for conditional branching. </p>

<p>Example: </p>

<pre><code>d1 f8                   sar    %eax
</code></pre>

<p>ZF is set by this instruction, so we can use it for condtional branching. </p>
</div>
<div id="pu33" class="pu"><p>To add or subtract 1, use the one byte <code>inc</code> or <code>dec</code> instructions which are smaller than the multibyte add and sub instructions.</p>
</div>
<div id="pu34" class="pu"><h1>Use conditional moves <a href="http://www.felixcloutier.com/x86/CMOVcc.html" rel="nofollow noreferrer"><code>CMOVcc</code></a> and sets <a href="https://c9x.me/x86/html/file_module_x86_id_288.html" rel="nofollow noreferrer"><code>SETcc</code></a></h1>

<p>This is more a reminder to myself, but conditional set instructions exist and conditional move instructions exist on processors P6 (Pentium Pro) or newer. There are many instructions that are based on one or more of the flags set in EFLAGS. </p>
</div>
<div id="pu35" class="pu"><h1><code>mov</code> small immediates into lower registers when applicable</h1>

<p>If you already know the upper bits of a register are 0, you can use a shorter instruction to move an immediate into the lower registers.</p>

<pre><code>b8 0a 00 00 00          mov    $0xa,%eax
</code></pre>

<p>versus</p>

<pre><code>b0 0a                   mov    $0xa,%al
</code></pre>

<h1>Use <code>push</code>/<code>pop</code> for imm8 to zero upper bits</h1>

<p>Credit to Peter Cordes. <code>xor</code>/<code>mov</code> is 4 bytes, but <code>push</code>/<code>pop</code> is only 3!</p>

<pre><code>6a 0a                   push   $0xa
58                      pop    %eax
</code></pre>
</div>
<div id="pu36" class="pu"><p>You can fetch sequential objects from the stack by setting esi to esp, and performing a sequence of lodsd/xchg reg, eax.</p>
</div>
<div id="pu37" class="pu"><p>In a lot of cases, accumulator-based instructions (i.e. those that take <code>(R|E)AX</code> as the destination operand) are 1 byte shorter than general-case instructions; see <a href="https://stackoverflow.com/questions/38019386/what-is-the-significance-of-operations-on-the-register-eax-having-their-own-opco">this question</a> on StackOverflow.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/132981/">132981</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




