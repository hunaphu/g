<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::139463</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>336</td><td>Python3</td><td>250312T022003Z</td><td><a href="https://codegolf.stackexchange.com/questions/139463/optimal-path-through-a-matrix/278609#278609">Ajax1234</a></td></tr>
<tr d-ix="1"><td>033</td><td>APL Dyalog Classic</td><td>180312T022710Z</td><td><a href="https://codegolf.stackexchange.com/questions/139463/optimal-path-through-a-matrix/157851#157851">ngn</a></td></tr>
<tr d-ix="2"><td>139</td><td>Octave + Image Processing package</td><td>170818T002127Z</td><td><a href="https://codegolf.stackexchange.com/questions/139463/optimal-path-through-a-matrix/139514#139514">beaker</a></td></tr>
<tr d-ix="3"><td>279</td><td>Mathematica 279 Bytes</td><td>170823T195831Z</td><td><a href="https://codegolf.stackexchange.com/questions/139463/optimal-path-through-a-matrix/140255#140255">Kelly Lo</a></td></tr>
<tr d-ix="4"><td>320</td><td>Python 2</td><td>170820T003024Z</td><td><a href="https://codegolf.stackexchange.com/questions/139463/optimal-path-through-a-matrix/139720#139720">Solvatio</a></td></tr>
<tr d-ix="5"><td>228</td><td>Haskell</td><td>170818T224328Z</td><td><a href="https://codegolf.stackexchange.com/questions/139463/optimal-path-through-a-matrix/139614#139614">Leif Wil</a></td></tr>
<tr d-ix="6"><td>358</td><td>JavaScript</td><td>170818T022836Z</td><td><a href="https://codegolf.stackexchange.com/questions/139463/optimal-path-through-a-matrix/139521#139521">Benjamin</a></td></tr>
<tr d-ix="7"><td>186</td><td>Python 3 + numpy + scipy</td><td>170818T001535Z</td><td><a href="https://codegolf.stackexchange.com/questions/139463/optimal-path-through-a-matrix/139512#139512">notjagan</a></td></tr>
<tr d-ix="8"><td>197</td><td>JavaScript</td><td>170818T070443Z</td><td><a href="https://codegolf.stackexchange.com/questions/139463/optimal-path-through-a-matrix/139528#139528">tsh</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Python3, 336 bytes</h1>
<pre class="lang-py prettyprint-override"><code>E=enumerate
def f(m):
 S,M=(0,0),[-1,0,1]
 J,K=len(m),len(m[0])
 q,d,F=[(*S,V:=m[0][0])],{S:V},[]
 for x,y,c in q:
  if(x,y)==(J-1,K-1):F+=[c];continue
  for X in M:
   for Y in M:
    Q,W=x+X,y+Y
    if[X,Y]!=[0,0]and 0&lt;=Q&lt;J and 0&lt;=W&lt;K and((V:=d.get((Q,W),-1))==-1 or V&gt;c+m[Q][W]):q+=[(Q,W,c+m[Q][W])];d[(Q,W)]=c+m[Q][W]
 return min(F)
</code></pre>
<p><a href="https://tio.run/##bVRNj9owED3Xv8Llss5iVjifhMW9lQNoKyEkPpRGFSVJGwkSCEFatOpvpx7bcQrlwNjz/ObNs41zuNS/y8IZHKrr9StPi/M@rTZ1ipI0wxnZW0OE5/SNkz7tWzTqMdqnLEZ4Qqd8lxaCQOUQ9WML4SNN6JhH5HlOF0MOIOAx/ZgPF39oJOqyssLv9EK3OC/wUYjjPCMCsDgnE6E@7TFrOO7yaBu/bsuizotzKkhQtoKSNyiR6bpN8Ywu@Xt3RS/dtczzLFrRdfyZR8J2vCkS3B/x2WiC9XQ5msKUEOEyefmV1oQICYuK5sJIj2Ghv/iy7e6jWRwtY2t4FI6AQlssfk0kZMXcgAhXaX2uCrzPCzK2rieGOe50OogJU/L3zwzwk60JAdgOIfgmuEiNnlljcg2xPoxQomYuBAep0TbBkSykSu2mRKWuau/o9mLVtXVfV7oTxY7TeJWIwG2mRLzQ7CVQVW6LhKqbE7a7dHUbz@wtML5dxKCzDLbXBu3bbRCVCji4haU5W2/@Pqj23v0tSGeh1rx1Ln8Psrt789uDw55nbskxt8SMCYbk4Xt@A4fh/wE2BsVeYLTsm6BYTLMGRl0SBjfSWJ@GDzI@tPXlLQ0ah4rlKF@qmWvcO03a@AqAEIBMADIByASwNoA/34Dpjq2Md3sIraotzw6@LHX542e5qRJyEh@YT/rRRNHzfnMgeVFTnL@cDru8JpYVw2PP4bFn@a5OK/KtLFKKT5rw9L14EiSEDpUoJBlppcVjth7A9mPYeQy7j2HvMewL@PoX" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.dyalog.com/" rel="nofollow noreferrer">APL (Dyalog Classic)</a>, 33 bytes</h1>



<pre class="lang-apl prettyprint-override"><code>{⊃⌽,(⊢⌊⍵+(⍉3⌊/⊣/,⊢,⊢/)⍣2)⍣≡+\+⍀⍵}
</code></pre>

<p><a href="https://tio.run/##VVDbSsNAEH33K@YtCW1ps5ds1m/xJVQqxUCl7YtIQVAKjY3ogx9g@w19EfyZ@ZF4ZjfeOJvJyWT2zJypburR5W1VL65G07parebTjp/f5gvevky6GeIdNw@8/xym3Bx433B7GqTc7jT4mJvjeIi8POOM26OSwLv3wcWA23vUbrpuHUTaE@8OS9AZtx/nyaya1wkY8kt@ekwW18nmLOXta5oTkPWvbE06ph15KgCTpQVZfORUoGpCjhAM6Sw1pABNLks9iNwwoqDKKKHIKFEQeU1aU98K93JUWx/7OqnpuehoHwdRLspY/HdQwSS5Ihxl45G2RqgncBc5Oihp0SM4Mn@cSh9Pgr4h8I/8LCK33zasxQbi@MEMMgW497/HikULU2EnSlLBtS1lLCpjeZisgCFsFrZLiCKrg6LsFDC9mrPk4NuRK8l5KidU5nJf6oLLUK1k0MJ9AQ" rel="nofollow noreferrer" title="APL (Dyalog Classic) – Try It Online">Try it online!</a></p>

<p><code>{ }</code> function with argument <code>⍵</code></p>

<p><code>+\+⍀⍵</code> take partial sums by row and by column to establish a pessimistic upper bound on path distances</p>

<p><code>( )⍣≡</code> repeat until convergence:</p>

<ul>
<li><p><code>(⍉3⌊/⊣/,⊢,⊢/)⍣2</code> min of distances to neighbours, i.e. do twice (<code>( )⍣2</code>): prepend leftmost column (<code>⊣/,</code>) to self (<code>⊢</code>) and append rightmost columns (<code>,⊢/</code>), find minima in horizontal triples (<code>3⌊/</code>) and transpose (<code>⍉</code>)</p></li>
<li><p><code>⍵+</code> add each node's value to its min of distances to neighbours</p></li>
<li><p><code>⊢⌊</code> try to beat the current best distances</p></li>
</ul>

<p><code>⊃⌽,</code> finally, return the bottom right cell</p>
</div>
<div id="pu2" class="pu"><h1>Octave + Image Processing package, <s>175</s> <s>162</s> <s>157</s> <s>151</s> <s>142</s> 139 bytes</h1>
<p>Saved 14 bytes thanks to <a href="https://codegolf.stackexchange.com/users/36398/luis-mendo">@Luis Mendo</a> and 1 byte thanks to <a href="https://codegolf.stackexchange.com/users/63641/notjagan">@notjagan</a></p>
<pre class="lang-matlab prettyprint-override"><code>function P(G)A=inf(z=size(G));A(1)=G(1);for k=G(:)'B=im2col(padarray(A,[1,1],inf),[3,3])+G(:)';B(5,:)-=G(:)';A=reshape(min(B),z);end,A(end)
</code></pre>
<p>Uses the Image Processing package, because why not? Isn't that how everybody solves graph problems?</p>
<p><a href="https://tio.run/##JYvNCsIwEITvPsXe3MUIpq0tuuSQXnrtvfQQ2hSDmkr9AfvydVUGvpmBmbF7uJdfluEZu0cYI9RYkTUhDjibe5i9VGKLmkwl4GGc4CzxSOvShGvSjRe8ud5Nk3ujVY1WulXyJtWkKm1p85tyiXt1pO3/yNZM/n5yN4/XELEkNRP72CuLQloEvKqxKeAAuSjjHPaSNeSsd1CAIIOUM0hEKRR8EP@us5aWDw" rel="nofollow noreferrer">Try it online!</a></p>
<p><strong>Exploded</strong></p>
<pre class="lang-matlab prettyprint-override"><code>function P(G)
   A=inf(z=size(G));         % Initialize distance array to all Inf
   A(1)=G(1);                % Make A(1) = cost of start cell
   for k=G(:)'               % For a really long time...
      B=im2col(padarray(A,[1,1],inf),[3,3])+G(:)';
       %  B=padarray(A,[1,1],inf);     % Add border of Inf around distance array
       %  B=im2col(B,[3,3]);           % Turn each 3x3 neighborhood into a column
       %  B=B+G(:)';                   % Add the weights to each row
      B(5,:)-=G(:)';         % Subtract the weights from center of neighborhood
      A=reshape(min(B),z);   % Take minimum columnwise and reshape to original
   end
   A(end)                    % Display cost of getting to last cell
</code></pre>
<hr />
<p><strong>Explanation</strong></p>
<p>Given an array of weights:</p>
<pre><code>7   12    6    2    4
5   13    3   11    1
4    7    2    9    3
4    2   12   13    4
9    2    7    9    4
</code></pre>
<p>Initialize a cost array so that the cost to reach every element is Infinity, except the starting point (the upper left element) whose cost is equal to its weight.</p>
<pre><code>  7   Inf   Inf   Inf   Inf
Inf   Inf   Inf   Inf   Inf
Inf   Inf   Inf   Inf   Inf
Inf   Inf   Inf   Inf   Inf
Inf   Inf   Inf   Inf   Inf
</code></pre>
<p>This is iteration 0. For each subsequent iteration, the cost to reach a cell is set to the minimum of:</p>
<ul>
<li>the current cost to reach that element, and</li>
<li>the current cost to reach the element's neighbors + the weight of the element</li>
</ul>
<p>After the first iteration, the cost of the path to element (2,2) (using 1-based indexing) will be</p>
<pre><code>minimum([  7   Inf   Inf]   [13  13  13]) = 20
        [Inf   Inf   Inf] + [13   0  13]
        [Inf   Inf   Inf]   [13  13  13]
</code></pre>
<p>The full cost array after the first iteration would be:</p>
<pre><code>  7    19   Inf   Inf   Inf
 12    20   Inf   Inf   Inf
Inf   Inf   Inf   Inf   Inf
Inf   Inf   Inf   Inf   Inf
Inf   Inf   Inf   Inf   Inf
</code></pre>
<p>After iteration <code>k</code>, each element will be the lowest cost of reaching that element from the start taking at most <code>k</code> steps. For example, the element at (3,3) can be reached in 2 steps (iterations) for a cost of 22:</p>
<pre><code>  7    19    25   Inf   Inf
 12    20    22   Inf   Inf
 16    19    22   Inf   Inf
Inf   Inf   Inf   Inf   Inf
Inf   Inf   Inf   Inf   Inf
</code></pre>
<p>But on the 4th iteration, a path of 4 steps is found with a cost of 20:</p>
<pre><code> 7   19   25   24   28
12   20   22   32   25
16   19   20   30   34
20   18   30   34   35
27   20   25   40   39
</code></pre>
<p>Since no path through the <em>mxn</em> matrix can be longer than the number of elements in the matrix (as a very loose upper bound), after <code>m*n</code> iterations every element will contain the cost of the shortest path to reach that element from the start.</p>
</div>
<div id="pu3" class="pu"><h2>Mathematica 279 Bytes</h2>

<p>Basic idea is to create a graph with vertices corresponding to matrix entries and directed edges between any two vertices separated by a <code>ChessboardDistance</code> greater than zero but less than or equal to 1. Incidentally, this happens to be known as a <a href="http://mathworld.wolfram.com/KingGraph.html" rel="nofollow noreferrer">King graph</a>, since it corresponds to the valid moves of a king on a chessboard.</p>

<p><code>FindShortestPath</code> is then used to get the minimal path.  It works on <code>EdgeWeight</code>, not <code>VertexWeight</code>, so there is some extra code to define the <code>EdgeWeight</code> as the matrix entry corresponding to the destination of each directed edge.</p>

<p>Code:</p>

<pre><code>(m=Flatten[#];d=Dimensions@#;s=Range[Times@@d];e=Select[Tuples[s,2],0&lt;ChessboardDistance@@(#/.Thread[s-&gt;({Ceiling[#/d[[1]]],Mod[#,d[[1]],1]}&amp;/@s)])≤1&amp;];Tr[FindShortestPath[Graph[s,#[[1]]-&gt;#[[2]]&amp;/@e,EdgeWeight-&gt;(Last@#&amp;/@Map[Extract[m,#]&amp;,e,{2}])],1,Last@s]/.Thread[s-&gt;m]])&amp;
</code></pre>

<p>Note that the <code></code> character is the transpose symbol.  It will paste into Mathematica as-is.</p>

<p>Usage:</p>

<pre><code>%@{{2, 55, 5, 3, 1, 1, 4, 1},
  {2, 56, 1, 99, 99, 99, 99, 5},
  {3, 57, 5, 2, 2, 2, 99, 1},
  {3, 58, 4, 2, 8, 1, 99, 2},
  {4, 65, 66, 67, 68, 3, 99, 3},
  {2, 5, 4, 3, 3, 4, 99, 5},
  {75, 76, 77, 78, 79, 80, 81, 2},
  {5, 4, 5, 1, 1, 3, 3, 2}}
</code></pre>

<p>Output:</p>

<pre><code>67
</code></pre>

<p>If you set <code>g=Graph[...,GraphLayout-&gt;{"GridEmbedding","Dimension"-&gt;d},VertexLabels-&gt;Thread[s-&gt;m]</code> and <code>p=FindShortestPath[...</code> then the following graphic will visually display the solution (top of the matrix corresponds to the bottom of the graph):</p>

<pre><code>HighlightGraph[g,PathGraph[p,Thread[Most@p-&gt;Rest@p]]]
</code></pre>

<p><a href="https://i.sstatic.net/DWiiz.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/DWiiz.gif" alt="enter image description here"></a></p>
</div>
<div id="pu4" class="pu"><h1>Python 2, <s>356</s> 320 bytes</h1>



<pre class="lang-python prettyprint-override"><code>s=input()
r=lambda x:[x-1,x,x+1][-x-2:]
w=lambda z:[z+[(x,y)]for x in r(z[-1][0])for y in r(z[-1][1])if x&lt;len(s)&gt;0==((x,y)in z)&lt;len(s[0])&gt;y]
l=len(s)-1,len(s[0])-1
f=lambda x:all(l in y for y in x)and x or f([a for b in[l in z and[z]or w(z)for z in x]for a in b])
print min(sum(s[a][b]for(a,b)in x)for x in f([[(0,0)]]))
</code></pre>

<p><a href="https://tio.run/##TY/BasMwEETv/godtWQNlkOhmCo/suxBJjE1yIpxHCLr592VQt2eVpqZ1RvN2/p9D@2@P@wY5ueqoVqsd1N/dSp2FGuDEePJMNWxbjuuXr9u6iidSEfcgIf7oqIag1p0olrCDUPWtv@aYRgHFb/8LegHXBprddmWSIK3mvcuG1fevkNCP/TaVMNfM@e99vn1TR2gCC5cpYfcB02uGL0YVIJJiUuJRXzpVOqlslXau3zsGap5GcOqplGoz0nIjqnPCe2whwI5PisQ0g02wAyw70QGDZ4ZZX5gW@YnGuYf" rel="nofollow noreferrer">Try it here!</a></p>

<p>-36 bytes thanks to <a href="https://codegolf.stackexchange.com/users/63641/notjagan">notjagan</a>!</p>

<p>Receives a list of lists as an input, and outputs the lowest cost when navigating the matrix from the upper left to the bottom right.</p>

<h2>Explanation</h2>

<p>Find every possible route from the upper left to the bottom right of the matrix, creating a list of x,y coordinates for each route. The routes cannot backtrack, and they must end at <code>(len(s)-1,len(s[0])-1)</code>. </p>

<p>Sum the integers on each path of coordinates, and return the minimum cost.</p>

<p>The <code>print</code> can be easily changed to output the list of coordinates for the shortest route.</p>
</div>
<div id="pu5" class="pu"><h1>Haskell, 228 bytes</h1>

<p>Positions are lists of two elements, because those are easy to generate with <code>sequence</code> and just as easy to pattern match as 2-tuples.</p>

<pre><code>h=g[[-1,-1]]
g t@(p:r)c|p==m=0|1&lt;2=minimum$(sum$concat c):(\q@[a,b]-&gt;c!!a!!b+g(q:t)c)#(f(e$s$(\x-&gt;[0..x])#m)$f(not.e t)$zipWith(+)p#s[[-1..1],[-1..1]])where m=[l(c)-1,l(head c)-1]
(#)=map
f=filter
e=flip elem
s=sequence
l=length
</code></pre>

<p>Start at <code>-1,-1</code> and count the cost of each steps destination field.</p>

<p>Alternative first two lines: start at <code>0,0</code>, count the departure fields, terminate at the coordinates equal to the matrix dimensions (so down-right from the goal, which needs to be added to the list of legal destinations) - exact same length but slower:</p>

<pre><code>j=i[[0,0]]
i t@(p@[a,b]:r)c|p==m=0|1&lt;2=c!!a!!b+(minimum$(sum$concat c):(\q-&gt;i(q:t)c)#(f(e$m:(s$(\x-&gt;[0..x-1])#m))$f(not.e t)$zipWith(+)p#s[[-1..1],[-1..1]]))where m=[l c,l$head c]
</code></pre>

<p>Using an infix for <code>map</code> does not save bytes here but I substitute it as soon as it doesn't cost one, because it can only get better with more uses, and sometimes with other restructurings as well which shave off another pair of parentheses.</p>

<p>To be improved: Redundant <code>filter</code>s. Merging/in-lining them to <code>filter(flip elem$(s$(\x-&gt;[0..x])#m)\\p)</code> with <code>import Data.List</code> for <code>\\</code> costs 3 bytes.</p>

<p>Also, too bad <code>(fromEnumTo 0)</code> is 2 bytes longer than <code>(\x-&gt;[0..x])</code>.</p>

<p><code>sum$concat c</code> is all fields' cost summed up and thus a concisely expressible upper bound on the path cost which is given to the <code>minimum</code> to avoid an empty list (my type checker has already determined the whole thing to work on <code>Integer</code>s, so no hard-coding the maximum, hehe). No matter how I restrict steps based on the previous one made (which would speed up the algorithm a lot, but also cost bytes), I can not avoid the dead ends that make this fall-back necessary.</p>

<ul>
<li><p>One filter idea was <code>((not.e n).zipWith(-)(head r))</code> with extracting <code>n=s[[-1..1],[-1..1]]</code>, which necessitates adding <code>,[-1,-1]</code> to the initial path. The algorithm then avoids going where it could already have gone in the previous step, which makes stepping on an edge field orthogonally to that edge a dead end.</p></li>
<li><p>Another was <code>((&gt;=0).sum.z(*)d)</code> with extracting <code>z=zipWith</code>, which introduces a new argument <code>d</code> to the recursive function that is given as <code>(z(-)p q)</code> in the recursion and <code>[1,1]</code> in the initial case. The algorithm avoids successive steps with a negative scalar product (<code>d</code> being the previous step), which means no sharp 45°-turns. This still narrows down the choices considerably, and avoids the previous trivial dead end, but there are still paths that end up enclosed in already-visited fields (and possibly an 'escape' which however would be a sharp turn).</p></li>
</ul>
</div>
<div id="pu6" class="pu"><h1>JavaScript, <s>442 412 408</s> 358 bytes</h1>
<p>This is my first PPCG submission. Feedback would be appreciated.</p>
<pre><code>(m,h=m.length,w=m[0].length)=&gt;{for(i=0;i&lt;h*w;i++)for(x=0;x&lt;w;x++){for(y=0;y&lt;h;y++){if(m[y][x]%1==0)m[y][x]={c:m[y][x],t:m[y][x]};for(X=-1;X&lt;=1;X++)for(Y=-1;Y&lt;=1;Y++){t=x+X;v=y+Y;if((X==0&amp;&amp;Y==0)||t&lt;0||t&gt;=w||v&lt;0||v&gt;=h)continue;if(m[v][t]%1==0)m[v][t]={c:m[v][t],t:null};c=m[y][x].t+m[v][t].c;if (c&lt;m[v][t].t||m[v][t].t==null)m[v][t].t=c}}}return m[h-1][w-1].t}
</code></pre>
<p>This takes a multi-dimensional array as input.</p>
<h1>Explanation</h1>
<p>Basically, loop through all of the cells over and over adjusting the lowest known cost to get to each of the neighbors. Eventually, the grid will reach a state where the total cost to reach the bottom right is the lowest cost to get there.</p>
<h1>Demo</h1>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>f=(m,h=m.length,w=m[0].length)=&gt;{for(i=0;i&lt;h*w;i++)for(x=0;x&lt;w;x++){for(y=0;y&lt;h;y++){if(m[y][x]%1==0)m[y][x]={c:m[y][x],t:m[y][x]};for(X=-1;X&lt;=1;X++)for(Y=-1;Y&lt;=1;Y++){t=x+X;v=y+Y;if((X==0&amp;&amp;Y==0)||t&lt;0||t&gt;=w||v&lt;0||v&gt;=h)continue;if(m[v][t]%1==0)m[v][t]={c:m[v][t],t:null};c=m[y][x].t+m[v][t].c;if (c&lt;m[v][t].t||m[v][t].t==null)m[v][t].t=c}}}return m[h-1][w-1].t}

//Tests
console.log(f([[1,1,1],[1,1,1]])===3);
console.log(f([[7,9,6,6,4],[6,5,9,1,6],[10,7,10,4,3],[4,2,2,3,7],[9,2,7,9,4]])===28);
console.log(f([[2,42,6,4,1],[3,33,1,1,1],[4,21,7,59,1],[1,7,6,49,1],[1,9,2,39,1]])===27);
console.log(f([[5,6,7,4,4],[12,12,25,25,25],[9,4,25,9,5],[7,4,25,1,12],[4,4,4,4,4]])===34); 
console.log(f([[1,1,1,1],[9,9,9,1],[1,9,9,9],[1,9,9,9],[1,1,1,1]])===15)
console.log(f([[2,55,5,3,1,1,4,1],[2,56,1,99,99,99,99,5],[3,57,5,2,2,2,99,1],[3,58,4,2,8,1,99,2],[4,65,66,67,68,3,99,3],[2,5,4,3,3,4,99,5],[75,76,77,78,79,80,81,2],[5,4,5,1,1,3,3,2]])===67);</code></pre>
</div>
</div>
</p>
<p>Edit: Special thanks to <a href="https://codegolf.stackexchange.com/users/42545/ethproductions">@ETHproductions</a> for helping me shave dozens of tasty bytes.</p>
<p>More thanks to <a href="https://codegolf.stackexchange.com/users/31516/stewie-griffin">@Stewie Griffin</a> for your tips that knocked off 50 bytes.</p>
</div>
<div id="pu7" class="pu"><h1><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python 3</a> + <a href="http://numpy.org" rel="nofollow noreferrer">numpy</a> + <a href="https://www.scipy.org/" rel="nofollow noreferrer">scipy</a>, <strike>239</strike> <strike>222</strike> 186 bytes</h1>



<pre class="lang-python prettyprint-override"><code>from numpy import*
from scipy.sparse.csgraph import*
def f(M):m,n=s=M.shape;x,y=indices(s);return dijkstra([(M*(abs(i//n-x)&lt;2)*(abs(i%n-y)&lt;2)).flatten()for i in range(m*n)])[0,-1]+M[0,0]
</code></pre>

<p><a href="https://tio.run/##bVTbjtsgEH3nK5ClSuA62eC7s80n5AvSPLCJs6GNiQVeaf31KQMYr7d58Jg5zJw5w60fh@tdZo/HRd07LD@6fsSi6@9qiJGF9En041r3XOl2fdLvivfXEHFuL/hC9nTbJXKnd/u1vvK@ff1Mxp2QZ3FqNdH0VbXDh5L4LP781YPi5ED2MeFvmoiXF7n6pL9S6v0fcjWCS9eXGx@GVhJ6uSsssJBYcfneki6W9EgPm2TFjj/35r85PiBEQ8ghiiKEWYwxbsyHKzCZ@dgGRqk1yDk5RLGlsfE1sim4nJJxjSfCwkYhi3zhLMLI0uTIISyYmdCWaGJklK5V29/4qSVRHCU4imgCKGI@iX0ZGdxN@vxAZ42pVwYZTSha@k6rIDa3WpD7p8FYdaarJiBzlXyubWby1NfMrSyTmGWTSIsYPGWOoGhCE5XLymekcZWy5lt7xXKhcieBQVlr0mI2XnA@IX6L0Jyahm1gqe/6u5lrs0UjjedbSrbfE@/ZToHcogj7ki1PhK3OfFQ5wU3zv4GOILmolkctGBfFfFQd2NNwdgM19stQAk0JZUu7N/Wk0EVl6Mu5zoP6bHInXRUEVEBTAU0FNBXM1XDcauYrzjTPrkXmosyaHbcI73dcKT6Sw03ogXS8J0IOCb4J2ZpH6CYGQinFcOMBgkuvPR79lhE9sK15GI4U4V6ZRPM0TSN4poJDH/8A" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
</div>
<div id="pu8" class="pu"><h1>JavaScript, 197 bytes</h1>

<pre><code>a=&gt;(v=a.map(x=&gt;x.map(_=&gt;1/0)),v[0][0]=a[0][0],q=[...(a+'')].map(_=&gt;v=v.map((l,y)=&gt;l.map((c,x)=&gt;Math.min(c,...[...'012345678'].map(c=&gt;a[y][x]+((v[y+(c/3|0)-1]||[])[x+c%3-1]||1/0)))))),v.pop().pop())
</code></pre>

<p>Prettify:</p>

<pre><code>a=&gt;(
  // v is a matrix holds minimal distance to the left top
  v=a.map(x=&gt;x.map(_=&gt;1/0)),
  v[0][0]=a[0][0],
  q=[
     // iterate more than width * height times to ensure the answer is correct
    ...(a+'')
  ].map(_=&gt;
    v=v.map((l,y)=&gt;
      l.map((c,x)=&gt;
        // update each cell
        Math.min(c,...[...'012345678'].map(
          c=&gt;a[y][x]+((v[y+(c/3|0)-1]||[])[x+c%3-1]||1/0)
        ))
      )
    )
  ),
  // get result at right bottom
  v.pop().pop()
)
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/139463/">139463</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




