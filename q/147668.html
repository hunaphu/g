<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::147668</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>075</td><td>JavaScript Node.js</td><td>250208T112458Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/278139#278139">l4m2</a></td></tr>
<tr d-ix="1"><td>011</td><td>Maple</td><td>230527T014707Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/261263#261263">138 Aspe</a></td></tr>
<tr d-ix="2"><td>006</td><td>Pari/GP</td><td>171112T075844Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147848#147848">alephalp</a></td></tr>
<tr d-ix="3"><td>003</td><td>R</td><td>171110T135850Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147677#147677">Giuseppe</a></td></tr>
<tr d-ix="4"><td>098</td><td>Proton</td><td>171110T140125Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147679#147679">hyperneu</a></td></tr>
<tr d-ix="5"><td>023</td><td>05AB1E</td><td>200331T120950Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/202866#202866">Kevin Cr</a></td></tr>
<tr d-ix="6"><td>176</td><td>Java OpenJDK 8</td><td>171114T194546Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/148078#148078">ceilingc</a></td></tr>
<tr d-ix="7"><td>091</td><td>JavaScript ES6</td><td>171113T113437Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147910#147910">edc65</a></td></tr>
<tr d-ix="8"><td>128</td><td>APLNARS</td><td>181021T165220Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/174417#174417">user5898</a></td></tr>
<tr d-ix="9"><td>045</td><td>CJam</td><td>181020T195013Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/174391#174391">Peter Ta</a></td></tr>
<tr d-ix="10"><td>010</td><td>Jelly</td><td>171110T161959Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147713#147713">Dennis</a></td></tr>
<tr d-ix="11"><td>034</td><td>MY</td><td>171110T151557Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147702#147702">Adalynn</a></td></tr>
<tr d-ix="12"><td>258</td><td>Java 8</td><td>171110T162743Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147718#147718">Kevin Cr</a></td></tr>
<tr d-ix="13"><td>141</td><td>Clojure</td><td>171114T213014Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/148100#148100">NikoNyrh</a></td></tr>
<tr d-ix="14"><td>149</td><td>Python 3</td><td>171114T203350Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/148087#148087">Bolce Bu</a></td></tr>
<tr d-ix="15"><td>071</td><td>Haskell</td><td>171110T154750Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147709#147709">totallyh</a></td></tr>
<tr d-ix="16"><td>nan</td><td>SageMath</td><td>171113T113644Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147911#147911">user4594</a></td></tr>
<tr d-ix="17"><td>043</td><td>Jelly</td><td>171110T145238Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147693#147693">user2027</a></td></tr>
<tr d-ix="18"><td>050</td><td>Excel VBA</td><td>171110T145640Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147696#147696">Taylor R</a></td></tr>
<tr d-ix="19"><td>216</td><td>Python 3</td><td>171110T144250Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147689#147689">Кирилл М</a></td></tr>
<tr d-ix="20"><td>125</td><td>C</td><td>171110T145016Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147692#147692">Steadybo</a></td></tr>
<tr d-ix="21"><td>075</td><td>Python 2</td><td>171111T170530Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147821#147821">xnor</a></td></tr>
<tr d-ix="22"><td>059</td><td>Haskell</td><td>171111T164914Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147820#147820">xnor</a></td></tr>
<tr d-ix="23"><td>052</td><td>Wolfram Language Mathematica</td><td>171110T214649Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147752#147752">Misha La</a></td></tr>
<tr d-ix="24"><td>015</td><td>Jelly</td><td>171110T173853Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147723#147723">Leaky Nu</a></td></tr>
<tr d-ix="25"><td>095</td><td>Python 2</td><td>171110T162101Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147714#147714">totallyh</a></td></tr>
<tr d-ix="26"><td>062</td><td>Haskell</td><td>171111T130217Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147805#147805">Christia</a></td></tr>
<tr d-ix="27"><td>032</td><td>R</td><td>171111T092215Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147797#147797">JAD</a></td></tr>
<tr d-ix="28"><td>133</td><td>TIBasic 83 series</td><td>171111T065738Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147788#147788">Misha La</a></td></tr>
<tr d-ix="29"><td>1442</td><td>Wolfram Language Mathematica</td><td>171110T232117Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147760#147760">Not a tr</a></td></tr>
<tr d-ix="30"><td>035</td><td>MATL</td><td>171110T145902Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147697#147697">Luis Men</a></td></tr>
<tr d-ix="31"><td>002</td><td>Jelly</td><td>171110T135335Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147670#147670">Erik the</a></td></tr>
<tr d-ix="32"><td>028</td><td>Octave</td><td>171110T151402Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147701#147701">Luis Men</a></td></tr>
<tr d-ix="33"><td>024</td><td>Jelly</td><td>171110T150008Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147698#147698">hyperneu</a></td></tr>
<tr d-ix="34"><td>005</td><td>J</td><td>171110T150510Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147699#147699">Galen Iv</a></td></tr>
<tr d-ix="35"><td>002</td><td>TIBasic</td><td>171110T145553Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147695#147695">totallyh</a></td></tr>
<tr d-ix="36"><td>030</td><td>Octave</td><td>171110T144532Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147690#147690">Stewie G</a></td></tr>
<tr d-ix="37"><td>003</td><td>Julia</td><td>171110T143057Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147686#147686">Uriel</a></td></tr>
<tr d-ix="38"><td>029</td><td>Python 2 + numpy</td><td>171110T141207Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147682#147682">Mr. Xcod</a></td></tr>
<tr d-ix="39"><td>003</td><td>Wolfram Language Mathematica</td><td>171110T135454Z</td><td><a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147671#147671">user2027</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 75 bytes</h1>

<pre class="lang-none prettyprint-override"><code>q=(a,i=0,j=1,s=0)=&gt;a+a?a.map(e=&gt;s-=e[i]*q(a.filter(_=&gt;_!=e),i+1,j=-j))&amp;&amp;s:j
</code></pre>
<p><a href="https://tio.run/##TZLBjtwgEETv/gpy2bGzYAENGCLhHKL8QW6OtYsmbOKJM561R3uJ8u2TbjORckFQXfUoYZ/SW9qO63S5ivPyLd9ur7FOfIqSn6LiW5RN7NNj@pjaX@lS59hvIuZhGt@/1ql9meZrXuun2D@9i7nh06PCmDg1zcPD9uF0q6ovebt@Slve4vMwGD2OTPTM6GoYNGcwcjYozkyRLap4@jcwnFnOHG07zjxnodgk2YAzhao2OyLg6Z4SmMGkLF5lAdAOHUKFspoSe0SEjpSAMeVtCSJTQNG1uzd11njw@5VS4kTTaj11Lt1FINlaSrkCcoTwSNNAxbwmVYOnOMngsSCE@2PYTkntjKU7DGBDgywApGry6W5/AWECjaidAthJYV/L0JBk9m4OHZY6gSpJMHSdQp0QWiJeyb2@7hAHkuoaZ/a3oa2@NxNWGeOkci4EZc1z1W6XebrWh6/nQ/Pfp21flvVzOv6o19j/rhgbEv85ssjW4mf1gWgYYSyhnN/SXCc6HZfztsy5nZfvNf5OTVP9aW5/AQ" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.maplesoft.com/products/Maple/" rel="nofollow noreferrer">Maple</a>, 11 bytes</h1>
<p><a href="https://www.maplesoft.com/support/help/maple/view.aspx?path=LinearAlgebra%2FDeterminant" rel="nofollow noreferrer">Documentaiton</a></p>
<pre><code>Determinant
</code></pre>
<pre><code>LinearAlgebra[Determinant](Matrix([[2, 3, 1], [3, 2, 3], [0, 3, 2]]));
LinearAlgebra[Determinant](LinearAlgebra[HilbertMatrix](4));
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="http://pari.math.u-bordeaux.fr/" rel="nofollow noreferrer">Pari/GP</a>, 6 bytes</h1>
<pre><code>matdet
</code></pre>
<p><a href="https://tio.run/##PVHJagMxDP0VHxOwwVq8iKFfEnoItCk5tAxh/n@ip2lyEbYsvcVvvT7u5Wfdb@kj7b/X7et729fH/W873U6XWXOiZjlJ55yK@LWwelGTnJT8zurPhQil2oIjpogFYx19wQb37liGYZXhy9q82MzJ@pJoNDxU9ARUA8QoHezSgTA6jgPHWsFU0ZYRAjBcAv@gpuEwpM4vjGZzJgmBQoEmAOZAC1HT59kgdQYsd@gLx9aW1MNEDZ/NZbI4IInfCZu@P8Jw/BOBG758F@1wx5CrAwhBo4d66MIPacWkDRjT@EJYPfYFZpgxSl64BYjbJMLMBJO1SAibSoZ08guJ8a//LukF5xm@qTjacwZrpDcjMkUA2I0cFVmUzp/n8/4E" rel="nofollow noreferrer" title="Pari/GP – Try It Online">Try it online!</a></p>
<hr />
<h1><a href="http://pari.math.u-bordeaux.fr/" rel="nofollow noreferrer">Pari/GP</a>, 52 bytes</h1>
<pre><code>f(a)=if(#a,sum(n=1,#a,-(-1)^n*a[1,n]*f(a[^1,^n])),1)
</code></pre>
<p><a href="https://tio.run/##PVLJasMwEP0VQS92kECzaCPkS0ICvrjkUBPS9PvdeZOml0Eav3mLxvflcUuf930Np7Cv0zKfbuv0scTvn69pO1G0Y5oSzdftsJwpbpeDgc5XitftMs@R5v3@uG3PaZ3OPcdAZcQglWNIYtfEakWHxKBkd1b7nIhQ8jjiCBSxAFbRF0xwrcY1AFZpNqzFyugxjHoM1Ao@ZPQEUg3CKBXqUsHQKo4Nx5yhlNGW5gYATs7/kqZmNKSmL4xmMSVxg0LOJiBmZ3NT3fA8YLU7LVf488SjHEP1ENlzFrPJYoQkdidM2nzzwP5OBG3kslm0PR3DrjYwuIy@3MMXXkgzkKMhmPoTIuprXhCGGVCywsVJLCYRMB1Ko/iGMKk0sJ34ZmK8619KetPZDv@l2Nu9u6pvr/vKFAvArO9RsYtU2f6S/Rc" rel="nofollow noreferrer" title="Pari/GP – Try It Online">Try it online!</a></p>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.r-project.org/" rel="nofollow noreferrer">R</a>, 3 bytes</h1>

<p><em>Trivial Solution</em></p>



<pre class="lang-r prettyprint-override"><code>det
</code></pre>

<p><a href="https://tio.run/##K/r/PyW15P9/AA" rel="nofollow noreferrer" title="R – Try It Online">Try it online!</a></p>

<h1><a href="https://www.r-project.org/" rel="nofollow noreferrer">R</a>, <s>94</s> <s>92</s> 89 bytes</h1>

<p><em>re-implemented solution</em></p>

<p><em>outgolfed by <a href="https://codegolf.stackexchange.com/questions/147668/determinant-of-an-integer-matrix/147797#147797">Jarko Dubbeldam</a></em>
</p>

<pre class="lang-r prettyprint-override"><code>d=function(m)"if"(x&lt;-nrow(m),m[,1]%*%sapply(1:x,function(y)(-1)^y*-d(m[-y,-1,drop=F])),1)
</code></pre>

<p><a href="https://tio.run/##PcrLCoMwEEbhdxGEGflnMamrUrd9CbEgBiFgLqSWJk@fuuryfJzcmp32T9hOFwN57tzeUXlIyPF7JfwMXfqhf68pHZX0XvC/K5Mov@oglvwsFaKwOabpuTBDuV28ntkV2shAccPIMDDM7Qc" rel="nofollow noreferrer" title="R – Try It Online">Try it online!</a></p>

<p>Recursively uses expansion by minors down the first column of the matrix.</p>

<p><pre class="lang-r prettyprint-override"><code>f &lt;- function(m){
 x &lt;- nrow(m)                 # number of rows of the matrix
 if(sum(x) > 1){              # when the recursion reaches a 1x1, it has 0 rows
                              # b/c [] drops attributes
  minor &lt;- function(y){
   m[y] * (-1)^y *
   -d(m[-y,-1])                # recurse with the yth row and first column dropped
   }
  minors &lt;- sapply(1:x,minor) # call on each row
  sum(minors)                 # return the sum
 } else {
  m                           # return the 1x1 matrix
 }
}
</pre></code></p>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/alexander-liao/proton" rel="nofollow noreferrer">Proton</a>, 98 bytes</h1>

<pre><code>f=m=&gt;(l=len(m))-1?sum((-1)**i*m[0][i]*f([[m[k][j]for k:1..l]for j:0..l if j-i])for i:0..l):m[0][0]
</code></pre>

<p><a href="https://tio.run/##HYxBCsMgEEWvMktHNGiTUirYHmSYZQVNjMGm57fR3fsP3j9qOcveWvDZv8Tmt88uMqK27@8vC6EtShllJsMUWQZBlGllShxKhdXZadoGJmcuhBgg6cjYVRwK3YgNt6PG/RT9ws4K7EPBbWEFZJ/XUjB31ncFiwLDjNj@" rel="nofollow noreferrer" title="Proton – Try It Online">Try it online!</a></p>

<p>-3 bytes thanks to Mr. Xcoder<br>
-3 bytes thanks to Erik the Outgolfer<br>
-1 byte thanks to S.S. Anne  </p>

<p>Expansion over the first row</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 23 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>ā&lt;œε©2.ÆíÆ.±Iε®Nèè}«P}O
</code></pre>
<p>Port of <a href="https://codegolf.stackexchange.com/a/147723/52210"><em>@LeakyNun</em>'s Jelly answer</a>.</p>
<p><a href="https://tio.run/##yy9OTMpM/f//SKPN0cnnth5aaaR3uO3w2sNteoc2egL56/wOrzi8ovbQ6oBa////o6MNjXUUDM11FIxMYnUUog0tgTwdBWMQW9dUR8FER8EgNhYA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##NVK7bhRBEMz5CuviGmv6MS8EckJCgomQ0OoCkAhIAAkbicABiX@AnzBCIBHAB9xCyi8d1bNHsHs3PdVV1dX79v2Ll69fHT/sHr95d311/2x38fHRs4f3dpfXV6fz8fenB38@//15@KLn6@36bb09P/x4zvP3J@vdendz@Pr05vKIw6@L47Isrvs9zpZFYXssAt@Ogq3gKKj8begYpyuDNKgHfEAmLBU48nZvTZGkKCGBSaPxOATSy0Qaks2a1hNhzkjKV@mYrEiDlVKIqbOnEt4NatTryopaZwtL1h02TjO4KbzALENZ1xbOkw9WKShm0TPiNevOs4dshRQKmky8OSmlgm2aCySHJ20NlmnDq8dg/KP/VYmtFeZUDRq3SuO@aRNde3DAG@cy41DuMYKUEfKklWiavrzDWuZlpTYV3UllynBnhnMhNSOe5DIjYCg0Y22a9MF@okkmsQVX7krL5pP00xgX23psKLibUWSG3pkCn8QWTmEe7iQUlfPJpsfUNydzgEw1xp0smHTwFZc@ZrqxHC5dudMastrQxmQjR40UNCLX6CKJ8OPa/wM" rel="nofollow noreferrer">verify all but one test cases</a> (the biggest test case times out on TIO).</p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>ā             # Push a list in the range [1, (implicit) input-length]
 &lt;            # Decrease it by 1 to make the range [0, input-length)
  œ           # Get all permutations of this list
   ε          # Map each permutation to:
    ©         #  Store the permutation in variable `®` (without popping)
     2.Æ      #  Get all 2-element combinations of this list
        í     #  Reverse each inner list
         Æ    #  Reduce each by subtraction
          .±  #  And take their signum (-1 if a&lt;0; 0 if a==0; 1 if a&gt;0)
    I         #  Push the input
     ε        #  Map each row to:
      ®       #   Get the current permutation from variable `®`
       Nè     #   Use the map-index to index into this permutation
         è    #   And use that to index into the row
     }«       #  After the map: merge the two lists together
       P      #  And take its product
   }O         # After the outer map: sum all value
              # (after which it is output implicitly as result)
</code></pre>
</div>
<div id="pu6" class="pu"><h1><a href="http://openjdk.java.net/" rel="nofollow noreferrer">Java (OpenJDK 8)</a>, <s>195 192 177</s> 176 bytes</h1>



<pre class="lang-java prettyprint-override"><code>long d(int[][]m){long D=0;for(int i=m.length,l=i-1,t[][]=new int[l][l],j,k;i--&gt;0;D+=m[0][i]*(1-i%2*2)*(l&lt;1?1:d(t)))for(j=l*l;j--&gt;0;)t[j/l][k=j%l]=m[1+j/l][k&lt;i?k:k+1];return D;}
</code></pre>

<p><a href="https://tio.run/##rVZNb9tGEL3nV8wlgGhzbe4Hl7tR1Fx87SlHQQc1Ul1KlGTYdIrC0G93Z97IRoCsiqKqIYjycjjz5r354Gb5fWkOD@v9ZrV9/TYsn57o12W/f/lA9DQux/4bvQ6H/T2tJv1@nC/mi131goO7WTP9/fAox9TPdjfDen8//lEPs97YGpaz/fpPkqeGBX/qTb2d9sb80kzvrme7ebOY94uriTX9R3flqqvJ8Nl@sZ9Wk7GqKnG8mQ1Xw3SDJ6pxvrllN9vZ5uOw4Kfttf7/uf@y/bS9tovp43p8ftzT3fT4SvTw/NvA0E8ZfD/0K9pxVpOv42O/v58vlpUkSPT1r6dxvbs5PI83D3xnHPaT1eQNNqegVkTvRy/BHXF2rKrpf3ThavLH@qdjW1O42Dc7OeM@1NTWFAt3uppSTfny2L4my85cKGWXayJGV8RmGBkxQGouBuE7zt/Ylr8ZSAmJyZ1YZAFjU1uEw5kYr3YuXk5M07AnJ9/UMtX8VwKm/Jgsxm0rsWMRXezELDFG58FqcgUz55MEFTOfhFufLy/d4J3CF8G8l4QcnLuuVFkmZLEPwiRZ7wFIIPOlaB7EJIAoaqM81Aob3ha9@4C8rBgSIrlGgNmmRK/rBAX5RmQNMWiByG/3PxCjICjKxQcQA@jBR1EylOkBCopJQQtVnZV8vcgfQklX24LAIGlw7oghnBoXxI3vmsJDUWVTCkIQSN4JVRwQzVCcGBE64GKCTaqbZOaFNt8VWQ4ZLHdoaYht0ZLBefnt2ou55kyVU4d8E/odKXUe6RXnT4JAejHA0iI9L4A5vRID7qSqNOaJAX/qX6WtKFCjDEiPGA9gLiMqHgq5WPpoVK5ii8pBkIgsHaq2y0V4SQVCtTh0iouoHGhrL5/pkqPIFlCW0DZoGo0HkVZzLaFD@RjtN4/mh0CMMcBlAIWlcvUN3J46VguVoDNObBLPoSlOx9BAM5MxNyCZh1gnshDVFbeQa3RCCEirPeUyQMKlqMLy2WJUB5OgTYKuRtVjCJAFFb7N5ahof5UvtdAfi9K5N85Z0PSDlLe3/05MtfsxGIiTqZqJao@pYDDFgZmTQwNZjC@IzbQJAY0g/9kd322UToxUrC/MBoc5aDOwex06GAgZIuRYdGcxNFhBmOqqMRC8xXfMUBMd1cV3ZXmxnkHX6FSAhq12LAYS8GIsaWUz1zhH3/lzyWLRGN25Hm1pUB4hYfXkgLUc37qQk8Xaz23RnY5@Bg@CW@iO4WK9vplgaCZdVqgEC7xnuOM4YqoMOvQAdgk3AnDpzO@0H7BpUOz8MnSGuwBloZ26xpsVOWwAbSytU4OisRaW6Qy63Gqp6SrBgMRI0TC6tunEpn0PxgX5T@hcQvyEprPQ1OGlB9zaCE4jZjdKx0Re9OrtNBKPH46vfwM" rel="nofollow noreferrer" title="Java (OpenJDK 8) – Try It Online">Try it online!</a></p>

<p>Like many other answers, this also uses the Laplace formula. A slightly less golfed version:
</p>

<pre class="lang-java prettyprint-override"><code>long d(int[][]m){
  long D=0;
  int i=m.length,l=i-1,t[][]=new int[l][l],j,k
  for(;i--&gt;0;)
    for(j=l*l;j--&gt;0;)
      t[j/l][k=j%l]=m[1+j/l][k&lt;i?k:k+1];
    D+=m[0][i]*(1-i%2*2)*(l&lt;1?1:d(t));
  return D;
}
</code></pre>
</div>
<div id="pu7" class="pu"><h1>JavaScript (ES6), 91</h1>
<p>Recursive Laplace</p>
<pre class="lang-js prettyprint-override"><code>q=(a,s=1)=&gt;+a||a.reduce((v,[r],i)=&gt;v-(s=-s)*r*q(a.map(r=&gt;r.slice(1)).filter((r,j)=&gt;j-i)),0)
</code></pre>
<p><em>Less golfed</em></p>
<pre class="lang-js prettyprint-override"><code>q = (a,s=1) =&gt; // s used as a local variable
  a[1] // check if a is a single element array 
       // if array, recursive call expanding along 1st column
  ? a.reduce((v,[r],i) =&gt; v-(s=-s)*r*q(a.map(r=&gt;r.slice(1)).filter((r,j)=&gt;j-i)),0) 
  : +a // single element, convert to number
</code></pre>
<p><strong>Test</strong></p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>q=(a,s=1)=&gt;+a||a.reduce((v,[r],i)=&gt;v-(s=-s)*r*q(a.map(r=&gt;r.slice(1)).filter((r,j)=&gt;j-i)),0)

TestCases=`[[42]] -&gt; 42
[[2, 3], [1, 4]] -&gt; 5
[[1, 2, 3], [4, 5, 6], [7, 8, 9]] -&gt; 0
[[13, 17, 24], [19, 1, 3], [-5, 4, 0]] -&gt; 1533
[[372, -152, 244], [-97, -191, 185], [-53, -397, -126]] -&gt; 46548380
[[100, -200, 58, 4], [1, -90, -55, -165], [-67, -83, 239, 182], [238, -283, 384, 392]] -&gt; 571026450
[[432, 45, 330, 284, 276], [-492, 497, 133, -289, -28], [-443, -400, 56, 150, -316], [-344, 316, 92, 205, 104], [277, 307, -464, 244, -422]] -&gt; -51446016699154`
.split('\n')

TestCases.forEach(r=&gt;{
  [a,k] = r.split (' -&gt; ')
  a = eval(a)
  d = q(a)
  console.log('Test '+(k==d ? 'OK':'KO')+
    '\nMatrix '+a.join('|')+
    '\nResult '+d+
    '\nCheck  '+k)
})</code></pre>
</div>
</div>
</p>
</div>
<div id="pu8" class="pu"><h1>APL(NARS), 64 chars, 128 bytes</h1>
<pre><code>{1≥k←↑⍴w←⍵:⍵⋄2=k:-/⌽w[2;]×⌽w[1;]⋄v←⍳k⋄-/w[1;]×∇¨{w[v∼1;v∼⍵]}¨⍳k}
</code></pre>
<p>This would be the formula used in the schools, it is easy, much easier than i tought...
if w is a 2x2 matrix -/⌽w[2;]×⌽w[1;] rotate first row multiply with second row than reverse
and make difference in pratice it does: (w[1;1]×w[2;2])-w[1;2]×w[2;1]
else if it is a matrix nxn with n&gt;2 multiply the first row with its adjunt Matrix (if i remember well the name), and make -/;
test:</p>
<pre><code>  D←{1≥k←↑⍴w←⍵:⍵⋄2=k:-/⌽w[2;]×⌽w[1;]⋄v←⍳k⋄-/w[1;]×∇¨{w[v∼1;v∼⍵]}¨⍳k}
  D ⊃(1 9 3)(4 ¯5  6)(7 8 9)
162
  D 3 3 ⍴ ⍳20
0
  D ⊃(1 0)(0 1)
1
  D ,89
89 
  D  1
1
  D 'ac'
RANK ERROR
</code></pre>
</div>
<div id="pu9" class="pu"><h2>CJam (<strike>50</strike> 45 bytes)</h2>

<pre><code>{:A_,{1$_,,.=1b\)/:CAff*A@zf{\f.*1fb}..-}/;C}
</code></pre>

<p>This is an anonymous block (function) which takes a 2D array on the stack and leaves an integer on the stack.</p>

<p><a href="http://cjam.aditsu.net/#code=q&#39;%2C-~%5D2%2F%7B~%3AE%3B%0A%0A%7B%3AA_%2C%7B1%24_%2C%2C.%3D1b%5C)%2F%3ACAff*A%40zf%7B%5Cf.*1fb%7D..-%7D%2F%3BC%7D%0A%0A~%5B_%5CE%3D%5B%22Err%22%22Ok%22%5D%3D%5Dp%7D%2F&amp;input=%5B%5B42%5D%5D%2042%0A%5B%5B2%2C%203%5D%2C%20%5B1%2C%204%5D%5D%205%0A%5B%5B1%2C%202%2C%203%5D%2C%20%5B4%2C%205%2C%206%5D%2C%20%5B7%2C%208%2C%209%5D%5D%200%0A%5B%5B13%2C%2017%2C%2024%5D%2C%20%5B19%2C%201%2C%203%5D%2C%20%5B-5%2C%204%2C%200%5D%5D%201533%0A%5B%5B372%2C%20-152%2C%20244%5D%2C%20%5B-97%2C%20-191%2C%20185%5D%2C%20%5B-53%2C%20-397%2C%20-126%5D%5D%2046548380%0A%5B%5B100%2C%20-200%2C%2058%2C%204%5D%2C%20%5B1%2C%20-90%2C%20-55%2C%20-165%5D%2C%20%5B-67%2C%20-83%2C%20239%2C%20182%5D%2C%20%5B238%2C%20-283%2C%20384%2C%20392%5D%5D%20571026450%0A%5B%5B432%2C%2045%2C%20330%2C%20284%2C%20276%5D%2C%20%5B-492%2C%20497%2C%20133%2C%20-289%2C%20-28%5D%2C%20%5B-443%2C%20-400%2C%2056%2C%20150%2C%20-316%5D%2C%20%5B-344%2C%20316%2C%2092%2C%20205%2C%20104%5D%2C%20%5B277%2C%20307%2C%20-464%2C%20244%2C%20-422%5D%5D%20-51446016699154%0A%5B%5B416%2C%2066%2C%20340%2C%20250%2C%20-436%2C%20-146%5D%2C%20%5B-464%2C%2068%2C%20104%2C%20471%2C%20-335%2C%20-442%5D%2C%20%5B159%2C%20-407%2C%20310%2C%20-489%2C%20-248%2C%20370%5D%2C%20%5B62%2C%20277%2C%20446%2C%20-325%2C%2047%2C%20-193%5D%2C%20%5B460%2C%20460%2C%20-418%2C%20-28%2C%20234%2C%20-374%5D%2C%20%5B249%2C%20375%2C%20489%2C%20172%2C%20-423%2C%20125%5D%5D%2039153009069988024%0A%5B%5B-246%2C%20-142%2C%20378%2C%20-156%2C%20-373%2C%20444%5D%2C%20%5B186%2C%20186%2C%20-23%2C%2050%2C%20349%2C%20-413%5D%2C%20%5B216%2C%201%2C%20-418%2C%2038%2C%2047%2C%20-192%5D%2C%20%5B109%2C%20345%2C%20-356%2C%20-296%2C%20-47%2C%20-498%5D%2C%20%5B-283%2C%2091%2C%20258%2C%2066%2C%20-127%2C%2079%5D%2C%20%5B218%2C%20465%2C%20-420%2C%20-326%2C%20-445%2C%2019%5D%5D%20-925012040475554%0A%5B%5B-192%2C%20141%2C%20-349%2C%20447%2C%20-403%2C%20-21%2C%2034%5D%2C%20%5B260%2C%20-307%2C%20-333%2C%20-373%2C%20-324%2C%20144%2C%20-190%5D%2C%20%5B301%2C%20277%2C%2025%2C%208%2C%20-177%2C%20180%2C%20405%5D%2C%20%5B-406%2C%20-9%2C%20-318%2C%20337%2C%20-118%2C%2044%2C%20-123%5D%2C%20%5B-207%2C%2033%2C%20-189%2C%20-229%2C%20-196%2C%2058%2C%20-491%5D%2C%20%5B-426%2C%2048%2C%20-24%2C%2072%2C%20-250%2C%20160%2C%20359%5D%2C%20%5B-208%2C%20120%2C%20-385%2C%20251%2C%20322%2C%20-349%2C%20-448%5D%5D%20-4248003140052269106%0A%5B%5B80%2C%20159%2C%20362%2C%20-30%2C%20-24%2C%20-493%2C%20410%2C%20249%2C%20-11%2C%20-109%5D%2C%20%5B-110%2C%20-123%2C%20-461%2C%20-34%2C%20-266%2C%20199%2C%20-437%2C%20445%2C%20498%2C%2096%5D%2C%20%5B175%2C%20-405%2C%20432%2C%20-7%2C%20157%2C%20169%2C%20336%2C%20-276%2C%20337%2C%20-200%5D%2C%20%5B-106%2C%20-379%2C%20-157%2C%20-199%2C%20123%2C%20-172%2C%20141%2C%20329%2C%20158%2C%20309%5D%2C%20%5B-316%2C%20-239%2C%20327%2C%20-29%2C%20-482%2C%20294%2C%20-86%2C%20-326%2C%20490%2C%20-295%5D%2C%20%5B64%2C%20-201%2C%20-155%2C%20238%2C%20131%2C%20182%2C%20-487%2C%20-462%2C%20-312%2C%20196%5D%2C%20%5B-297%2C%20-75%2C%20-206%2C%20471%2C%20-94%2C%20-46%2C%20-378%2C%20334%2C%20407%2C%20-97%5D%2C%20%5B-140%2C%20-137%2C%20297%2C%20-372%2C%20228%2C%20318%2C%20251%2C%20-93%2C%20117%2C%20286%5D%2C%20%5B-95%2C%20-300%2C%20-419%2C%2041%2C%20-140%2C%20-205%2C%2029%2C%20-481%2C%20-372%2C%20-49%5D%2C%20%5B-140%2C%20-281%2C%20-88%2C%20-13%2C%20-128%2C%20-264%2C%20165%2C%20261%2C%20-469%2C%20-62%5D%5D%20297434936630444226910432057" rel="nofollow noreferrer">Online test suite</a></p>

<h3>Dissection</h3>

<p>This implements the <a href="https://en.wikipedia.org/wiki/Faddeev%E2%80%93LeVerrier_algorithm" rel="nofollow noreferrer">Faddeev-LeVerrier algorithm</a>, and I think it's the first answer to take that approach.</p>

<blockquote>
  <p>The objective is to calculate the coefficients <span class="math-container">\$c_k\$</span> of the characteristic polynomial of the <span class="math-container">\$n\times n\$</span> matrix <span class="math-container">\$A\$</span>,
  <span class="math-container">$$p(\lambda )\equiv \det(\lambda I_{n}-A)=\sum _{k=0}^{n}c_{k}\lambda ^{k}$$</span>
  where, evidently, <span class="math-container">\$c_n = 1\$</span> and <span class="math-container">\$c_0 = (−1)^n \det A\$</span>.</p>
  
  <p>The coefficients are determined recursively from the top down, by dint of the auxiliary matrices <span class="math-container">\$M\$</span>,
  <span class="math-container">$$\begin{aligned}M_{0}&amp;\equiv 0&amp;c_{n}&amp;=1\qquad &amp;(k=0)\\M_{k}&amp;\equiv AM_{k-1}+c_{n-k+1}I\qquad \qquad &amp;c_{n-k}&amp;=-{\frac {1}{k}}\mathrm {tr} (AM_{k})\qquad &amp;k=1,\ldots ,n~.\end{aligned}$$</span></p>
</blockquote>

<p>The code never works directly with <span class="math-container">\$c_{n-k}\$</span> and <span class="math-container">\$M_k\$</span>, but always with  <span class="math-container">\$(-1)^k c_{n-k}\$</span> and <span class="math-container">\$(-1)^{k+1}AM_k\$</span>, so the recurrence is
<span class="math-container">$$(-1)^k c_{n-k} = \frac1k \mathrm{tr} ((-1)^{k+1} AM_{k}) \\
(-1)^{k+2} AM_{k+1} = (-1)^k c_{n-k}A - A((-1)^{k+1}A M_k)$$</span></p>

<pre><code>{               e# Define a block
  :A            e#   Store the input matrix in A
  _,            e#   Take the length of a copy
  {             e#     for i = 0 to n-1
                e#       Stack: (-1)^{i+2}AM_{i+1} i
    1$_,,.=1b   e#       Calculate tr((-1)^{i+2}AM_{i+1})
    \)/:C       e#       Divide by (i+1) and store in C
    Aff*        e#       Multiply by A
    A@          e#       Push a copy of A, bring (-1)^{i+2}AM_{i+1} to the top
    zf{\f.*1fb} e#       Matrix multiplication
    ..-         e#       Matrix subtraction
  }/
  ;             e#   Pop (-1)^{n+2}AM_{n+1} (which incidentally is 0)
  C             e#   Fetch the last stored value of C
}
</code></pre>
</div>
<div id="pu10" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="noreferrer">Jelly</a>, <s>16</s> <s>15</s> <s>12</s> 10 bytes</h1>

<pre><code>Ḣ×Zß-Ƥ$Ṛḅ-
</code></pre>

<p>Uses <a href="https://en.wikipedia.org/wiki/Laplace_expansion" rel="noreferrer" title="Laplace expansion - Wikipedia">Laplace expansion</a>. <em>Thanks to @miles for golfing off <s>3</s> 5 bytes!</em></p>

<p><a href="https://tio.run/##PVNLit1ADNznFD6AG7ol9e8oifEym2EuMNuBEMgFAtkEQpZzgJf1g9zj5SKOqmTP4jW23FUqVek9fX5@fjmOx@3bp/vP9Pf3/fvj9uvx58fj9iUd96//Xt8@Hse2bSb7vn5Ytk3WRfd12cq62Fnyx6tq61LXpeGxr8tYl3nd0XUpXhIjePrbCUkOcFg@L2p3rlSq4C4vp9lRmQ4oowbE2ZJGXdrVImd/F5x1QF2oTBPlWnG3BbwBOJxDFEKGoCo6AEdZhwvSeY1s6mLMCVSdSvBROmdMNvEJQooq4ZNnfDSUjIKa36gQoiWQauhRvA4KyU5fMjVLdzrN0GjNaAMe5V0OQM1/apBDVtOG@exUBVgbZHR5HS6owgEzzlrqpDI0KsSHbnOM9owrDaqgxAzUKogpgoikm@N4JCvhHPyEVO0xh02wAQf2wmBNsAhSz1m8ZQjHAvXB5NmuKzpHhgPm4UgAY1416i9UIvCjXDqQ4qkzRs1QgfSSklomTl6xGUExdOyXYHEaFYlf6DP4QdlonzBCIQM4y7XfaOevRquhzqJD5lZg18MTGhbhKjeGkzqlAW3UTf81lzMAOE9n8FIGbM@xx5YhZHKrMLpybsolk8QfTJgz2pSIWSb7tPijuA0l6DCXMUuHMy5uV4ForfMkw16FD6NCHYYTueZ2X8a@7/8B" rel="noreferrer" title="Jelly – Try It Online">Try it online!</a></p>

<h3>How it works</h3>

<pre><code>Ḣ×Zß-Ƥ$Ṛḅ-  Main link. Argument: M (matrix / 2D array)

Ḣ           Head; pop and yield the first row of M.
      $     Combine the two links to the left into a monadic chain.
  Z         Zip/transpose the matrix (M without its first row).
   ß-Ƥ      Recursively map the main link over all outfixes of length 1, i.e., over
            the transpose without each of its rows.
            This yields an empty array if M = [[x]].
 ×          Take the elementwise product of the first row and the result on the
            right hand. Due to Jelly's vectorizer, [x] × [] yields [x].
       Ṛ    Reverse the order of the products.
        ḅ-  Convert from base -1 to integer.
                [a]          -&gt; (-1)**0*a
                [a, b]       -&gt; (-1)**1*a + (-1)**0*b = b - a
                [a, b, c]    -&gt; (-1)**2*a + (-1)**1*b + (-1)**0*c = c - b + a
                etc.
</code></pre>
</div>
<div id="pu11" class="pu"><h1><a href="https://bitbucket.org/zacharyjtaylor/my-language" rel="nofollow noreferrer">MY</a>, 3 (4?) bytes</h1>

<pre><code>ω∥↵
</code></pre>

<p><a href="https://tio.run/##y638//9856OOpY/atv7//z862khHwThWRyHaUEfBJDYWAA" rel="nofollow noreferrer" title="MY – Try It Online">Try it online!</a></p>

<p>Precision is a little weird (the second test case is 5.000000000000001), this can be fixed at a cost of one byte: <code>ω∥⌊↵</code></p>
</div>
<div id="pu12" class="pu"><h1>Java 8, <s>266</s> <s>261</s> <s>259</s> 258 bytes</h1>

<pre class="lang-java prettyprint-override"><code>long d(int[][]m){long r=0;int i=0,j,k,l=m.length,t[][]=new int[l-1][l-1],q=m[0][0];if(l&lt;3)return l&lt;2?q:q*m[1][1]-m[0][1]*m[1][0];for(;i&lt;l;r+=m[0][i]*(1-i++%2*2)*d(t))for(j=0;++j&lt;l;)for(k=l;k--&gt;0;){q=m[j][k];if(k&lt;i)t[j-1][k]=q;if(k&gt;i)t[j-1][k-1]=q;}return r;}
</code></pre>
<p>Look mom, no build-ins.. <sub><sub><sub>because Java has none.. &gt;.&gt;</sub></sub></sub></p>
<p>-7 bytes thanks to <em>@ceilingcat</em>.</p>
<p><strong>Explanation:</strong></p>
<p><a href="https://tio.run/##rVbLbuNGELzvV8wlgGhxvPPicCayNl@Q0x4FHpSV1qFESbZMbxAY@nanu1p2FthREEQxDFIaNburq/rBzfLbUh8e1vvNavv6ZVg@Palfl/3@5YNST@Ny7L@o1@Gwv1erSb8fF92i21UvODjOzYyOVD839abe1sN8dzus9/fj7zXs5vv1H4qfGbTtcKkf57uF6eh/1n@dDHe@Oq7H5@NeDXful8efH292C7K0nYaV7eQ7WX89HCez/m6YHafioe9uJlb30@lP7sZVN6vJWFVstCFM0@mGLPF1Ox9mW60/mVn1wrE33WKL2Nu7vhoXGwa27eaPOPr09xFd6PB0RnecnV6Venj@bSAyzpx8O/QrtSOeJp/HY7@/X3TLiilT6vOfT@N6d3t4Hm8f6Jdx2E9WkzcqiBaxUur96CW4E85OVTX7jy5crfyp/uHY1ipc7ZucXHAfatXUKhZ@aWuVapWvj@1rZcmZC6Xscq0UoSti04RMEUBlrgbhW8pf24auBKSEROeWLTKDsakpwqFMtBc7F68nxhjy5PiqGqKa/krAhB@d2bhpOHYsoostmyXC6DxYTa5g5nzioGzmE3Pr8/WlG7wT@CyY95yQg3PXlipLh8z2gZlU1nsAYsh0K5oHNgkgSjWRH2qYDW@L3n1AXpYNFSI5w8CsKdHrWkahvGFZQwxSIPzZ/Q/ECAgV@eYDiAH04CMrGcr0AIWKSUAzVa3lfD3LH0JJV9uAwMBpUO6IwZxqF9iNb03hoSiyCQUhMCTvmCoKiGYoTowIHXDTwSbRjTPzTJtviyyHDJZbtDTEtmjJ4Dx/ds3VXFOmwqlDvgn9jpRaj/SK8ydBILlpYGmQnmfAlF6JAXdWlRvzzIA/96/QVhTICAPcI9oDmMuIiodCLpY@GpWq2KJyECQiS4eqbXMRXhKBUC0OneIiKgfa2utnOufIsgWUJbQNkobxINJKriV0KB8t/ebR/BCIMAa4DKCwVK7ewO25Y6VQFXTGiU3sOZjidAwGmumMuQHJPMQ6k4WorriFnJEJwSCt9JTLAAmXrArJZ4tRHUyCNAm6GlWPIaAsqPBNLkdF@4t8qYH@WJTOvXFOgqbvpPz48d@JKXbfBwNxPFWzUrXHVNCY4sBMyaGBLMYXxCbamADDyH90R78aoRMjFesLs8FhDtoM7F6GDgZChgg5Ft1ZDA1SEKayajQEb3CNGWqio9r4riwt1gvojEwFaNhIx2IgAS/GklQ2cY1z9J2/lCwWjZad69GWGuURElZPDljL8a0LKVms/dwU3cnoJ/AguIHuGC7Wy5sJhmaSZYVKsMB7gTuKw6bCoEMPYJdQIwCXzPxW@gGbBsVOL0MXuAtQFtqJa7xZKYcNII0ldapRNNbCMl1AlxspNVklGJAYKRJG1rY6s2nfg1FB/hM6lxA/oeksNHV46QG3NoLTiNmN0tGRFr14O4/E04fT618" rel="nofollow noreferrer">Try it here.</a> (Only the last test case is too big to fit in a <code>long</code> of size 2<sup>63</sup>-1.)</p>
<pre class="lang-java prettyprint-override"><code>long d(int[][]m){             // Method with integer-matrix parameter and long return-type
  long r=0;                   //  Return-long, starting at 0
  int i=0,j,k,                //  Index-integers
      l=m.length,             //  Dimensions of the square matrix
      t[][]=new int[l-1][l-1],//  Temp-matrix, one size smaller than `m`
      q=m[0][0];              //  The first value in the matrix (to reduce bytes)
  if(l&lt;3)                     //  If the dimensions are 1 or 2:
    return l&lt;2?               //   If the dimensions are 1:
      q                       //    Simply return the only item in it
     :                        //   Else (the dimensions are 2):
      q*m[1][1]-m[0][1]*m[1][0];
                              //    Calculate the determinant of the 2x2 matrix
                              //  If the dimensions are 3 or larger: 
  for(;i&lt;l;                   //  Loop (1) from 0 to `l` (exclusive)
      r+=                     //    After every iteration: add the following to the result:
         m[0][i]              //     The item in the first row and `i`'th column,
         *(1-i++%2*2)         //     multiplied by 1 if `i` is even; -1 if odd,
         *d(t))               //     multiplied by a recursive call with the temp-matrix
    for(j=0;                  //   Reset index `j` to 0
        ++j&lt;l;)               //   Inner loop (2) from 0 to `l` (exclusive)
      for(k=l;k--&gt;0;){        //    Inner loop (3) from `l-1` to 0 (inclusive)
        q=m[j][k];            //     Set the integer at location `j,k` to reduce bytes
        if(k&lt;i)               //     If `k` is smaller than `i`:
          t[j-1][k]=q;        //      Set this integer at location `j-1,k`
        if(k&gt;i)               //     Else-if `k` is larger than `i`:
          t[j-1][k-1]=q;      //      Set this integer at location `j-1,k-1`
                              //     Else: `k` and `i` are equals: do nothing (implicit)
      }                       //    End of inner loop (3)
                              //   End of inner loop (2) (implicit / single-line body)
                              //  End of loop (1) (implicit / single-line body)
  return r;                   //  Return the result-long
}                             // End of method
</code></pre>
</div>
<div id="pu13" class="pu"><h2>Clojure, 141 bytes</h2>

<pre><code>(fn D[A](apply +(map *(cycle[1 -1])(first A)(if(next A)(for[R[(range(count A))]i R](D(for[a(rest A)](for[j(remove #{i}R)](nth a j)))))[1]))))
</code></pre>

<p>Laplace's formula, longer than I'd like...</p>
</div>
<div id="pu14" class="pu"><h2>Python 3, <s>153</s> 149 Bytes</h2>

<pre><code>def d(n):
 l=len(n);r=range(0,l)
 if l==1:return n[0][0]
 else:return sum([(-1)**i*n[0][i]*d([[n[a][b]for b in r if b!=i]for a in r[1:]])for i in r])
</code></pre>

<p>I'm new to code golf, so I wouldn't be surprised if this could be improved.
It's calculated in a pretty basic way; by summing the product of each element of the first row with the determinant of its respective minor, with a sign change based on the element's position.</p>

<p>Edit: Realized I could shorten it by using a single character for the function name :/</p>
</div>
<div id="pu15" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, 71 bytes</h1>

<p><em>-3 bytes thanks to Lynn. Another one bytes the dust thanks to Craig Roy.</em></p>



<pre class="lang-hs prettyprint-override"><code>f[]=1
f(h:t)=foldr1(-)[v*f[take i l++drop(i+1)l|l&lt;-t]|(i,v)&lt;-zip[0..]h]
</code></pre>

<p><a href="https://tio.run/##VVTRjhMxDHznK/LYcptTYnuzCeI@AfEBVR8qoFx1BU7HiQfEt1M841ZaKjXazcbjsWecx8PPpy/n8@Vy3O0f6pvj5vHd6/bh@OP8@aVu8nb36@1x93p4@pJO6Xx39/nlx/PmdFe35z/n9/l1/2dzmn5t3@ffp@ddub/fP@4v3w6n7@khfTs8f0ib55fT99d0n47bN8l/u7Tbmez3fJn8Raake3@oU7LVtr/evtiU5ik1PC5T6lMa63M6perbYgQZ/nYNyx7koWV1WBfHzHUWnGdAHgt2hgfVPkeYI2aNfWnrVKX4nmCdO9gG6zywPc843wKiIbg7jigIdcGuaEc4trU7MR3rNpg6KXMQVYcTHJCFNWcb@ARCVZUQg2t8NGwZSTU/MYOM1ohUQ57q@4CQ4vC1kLcsDqcFPK0Z24FH@Y8SApv/1UCJyKYNddqVGUJbJ6pTXNANVXTCjDXXeZAdklXGB3fzGF0KjjQwAxszQKtAthAl1G8exyVbjQ6ir6CrS9RiA2iIA3qlyCYwhsyrejxtkIexlk4nMOWiyB56djQRSwYAalZjDZVsBD2pNy5Q9Mo1yi1gAhWzEloGVh6xEYLRAPCbwESNjMQPLCPwAdnYQqGUQgRg1rXvkdK3jC0HQ4sshQ7BDERv2LgQWukeVuuwhmgjd@qgpV6FgALsDl5qR/tL@NoKyAw6DOUraydlIkkMnlBvpKkhtwzmaTE43ooacKjNqKmHUza6rIK0zuMKBn9FL/oMdihO5Fa396av@gK6dJ02HilXdE8KlWFC@sVpYymRpNKcVThLLXqKQMhTB7MoLQqTDVxBHIC6UCjMFec3o2EzlgYGnBWf4lun/OqIbCVsRxpz@AfGZXral7oq2lbRMb3S5ChnXioqRCS1jhEaINzbzTLGW0kGhWssprBiXFS8iqry0uOw9LgI2LGK/FGfx@MDqxSQjhFnqpjWhTbA8NNiY4kCje1E0YHAi1cwuTQONcwQpPLu7pFtcHBKjDosTcIWty5oR7X1BuiartIJP3Q6l40UOgu1VwyUUFeDMrn5PZf2l7@fjufD15@X/PEf" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a> <em>Added <code>-O</code> flag for optimization purposes. It is not necessary.</em></p>

<h2>Explanation (outdated)</h2>

<p><code>f</code> recursively implements cofactor expansion.</p>

<pre class="lang-hs prettyprint-override"><code>f[[x]]=x
</code></pre>

<p>This line covers the base case of a <strong>1</strong> × <strong>1</strong> matrix, in which case the determinant is <code>mat[0, 0]</code>.</p>

<pre class="lang-hs prettyprint-override"><code>f(h:t)=
</code></pre>

<p>This uses Haskell's <em>pattern matching</em> to break the matrix into a <em>head</em> (the first row) and a <em>tail</em> (the rest of the matrix).</p>

<pre class="lang-hs prettyprint-override"><code>          [                                     |(i,v)&lt;-zip[0..]h]
</code></pre>

<p>Enumerate the head of the matrix (by zipping the infinite list of whole numbers and the head) and iterate over it.</p>

<pre class="lang-hs prettyprint-override"><code>           (-1)*i*v
</code></pre>

<p>Negate the result based on whether its index is even since the calculation of the determinant involves alternating addition and subtraction.</p>

<pre class="lang-hs prettyprint-override"><code>                     [take i l++drop(i+1)l|l&lt;-t]
</code></pre>

<p>This essentially removes the <strong>ith</strong> column of the tail by taking <strong>i</strong> elements and concatenating it with the row with the first <strong>(i + 1)th</strong> elements dropped for every row in the tail.</p>

<pre class="lang-hs prettyprint-override"><code>                   *f
</code></pre>

<p>Calculate the determinant of the result above and multiply it with the result of <code>(-1)*i*v</code>.</p>

<pre class="lang-hs prettyprint-override"><code>       sum
</code></pre>

<p>Sum the result of the list above and return it.</p>
</div>
<div id="pu16" class="pu"><h2><a href="http://www.sagemath.org/" rel="nofollow noreferrer">SageMath</a>, various</h2>

<p>Here are a bunch of methods for computing the determinant that I found interesting, all programmed in SageMath. They can all be tried <a href="http://sagecell.sagemath.org/?z=eJyVk11v0zAUhu8j5T8clRu7uFWTDSEqwd24mDqE4DIKzE1OUrf-iGyHdUP8d-x07VKtQqJXzfny857XvoOPoLi3Yk-KImdwVTIoMgbXZUnT5C4fp7MrBtl7Bvn1UPQhfD03zN6FDgaLoSlN3sC6F9ILDTX6NOms0D7-JXf07CsfqofAoa2zpu4rD6YBFC3qX1z26NKkCRiSq3XNQS0tckliJVHzURWh9DS9GZ3U_PucWvDWaC4BJSrU3kHAvjW25pG-MqozTnhhNMzAaPkID8buHDTGguUxHltfKGCNFe8dxtGNQFmDcG7Q0I41PONvh3N-hmGK0GLP9mWcu48IlusWQ4m25uFMWzto8_ZxmSYQfqdoVIn7Cjt_lpncfvkMDRfyAK2Nnl0Cn_znir4r4TfnG0qTzQWNLhYeJS7K-XEaeZG0Gdm1uWDXineSVwi477h20QsujW7Bmw7CetJkNT73tLNPGdc1uF4RMsvodLqdqmLBtuV0RVSRLdlyW85530ZJh8D2bbYsKY1r2p55UBk5eBASccSiPNKuRuSrS-Qo1lo8xc2rXvJAmo9RI5trNeno9LCtYse6YlfOsuEi7C5CxEwXM18xDPWDl25ccALKx3T5BbxvSPCHt0RqokIjG27I0SDxxNcSD8-_Cjd7BhZ9b7UD96jWRooqGmLRRUcYOAPx3t9rQu-DM9CiB90rtLHOeRHmYJrcvHrJYQaJe1C8Cxzs1Zt-0XMzknMT1TCYkN9_6GQe18s90WQIU_oXzJuCHw==&amp;lang=sage" rel="nofollow noreferrer">here</a>.</p>



<h3>Builtin, 3 bytes</h3>

<pre class="lang-py prettyprint-override"><code>det
</code></pre>

<p>This one isn't too interesting. Sage provides global-level aliases to many common operations that would normally be object methods, so this is shorter than <code>lambda m:m.det()</code>.</p>

<hr>

<h3>Real Part of Product of Eigenvalues, 36 bytes</h3>

<pre class="lang-py prettyprint-override"><code>lambda m:real(prod(m.eigenvalues()))
</code></pre>

<p>Unfortunately, <code>eigenvalues</code> is not one of those global-level aliases. That, combined with the fact that Sage doesn't have a neat way to compose functions, means we're stuck with a costly <code>lambda</code>. This function symbolic values which are automatically converted to numeric values when printed, so some floating point inaccuracy may be present in some outputs.</p>

<hr>

<h3>Product of Diagonal in Jordan Normal Form, 60 bytes</h3>

<pre class="lang-py prettyprint-override"><code>lambda m:prod(m.jordan_form()[x,x]for x in range(m.nrows()))
</code></pre>

<p>In Jordan Normal form, an NxN matrix is represented as a block matrix, with N blocks on the diagonal. Each block consists of either a single eigenvalue, or a MxM matrix with a repeated eigenvalue on the diagonal and <code>1</code>s on the super-diagonal (the diagonal above and to the right of the "main" diagonal). This results in a matrix with all eigenvalues (with multiplicity) on the main diagonal, and some <code>1</code>s on the super-diagonal corresponding to repeated eigenvalues. This returns the product of the diagonal of the Jordan normal form, which is the product of the eigenvalues (with multiplicty), so this is a more roundabout way of performing the same computation as the previous solution.</p>

<p>Because Sage wants the Jordan normal form to be over the same ring as the original matrix, this only works if all of the eigenvalues are rational. Complex eigenvalues result in an error (unless the original matrix is over the ring <code>CDF</code> (complex double floats) or <code>SR</code>). However, this means that taking the real part is not necessary, compared to the above solution.</p>

<hr>

<h3>Product of Diagonal in Smith Decomposition</h3>

<pre class="lang-py prettyprint-override"><code>lambda m:prod(m.smith_form()[0].diagonal())
</code></pre>

<p>Unlike Jordan normal form, Smith normal form is guaranteed to be over the same field as the original matrix. Rather than computing the eigenvalues and representing them with a block diagonal matrix, Smith decomposition computes the elementary divisors of the matrix (which is a topic a bit too complicated for this post), puts them into a diagonal matrix <code>D</code>, and computes two matrices with unit determinant <code>U</code> and <code>V</code> such that <code>D = U*A*V</code> (where <code>A</code> is the original matrix). Since the determinant of the product of matrices equals the product of the determinants of the matrices (<code>det(A*B*...) = det(A)*det(B)*...</code>), and <code>U</code> and <code>V</code> are defined to have unit determinants, <code>det(D) = det(A)</code>. The determinant of a diagonal matrix is simply the product of the elements on the diagonal.</p>

<h3>Laplace Expansion, 109 bytes</h3>

<pre class="lang-py prettyprint-override"><code>lambda m:m.nrows()&gt;1and sum((-1)**j*m[0,j]*L(m[1:,:j].augment(m[1:,j+1:]))for j in range(m.ncols()))or m[0,0]
</code></pre>

<p>This performs Laplace expansion along the first row, using a recursive approach. <code>det([[a]]) = a</code> is used for the base case. It should be shorter to use <code>det([[]]) = 1</code> for the base case, but <a href="http://sagecell.sagemath.org/?z=eJxNjUEOgjAQRfck3GGWHRwILRgjiTeAEzRdVEFCQ4spED2-FTVhNZn35_1p4AJWL354MSkFQaEIJCcolcI4asQ-5gUBPxGIcjs6h-0npMdgEOSbFEd1sEZtr60GW9nM-ek5M9SuhXm1jKUck8QkVuZkVFIzK3lFlVGZXnvbueULzIFXCvE-eTAwOPDa9R0LbbdpDG2IIeCfbw8_uAVq1iBB2y1h7pj4Q4Fvguc_gA==&amp;lang=sage" rel="nofollow noreferrer">my attempt</a> at that implementation had a bug that I haven't been able to track down yet.</p>

<hr>

<h3>Leibniz's Formula, 100 bytes</h3>

<pre class="lang-py prettyprint-override"><code>L2 = lambda m:sum(sgn(p)*prod(m[k,p[k]-1]for k in range(m.ncols()))for p in Permutations(m.ncols()))
</code></pre>

<p>This directly implements Leibniz's formula. For a much better explanation of the formula and why it works than I could possibly write, see <a href="https://codegolf.stackexchange.com/a/147723/45941">this excellent answer</a>.</p>

<hr>

<h3>Real Part of <code>e^(Tr(ln(M)))</code>, 48 bytes</h3>

<pre class="lang-py prettyprint-override"><code>lambda m:real(exp(sum(map(ln,m.eigenvalues()))))
</code></pre>

<p>This function returns symbolic expressions. To get a numerical approximation, call <code>n(result)</code> before printing.</p>

<p>This is an approach that I haven't seen anyone use yet. I'm going to give a longer, more-detailed explanation for this one.</p>

<p>Let <code>A</code> be a square matrix over the reals. By definition, the determinant of <code>A</code> is equal to the product of the eigenvalues of <code>A</code>. The trace of <code>A</code> is equal to the sum of <code>A</code>'s eigenvalues. For real numbers <code>r_1</code> and <code>r_2</code>, <code>exp(r_1) * exp(r_2) = exp(r_1 + r_2)</code>. Since the <a href="https://en.wikipedia.org/wiki/Matrix_exponential" rel="nofollow noreferrer">matrix exponential function</a> is defined to be analogous to the scalar exponential function (especially in the previous identity), and the matrix exponential can be computed by diagonalizing the matrix and applying the scalar exponential function to the eigenvalues on the diagonal, we can say <code>det(exp(A)) = exp(trace(A))</code> (the product of <code>exp(λ)</code> for each eigenvalue <code>λ</code> of <code>A</code> equals the sum of the eigenvalues of <code>exp(A)</code>). Thus, if we can find a matrix <code>L</code> such that <code>exp(L) = A</code>, we can compute <code>det(A) = exp(trace(L))</code>.</p>

<p>We can find such a matrix <code>L</code> by computing <code>log(A)</code>. The matrix logarithm can be computed in the same way as the matrix exponential: form a square diagonal matrix by applying the scalar logarithm function to each eigenvalue of <code>A</code> (this is why we restriced <code>A</code> to the reals). Since we only care about the trace of <code>L</code>, we can skip the construction and just directly sum the exponentials of the eigenvalues. The eigenvalues can be complex, even if the matrix isn't over the complex ring, so we take the real part of the sum.</p>
</div>
<div id="pu17" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 43 bytes</h1>

<p>Finally I've done writing my non-builtin solution in a golfing language!</p>

<pre><code>ḣ⁹’’¤;ṫḊ€Ç×⁸ị@⁹’¤¤ḷ/¤
çÐ€⁸J‘¤µJ-*×NS
ÇḢḢ$Ṗ?
</code></pre>

<p>Thanks to <em>HyperNeutrino</em> for saving a byte!</p>

<p><a href="https://tio.run/##y0rNyan8///hjsUKjxp3PmqYCUSHlihYP9y5WuHhjq5HTWsUDrcrHJ4OlN3xcHe3A0TRoSWHljzcsV3/0BKuw8sPTwCpAsp7PWqYAdR7aKuCl4KuFkiTn0IwF1D7wx2LgEhF4eHOafb///@PNtNRMAeiWB2FaBMw0wzEBIoCeRaxAA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a> (spaced code for clarity)</p>

<p><em>terribly long way to remove n'th elements from a list, will improve later</em></p>

<hr>

<p>This answer had been outgolfed by answers of HyperNeutrino, Dennis and Leaky Nun. Jelly is <em>very</em> popular as a golfing language.</p>

<p>Quick explanation:</p>

<pre><code>ÇḢḢ$Ṗ?    Main link.
     ?    If
    Ṗ     after remove the last element, the value is not empty (truthy)
Ç         then execute the last link
 ḢḢ$      else get the element at index [1, 1].

çÐ€⁸J‘¤µJ-*×NS     Helper link 1, take input as a matrix.
çÐ€                Apply the previous link, thread right argument to
   ⁸J‘¤            the range [2, 3, ..., n+1]
       µ           With the result,
        J-*        generate the range [-1, 1, -1, 1, ...] with that length
           ×N      Multiply by negative
             S     Sum

ḣ⁹’’¤;ṫḊ€Ç×⁸ị@⁹’¤¤ḷ/¤    Helper link 2, take left input as a matrix, right input as a number in range [2..n+1]
ḣ
 ⁹’’¤                    Take head ρ-2 of the matrix
     ;                   concatenate with 
      ṫ                  tail ρ (that is, remove item ρ-1)
       Ḋ€                Remove first column
         Ç               Calculate determinant of remaining matrix
          ×         ¤    multiply by
                  ḷ/     the first column,
            ị@           row #
              ⁹’¤        ρ-1 (just removed in determinant calculation routine) of
           ⁸     ¤       the matrix.
</code></pre>
</div>
<div id="pu18" class="pu"><h1>Excel VBA, <sub><s>58</s></sub> 50 Bytes</h1>

<p>Returns the determinant of the matrix entered into the the upper left corner of the default <code>Sheet1</code> object.</p>
<pre class="lang-vba prettyprint-override"><code>?Evaluate(&quot;MDeterm(&quot;+Sheet1.UsedRange.Address+&quot;)&quot;)
</code></pre>
<p>-8 Bytes thanks to <a href="https://codegolf.stackexchange.com/users/68602/greedo">Greedo</a></p>
</div>
<div id="pu19" class="pu"><h1><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python 3</a>, <s><strong>238 bytes</strong></s>, <s><strong>227 bytes</strong></s>, <s><strong>224 bytes</strong></s>, <strong>216 bytes</strong></h1>



<pre class="lang-python prettyprint-override"><code>from functools import*
from itertools import*
r=range;n=len;s=sum
f=lambda l:s(reduce(lambda p,m:p*m,[l[a][b]for a,b in zip(r(n(l)),j)])*(-1)**s(s(y&lt;j[x]for y in j[x:])for x in r(n(l)))for j in permutations(r(n(l))))
</code></pre>

<p><a href="https://tio.run/##ZVPLbttADLznK/YoGRKgJanHJvWXCD44id3asB6QZCDpz7scroyi6sELL5czHA6p8Xv5NfT8eJynoXPne/@xDMNtdpduHKZl92Lhy3Ka/g1P@@nY/zy99fvbqX@b9/O9eznvb8fu/fPobq9zMp0@7x@nZI2MWfc67rqsvbXHQ/t@OA@TO2bv7tK735cxmZI@uaVpdk0P6S7JfbrbzcmcfP@4tl@W@41MvbweUly/cF1BFrgiMJ6m7r4cl8vQz0/KNH2M06VfknPStkKHQ5q@/A1Q5viQudZnTjZPGnq@SubKzFX4W2euyVzY5nLmvD6RGFnQ2wrNFajwYgPgWrlzXxIwBspDjUhQoG/KCFXWnGOcqm3JotA44SwbqI9d5AHhsgSmijQVCBrlIoawhhAlbgBHmBsVyGFrjbCKEyViVkpCEtXmQS4BTxDmmY0m2BkfBSExYZVmlBDEPiJZUMtrHBRUKL0vTDvVSscFtEolZgv@0n@yAK70xwJZxi5coV9Z1QFeNcasMmu4wgxHRKx3XwZTiILe8FG/KIbrAikV1EGRCKiZMMY4oLgRleLsyMVHJ@EvJHMd@5EANuDA7m3gQlgUKjc9aenYABaubmwzrGzNUBBn28BMHDlI0DeL9eFNEcEX/9SD6a56Y8sF1GCaORs1BZyWIiEOzpYB@0dYqMoUkSbUIfKDsjIbyUZKxgBOv/0eUFbDYtZDpcRKhW0Lvo3okRkYh862SdaxUgvQYvptHlz4dSCYhDmEi28whiLuuRQQFGzbYAFb/ybbmCh@kGRzRxkfx07B6lTxQ1I7fKRDf2KzVbiNz7bNQzSXYSXDnkU/mhLq0BzRs2/1p4E3jz8" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>

<p>My solution uses the definition of a determinant for calculations. Unfortunately, the complexity of this algorithm is <code>n!</code> and I can not show the passage of the last test, but in theory this is possible.</p>
</div>
<div id="pu20" class="pu"><h1>C, <s> 176 </s> 125 bytes</h1>

<p><em>Thanks to @ceilingcat for golfing 42 bytes, and thanks to both @Lynn and @Jonathan Frech for saving a byte each!</em></p>

<pre><code>d(M,n)int*M;{int i=n--,s=*M*!n,c,T[n*n];for(;i--;s+=M[i]*(1-i%2*2)*d(T,n))for(c=n*n;c--;T[c]=M[n-~c+c/n+(c%n&gt;=i)]);return s;}
</code></pre>

<p>Calculates the determinant using the <a href="https://en.wikipedia.org/wiki/Laplace_expansion" rel="nofollow noreferrer">Laplace expansion</a> along the first row.</p>

<p><a href="https://tio.run/##fZDBasMwDIbvfQqtULBdmTW2kyaY7A1y6y3LYTjt8GHeSLJT6V49k5oxGB3NwcHyr@@THfRrCPPciwaTjGlSjT/TD2KdtMaxVo16SBjw0CaVOn96H4SPWvtxWzdt7JTIdNwYZaTqxYEQkhOhprAPFDu0oaNg0l9hGx7TVoRNeqqj7KQfjtPnkGD0l5mFby8xCbk6r4A@LkzHccraDmo4O3Px1/rHQCcnsd70z2mN0ItrCCGT0q/@dJql0yBYOkZw9wiUMjcEuxCod4E4hByhQNgjlAjVPSDF7Q3QLUC7J57OcpY6gupqz/uKr1GSQefUre1SNcU9jftPk//MvdsRwPCal9fpM3ZxMWdLVvBasKUkobEV@3koW3IjF23Jhur29X8nIIbjCS7zNw" rel="nofollow noreferrer">Try it online!</a></p>

<p><strong>Unrolled:</strong></p>

<pre><code>d(M, n)int*M;
{
    int i=n--, s=*M*!n, c, T[n*n];
    for (; i--; s+=M[i]*(1-i%2*2)*d(T,n))
        for (c=n*n; c--;)
            T[c] = M[n-~c+c/n+(c%n&gt;=i)];
    return s;
}
</code></pre>
</div>
<div id="pu21" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>, 75 bytes</h1>



<pre class="lang-python prettyprint-override"><code>f=lambda m,p=[]:m[0][0]*f(zip(*p+m[1:])[1:])-f(m[1:],p+m[:1])if m else[]==p
</code></pre>

<p><a href="https://tio.run/##TY/RqsIwEETf@xXz2Ho3YNLW2kK@JOyDl9twA6YG2xf9@bqNioYQdk5mBjbdlv/LZNbV2/Mp/v6dEClZx0N0e5a78@U9pHKXfqLTA1f5Ub7MijY6aK6CR8R4nkfH1qZ1GedlhoUrIMe5xjDTazaEmglOE5oPFfX@aAgt4bCNHeFI6L9sNUELNU2u6EW9Ukoyktx/vHUnjUq3ZrNnv@q7jfSS0cf2mZJCVT@5OTAXXBT@ckVAmJDXGHJduoZpgS9DtT4A" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>
</div>
<div id="pu22" class="pu"><h1><a href="https://www.haskell.org/" rel="noreferrer">Haskell</a>, 59 bytes</h1>



<pre class="lang-hs prettyprint-override"><code>p%(l:r)=l!!0*f(tail&lt;$&gt;p++r)-(p++[l])%r
[]%_=1
p%_=0
f=([]%)
</code></pre>

<p><a href="https://tio.run/##VVTRihsxDHzPV2yhB0lvXWxJ67VL0z8o/YAQSihNezR3hNx9f1PNKIHtwTm7Xms00oz8@/D65@fpdL2eH9anT5fN9vTuXf5wXL8dnk6f3385Pz5eNmntP7vTfvNwWe32D9@3ZXX2Na@O27W/b67Ph6eXYTs8H85fh/X58vTyNnwcjpvV4H@7Ybcz2e/5MvqLjIPu/aGMgy22/fX@xcZhGoeKx3kc2jj05Tkdh@LbYgTp/nYLSx7koXlxWGfHTGUSnGdA6jN2ugeVNkWYIyaNfanLVDn7nmCdGtgG69SxPU04XwOiIrg5jigINcGuaEM4trU5Me3LNpg6KXMQVYcTHJCZNSfr@ARCRZUQnWt8NGwZSVU/MYGMlohUQ57i@4CQ7PAlk7fMDqcZPK0a24FH@Y8SAqv/q4ESkU0r6rQbM4TWRlSnOKMbquiEGWsuUyc7JCuMD@7mMTpnHKlgBjZmgFaBbCFKqF89jkuyEh1EX0FX56jFOtAQB/RCkU1gDJkW9XjaIA9jzY1OYMpZkT30bGgilgQA1KzGGgrZCHpS7lyg6I1rlJvBBComJbR0rDxiPQSjAeA3gYkqGYkfmHvgA7KyhUIphQjALEvfI6VvGVsOhhZZMh2CGYjesHEhtNI9rNZhDdFG7tRBc7kJAQXYHbyUhvbn8LVlkOl0GMpX1k7KRJIYPKHeSFNCbunMU2NwvBUl4FCbUVMPp2x0WQFpnfoNDP6KXrQJ7FCcyL1u701b9AV06TqtPJJv6J4UKsOE9IvTxpIjSaE5i3CWavQUgZCndGZRWhQm67iCOABlplCYK85vQsMmLBUMOCs@xfdO@dUR2XLYjjSm8A@My/S0L3VVtK2gY3qjyVFOvFRUiEhqDSPUQbjVu2WMt5J0CldZTGbFuKh4FRXlpcdhaXERsGMF@aM@j8cHVikgHSPOVDGtM22A4afF@hwFGtuJogOBF69gcmkcapggSOHd3SJb5@DkGHVYmoQtbl3QjmrLHdA1XaQTfmh0LhspdBZqLxgooa4GZVL1e27YX//@OJ4Ov16v6ds/" rel="noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
</div>
<div id="pu23" class="pu"><h1><a href="https://www.wolfram.com/wolframscript/" rel="nofollow noreferrer">Wolfram Language (Mathematica)</a>, <s>53</s> 52 bytes</h1>

<pre><code>1##&amp;@@@(t=Tuples)@#.Signature/@t[Range@Tr[1^#]&amp;/@#]&amp;
</code></pre>

<p><a href="https://tio.run/##y00syUjNTSzJTE78n1aaZ/vfUFlZzcHBQaPENqS0ICe1WNNBWS84Mz0vsaS0KFXfoSQ6KDEvPdUhpCjaME45Vk3fAUj8DyjKzCuJBuqPrq5O1EnSSa7VqU7RSdVJA9LpOhk6mbW1sbFcEFUuqSX4VP0HAA" rel="nofollow noreferrer" title="Wolfram Language (Mathematica) – Try It Online">Try it online!</a></p>

<p>Unfortunately, computing the determinant of an <em>n</em> by <em>n</em> matrix this way uses O(<em>n</em><sup><em>n</em></sup>) memory, which puts large test cases out of reach.</p>

<h2>How it works</h2>

<p>The first part, <code>1##&amp;@@@(t=Tuples)@#</code>, computes all possible products of a term from each row of the given matrix. <code>t[Range@Tr[1^#]&amp;/@#]</code> gives a list of the same length whose elements are things like <code>{3,2,1}</code> or <code>{2,2,3}</code> saying which entry of each row we picked out for the corresponding product.</p>

<p>We apply <code>Signature</code> to the second list, which maps even permutations to <code>1</code>, odd permutations to <code>-1</code>, and non-permutations to <code>0</code>. This is precisely the coefficient with which the corresponding product appears in the determinant.</p>

<p>Finally, we take the dot product of the two lists.</p>

<hr>

<p>If even <code>Signature</code> is too much of a built-in, at <strong>73 bytes</strong> we can take</p>

<pre><code>1##&amp;@@@(t=Tuples)@#.(1##&amp;@@Order@@@#~Subsets~{2}&amp;/@t[Range@Tr[1^#]&amp;/@#])&amp;
</code></pre>

<p>replacing it by <code>1##&amp;@@Order@@@#~Subsets~{2}&amp;</code>. This computes <code>Signature</code> of a possibly-permutation by taking the product of <code>Order</code> applied to all pairs of elements of the permutation. <code>Order</code> will give <code>1</code> if the pair is in ascending order, <code>-1</code> if it's in descending order, and <code>0</code> if they're equal.</p>

<hr>

<p><em>-1 byte thanks to @user202729</em></p>
</div>
<div id="pu24" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="noreferrer">Jelly</a>, 15 <a href="https://github.com/DennisMitchell/jelly/wiki/Code-page" rel="noreferrer">bytes</a></h1>

<pre><code>LŒ!ðŒcIṠ;ị"Pð€S
</code></pre>

<p><a href="https://tio.run/##y0rNyan8/9/n6CTFwxuOTkr2fLhzgfXD3d1KAYc3PGpaE/z////oaEMDAx0FXSMQaWqho2ASq6MQbQgUsQQJm5oCCUMzU5Cgrpk5kGNhrKNgZGypo2BoYQQSNTK2AGkHCRtbmAAJS6PYWAA" rel="noreferrer" title="Jelly – Try It Online">Try it online!</a></p>

<h2>How it works</h2>

<pre><code>LŒ!ðŒcIṠ;ị"Pð€S   input
L                 length
 Œ!               all_permutations
   ð        ð€    for each permutation:
    Œc                take all unordered pairs
      I               calculate the difference between
                      the two integers of each pair
       Ṡ              signum of each difference
                      (positive -&gt; 1, negative -&gt; -1)
        ;             append:
         ị"             the list of elements generated by taking
                        each row according to the index specified
                        by each entry of the permutation
           P          product of everything
              S   sum
</code></pre>

<h2>Why it works -- mathy version</h2>

<p>The operator <strong>det</strong> takes a matrix and returns a scalar. An <em>n</em>-by-<em>n</em> matrix can be thought of as a collection of <em>n</em> vectors of length <em>n</em>, so <strong>det</strong> is really a function that takes <em>n</em> vectors from ℤ<sup><em>n</em></sup> and returns a scalar.</p>

<p>Therefore, I write <strong>det</strong>(<em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>, <em>v</em><sub>3</sub>, ..., <em>v</em><sub><em>n</em></sub>) for <strong>det</strong> [<em>v</em><sub>1</sub> <em>v</em><sub>2</sub> <em>v</em><sub>3</sub> ... <em>v</em><sub>n</sub>].</p>

<p>Notice that <strong>det</strong> is linear in each argument, i.e. <strong>det</strong>(<em>v</em><sub>1</sub> + λ<em>w</em><sub>1</sub>, <em>v</em><sub>2</sub>, <em>v</em><sub>3</sub>, ..., <em>v</em><sub><em>n</em></sub>) = <strong>det</strong>(<em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>, <em>v</em><sub>3</sub>, ..., <em>v</em><sub><em>n</em></sub>) + λ <strong>det</strong>(<em>w</em><sub>1</sub>, <em>v</em><sub>2</sub>, <em>v</em><sub>3</sub>, ..., <em>v</em><sub><em>n</em></sub>). Therefore, it is a linear map from (ℤ<sup><em>n</em></sup>)<sup>⊗<em>n</em></sup> to ℤ.</p>

<p>It suffices to determine the image of the basis under the linear map. The basis of (ℤ<sup><em>n</em></sup>)<sup>⊗<em>n</em></sup> consists of <em>n</em>-fold tensor products of the basis elements of ℤ<sup><em>n</em></sup>, i.e. e.g. e<sub>5</sub> ⊗ e<sub>3</sub> ⊗ e<sub>1</sub> ⊗ e<sub>5</sub> ⊗ e<sub>1</sub>. Tensor products that include identical tensors must be sent to zero, since the determinant of a matrix in which two columns are identical is zero. It remains to check what the tensor products of distinct basis elements are sent to. The indices of the vectors in the tensor product form a bijection, i.e. a permutation, in which even permutations are sent to 1 and odd permutations are sent to -1.</p>

<p>For example, to find the determinant of [[1, 2], [3, 4]]: note that the columns are [1, 3] and [2, 4]. We decompose [1, 3] to give (1 e<sub>1</sub> + 3 e<sub>2</sub>) and (2 e<sub>1</sub> + 4 e<sub>2</sub>). The corresponding element in the tensor product is (1 e<sub>1</sub> ⊗ 2 e<sub>1</sub> + 1 e<sub>1</sub> ⊗ 4 e<sub>2</sub> + 3 e<sub>2</sub> ⊗ 2 e<sub>1</sub> + 3 e<sub>2</sub> ⊗ 4 e<sub>2</sub>), which we simplify to (2 e<sub>1</sub> ⊗ e<sub>1</sub> + 4 e<sub>1</sub> ⊗ e<sub>2</sub> + 6 e<sub>2</sub> ⊗ e<sub>1</sub> + 12 e<sub>2</sub> ⊗ e<sub>2</sub>). Therefore:</p>

<p><strong>det</strong> [[1, 2], [3, 4]] <br />
= <strong>det</strong>(1 e<sub>1</sub> + 3 e<sub>2</sub>, 2 e<sub>1</sub> + 4 e<sub>2</sub>) <br />
= <strong>det</strong>(2 e<sub>1</sub> ⊗ e<sub>1</sub> + 4 e<sub>1</sub> ⊗ e<sub>2</sub> + 6 e<sub>2</sub> ⊗ e<sub>1</sub> + 12 e<sub>2</sub> ⊗ e<sub>2</sub>) <br />
= <strong>det</strong>(2 e<sub>1</sub> ⊗ e<sub>1</sub>) + <strong>det</strong>(4 e<sub>1</sub> ⊗ e<sub>2</sub>) + <strong>det</strong>(6 e<sub>2</sub> ⊗ e<sub>1</sub>) + <strong>det</strong>(12 e<sub>2</sub> ⊗ e<sub>2</sub>) <br />
= 2 <strong>det</strong>(e<sub>1</sub> ⊗ e<sub>1</sub>) + 4 <strong>det</strong>(e<sub>1</sub> ⊗ e<sub>2</sub>) + 6 <strong>det</strong>(e<sub>2</sub> ⊗ e<sub>1</sub>) + 12 <strong>det</strong>( e<sub>2</sub> ⊗ e<sub>2</sub>) <br />
= 2 (0) + 4 (1) + 6 (-1) + 12 (0) <br />
= 4 - 6 <br />
= -2</p>

<p>Now it remains to prove that the formula for finding the parity of the permutation is valid. What my code does is essentially find the number of inversions, i.e. the places where an element on the left is bigger than an element on the right (not necessarily consecutively).</p>

<p>For example, in the permutation 3614572, there are 9 inversions (31, 32, 61, 64, 65, 62, 42, 52, 72), so the permutation is odd.</p>

<p>The justification is that each transposition (swapping two elements) either adds one inversion or takes away one inversion, swapping the parity of the number of inversions, and the parity of the permutation is the parity of the number of transpositions needed to achieve the permutation.</p>

<p>Therefore, in conclusion, our formula is given by:</p>

<h2>Why it works -- non-mathy version</h2>

<p><img src="https://i.sstatic.net/pfOYs.gif" alt=""></p>

<p>where σ is a permutation of 𝕊<sub><em>n</em></sub> the group of all permutations on <em>n</em> letters, and <strong>sgn</strong> is the sign of the permutation, AKA (-1) raised to the parity of the permutation, and <em>a</em><sub><em>ij</em></sub> is the (<em>ij</em>)<sup>th</sup> entry in the matrix (<em>i</em> down, <em>j</em> across).</p>
</div>
<div id="pu25" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>, 95 bytes</h1>

<p><em>-12 bytes thanks to Lynn.</em></p>

<p>Port of <a href="https://codegolf.stackexchange.com/a/147709/68615">my Haskell answer</a>.</p>



<pre class="lang-python prettyprint-override"><code>f=lambda m:sum((-1)**i*v*f([j[:i]+j[i+1:]for j in m[1:]])for i,v in enumerate(m[0]))if m else 1
</code></pre>

<p><a href="https://tio.run/##TY/RroIwEETf@Yp9pLhNbAEREr@k2QdubptbYtFANfHrcVs13j7tnM5MMtdH/LvMetvc6TyGn98RwrDeQllKJarKV/fKlWYyg6fdZPxODeQuC0zgZwiGFYmkPd4TsfMt2GWMtgxmT0J4BwHsebWgtmjXuMIJTAH8jGk0Eb5vjVATglEIzZey@nw0CC3CIZ0dwhGh/2erERRT3eSKntU7JTnDyf3XW3fcKFWrkz37Zd8l0nNGHdtXigtl/eL6QFRQUeSRaWKeMeS66@LnCK70YnsC" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>
</div>
<div id="pu26" class="pu"><h1>Haskell, 62 bytes</h1>

<pre><code>a#((b:c):r)=b*d(a++map tail r)-(a++[c])#r
_#_=0
d[]=1
d l=[]#l
</code></pre>

<p><a href="https://tio.run/##VVTRahsxEHz3Vwj8Yrd3Rdrd00kBf0K/wJjgxIWGOiG4@X93Z/YM10CEpdPOzu7M6vf5759f1@v9ft7udi9Pr/un2/7w8u2yO3///n7@TF/nt2u67Ufsj6@n/fa2ed4@H/LmcjwdyuaSrofjaXu9v5/fPtIhecjPtPu8vX18pR/pst8k/zum49HkdOJm8I0MSU/@owzJVse@fXyxIU1Dqvg5D6kNqa/v6ZCKH4sRpPtuCRs9yEPz6rLOjjmWSXCfAWOfcdI9qLQpwhxx1DiXuk6Vs58J1qmBbbAeO46nCfdrQFQEN8cRBaEmOBVtCMexNiemfd0GUydlDqLqcIILMrPm0To@gVBRJUTnGh8NR0ZS1W9MIKMlItWQp/g5ICQ7fMnkLbPDaQZPq8Z24Kf8RwmB1f/VQInIphV12sIMobUR1SnO6IYqOmHGmsvUyQ7JCuODu3mMzhlXKpiBjRmgVSBbiBLqV4/jMlqJDqKvoKtz1GIdaIgDeqHIJjCGTKt6PG2Qh7HmRicw5azIHno2NBHLCADUrMYaCtkIelIeXKDowjXKzWACFUcltHSsvGI9BKMB4DeBiSoZiV@Ye@ADsrKFQimFCMAsa98jpR8ZWw6GFlkyHYIZiN6wcSG00j2s1mEN0Ubu1EFzWYSAAuwONqWh/Tl8bRlkOh2G8pW1kzKRJAZPqDfSlJBbOvPUGBxvRQk41GbU1MMpG11WQFqnvoDBX9GLNoEdihN51O29aau@gC5dp5VX8oLuSaEyTEi/OG0sOZIUmrMIZ6lGTxEIeUpnFqVFYbKOJ4gDUGYKhbni/I5o2ISlggFnxaf40Sl/OiJbDtuRxhT@gXGZnvalroq2FXRMF5oc5ZGPigoRSa1hhDoIt/qwjPFVkk7hKovJrBgPFZ@ionz0OCwtHgJ2rCB/1Ofx@MAqBaRjxJkqpnWmDTD8tFifo0BjO1F0IPDhFUwujUMNRwhS@Ha3yNY5ODlGHZYmYYtXF7Sj2vIAdE1X6YQfGp3LRgqdhdoLBkqoq0GZsfo7l073fw" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a> (Footer with test cases taken from @totallyhuman's solution.)</p>

<p><code>d</code> computes the determinant using a Laplace expansion along the first column. Needs three bytes more than the <a href="https://codegolf.stackexchange.com/a/96837/56725">permanent</a>.</p>
</div>
<div id="pu27" class="pu"><h1><a href="https://www.r-project.org/" rel="noreferrer">R</a>, 32 bytes</h1>



<pre class="lang-r prettyprint-override"><code>function(m)Re(prod(eigen(m)$va))
</code></pre>

<p>Uses Not a Tree's algorithm of taking the eigenvalues of the matrix and taking the real part of their product.</p>

<p><a href="https://tio.run/##K/qfZvs/rTQvuSQzP08jVzMoVaOgKD9FIzUzPRXEVylL1NT8n2ubm1hSlFmhUZyYW5CTqmFoYGCgowAkNUEkCGtyFRRl5pVopKSWAHXBeGkg9n8A" rel="noreferrer" title="R – Try It Online">Try it online!</a></p>
</div>
<div id="pu28" class="pu"><h1>TI-Basic (83 series), <s>137</s> 133 bytes</h1>

<pre><code>Ans→[A]
For(N,max(dim(Ans)),2,-1
 Matr▶list(Ans,N,C
 1+sum(not(cumSum(not(not(∟C→R
 If R&gt;N
 Then
  0[A]→[A]
 Else
  rowSwap([A],R,N
  *row(cos(π(R≠N))Ans(N,N),Ans,1
  *row(-Ans(N,N)⁻¹,Ans,N
  For(I,1,N
   *row+(Ans(I,N),Ans,N,I→[A]
  End
 End
End
Ans(1,1
</code></pre>

<p>(Indentation is purely decorative and doesn't appear on the calculator.)</p>

<p>Instead of the built-in <code>det(</code>, does row reduction by hand. The pivots are built backwards, starting at the (<em>n</em>,<em>n</em>)<sup>th</sup> entry and going back to the (1,1)<sup>th</sup> (or is that (1,1)<sup>st</sup>?).</p>

<p>Every time we need to divide by a number to set the pivot to 1, we multiply the first row by the same number (possibly negated, if we needed to swap rows), so that the determinant of the matrix stays the same. (If we didn't find a pivot, we zero out the entire matrix.) As a result, at the end, the <s>(1,1)<sup>th</sup></s> <s>(1,1)<sup>st</sup></s> top left entry holds the determinant.</p>
</div>
<div id="pu29" class="pu"><h2><a href="https://www.wolfram.com/wolframscript/" rel="noreferrer">Wolfram Language (Mathematica)</a>, between 14 and 42 bytes</h2>

<p>We've had a <a href="https://codegolf.stackexchange.com/a/147671/66104">3-byte built-in</a> and a <a href="https://codegolf.stackexchange.com/a/147752/66104">53-byte solution</a> that completely avoids built-ins, so here are some weirder solutions somewhere in between.</p>

<p>The Wolfram Language has <a href="http://reference.wolfram.com/language/guide/MatrixDecompositions.html" rel="noreferrer">a lot of</a> very intense functions for decomposing matrices into products of other matrices with simpler structure. One of the simpler ones (meaning I've heard of it before) is Jordan decomposition. Every matrix is similar to a (possibly complex-valued) upper triangular matrix made of diagonal blocks with a specific structure, called the Jordan decomposition of that matrix. Similarity preserves determinants, and the determinant of a triangular matrix is the product of the diagonal elements, so we can compute the determinant with the following <strong>42 bytes</strong>:</p>

<pre><code>1##&amp;@@Diagonal@Last@JordanDecomposition@#&amp;
</code></pre>

<p>The determinant is also equal to the product of the eigenvalues of a matrix, with multiplicity. Luckily, Wolfram's eigenvalue function keeps track of multiplicity (even for non-diagonalisable matrices), so we get the following <strong>20 byte</strong> solution:</p>

<pre><code>1##&amp;@@Eigenvalues@#&amp;
</code></pre>

<p>The next solution is kind of cheating and I'm not really sure why it works. The Wronskian of a list of <em>n</em> functions is the determinant of the matrix of the first <em>n</em>-1 derivatives of the functions. If we give the <code>Wronskian</code> function a matrix of integers and say that the variable of differentiation is 1, somehow it spits out the determinant of the matrix. It's weird, but it doesn't involve the letters "<code>Det</code>" and it's only <strong>14 bytes</strong>…</p>

<pre><code>#~Wronskian~1&amp;
</code></pre>

<p>(The Casoratian determinant works as well, for 1 more byte: <code>#~Casoratian~1&amp;</code>)</p>

<p>In the realm of abstract algebra, the determinant of an <em>n</em> x <em>n</em> matrix (thought of as the map k → k that is multiplication by the determinant) is the <em>n</em>th exterior power of the matrix (after picking an isomorphism k → ⋀<sup>n</sup> k<sup>n</sup>). In Wolfram language, we can do this with the following <strong>26 bytes</strong>:</p>

<pre><code>HodgeDual[TensorWedge@@#]&amp;
</code></pre>

<p>And here's a solution that works for positive determinants only. If we take an <em>n</em>-dimensional unit hypercube and apply a linear transformation to it, the <em>n</em>-dimensional "volume" of the resulting region is the absolute value of the determinant of the transformation. Applying a linear transformation to a cube gives a parallelepiped, and we can take its volume with the following <strong>39 bytes</strong> of code:</p>

<pre><code>RegionMeasure@Parallelepiped[Last@#,#]&amp;
</code></pre>
</div>
<div id="pu30" class="pu"><h1><a href="https://github.com/lmendo/MATL" rel="nofollow noreferrer">MATL</a>, 3 bytes / 5 bytes</h1>
<h3>With built-in function</h3>
<pre><code>&amp;0|
</code></pre>
<p><a href="https://tio.run/##y00syfn/X82g5v//aGNzIx0FXUNTIGlkYmKtoGtpDuJbGuooGFqYAvmmxkC@MUTUyCwWAA" rel="nofollow noreferrer">Try it online!</a></p>
<h3>Without built-in</h3>
<p><em>Thanks to <a href="https://codegolf.stackexchange.com/users/74672/misha-lavrov">Misha Lavrov</a> for pointing out a mistake, now corrected</em></p>
<pre><code>YvpYo
</code></pre>
<p><a href="https://tio.run/##y00syfn/P7KsIDL///9oY3MjHQVdQ1MgaWRiYq2ga2kO4lsa6igYWpgC@abGQL4xRNTILBYA" rel="nofollow noreferrer">Try it online!</a></p>
<p>This computes the determinant as the product of the eigenvalues, rounded to the closest integer to avoid floating-point inaccuracies.</p>
<pre><code>Yv       % Implicit input. Push vector containing the eigenvalues
p        % Product
Yo       % Round. Implicit display
</code></pre>
</div>
<div id="pu31" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 2 bytes</h1>

<pre><code>ÆḊ
</code></pre>

<p><a href="https://tio.run/##TVHLbQUhDGyFAlgJfzBQy2qP7xK9BtJADqko91SSSjae4UXKxQLs@eG3x/P5ft/fHz9fn/d9n@dstUhftVhoLYfl9VDP4stqccm7erYPEZS2rlrOvGBO1DAY6BgwGpFsC@NuI@Hes6xZywrgZHS0Gl4NcgPiKAEHFuAYgePAsbWt1tCwQRsYP6ix5WUkkXh6MMVjTzV72TQho4FcyUhrMxG6YHiSWAMumXx1AINhGhP3NKuWpGJ5F2CTYTA4f0ygv/MlHg2mVJj2AQ5K@c4Ad/grb5hcYwd0fidCbwZDKFUMSxbtpMm4IpiZW211bgxYl4VtgYVcij9@pZU/wtzpPzllY04qc5uTK3SsA2ju1bGZI/S6fgE" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>

<p><s>Currently only built-in solution. :(</s> Looks like others have managed to find out interesting non-built-in solutions.</p>
</div>
<div id="pu32" class="pu"><h1><a href="https://www.gnu.org/software/octave/" rel="nofollow noreferrer">Octave</a>, 28 bytes</h1>



<pre class="lang-matlab prettyprint-override"><code>@(x)round(prod(diag(qr(x))))
</code></pre>

<p><a href="https://tio.run/##y08uSSxL/Z9mq6en999Bo0KzKL80L0WjoCg/RSMlMzFdo7AIKAgE/9M0oqONzY10FHQNTYGkkYlJrLVCtK6lOUjE0lBHwdDCFCxiagwUMYaIG5nFxmr@BwA" rel="nofollow noreferrer" title="Octave – Try It Online">Try it online!</a></p>

<p>This uses the <a href="https://en.wikipedia.org/wiki/QR_decomposition" rel="nofollow noreferrer">QR decomposition</a> of a matrix <strong>X</strong> into an orthgonal matrix <strong>Q</strong> and an upper triangular matrix <strong>R</strong>. The determinant of <strong>X</strong>  is the product of those of <strong>Q</strong> and <strong>R</strong>. An orthogonal matrix has unit determinant, and for a triangular matrix the determinant is the product of its diagonal entries. Octave's <code>qr</code> function called with a single output gives <strong>R</strong>.</p>

<p>The result is rounded to the closest integer. For large input matrices, floating-point inaccuracies may produce an error exceeding <code>0.5</code> and thus produce a wrong result.</p>
</div>
<div id="pu33" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 24 bytes</h1>

<pre><code>œcL’$ṚÑ€
J-*×Ḣ€×ÇSµḢḢ$Ṗ?
</code></pre>

<p><a href="https://tio.run/##y0rNyan8///o5GSfRw0zVR7unHV44qOmNVxeulqHpz/csQjIPjz9cHvwoa1ADhABVUyz////f3S0obGOgqG5joKRSayOQrShJZCno2AMYuua6iiY6CgYxMYCAA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>

<h1>Explanation</h1>

<pre><code>œcL’$ṚÑ€         Helper Link; get the next level of subdeterminants (for Laplace Expansion)
œc               Combinations without replacement of length:
  L’$            Length of input - 1 (this will get all submatrices, except it's reversed)
     Ṛ           Reverse the whole thing
      Ñ€         Get the determinant of each of these
J-*×Ḣ€×ÇSµḢḢ$Ṗ?  Main Link
              ?  If the next value is truthy
             Ṗ   Remove the last element (truthy if the matrix was at least size 2)
J-*×Ḣ€×ÇSµ       Then expand
          ḢḢ$    Otherwise, get the first element of the first element (m[0][0] in Python)
J                [1, 2, ..., len(z)]
 -*              (-1 ** z) for each z in the length range
   ×             Vectorizing multiply with
    Ḣ€           The first element of each (this gets the first column); modifies each row (makes it golfier yay)
      ×Ç         Vectorizing multiply with the subdeterminants
        S        Sum
</code></pre>

<p>-2 bytes thanks to user202729's solution</p>
</div>
<div id="pu34" class="pu"><h1><a href="http://jsoftware.com/" rel="nofollow noreferrer">J</a>, 5 bytes</h1>

<pre><code>-/ .*
</code></pre>

<p><a href="https://tio.run/##y/qfVqxga6VgoADE/3X1FfS0/mtyKekpqKfZWqkr6CjUWimkFXOlJmfkK6Qp2BkpGFsrGCqYwAUMjRUMzRWMTICilkAJoGy8qYKJAtAsAA" rel="nofollow noreferrer" title="J – Try It Online">Try it online!</a></p>
</div>
<div id="pu35" class="pu"><h1>TI-Basic, 2 bytes</h1>

<pre><code>det(Ans
</code></pre>

<p>Ah, well.</p>

<p><a href="https://codegolf.meta.stackexchange.com/questions/10127/how-can-we-help-users-who-are-put-off-by-the-use-of-golfing-languages/10132#10132">Please don't upvote trivial answers.</a></p>

<p><sub>As a high school student (who's forced to own one of these calculators), this function is hella useful so...</sub></p>
</div>
<div id="pu36" class="pu"><h1><a href="https://www.gnu.org/software/octave/" rel="nofollow noreferrer">Octave</a>, 30 bytes</h1>



<pre class="lang-matlab prettyprint-override"><code>@(x)-prod(diag([~,l,~]=lu(x)))
</code></pre>

<p><a href="https://tio.run/##y08uSSxL/Z9mq6en999Bo0JTt6AoP0UjJTMxXSO6TidHpy7WNqcUKK6p@T9NIzra2NxIR0HX0BRIGpmYxForROtamoNELA11FAwtTMEipsZAEWOIuJFZbKzmfwA" rel="nofollow noreferrer" title="Octave – Try It Online">Try it online!</a></p>

<p>or, the boring 4 byte solution (saved 6 bytes thanks to Luis Mendo (forgot the rules regaring builtin functions)):</p>

<pre class="lang-matlab prettyprint-override"><code>@det
</code></pre>

<h3>Explanation:</h3>

<p>Coming up! :)</p>
</div>
<div id="pu37" class="pu"><h1><a href="http://julialang.org/" rel="nofollow noreferrer">Julia</a>, 3 bytes</h1>



<pre class="lang-julia prettyprint-override"><code>det
</code></pre>

<p><a href="https://tio.run/##yyrNyUw0/f8/zTYlteR/QVFmXolGmka0kYKxtaGCSaym5n8A" rel="nofollow noreferrer" title="Julia 0.5 – Try It Online">Try it online!</a></p>
</div>
<div id="pu38" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a> + <a href="https://pypi.python.org/pypi/numpy/1.13.3" rel="nofollow noreferrer">numpy</a>, 29 bytes</h1>



<pre class="lang-python prettyprint-override"><code>from numpy.linalg import*
det
</code></pre>

<p><a href="https://tio.run/##Jci7CoAgFADQva@4Y4UFviqHvkQcgrKEfCA29PVmtZzhhDsd3pGcdfQW3GXD3Z/GLecOxgYfU1vped1SDtG4VOtaSjoSBB3mRcKYQiA7Mb4jMAI88W84LUP/J4NSTZMf" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>
</div>
<div id="pu39" class="pu"><h1><a href="https://www.wolfram.com/wolframscript/" rel="nofollow noreferrer">Wolfram Language (Mathematica)</a>, 3 bytes</h1>

<pre><code>Det
</code></pre>

<p><a href="https://tio.run/##y00syUjNTSzJTE78n2b73yW15H9AUWZeSXRadDVXNaehDqeRDqdxrQ6QbaLDaarDaQZmm@twWuhwWtZy1cbG/gcA" rel="nofollow noreferrer" title="Wolfram Language (Mathematica) – Try It Online">Try it online!</a></p>

<p>Per the <a href="https://codegolf.meta.stackexchange.com/questions/13128/non-trivial-answers-get-too-few-upvotes">meta consensus</a>, mainly upvote nontrivial solutions that take effort to write.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/147668/">147668</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




