<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::65382</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>059</td><td>TIBASIC TI84 Plus CE Python</td><td>250819T141121Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/283211#283211">madeforl</a></td></tr>
<tr d-ix="1"><td>044</td><td>Desmos</td><td>250801T235020Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/282917#282917">ErikDaPa</a></td></tr>
<tr d-ix="2"><td>052</td><td>Python 3 + sympy</td><td>250706T045352Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/282567#282567">Lucenapo</a></td></tr>
<tr d-ix="3"><td>045</td><td>Actually</td><td>160826T070338Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/91190#91190">Sherlock</a></td></tr>
<tr d-ix="4"><td>022</td><td>Pyth</td><td>190821T075726Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/190504#190504">ar4093</a></td></tr>
<tr d-ix="5"><td>166</td><td>APLNARS</td><td>190812T201112Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/189835#189835">user5898</a></td></tr>
<tr d-ix="6"><td>147</td><td>Axiom</td><td>170518T143935Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/121383#121383">user5898</a></td></tr>
<tr d-ix="7"><td>057</td><td>Axiom</td><td>170423T215528Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/117390#117390">user5898</a></td></tr>
<tr d-ix="8"><td>118</td><td>Python 2</td><td>151201T031303Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/65410#65410">primo</a></td></tr>
<tr d-ix="9"><td>168</td><td>Javascript</td><td>161118T144219Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/100313#100313">Marquis </a></td></tr>
<tr d-ix="10"><td>010</td><td>J</td><td>160928T043743Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/94764#94764">miles</a></td></tr>
<tr d-ix="11"><td>093</td><td>R</td><td>160826T210558Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/91292#91292">Rudier</a></td></tr>
<tr d-ix="12"><td>083</td><td>Perl 6</td><td>160826T074603Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/91197#91197">bb94</a></td></tr>
<tr d-ix="13"><td>095</td><td>Haskell</td><td>160423T123541Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/78311#78311">Sherlock</a></td></tr>
<tr d-ix="14"><td>061</td><td>Ruby</td><td>160107T090809Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/68787#68787">Sherlock</a></td></tr>
<tr d-ix="15"><td>112</td><td>Python 3</td><td>151130T214056Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/65386#65386">Sherlock</a></td></tr>
<tr d-ix="16"><td>033</td><td>CJam</td><td>151202T130214Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/65537#65537">Peter Ta</a></td></tr>
<tr d-ix="17"><td>079</td><td>gawk4</td><td>151203T175959Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/65660#65660">Cabbie40</a></td></tr>
<tr d-ix="18"><td>101</td><td>Perl</td><td>151203T125515Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/65640#65640">primo</a></td></tr>
<tr d-ix="19"><td>063</td><td>GolfScript</td><td>151203T104535Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/65630#65630">primo</a></td></tr>
<tr d-ix="20"><td>020</td><td>Julia</td><td>151201T094910Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/65430#65430">alephalp</a></td></tr>
<tr d-ix="21"><td>130</td><td>Python 2</td><td>151202T202315Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/65583#65583">Dennis</a></td></tr>
<tr d-ix="22"><td>023</td><td>PARI/GP</td><td>151201T033440Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/65412#65412">alephalp</a></td></tr>
<tr d-ix="23"><td>022</td><td>Mathematica</td><td>151201T025515Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/65408#65408">alephalp</a></td></tr>
<tr d-ix="24"><td>042</td><td>Mathematica</td><td>151130T220533Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/65390#65390">LegionMa</a></td></tr>
<tr d-ix="25"><td>045</td><td>PARI/GP</td><td>151201T091220Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/65428#65428">primo</a></td></tr>
<tr d-ix="26"><td>097</td><td>Minkolang 0.14</td><td>151130T232314Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/65396#65396">El&#39;e</a></td></tr>
<tr d-ix="27"><td>058</td><td>Julia</td><td>151130T211614Z</td><td><a href="https://codegolf.stackexchange.com/questions/65382/bernoulli-numbers/65384#65384">Alex A.</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>TI-BASIC (TI-84 Plus CE Python), 59 bytes</h1>
<pre><code>Input F
{1→L₁
For(M,1,F
1-Σ((M nCr K)L₁(K+1)/(M-K+1),K,0,M-1→L₁(M+1
End
Ans
</code></pre>
<p>Pretty much the exact equation, except the list is changed to be 1-indexed.</p>
<p>Outputs in decimal representation.</p>
<p>outputs:</p>
<pre><code>Input -&gt; Output
1     -&gt; 0.5
6     -&gt; 0.0238095238
9     -&gt; -3.4ᴇ-12
15    -&gt; 1.255ᴇ-10
30    -&gt; 601580873.9
40    -&gt; -1.92965793ᴇ16
58    -&gt; 2.38654275ᴇ32
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://desmos.com" rel="nofollow noreferrer">Desmos</a>, 44 bytes</h1>
<pre><code>B(x)=1-∑_{n=0}^{x-1}(nCr(x,n)B(n))/(x-n+1)
B(0)=1
</code></pre>
<p><a href="https://www.desmos.com/calculator/mjv2mqrmo2" rel="nofollow noreferrer">Try this online!</a></p>
</div>
<div id="pu2" class="pu"><h1><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python 3</a> + sympy, 52 bytes</h1>

<pre class="lang-python prettyprint-override"><code>lambda x:+(x&lt;1)or-zeta(1-x)*x
from sympy import zeta
</code></pre>
<p><a href="https://tio.run/##FckxDoUgDADQ3VN0bP06EBMH872JC0ZREqGkMhQvj/GtL5V8chyqm5d62bBuFnT6of4NsfTPni2aXqnVxgkHuEtIBXxILBm@rY4FFHwEsfHYcTQ0NZDEx4zaOVSi@gI" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/Mego/Seriously" rel="nofollow noreferrer">Actually</a>, <s>46</s> 45 bytes</h1>
<p>I've been meaning to do a Seriously/Actually answer for months and now I can. Golfing suggestions welcome. <a href="https://tio.run/nexus/actually#@2/9aOq00qJHPQuAjLkQhrVB3aPG/RqPps5@NK1D69HUORqlQL7Wo56FvucWA0VLs0HMR1PWZDpYn2@w1nw0syFGyyH70bQ9//@bGQAA" rel="nofollow noreferrer" title="Actually – TIO Nexus">Try it online!</a></p>
<p><strong>Edit:</strong> In February of 2017, there was an update to Actually that changed which function literals are which. Enjoy.</p>
<p>This uses the explicit definition of the Bernoulli numbers on Wikipedia.</p>
<pre><code>;╖ur⌠;╝ur⌠;;0~ⁿ(╛█*╜(uⁿ*⌡MΣ╛uk⌡M┬i@;π;)♀\*@k▼
</code></pre>
<p><strong>Ungolfing</strong></p>
<pre><code>;╖     Duplicate and save m in register 0.
ur     Range [0..m]
  ⌠      Start first for loop
  ;╝     Duplicate and save k in register 1.
  ur     Range [0..k]
    ⌠      Start second for loop (as string).
    ;;     Duplicate v twice.
    0~ⁿ    Push -1, and pow() to get (-1)**v.
    (╛█    Rotate a duplicate v to TOS, push k, and binom(k, v).
    *      Multiply (-1)**v by binom(k, v).
    ╜(uⁿ   Push m, rotate last duplicate v to TOS, increment, and pow() to get (v+1)**m.
    *      (-1)**v * binom(k, v) * (v+1)**m
    ⌡      End second for loop (string turned to function).
  MΣ     Map over range [0..v] and sum
  ╛u     Push k and increment (the denominator)
           (Note: second for loop does numerators only as denominator only depends on k)
  k      Push fraction in list form [numerator, denominator]
  ⌡      End first for loop
M      Map over range [0..k]
┬i@    Transpose all of the fractions, flatten and swap.
         Stack: [denominators] [numerators]
;π     Duplicate and take product of denominators.
;)     Duplicate product and move to bottom of stack.
         Stack: product [denominators] [numerators] product
♀\     For all items in denominators, integer divide product by item.
         Return a list of these scaled-up denominators.
*      Dot product of numerators and the scaled-up denominators as new numerator.
         (In effect, getting the fractions to the same denominator and summing them)
@k     Swap new numerator and product (new denominator) and turn into a list (fraction).
▼      Divide fraction by gcd(numerator, denominator) (Simplify fraction).
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/isaacg1/pyth" rel="nofollow noreferrer">Pyth</a>, 22 bytes</h1>

<pre><code>L?b-1sm*.cbdcyd-btdUb1
</code></pre>

<p><a href="https://tio.run/##K6gsyfj/38c@SdewOFdLLzkpJbkyRTepJCU0yfB/ZeB/MwMA" rel="nofollow noreferrer" title="Pyth – Try It Online">Try it online!</a></p>

<p>Defines a function that is called as <code>y&lt;number&gt;</code>, e.g. <code>yQ</code>.</p>

<pre><code>L                      # y=lambda b:
 ?b                  1 # ... if b else 1
   -1                  # 1 -
     s                 #     sum(
      m            Ub  #         map(lambda d: ... , range(b)) 
       *.cbd           #           combinations(b, d) *
            cyd        #             y(d) /      (float division)
               -btd    #                    b - (d - 1)
</code></pre>
</div>
<div id="pu5" class="pu"><h1>APL(NARS), 83 chars, 166 bytes</h1>
<pre><code>r←B w;i
r←,1⋄i←0x⋄w+←1
→3×⍳w≤i+←1⋄r←r,1-+/{(1+i-⍵)÷⍨(⍵!i)×r[⍵+1]}¨0..i-1⋄→2
r←r[i]
</code></pre>
<p>Input as integer output as big rational</p>
<pre><code>  B 0
1
  B 1
1r2 
  B 2
1r6 
  B 3
0 
  B 4
¯1r30 
  B 10
5r66 
  B 100
¯94598037819122125295227433069493721872702841533066936133385696204311395415197247711r33330 
  B 1000
¯1824310473866188725457264025685778887933833686704290605219715815764112625726249111586574725773210697096154899246
  27495522908087488299539455188791856758224155166849269724418491401224257983095561709862992465225174097919156
  37226361428342780548971002281045465308441161372350696920220116244179176068026260201962026025579005841653927
  13328528060009666284676390683434226380702951226108116666172815817157023611889303668166839919156379768387784
  56901148431227534274268805917998837802553382786645786602185045895962670442011443630321460259486764674312436
  99485605430176555742513711502134010510584086798747663529527491787349736768598347076238816346251471489942512
  87819057432353129907040693030947738925173870541768065311836481894518927257264459495897596007053347675853897
  69924857630972963997636483244264351262207385878011073153983309981755577513600811117079762505973229513088849
  00670113339167641953793994512377610306198429310933121463214168354260774664123208985481506462912959653699738
  06082564288019784909897301658268809203555030692846151917069465607257641149187197651090551596684031241184554
  36505930214028492216913418528197912335893019941012291773441794027493574651881059432274494354092231954894280
  74206847271461929421334360546114754048678863132501143996815327532364292906259093411000391368336312138915621
  70153595481408420879424166549229427077334760558784157659275820142147265848222364436913143660975700854733545
  84000998591519058404733793433129733940339271957909399584231274683687116967497864609134118725271669900471262
  22109345933847358924230951718379883743256346548760417031607741875424271006526981819059127169069544663383612
  03745255515267088218383996330164203403732365333352120338272021319718003599422045899487646001835027038563411
  78077687451616229338340631455056219106004731529642292049578901r342999030 
</code></pre>
</div>
<div id="pu6" class="pu"><h1>Axiom, <s>134</s> 147 bytes</h1>

<pre><code>b(n:NNI):FRAC INT==(v:=[1/1];k:=1;repeat(k&gt;n=&gt;break;r:=1-reduce(+,[binomial(k,j)*v.(j+1)/(k-j+1)for j in 0..k-1]);v:=append(v,[r]);k:=k+1);v.(n+1))
</code></pre>

<p>ungolf and test</p>

<pre><code>(23) -&gt; b
   (23)
   b n ==
           1
     v := [-]
           1
     k := 1
     repeat
       if n &lt; k
         then break
         else
                               binomial(k,j)v(j + 1)
           r := 1 - reduce(+,[[--------------------- for j in 0..(k - 1)]])
                                     k - j + 1
           v := append(v,[r])
           k := k + 1
     v(n + 1)
                                                   Type: FunctionCalled b
(50) -&gt; [[i,b(i)]  for i in [0,1,2,3,4,5,6,7,8,9,10]]
   (50)
             1     1              1            1              1             5
   [[0,1],[1,-],[2,-],[3,0],[4,- --],[5,0],[6,--],[7,0],[8,- --],[9,0],[10,--]]
             2     6             30           42             30            66
                                         Type: List List Fraction Integer

(51) -&gt; b 1000
   (51)
   -
   18243104738661887254572640256857788879338336867042906052197158157641126_
    2572624911158657472577321069709615489924627495522908087488299539455188_
    7918567582241551668492697244184914012242579830955617098629924652251740_
    9791915637226361428342780548971002281045465308441161372350696920220116_
    2441791760680262602019620260255790058416539271332852806000966628467639_
    0683434226380702951226108116666172815817157023611889303668166839919156_
    3797683877845690114843122753427426880591799883780255338278664578660218_
    5045895962670442011443630321460259486764674312436994856054301765557425_
    1371150213401051058408679874766352952749178734973676859834707623881634_
    6251471489942512878190574323531299070406930309477389251738705417680653_
    1183648189451892725726445949589759600705334767585389769924857630972963_
    9976364832442643512622073858780110731539833099817555775136008111170797_
    6250597322951308884900670113339167641953793994512377610306198429310933_
    1214632141683542607746641232089854815064629129596536997380608256428801_
    9784909897301658268809203555030692846151917069465607257641149187197651_
    0905515966840312411845543650593021402849221691341852819791233589301994_
    1012291773441794027493574651881059432274494354092231954894280742068472_
    7146192942133436054611475404867886313250114399681532753236429290625909_
    3411000391368336312138915621701535954814084208794241665492294270773347_
    6055878415765927582014214726584822236443691314366097570085473354584000_
    9985915190584047337934331297339403392719579093995842312746836871169674_
    9786460913411872527166990047126222109345933847358924230951718379883743_
    2563465487604170316077418754242710065269818190591271690695446633836120_
    3745255515267088218383996330164203403732365333352120338272021319718003_
    5994220458994876460018350270385634117807768745161622933834063145505621_
    9106004731529642292049578901
     /
    342999030
                                                   Type: Fraction Integer

(52) -&gt; b 60
           1215233140483755572040304994079820246041491
   (52)  - -------------------------------------------
                             56786730
                                                   Type: Fraction Integer
</code></pre>
</div>
<div id="pu7" class="pu"><h1>Axiom, 57 bytes</h1>

<pre><code>g(n)==factorial(n)*coefficient(taylor(t*%e^t/(%e^t-1)),n)
</code></pre>

<p>code for test and results</p>

<pre><code>(18) -&gt; [[i, g(i)]  for i in 0..29]
   (18)
              1      1                1              1                1
   [[0,1], [1,-], [2,-], [3,0], [4,- --], [5,0], [6,--], [7,0], [8,- --],
              2      6               30             42               30
                5                  691               7                 3617
    [9,0], [10,--], [11,0], [12,- ----], [13,0], [14,-], [15,0], [16,- ----],
               66                 2730               6                  510
                43867                 174611               854513
    [17,0], [18,-----], [19,0], [20,- ------], [21,0], [22,------], [23,0],
                 798                    330                  138
          236364091               8553103                 23749461029
    [24,- ---------], [25,0], [26,-------], [27,0], [28,- -----------], [29,0]]
             2730                    6                        870
                                       Type: List List Expression Integer

(19) -&gt; g 60
           1215233140483755572040304994079820246041491
   (19)  - -------------------------------------------
                             56786730
                                                 Type: Expression Integer
</code></pre>

<p>one has to note that the function is not the one someone wrote above
but <code>t*%e^t/(%e^t-1))</code> with %e Euler costant</p>
</div>
<div id="pu8" class="pu"><h1>Python 2, 118 bytes</h1>
<p><em>Saved 6 bytes due to <a href="https://codegolf.stackexchange.com/posts/comments/158355?noredirect=1">xsot</a>.</em><br />
<em>Saved <s>6</s> 10 more due to <a href="https://codegolf.stackexchange.com/posts/comments/158810?noredirect=1">Peter Taylor</a>.</em></p>

<pre class="lang-python prettyprint-override"><code>n=input()
a=[n%4-1,n&lt;2]*n;exec&quot;a=[(a[j-1]+a[j+1])*j/2for j in range(len(a)-2)];&quot;*~-n
print+(n&lt;1)or-n/(2.**n-4**n)*a[1]
</code></pre>
<p>Uses the following identity:</p>
<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chl=B_%7B2n%7D%3D%28-1%29%5E%7Bn-1%7D%5Cfrac%7B2n%7D%7B4%5E%7B2n%7D-2%5E%7B2n%7D%7DA_%7B2n-1%7D" alt="" /></p>
<p>where <em>A<sub>n</sub></em> is the <em>n<sup>th</sup></em> <a href="http://en.wikipedia.org/wiki/Alternating_permutation#Related_integer_sequences" rel="nofollow noreferrer">Alternating Number</a>, which can be formally defined as the number of alternating permutations on a set of size <em>n</em>, halved (see also: <a href="http://oeis.org/A000111" rel="nofollow noreferrer">A000111</a>).</p>
<p>The algorithm used was originally given by <a href="http://www.ams.org/journals/mcom/1967-21-100/S0025-5718-1967-0221735-9/" rel="nofollow noreferrer">Knuth and Buckholtz (1967)</a>:</p>
<blockquote>
<p><em>Let T<sub>1,k</sub> = 1 for all k = 1..n</em></p>
<p><em>Subsequent values of T are given by the recurrence relation:</em></p>
<p><em>T<sub>n+1,k</sub> = 1/2</em> [ <em>(k - 1) T<sub>n,k-1</sub> + (k + 1) T<sub>n,k+1</sub></em> ]</p>
<p><em>A<sub>n</sub> is then given by T<sub>n,1</sub></em></p>
<p>(see also: <a href="http://oeis.org/A185414" rel="nofollow noreferrer">A185414</a>)</p>
</blockquote>
<hr />
<h2>Python 2, 152 bytes</h2>
<pre class="lang-python prettyprint-override"><code>from fractions import*
n=input()
a=[n%4-1,n&lt;2]*n
for k in range(n-1):a=[(a[j-1]+a[j+1])*j/2for j in range(n-k)]
print+(n&lt;1)or Fraction(n*a[1],4**n-2**n)
</code></pre>
<p>Prints the exact fractional representation, necessary for values greater than 200 or so.</p>
</div>
<div id="pu9" class="pu"><h2>Javascript, 168 bytes</h2>

<pre><code>function h(b,a){return a?h(a,b%a):b}for(var c=[],a=[],e=0,b,d,f,g;e&lt;=k;)for(c[b=d=e]=1,a[e]=++e;d;)f=c[--d]*a[b]-(c[b]*=g=a[d]),r=h(f*=b,g=a[b]*=g),c[d]=f/r,a[--b]=g/r;
</code></pre>

<p>Set the 'k' variable to the Bernoulli number you want, and the result is c[0] over a[0]. (numerator &amp; denominator)</p>

<h2>Sample Usage</h2>

<pre><code>k = 2;
console.log(c[0] + "/" + a[0]);
</code></pre>

<p>Not as small as the others, but the only one I've written that comes close. See <a href="https://marquisdegeek.com/code_ada99" rel="nofollow noreferrer">https://marquisdegeek.com/code_ada99</a> for my other (non-golf) attempts.</p>
</div>
<div id="pu10" class="pu"><h1>J, 10 bytes</h1>

<pre><code>(%1-^@-)t:
</code></pre>

<p>Computes the <em>n<sup>th</sup></em> Bernoulli number by finding the <em>n<sup>th</sup></em> coefficient of the exponential generating function of <em>x</em>/(1 - <em>e<sup>-x</sup></em>).</p>

<h2>Usage</h2>

<p>If the input is given integer or floats as an argument, it will output a float. If given an extended integer, marked with a suffix <code>x</code>, it will output either an extended integer or a rational, two extended integers separated by <code>r</code>.</p>

<pre><code>   f =: (%1-^@-)t:
   f 1
0.5
   f 1x
1r2
   (,.f"0) i. 10x
0     1
1   1r2
2   1r6
3     0
4 _1r30
5     0
6  1r42
7     0
8 _1r30
9     0
</code></pre>

<h2>Explanation</h2>

<pre><code>(%1-^@-)t: Input: n
(      )t: Takes a monad and creates a new monad that
           computes the coefficients of its egf
(      )   A monad that operates on x
      -      Negate x
    ^@       Computes its exponential, e^-x
  1-         Subtract it from 1
 %           Divide x by it, x/(1 - e^-x)
</code></pre>
</div>
<div id="pu11" class="pu"><h1>R, 93 bytes</h1>
<pre><code>function(m){if(m==0){1}else{v=c();for(k in 0:(m-1))v=c(v,choose(m,k)*f(k)/(m-k+1));1-sum(v)}}
</code></pre>
<p>Not really original as a solution. If any comment, please feel free !</p>
<p><strong>Ungolfed :</strong></p>
<pre><code>function(m)
    if(m==0){1}
    else
         v=c()
         for(k in 0:(m-1))
            v=c(v,choose(m,k)*f(k)/(m-k+1))

1-sum(v)
</code></pre>
</div>
<div id="pu12" class="pu"><h2>Perl 6, 83 bytes</h2>

<pre><code>my &amp;B={$^m??1-[+] (^$m).map: {combinations($m,$_)*B($_)/($m+1-$_)}!!1};say B slurp;
</code></pre>

<p>A faster, 114-byte solution:</p>

<pre><code>my @b=1;for 1..+slurp() {@b.push: 1-[+] (^$^m).map: {([*] $m+1-$_..$m)*@b[$_]/($m+1-$_)/([*] 1..$_)}};say @b[*-1];
</code></pre>
</div>
<div id="pu13" class="pu"><h1>Haskell, 95 bytes</h1>



<pre class="lang-haskell prettyprint-override"><code>import Data.Ratio
p=product
b m=sum[p[k-v+1..k]*(v+1)^m%(p[-v..0-1]*(k+1))|k&lt;-[0..m],v&lt;-[0..k]]
</code></pre>

<p>This implements the explicit definition of Bernoulli numbers outlined on the <a href="http://en.wikipedia.org/wiki/Bernoulli_numbers" rel="nofollow">Wikipedia page</a>.</p>
</div>
<div id="pu14" class="pu"><h1>Ruby, <s>66</s> 61 bytes</h1>



<p>This is a Ruby version of my Python answer.</p>

<pre class="lang-ruby prettyprint-override"><code>b=-&gt;m{s,p=0r,1;m.times{|k|a=m-k;s+=p*b[k]/-~a;p=p*a/-~k};1-s}
</code></pre>

<p>Since this uses <code>Rational</code> in its answers, I'm fairly sure this works up to 60, but I had trouble running even <code>b[24]</code>, so I implemented the lookup table again for <s>86</s> <s>81</s> 80 bytes.</p>

<pre class="lang-ruby prettyprint-override"><code>t=-&gt;m{s,p,r=0r,1,m&gt;0?t[m-1]:[];m.times{|k|a=m-k;s+=p*r[k]/-~a;p=p*a/-~k};r&lt;&lt;1-s}
</code></pre>
</div>
<div id="pu15" class="pu"><h1>Python 3, 112 bytes</h1>

<p><strong>Edit:</strong> I cleaned up this answer. If you want to see all the other ways I thought of to answer this question in Python 2 and 3, look in the revisions.</p>
<p>If I don't use the lookup table (and I use memoization instead), I manage to get the recursive definition to 112 bytes! WOO! Note that <code>b(m)</code> returns a <code>Fraction</code>. As usual, <a href="https://mothereff.in/byte-counter#from%20fractions%20import%2A%0Adef%20e%28m%29%3A%0A%20if%20m%3C1%3Areturn%201%0A%20s%3Dk%3D0%3Bp%3D1%0A%20while%20k%3Cm%3Aa%3Dm-k%3Bs%2B%3DFraction%28p%2Ae%28k%29%29%2F-%7Ea%3Bp%3Dp%2Aa%2F%2F-%7Ek%3Bk%2B%3D1%0A%20return%201-s" rel="nofollow noreferrer">the byte count</a> and <a href="http://ideone.com/ZG7m33" rel="nofollow noreferrer">a link for testing</a>.</p>
<pre class="lang-python prettyprint-override"><code>from fractions import*
def b(m):
 s=k=0;p=1
 while k&lt;m:a=m-k;s+=Fraction(p*b(k))/-~a;p=p*a//-~k;k+=1
 return 1-s
</code></pre>
<p>And a function that does use a lookup table, and returns the whole table of fractions from <code>b(0)</code> to <code>b(m)</code>, inclusive.</p>
<pre class="lang-python prettyprint-override"><code>from fractions import*
def b(m,r=[]):
 s=k=0;p=1
 while k&lt;m:
  if k&gt;=len(r):r=b(k,r)
  a=m-k;s+=Fraction(p*r[k])/-~a;p=p*a//-~k;k+=1
 return r+[1-s]
</code></pre>
</div>
<div id="pu16" class="pu"><h2>CJam, <s>69 49 34</s> 33 bytes</h2>

<pre><code>{_),:):R_:*_@f/@{_(;.-R.*}*0=\d/}
</code></pre>

<p><a href="http://cjam.aditsu.net/#code=%7B_)%2C%3A)%3AR_%3A*_%40f%2F%40%7B_(%3B.-R.*%7D*0%3D%5Cd%2F%7D%0A%0A61%25N*" rel="nofollow noreferrer">Online demo</a></p>

<p>Thanks to <a href="https://codegolf.stackexchange.com/users/44613/cabbie407">Cabbie407</a>, whose answer made me aware of the Akiyama–Tanigawa algorithm.</p>

<h3>Dissection</h3>

<pre><code>{           e# Function: takes n on the stack
  _),:)     e# Stack: n [1 2 3 ... n+1]
  :R        e# Store that array in R
  _:*       e# Stack: n [1 2 3 ... n+1] (n+1)!
  _@f/      e# Stack: n (n+1)! [(n+1)!/1 (n+1)!/2 (n+1)!/3 ... (n+1)!/(n+1)]
            e#   representing [1/1 1/2 ... 1/(n+1)] but avoiding floating point
  @{        e# Repeat n times:
    _(;.-   e#   Take pairwise differences
    R.*     e#   Pointwise multiply by 1-based indices
  }*        e#   Note that the tail of the array accumulates junk, but we don't care
  0=\d/     e# Take the first element and divide by (n+1)!
}
</code></pre>
</div>
<div id="pu17" class="pu"><h1>gawk4, 79 bytes</h1>

<p>77 bytes code + 2 bytes for <code>-M</code> flag</p>

<pre class="lang-awk prettyprint-override"><code>PREC^=2{for(n=$0;m++&lt;=n;)for($(j=m)=1/m;j&gt;1;)$j=(-$j+$--j)*j;printf"%.6f",$1}
</code></pre>

<p>It's an implementation of the Akiyama–Tanigawa algorithm from the Wikipedia page.</p>

<p>Had some trouble with the "6-decimal-digits-rule", because this prints the whole number and then 6 digits, but there is no list here to compare the results.</p>

<p>A flaw is that this prints a minus sign in front of the <code>0.000000</code> al lot of times, but I don't think that's wrong.</p>

<h2>Usage example</h2>

<pre class="lang-sh prettyprint-override"><code>echo 58 | awk -M 'PREC^=2{for(n=$0;m++&lt;=n;)for($(j=m)=1/m;j&gt;1;)$j=(-$j+$--j)*j;printf"%.6f",$1}'
</code></pre>

<h2>Output from 0 to 60</h2>

<pre>
0 -> 1.000000
1 -> 0.500000
2 -> 0.166667
3 -> -0.000000
4 -> -0.033333
5 -> 0.000000
6 -> 0.023810
7 -> 0.000000
8 -> -0.033333
9 -> 0.000000
10 -> 0.075758
11 -> -0.000000
12 -> -0.253114
13 -> -0.000000
14 -> 1.166667
15 -> -0.000000
16 -> -7.092157
17 -> -0.000000
18 -> 54.971178
19 -> -0.000000
20 -> -529.124242
21 -> -0.000000
22 -> 6192.123188
23 -> 0.000000
24 -> -86580.253114
25 -> 0.000000
26 -> 1425517.166667
27 -> 0.000000
28 -> -27298231.067816
29 -> 0.000000
30 -> 601580873.900642
31 -> 0.000000
32 -> -15116315767.092157
33 -> 0.000000
34 -> 429614643061.166667
35 -> 0.000000
36 -> -13711655205088.332772
37 -> 0.000000
38 -> 488332318973593.166667
39 -> -0.000000
40 -> -19296579341940068.148633
41 -> -0.000000
42 -> 841693047573682615.000554
43 -> -0.000000
44 -> -40338071854059455413.076812
45 -> -0.000000
46 -> 2115074863808199160560.145390
47 -> -0.000000
48 -> -120866265222965259346027.311937
49 -> -0.000000
50 -> 7500866746076964366855720.075758
51 -> -0.000000
52 -> -503877810148106891413789303.052201
53 -> -0.000000
54 -> 36528776484818123335110430842.971178
55 -> -0.000000
56 -> -2849876930245088222626914643291.067816
57 -> -0.000000
58 -> 238654274996836276446459819192192.149718
59 -> -0.000000
60 -> -21399949257225333665810744765191097.392674
</pre>
</div>
<div id="pu18" class="pu"><h1>Perl, 101 bytes</h1>



<pre class="lang-perl prettyprint-override"><code>#!perl -p
@a=($_%4-1,$_&lt;2)x$_;
@a=map$_*($a[$_-1]+$a[$_+1])/2,0..@a-3for 2..$_;
$_=!$_||$_/(4**$_-2**$_)*$a[1]
</code></pre>

<p>Counting the shebang as three, input is taken from stdin.</p>

<p>Using the same formula as my <a href="https://codegolf.stackexchange.com/a/65410/4098">Python answer</a>.</p>

<hr>

<p><strong>Sample Usage</strong></p>

<pre class="lang-perl prettyprint-override"><code>$ echo 60 | perl bernoulli.pl
-2.13999492572253e+034
</code></pre>

<p><a href="http://codepad.org/ht3M6XJw" rel="nofollow noreferrer">Online Demo</a>.</p>
</div>
<div id="pu19" class="pu"><h1>GolfScript, 63 bytes</h1>



<pre class="lang-default prettyprint-override"><code>~:i.!+.[3i&amp;(2i&gt;]*i(,{i\-,{1$1$(=2$2$)=+*2/}%\;}/~\2i?.(*\--1?**
</code></pre>

<p><a href="http://golfscript.apphb.com/?c=IjYwIgp%2BOmkuISsuWzNpJigyaT5dKmkoLHtpXC0sezEkMSQoPTIkMiQpPSsqMi99JVw7fS9%2BXDJpPy4oKlwtLTE%2FKio%3D" rel="nofollow noreferrer">Online Demo</a>.</p>

<p>Using the same formula as my <a href="https://codegolf.stackexchange.com/a/65410/4098">Python answer</a>.</p>

<hr>

<p><strong>Test Script</strong></p>

<pre class="lang-default prettyprint-override"><code>61,{[.`
  ~:i.!+.[3i&amp;(2i&gt;]*i(,{i\-,{1$1$(=2$2$)=+*2/}%\;}/~\2i?.(*\--1?**
]p}/
</code></pre>

<p>The apphb link will time out on this. If you don't have GolfScript installed locally, I recommend using the <a href="http://golf.shinh.org/check.rb" rel="nofollow noreferrer">anarchy golf interpreter</a> (use form, select GolfScript, paste, submit).</p>
</div>
<div id="pu20" class="pu"><h1>Julia, <s>23</s> 20 bytes</h1>



<p>Saved 3 bytes thanks to Alex A.</p>

<p>It uses the same formula as <a href="https://codegolf.stackexchange.com/a/65408/9288">my Mathematica solution</a> and <a href="https://codegolf.stackexchange.com/a/65412/9288">PARI/GP solution</a>. </p>

<pre class="lang-julia prettyprint-override"><code>n-&gt;n&gt;0?-zeta(1-n)n:1
</code></pre>
</div>
<div id="pu21" class="pu"><h1>Python 2, <s>132</s> 130 bytes</h1>

<pre><code>import math,fractions
f=math.factorial
B=lambda m:~-m*m%2or 1+sum(B(k)*f(m)/f(k)/f(m-k)/fractions.Fraction(k+~m)for k in range(m))
</code></pre>

<p>This is just a golfed version of the reference implementation.</p>

<p>This is a little slow in practice, but can be sped up significantly with memoization:</p>

<pre><code>import math,fractions
f=math.factorial

def memoize(f):
 memo = {}
 def helper(x):
  if x not in memo:
   memo[x] = f(x)
  return memo[x]
 return helper

@memoize
def B(m):
 return~-m*m%2or 1+sum(B(k)*f(m)/f(k)/f(m-k)/fractions.Fraction(k+~m)for k in range(m))

for m in range(61):
 print(B(m))
</code></pre>

<p>You can try this version online on <a href="http://ideone.com/oc6yHW" rel="nofollow">Ideone</a>.</p>
</div>
<div id="pu22" class="pu"><h1>PARI/GP, <s>52</s> 23 bytes</h1>

<p>Using the famous formula <em>n</em>*<em>ζ</em>(1−<em>n</em>)=−<em>B</em><sub><em>n</em></sub>, where <em>ζ</em> is the <a href="https://en.wikipedia.org/wiki/Riemann_zeta_function" rel="nofollow">Riemann Zeta function</a>.</p>

<pre><code>n-&gt;if(n,-n*zeta(1-n),1)
</code></pre>

<hr>

<p>Original solution, 52 bytes, using <a href="https://en.wikipedia.org/wiki/Bernoulli_number#Generating_function" rel="nofollow">the generating function of Bernoulli numbers</a>. </p>

<pre><code>n-&gt;n!*polcoeff(-x/sum(i=1,n+1,(-x)^i/i!)+O(x^n*x),n)
</code></pre>
</div>
<div id="pu23" class="pu"><h1>Mathematica, <s>40</s> <s>28</s> <s>23</s> 22 bytes</h1>

<p>Using the famous formula <em>n</em>*<em>ζ</em>(1−<em>n</em>)=−<em>B</em><sub><em>n</em></sub>, where <em>ζ</em> is the <a href="https://en.wikipedia.org/wiki/Riemann_zeta_function">Riemann Zeta function</a>.</p>

<pre><code>If[#&gt;0,-Zeta[1-#]#,1]&amp;
</code></pre>

<p>The same length:</p>

<pre><code>B@0=1;B@n_=-Zeta[1-n]n
</code></pre>

<hr>

<p>Original solution, 40 bytes, using <a href="https://en.wikipedia.org/wiki/Bernoulli_number#Generating_function">the generating function of Bernoulli numbers</a>. </p>

<pre><code>#!SeriesCoefficient[t/(1-E^-t),{t,0,#}]&amp;
</code></pre>
</div>
<div id="pu24" class="pu"><h2>Mathematica, <s>52</s> <s>48</s> 42 bytes</h2>

<pre><code>1-Sum[#~Binomial~k#0@k/(#-k+1),{k,0,#-1}]&amp;
</code></pre>

<p>Unnamed function that uses the literal definition.</p>
</div>
<div id="pu25" class="pu"><h1>PARI/GP, 45 bytes</h1>



<pre class="lang-default prettyprint-override"><code>n-&gt;if(n,2*n/(2^n-4^n)*real(polylog(1-n,I)),1)
</code></pre>

<p>Using the same formula as my <a href="https://codegolf.stackexchange.com/a/65410/4098">Python answer</a>, with <em>A<sub>n</sub></em> generated via polylog.</p>

<hr>

<p><strong>Test Script</strong></p>

<p>Run <code>gp</code>, at the prompt paste the following:</p>

<pre class="lang-default prettyprint-override"><code>n-&gt;if(n,2*n/(2^n-4^n)*real(polylog(1-n,I)),1)
for(i=0, 60, print(i, ": ", %(i)))
</code></pre>
</div>
<div id="pu26" class="pu"><h2><a href="http://github.com/elendiastarman/Minkolang" rel="nofollow noreferrer">Minkolang 0.14</a>, 97 bytes</h2>
<p>I actually tried doing it recursively first, but my interpreter, as currently designed, actually can't do it. If you try to recurse from within a for loop, it starts a new recursion. So I went for the tabulating approach...which had precision problems. So I did the whole thing with fractions. With no built-in support for fractions. [<em>sigh</em>]</p>
<pre><code>n1+[xxi$z0z2%1+F0c0=$1&amp;$d4Mdm:1R:r$dz1Az0A]$:N.
11z[i0azi6M*i1azi-1+*d0c*1c2c*-1c3c*4$X]f
z1=d1+f
</code></pre>
<p><a href="http://play.starmaninnovations.com/minkolang/?code=n1%2B%5Bxxi%24z0z2%251%2BF0c0%3D%241%26%24d4Mdm%3A1R%3Ar%24dz1Az0A%5D%24%3AN%2E%0A11z%5Bi0azi6M*i1azi-1%2B*d0c*1c2c*-1c3c*4%24X%5Df%0Az1%3Dd1%2Bf&amp;input=60" rel="nofollow noreferrer">Try it here.</a> Bonus: the array has all fractions for every previous Bernoulli number!</p>
<h3>Explanation (in a bit)</h3>
<pre><code>n1+                 Take number from input (N) and add 1
   [                Open for loop that runs N+1 times (starts at zero)
    xx              Dump the top two values of the stack
      i$z           Store the loop counter in the register (m)
         0          Push 0
          z2%1+     Push 1 if N is even, 2 if odd
               F    Gosub; pops y,x then goes to codebox(x,y), to be returned to

    0c                                 Copy the first item on the stack
      ,                                1 if equal to 0, 0 otherwise
       $1&amp;                             Jump 11 spaces if top of stack is not 0

                                       (If top of stack is not 0, then...)
          $d                           Duplicate whole stack
            4M                         Pop b,a and push GCD(a,b)
              dm                       Duplicate and merge (a,b,c,c -&gt; a,c,b,c)
                :                      Divide
                 1R                    Rotate 1 item to the right (0G works too)
                   :                   Divide
                    r                  Reverse stack

                                       (In both cases...)
                     $d                Duplicate whole stack
                       z1A             Store denominator of B_m in array
                           z0A         Store numerator of B_m in array
                              ]        Close for loop
                               $:      Divide (float division)
                                 N.    Output as number and stop.

11                                           Push two 1s (a, b)
  z[                                         Open a for loop that repeats m times
    i0a                                      Retrieve numerator of B_k (p)
       zi                                    Push m, k
         6M                                  Pop k,m and push mCk (binomial) (x)
           *                                 p*x (c)
            i1a                              Retrieve denominator of B_k (q)
               zi-1+                         m-k+1 (y)
                    *                        q*y (d)
                     d                       Duplicate top of stack
                      0c*                    a*d
                         1c2c*               b*c
                              -              a*d-b*c
                               1c3c*         b*d
                                    4$X      Dump the bottom four items of stack
                                       ]f    Jump back to F

z          m
 1=        0 (if m is 1) or 1 (otherwise)
   d1+     Duplicate and add 1 (1 or 2)
      f    Jump back to F
</code></pre>
<p>The third line is responsible for <code>1/2</code> if <code>m</code> is 1 and <code>0/1</code> if <code>m</code> is an odd number greater than 1. The second line calculates <code>B_m</code> with the summation formula given in the question, and does so entirely with numerators and denominators. Otherwise it'd be a lot shorter. The first half of the first line does some bookkeeping and chooses whether to execute the second or third line, and the second half divides the numerator and denominator by their GCD (if applicable) and stores those values. And outputs the answer at the end.</p>
</div>
<div id="pu27" class="pu"><h1>Julia, 58 bytes</h1>



<pre class="lang-julia prettyprint-override"><code>B(m)=m&lt;1?1:1-sum(k-&gt;big(binomial(m,k))*B(k)/(m-k+1),0:m-1)
</code></pre>

<p>This creates a recursive function <code>B</code> that accepts an integer and returns a <code>BigFloat</code> (i.e. high precision floating point).</p>

<p>Ungolfed:</p>

<pre class="lang-julia prettyprint-override"><code>function B(m::Integer)
    m == 0 &amp;&amp; return 1
    return 1 - sum(k -&gt; big(binomial(m, k)) * B(k) / (m-k+1), 0:m-1)
end
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/65382/">65382</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




