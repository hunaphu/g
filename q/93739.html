<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::93739</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>131</td><td>Java</td><td>160927T095422Z</td><td><a href="https://codegolf.stackexchange.com/questions/93739/compute-the-carmichael-function/94689#94689">ceilingc</a></td></tr>
<tr d-ix="1"><td>120</td><td>C</td><td>160922T055954Z</td><td><a href="https://codegolf.stackexchange.com/questions/93739/compute-the-carmichael-function/94142#94142">ceilingc</a></td></tr>
<tr d-ix="2"><td>129</td><td>C++</td><td>160923T080101Z</td><td><a href="https://codegolf.stackexchange.com/questions/93739/compute-the-carmichael-function/94272#94272">ceilingc</a></td></tr>
<tr d-ix="3"><td>028</td><td>APLNARS</td><td>250324T081231Z</td><td><a href="https://codegolf.stackexchange.com/questions/93739/compute-the-carmichael-function/278874#278874">Rosario</a></td></tr>
<tr d-ix="4"><td>297</td><td>SAKO</td><td>250323T174643Z</td><td><a href="https://codegolf.stackexchange.com/questions/93739/compute-the-carmichael-function/278867#278867">Acrimori</a></td></tr>
<tr d-ix="5"><td>246</td><td>Templates Considered Harmful</td><td>160918T220256Z</td><td><a href="https://codegolf.stackexchange.com/questions/93739/compute-the-carmichael-function/93762#93762">feersum</a></td></tr>
<tr d-ix="6"><td>067</td><td>Python</td><td>160919T022639Z</td><td><a href="https://codegolf.stackexchange.com/questions/93739/compute-the-carmichael-function/93772#93772">Dennis</a></td></tr>
<tr d-ix="7"><td>129</td><td>Axiom</td><td>161121T110144Z</td><td><a href="https://codegolf.stackexchange.com/questions/93739/compute-the-carmichael-function/100605#100605">user5898</a></td></tr>
<tr d-ix="8"><td>026</td><td>Actually</td><td>160919T071940Z</td><td><a href="https://codegolf.stackexchange.com/questions/93739/compute-the-carmichael-function/93779#93779">Sherlock</a></td></tr>
<tr d-ix="9"><td>218</td><td>Racket</td><td>160929T035914Z</td><td><a href="https://codegolf.stackexchange.com/questions/93739/compute-the-carmichael-function/94812#94812">rnso</a></td></tr>
<tr d-ix="10"><td>090</td><td>Ruby</td><td>160920T015349Z</td><td><a href="https://codegolf.stackexchange.com/questions/93739/compute-the-carmichael-function/93850#93850">Sherlock</a></td></tr>
<tr d-ix="11"><td>135</td><td>JavaScript ES6</td><td>160918T213721Z</td><td><a href="https://codegolf.stackexchange.com/questions/93739/compute-the-carmichael-function/93760#93760">Arnauld</a></td></tr>
<tr d-ix="12"><td>260</td><td>Java8</td><td>160919T225147Z</td><td><a href="https://codegolf.stackexchange.com/questions/93739/compute-the-carmichael-function/93833#93833">Master_e</a></td></tr>
<tr d-ix="13"><td>nan</td><td>Java</td><td>160920T223359Z</td><td><a href="https://codegolf.stackexchange.com/questions/93739/compute-the-carmichael-function/93966#93966">Olivier </a></td></tr>
<tr d-ix="14"><td>057</td><td>Mathematica without builtin</td><td>160918T194236Z</td><td><a href="https://codegolf.stackexchange.com/questions/93739/compute-the-carmichael-function/93750#93750">Greg Mar</a></td></tr>
<tr d-ix="15"><td>027</td><td>J</td><td>160918T194310Z</td><td><a href="https://codegolf.stackexchange.com/questions/93739/compute-the-carmichael-function/93751#93751">miles</a></td></tr>
<tr d-ix="16"><td>5956</td><td>Ruby</td><td>160918T190043Z</td><td><a href="https://codegolf.stackexchange.com/questions/93739/compute-the-carmichael-function/93745#93745">m-chrzan</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Java, <s>165 163 158 152 143</s> 131 bytes</h1>
<pre><code>n-&gt;{int k=1,x,a,b,t,d=1;for(;d&gt;0;)for(d=x=0;++x&lt;n;d=a&lt;2&amp;t&gt;1?k++:d){for(a=x,b=n;b&gt;0;b=a%b,a=t)t=b;for(t=1;b++&lt;k;t=t*x%n);}return k;}
</code></pre>
<p>Another port of my <a href="https://codegolf.stackexchange.com/a/94142/52904">C implementation</a>.</p>
<p><a href="https://tio.run/##fVBNb4MwDL33V1iTOpElRbDjQthpx/XS47RDQmiXAgEFt2Oq@O3MsPVSTXMk27He88c76rPeHG01FbXue3jVzl9WAM5jGfa6KGE7f5cC1NHsPZNUGVfketToCthCAwomv8kvM6BSqRiEFkagsCqV@zZE0uaJZHNm1aASyfmQeWmVzh7vMU@fK86fLLvMAK0GYZSXhhhG6bURWiFDZZZGSA0N51klUeHDsKZtxlDiKXio5DhJuFp3MjXt9rviuXUWGjoOoh0G5w9v76DDoWeAH6H97OFIOsS19of4ZSjKDl3r4efyq83TFxkcHZtKChmkSUIJ58BuwAC7rx7LJm5PGHc0EIkLi3L/gWofwR09Dk1MarNbxrj6Kx@nbw" rel="nofollow noreferrer" title="Java (JDK) – Try It Online">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1>C, <s>278 276 272 265 256 243 140 134 125</s> 120 bytes</h1>
<pre class="lang-cpp prettyprint-override"><code>k,x,a,b,t,d;l(n){for(k=d=1;d;)for(d=x=0;a=++x%n;d=t&gt;1&gt;=a?k++:d){for(b=n;t=b;a=t)b=a%b;for(t=1;b++&lt;k;t=t*x%n);}return k;}
</code></pre>
<p>This uses a slow modular exponentiation algorithm, computes the GCD too often and no longer leaks memory!</p>
<p>Ungolfed:</p>
<pre><code>int gcd( int a, int b ) {
  int t;
  while( b ) {
    t = b;
    b = a%b;
    a = t;
  }
  return a;
}
int pw(int a,int b,int c){
  int t=1;
  for( int e=0; e&lt;b; e++ ) {
    t=(t*a)%c;
  }
  return t;
}
int carmichael(int n) {
  int k = 1;
  for( ;; ) {
    int done = 1;
    for( int x=1; x&lt;n; x++ ) {
      if( gcd(x,n)==1 &amp;&amp; pw(x,k,n) != 1 ) {
        done = 0;
        k++;
      }
    }
    if( done ) break;
  }
  return k;
}
</code></pre>
<p><a href="https://tio.run/##JczBCoMwDAbgu0/xIxTatQO9Lsa9yC6tnaPUdUM6EMRndxVPSf58yXB9DcO@R7MYa5zJxtMkk1rHzywje27JkzoGzws3ZFnrRSTynPu2Z3uPWt/8yR0nyuyKycqxFY6ONJcXTusull2@lFtF2/zMvzkh0ra/bUhSYa2AQyOkjABGS6V0aJumNFrjJMB3LmKUqIWH8I9UGwSDSQYFRUVs1bb/AQ" rel="nofollow noreferrer" title="C (gcc) – Try It Online">Try it online!</a></p>
</div>
<div id="pu2" class="pu"><h1>C++, <s>208 200 149 144 140 134</s> 129 bytes</h1>
<pre><code>[](int n){int k=1,x,a,b,t,d=1;for(;d;)for(d=x=0;a=++x%n;d=t&gt;1&gt;=a?k++:d){for(b=n;t=b;a=t)b=a%b;for(t=1;b++&lt;k;t=t*x%n);}return k;};
</code></pre>
<p>A port of my <a href="https://codegolf.stackexchange.com/a/94142/52904">C implementation</a>.</p>
<p><a href="https://tio.run/##JY7NasMwEITvfoqFEGxVKlhXr9Z9kLYH/ThB2JGDswaD8bO7UnOagflmd/zz@Xn3/rzE5Kc1DCbOL14G@@irmBgeNqZGwF4B2JVnmIDO79@mREnsRUbSalNWOcUqkMbbvDQYUBQNtFGLlqTcrgkDca97sl@jlF0QeyEcJWRymWHhyF7df5/zHSelGXPGH7kr8FgGXpcEIx54AhQKyvsIBBqzGNBtm42U8N4L8OLQdX5e2ZhoTA21MVMTRbY/qcaMHNVx/gE" rel="nofollow noreferrer" title="C++ (gcc) – Try It Online">Try it online!</a></p>
</div>
<div id="pu3" class="pu"><h1>APL(NARS), 28 chars</h1>
<pre><code>∧/{(13π⍵)÷1+0=8∣⍵}¨×/¨⊂⍨1,π⎕
</code></pre>
<p><code>13π</code> is here the builtin totient function, <code>π</code> find factors of input.  It would
use the totient function for build lambda as other answers. It add 1 as a factor
of input number, it would than apply <code>{(13π⍵)÷1+0=8∣⍵}</code> in the prime factors
pow to their multiplicity, of number of input. It seems ⊂⍨ enclose 1 too, so ok.</p>
<p>Test:</p>
<pre><code>  ∧/{(13π⍵)÷1+0=8∣⍵}¨×/¨⊂⍨1,π⎕
⎕:
  10000
500
  ∧/{(13π⍵)÷1+0=8∣⍵}¨×/¨⊂⍨1,π⎕
⎕:
  6511
3056
</code></pre>
<p>slower of above this below, traslate of one other answer</p>
<h1>APL(NARS), 160 chars</h1>
<pre><code>r←l w;b;e;n
(b e n)←w⋄r←1
→3×⍳0=2∣e⋄r←n∣r×b
b←n∣b×b⋄→2×⍳0&lt;e←⌊e÷2

r←c w;t;a;i;v;s
s←≢t←t/⍨1=w∨t←⍳w⋄v←r←i←1
→3×⍳i&gt;s⋄v←l t[i],r,w⋄i+←1⋄→2×⍳v=1
→0×⍳v≤1⋄r+←1⋄i←1⋄→2
</code></pre>
<p>//12+14+18+21+16+25+34+20
where l is ltor, and c is the function of the question</p>
<pre><code>  c¨1 2 3 10 35 101 530 6511 10000
1 1 2 4 12 100 52 3056 500 
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://en.wikipedia.org/wiki/SAKO_(programming_language)" rel="nofollow noreferrer">SAKO</a>, 297 bytes</h1>
<pre><code>PODPROGRAM:F(N)
CALKOWITE:N,I,J,*T,K
BLOK(9):T
GDYN&gt;2:0,INACZEJ4
4)K=1
SKOCZDO9
0)J=0
*)T(J)=I
J=J+0*(G(N,I)-1)
POWTORZ:I=2(1)N-1
K=1
*1)GDYMOD(T(I)*K,N)=1:2,INACZEJ3
2)POWTORZ:I=0(1)J-1
9)F()=K
WROC
3)K=K+1
SKOCZDO1
PODPROGRAM:G(A,B)
CALKOWITE:A,B
GDYB&gt;0:1,INACZEJ2
1)A=G(B,MOD(A,B))
2)G()=A
WROC
</code></pre>
<p>Due to a lack of terrifyingly long answers, I decided to post mine.</p>
<p>Explanation:</p>
<ol>
<li>We take an integer value as an argument <code>N</code>.</li>
<li>We get all coprimes of <code>N</code> and put it in the list <code>T</code>.</li>
<li>We check for every <code>T(I)</code> if <code>MOD(T(I)*K, N) = 1</code> and if yes we print <code>K</code>. Else we increase K by one.</li>
</ol>
<p>There is probably a shorter way to do this; however, I do not know it.</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/feresum/tmp-lang" rel="noreferrer">Templates Considered Harmful</a>, 246 bytes</h1>
<pre><code>Fun&lt;Ap&lt;Fun&lt;If&lt;Eq&lt;A&lt;2&gt;,T&gt;,A&lt;1&gt;,And&lt;Eq&lt;Ap&lt;Fun&lt;If&lt;A&lt;1&gt;,Ap&lt;A&lt;0&gt;,Rem&lt;A&lt;2&gt;,A&lt;1&gt;&gt;,A&lt;1&gt;&gt;,A&lt;2&gt;&gt;&gt;,A&lt;1,1&gt;,A&lt;2&gt;&gt;,T&gt;,Sub&lt;Ap&lt;Fun&lt;Rem&lt;If&lt;A&lt;1&gt;,Mul&lt;A&lt;2,1&gt;,Ap&lt;A&lt;0&gt;,Sub&lt;A&lt;1&gt;,T&gt;&gt;&gt;,T&gt;,A&lt;1,2&gt;&gt;&gt;,A&lt;1&gt;&gt;,T&gt;&gt;,Ap&lt;A&lt;0&gt;,Add&lt;A&lt;1&gt;,T&gt;,A&lt;1,1&gt;&gt;,Ap&lt;A&lt;0&gt;,A&lt;1&gt;,Sub&lt;A&lt;2&gt;,T&gt;&gt;&gt;&gt;,T,A&lt;1&gt;&gt;&gt;
</code></pre>
<p>An unnamed function (not that there are named functions).</p>
<p>This is a forgotten esolang of mine which is interpreted by a C++ compiler instantiating templates. With the default max template depth of <code>g++</code>, it can do λ(35), but it can't do λ(101) (the lazy evaluation makes things worse).</p>
</div>
<div id="pu6" class="pu"><h1>Python, <s>76</s> <s>73</s> 67 bytes</h1>

<pre class="lang-python prettyprint-override"><code>f=lambda n,k=1:1-any(a**-~k*~-a**k%n for a in range(n))or-~f(n,k+1)
</code></pre>
<p><a href="https://tio.run/nexus/python2#FY7BDoMgEETP5Sv2QgQLjdTSg4n9F1q1IepigB68@OuW3WQzuy@ZyZxTv7j1PThANfemM9rhLlxd62OuD12OmSNMIYIDjxAdfkeBUoaoj0kUz9XI069biBnSnljZWxpzHD@/mHzAxa8@C9OUkQwYBSEFCaPgrqBVYJoilrQg29LXEHtaY4iSs2OXLXrMouJ2AP0C/hgq4FAKwER15PkH" rel="noreferrer">Try it online!</a></p>
<p>A further byte could be saved by returning <em>True</em> instead of <strong>1</strong>.</p>
<h3>Alternative implementation</h3>
<p>Using the same approach, there is also the following implementation by @feersum which doesn't use list comprehensions.</p>
<pre class="lang-python prettyprint-override"><code>f=lambda n,k=1,a=1:a/n or(a**-~k*~-a**k%n&lt;1)*f(n,k,a+1)or-~f(n,k+1)
</code></pre>
<p>Note that this implementation requires <strong>O(n<sup>λ(n)</sup>)</strong> time. Efficiency could be improved dramatically while actually <em>decreasing</em> score to <strong>66 bytes</strong>, but the function would return <em>True</em> for input <strong>2</strong>.</p>
<pre class="lang-python prettyprint-override"><code>f=lambda n,k=1,a=1:a/n or~-a**k*a**-~k%n&lt;1==f(n,k,a+1)or-~f(n,k+1)
</code></pre>
<h2>Background</h2>
<h3>Definitions and notation</h3>
<p>All employed variables will denote integers; <strong>n</strong>, <strong>k</strong>, and <strong>α</strong> will denote <em>positive</em> integers; and <strong>p</strong> will denote a positive <em>prime</em>.</p>
<p><strong>a | b</strong> if <strong>b</strong> is divisible by <strong>a</strong>, i.e., if there is <strong>q</strong> such that <strong>b = qa</strong>.</p>
<p><strong>a ≡ b (<em>mod</em> m)</strong> if <strong>a</strong> and <strong>b</strong> have the same residue modulo <strong>m</strong>, i.e., if <strong>m | a - b</strong>.</p>
<p><strong>λ(n)</strong> is the smallest <strong>k</strong> such that <strong>a<sup>k</sup> ≡ 1 (<em>mod</em> n)</strong> – i.e., such that <strong>n | a<sup>k</sup> - 1</strong> – for all <strong>a</strong> that are coprime to <strong>n</strong>.</p>
<p><strong>f(n)</strong> is the smallest <strong>k</strong> such that <strong>a<sup>2k+1</sup> ≡ a<sup>k+1</sup> (<em>mod</em> n)</strong> – i.e., such that <strong>n | a<sup>k+1</sup>(a<sup>k</sup> - 1)</strong> – for all <strong>a</strong>.</p>
<h3>λ(n) ≤ f(n)</h3>
<p>Fix <strong>n</strong> and let <strong>a</strong> be coprime to <strong>n</strong>.</p>
<p>By the definition of <strong>f</strong>, <strong>n | a<sup>f(n)+1</sup>(a<sup>f(n)</sup> - 1)</strong>. Since <strong>a</strong> and <strong>n</strong> do not have a common prime factor, neither do <strong>a<sup>f(n)+1</sup></strong> and <strong>n</strong>, which implies that <strong>n | a<sup>f(n)</sup> - 1</strong>.</p>
<p>Since <strong>λ(n)</strong> is the smallest integer <strong>k</strong> such that <strong>n | a<sup>k</sup> - 1</strong> for all integers <strong>a</strong> that are coprime to <strong>n</strong>, it follows that <strong>λ(n) ≤ f(n)</strong>.</p>
<h3>λ(n) = f(n)</h3>
<p>Since we've already established the inequality <strong>λ(n) ≤ f(n)</strong>, it is sufficient to verify that <strong>k = λ(n)</strong> satisfies the condition that defines <strong>f</strong>, i.e., that <strong>n | a<sup>λ(n)+1</sup>(a<sup>λ(n)</sup> - 1)</strong> for all <strong>a</strong>. For this purpose, we'll establish that <strong>p<sup>α</sup> | a<sup>λ(n)+1</sup>(a<sup>λ(n)</sup> - 1)</strong> whenever <strong>p<sup>α</sup> | n</strong>.</p>
<p><strong>λ(k) | λ(n)</strong> whenever <strong>k | n</strong> (<a href="https://en.wikipedia.org/wiki/Carmichael_function#Divisibility" rel="noreferrer" title="Carmichael function - Wikipedia, the free encyclopedia">source</a>), so <strong>(a<sup>λ(k)</sup> - 1)(a<sup>λ(n)-λ(k)</sup> + a<sup>λ(n)-2λ(k)</sup> + ⋯ + a<sup>λ(k)</sup> + 1) = a<sup>λ(n)</sup> - 1</strong> and, therefore, <strong>a<sup>λ(k)</sup> - 1 | a<sup>λ(n)</sup> - 1 | a<sup>λ(n)+1</sup>(a<sup>λ(n)</sup> - 1)</strong>.</p>
<p>If <strong>a</strong> and <strong>p<sup>α</sup></strong> are coprime, by the definition of <strong>λ</strong> and the above, <strong>p<sup>α</sup> | a<sup>λ(p<sup>α</sup>)</sup> - 1 | a<sup>λ(n)+1</sup>(a<sup>λ(n)</sup> - 1)</strong> follows, as desired.</p>
<p>If <strong>a = 0</strong>, then <strong>a<sup>λ(n)+1</sup>(a<sup>λ(n)</sup> - 1) = 0</strong>, which is divisible by all integers.</p>
<p>Finally, we must consider the case where <strong>a</strong> and <strong>p<sup>α</sup></strong> have a common prime factor. Since <strong>p</strong> is prime, this implies that <strong>p | a</strong>. <a href="https://en.wikipedia.org/wiki/Carmichael_function#Carmichael.27s_theorem" rel="noreferrer" title="Carmichael function - Wikipedia, the free encyclopedia">Carmichael's theorem</a> establishes that <strong>λ(p<sup>α</sup>) = (p - 1)p<sup>α - 1</sup></strong> if <strong>p &gt; 2</strong> or <strong>α &lt; 3</strong> and that <strong>λ(p<sup>α</sup>) = p<sup>α - 2</sup></strong> otherwise. In all cases, <strong>λ(p<sup>α</sup>) ≥ p<sup>α - 2</sup> ≥ 2<sup>α - 2</sup> &gt; α - 2</strong>.</p>
<p>Therefore, <strong>λ(n) + 1 ≥ λ(p<sup>α</sup>) + 1 &gt; α - 1</strong>, so <strong>λ(n) + 1 ≥ α</strong> and <strong>p<sup>α</sup> | p<sup>λ(n)+1</sup> | a<sup>λ(n)+1</sup> | a<sup>λ(n)+1</sup>(a<sup>λ(n)</sup> - 1)</strong>. This completes the proof.</p>
<h2>How it works</h2>
<p>While the definitions of <strong>f(n)</strong> and <strong>λ(n)</strong> consider all possible values of <strong>a</strong>, it is sufficient to test those that lie in <strong>[0, ..., n - 1]</strong>.</p>
<p>When <strong>f(n, k)</strong> is called, it computes <strong>a<sup>k+1</sup>(a<sup>k</sup> - 1) % n</strong> for all values of <strong>a</strong> in that range, which is <strong>0</strong> if and only if <strong>n | a<sup>k+1</sup>(a<sup>k</sup> - 1)</strong>.</p>
<p>If all computed residues are zero, <strong>k = λ(n)</strong> and <code>any</code> returns <em>False</em>, so <strong>f(n, k)</strong> returns <strong>1</strong>.</p>
<p>On the other hand, while <strong>k &lt; λ(n)</strong>, <code>1-any(...)</code> will return <strong>0</strong>, so <strong>f</strong> is called recursively with an incremented value of <strong>k</strong>. The leading <code>-~</code> increments the return value of <strong>f(n, k + 1)</strong>, so we add <strong>1</strong> to <strong>f(n, λ(n)) = 1</strong> once for every integer in <strong>[1, ..., λ(n) - 1]</strong>. The final result is thus <strong>λ(n)</strong>.</p>
</div>
<div id="pu7" class="pu"><p><strong>Axiom 129 bytes</strong></p>

<pre><code>c(n)==(r:=[x for x in 1..n|gcd(x,n)=1];(v,k):=(1,1);repeat(for a in r repeat(v:=powmod(a,k,n);v~=1=&gt;break);v&lt;=1=&gt;break;k:=k+1);k)
</code></pre>

<p>less golfed</p>

<pre><code>cml(n)==
 r:=[x for x in 1..n|gcd(x,n)=1];(v,k):=(1,1)
 repeat 
   for a in r repeat(v:=powmod(a,k,n);v~=1=&gt;break)
   v&lt;=1=&gt;break
   k:=k+1
 k
</code></pre>

<p>results</p>

<pre><code>(3) -&gt; [i,c(i)] for i in [1,2,3,10,35,101,530,3010,6511,10000]
   Compiling function c with type PositiveInteger -&gt; PositiveInteger

   (3)
   [[1,1], [2,1], [3,2], [10,4], [35,12], [101,100], [530,52], [3010,84],
    [6511,3056], [10000,500]]
                                             Type: Tuple List PositiveInteger
</code></pre>
</div>
<div id="pu8" class="pu"><h1>Actually, <s>30</s> <s>28</s> <s>25</s> <s>19</s> 26 bytes</h1>

<p>The Carmichael function, <code>λ(n)</code> where <code>n = p_0**k_0 * p_1**k_1 * ... * p_a**k_a</code>, is defined as the least common multiple (LCM) of <code>λ(p_i**k_i)</code> for the maximal prime powers <code>p_i**k_i</code> that divide into <code>n</code>. Given that for every prime power except where the prime is <code>2</code>, the Carmichael function is equivalent to the Euler totient function, <code>λ(n) == φ(n)</code>, we use <code>φ(n)</code> instead. For the special case of <code>2**k</code> where <code>k ≥ 3</code>, we just check if <code>2**3 = 8</code> divides into <code>n</code> at the beginning of the program, and divide by 2 if it does.</p>

<p>Unfortunately, Actually doesn't currently have an LCM builtin, so I made a brute-force LCM. Golfing suggestions welcome. <a href="http://actually.tryitonline.net/#code=OzcmWXVAXHdgaeKBv-KWkmBN4pWXMmDilZxA4pmAJc6jWWDilZNO&amp;input=NDAzMjA" rel="nofollow noreferrer">Try it online!</a></p>

<pre><code>;7&amp;Yu@\w`iⁿ▒`M╗2`╜@♀%ΣY`╓N
</code></pre>

<p><strong>Ungolfing</strong></p>

<pre><code>         Implicit input n.
;        Duplicate n.
7&amp;       n&amp;7 == n%8.
Yu       Logical NOT and increment. If n%8 == 0, return 2. Else, return 1.
@\       Integer divide n by 2 if n%8==0, by 1 otherwise.
          Thus, we have dealt with the special case where p_i == 2 and e_i &gt;= 3.
w        Full prime factorization of n as a list of [prime, exponent] lists.
`...`M   Map the following function over the prime factorization.
  i        Flatten the array, pushing exponent, then prime to the stack.
  ⁿ▒       totient(pow(prime, exponent)).
╗        Save that list of totients in register 0.
2`...`╓  Get the first two values of n where the following function f(n) is truthy.
         Those two numbers will be 0 and our LCM.
  ╜@       Push the list in register 0 and swap with our n.
  ♀%       Get n mod (every number in the list)
  Σ        Sum the modulos. This sum will be 0, if and only if this number is 0 or LCM.
  Y        Logical NOT, so that we only get a truthy if the sum of modulos is 0.
N        Grab the second number, our LCM. Implicit return.
</code></pre>
</div>
<div id="pu9" class="pu"><h2>Racket 218 bytes</h2>

<pre><code>(λ(n)(let((fl #f)(cl(for/list((i n) #:when(coprime? n i))i)))(for/sum((k(range 1 n))#:break fl)(set! fl #t)
(for((i(length cl))#:break(not fl))(when(not(= 1(modulo(expt(list-ref cl i)k)n)))(set! fl #f)))(if fl k 0))))
</code></pre>

<p>Ungolfed version: </p>

<pre><code>(require math)
(define f
  (λ(n)
    (let ((fl #f)
          (cl (for/list ((i n) #:when (coprime? n i))
                i)))
             (for/sum ((k (range 1 n)) #:break fl)
               (set! fl #t)
               (for ((i (length cl)) #:break (not fl))
                 (when (not (= 1 (modulo (expt (list-ref cl i) k) n)))
                   (set! fl #f)))
               (if fl k 0)))))
</code></pre>

<p>Testing:     </p>

<pre><code>(f 2) 
(f 3)
(f 10)
(f 35)
(f 101)
(f 530)
(f 3010)
(f 6511)
(f 10000)
</code></pre>

<p>Output: </p>

<pre><code>1
2
4
12
100
52
84
3056
500
</code></pre>
</div>
<div id="pu10" class="pu"><h1>Ruby, <s>101</s> <s>86</s> <s>91</s> 90 bytes</h1>



<p>A Ruby port of <a href="https://codegolf.stackexchange.com/a/93779/47581">my Actually answer</a>. Golfing suggestions welcome.</p>

<p><strong>Edit:</strong> -4 bytes from removing <code>a</code> but +9 bytes from fixing a bug where <code>1</code> returned <code>nil</code>. -1 byte thanks to Cyoce.</p>

<pre class="lang-ruby prettyprint-override"><code>require'prime'
-&gt;n{((n%8&lt;1?n/2:n).prime_division&lt;&lt;[2,1]).map{|x,y|x**~-y*~-x}.reduce :lcm}
</code></pre>

<p><strong>Ungolfing</strong></p>

<pre class="lang-ruby prettyprint-override"><code>require 'prime'
def carmichael(n)
  if n%8 &lt; 1
    n /= 2
  end
  a = []
  n.prime_division.do each |x,y|
    a &lt;&lt; x**(y-1)*(x-1)
  end
  return a.reduce :lcm
end
</code></pre>
</div>
<div id="pu11" class="pu"><h2>JavaScript (ES6), <s>143</s> 135 bytes</h2>

<p><em>Edit: saved 8 bytes thanks to Neil</em></p>

<p>An implementation using functional programming.</p>

<pre class="lang-js prettyprint-override"><code>n=&gt;(A=[...Array(n).keys()]).find(k=&gt;k&amp;&amp;!c.some(c=&gt;A.slice(0,k).reduce(y=&gt;y*c%n,1)-1),c=A.filter(x=&gt;(g=(x,y)=&gt;x?g(y%x,x):y)(x,n)==1))||1
</code></pre>

<h3>Ungolfed and commented</h3>

<pre><code>n =&gt;                                          // Given a positive integer n:
  (A = [...Array(n).keys()])                  // Build A = [0 ... n-1].
  .find(k =&gt;                                  // Try to find k in [1 ... n-1] such as
    k &amp;&amp; !c.some(c =&gt;                         // for each coprime c: c^k ≡ 1 (mod n).
      A.slice(0, k).reduce(y =&gt;               // We use reduce() to compute
        y * c % n, 1                          // c^k mod n.
      ) - 1                                   // Compare it with 1.
    ),                                        // The list of coprimes is precomputed
    c = A.filter(x =&gt;                         // before the find() loop is executed:
      (                                       // for each x in [0 ... n-1], keep
        g = (x, y) =&gt; x ? g(y % x, x) : y     // only integers that verify:
      )(x, n) == 1                            // gcd(x, n) = 1
    )                                         // (computed recursively)
  ) || 1                                      // Default result is 1 (for n = 1)
</code></pre>

<h3>Demo</h3>

<p>Although it does work for <code>6511</code> and <code>10000</code>, I won't include them here as it tends to be a bit slow.</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let f =
n=&gt;(A=[...Array(n).keys()]).find(k=&gt;k&amp;&amp;!c.some(c=&gt;A.slice(0,k).reduce(y=&gt;y*c%n,1)-1),c=A.filter(x=&gt;(g=(x,y)=&gt;x?g(y%x,x):y)(x,n)==1))||1

console.log(f(1));     // 1
console.log(f(2));     // 1
console.log(f(3));     // 2
console.log(f(10));    // 4
console.log(f(35));    // 12
console.log(f(101));   // 100
console.log(f(530));   // 52
console.log(f(3010));  // 84</code></pre>
</div>
</div>
</p>
</div>
<div id="pu12" class="pu"><h1>Java8 <s>38</s> 19 + <s>287</s> <s>295</s> <s>253</s> <s>248</s> 241 = <s>325</s> <s>333</s> <s>272</s> <s>267</s> 260 bytes</h1>
<pre><code>BigInteger B(int i){return new BigInteger(&quot;&quot;+i);}int c(int...k){int n=k[0];for(k[0]=1;n&gt;1&amp;!java.util.stream.IntStream.range(0,n).filter(i-&gt;B(n).gcd(B(i)).equals(B(1))).allMatch(x-&gt;B(x).modPow(B(k[0]),B(n)).equals(B(1)));k[0]++);return k[0];}
</code></pre>
<p><strong>Imports, 19 bytes</strong></p>
<pre><code>import java.math.*;
</code></pre>
<p><strong>Explanation</strong></p>
<p>It is a straight forward implementation. The co-primes are calculated in the <code>Set p</code> and every one's kth power is used to check if it equals 1 modulo n.</p>
<p>I had to use <code>BigInteger</code> because of precision issues.</p>
<p><strong>Usage</strong></p>
<pre><code>public static void main(String[] args) {
    Carmichael c = new Carmichael();
    System.out.println(c.c(3)); // prints 2
}
</code></pre>
<p><strong>Ungolfed</strong></p>
<pre><code>// returns the BigInteger representation of the given interger
BigInteger B(int i) {
    return new BigInteger(&quot;&quot;+i);
}
// for a given integer it returns the result of the carmichael function again as interger
// so the return value cannot be larger
int c(int... k) {
    int n = k[0];
    // iterate k[0] until for all co-primes this is true: (x^n) mod n == 1, if n==1 skip the loop
    for (k[0]=1;n &gt; 1 &amp;&amp; !java.util.stream.IntStream.range(0, n)
                .filter(i -&gt; B(n).gcd(B(i)).equals(B(1)))
                .allMatch(x -&gt; B((int) x).modPow(B(k[0]), B(n)).equals(B(1)));k[0]++);
    return k[0];
}
</code></pre>
<p>Any suggestions to golf it more are welcome :-)</p>
<p><strong>Update</strong></p>
<ul>
<li>No elements outside the functions that keep the state</li>
<li>Followed Olivier Grégoire's advice and saved 1 byte from <code>B()</code></li>
<li>Removed the <code>k()</code> method and <code>p</code> (co-primes) Set.</li>
<li>Removed not required casting to int.</li>
<li>Added varags and use for instead of while.</li>
</ul>
</div>
<div id="pu13" class="pu"><h1>Java, <del>209</del> <del>207</del> <del>202</del> <del>194</del> 192 bytes</h1>

<p>Code (96 bytes):</p>

<pre><code>n-&gt;{for(int x,k=1,a;;k++){for(a=1,x=0;++x&lt;=n&amp;&amp;a&lt;2;)a=g(x,n)&lt;2?p(x,k,n):1;if(a&lt;2||n&lt;2)return k;}}
</code></pre>

<p>extra functions (96 bytes):</p>

<pre><code>int g(int a,int b){return b&lt;1?a:g(b,a%b);}int p(int n,int p,int m){return p&lt;2?n:n*p(n,p-1,m)%m;}
</code></pre>

<h2>Testing &amp; ungolfed</h2>

<pre><code>import java.util.Arrays;
import java.util.function.IntUnaryOperator;

public class Main2 {

  static int g(int a,int b) { // recursive gcd
    return b &lt; 1
        ? a
        : g(b,a%b);
  }

  static int p(int n, int p, int m) { // recursive modpow
    return p &lt; 2
      ? n
      : n * p(n, p - 1, m) % m;
  }

  public static void main(String[] args) {

    IntUnaryOperator f = n -&gt; {
      for(int x,k=1,a;;k++) { // for each k
        for(a=1,x=0;++x&lt;=n&amp;&amp;a&lt;2;) // for each x
          a=g(x,n)&lt;2?p(x,k,n):1; // compute modpow(x,k,n) if g(x,n)
        if(a&lt;2||n&lt;2) // if all modpow(x,k,n)=1. Also check for weird result for n=1.
          return k;
      }
    };

    Arrays.stream(new int[]{1, 2, 3, 10, 35, 101, 530, 3010, 6511, 10000})
        .map(f)
        .forEach(System.out::println);
  }
}
</code></pre>

<h2>Notes</h2>

<ul>
<li>the use of <code>a</code> being an <code>int</code> is shorter than if I had to use a <code>boolean</code> to perform my tests.</li>
<li>Yes, it's shorter to <code>valueOf</code> all new <code>BigInteger</code> than create a separate function (there are 5, plus the <code>ONE</code> constant is a freebie).</li>
<li>Algorithm is different than @Master_ex' algorithm, so it's not just a golfed repost. Also, this algorithm is much less efficient as <code>gcd</code> is computed again and again for the same values.</li>
</ul>

<h2>Shaves</h2>

<ol>
<li>209 -> 207 bytes:

<ul>
<li><code>if(...)a=...;</code> -> <code>a=...?...:1;</code></li>
<li><code>a==1</code> -> <code>a&lt;2</code></li>
</ul></li>
<li>207 -> 202 bytes

<ul>
<li>Got rid of <code>BigInteger</code> by golfing <code>gcd</code> and <code>modPow</code> for <code>int</code>.</li>
</ul></li>
<li>202 -> 194 bytes

<ul>
<li>looping <code>modPow</code> -> recursive</li>
</ul></li>
<li>194 -> 192 bytes

<ul>
<li><code>==1</code> -> <code>&lt;2</code> (seems to work for all the test cases, don't know for other numbers.)</li>
</ul></li>
</ol>
</div>
<div id="pu14" class="pu"><h1>Mathematica without built-in, <s>58</s> 57 bytes</h1>

<p><em>Thanks to Martin Ender for finding an error, then saving me the bytes it took to fix it!</em></p>

<p><em>Thanks to miles for saving 1 byte! (which seemed like 2 to me)</em></p>

<p>Built-ins are totally fine ... but for those who want to implement it without using brute force, here's a formula for the Carmichael function:</p>

<pre><code>LCM@@(EulerPhi[#^#2]/If[#==2&lt;#2,2,1]&amp;@@@FactorInteger@#)&amp;
</code></pre>

<p>If p is a prime, the Carmichael function λ(p^r) equals φ(p^r) = (p-1)*p^(r-1)—<em>except</em> when p=2 and r≥3, in which case it's half that, namely 2^(r-2).</p>

<p>And if the prime-power factorization of n equals p1^r1 * p2^r2 * ..., then λ(n) equals the least common multiple of { λ(p1^r1), λ(p2^r2), ...}.</p>

<p>Runtime is one instant more than factoring the integer in the first place.</p>
</div>
<div id="pu15" class="pu"><h1>J, <s>28</s> 27 bytes</h1>

<pre><code>[:*./@(5&amp;p:%2^0=8&amp;|)2^/@p:]
</code></pre>

<p>The Carmichael function is λ(<em>n</em>) and the totient function is φ(<em>n</em>).</p>

<p>Uses the definition where λ(<em>p</em><sup><em>k</em></sup>) = φ(<em>p</em><sup><em>k</em></sup>)/2 if <em>p</em> = 2 and <em>k</em> > 2 else φ(<em>p</em><sup><em>k</em></sup>). Then, for general <em>n</em> = <em>p</em><sub>1</sub><sup><em>k</em><sub>1</sub></sup> <em>p</em><sub>2</sub><sup><em>k</em><sub>2</sub></sup> ⋯ <em>p</em><sub><em>i</em></sub><sup><em>k</em><sub><em>i</em></sub></sup>, λ(<em>n</em>) = LCM[ λ(<em>p</em><sub>1</sub><sup><em>k</em><sub>1</sub></sup>) λ(<em>p</em><sub>2</sub><sup><em>k</em><sub>2</sub></sup>) ⋯ λ(<em>p</em><sub><em>i</em></sub><sup><em>k</em><sub><em>i</em></sub></sup>) ].</p>

<h2>Usage</h2>

<p>Extra commands used to format multiple input/output.</p>

<pre><code>   f =: [:*./@(5&amp;p:%2^0=8&amp;|)2^/@p:]
   f 530
52
   (,.f"0) 1 2 3 10 35 101 530 3010 6511 10000
    1    1
    2    1
    3    2
   10    4
   35   12
  101  100
  530   52
 3010   84
 6511 3056
10000  500
</code></pre>

<h2>Explanation</h2>

<pre><code>[:*./@(5&amp;p:%2^0=8&amp;|)2^/@p:]  Input: integer n
                          ]  Identity function, get n
                    2   p:   Get a table of prime/exponent values for n
                     ^/@     Raise each prime to its exponent to get the prime powers of n
[:    (            )         Operate on the prime powers
                8&amp;|            Take each modulo 8
              0=               Test if its equal to 0, 1 if true else 0
            2^                 Raise 2 to the power of each
       5&amp;p:                    Apply the totient function to each prime power
           %                   Divide it by the powers of 2
  *./@                       Reduce using LCM and return
</code></pre>
</div>
<div id="pu16" class="pu"><h1>Ruby, <del>59</del> 56 bytes</h1>

<pre><code>-&gt;x{a=1..x
a.detect{|k|a.all?{|y|x.gcd(y)&gt;1||y**k%x&lt;2}}}
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/93739/">93739</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




