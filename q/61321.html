<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::61321</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>064</td><td>Nim</td><td>230811T132608Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/264014#264014">xigoi</a></td></tr>
<tr d-ix="1"><td>002</td><td>Thunno 2</td><td>230811T131436Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/264012#264012">The Thon</a></td></tr>
<tr d-ix="2"><td>nan</td><td></td><td>221024T133238Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/253700#253700">bigyihsu</a></td></tr>
<tr d-ix="3"><td>032</td><td>R</td><td>221023T193526Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/253666#253666">Giuseppe</a></td></tr>
<tr d-ix="4"><td>005</td><td>Japt h</td><td>221023T220532Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/253674#253674">Shaggy</a></td></tr>
<tr d-ix="5"><td>027</td><td>Raku</td><td>221023T170754Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/253660#253660">Sean</a></td></tr>
<tr d-ix="6"><td>038</td><td>Ruby</td><td>221023T152809Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/253656#253656">Jordan</a></td></tr>
<tr d-ix="7"><td>021</td><td>Factor</td><td>221023T143124Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/253654#253654">chunes</a></td></tr>
<tr d-ix="8"><td>004</td><td>05AB1E</td><td>161114T155911Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/99762#99762">Magic Oc</a></td></tr>
<tr d-ix="9"><td>031</td><td>PARI/GP</td><td>220811T022237Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/250955#250955">alephalp</a></td></tr>
<tr d-ix="10"><td>002</td><td>Vyxal</td><td>220811T012839Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/250948#250948">naffetS</a></td></tr>
<tr d-ix="11"><td>067</td><td>Lua</td><td>210123T015621Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/217916#217916">J. А. de</a></td></tr>
<tr d-ix="12"><td>003</td><td>Husk</td><td>210123T000507Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/217913#217913">user</a></td></tr>
<tr d-ix="13"><td>003</td><td>Jelly</td><td>171015T174811Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/145388#145388">Mr. Xcod</a></td></tr>
<tr d-ix="14"><td>047</td><td>Axiom</td><td>161118T224909Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/100399#100399">user5898</a></td></tr>
<tr d-ix="15"><td>067</td><td>C++14</td><td>161114T090220Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/99726#99726">Karl Nap</a></td></tr>
<tr d-ix="16"><td>003</td><td>K</td><td>151021T065008Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/61347#61347">JohnE</a></td></tr>
<tr d-ix="17"><td>022</td><td>Gol><> 0.3.10</td><td>151021T113647Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/61356#61356">Sp3000</a></td></tr>
<tr d-ix="18"><td>nan</td><td>C++14</td><td>151020T231500Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/61339#61339">Zereges</a></td></tr>
<tr d-ix="19"><td>078</td><td>C++ 61 + 17 =</td><td>151023T043431Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/61527#61527">Jerry Co</a></td></tr>
<tr d-ix="20"><td>052</td><td>Python</td><td>151022T234839Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/61514#61514">xnor</a></td></tr>
<tr d-ix="21"><td>010</td><td>Burlesque</td><td>151022T164244Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/61478#61478">mroman</a></td></tr>
<tr d-ix="22"><td>073</td><td>Python 3</td><td>151021T142416Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/61369#61369">Morgan T</a></td></tr>
<tr d-ix="23"><td>076</td><td>Python</td><td>151020T214522Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/61335#61335">Anthony </a></td></tr>
<tr d-ix="24"><td>038</td><td>JavaScript ES6</td><td>151021T204452Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/61413#61413">edc65</a></td></tr>
<tr d-ix="25"><td>067</td><td>Python 2</td><td>151021T155214Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/61377#61377">mathmand</a></td></tr>
<tr d-ix="26"><td>075</td><td>R</td><td>151020T210244Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/61330#61330">njnnja</a></td></tr>
<tr d-ix="27"><td>073</td><td>Labyrinth</td><td>151021T133844Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/61366#61366">Martin E</a></td></tr>
<tr d-ix="28"><td>nan</td><td>C#</td><td>151021T013123Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/61343#61343">LegionMa</a></td></tr>
<tr d-ix="29"><td>019</td><td>Mathematica</td><td>151020T193234Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/61322#61322">Martin E</a></td></tr>
<tr d-ix="30"><td>029</td><td>Julia</td><td>151021T062202Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/61346#61346">Glen O</a></td></tr>
<tr d-ix="31"><td>005</td><td>J</td><td>151020T200856Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/61325#61325">Dennis</a></td></tr>
<tr d-ix="32"><td>008</td><td>APL</td><td>151020T193626Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/61323#61323">Dennis</a></td></tr>
<tr d-ix="33"><td>024</td><td>Octave</td><td>151021T033048Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/61344#61344">alephalp</a></td></tr>
<tr d-ix="34"><td>023</td><td>Haskell</td><td>151020T210919Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/61333#61333">Zgarb</a></td></tr>
<tr d-ix="35"><td>041</td><td>R</td><td>151021T012934Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/61342#61342">flodel</a></td></tr>
<tr d-ix="36"><td>009</td><td>Pyth</td><td>151020T211803Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/61334#61334">Jakube</a></td></tr>
<tr d-ix="37"><td>041</td><td>Matlab</td><td>151020T193932Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/61324#61324">flawr</a></td></tr>
<tr d-ix="38"><td>047</td><td>Haskell</td><td>151020T203024Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/61328#61328">Jake</a></td></tr>
<tr d-ix="39"><td>013</td><td>CJam</td><td>151020T205113Z</td><td><a href="https://codegolf.stackexchange.com/questions/61321/iterated-partial-sums/61329#61329">Martin E</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://nim-lang.org/" rel="nofollow noreferrer">Nim</a>, 64 bytes</h1>
<pre><code>import math
proc s[I](x:var seq[I],n:I)=
 for _ in 1..n:x.cumsum
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m704LzN3wYKlpSVpuhY3HTJzC_KLShRyE0syuAqK8pMViqM9YzUqrMoSixSKUwuBHJ08K09NWy6FtPwihXiFzDwFQz29PKsKveTS3OLSXKg5sSD1FVZgLZl5JbFcFQq2Cg7RusY6CiY6CuY6CrqGOgqGprFcxRoVQIYmV2pyRr5CBX5lxjBlEEtgjgYA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Outputs by mutating the array in place.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/Thunno/Thunno2" rel="nofollow noreferrer">Thunno 2</a>, 2 <a href="https://github.com/Thunno/Thunno2/blob/main/docs/codepage.md" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>{ṡ
</code></pre>
<p><a href="https://Not-Thonnu.github.io/run#aGVhZGVyPSZjb2RlPSU3QiVFMSVCOSVBMSZmb290ZXI9JmlucHV0PTElMkMlMjAlNUItMyUyQyUyMDQlMkMlMjA3JTJDJTIwLTElMkMlMjAxNSU1RCUyMCUzRCUzRSUyMCU1Qi0zJTJDJTIwMSUyQyUyMDglMkMlMjA3JTJDJTIwMjIlNUQlMEEzJTJDJTIwJTVCLTMlMkMlMjA0JTJDJTIwNyUyQyUyMC0xJTJDJTIwMTUlNUQlMjAlM0QlM0UlMjAlNUItMyUyQyUyMC01JTJDJTIwMSUyQyUyMDE0JTJDJTIwNDklNUQmZmxhZ3M9Q2U=" rel="nofollow noreferrer">Try it online!</a></p>
<h4>Explanation</h4>
<pre class="lang-python prettyprint-override"><code>{ṡ  # Implicit input
{   # Input number of times:
 ṡ  #  Cumulative sums
    # Implicit output
</code></pre>
</div>
<div id="pu2" class="pu">
<h1><a href="https://go.dev" rel="nofollow noreferrer">Go</a>, 120 bytes</h1>
<pre class="lang-go prettyprint-override"><code>func f(s[]int,n int)(o[]int){if n&lt;1{return s}
o=[]int{s[0]}
for i:=range s[1:]{o=append(o,s[i+1]+o[i])}
return f(o,n-1)}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=fZDLTgMhFIbjlqc4dgUpY6SXWBtn6d5Fd4QFrUNDZGBkZpKaCU_ipjHxIXwUfRqBVk1ddMPth-98h9e3rdt_NHLzJLcV1FJbpOvG-e5qpOpu9N53qlh87lRvN6Bwy4W2HbUQR4Jd3pFBK7B3bPBV13sLbUCuzMnQ8msRkHIe9LL00sYKLWdLMbhSNk1lH7GjLddjJsaOa0ECOjJUDGzBSDjU_7oQWeD-uZeGr2Dj6kZ6uTaVwIZ64GJF8No5Q7MPikKmstgQuCzzyhP40VPStBUt2D8vA6kNEy3SG5_m0xc6_Np1vk8EFBDKWunXcCy7oy_LUuFD78WUwozCDYWCUWDzEAdC4S-Mp4ucTyYBrWk0ye3hSCHowcdrxqYNjRlJ7HPo6Qm6mGc8i5dmtxl-ln385f3-MH8D" rel="nofollow noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.r-project.org/" rel="nofollow noreferrer">R</a>, 32 bytes</h1>

<pre class="lang-r prettyprint-override"><code>function(l,i)diffinv(l,,i)[0:-i]
</code></pre>
<p><a href="https://tio.run/##K/qfpmCj@z@tNC@5JDM/TyNHJ1MzJTMtLTOvDMgGcqINrHQzY/@naSRr6BrrmOiY6@ga6hiaauoYanJhChpr/gcA" rel="nofollow noreferrer" title="R – Try It Online">Try it online!</a></p>
<p><code>diffinv</code> is the <code>inv</code>erse of <code>diff</code>, with optional parameters <code>lag</code>, <code>differences</code>, and <code>xi</code>; <code>lag</code> defaults to <code>1</code> so we skip it and we compute the the inverse of the <span class="math-container">\$n^\text{th}\$</span> difference; <code>xi</code> defaults to <code>0</code>, so it prepends <code>i</code> instances of <code>0</code> to the inverse difference list, which we discard by negative indexing.</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/ETHproductions/japt" rel="nofollow noreferrer">Japt</a> <a href="https://codegolf.meta.stackexchange.com/a/14339/"><code>-h</code></a>, 5 <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>ÆV=å+
</code></pre>
<p><a href="https://petershaggynoble.github.io/Japt-Interpreter/?v=1.4.6&amp;flags=LWg&amp;code=xlY95Ss&amp;input=MwpbLTMsIDQsIDcsIC0xLCAxNV0" rel="nofollow noreferrer">Try it</a></p>
<pre><code>ÆV=å+     :Implicit input of integer U &amp; array V
Æ         :Map the range [0,U)
 V=       :  Reassign to V
   å+     :  Cumulatively reduce V by addition
          :Implicit output of last element
</code></pre>
</div>
<div id="pu5" class="pu"><h1><a href="https://raku.org/" rel="nofollow noreferrer">Raku</a>, 27 bytes</h1>
<pre><code>{(@^l,{[\+] @$_}...*)[$^n]}
</code></pre>
<p><a href="https://tio.run/##Zcq7CoAgAEbhV/kJiSyTxC5LRe9hJg05daOmsJ7d2psOfJx9OubSLxdCi8a7qBtm5lSfaHTEPJzzmCoyrPrx53ghIEZlmuGL0GhaOIv7@wLY7UBUpxI5KqQComgZBGV/lNS/" rel="nofollow noreferrer" title="Perl 6 – Try It Online">Try it online!</a></p>
<p><code>[\+] @array</code> is how to get a list of partial sums in Raku.  Here we construct an infinite sequence of sequences of partial sums and then select the one at the desired index.</p>
</div>
<div id="pu6" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, <s>52</s> 38 bytes</h1>
<p>-14 bytes thanks to <a href="https://codegolf.stackexchange.com/users/110888/south">south</a></p>
<pre class="lang-ruby prettyprint-override"><code>F=-&gt;a,n{x=0;n&lt;1?a:F[a.map{x+=_1},n-1]}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m72kqDSpcsGCpaUlaboWN9XcbHXtEnXyqitsDazzbAztE63cohP1chMLqiu0beMNa3XydA1jayGqdxUouEVH6xrrKJjoKJjrKOga6igYmsbqKBjHQhTAjAUA" rel="nofollow noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu7" class="pu"><h1><a href="https://factorcode.org/" rel="nofollow noreferrer">Factor</a>, 21 bytes</h1>
<pre class="lang-factor prettyprint-override"><code>[ [ cum-sum ] times ]
</code></pre>
<p><a href="https://tio.run/##dY2xCsIwFEX3fMX9gRRCLYKCq7i4FKfS4RFaDPJsyHsdpOTb06Cz98Id7hnOTF6XVB797X49gUQWL2DS53caUdIgGuoZ06T6iSm8FWdjNoOarda2OOAI6@A6ZDjkf6itKJsyYIBf2crKGKGBJ8FY5p/9whRRtf7VlB0" rel="nofollow noreferrer" title="Factor – Try It Online">Try it online!</a></p>
</div>
<div id="pu8" class="pu"><h1><a href="http://github.com/Adriandmen/05AB1E" rel="nofollow noreferrer">05AB1E</a>, 4 bytes</h1>
<pre><code>F.pO
</code></pre>
<h2>Explanation</h2>
<pre><code>F    # Implicitly take first input and loop n times.
 .p  # Generate prefixes of input.
   O # Sum all prefixes (implicitly vectorized).
</code></pre>
<p><a href="http://05ab1e.tryitonline.net/#code=Ri5wTw&amp;input=MwpbLTMsIDQsIDcsIC0xLCAxNV0K" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu9" class="pu"><h1><a href="https://pari.math.u-bordeaux.fr" rel="nofollow noreferrer">PARI/GP</a>, 31 bytes</h1>
<pre><code>f(a,n)=Vec(Ser(a)/(1-x)^n+.5)\1</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m728ILEoMz69YMGCpaUlaboW-9M0EnXyNG3DUpM1glOLNBI19TUMdSs04_K09Uw1Ywwhqm7aFxRl5pVopGlE6xrrKJjoKJjrKOga6igYmsYCCU1NLnzyxpqaEGNglgIA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Converts the list to a power series, divides it by <span class="math-container">\$(1-x)^n\$</span>, and then converts it back to a list.</p>
<p>PARI/GP would drop the leading zeros when converting a power series into a list. So I need to do <code>Vec(...+.5)\1</code>.</p>
<hr />
<h1><a href="https://pari.math.u-bordeaux.fr" rel="nofollow noreferrer">PARI/GP</a>, 31 bytes</h1>
<pre><code>f(a,n)=a*matrix(#a,,i,j,i&lt;=j)^n</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m728ILEoMz69YMGCpaUlaboW-9M0EnXyNG0TtXITS4oyKzSUE3V0MnWydDJtbLM04_Igqm7aFxRl5pVopGlE6xrrKJjoKJjrKOga6igYmsYCCU1NLnzyxpqaEGNglgIA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Multiples the <span class="math-container">\$n\$</span>-th power of the upper triangular matrix of ones. A port of <a href="https://codegolf.stackexchange.com/a/61344/9288">my octave answer</a>.</p>
</div>
<div id="pu10" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a>, 2 bytes</h1>
<pre><code>(¦
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/#WyIiLCIiLCIowqYiLCIiLCIzXG5bLTMsIDQsIDcsIC0xLCAxNV0iXQ==" rel="nofollow noreferrer">Try it Online!</a></p>
</div>
<div id="pu11" class="pu"><h1>Lua (67 bytes)</h1>
<pre class="lang-lua prettyprint-override"><code>function x(t,n)return load(&quot;return &quot;..table.concat(t,&quot;+&quot;,1,n))()end
</code></pre>
<p>Explanation:</p>
<p><code>table.concat(t,&quot;+&quot;,1,n)</code> gives the string formed by concatenation of elements of <code>t</code> from 1 to n using <code>+</code> as connector, i.e. <code>t[1]+...+t[n]</code>.</p>
<p><code>load(&lt;string&gt;)()</code>, as its name suggests, loads a string to be executed as a function. In this case, a function with zero arguments given by <code>table.concat</code>.</p>
</div>
<div id="pu12" class="pu"><h1><a href="https://github.com/barbuz/Husk" rel="nofollow noreferrer">Husk</a>, <s>4</s> 3 bytes</h1>
<p>Saved 1 byte thanks to <a href="https://codegolf.stackexchange.com/users/95126/dominic-van-essen">Dominic Van Essen</a></p>
<pre><code>!¡∫
</code></pre>
<p><a href="https://tio.run/##yygtzv7/X/HQwkcdq////x@ta6xjomOuo2uoY2ga@98YAA" rel="nofollow noreferrer" title="Husk – Try It Online">Try it online!</a></p>
<pre><code>!¡∫
 ¡   Repeatedly apply the following function to the first argument, making an infinite list
  ∫  Cumulative sum (one cycle)
!    Index into this list with the second argument
</code></pre>
</div>
<div id="pu13" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 3 bytes</h1>
<pre><code>SƤ¡
</code></pre>
<p><a href="https://tio.run/##y0rNyan8/z/42JJDC////x@ta6yjYKKjYK6joGuoo2BoGvvfGAA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p>This is my (<a href="https://codegolf.stackexchange.com/posts/145388/revisions">Mr Xcoder</a>'s) method.</p>
<h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 3 bytes</h1>
<pre><code>+\¡
</code></pre>
<p><a href="https://tio.run/##y0rNyan8/1875tDC////R@sa6yiY6CiY6yjoGuooGJrG/jcGAA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p>This is <a href="https://codegolf.stackexchange.com/users/66833/">caird coinheringaahing</a>'s solution.</p>
<h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 2 bytes</h1>
<pre><code>Ä¡
</code></pre>
<p><a href="https://tio.run/##y0rNyan8//9wy6GF////j9Y11lEw0VEw11HQNdRRMDSN/W8MAA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p>This is a newer solution.</p>
<h3>Method #1</h3>
<pre>
SƤ¡  - Full program, dyadic.

  ¡  - Apply repeatedly, N times.
 Ƥ   - Map the preceding link over the prefixes of the list.
S    - Sum.
     - Output implicitly
</pre>
<h3>Method #2</h3>
<pre>
+\¡  - Full program, dyadic.

  ¡  - Apply repeatedly, N times.
 \   - Cumulative reduce by:
+    - Addition.
</pre>
<h3>Method #3</h3>
<pre>
Ä¡  - Full program, dyadic.

 ¡  - Apply repeatedly, N times.
Ä   - Cumulative sums.
</pre>
</div>
<div id="pu14" class="pu"><p><strong>Axiom <s>213</s> 47 bytes</strong></p>

<pre><code>m(a,b)==(for i in 1..b repeat a:=scan(+,a,0);a)
</code></pre>

<p>ungolf and some example</p>

<pre><code> (3) -&gt; [m([-3,4,7,-1,15],1), m([-3,4,7,-1,15],3)]
    Compiling function l with type List Integer -&gt; List Integer
    Compiling function m with type (List Integer,Integer) -&gt; List
       Integer

    (3)  [[- 3,1,8,7,22],[- 3,- 5,1,14,49]]
                                                       Type: List List Integer
</code></pre>
</div>
<div id="pu15" class="pu"><h1>C++14, 67 bytes</h1>

<p>As unnamed lambda modifying its input, requiring <code>c</code> as a random-access-container like <code>vector&lt;int&gt;</code>.</p>
<pre class="lang-c++ prettyprint-override"><code>[](auto&amp;c,int n){while(n--)for(int i=0;i++&lt;c.size();c[i]+=c[i-1]);}
</code></pre>
</div>
<div id="pu16" class="pu"><h1>K, <s>7</s> 3 bytes</h1>

<pre><code>{y+\/x}
</code></pre>

<p>Very similar to the J solution. <code>+\</code> precisely performs a partial sum, and when <code>/</code> is provided with a monadic verb and an integer left argument it iterates a specified number of times, like a "for" loop. The rest is just wrapping it up neatly to suit the order of arguments.</p>

<pre><code>  {y+\/x}[-3 4 7 -1 15;1]
-3 1 8 7 22
  {y+\/x}[-3 4 7 -1 15;3]
-3 -5 1 14 49
</code></pre>

<p>Tested in Kona and <a href="http://johnearnest.github.io/ok/index.html?run=%20%7By%2B%5C%2Fx%7D%5B-3%204%207%20-1%2015%3B3%5D" rel="nofollow">oK</a>.</p>

<h2>Edit:</h2>

<p>If I'm allowed to reverse the arguments, as @kirbyfan64sos determined, I can dispense with the function wrapping entirely:</p>

<pre><code>+\/
</code></pre>

<p>Invoked like:</p>

<pre><code>+\/[3;-3 4 7 -1 15]
</code></pre>

<p>This works properly in both k2.8 and k5. It doesn't work in oK since that interpreter does not yet support curried (aka "projected") adverbs, and it doesn't appear to work properly in Kona for less clear reasons.</p>

<p><em>edit</em>: As of a few days ago, the <code>+\/</code> formulation also works in oK.</p>
</div>
<div id="pu17" class="pu"><h1><a href="https://github.com/Sp3000/Golfish/wiki" rel="nofollow">Gol>&lt;> 0.3.10</a>, 22 bytes</h1>

<pre><code>SI
C&gt;rFlMF:}+
NRl&lt;C}&lt;;
</code></pre>

<p>The first integer is taken to be the iteration number and the rest make up the list. The final list is outputted newline-separated.</p>

<p>The language is still quite young and unstable, but since I'm pretty set on these operators I thought it'd be okay.</p>

<h3>Explanation</h3>

<pre><code>SI            Read integer, moving down on EOF (first line runs as loop)
r             Reverse stack, putting iteration number on top

[outer loop]
F             Do #(iterations) times

[inner loop]
lMF           Do #(length of stack - 1) times
:             Duplicate top of stack
}             Rotate stack rightward (top goes to bottom)
+             Add the top two elements of the stack
C             Continue inner loop, moving down from F when loop is over

}             Rotate once more
C             Continue outer loop, moving down from F when loop is over

lRN           Print stack as (num + newline)
;             Halt
</code></pre>

<p>To see why this works, let's try a small example <code>[5 2 1]</code>:</p>

<pre><code>[5 2 1] -- : --&gt; [5 2 1 1] -- } --&gt;  [1 5 2 1]  -- + --&gt; [1 5 3]
[1 5 3] -- : --&gt; [1 5 3 3] -- } --&gt;  [3 1 5 3]  -- + --&gt; [3 1 8]

-- } --&gt; [8 3 1]
</code></pre>
</div>
<div id="pu18" class="pu"><h1>C++14, <s>102</s> <s>103</s> 94 + 17 (include) = 111 bytes</h1>

<pre><code>#include&lt;vector&gt;
auto f(std::vector&lt;int&gt;a,int n){for(;n--;)for(int i=0;i&lt;a.size()-1;++i)a[i+1]+=a[i];return a;}
</code></pre>

<p>Ungolfed, with test case</p>

<pre><code>#include &lt;vector&gt;
#include &lt;iostream&gt;

auto f(std::vector&lt;int&gt; a, int n)
{
    for (; n--;)
        for (int i = 0; i &lt; a.size() - 1; ++i)
            a[i + 1] += a[i];
    return a;
}


int main()
{
    auto t = f({-3, 4, 7, -1, 15}, 3);
    for (int i : t)
        std::cout &lt;&lt; i &lt;&lt; " ";
}
</code></pre>

<p><s>Relies on order of evaluation. Not sure if it is UB or not, but works</s> It's compiler dependent, so I changed it.</p>
</div>
<div id="pu19" class="pu"><h1>C++ (61 + 17 = 78 bytes)</h1>
<pre><code>#include&lt;numeric&gt;
void f(int*a,int*e,int n){for(;n--;)std::partial_sum(a,e,a);}
</code></pre>
<p>Test case:</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;iterator&gt;

int main() {
    int a[] { -3, 4, 7, -1, 15 };
    f(a, std::end(a), 3);
    for (auto i : a)
        std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;
}
</code></pre>
<p>This takes a slight liberty with the specification: it uses a C-style array, passing pointers to the beginning and end of the array. Internally, as you can see, it's only an <em>extremely</em> thin wrapper around the <code>std::partial_sum</code> in the standard library. Rather than actually return the resulting value, it just modifies the array that's passed in.</p>
<p>If we don't mind pushing definitions of things to the limit (and, arguably, a bit beyond) we can define a &quot;function&quot; in a lambda expression:</p>
<pre><code>#include&lt;numeric&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;

int main() {
    int a[] { -3, 4, 7, -1, 15 };
    int *e = std::end(a);
    int n=3;

    auto f=[&amp;]{for(;n--;)std::partial_sum(a,e,a);};

    f();
    for (auto i : a)
        std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;
}
</code></pre>
<p>This reduces the definition of the function(-like object) to this piece:</p>
<pre><code>[&amp;]{for(;n--;)std::partial_sum(a,e,a);};
</code></pre>
<p>...for 40 bytes (+17 for the <code>#include</code>).</p>
</div>
<div id="pu20" class="pu"><h2>Python, 52 bytes</h2>



<pre class="lang-python prettyprint-override"><code>f=lambda l,n:n*l and f(f(l[:-1],1)+[sum(l)],n-1)or l
</code></pre>

<p>A recursive function that recurses both on the list <code>l</code> and the number of iterations <code>n</code>. Let's break it down.</p>

<p>First, let's consider a recursive function <code>g</code> that iterated the partial sum just once.</p>

<pre class="lang-python prettyprint-override"><code>g=lambda l:l and g(l[:-1])+[sum(l)]
</code></pre>

<p>For an empty list <code>l</code>, this returns <code>l</code> itself, the empty list. Otherwise, the last entry of the partial sums of <code>l</code> is the overall sum of <code>l</code>, which is appended to the recursive result for all but the last element of <code>l</code>.</p>

<p>Now, let's look at a function <code>f</code> that applies <code>g</code> for <code>n</code> iterations.</p>

<pre class="lang-python prettyprint-override"><code>f=lambda l,n:n and f(g(l),n-1)or l
</code></pre>

<p>When <code>n</code> is <code>0</code>, this returns the list <code>l</code> unchanged, and otherwise, applies <code>g</code> once, then calls <code>f</code> recursively with one fewer iteration remaining.</p>

<p>Now, let's look again at the actual code, which combines the two recursions into a single function. The idea is to treat <code>g(l)</code> as the special case <code>f(l,1)</code>.</p>

<pre class="lang-python prettyprint-override"><code>f=lambda l,n:n*l and f(f(l[:-1],1)+[sum(l)],n-1)or l
</code></pre>

<p>We took <code>f(g(l),n-1)</code> from the previous definition, expanded <code>g(l)</code> into <code>g(l[:-1])+[sum(l)]</code>, and then replaced <code>g(_)</code> with <code>f(_,1)</code> to confined the recursive calls to <code>f</code>.</p>

<p>For the base case, we want to return <code>l</code> whenever <code>n==0</code> or <code>l==[]</code>. We combine these by noting that either one makes <code>n*l</code> be the empty list, which is Falsy. So, we recurse whenever <code>n*l</code> is non-empty, and return <code>l</code> otherwise.</p>

<p>Even though there are two recursive calls to <code>f</code>, this does not cause an exponential blow-up the recursive definition of the Fibonacci numbers, but remains quadratic.</p>
</div>
<div id="pu21" class="pu"><h2>Burlesque, 10 bytes</h2>

<pre><code>{q++pa}jE!
</code></pre>

<p>it's not very efficient in general but it does the trick.</p>

<pre><code>blsq ) {-3 4 7 -1 15} 1 {q++pa}jE!
{-3 1 8 7 22}
blsq ) {-3 4 7 -1 15} 3 {q++pa}jE!
{-3 -5 1 14 49}
</code></pre>
</div>
<div id="pu22" class="pu"><h1>Python 3, 73</h1>
<p>Could probably be golfed down a bit further.</p>
<pre><code>def f(n,i):
 p=0;c=[]
 for m in n:p+=m;c+=[p]
 f(c,i-1)if i else print(n)
</code></pre>
<p>This version uses numpy, which feels a little like cheating, but here it is:</p>
<h1>Python 3 (with numpy), 72</h1>
<pre><code>from numpy import*
def f(n,i):
 if i:c=cumsum(n);f(c,i-1)
 else:print(n)
</code></pre>
</div>
<div id="pu23" class="pu"><h2>Python, <strike>113</strike> <strike>93</strike> <strike>89</strike> 76 bytes</h2>

<pre><code>def f(l,n):
 for i in[0]*n:l=[sum(l[:j+1])for j in range(len(l))];
 print(l)
</code></pre>

<p>It works for both of the test cases. Thanks to Status, Morgan Thrapp, and Ruth Franklin for helping me golf the program down to 93, 89, and 76 bytes respectively. </p>
</div>
<div id="pu24" class="pu"><h1>JavaScript (ES6) 38</h1>

<p>Surprisingly small using .map recursively</p>

<p><div class="snippet" data-lang="js" data-hide="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>f=(l,n,t=0)=&gt;n?f(l.map(x=&gt;t+=x),n-1):l

function test()
{
  var n, v, i = I.value
  v = i.match(/\-?\d+/g).map(x=&gt;+x)
  n = v.pop()
  console.log(v,n)
  O.innerHTML = I.value + ' -&gt; ' + f(v,n) + '\n' + O.innerHTML;
}

test()</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;input id=I value='[-3, 4, 7, -1, 15], 3'&gt;&lt;button onclick="test()"&gt;-&gt;&lt;/button&gt;
&lt;pre id=O&gt;&lt;/pre&gt;</code></pre>
</div>
</div>
</p>
</div>
<div id="pu25" class="pu"><h1>Python 2, 67</h1>
<p>This uses the same summation as <a href="https://codegolf.stackexchange.com/a/61335/36885">Anthony Roitman</a>, and the same recursion as <a href="https://codegolf.stackexchange.com/a/61369/36885">Morgan Thrapp</a>.</p>
<pre><code>f=lambda l,n:f([sum(l[:i+1])for i in range(len(l))],n-1)if n else l
</code></pre>
<p>I developed this solution before I saw theirs, and then it just seemed easier to post it as an answer rather than a comment to either or both of them.</p>
</div>
<div id="pu26" class="pu"><h1>R, 75 bytes</h1>



<p>It's long but a different take...computing the desired sequence directly instead of cumulative sums:</p>

<pre class="lang-r prettyprint-override"><code>function(x,n)sapply(1:length(x),function(i)sum(x[1:i]*choose(i:1+n-2,n-1)))
</code></pre>

<p>Noting that the coefficients of the terms of xi for cumsum^n(x) are diagonals of Pascal's triangle. i.e. </p>

<pre class="lang-r prettyprint-override"><code>cumsum^3(x) = choose(2,2) * x1, choose(3,2) * x1 + choose(2,2) *x2, choose(4,2) * x1 + choose(3,2) * x2 + choose(2,2) * x3, ....
</code></pre>

<p>edit: to make a function</p>
</div>
<div id="pu27" class="pu"><h1><a href="https://github.com/mbuettner/labyrinth" rel="nofollow">Labyrinth</a>, 73 bytes</h1>

<pre><code>;?
,"
;
#
#;}=
;  #
"#;(
_  ;={()"
#;; ( { "
  ; { !\(@
+=( =
" " "
":{:"
</code></pre>

<p>It's been a while since I answered something in Labyrinth, and this seemed doable. :)</p>

<p>Input format is a flat list with the number of iterations first (and then the list to apply the partial sums to). Delimiters don't matter all, as long as there is no character after the last integer, so you can use something readable like:</p>

<pre><code>3 | -3, 4, 7, -1, 15
</code></pre>

<p>Output is newline-separated:</p>

<pre><code>-3
-5
1
14
49
</code></pre>
</div>
<div id="pu28" class="pu"><h1>C#, 52 + 85 = <s>148</s> 137 bytes</h1>



<pre class="lang-cs prettyprint-override"><code>using E=System.Collections.Generic.IEnumerable&lt;int&gt;;
</code></pre>

<p>and</p>

<pre class="lang-cs prettyprint-override"><code>E I(E s,int i){int t=0;return i&lt;1?s:I(System.Linq.Enumerable.Select(s,v=&gt;t+=v),i-1);}
</code></pre>

<p>It uses unorthodox practices (<code>v=&gt;t+=v</code>), but this is PPCG. Also note the stack depth constraint.</p>
</div>
<div id="pu29" class="pu"><h1>Mathematica, 19 bytes</h1>

<p>Well, if built-ins are okay...</p>

<pre><code>Accumulate~Nest~##&amp;
</code></pre>

<p>Defines a function with the same signature as the examples in the challenge. I'm pretty sure, thanks to the long name <code>Accumulate</code> that this will be easily beaten by the golfing languages and the APL-family, though. :)</p>

<p>To elaborate on LegionMammal978's comment for those who don't Mathematica:</p>

<p><code>##</code> represents a <em>sequence</em> of the function's parameters (which is like a list that automatically "splats" wherever it's inserted, if you're more familiar with that term from your language's of choice). The <code>~</code> are syntactic sugar for infix function invocation, so if we call the function with parameters <code>list</code> and <code>n</code> and expand everything, we get:</p>

<pre><code>Accumulate~Nest~##
Nest[Accumulate, ##]
Nest[Accumulate, list, n]
</code></pre>

<p>Which happens to be exactly the argument order expected by <code>Nest</code>.</p>
</div>
<div id="pu30" class="pu"><h1>Julia, 29 bytes</h1>

<pre><code>f(x,y)=y&gt;0?f(cumsum(x),y-1):x
</code></pre>

<p>This really doesn't need much explanation. It's a recursive function, if <code>y==0</code> then just output x. Otherwise decrement y, perform a cumsum, and recurse. Probably not the most golfed possible Julia solution, I'm still working on it.</p>
</div>
<div id="pu31" class="pu"><h1>J, 5 bytes</h1>

<pre><code>+/\^:
</code></pre>

<p>Try it online on <a href="https://a296a8f7c5110b2ece73921ddc2abbaaa3c90d10.googledrive.com/host/0B3cbLoy-_9Dbb0NaSk9MRGE5UEU/index.html#code=3%20(%2B%2F%5C%5E%3A)%20_3%204%207%20_1%2015" rel="noreferrer">J.js</a>.</p>

<h3>How it works</h3>

<ul>
<li><p><code>/\</code> is an adverb (function that takes a left argument) that cumulatively reduces by its argument.</p></li>
<li><p>Thus <code>+/\</code> is the <em>cumulative sum</em> verb.</p></li>
<li><p><code>^:</code> is the <em>power conjunction</em>; <code>(f ^: n) y</code> applies <code>f</code> a total of <code>n</code> times to <code>y</code>.</p></li>
<li><p>The verb-conjunction train <code>+/\^:</code> forms an adverb that repeats <code>+/\</code> as many times as specified in its (left) argument.</p>

<p><code>x (+/\^:) y</code> gets parsed as <code>(x (+/\^:)) y</code>, which is equivalent to executing <code>(+/\^:x) y</code>.</p></li>
</ul>

<p><em>Thanks to @Zgarb for his help with the explanation.</em></p>
</div>
<div id="pu32" class="pu"><h1>APL, <s>9</s> 8 bytes</h1>

<pre><code>{+\⍣⍺⊢⍵}
</code></pre>

<p>This defines a dyadic function that accepts the iterations and list as left and right arguments.</p>

<p><em>Thanks to @NBZ for golfing off 1 byte!</em></p>

<p>Try it online on <a href="http://tryapl.org/?a=3%20%7B+%5C%u2363%u237A%u22A2%u2375%7D%20%AF3%204%207%20%AF1%2015&amp;run" rel="nofollow">TryAPL</a>.</p>

<h3>How it works</h3>

<ul>
<li><p><code>⍺</code> and <code>⍵</code> are the left and right arguments to the function.</p></li>
<li><p><code>+\</code> is cumulative reduce by sum.</p></li>
<li><p><code>⍣⍺</code> repeats the preceding operator <code>⍺</code> times.</p></li>
<li><p><code>⊢⍵</code> applies the identity function to <code>⍵</code>.</p>

<p>This is a shorter way of parsing the code as <code>(+\⍣⍺)⍵</code> instead of <code>+\⍣(⍺⍵)</code>.</p></li>
</ul>

<p>In conjunction, we apply <code>+\</code> a total of <code>⍺</code> times to <code>⍵</code></p>
</div>
<div id="pu33" class="pu"><h1>Octave, 24 bytes</h1>

<pre><code>@(l,n)l*triu(0*l'*l+1)^n
</code></pre>
</div>
<div id="pu34" class="pu"><h2>Haskell, <s>26</s> 23 bytes</h2>

<pre><code>(!!).iterate(scanl1(+))
</code></pre>

<p>This defines an anonymous function, invoked as follows:</p>

<pre><code>&gt; let f = (!!).iterate(scanl1(+)) in f [-3,4,7,-1,15] 3
[-3,-5,1,14,49]
</code></pre>

<p>Thanks to @nimi for saving 3 bytes.</p>

<h2>Explanation</h2>

<pre><code>(!!).                    -- Index by second argument from
     iterate(         )  -- the infinite list obtained by iterating
             scanl1(+)   -- the partial sums function (left scan by +) to first argument
</code></pre>
</div>
<div id="pu35" class="pu"><h2>R, 41 bytes</h2>

<pre><code>function(x,n){for(i in 1:n)x=cumsum(x);x}
</code></pre>
</div>
<div id="pu36" class="pu"><h1>Pyth, 9 bytes</h1>

<pre><code>usM._GvwQ
</code></pre>

<p>Try it online: <a href="http://pyth.herokuapp.com/?code=usM._GvwQ&amp;test_suite=0&amp;input_size=2&amp;test_suite_input=%5B-3%2C%204%2C%207%2C%20-1%2C%2015%5D%0A1%0A%5B-3%2C%204%2C%207%2C%20-1%2C%2015%5D%0A3&amp;input=%5B-3%2C%204%2C%207%2C%20-1%2C%2015%5D%0A3" rel="nofollow">Demonstration</a> or <a href="http://pyth.herokuapp.com/?code=usM._GvwQ&amp;test_suite=1&amp;input_size=2&amp;test_suite_input=%5B-3%2C%204%2C%207%2C%20-1%2C%2015%5D%0A1%0A%5B-3%2C%204%2C%207%2C%20-1%2C%2015%5D%0A3&amp;input=%5B-3%2C%204%2C%207%2C%20-1%2C%2015%5D%0A3" rel="nofollow">Test Suite</a></p>

<h3>Explanation</h3>

<pre><code>usM._GvwQ  implicit: Q = input list
      vw   input number
u       Q  repeat the following instruction ^ times to G = Q
   ._G        sequence of prefixes of G
 sM           sum them up
</code></pre>
</div>
<div id="pu37" class="pu"><h1>Matlab, 41 bytes</h1>

<pre class="lang-matlab prettyprint-override"><code>function f(l,n);for i=1:n;l=cumsum(l);end
</code></pre>
<p>Quite straightforward. I still think it is quite annoying not having a built in way of making piecewise defined anonymous functions, or anchors in recursions.</p>
<p>Ungolfed:</p>
<pre class="lang-matlab prettyprint-override"><code>function f(l,n);
for i=1:n;
    l=cumsum(l);
end
</code></pre>
</div>
<div id="pu38" class="pu"><h2>Haskell, <s>52</s> 47 bytes</h2>

<p>First ever code golf 'attempt', and I'm very much a Haskell beginner, so comments are gladly welcomed! It was not clear in the question as to any necessary format of the function call, or whether it was taken by an argument to the program, so I used the exclamation mark as the function identifier to save a couple of spaces.</p>

<pre><code>0!a=a
i!a=(i-1)![sum$take j a|j&lt;-[1..length a]]
</code></pre>

<p>Usage (GHCi):</p>

<pre><code>$ ghci partialsums.hs
GHCi, version 7.6.3: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
[1 of 1] Compiling Main             ( partialsums.hs, interpreted )
Ok, modules loaded: Main.
*Main&gt; 1![-3, 4 ,7 ,-1 ,15]
[-3,1,8,7,22]
*Main&gt; 3![-3, 4 ,7 ,-1 ,15]
[-3,-5,1,14,49]
</code></pre>
</div>
<div id="pu39" class="pu"><h1>CJam, 13 bytes</h1>

<pre><code>q~{{1$+}*]}*p
</code></pre>

<p><a href="http://cjam.aditsu.net/#code=q~%7B%7B1%24%2B%7D*%5D%7D*p&amp;input=%5B-3%204%207%20-1%2015%5D%203" rel="nofollow">Test it here.</a></p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/61321/">61321</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




