<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::109248</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>081</td><td>YASEPL</td><td>240326T190225Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/272103#272103">madeforl</a></td></tr>
<tr d-ix="1"><td>058</td><td>Swift</td><td>240314T150324Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/271806#271806">macOSist</a></td></tr>
<tr d-ix="2"><td>nan</td><td></td><td>221007T154932Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/252791#252791">bigyihsu</a></td></tr>
<tr d-ix="3"><td>nan</td><td>Python</td><td>210915T145634Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/235340#235340">Larry Ba</a></td></tr>
<tr d-ix="4"><td>027</td><td>///</td><td>210515T230903Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/225738#225738">nph</a></td></tr>
<tr d-ix="5"><td>182</td><td>CLCINTERCAL</td><td>210916T084331Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/235408#235408">user1004</a></td></tr>
<tr d-ix="6"><td>021</td><td>APL Dyalog Extended</td><td>200928T085417Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/211728#211728">rak1507</a></td></tr>
<tr d-ix="7"><td>016</td><td>Vyxal</td><td>210915T015057Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/235326#235326">lyxal</a></td></tr>
<tr d-ix="8"><td>018</td><td>><></td><td>210915T033756Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/235328#235328">Bubbler</a></td></tr>
<tr d-ix="9"><td>028</td><td>Julia 0.7</td><td>210505T102129Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/225121#225121">MarcMush</a></td></tr>
<tr d-ix="10"><td>029</td><td>Vim</td><td>210504T195104Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/225076#225076">DLosc</a></td></tr>
<tr d-ix="11"><td>047</td><td>Scala</td><td>201014T113929Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/213511#213511">Tomer Sh</a></td></tr>
<tr d-ix="12"><td>041</td><td>R</td><td>180421T181525Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/163030#163030">Giuseppe</a></td></tr>
<tr d-ix="13"><td>017</td><td>Bash + Unix utilities</td><td>170206T093349Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109258#109258">Mitchell</a></td></tr>
<tr d-ix="14"><td>037</td><td>Python 2</td><td>200502T162607Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/204227#204227">Surculos</a></td></tr>
<tr d-ix="15"><td>069</td><td>Rust macros</td><td>200502T160107Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/204225#204225">corvus_1</a></td></tr>
<tr d-ix="16"><td>011</td><td>GolfScript</td><td>200109T100803Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/197844#197844">user8505</a></td></tr>
<tr d-ix="17"><td>050</td><td>Wren</td><td>200109T085014Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/197841#197841">user8505</a></td></tr>
<tr d-ix="18"><td>011</td><td>Japt</td><td>180517T024339Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/164942#164942">Bubbler</a></td></tr>
<tr d-ix="19"><td>042</td><td>C gcc</td><td>180421T160147Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/163024#163024">l4m2</a></td></tr>
<tr d-ix="20"><td>018</td><td>Vim + bc</td><td>180114T191738Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/153213#153213">Endenite</a></td></tr>
<tr d-ix="21"><td>042</td><td>Deorst</td><td>180114T181121Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/153211#153211">caird co</a></td></tr>
<tr d-ix="22"><td>020</td><td>Befunge98 PyFunge</td><td>170907T024321Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/141940#141940">MercyBea</a></td></tr>
<tr d-ix="23"><td>042</td><td>Cubically</td><td>170907T034338Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/141948#141948">Kamil Dr</a></td></tr>
<tr d-ix="24"><td>035</td><td>PHP 7.1</td><td>170206T091856Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109255#109255">aross</a></td></tr>
<tr d-ix="25"><td>031</td><td>sed</td><td>170208T233931Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109569#109569">Kevin</a></td></tr>
<tr d-ix="26"><td>048</td><td>F#</td><td>170212T225457Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109853#109853">Lukas Bo</a></td></tr>
<tr d-ix="27"><td>042</td><td>Python</td><td>170206T092434Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109257#109257">busukxua</a></td></tr>
<tr d-ix="28"><td>028</td><td>PowerShell</td><td>170212T194552Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109840#109840">briantis</a></td></tr>
<tr d-ix="29"><td>109</td><td>Java OpenJDK 8</td><td>170212T143625Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109815#109815">DmitrySa</a></td></tr>
<tr d-ix="30"><td>063</td><td>SmileBASIC</td><td>170211T231100Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109787#109787">12Me21</a></td></tr>
<tr d-ix="31"><td>7284</td><td>Brainfuck</td><td>170209T194904Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109621#109621">Rupert T</a></td></tr>
<tr d-ix="32"><td>074</td><td>JavaX</td><td>170210T190940Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109703#109703">Stefan R</a></td></tr>
<tr d-ix="33"><td>056</td><td>C</td><td>170210T213729Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109710#109710">aka.nice</a></td></tr>
<tr d-ix="34"><td>053</td><td>C</td><td>170206T170132Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109294#109294">Ahemone</a></td></tr>
<tr d-ix="35"><td>011</td><td>Pyth</td><td>170209T012551Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109572#109572">insert_n</a></td></tr>
<tr d-ix="36"><td>115</td><td>Brainfuck</td><td>170209T010748Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109571#109571">Ray</a></td></tr>
<tr d-ix="37"><td>042</td><td>Haskell</td><td>170207T175605Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109408#109408">minseong</a></td></tr>
<tr d-ix="38"><td>084</td><td>C#</td><td>170207T115843Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109382#109382">adrianmp</a></td></tr>
<tr d-ix="39"><td>020</td><td>Ruby</td><td>170207T080007Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109369#109369">G B</a></td></tr>
<tr d-ix="40"><td>013</td><td>Pyth</td><td>170208T022752Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109462#109462">ericmark</a></td></tr>
<tr d-ix="41"><td>nan</td><td>Ruby</td><td>170206T101413Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109263#109263">Value In</a></td></tr>
<tr d-ix="42"><td>081</td><td>Java 7</td><td>170207T050636Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109360#109360">Poke</a></td></tr>
<tr d-ix="43"><td>038</td><td>Python</td><td>170207T130305Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109384#109384">Jonathan</a></td></tr>
<tr d-ix="44"><td>232</td><td>Brainfuck  way to many bytes</td><td>170207T065703Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109363#109363">CodyCode</a></td></tr>
<tr d-ix="45"><td>024</td><td>Bean</td><td>170207T055303Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109362#109362">Patrick </a></td></tr>
<tr d-ix="46"><td>005</td><td>Jelly</td><td>170206T235859Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109345#109345">Jonathan</a></td></tr>
<tr d-ix="47"><td>031</td><td>RProgN</td><td>170207T001739Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109348#109348">ATaco</a></td></tr>
<tr d-ix="48"><td>077</td><td>IBM/Lotus Notes Formula</td><td>170206T145111Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109280#109280">ElPedro</a></td></tr>
<tr d-ix="49"><td>013</td><td>Retina</td><td>170206T222057Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109332#109332">Leo</a></td></tr>
<tr d-ix="50"><td>027</td><td>Haskell</td><td>170206T214848Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109323#109323">xnor</a></td></tr>
<tr d-ix="51"><td>008</td><td>Jelly</td><td>170206T211354Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109318#109318">user6213</a></td></tr>
<tr d-ix="52"><td>065</td><td>Haskell</td><td>170206T123424Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109267#109267">Laikoni</a></td></tr>
<tr d-ix="53"><td>011</td><td>CJam</td><td>170206T154745Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109286#109286">Martin E</a></td></tr>
<tr d-ix="54"><td>024</td><td>Befunge</td><td>170206T150832Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109283#109283">James Ho</a></td></tr>
<tr d-ix="55"><td>020</td><td>Perl</td><td>170206T143754Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109277#109277">Dada</a></td></tr>
<tr d-ix="56"><td>029</td><td>JavaScript ES6</td><td>170206T090711Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109250#109250">Arnauld</a></td></tr>
<tr d-ix="57"><td>062</td><td>Batch</td><td>170206T135005Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109272#109272">Neil</a></td></tr>
<tr d-ix="58"><td>039</td><td>Haskell</td><td>170206T130110Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109269#109269">Zgarb</a></td></tr>
<tr d-ix="59"><td>014</td><td>Retina</td><td>170206T090311Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109249#109249">Martin E</a></td></tr>
<tr d-ix="60"><td>023</td><td>Perl 6</td><td>170206T100032Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109262#109262">smls</a></td></tr>
<tr d-ix="61"><td>009</td><td>Grime</td><td>170206T095204Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109261#109261">Zgarb</a></td></tr>
<tr d-ix="62"><td>017</td><td>Mathematica</td><td>170206T090808Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109251#109251">Martin E</a></td></tr>
<tr d-ix="63"><td>009</td><td>05AB1E</td><td>170206T094347Z</td><td><a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109260#109260">Adnan</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/madeforlosers/YASEPL-esolang/" rel="nofollow noreferrer">YASEPL</a>, 81 bytes</h1>
<pre><code>=1'=s®1=i`1!m¥i,1ſ&quot;&quot;}7,exclamation,2!i+}2,s`2!1±m!3¥1,1®3}2,1,3!m$`3!3¥0,1®3+m%&lt;
</code></pre>
</div>
<div id="pu1" class="pu"><h1>Swift, 58 bytes</h1>
<pre class="lang-swift prettyprint-override"><code>let f={($0.last==&quot;0&quot; ?0:1)^($0+&quot;&quot;).prefix{$0&lt;&quot;0&quot;}.count%2}
</code></pre>
<p>Basically ended up being a port of <a href="https://codegolf.stackexchange.com/a/109257/118665">@busukxuan's Python answer</a>.</p>
</div>
<div id="pu2" class="pu">
<h1><a href="https://www.lexurgy.com/sc" rel="nofollow noreferrer">Lexurgy</a>, 47 bytes</h1>
<pre class="lang-awk prettyprint-override"><code>f:
{\0,\1} \!+=&gt;\1
e:
\!\!=&gt;*
g:
\! {\0,\1}=&gt;* {\1,\0}
</code></pre>
<h3>Explanation</h3>
<pre class="lang-awk prettyprint-override"><code># strip factorials
f:
{\0,\1} \!+=&gt;\1

# !!X = X
e:
\!\!=&gt;*

# apply !
g:
\! {\0,\1}=&gt;* {\1,\0}
</code></pre>
</div>
<div id="pu3" class="pu"><h1>Python, <del>183</del> <del>159</del> 125 bytes</h1>
<p><em>-34 bytes thanks to @wasif</em></p>
<p>Probably not going to beat anyone, but it was fun.</p>
<pre class="lang-python prettyprint-override"><code>g=lambda x:x&lt;2or x*f(~-x);from re import*;a,b,c=split(&quot;(\d+)&quot;,input())
exec(&quot;b=g(int(b));&quot;*len(c)+&quot;b=not b;&quot;*len(a));print(b)
</code></pre>
<p><a href="https://tio.run/##LYo7DgIhFAB7TwFU77FYqJ3ITWyAZVcSfkFMsPHqSKLFNDNT3u2R02WMXQUdzapJv/bbOVfS@QafY0e51RxJdcTHkmvjUgsjrHqW4BswuK8LMuFTeTVAPLjuLDCjdvCpgUGUjAeXwOIybcqNmL/Rs5X6u8aglJ4m9As" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu4" class="pu"><h1><a href="https://esolangs.org/wiki////" rel="nofollow noreferrer">///</a>, 27 bytes</h1>
<pre><code>/0!/1//!!///!1/0//!0/1//!//
</code></pre>
<p><a href="https://tio.run/##TYyxDYAwEAN7pogHQLYXYBcKJAq67K8nIZ@Ixvdv2a7PWe@rRlCgSYBNTDXVZ5Chsh9Fmzu8CYNOQkmPGEagHc5DWJXZQW4CniuYNawldPfvry9e" rel="nofollow noreferrer" title="/// – Try It Online">Try it online!</a></p>
</div>
<div id="pu5" class="pu"><h1><a href="https://esolangs.org/wiki/CLC-INTERCAL" rel="nofollow noreferrer">CLC-INTERCAL</a>, 182 bytes.</h1>
<p>The following source must be in Latin-1 or ISO-8859-1 encoding:</p>
<pre><code>DO;1&lt;-#1DO.9&lt;-.9/;1SUB#1DOCOMEFROM:9DO.8&lt;-&quot;¥'.8¢:9'&quot;~#1DOWRITEIN;1(1)DO:9&lt;-.9~#16DO.7&lt;-.9~#1DOWRITEIN;1DO.9&lt;-&quot;V'&quot;'¥&quot;'&quot;&amp;'&quot;'¥&quot;#1¢'.9~#4'&quot;'~#1&quot;¢.7'&quot;~#1'¢.8&quot;'~#1&quot;¢#100'&quot;~#5461DOREADOUT;1
</code></pre>
<h2>Assumed I/O</h2>
<ul>
<li>Uses standard input/output.</li>
<li>Input: a line of the text. Does not matter trailing LF.</li>
</ul>
<h2>How to try it online</h2>
<p><a href="http://golf.shinh.org/check.rb" rel="nofollow noreferrer">Try it online!</a> Because of encoding issue, I recommend uploading and submitting the source rather than copying and pasting the code to the form.
Also it may take very long time until the program ends.</p>
<h3>How to test</h3>
<p>Use the following shellscript:</p>
<pre class="lang-sh prettyprint-override"><code>#!/bin/sh
set -eu
cat&lt;&lt;'.' | awk 'BEGIN{ORS=&quot;&quot;}$0=(NR&gt;1?&quot;&quot;:RS)$0' | iconv -f UTF-8 -t ISO-8859-1 &gt;.i
DO;1&lt;-#1
DO.9&lt;-.9/;1SUB#1
DOCOMEFROM:9
DO.8&lt;-&quot;¥'.8¢:9'&quot;~#1
DOWRITEIN;1
(1)DO:9&lt;-.9~#16

DO.7&lt;-.9~#1
DOWRITEIN;1

DONOTE remove the following long line to uncomment four sentences that begin with &quot;DONOT.9&lt;-&quot; because it will result in timeout because of stupidly long expression.
DONOTE don't worry because they work equivalently.
DO.9&lt;-&quot;V'&quot;'¥&quot;'&quot;&amp;'&quot;'¥&quot;#1¢'.9~#4'&quot;'~#1&quot;¢.7'&quot;~#1'¢.8&quot;'~#1&quot;¢#100'&quot;~#5461

DONOT.9&lt;-.9~#4
DONOT.9&lt;-#1¢.9
DONOT.9&lt;-.¥9~#1
DONOT.9&lt;-&quot;V'&quot;'¥&quot;'&quot;&amp;'&quot;.9&quot;¢.7'&quot;~#1'¢.8&quot;'~#1&quot;¢#100'&quot;~#5461

DOREADOUT;1

.
wc -c .i &gt;&amp;2
sick .i
: &gt;o
while read p _ q; do
   o=&quot;$(
      printf %s &quot;$p&quot; |
      ./.io |
      tee -a o
      printf X
   )&quot;
   [ &quot;X$o&quot; = &quot;X${q}X&quot; ] &amp;&amp;
      printf &quot;%s: Passed\n&quot; &quot;$p&quot; &gt;&amp;2 ||
      printf &quot;%s: Failed\n&quot; &quot;$p&quot; &gt;&amp;2
done &lt;&lt;'.'
0 -&gt; 0
1 -&gt; 1
0! -&gt; 1
1! -&gt; 1
!0 -&gt; 1
!1 -&gt; 0
!0! -&gt; 0
!1! -&gt; 0
0!! -&gt; 1
1!! -&gt; 1
!!0 -&gt; 0
!!1 -&gt; 1
!0!! -&gt; 0
!!!1 -&gt; 0
!!!0!!!! -&gt; 0
!!!1!!!! -&gt; 0
.
cat o
</code></pre>
<h2>How it works</h2>
<pre><code>DONOTE ;1SUB#1 shall be these:
   '!' is #116
   '0' is #101
   '1' is #100
DONOTE actually first 16 bits are random bits
DONOTE that has at least a 1 bit 
DONOTE when WRITEIN is done
DONOTE then second 16 bits are the values above
DONOTE EOF is really #0
DONOTE otherwise at least 2^16

DO;1&lt;-#1 DONOTE for i/o
DO.9&lt;-.9/;1SUB#1 DONOTE replaces every .9 with ;1SUB#1

DOCOMEFROM:9 DONOTE it is from label 1
DO.8&lt;-&quot;¥'.8¢:9'&quot;~#1 DONOTE for fact
DOWRITEIN;1
(1)DO:9&lt;-.9~#16 DONOTE '!' is #116 others are #101 or #100

DO.7&lt;-.9~#1 DONOTE '0': 1, '1': 0

DOWRITEIN;1 DONOTE has trailing '!'?
DONOTE at this point .9 is '!': #116, EOF: #0, LF: #89

DONOTE explaining long expression

.9~#4                 #1 if .9&amp;0x04==0x04 else #0
'¥&quot;#1¢'...'&quot;'~#1      ^#1
&quot;&amp;'&quot;...&quot;¢.7'&quot;~#1      &amp;.7
'¥&quot;'...'¢.8&quot;'~#1      ^.8
&quot;V'&quot;...&quot;¢#100'&quot;~#5461 |#100


DO.9&lt;-&quot;V'&quot;'¥&quot;'&quot;&amp;'&quot;'¥&quot;#1¢'.9~#4'&quot;'~#1&quot;¢.7'&quot;~#1'¢.8&quot;'~#1&quot;¢#100'&quot;~#5461


DONOTE finally
DOREADOUT;1
<span class="math-container">```</span>
</code></pre>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/abrudz/dyalog-apl-extended" rel="nofollow noreferrer">APL (Dyalog Extended)</a>, 21 bytes</h1>

<pre class="lang-apl prettyprint-override"><code>⍎⌽'!(\d.*)'⎕R'\1~'⍣≡⍞
</code></pre>
<p>Repeatedly shift any !s to the right with the fixpoint ⍣≡</p>
<p>!!!!0! -&gt; !!!0!~ -&gt; !!0!~~ -&gt; !0!~~~ -&gt; 0!~~~~</p>
<p>Then reverse with ⌽, and execute with ⍎</p>
<p><a href="https://tio.run/##SyzI0U2pTMzJT9dNrShJzUtJTfn/qKM97f@j3r5HPXvVFTViUvS0NNUf9U0NUo8xrFN/1Lv4UefCR73zQMr@K4BBGpcBF4xlCGcZKCIEEUxFhFJFQyRRJBVIqg0UkQ1BUoNsjKIhAA" rel="nofollow noreferrer" title="APL (Dyalog Extended) – Try It Online">Try it online!</a></p>
</div>
<div id="pu7" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a>, 16 bytes</h1>
<pre><code>`\d!+`1øṙ\!\¬VṘĖ
</code></pre>
<p><a href="https://lyxal.pythonanywhere.com?flags=&amp;code=%60%5Cd!%2B%601%C3%B8%E1%B9%99%5C!%5C%C2%ACV%E1%B9%98%C4%96&amp;inputs=!!0&amp;header=&amp;footer=" rel="nofollow noreferrer">Try it Online!</a></p>
<p>We do a little regex.</p>
<h2>Explained</h2>
<pre class="lang-js prettyprint-override"><code>`\d!+`1øṙ\!\¬VṘĖ
`\d!+`            # The string &quot;\\d!+&quot; ( a regex that matches the digit followed by !)
      1øṙ         # and replace it with &quot;1&quot; (because 0! = 1! = 1)
         \!\¬V    # replace any remaining &quot;!&quot; with &quot;¬&quot; (not)
              ṘĖ  # then reverse and evaluate
</code></pre>
</div>
<div id="pu8" class="pu"><h1><a href="https://esolangs.org/wiki/Fish" rel="nofollow noreferrer">&gt;&lt;&gt;</a>, 18 bytes</h1>
<pre><code>ib%:?\
+2%n;\i+3=l
</code></pre>
<p><a href="https://tio.run/##S8sszvj/PzNJ1co@hkvbSDXPOiZT29g25/9/RUVFAyAGAA" rel="nofollow noreferrer" title="&gt;&lt;&gt; – Try It Online">Try it online!</a></p>
<p>Solved as part of <a href="https://chat.stackexchange.com/transcript/message/59147177#59147177">LYAL CMC</a>.</p>
<p>The basic idea is to process from left to right, doing the following:</p>
<ul>
<li>If the current char is <code>!</code> (boolean negation), keep it on the stack so that stack height can be used for negation count.</li>
<li>If the current char is <code>0</code> or <code>1</code>, take one more char and test if there's a factorial (modifying the number to 1 if there is). Apply negation, print as number, and halt.</li>
</ul>
<p>Optimizations:</p>
<ul>
<li><p>To get the final number, we can simply do <code>2%</code> at the end, which means we can just add the stack height + 1 (because the final stack height would be one more than the number of negations).</p>
</li>
<li><p>To discriminate between 48/49 and 33, we can do <code>b%</code> (modulo 11, <a href="https://chat.stackexchange.com/transcript/message/59147302#59147302">idea</a> by Jo King).</p>
</li>
<li><p>The (digit, factorial-or-EOF) combinations to handle are:</p>
<pre><code>(48, 33) -&gt; 1
(49, 33) -&gt; 1
(48, -1) -&gt; 0
(49, -1) -&gt; 1
</code></pre>
<p>We can use <code>48%11 = 4</code> and <code>49%11 = 5</code>. Then a simple way to handle these combinations is to check if the sum of two numbers is 3 or not. We could use &quot;is not 3&quot; for the condition, but it turns out that we can negate it and remove the extra <code>1+</code>.</p>
</li>
</ul>
</div>
<div id="pu9" class="pu"><h1><a href="http://julialang.org/" rel="nofollow noreferrer">Julia 0.7</a>, 28 bytes</h1>
<pre><code>~s=s[1]&lt;'0'?!~s[2:end]:s&gt;&quot;0&quot;
</code></pre>
<p><a href="https://tio.run/##LY7BCsIwDEDv@YokDLbdWi/CsPVDxg6CEyqljiW7SX@9tuolvPcOSZ5HDLdzKVmczHa59Ka/Upb5NK3pvkzi2XDRVVTQITODAQuGwBKQAbJ1VqpmqMXKLf96k0bU@G8N6hp8e5QtBgV4vHZUDAm/V2DbQ9KYBu4U0XnEbsg68gj1n/IB" rel="nofollow noreferrer" title="Julia 0.7 – Try It Online">Try it online!</a></p>
<p>called with <code>~&quot;!!0!&quot;</code>, returns <code>true</code> or <code>false</code></p>
<p>ungolfed:</p>
<pre><code>function f(s)
    if s[1] == '!'
        return !f(s[2:end])
    else
        return s&gt;&quot;0&quot;
    end
end
</code></pre>
<p><code>s&gt;&quot;0&quot;</code> is false only for <code>s==&quot;0&quot;</code></p>
</div>
<div id="pu10" class="pu"><h1><a href="https://www.vim.org" rel="nofollow noreferrer">Vim</a>, 29 bytes</h1>
<pre><code>:s/\d!!*\|1
A&lt;C-r&gt;=col('.')%2
&lt;esc&gt;d|
</code></pre>
<p><a href="https://tio.run/##K/v/36pYPyZFUVErpsaQy9HGWbfIzjY5P0dDXU9dU9WIyya1ONkupeb///@6ZQA" rel="nofollow noreferrer" title="V (vim) – Try It Online">Try it online!</a></p>
<h3>Explanation</h3>
<p>If we normalize the number-and-factorial part, we can get the answer by counting the number of characters on the line mod 2.</p>
<pre><code>:s/\d!!*\|1//&lt;cr&gt;
</code></pre>
<p>Substitute either 1) a digit followed by one or more <code>!</code>s or 2) a <code>1</code> digit with the empty string. (In the golfed version, the two final <code>/</code>s can be omitted.) This leaves a <code>0</code> if there was a lone <code>0</code> to begin with, and otherwise deletes the digit and everything after it.</p>
<pre><code>A
</code></pre>
<p>Go to the end of the line and append something. The cursor is now positioned one column after the last character on the line.</p>
<pre><code>&lt;C-r&gt;=col('.')%2&lt;cr&gt;
</code></pre>
<p>Calculate the column number mod 2 and insert that result (either 0 or 1).</p>
<pre><code>&lt;esc&gt;d|
</code></pre>
<p>Leave insert mode; the cursor is now on the just-inserted character. Delete everything to the left of the cursor.</p>
</div>
<div id="pu11" class="pu"><h1><a href="http://www.scala-lang.org/" rel="nofollow noreferrer">Scala</a>, <s>65</s> <s>63</s> 47 bytes</h1>

<pre class="lang-scala prettyprint-override"><code>s=&gt;s.takeWhile(34&gt;).length%2^(s.last-48).abs%14
</code></pre>
<p><a href="https://tio.run/##dZCxasMwEIZ3P8WdIWBT7OhaD6FgQ8YMmTJ0K8ipErsVqqlECIQ8u5vQUutcaRPHd5/@/@xeajl@tu9q72ArewPq7JR5s7AehktykhoOz7BzX705Qt3AxjioR1s3tnTyQ710vVbZU9XkpVbm6LrF42tmSy2tK6pVXsrWLqgah9u60yZLBRQNpPAAh9s7zXNYLu8TkfwR5BE0ETQRAn0JBhnyGQoz6IdBEWb8OEjBxDgF@jFhGCOOURgTyOvF@vGCkYa8IoYvjrwkUuRa7EtkyZhtpotdDe8K7vwdRb3/eZrzyXX8Bg" rel="nofollow noreferrer" title="Scala – Try It Online">Try it online!</a></p>
<p>Many thanks to <a href="https://codegolf.stackexchange.com/users/95792/user">user</a> for -16 chars!!!</p>
</div>
<div id="pu12" class="pu"><h1><a href="https://www.r-project.org/" rel="nofollow noreferrer">R</a>, 41 bytes</h1>

<pre class="lang-r prettyprint-override"><code>+eval(parse(t=gsub(&quot;\\d!+&quot;,1,scan(,&quot;&quot;))))
</code></pre>
<p><a href="https://tio.run/##K/r/Xzu1LDFHoyCxqDhVo8Q2vbg0SUMpJiZFUVtJx1CnODkxT0NHSUkTCP4b/AcA" rel="nofollow noreferrer" title="R – Try It Online">Try it online!</a></p>
<p>Two and a half years later, finally fixed the bug pointed out by <a href="https://codegolf.stackexchange.com/users/80010/jayce">JayCe</a>, by switching <code>*</code> in the regex to a <code>+</code>...</p>
<p>The <code>+</code> is just to coerce the <code>logical</code> to <code>numeric</code>.</p>
</div>
<div id="pu13" class="pu"><h1><a href="https://www.gnu.org/software/bash/" rel="nofollow noreferrer">Bash</a> + Unix utilities, <s>21</s> 17 bytes</h1>



<pre class="lang-bash prettyprint-override"><code>sed s/.!!*$/1/|bc
</code></pre>

<p><a href="https://tio.run/##TY6xCoMwGIT3PMUlWIQWTDIW1K1d@wwatTpoJLGQwXdPTdKWLsfd99/B3zZ29KrZUK9GP00zoyzZ7XFn3vYdLC8oPWdc8r1V/sCEqHHWHV4Xh4J/JmTQBg7TAgGJXNAcuQxCRRAZXcyRCpoKkaTKt5NQSjTkH4mWAJ0@BFjNtGwD2OlqUdVgAMsci6dejRqZw/73YNgtvX8D" rel="nofollow noreferrer" title="Bash – Try It Online">Verify the test cases online!</a></p>

<p><em>Added a TIO link to the test suite.</em></p>

<p>This must be saved in a file and run as a program.  If you try to enter the command directly from the command line, it won't work because !! is expanded due to history substitution being enabled in bash's interactive mode.  (Alternatively, you can turn history substitution off with <code>set +H</code>.)</p>
</div>
<div id="pu14" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>, 37 bytes</h1>



<pre class="lang-python prettyprint-override"><code>f=lambda s:s&lt;"0"and 1-f(s[1:])or"0"&lt;s
</code></pre>

<p><a href="https://tio.run/##TY3NisMwDITvfgrJJ4ckxd5jaPoipQeXNKwhcYxkCn36rLz5oacZjb8Zp0/@XeLPuo795Ofn4IE7vmqrfRzAtaPhu@se1UISXXkNc1ooA39YqXEhmEJ8QYgluHAeQuwUADfgI0MPs0@GM8kLhdT8wxdOU8hGtzddVcJu4OvtJyO2JCR3Lf8WnyjEXPYK3wCJueta5gz1feFr/dCrhfYGVrkiTlnc1O2Kdle3YbgBYtxuLJ6Vo4P7JqI7VvCo4bmEJf3Oz@sP" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>

<p>Sometimes returns <code>True/False</code> instead of <code>0/1</code>, which is allowed I think.</p>

<p><strong>How</strong>  </p>

<ul>
<li>The factorial part can be evaluated simply as <code>"0"&lt;s</code>. This is 0 only when <code>s</code> is 0, and 1 if <code>s</code> is anything else (e.g <code>1</code> or <code>0!!</code>).  </li>
<li>The negation part is evaluated using recursion. If <code>s</code> starts with <code>!</code> (<code>s&lt;"0"</code>), recurs as <code>1-f(s[1:])</code>.</li>
</ul>
</div>
<div id="pu15" class="pu"><h1>Rust macros, 69 bytes</h1>

<pre class="lang-rust prettyprint-override"><code>macro_rules!f{(!$($x:tt)*)=&gt;{1-f!($($x)*)};(0)=&gt;{0};($($x:tt)*)=&gt;{1}}
</code></pre>

<p>Defined a macro f that takes a sequence of tokens (including <code>!</code>, <code>0</code> and <code>1</code>) as input and produces a token sequence that evaluates to the expected result. Port of a <a href="https://codegolf.stackexchange.com/a/109267/46901">Haskell answer</a>.</p>

<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;code=macro_rules!f%7B%0A%20%20%20%20(!%24x%3Att)%3D%3E%7B1-f!(%24x)%7D%3B%0A%20%20%20%20(0)%3D%3E%7B0%7D%3B%0A%20%20%20%20(%24(%24x%3Att)*)%3D%3E%7B1%7D%0A%7D%0Afn%20main()%20%7B%0A%20%20%20%20assert_eq!(0%2C%20f!(0))%3B%0A%20%20%20%20assert_eq!(1%2C%20f!(1))%3B%0A%20%20%20%20assert_eq!(1%2C%20f!(0!))%3B%0A%20%20%20%20assert_eq!(1%2C%20f!(1!))%3B%0A%20%20%20%20assert_eq!(1%2C%20f!(!0))%3B%0A%20%20%20%20assert_eq!(0%2C%20f!(!0!))%3B%0A%7D" rel="nofollow noreferrer">try it online</a></p>

<h2>Explanation</h2>

<pre class="lang-rust prettyprint-override"><code>macro_rules! f {
    (! $($x:tt)*) =&gt; {  // match an exclamation mark followed by any number of token trees
        1 - f!($($x)*)  // expand to 1- and call the macro recursively
    };    
    (0) =&gt; {            // match a 0 that's not followed by anything
        0               // replace with a 0
    };
    ($($x:tt)*) =&gt; {    // match any number of token trees
        1               // replace with 1
    }
}
</code></pre>
</div>
<div id="pu16" class="pu"><h1><a href="http://www.golfscript.com/golfscript/" rel="nofollow noreferrer">GolfScript</a>, 11 bytes</h1>

<p>Blatant port (not copying the whole algorithm) of <a href="https://codegolf.stackexchange.com/a/109286/85052">Martin Ender's CJam answer</a>. At least I got the same length.</p>

<pre><code>.)\;48=!\~;
</code></pre>

<p><a href="https://tio.run/##S8/PSStOLsosKPn/X08zxtrEwlYxps76/38DRQA" rel="nofollow noreferrer" title="GolfScript – Try It Online">Try it online!</a></p>

<h2>Explanation</h2>

<pre><code>.           # Add a fresh copy of the input
 )          # Generate the input without the last item 
            # and the last item of the input
  \         # Swap so that the first output of ) is on top
   ;        # Remove so that there is only the last item
    48=     # Is the item equal to 48 (ASCII '0') ?
       !    # If not (0), there are !'s before either 0 or 1
            # and the result is obviously 1 (0 negated)
            # If yes (1), the last item is going to be 0,
            # and the result is 0 (1 negated).
        \   # Take the fresh unused copy of the input to the top
         ~  # Apply the input to the top
          ; # (Due to postfix evaluation the trailing
            # !'s are applied to the number.)
            # Discard the applied number, which is garbage

# Implicitly output the result
<span class="math-container">```</span>
</code></pre>
</div>
<div id="pu17" class="pu"><h1><a href="https://github.com/munificent/wren" rel="nofollow noreferrer">Wren</a>, 50 bytes</h1>

<pre><code>Fn.new{|a|(a[-1]=="0"?1:0)^a.trimEnd("!").count%2}
</code></pre>

<p><a href="https://tio.run/##Ky9KzftfllikkFaal6xgq/DfLU8vL7W8uiaxRiMxWtcw1tZWyUDJ3tDKQDMuUa@kKDPXNS9FQ0lRSVMvOb80r0TVqPZ/cGVxSWquXnlRZkmqBsgcveTEnBygIkVFQyAGqtX8DwA" rel="nofollow noreferrer" title="Wren – Try It Online">Try it online!</a></p>
</div>
<div id="pu18" class="pu"><h1><a href="https://github.com/ETHproductions/japt" rel="nofollow noreferrer">Japt</a>, 11 bytes</h1>

<pre><code>+OxUe/\d!/1
</code></pre>

<p><a href="https://ethproductions.github.io/japt/?v=2.0a0&amp;code=K094VWUvXGQhLzE=&amp;input=LW0gWwoiMCIsCiIxIiwKIjAhIiwKIjEhIiwKIiEwIiwKIiExIiwKIiEwISIsCiIhMSEiLAoiMCEhIiwKIjEhISIsCiIhITAiLAoiISExIiwKIiEwISEiLAoiISEhMSIsCiIhISEwISEhISIsCiIhISExISEhISIKXQ==" rel="nofollow noreferrer">Try it online!</a></p>

<h3>How it works</h3>

<pre><code>+OxUe/\d!/1

   Ue        Apply recursive replace to input string...
     /\d!/1    which replaces digit+! to 1
 Ox          Eval the result as vanilla JS
+            Cast the result (String or Boolean) to Number
</code></pre>

<p>The idea is similar to <a href="https://codegolf.stackexchange.com/a/109250/78410">Arnauld's JS answer</a> though I came up with it independently.</p>
</div>
<div id="pu19" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C (gcc)</a>, 42 bytes</h1>



<pre class="lang-c prettyprint-override"><code>c;e(char*a){c=*a&lt;34?!e(a+1):*a-48|1[a]%2;}
</code></pre>

<p><a href="https://tio.run/##fU5BDoIwELz7im0NSVvBgHowovgQ9dC0RZvYakAPirwdqV5MdN3TzuzM7Khkr1Q3tF4dr9rAsr5oexofisFQm9J6A5o5DmHOlfWXktGohqSASG89jcHFYHoB71RumDrISkjeqJWQy@lsTQyTo4wvhExm80e2kbtokrddHwNOWs/Cco/hZRM3Ds0g/AkQBLj8hRysgKb0DUKXDzr7TacEkSM8QeJJhumxIOxDStBKWBRa6k8rNAv1kOD65/u6tt0T" rel="nofollow noreferrer" title="C (gcc) – Try It Online">Try it online!</a></p>
</div>
<div id="pu20" class="pu"><h1>Vim + <code>bc</code>, 18 bytes</h1>

<pre><code>:s/\d!\+/1␊V!bc␊
</code></pre>

<p><code>␊</code> is a literal newline</p>

<h2>Explanation</h2>

<pre>
:s/\d!\+/1␊  Replace any digit followed by factorials with 1 ("0!!!" -> "1"; "1!!" -> "1")
V!bc␊        Evaluate the not-operators using the `bc` command, similarly to <a href="https://codegolf.stackexchange.com/a/109258/70894">this answer</a>
</pre>

<hr>

<h1>Vim, 36 bytes</h1>

<pre><code>:s/\d!\+/1␊:s/!!//g␊:s/!1/0␊:s/!0/1␊
</code></pre>

<p><code>␊</code> is a literal newline</p>

<h2>Explanation</h2>

<pre><code>:s/\d!\+/1␊  Replace any digit followed by factorials with 1 ("0!!!" -&gt; "1"; "1!!" -&gt; "1")
:s/!!//g␊    Remove all double nots ("!!!!!" -&gt; "!"; "!!!!!!" -&gt; "")
:s/!1/0␊     Replace !1 with 0
:s/!0/1␊     Replace !0 with 1
</code></pre>
</div>
<div id="pu21" class="pu"><h1><a href="https://github.com/cairdcoinheringaahing/Deorst" rel="nofollow noreferrer">Deorst</a>, 42 bytes</h1>

<pre><code>o1:ER'[01]!+'gs''p@
'(!!)+'gst!0gso0@t!1gs
</code></pre>

<p><a href="https://tio.run/##S0nNLyou@f8/39DKNUg92sAwVlFbPb1YXb3AgUtdQ1FRE8QrUTRIL843cChRNEwv/v//v7qioqIBECuqAwA" rel="nofollow noreferrer" title="Deorst – Try It Online">Try it online!</a></p>

<p>Regex based solution. Input must be quoted (<code>'0'</code>)</p>

<h2>How it works</h2>

<p>Example input: <code>'!!!0!!!!'</code></p>

<pre><code>o1                     - Push '1';      STACK = ['!!!0!!!!', '1']
  :                    - Duplicate;     STACK = ['!!!0!!!!', '1', '1']
   ER                  - Reverse;       STACK = ['1', '1', '!!!0!!!!']
     '[01]!+'          - Push '[01]!+'; STACK = ['1', '1', '!!!0!!!!', '[01]!+']
             gs        - Regez replace; STACK = ['1', '!!!1']
               ''p     - Push '';       STACK = ['1', '!!!1', '']
                  @    - Swap;          STACK = ['1', '', '!!!1']
'(!!)+'                - Push '(!!)+';  STACK = ['1', '', '!!!1', '(!!)+']
       gs              - Regex replace; STACK = ['1', '!1']
         t!0           - Push '!0';     STACK = ['1', '!1', '!0']
            gs         - Regex replace; STACK = ['!1']
              o0       - Push '0';      STACK = ['!1', '0']
                @      - Swap;          STACK = ['0', '!1']
                 t!1   - Push '!1';     STACK = ['0', '!1', '!1']
                    gs - Regex replace; STACK = ['0']
</code></pre>

<h2>Alternative, 27 bytes</h2>

<pre><code>t!1@t0$gs''p@
t!!gs'^\d'gcB
</code></pre>

<p><a href="https://tio.run/##S0nNLyou@f@/RNHQocRAJb1YXb3AgatEURHIiotJUU9Pdvr//7@6gToA" rel="nofollow noreferrer" title="Deorst – Try It Online">Try it online!</a></p>

<p>Requires input to be quoted (<code>'0'</code>). Based on <a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109332#109332">Leo's Retina answer</a></p>

<h2>How it works</h2>

<pre><code>t!1           - Push '!1';         STACK = ['!!!0!!!!', '!1']
   @          - Swap;              STACK = ['!1', '!!!0!!!!']
    t0$       - Push '0$';         STACK = ['!1', '!!!0!!!!', '0$']
       gs     - Regex replace;     STACK = ['!!!0!!!!']
         ''p  - Push empty string; STACK = ['!!!0!!!!', '']
            @ - Swap;              STACK = ['', '!!!0!!!!']
t!!           - Push '!!';         STACK = ['', '!!!0!!!!', '!!']
   gs         - Regex replace;     STACK = ['!0']
     '^\d'    - Push '^\d';        STACK = ['!0', '^\d']
          gcB - Count occurrences; STACK = [0]
</code></pre>
</div>
<div id="pu22" class="pu"><h1><a href="https://pythonhosted.org/PyFunge/" rel="nofollow noreferrer">Befunge-98 (PyFunge)</a>, <s>22</s> 20 bytes</h1>
<p>Golfed off 2 bytes because I realized that if I used <code>k</code> instead of <code>j</code> to do the logical notting to account for a 0 without a factorial, I didn't have to mod the ASCII value of 0 or 1 by 2. I did have to move the code because removing the <code>2%</code> left a hole between the <code>$~</code> and <code>#&lt;</code> previously.</p>
<pre><code>-kv$!~:'!
#&lt;k!.@.$$~
</code></pre>
<p><a href="https://tio.run/##S0pNK81LT9W1tNAtqAQz///XzS5TUayzUlfkUrbJVtRz0FNRqfv/X1FR0QCIFQE" rel="nofollow noreferrer" title="Befunge-98 (PyFunge) – Try It Online">Try it online!</a></p>
<h3>Explanation</h3>
<p>The first line:</p>
<pre><code>-kv$         Does nothing because the top of the stack is 0
    !        Nots the top, so we start with a value of 1
     ~       Gets a character from input
-     :'!    Pushes (that character - the value of '!')
 kv          If that value is not 0 (the character was not '!'), go to the next line
   $!        If it is, Throw away the extra '!' and not the number below it (originally 1)
             Repeat from the ~
</code></pre>
<p>Now that we're on the second line, we have notted 1 for each <code>!</code> before the number. If there is a <code>!</code> after the number, we can just print this value, but if there isn't we need to adjust for whether or not the number is 0.</p>
<p>The second line:</p>
<pre><code> &lt;            Directs the IP left.
#             Doesn't skip anything because it's at the beginning of a line
         ~    If we reached EOF (no factorials), the ~ will reverse the IP's direction
       $$     No EOF: Drop the '!' we just read along with the number
     @.               Print (1 notted the appropriate amount of times) and end
#&lt;            EOF: Wrap around and skip the arrow
  k!               Not the top n + 1 times, where n is the ASCII value of 0 or 1 (48 or 49)
                       If the number is 1, it will be notted 50 times (even),
                       yielding no change.
                       If the number is 0, we not it 49 times (odd), which makes up for
                       starting with a 1 at the beginning.
    .@             Print this value and exit
</code></pre>
</div>
<div id="pu23" class="pu"><h1><a href="https://github.com/aaronryank/cubically" rel="nofollow noreferrer">Cubically</a>, 42 bytes</h1>

<pre><code>UD3(L2~:7=3)6+13=7!6{&lt;0%6&amp;}~:7=3?6L2-6=0%6
</code></pre>

<p><a href="https://tio.run/##Sy5NykxOzMmp/P8/1MVYw8eozsrc1ljTTNvQ2NZc0azaxkDVTK0WLGhv5mOka2YLFPj/X1FR0VARAA" rel="nofollow noreferrer" title="Cubically – Try It Online">Try it online!</a></p>

<p>For some unknown reason it exits with an error when the digit is <code>1</code>, but it outputs the correct result regardless. The following is my basic algorithm:</p>

<ol>
<li>Start with 0</li>
<li>Invert for each <code>!</code></li>
<li>If digit is <code>1</code> invert again and output (any number of trailing <code>!</code> are irrelevant), ending the program</li>
<li>If there is a <code>!</code> after the digit, invert</li>
<li>Output (any further <code>!</code> are irrelevant)</li>
</ol>

<p>And a more thorough explanation:</p>

<pre><code>UD3                            Sets RIGHT to 33 and LEFT to 15

(L2~:7=3)6                     Flips TOP between 0 and 15 each time the input is ASCII 33 '!'

+13=7!6                        If the next character is NOT ASCII 15+33 '0':
       {&lt;0%6&amp;}                   output 1 if TOP is 15, 0 otherwise, then exit

~:7=3?6                        If the next character is ASCII 33 '!':
       L2                        flip TOP 

-6=0%6                         Output 1 if TOP is 0, 0 otherwise
</code></pre>
</div>
<div id="pu24" class="pu"><h1>PHP 7.1, <s>58</s> <s>55</s> <s>54</s> <s>37</s> 35 bytes</h1>

<p>Note: uses IBM-850 encoding</p>

<pre><code>echo!!$argn[-1]^strspn($argn,~Ì)%2;
</code></pre>

<p>Run like this:</p>

<pre><code>echo '!!!0!!!!' | php -nR 'echo!!$argn[-1]^strspn($argn,~Ì)%2;';echo
&gt; 0
</code></pre>

<h1>Explanation</h1>

<pre><code>echo
  strspn($a=$argv[1],~Ì) # Count the number of leading exclamation marks.
  % 2                    # Make 0 (even) or 1 (odd).
  ^ !!$a[-1];            # Negate with factorial part (truthy value of the 
                         # last char):
                         # - "0" is considered falsy.
                         # - "1" or "!" is considered truthy.
</code></pre>

<h1>Tweaks</h1>

<ul>
<li>Saved 3 bytes by using IBM-850 encoding</li>
<li>Saved a byte by changing the regex slightly</li>
<li>Saved 17 bytes, new version without long function names and return</li>
<li>Saved 2 bytes by using <code>-R</code> (which makes <code>$argn</code> available)</li>
</ul>
</div>
<div id="pu25" class="pu"><h1>sed, <s>36</s> <s>33</s> 31 bytes</h1>
<p>Pure sed, no bc / shell utils. Works on GNU sed &lt; 4.3; 33 bytes on BSD and GNU 4.3+.</p>
<pre><code>s/.!!*$/1/
:
s/!0/1/
s/!1/0/
t
</code></pre>
<p>Straightforward enough if you're familiar with <code>sed</code>; commented for those who aren't:</p>
<pre><code># Since 0! == 1! == 1 and factorial has precedence, just collapse any trailing &quot;!&quot; 
s/.!!*$/1/
# Define an anonymous label
:
# Invert 0 if needed
s/!0/1/
# Invert 1 if needed
s/!1/0/
# If a change was made, go back to the anonymous label.
t
</code></pre>
<p>Test:</p>
<pre><code>% cat 109248.sed
s/.!!*$/1/
:l
s/!0/1/
s/!1/0/
tl
% wc -c 109248.sed
      33 109248.sed
% cat cases
0
1
0!
1!
!0
!1
!0!
!1!
0!!
1!!
!!0
!!1
!0!!
!!!1
!!!0!!!!
!!!1!!!!
% sed -f 109248.sed cases
0
1
1
1
1
0
0
0
1
1
0
1
0
0
0
0
% gsed -f 109248.sed cases
0
1
1
1
1
0
0
0
1
1
0
1
0
0
0
0
%
</code></pre>
</div>
<div id="pu26" class="pu"><h1>F#, <s>69</s> 48 Bytes</h1>



<pre class="lang-fs prettyprint-override"><code>let rec f=function|'!'::t-&gt;1-f t|'0'::[]-&gt;0|_-&gt;1
</code></pre>

<p><strong><a href="https://dotnetfiddle.net/2dhn2C" rel="nofollow noreferrer">Try it online!</a></strong></p>

<h3>Tests</h3>

<pre class="lang-fs prettyprint-override"><code>let test (input,expected) = 
  let result = input |&gt; Seq.toList |&gt; f
  if result = expected then
    printfn "%s = %d" input result
  else
    printfn "Error at %s" input

[
  ("0", 0)
  ("1", 1)
  ("0!", 1)
  ("1!", 1)
  ("!0", 1)
  ("!1", 0)
  ("!0!", 0)
  ("!1!", 0)
  ("0!!", 1)
  ("1!!", 1)
  ("!!0", 0)
  ("!!1", 1)
  ("!0!!", 0)
  ("!!!1", 0)
  ("!!!0!!!!", 0)
  ("!!!1!!!!", 0)
] |&gt; Seq.iter test
</code></pre>
</div>
<div id="pu27" class="pu"><h1>Python, <s>-44-</s> 42 bytes</h1>

<p>Saved 2 bytes thanks to Zgarb!</p>

<pre class="lang-python prettyprint-override"><code>lambda x:(x[-1]=='0')^len(x.rstrip('!'))%2
</code></pre>

<p>Step by step:</p>

<ol>
<li><code>x[-1]!='0'</code><br>
if <code>x</code> ends with <code>1</code> or <code>!</code> ⇔ <code>x</code> doesn't end with <code>0</code>, the factorial portion must have value <code>1</code>, else <code>0</code></li>
<li><code>^len(x.rstrip('!'))%2</code><br>
exploit xor's property as a "conditional not". The condition in this case is if the length of initial <code>!</code>s is odd. However, <code>.rstrip</code> doesn't remove the number from the string so the length calculated is offset by 1, therefore the condition is inverted</li>
<li>The offset by 1 in step 2 is corrected by changing <code>!=</code> to <code>==</code> in step 1. Zgarb suggested using a difference comparison operator rather than applying another inversion, saving 2 bytes.</li>
</ol>

<p><a href="https://tio.run/nexus/python3#LYxBCsMgEEX3c4oxUBwJKdplqCcJLaSkgjAxQV3Y06fadBbDe2/xnaWD5/W1zFhGKtNgHtZKLdWT34HKNaYc/U5SSKUut0OBi9uK6ZPQr/sWM6a8@ABui8jow6kjYD22PI117yd79CFTHSNHrFTf4X3Armd1aDCgBRgBQoMw9VeqpkWLlVs@e5NGovHfGnwB" rel="nofollow noreferrer" title="Python 3 – TIO Nexus">Try it online!</a></p>
</div>
<div id="pu28" class="pu"><h1><a href="https://github.com/PowerShell/PowerShell" rel="nofollow noreferrer">PowerShell</a>, 28 bytes</h1>



<pre class="lang-powershell prettyprint-override"><code>+($args-replace'\d!+',1|iex)
</code></pre>

<p><a href="https://tio.run/nexus/powershell#@6@toZJYlF6sW5RakJOYnKoek6Kora5jWJOZWqH5//9/RUVFAyBWBAA" rel="nofollow noreferrer" title="PowerShell – TIO Nexus">Try it online!</a></p>

<h3>Explanation</h3>

<p>Replace any digit followed by 1 or more <code>!</code> with <code>1</code> (to solve the factorials), then just execute the remaining string which is valid code. The result will be boolean so I use unary <code>+</code> to convert it to a number.</p>
</div>
<div id="pu29" class="pu"><h1><a href="http://openjdk.java.net/" rel="nofollow noreferrer">Java (OpenJDK 8)</a>, 109 bytes</h1>



<pre class="lang-java prettyprint-override"><code>s-&gt;{int l=s.length(),n=(l&gt;1?s.split("[01]")[0]:s).length();return l&lt;2?s:(l-n&lt;2&amp;&amp;s.charAt(n)&lt;'1')==n%2&gt;0?1:0;}
</code></pre>

<p><a href="https://tio.run/nexus/java-openjdk#RZBLj4MgFIX3/RVoMi0kLUGXPtNMZpaz6dK4IJYqDaKBayeN8bd3fI09i5vDxwHuRdZtYwDd@YPTDqSiZ2P404Y7qUGYGy8EqjlU37yAz@YqfhpA/Q6NssBBFujRyOuYkBpfwEhdUkoRN6Ula2zSciW1YASv8Yb/pcUvWg5nee8y94hcbyrMme1cnRk73uIXtOwwZ40tcA1uyZWua2cibzb7YWuI0Jq3@GVPST9Oj1RsqRK6hAqTo46xSrx0nKJVErCbMS93ScbywJItFRoBndFIRX5qA6xOOvL3e0uLipszYE2ig3cgcaw//ISlXsDC4fV@/NaYL15U@PK0IGradBAE7fgtoDQJ5yaH3fD6Aw" rel="nofollow noreferrer" title="Java (OpenJDK 8) – TIO Nexus">Try it online!</a></p>
</div>
<div id="pu30" class="pu"><h1>SmileBASIC, 63 bytes</h1>
<pre><code>INPUT S$WHILE&quot;#&quot;&gt;S$[0]N=!N
S$[0]=&quot;
WEND?(VAL(S$)||LEN(S$)&gt;1)!=N
</code></pre>
<p>I don't think this is the best way...</p>
</div>
<div id="pu31" class="pu"><h1>Brainfuck, <s>85</s> 72 (84) bytes</h1>

<pre><code>,[&gt;-[-----&lt;-&gt;]&lt;++[&gt;++++[-&lt;++++&gt;]+&lt;[[+],[[-]&gt;-&lt;]]]&gt;[&lt;&lt;+[--&gt;]&gt;[&lt;],&gt;-]&lt;]&lt;+.
</code></pre>

<p>to return numerically, or</p>

<pre><code>,[&gt;-[-----&lt;-&gt;]&lt;++[&gt;++++[-&lt;++++&gt;]+&lt;[[+],[[-]&gt;-&lt;]]]&gt;[&lt;&lt;+[--&gt;]&gt;[&lt;],&gt;-]&lt;]-[-----&lt;+&gt;]&lt;--.
</code></pre>

<p>for ASCII text. > may also be prefixed to avoid memory wrapping.</p>

<p><a href="https://tio.run/nexus/brainfuck#NYzRCcBADEJnyXfO0gHERcT9x0hzHxVEwYdzLBhXhMJuq1cGbyhNu3NsRGASmdx54W05Qpj/YXkCz0xVveuaDw" rel="noreferrer" title="brainfuck – TIO Nexus">Try it online!</a></p>

<hr>

<pre><code>Loops over the input.
On 1, ends.
On "!", toggles bool a stored as 0 or 255.
On "0", toggles if there is no trailing bit, then ends.

Memory labels  | BOOL | INPUT | FLAG |

,                   first input 
[                     # loop on INPUT
  &gt;-[-----&lt;-&gt;]&lt;++     subtract 49 == "1"

  [                     # case not "1"
    &gt;++++[-&lt;++++&gt;]      add 16 since 49 take 16 == "!"

    +                   set FLAG
    &lt;                   move to INPUT
    [                     # case "0"
      [+],                clear and new INPUT
      [                     # case "0!"
        [-]&gt;-&lt;              clear INPUT and FLAG
      ]
    ]
  ]

  &gt;                   move to FLAG
  [                     # case "!" or "0" without tail
    &lt;&lt;+[--&gt;]&gt;[&lt;]        not the BOOL
    ,                   take new input
    &gt;-                  clear FLAG
  ]
  &lt;                   move to INPUT
]

+.                    return 0 or 1
</code></pre>

<p>Or for text response, replace the last line with </p>

<pre><code>-[-----&lt;+&gt;]&lt;--.       add 49 for "0" or "1" conversion and return
</code></pre>
</div>
<div id="pu32" class="pu"><h1><a href="http://javax.ai1.lol" rel="nofollow noreferrer">JavaX</a>, <strike>77</strike> 74 bytes</h1>

<pre><code>!7p{print(repeatMultiReplace3(args[0],splitAtSpace("0! 1 1! 1 !0 1 !1 0";}
</code></pre>

<p>Run with, e.g.: " java -jar <a href="http://tinybrain.de/x30.jar" rel="nofollow noreferrer">x30.jar</a> <a href="http://tinybrain.de/1006862" rel="nofollow noreferrer">1006862</a> '!0' "</p>
</div>
<div id="pu33" class="pu"><h1>C, 56 bytes</h1>



<pre class="lang-c prettyprint-override"><code>c=1;f(char*a){c=-c;*a&amp;16?c+=1-*a-1[a],c&amp;=2,c/=2:f(a+1);}
</code></pre>

<p>Hint: only the last two bits count.</p>

<p>The basic idea was to use least significant bit for storing result of factorial, and next bit for storing the negation, then xoring the two.</p>

<pre class="lang-c prettyprint-override"><code>c=0;
for(;*a&lt;34;a++)c^=2; // invert the 2nd bit at each negation
while(*a)c|=*a++; // '0' ends with bits 00, '1' and '!' ends with bits 01, so this OR will let the first bit to resut of factorial (LSB) and leave the 2nd bit unchanged
c=((c&gt;&gt;1)^c)&amp;1; // apply the negation (2nd bit) on the factorial (1st bit)
</code></pre>

<p>But it makes our intentions too clear. First, we don't need a loop for the factorial, and we can allways take 2 char, the 2nd being eventually a NULL terminator will have neutral 00 end bits. This is much like the answer <a href="https://codegolf.stackexchange.com/questions/109248/mathematics-is-fact-programming-is-not/109294#109294">Mathematics is fact. Programming is not</a> from Ahemone, but longer and less elegant so far.</p>

<pre class="lang-c prettyprint-override"><code>c=0;
while(*a++&lt;34)c^=2; // invert the 2nd bit at each negation
c|=*a,c|=*--a; // '0' and NULL ends with bits 00, '1' and '!' ends with bits 01, so this OR will let the first bit to resut of factorial (LSB) and leave the 2nd bit unchanged
c=((c&gt;&gt;1)^c)&amp;1; // apply the negation (2nd bit) on the factorial (1st bit)
</code></pre>

<p>C isn't going to win anyway, so let's trade some golf for some obfuscation: replace the last expression with something else, assuming 2-complement: <code>-x == (~x+1)</code> and observe how the last two bits evolve</p>

<pre class="lang-c prettyprint-override"><code>- ...00 -&gt; ...11+1 -&gt; ...00
- ...01 -&gt; ...10+1 -&gt; ...11
- ...10 -&gt; ...01+1 -&gt; ...10
- ...11 -&gt; ...00+1 -&gt; ...01
</code></pre>

<p>We see that the LSB is unchanged via <code>c=-c</code>, and the 2nd bit becomes the xor of last two bits. So we can just pick this second bit with <code>c&gt;&gt;=1,c&amp;=1</code> or <code>c&amp;=2,c/=2;</code></p>

<p>Of course, the bit inversion <code>~x</code> is useless, just adding+1 has the same effect.<br>
But there is a reason behind it:<br>
what if we would replace the XOR flip/flop with negated op?<br>
at each neg -...01 becomes ...11 <em>et vice et versa</em><br>
If we then subtract 1, we have either ...00 or ...10 at the end of the loop.<br>
We are back to our original solution.</p>

<pre class="lang-c prettyprint-override"><code>c=1;
while(*a++&lt;34)c=-c;
c-=1;
c|=*a,c|=*--a;
c=-c;
c&amp;=2,c/=2;
</code></pre>

<p>And let's see what happens if we add the factorial bit instead of ORing:</p>

<p>...00 becomes 00 or 01 or 10 in case of <code>'0'</code> , <code>'0!'||'1'</code> , <code>'1!'</code>.<br>
...10 becomes 10 or 11 or 00.<br>
So using <code>+</code> gives the same parity than <code>|</code> on last two bits, even if we accidentally add a bit twice du to <code>'1!'</code> case.</p>

<p>Now we just have to roll the final c-=c inside the loop, and replace the + by - for getting our obfuscated solution.</p>

<p>Ah and also use recursion to take a functional style disguise, but of course with non reentrant, ugly static variable assignment side effect, else there would be no "<em>advantage</em>" to code in C ;)</p>
</div>
<div id="pu34" class="pu"><h1>C, <strike>68</strike> <strike>62</strike> <strike>61</strike> 53 bytes</h1>



<pre class="lang-c prettyprint-override"><code>c;e(char*a){for(c=1;*a&lt;34;a++)c^=1;c=a[1]?c:*a&amp;1^!c;}
</code></pre>

<p>Squeezed out a few more bytes with some abuse</p>

<p><a href="https://tio.run/nexus/c-gcc#fY7NDsIgEITvPsXSRgNYTYmexNYH8SchQFMSoabVgxqfvRa9mOjKiZmd/XZSF/TxYiysu7NxzbwuR6mxlQsWDPUM4ju1Lpwrmow7mJUwNruQZOAzsEOA9VpaqmvVcsXuVdNSXQjJ1XqxlGo6ZfowSF2ordhv9IqriTgQLR/9QASvXKDxc8vgReBXBvdRPBklcPDypTwUkOTJW8RaH7b4becEiSM@QfBEYHkMhF3ICVoJQ6Gl/rRCWegOiVv/9r6mj/4J" rel="nofollow noreferrer" title="C (gcc) – TIO Nexus">Try it online!</a></p>
</div>
<div id="pu35" class="pu"><h1>Pyth, 11 bytes</h1>

<pre><code>s.v:z"0!"\1
</code></pre>

<p><a href="http://pyth.herokuapp.com/?code=s.v%3Az%220%21%22%5C1&amp;input=%21%21%210%21%21%21%21&amp;debug=0" rel="nofollow noreferrer">Try it online!</a></p>

<h3>Explanation</h3>

<pre><code>s.v:z"0!"\1
   :         Replace...
    z        in the input...
     "0!"    the string "0!"...
         \1  with the string "1".
 .v          Evaluate the result. Since only the first expression is evaluated,
             anything after the number will be ignored.
s            Convert the result to an integer and implicitly print it.
             This is necessary because ! returns True/False, not 0/1.
</code></pre>
</div>
<div id="pu36" class="pu"><h1>Brainfuck, 115 bytes</h1>

<pre><code>&gt;,[-&gt;++++[&lt;--------&gt;-]&lt;[---------------&gt;,[&lt;[-]+&gt;-]&lt;&lt;[-&gt;-[&gt;+&lt;+]&gt;[-&lt;+&gt;]&lt;&lt;]&gt;&gt;++++++[-&lt;++++++++&gt;]&lt;.&gt;&gt;+&lt;]&gt;-[&lt;&lt;+&gt;,&gt;[-]]&lt;]
</code></pre>

<p><a href="https://tio.run/nexus/brainfuck#VYxBCsBADALfknPWQu/iR4L/f8bWlr10IBBGcWsN1GGIg2AO/qQW536zPMKo2daArSjrG8lMxCH@ik6GYWorbZveu6ruXD0" rel="nofollow noreferrer" title="brainfuck – TIO Nexus">Try it online!</a></p>

<h2>Ungolfed:</h2>

<pre><code>% 0: inverter count
% 1: result
% 2: if/else flag; tmpspace in inner loop 0

&gt;1,[
    -&gt;2++++[&lt;--------&gt;-]&lt;1 subtract 33 (!)
    [ 
        % we've reached the number
        ---------------
        % now it's either 0 or 1

        % check next char; If it's not 0 then it's '!'
        % 0! = 1! = 1!...! so we only need to determine if at least one ! exists
        &gt;2,
                [&lt;[-]+&gt;-]&lt;1

        % apply inversions
        &lt;0
        [-&gt;1
            % invert cell 1 once each iteration
                       % cell 1 is 0 or 1
            -          % cell 1 is 255 or 1
            [&gt;+&lt;+]     % cell 1 is 0; cell 2 is 1 iff cell 1 should be 1
            &gt;2[-&lt;+&gt;]&lt;1 % cell 1 is 1 or 0
        &lt;0]

        % print result
        &gt;1&gt;++++++[-&lt;++++++++&gt;]&lt;1.

        &gt;&gt;2+&lt; % tape={0 r 0 1}
    ]
    &gt;2-[ % we haven't seen the number yet
        &lt;&lt;0+&gt;1,&gt;2 % add to inverter count
        [-]
    ]&lt;1
]
</code></pre>
</div>
<div id="pu37" class="pu"><h1>Haskell, 42</h1>

<p>There must be a better way to do this...</p>

<pre><code>f(h:t)|h=='!'=1-f t|h=='1'=1|t==[]=0|1&lt;2=1
</code></pre>
</div>
<div id="pu38" class="pu"><h1>C#, <strike>88</strike> 84 bytes</h1>
<p><em>Saved 4 bytes thanks to <a href="https://codegolf.stackexchange.com/users/38550/thelethalcoder">TheLethalCoder</a>.</em></p>
<pre><code>s=&gt;{var c=s.Replace(&quot;!&quot;,&quot;&quot;)[0];int b=s.IndexOf(c);return(s.Length&gt;++b?b:b+c-49)%2;};
</code></pre>
<p>Previous version:</p>
<pre><code>s=&gt;{var c=s.Replace(&quot;!&quot;,&quot;&quot;)[0];int b=s.IndexOf(c),n=s.Length-b&gt;1?1:c-48;return(n+b)%2;};
</code></pre>
<p>Full program with commented method and test cases:</p>
<pre><code>using System;

class MathIsFactProgrammingIsNot
{
    static void Main()
    {
        Func&lt;string, int&gt; f =
        s=&gt;
        {
            // removes all the exclamation marks and extracts the 0 or 1 digit
            var c = s.Replace(&quot;!&quot;,&quot;&quot;)[0];

            // number of exclamation marks before the digit
            int b = s.IndexOf(c),
            
            // the number of exclamation marks after the digit increased by 1 (because of the digit)
                n = s.Length - b &gt; 1 ? 1 : c-48;
            // if no exclamation marks are present, converts the digit from the string to an integer
            
            return (n + b) % 2;   // applies binary negation
        };

        // test cases:
        Console.WriteLine(f(&quot;0&quot;));  // 0
        Console.WriteLine(f(&quot;1&quot;));  // 1
        Console.WriteLine(f(&quot;0!&quot;)); // 1
        Console.WriteLine(f(&quot;1!&quot;)); // 1
        Console.WriteLine(f(&quot;!0&quot;)); // 1
        Console.WriteLine(f(&quot;!1&quot;)); // 0
        Console.WriteLine(f(&quot;!0!&quot;));    // 0
        Console.WriteLine(f(&quot;!1!&quot;));    // 0
        Console.WriteLine(f(&quot;0!!&quot;));    // 1
        Console.WriteLine(f(&quot;1!!&quot;));    // 1
        Console.WriteLine(f(&quot;!!0&quot;));    // 0
        Console.WriteLine(f(&quot;!!1&quot;));    // 1
        Console.WriteLine(f(&quot;!0!!&quot;));   // 0
        Console.WriteLine(f(&quot;!!!1&quot;));   // 0
        Console.WriteLine(f(&quot;!!!0!!!!&quot;));   // 0
        Console.WriteLine(f(&quot;!!!1!!!!&quot;));   // 0
    }
}
</code></pre>
</div>
<div id="pu39" class="pu"><h2>Ruby, <s>22 21</s> 20 bytes</h2>
<pre><code>-&gt;s{(s=~/!*$|0$/)%2}
</code></pre>
<p>Explanation:</p>
<ul>
<li>First case, I got some '!' at the end, remove them, get length modulo 2.</li>
<li>Second case, no '!', if last character is zero then remove it, get length modulo 2</li>
<li>If the last character is 1, back to the first case</li>
</ul>
<p>(-1 byte stealing @Value Ink's idea)</p>
</div>
<div id="pu40" class="pu"><h1>Pyth, 13 bytes</h1>

<h2>Code</h2>

<pre><code>s.v:z"\d!+""1
</code></pre>

<p>There may be a way to shave off a couple of bytes, but alas.</p>

<h2>Explanation</h2>

<pre><code>s                # Cast to an integer (Python's int()).
 .v              # Evaluate (Python's eval()). This handles the negations.
   :             # Regex substitution. The following three expressions are its arguments.
    z            # Argument 1: what to replace in. This is equal to the (unevaluated) input string.
     "\d!+"      # Argument 2: what to replace. This is a regex that matches a number followed by one or more !'s.
           "1    # Argument 3: what to replace to. The string "1" (ending quote not needed in Pyth).
</code></pre>

<p>You can check it out <a href="https://pyth.herokuapp.com/?code=s.v%3Az%22%5Cd%21%2B%22%221&amp;test_suite_input=0%0A1%0A0%21%0A1%21%0A%210%0A%211%0A%210%21%0A%211%21%0A0%21%21%0A1%21%21%0A%21%210%0A%21%211%0A%210%21%21%0A%21%21%211%0A%21%21%210%21%21%21%21%0A%21%21%211%21%21%21%21&amp;debug=0" rel="nofollow noreferrer">here</a> or run the test suite <a href="https://pyth.herokuapp.com/?code=s.v%3Az%22%5Cd%21%2B%22%221&amp;input=%210%21%21%21&amp;test_suite=1&amp;test_suite_input=0%0A1%0A0%21%0A1%21%0A%210%0A%211%0A%210%21%0A%211%21%0A0%21%21%0A1%21%21%0A%21%210%0A%21%211%0A%210%21%21%0A%21%21%211%0A%21%21%210%21%21%21%21%0A%21%21%211%21%21%21%21&amp;debug=0" rel="nofollow noreferrer">here</a>. I have no earthly idea how to (or if one actually can) use the test suite feature to run tests as opposed to just evaluating a bunch of inputs at once, but if someone else knows, I'm all ears.</p>
</div>
<div id="pu41" class="pu"><h1>Ruby, 12+1 = <s>39</s> <s>24</s> <s>15</s> 13 bytes</h1>
<p>Uses the <code>-n</code> flag. Thanks to <a href="https://codegolf.stackexchange.com/users/18535/g-b">@GB</a> for -9 bytes!</p>
<pre><code>p~/!*$|0$/%2
</code></pre>
</div>
<div id="pu42" class="pu"><h1>Java 7, <s>105</s> <s>82</s> 81 bytes</h1>

<pre><code>int a(char[]a){int b=0,c=0;for(;a[b++]&lt;34;c^=1);return(b&lt;a.length?1:a[b-1]&amp;1)^c;}
</code></pre>

<p><a href="https://tio.run/nexus/java-openjdk#lZDBisIwFEX3/YrExZDgGBJ0ZSyDzHpWLqXCa6waqGlJX2eQ0m/vRF0rvFUI3HfP4bZ9WXvHXA1dx37ABzZMPiAD4S4Q9wXI4f4tc/3pcm1PTRQW9uV8XmyWK@sOuZE2VtjHIMoNqLoKZ7x8mXXKLEzxYeTB2XFqn5QOAdPz2/gjuyaW2GH04ZwoUbIhe@CB5SxUfw8XIW22u3VYXVXTo2pTGOsgQIGY6ZnC5js5bmOEm5DyTdYQsppTiilhTlHmhtRM8iBZa04bhGRCm4S6CU2F1s7v/WTCi5MxG6d/" rel="nofollow noreferrer" title="Java (OpenJDK) – TIO Nexus">Try it online!</a></p>

<h3>Old regex-ish solution</h3>

<pre><code>int a(String a){a=a.replace("0!","1").replaceAll("1.*","1");int b=a.length()-1;return b%2^a.charAt(b)&amp;1;}
</code></pre>
</div>
<div id="pu43" class="pu"><h1>Python, 38 bytes</h1>

<pre class="lang-python prettyprint-override"><code>lambda s:(s[1::2]&gt;s[::2])^ord(s[-1])%2
</code></pre>

<p><strong><a href="https://tio.run/nexus/python3#RY3RCsMgDEWf51fow7BCB9pHof0RsdDRCYWtHcb/d0viupfknpMLqWl8Lq/7ukjwHQTn/RAnCLjMfOT1624umusgygMKjEFb3UvtcFhFkaYirRxnVnyxqtVYtuLZbLaxQvN3lKNIR5b4Xm47bfDi8s7bXjok84PEeLKp9QM" rel="noreferrer">TryItOnline!</a></strong></p>

<p>An unnamed function taking an input string <code>s</code> and returning an integer <code>0</code> or <code>1</code>.</p>

<p><code>s[1::2]</code> is a slice of the input string that starts at index 1 and has a step size of two:<br>
<code>'Like this' -&gt; 'ieti'</code></p>

<p><code>s[::2]</code> is similar but starts at the default index of 0:<br>
<code>'Like this' -&gt; 'Lk hs'</code></p>

<p>The test <code>(s[1::2]&gt;s[::2])</code> checks if the 0-based index of the <code>'0'</code> or <code>'1'</code> is odd, i.e. if we need to complement.<br>
This works because the ordering of strings is checked lexicographically with any non-empty string greater than the empty string, and with ASCII ordering, so <code>'1'&gt;'0'&gt;'!'</code>. This is a byte shorter than the simpler <code>s.index(max(s))%2</code>.</p>

<p>The <code>ord(s[-1])%2</code> checks to see if the last character is not a <code>'0'</code> (for valid input), and results in an integer (whereas the same length <code>(s[-1]!='0')</code> would return a boolean).<br>
This works because the last character of the input, <code>s[-1]</code>, will be a <code>'0'</code>, <code>'1'</code>, or <code>'!'</code> which have ASCII code points 48, 49, and 33 respectively, which are 0, 1, and 1 modulo 2.</p>

<p>The <code>^</code> then performs a bitwise exclusive or operation on the two above values, returning an integer since one input, the right one, is an integer. If the left is True the complement of the right is returned, if the left is False the right is returned, as required.</p>
</div>
<div id="pu44" class="pu"><h1>Brainfuck - way to many bytes (232 bytes)</h1>

<p>Clearly the wrong language for winning in code golf. Mainly I noticed a lack of anyone using this esolang. There is a good online interpreter <a href="https://sange.fi/esoteric/brainfuck/impl/interp/i.html">bf interpeter</a> or you can actually watch what the program does using this <a href="https://fatiherikli.github.io/brainfuck-visualizer/#">bf visualizer</a>.</p>

<pre><code>&gt;&gt;&gt;&gt;&gt;,[&gt;+++[&lt;----------------&gt;-]&lt;&lt;&lt;&lt;&lt;&lt;[-]+&gt;[-]&gt;&gt;&gt;&gt;[-[&lt;&lt;[&gt;+&lt;&lt;&lt;&lt;-&gt;&gt;&gt;[&lt;&lt;+&gt;&gt;-] ]&lt;&lt;[&gt;&gt;+&lt;&lt;-]&lt;[&gt;&gt;+&lt;&lt;[-]]&gt;&gt;&gt;&gt;&gt;[-]]&lt;&lt;&lt;&lt;&lt;[&gt;&gt;&gt;++&lt;&lt;&lt;-]&gt;+&gt;&gt;&gt;&gt;[-]]&lt;&lt;&lt;&lt;-[&gt;&gt;+&lt;&lt;[-]]&gt;&gt;&gt;&gt;,]&lt;&lt;-&gt;[&lt;[-]+&gt;[-]]&lt;&lt;[&lt;[-]&gt;&gt;[&lt;&lt;+&gt;&gt;[-]]+&lt;&lt;[-&gt;&gt;-&lt;&lt;]&gt;-]&gt;&gt;[-]+++[&lt;++++++++++++++++&gt;-]&lt;.
</code></pre>
</div>
<div id="pu45" class="pu"><h1><a href="https://github.com/patrickroberts/bean" rel="nofollow noreferrer">Bean</a>, 24 bytes</h1>

<p>Hexdump:</p>

<pre><code>00000000 26 4a c1 53 a0 17 53 d0 80 a0 5d 20 80 0a a1 80  &amp;JÁS .SÐ. ] ..¡.
00000010 81 00 25 3a ae a1 ab 24                          ..%:®¡«$
00000018
</code></pre>

<p>Equivalent JavaScript:</p>

<pre><code>+eval(a.replace(/.!+$/,1))
</code></pre>

<p>Sorry for stepping on your toes, <a href="https://codegolf.stackexchange.com/a/109250/42091">Arnauld</a>.</p>

<h3>Explanation:</h3>

<p>Takes first line of input as unformatted string in <code>a</code>, and replaces any digit followed by one or more <code>!</code> with <code>1</code>, so that the rest can be <code>eval</code>'d by JavaScript.</p>

<h3>Try the <a href="https://patrickroberts.github.io/bean/#h=JkrBU6AXU9CAoF0ggAqhgIEAJTquoask&amp;i=ITAh&amp;f=0&amp;w=1" rel="nofollow noreferrer">demo</a>, or the <a href="https://patrickroberts.github.io/bean/#h=JlPQgNPQgKB4IICIQKBdVc2gXYBKwVOgF1XN26BeoF8AgFPQgKBdIIANI4EAU9CAoF4ggAqhgIEBJTpT0IDDoF6jgQCgXaOBAsygXYAgXwAggHsjACCAeyOBA6CtviCuoaskIAo=&amp;i=MCAtPiAwCjEgLT4gMQowISAtPiAxCjEhIC0+IDEKITAgLT4gMQohMSAtPiAwCiEwISAtPiAwCiExISAtPiAwCjAhISAtPiAxCjEhISAtPiAxCiEhMCAtPiAwCiEhMSAtPiAxCiEwISEgLT4gMAohISExIC0+IDAKISEhMCEhISEgLT4gMAohISExISEhISAtPiAw&amp;f=0&amp;w=1" rel="nofollow noreferrer">test suite</a></h3>
</div>
<div id="pu46" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="noreferrer">Jelly</a>, 5 <a href="https://github.com/DennisMitchell/jelly/wiki/Code-page" rel="noreferrer">bytes</a></h1>
<pre><code>VeMḂ$
</code></pre>
<p><strong><a href="https://tio.run/nexus/jelly#@x@W6vtwR5PK/6N7Drc/alrzqHG7tXvk///RSgZKOkqGQGygCGKACEWQkKIhmAXmg0UNFCEKwCIQJTA1ECEITxHEh4uAmbEA" rel="noreferrer">Try it online!</a></strong></p>
<p>Monadic function expecting a string. Inputs with leading <code>!</code>s cause a <code>1</code> to be printed to STDOUT along the way, so the TIO link I give is a test harness that prints the input-output pairs beneath the first line of output.</p>
<h3>How?</h3>
<pre><code>VeMḂ$ - Monadic link: string
V     - eval the string
          - the implicit input of 0 causes !...! to evaluate to 1 (which gets printed),
          - the result is the evaluation of the rest: &quot;0&quot;=0; &quot;0!&quot;=1; &quot;1&quot;=1; &quot;1!&quot;=1; ...
 e    - exists in?
    $ - last two links as a monad:
  M   -     Maximal indexes - the &quot;0&quot; and &quot;1&quot; characters are greater than &quot;!&quot;,
                            - so this results in a list of one item [i] where
                            - i is the 1-based index of the 0 or 1 character.
   Ḃ  -     %2 (vectorises) - [i%2], so a 0 if we need to logically negate and a 1 if not
                            - hence we check equality with e rather than inequality.
</code></pre>
</div>
<div id="pu47" class="pu"><h1><a href="https://github.com/TehFlaminTaco/Reverse-Programmer-Notation" rel="nofollow noreferrer">RProgN</a>, 31 bytes</h1>

<pre><code>~'(!*1?)0?(!*)'{L`x=L2%x+0&gt;1*}R
</code></pre>

<h2>Explained</h2>

<pre><code>~'(!*1?)0?(!*)'{L`x=L2%x+0&gt;1*}R
~                               # Zero Space Segment
 '(!*1?)0?(!*)'                 # A pattern string, matching any number of !'s with optionally a 1, optionally an uncaptured 0, and any number of !'s
               {             }  # An anonymous function, which takes two arguments. The last !'s and the optional 1 with the first 1's.
                L               # Get the length of the last !'s
                 `x=            # Set 'x' to equal it.
                    L2%         # Get the length of the first !'s with the optional 1, mod 2, giving us the boolean portion.
                       x+       # Add x
                         0&gt;1*   # If the total is larger than 0, converted to a number. If there are any leading !'s, this will always be 1, otherwise, it will be the boolean of the left handside.
                              R # Replace the input string via the function matching the first pattern.
</code></pre>

<p><a href="https://tio.run/nexus/rprogn#@1@nrqGoZWivaWAPpDXVq30SKmx9jFQrtA3sDLVqg/7//6@oqGioqAgA" rel="nofollow noreferrer" title="RProgN – TIO Nexus">Try it online!</a></p>
</div>
<div id="pu48" class="pu"><h1>IBM/Lotus Notes Formula - 77 bytes</h1>
<pre><code>@Eval(@Left(a;@If(@Like(a;&quot;%1%&quot;);&quot;1&quot;;&quot;0&quot;))+@If(@Ends(a;&quot;!&quot;);&quot;1&quot;;@Right(a;1)))
</code></pre>
<p>There is no TIO for Notes Formula so a screenshot of all test cases is shown below:</p>
<p><a href="https://i.stack.imgur.com/awdqB.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/awdqB.png" alt="All Test Cases" /></a></p>
<p><strong>How it works</strong></p>
<p><code>@Eval()</code> evaluates a string as an expression</p>
<p>First we check if the input string in field (input) <code>a</code> contains <code>1</code> or <code>0</code> and take all characters to the left of whichever it is which will be a string of <code>!</code> characters. We don't care how many. <code>@Eval()</code> will take care of that.</p>
<p>Next we look to see if there is a <code>!</code> at the end of the string. If there is we append <code>1</code> to the <code>!</code> string (<code>0!</code> and <code>1!</code> are both 1 - it doesn't matter how many <code>!</code> characters there are at the end) otherwise we append the last character unchanged because it is not a <code>!</code> and could be either a <code>1</code> or a <code>0</code>.</p>
<p>We now have a string containing the leading inversions plus a number defined by whether there are any factorial characters so we can feed this to <code>@Eval()</code> and get the results above.</p>
</div>
<div id="pu49" class="pu"><h1><a href="https://github.com/m-ender/retina">Retina</a>, 13 bytes</h1>

<p>A somewhat weird approach, but it's short and it works.</p>

<pre><code>0$
!1
!!

^\d
</code></pre>

<p>With the first two lines we replace an ending <code>0</code> with <code>!1</code>: with this replacement we now know that the part of our string from the digit onwards is equal to 1.</p>

<p>Next two lines, remove pairs of <code>!</code>: double negation erases itself, and we already accounted for factorial with the previous step.</p>

<p>Last line, match a digit at the start of the string and return the number of matches: if the negations have all been eliminated we'll find a match (and as we said before we know this is equal to 1), if there's still a negation this won't match.</p>

<p><a href="https://tio.run/nexus/retina#U9VwT/hvoMKlaMilqMjFFReT8v@/AZchl4Eil6Eil6IBWALIUQTyDBRBgkA2SBgiDuKAtYLYUB6IAQA" title="Retina – TIO Nexus">Try it online!</a></p>
</div>
<div id="pu50" class="pu"><h1><a href="https://www.haskell.org/">Haskell</a>, 27 bytes</h1>



<pre class="lang-hs prettyprint-override"><code>f('!':b)=1-f b
f"0"=0
f _=1
</code></pre>

<p><a href="https://tio.run/nexus/haskell#y03MzFOwVSgoyswrUVBRyE0sUEhTiFYyUNJRUFI0BJMGihAOhFI0gApCuVBFiiARhBiMDZaEGADVbwARgQpBNRgqxf5P01BXVLdK0rQ11E1TSOJKA7rB1oArTSHe1vD/fwA" title="Haskell – TIO Nexus">Try it online!</a></p>

<p>Each leading <code>!</code> complements the output for the rest of the expression, done as <code>1-</code>. We keep flipping until we hit a digit. If the remaining is just <code>"0"</code>, the result is 0. Otherwise, it's a <code>1</code> or is followed by one or more <code>!</code>, so the result is 1.</p>
</div>
<div id="pu51" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 8 bytes</h1>

<pre><code>œr”!LḂ=V
</code></pre>

<p><a href="https://tio.run/nexus/jelly#@390ctGjhrmKPg93NNmG/X/UMMcAiA1BtCKIASIUQUKKhmAWmA8WNVCEKACLQJTA1ECEIDxFEB8uAmHOPdz@qGnN0UkPd874DwA" rel="nofollow noreferrer" title="Jelly – TIO Nexus">Try it online!</a></p>

<p>This is a <em>function</em> (monadic link) that takes one argument and returns via its return value. (It also often writes junk to standard output as a side effect, but we don't care about that.)</p>

<h2>Explanation</h2>

<pre><code>œr”!LḂ=V
œr”!      Take {the input}, with all trailing ! deleted
    L     Take the length of this
     Ḃ    Take the parity of that length
      =   Return 0 if unequal, 1 if equal to:
       V    the value of {the input} when eval'ed as a niladic Jelly program
</code></pre>

<p>First, note that as the input always consists of some number of <code>!</code>, followed by a digit, followed by more <code>!</code>, that if we delete the trailing <code>!</code> and take the length, we'll end up with one plus the number of leading <code>!</code> in the program. Taking the parity of this will return 0 if there were an odd number of <code>!</code>, or 1 if there were an even number of <code>!</code>. Comparing to 0 is a "not" function, whereas comparing to 1 is the identity function; thus <code>œr”!LḂ=</code> effectively implements the "treat leading <code>!</code> as NOT operators" part of the question.</p>

<p>As for the second half, handling factorials, <code>!</code> is a factorial operation in Jelly, so if the program has no leading <code>!</code>, we can solve the problem directly with a simple <code>eval</code> (<code>V</code>). If the program <em>does</em> have leading <code>!</code>, those will be interpreted as taking the factorial of 0 (possibly multiple times), producing a return value of 1, which will be printed to standard output and discarded once a digit is seen; thus, they have no impact on the return value of the function that's my submission to the question.</p>
</div>
<div id="pu52" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, <s>67</s> 65 bytes</h1>

<pre class="lang-hs prettyprint-override"><code>f s|foldr(\_-&gt;not)(last s`elem`&quot;1!&quot;)$fst.span(&lt;'0')$s=&quot;1&quot;|1&lt;3=&quot;0&quot;
</code></pre>
<p><a href="https://tio.run/nexus/haskell#DcNBCoAgEADAr2yLoB4Kpav2kiClFAK1aPfY362B6RnozVc5HrVu49Iu1qpEYqCQSqoB7YBaZOKJ7tiUk0ZqQR4tvtbNHg32Gs8GHs7G6Yk7g4Dch5/5fw" rel="nofollow noreferrer" title="Haskell – TIO Nexus">Try it online!</a> Usage: <code>f &quot;!!!0!!!!&quot;</code></p>
<p>Saved two bytes thanks to @nimi.</p>
</div>
<div id="pu53" class="pu"><h2><a href="https://sourceforge.net/p/cjam" rel="nofollow noreferrer">CJam</a>, <s>12</s> 11 bytes</h2>

<pre><code>r_W='0=!\~;
</code></pre>

<p><a href="https://tio.run/nexus/cjam#@18UH26rbmCrGFNn/f@/oqKigaIiAA" rel="nofollow noreferrer" title="CJam – TIO Nexus">Try it online!</a> <a href="https://tio.run/nexus/cjam#K/TTr1ZS0LVTUNLXsAqy/h8UH26rbmCrGFNn/T@mrs42v1b/vwFI3oDLEEQZchkoQmhDKK1oAKUNIcoUIQqADEMow0ARrgWmRxFqpqKiIcwURZg2RbhJiiBRZHE4DwA" rel="nofollow noreferrer">Test suite</a> (prints a <code>1</code> for each correct test case).</p>

<pre><code>r      e# Read input.
_W='0= e# Duplicate and check whether the string ends in '0'. This is the
       e# only case in which the factorial part results in 0.
!      e# Negate this to get the actual result of the factorial part.
\      e# Swap with the input.
~      e# Evalute the input as CJam code. The leading `!` will apply the logical
       e# negations to the factorial result. The 0 or 1 will then push a junk value
       e# which is potentially negated a few times as well, by the factorials.
;      e# Discard the junk value.
</code></pre>
</div>
<div id="pu54" class="pu"><h1>Befunge, 24 bytes</h1>
<pre><code>~&quot;!&quot;-:#v_$1+
*+2%!.@&gt;0~`
</code></pre>
<p><a href="http://befunge.tryitonline.net/#code=fiIhIi06I3ZfJDErCiorMiUhLkA+MH5g&amp;input=ISEhMCEhISE" rel="noreferrer">Try it online!</a></p>
<p>This starts by counting the number of <code>!</code> characters read from stdin. The first character that isn't a <code>!</code> will either be a <code>0</code> or <code>1</code>, but in the process of testing for <code>!</code> we will have subtracted 33, making it either 15 or 16. We then read one more character, that will either be an <code>!</code> or EOF, and compare if that is less than 0 (i.e. EOF).</p>
<p>Taking those three data points - the exclamation count (<em>c</em>), the digit value, (<em>d</em>), and the end-of-file condition (<em>e</em>) - we can calculate the result as follows:</p>
<pre><code>!((c + d*e) % 2)
</code></pre>
<p>Multiplying the digit value by the end-of-file condition means it will be converted to zero if the digit was followed by a <code>!</code>, thus giving it the same modulo 2 value as a <code>1</code> (which remember has been converted to 16). But before applying the modulo 2, we add the initial exclamation count, which effectively toggles the modulo 2 result as many times as their were <code>!</code> prefixes. And finally we <em>not</em> the result since our baseline values for <code>0</code> and <code>1</code> are the opposite of what we need.</p>
<p>Looking at the code in more detail:</p>
<pre><code>~                Read a character from stdin.
 &quot;!&quot;-            Subtract 33 (ASCII for '!').
     :  _        Make a duplicate and check if zero (i.e. is it a '!').
         $1+     If so, drop the duplicate, increment a counter, and repeat.
       v         Otherwise move to the second line, leaving the digit value on the stack.
       &gt;0~`      Read one more character and check if less than 0 (i.e. EOF).
*                Multiple by the digit value, making it zero if not followed by EOF.
 +               Add to the exclamation count.
  2%             Modulo 2 the result.
    !            Then not that value.
     .@          And finally write to stdout and exit.
</code></pre>
</div>
<div id="pu55" class="pu"><h1><a href="https://www.perl.org/">Perl</a>, 20 bytes</h1>

<p>19 bytes of code + <code>-p</code> flag.</p>



<pre class="lang-perl prettyprint-override"><code>s/\d!+/1/;$_=0+eval
</code></pre>

<p><a href="https://tio.run/nexus/perl#U1YsSC3KUdAt@F@sH5OiqK1vqG@tEm9roJ1alpjz/78BlyGXgSKXoSKXogGXoiGQBLKAPANFkCCQDRKGiIM4IJYiiA3lgRgA" title="Perl – TIO Nexus">Try it online!</a></p>

<p>Perl's negation returns <code>undef</code> or <code>1</code>, so I use <code>0+</code> to numerify the result <code>0+undef</code> returns <code>0</code>. Besides that, not much to say about the code.</p>
</div>
<div id="pu56" class="pu"><h2>JavaScript (ES6), <s>43</s> <s>41</s> 29 bytes</h2>

<pre class="lang-js prettyprint-override"><code>s=&gt;+eval(s.replace(/.!+$/,1))
</code></pre>

<h3>Non-regex method (<s>41</s> 31 bytes)</h3>

<p>Below is my initial approach. It's slightly more interesting, but <s>significantly longer</s> <em>still a bit longer even after a significant optimization by Neil (10 bytes saved)</em>.</p>

<pre class="lang-js prettyprint-override"><code>f=([c,...s])=&gt;1/c?c|s&gt;'':1-f(s)
</code></pre>

<h3>Test cases</h3>

<p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let f =

s=&gt;+eval(s.replace(/.!+$/,1))

;[
  "0", "1", "0!", "1!", "!0", "!1", "!0!", "!1!", "0!!",
  "1!!", "!!0", "!!1", "!0!!", "!!!1", "!!!0!!!!", "!!!1!!!!"
].map(
  s =&gt; console.log(s, '=&gt;', f(s))
)</code></pre>
</div>
</div>
</p>
</div>
<div id="pu57" class="pu"><h2>Batch, 62 bytes</h2>

<pre><code>@set/ps=
@set s=%s:0!=1%
@set s=%s:!!=%
@cmd/cset/a%s:1!=1%
</code></pre>

<p>Takes input on STDIN. Batch actually understands leading <code>!</code>s correctly for this challenge, but the trailing <code>!</code>s need to be dealt with, which takes three steps:</p>

<ul>
<li>Change <code>0!</code> to <code>1</code></li>
<li>Delete pairs of <code>!!</code> (this is safe for the <code>!!</code>s before the digit too)</li>
<li>Delete any remaining trailing <code>!</code> (which by now can only be after a <code>1</code>)</li>
</ul>
</div>
<div id="pu58" class="pu"><h2><a href="https://www.haskell.org/">Haskell</a>, 39 bytes</h2>



<pre class="lang-hs prettyprint-override"><code>f('!':b)="10"!!read[f b]
f[a]=a
f _='1'
</code></pre>

<p>Defines a function <code>f</code>, which takes a string and returns a character.
<a href="https://tio.run/nexus/haskell#y03MzFOwVSgoyswrUVBRSFNQUlRUNFBU@p@moa6obpWkaatkaAAUK0pNTIlOU0iK5UqLToy1TeRKU4i3VTdU//8fAA" title="Haskell – TIO Nexus">Try it online!</a></p>

<h2>Explanation</h2>

<p>There are three cases: input begins with <code>!</code>, input has length 1, and everything else.</p>

<pre class="lang-hs prettyprint-override"><code>f('!':b)=    -- If input has head '!' and tail b,
 "10"!!      -- we index into the string "10"
  read[f b]  -- using f b converted to int. This essentially inverts f b.
f[a]=        -- If input has only one character, we know it's a digit,
 a           -- so we can just return it.
f _=         -- In all other cases, we know the input is a digit followed by !s,
 '1'         -- so we can return '1'.
</code></pre>
</div>
<div id="pu59" class="pu"><h2><a href="https://github.com/m-ender/retina">Retina</a>, <s>20</s> <s>15</s> 14 bytes</h2>

<p><em>Thanks to Leo for saving 1 byte.</em></p>

<pre><code>0!
1
!!

^1|!0
</code></pre>

<p><a href="https://tio.run/nexus/retina#LYm5DYBAEANzdzEBEqGvCro4UQi9L7Ygm@c4r3uMlkDa68EzjrYhLLIixExjuPnrlRLl3wov" title="Retina – TIO Nexus">Try it online!</a></p>

<h3>Explanation</h3>

<pre><code>0!
1
</code></pre>

<p>Turn <code>0!</code> into <code>1</code>. We don't care about any other trailing <code>!</code>s, the resulting number is the same as if we had applied all factorials.</p>

<pre><code>!!

</code></pre>

<p>Cancel pairs of negations. This may also cancel some factorials, but that's irrelevant.</p>

<pre><code>^1|!0
</code></pre>

<p>Count the number of matches of this regex, which is either <code>1</code> or <code>0</code> and gives the desired result.</p>
</div>
<div id="pu60" class="pu"><h1><a href="http://perl6.org/">Perl 6</a>, <s>32</s> <s>28</s> 23 bytes</h1>



<pre class="lang-perl6 prettyprint-override"><code>{m/(\!)*(1|0.)*/.sum%2}
</code></pre>

<h3>How it works</h3>

<pre class="lang-perl6 prettyprint-override"><code>{                     }  # A lambda.
{m/            /      }  # Match the lambda argument against the regex:
   (\!)*                 #   Zero or more `!`.
                         #     (First capture will be an array with one element per negation).
        (1|0.)*          #   A `1`, or a `0` and another character, zero or more times.
                         #     (Second capture will be a one-element array if the factorial
                         #     part evaluates to 1, and an empty array otherwise.)
                .sum     # Add the lengths of the two captures,
                    %2   # and return that sum modulo 2.
</code></pre>
</div>
<div id="pu61" class="pu"><h2><a href="https://github.com/iatorm/grime">Grime</a>, <s>14 12</s> 9 bytes</h2>

<pre><code>e`\0!~\!_
</code></pre>

<p><a href="https://tio.run/nexus/grime#@5@aEGOgWBejGP//vyIQGCgCAA">Try it online!</a></p>

<h2>Explanation</h2>

<p>This matches the input against a pattern, printing <code>1</code> for match and <code>0</code> for no match.</p>

<pre><code>e`\0!~\!_
e`         Match entire input against this pattern:
    !      not
  \0       a sole 0
     ~     xor
      \!   exclamation mark
        _  followed by this pattern matched recursively.
</code></pre>

<p>The idea is this.
If the input begins with a digit, then the recursive part <code>\!_</code> always fails, and <code>\0!</code> succeeds unless we have a single <code>0</code>.
Their xor succeeds unless the input is a single <code>0</code>.
If the input begins with a <code>!</code>, then <code>\0!</code> always succeeds, and <code>\!_</code> succeeds if the recursive match succeeds.
Their xor succeeds exactly when the recursive match fails, thus negating it.</p>
</div>
<div id="pu62" class="pu"><h2>Mathematica, <s>25</s> 17 bytes</h2>

<pre><code>Input[]/.!x_:&gt;1-x
</code></pre>

<p>Takes input from a user prompt. Assumes Mathematica's <a href="http://meta.codegolf.stackexchange.com/a/7844/8478">notebook environment</a> for implicit printing. To make it a command-line script, wrap it in <code>Print[...]</code> or to make it an argumentless function (which then takes input from the prompt), append <code>&amp;</code>.</p>

<p>Mathematica has both of the required operators (with the required precedence), so we can just "eval" the input (which is done automatically by <code>Input[]</code>), but the logical negation operator doesn't work on integers (so it will remain unevaluated). If there's a <code>!x</code> left in the result, we replace it with <code>1-x</code>.</p>

<p>A couple of fun facts about the evaluation:</p>

<ol>
<li>Mathematica actually <em>also</em> has the double factorial operator <code>!!</code>, which computes <code>n*(n-2)*(n-4)*...</code>, but applied to <code>0</code> or <code>1</code> it still gives <code>1</code>, so it doesn't matter that <code>0!!!!!</code> will actually be parsed as <code>((0!!)!!)!</code>.</li>
<li>Even though Mathematica leaves <code>!0</code> and <code>!1</code> unevaluated, it does know that <code>!</code> is self-inverse, so it will automatically cancel all pairs of leading <code>!</code>. After the <code>ToExpression</code> we're <em>always</em> left with one of <code>0</code>, <code>1</code>, <code>!0</code>, <code>!1</code>.</li>
</ol>
</div>
<div id="pu63" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E">05AB1E</a>, 9 bytes</h1>

<p>Code:</p>

<pre><code>.V¹'!ÜgG_
</code></pre>

<p>Uses the <strong>CP-1252</strong> encoding. <a href="https://tio.run/nexus/05ab1e#@68XdminuuLhOenu8f//KxooKgIA" title="05AB1E – TIO Nexus">Try it online!</a> or <a href="https://tio.run/nexus/05ab1e#qymr/K8XVqmueHhOunv8/9pKJQVdOwWlQ6uLD63W@W/AZchloMhlqMilaMClaAgkgSwgz0ARJAhkg4Qh4iAOiKUIYkN5IAYA">Verify all test cases!</a></p>

<p>Explanation:</p>

<pre><code>.V         # Evaluate the input as 05AB1E code. This computes the factorial part.
   '!Ü     # Remove trailing exclamation marks..
  ¹        # ..from the first input
      g    # Get the length of the resulting string
       G   # Do the following length - 1 times:
        _  #   Negate the number
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/109248/">109248</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




