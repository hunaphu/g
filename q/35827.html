<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::35827</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td></td><td>241124T174949Z</td><td><a href="https://codegolf.stackexchange.com/questions/35827/implement-the-game-of-life-on-anything-but-a-regular-grid/276816#276816">henrisro</a></td></tr>
<tr d-ix="1"><td>nan</td><td></td><td>241124T191355Z</td><td><a href="https://codegolf.stackexchange.com/questions/35827/implement-the-game-of-life-on-anything-but-a-regular-grid/276819#276819">henrisro</a></td></tr>
<tr d-ix="2"><td>nan</td><td></td><td>241124T192552Z</td><td><a href="https://codegolf.stackexchange.com/questions/35827/implement-the-game-of-life-on-anything-but-a-regular-grid/276820#276820">henrisro</a></td></tr>
<tr d-ix="3"><td>nan</td><td></td><td>241124T175625Z</td><td><a href="https://codegolf.stackexchange.com/questions/35827/implement-the-game-of-life-on-anything-but-a-regular-grid/276817#276817">henrisro</a></td></tr>
<tr d-ix="4"><td>nan</td><td></td><td>241124T180555Z</td><td><a href="https://codegolf.stackexchange.com/questions/35827/implement-the-game-of-life-on-anything-but-a-regular-grid/276818#276818">henrisro</a></td></tr>
<tr d-ix="5"><td>011</td><td>java</td><td>140808T232131Z</td><td><a href="https://codegolf.stackexchange.com/questions/35827/implement-the-game-of-life-on-anything-but-a-regular-grid/35956#35956">Stretch </a></td></tr>
<tr d-ix="6"><td>nan</td><td>Javascript</td><td>140813T113653Z</td><td><a href="https://codegolf.stackexchange.com/questions/35827/implement-the-game-of-life-on-anything-but-a-regular-grid/36167#36167">Thaylon</a></td></tr>
<tr d-ix="7"><td>002</td><td>Rectangles of width 2row in Python 3</td><td>181208T045711Z</td><td><a href="https://codegolf.stackexchange.com/questions/35827/implement-the-game-of-life-on-anything-but-a-regular-grid/177188#177188">Sparr</a></td></tr>
<tr d-ix="8"><td>097</td><td>Penrose rhombii in Python</td><td>140809T215308Z</td><td><a href="https://codegolf.stackexchange.com/questions/35827/implement-the-game-of-life-on-anything-but-a-regular-grid/35992#35992">Sparr</a></td></tr>
<tr d-ix="9"><td>nan</td><td></td><td>140819T212152Z</td><td><a href="https://codegolf.stackexchange.com/questions/35827/implement-the-game-of-life-on-anything-but-a-regular-grid/36469#36469">Peter Ta</a></td></tr>
<tr d-ix="10"><td>nan</td><td></td><td>140816T145640Z</td><td><a href="https://codegolf.stackexchange.com/questions/35827/implement-the-game-of-life-on-anything-but-a-regular-grid/36283#36283">Peter Ta</a></td></tr>
<tr d-ix="11"><td>nan</td><td></td><td>140813T175011Z</td><td><a href="https://codegolf.stackexchange.com/questions/35827/implement-the-game-of-life-on-anything-but-a-regular-grid/36176#36176">Peter Ta</a></td></tr>
<tr d-ix="12"><td>nan</td><td></td><td>140808T045009Z</td><td><a href="https://codegolf.stackexchange.com/questions/35827/implement-the-game-of-life-on-anything-but-a-regular-grid/35915#35915">Kevin L</a></td></tr>
<tr d-ix="13"><td>nan</td><td></td><td>140808T005805Z</td><td><a href="https://codegolf.stackexchange.com/questions/35827/implement-the-game-of-life-on-anything-but-a-regular-grid/35909#35909">Stretch </a></td></tr>
<tr d-ix="14"><td>017</td><td>Rhombitrihexagonal tiling</td><td>140811T124224Z</td><td><a href="https://codegolf.stackexchange.com/questions/35827/implement-the-game-of-life-on-anything-but-a-regular-grid/36064#36064">Peter Ta</a></td></tr>
<tr d-ix="15"><td>nan</td><td></td><td>140810T230825Z</td><td><a href="https://codegolf.stackexchange.com/questions/35827/implement-the-game-of-life-on-anything-but-a-regular-grid/36037#36037">Peter Ta</a></td></tr>
<tr d-ix="16"><td>nan</td><td></td><td>140808T025741Z</td><td><a href="https://codegolf.stackexchange.com/questions/35827/implement-the-game-of-life-on-anything-but-a-regular-grid/35912#35912">Jaa-c</a></td></tr>
<tr d-ix="17"><td>nan</td><td></td><td>140808T012013Z</td><td><a href="https://codegolf.stackexchange.com/questions/35827/implement-the-game-of-life-on-anything-but-a-regular-grid/35910#35910">DenDenDo</a></td></tr>
<tr d-ix="18"><td>017</td><td>Cairo pentagonal tiling + generic framework</td><td>140808T221809Z</td><td><a href="https://codegolf.stackexchange.com/questions/35827/implement-the-game-of-life-on-anything-but-a-regular-grid/35953#35953">Peter Ta</a></td></tr>
<tr d-ix="19"><td>nan</td><td>Go</td><td>140809T045719Z</td><td><a href="https://codegolf.stackexchange.com/questions/35827/implement-the-game-of-life-on-anything-but-a-regular-grid/35963#35963">Keith Ra</a></td></tr>
<tr d-ix="20"><td>nan</td><td></td><td>140807T174829Z</td><td><a href="https://codegolf.stackexchange.com/questions/35827/implement-the-game-of-life-on-anything-but-a-regular-grid/35886#35886">Kevin L</a></td></tr>
</table>
<div id="pu0" class="pu"><h2>Truncated square tiling (17+ points)</h2>
<p>Here, several years after the last post in the thread, are some results of expanding the Abstract Lattice construction by Peter Taylor to another six Archimedean lattices. In the past, I have been interested in these lattices from a completely different <a href="https://arxiv.org/abs/2303.04817" rel="nofollow noreferrer">perspective</a>.</p>
<p>On four of the six lattices I found only oscillators and still life. On two of them, however, I find gliders and what may be infinite growth (at least in one of them). I will post each of the six cases separately, starting with a &quot;boring&quot; case (which, however, permits many oscillators):</p>
<hr />
<p>The truncated square tiling permits still life (+2)</p>
<p><a href="https://i.sstatic.net/f5XqQNe6.png" rel="nofollow noreferrer"><img src="https://i.sstatic.net/f5XqQNe6.png" alt="still life on (4,8^2)" /></a></p>
<p>and independent oscillators of periods 2, 4, 5, 6, 7, 14 (+15 max) (as well as 10, 12, and 15)</p>
<p><a href="https://i.sstatic.net/53Fim5EH.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/53Fim5EH.gif" alt="p2" /></a> <a href="https://i.sstatic.net/cWeisNxg.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/cWeisNxg.gif" alt="p4" /></a> <a href="https://i.sstatic.net/6Ds4opBM.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/6Ds4opBM.gif" alt="p5" /></a> <a href="https://i.sstatic.net/TWkA2FJj.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/TWkA2FJj.gif" alt="p6" /></a> <a href="https://i.sstatic.net/CInISMrk.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/CInISMrk.gif" alt="p7" /></a> <a href="https://i.sstatic.net/4aBwU0vL.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/4aBwU0vL.gif" alt="p14" /></a></p>
<p>Abstract Lattice construction (this is meant to be used along with the rendering code provided by Peter Taylor in earlier posts, which is available here: <a href="https://gist.github.com/pjt33/becd56784480ddd751bf" rel="nofollow noreferrer">gist.github.com/pjt33/becd56784480ddd751bf</a>. GUI: &quot;GenericLifeGui&quot;, search and gif production: &quot;GenericLife&quot;):</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false" data-babel-preset-react="false" data-babel-preset-ts="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>public class FourEight extends AbstractLattice {
    public FourEight() {
        super(7, 7, 7, -7, new int[][] {
                {-2, 2, 5, 5, 2, -2, -5, -5},
                {-2, 2, 2, -2},
            }, new int[][] {
                {5, 5, 2, -2, -5, -5, -2, 2},
                {5, 5, 9, 9},
            });
    }

    @Override
    public boolean isInterestingOscillationPeriod(int period) {
        return period != 2 &amp;&amp; period != 3 &amp;&amp; period != 4 &amp;&amp; period != 6 &amp;&amp; period != 7 &amp;&amp; period != 10 &amp;&amp; period != 12 &amp;&amp; period != 14 &amp;&amp; period != 20 &amp;&amp; period != 30 &amp;&amp; period != 60;
    }
}</code></pre>
</div>
</div>
</p>
</div>
<div id="pu1" class="pu"><h2>Maple leaf tiling (14+ points)</h2>
<p>The Maple leaf tiling permits still life (+2):</p>
<p><a href="https://i.sstatic.net/Jpz3NCA2.png" rel="nofollow noreferrer"><img src="https://i.sstatic.net/Jpz3NCA2.png" alt="still life" /></a></p>
<p>Independent oscillators of periods 2, 3, 20, 24 (+12):</p>
<p><a href="https://i.sstatic.net/A2TuMd58.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/A2TuMd58.gif" alt="p2" /></a> <a href="https://i.sstatic.net/pYZqrcfg.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/pYZqrcfg.gif" alt="p3" /></a> <a href="https://i.sstatic.net/9nX4yLaK.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/9nX4yLaK.gif" alt="p20" /></a> <a href="https://i.sstatic.net/KS8z6vGy.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/KS8z6vGy.gif" alt="p24" /></a></p>
<p>Abstract Lattice construction (this is meant to be used along with the rendering code provided by Peter Taylor in earlier posts, which is available here: <a href="https://gist.github.com/pjt33/becd56784480ddd751bf" rel="nofollow noreferrer">gist.github.com/pjt33/becd56784480ddd751bf</a>. GUI: &quot;GenericLifeGui&quot;, search and gif production: &quot;GenericLife&quot;):</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false" data-babel-preset-react="false" data-babel-preset-ts="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>public class MapleLeaf extends AbstractLattice {
    public MapleLeaf() {
        super(20,7,16,-14, new int[][] {
                {-4,4,8,4,-4,-8},
                {-4,4,0},
                {4,8,12},
                {8,4,12},
                {0,4,8},
                {8,12,16},
                {8,4,12},
                {8,16,12},
                {8,12,16},
            }, new int[][] {
                {7,7,0,-7,-7,0},
                {7,7,14},
                {7,0,7},
                {0,-7,-7},
                {14,7,14},
                {14,7,14},
                {14,7,7},
                {0,0,7},
                {0,-7,0},
            });
    }

    @Override
    public boolean isInterestingOscillationPeriod(int period) {
        return period != 2 &amp;&amp; period != 3 &amp;&amp; period != 20 &amp;&amp; period != 24;
    }
}</code></pre>
</div>
</div>
</p>
</div>
<div id="pu2" class="pu"><h2>Kagome tiling (18+ points)</h2>
<p>The Kagome tiling also permits still life (+2):</p>
<p><a href="https://i.sstatic.net/26QSEt9M.png" rel="nofollow noreferrer"><img src="https://i.sstatic.net/26QSEt9M.png" alt="still life" /></a></p>
<p>Oscillators of periods 2 and 5 (there are probably more) (+6):</p>
<p><a href="https://i.sstatic.net/65l7tE1B.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/65l7tE1B.gif" alt="p2" /></a> <a href="https://i.sstatic.net/fzMxZDs6.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/fzMxZDs6.gif" alt="p5" /></a></p>
<p>Finally, a spaceship (+10):</p>
<p><a href="https://i.sstatic.net/H392Kz1O.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/H392Kz1O.gif" alt="glider" /></a></p>
<p>And here is a guy that leaves a trace of debris:</p>
<p><a href="https://i.sstatic.net/yROWCA0w.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/yROWCA0w.gif" alt="guy with debris" /></a></p>
<p>It is somewhat unclear whether this tiling permits infinite growth, but some initial searches makes it seem highly plausible.</p>
<p>Abstract Lattice construction (this is meant to be used along with the rendering code provided by Peter Taylor in earlier posts, which is available here: <a href="https://gist.github.com/pjt33/becd56784480ddd751bf" rel="nofollow noreferrer">gist.github.com/pjt33/becd56784480ddd751bf</a>. GUI: &quot;GenericLifeGui&quot;, search and gif production: &quot;GenericLife&quot;):</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false" data-babel-preset-react="false" data-babel-preset-ts="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>public class Kagome extends AbstractLattice {
    public Kagome() {
        super(8,14,16,0, new int[][] {
                {-4,4,8,4,-4,-8},
                {-4,4,0},
                {4,8,12},
            }, new int[][] {
                {7,7,0,-7,-7,0},
                {7,7,14},
                {7,0,7},
            });
    }

    @Override
    public boolean isInterestingOscillationPeriod(int period) {
        return period != 2 &amp;&amp; period != 5;
    }
}</code></pre>
</div>
</div>
</p>
</div>
<div id="pu3" class="pu"><h2>Star tiling (17+ points)</h2>
<p>The star tiling permits still life (+2)</p>
<p>[<img src="https://i.sstatic.net/KdsCXVGy.png" alt="still life1" /></p>
<p>and independent oscillators of periods 2, 3, 4, 5, 8, 9 (+15 max) (as well as 18)</p>
<p><a href="https://i.sstatic.net/v8jABKRo.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/v8jABKRo.gif" alt="p2" /></a> <a href="https://i.sstatic.net/TpGy297J.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/TpGy297J.gif" alt="p3" /></a> <a href="https://i.sstatic.net/pBecXm4f.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/pBecXm4f.gif" alt="p4" /></a> <a href="https://i.sstatic.net/Xzpq5Kcg.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/Xzpq5Kcg.gif" alt="p5" /></a> <a href="https://i.sstatic.net/1KKc51w3.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/1KKc51w3.gif" alt="p8" /></a> <a href="https://i.sstatic.net/eLOoknvI.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/eLOoknvI.gif" alt="p9" /></a></p>
<p>Abstract Lattice construction (this is meant to be used along with the rendering code provided by Peter Taylor in earlier posts, which is available here: gist.github.com/pjt33/becd56784480ddd751bf. GUI: &quot;GenericLifeGui&quot;, search and gif production: &quot;GenericLife&quot;):</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false" data-babel-preset-react="false" data-babel-preset-ts="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>public class Star extends AbstractLattice {
    public Star() {
        super(30, 0, 15, 26, new int[][] {
                {-4,4,11,15,15,11,4,-4,-11,-15,-15,-11},
                {-4,4,0},
                {11,15,19},
                {15,11,19},
            }, new int[][] {
                {15,15,11,4,-4,-11,-15,-15,-11,-4,4,11},
                {11,4,11},
                {11,4,11},
                {-4,-11,-11},
            });
    }

    @Override
    public boolean isInterestingOscillationPeriod(int period) {
        return period != 2 &amp;&amp; period != 3 &amp;&amp; period != 6 &amp;&amp; period != 8 &amp;&amp; period != 9 &amp;&amp; period != 18;
    }
}</code></pre>
</div>
</div>
</p>
</div>
<div id="pu4" class="pu"><h2>Truncated trihexagonal tiling (17+ points)</h2>
<p>The truncated trihexagonal tiling permits still life. On this tiling, however, one can form &quot;topological strings&quot; of still life that wraps around the handles of the torus if one imposes periodic boundary conditions (+2):</p>
<p><a href="https://i.sstatic.net/TIXDDmJj.png" rel="nofollow noreferrer"><img src="https://i.sstatic.net/TIXDDmJj.png" alt="topological still life" /></a></p>
<p>Independent oscillators of periods 2, 3, 5, 6, 9, 15 (+15 max):</p>
<p><a href="https://i.sstatic.net/gwF7O3PI.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/gwF7O3PI.gif" alt="p2" /></a> <a href="https://i.sstatic.net/f5OKgJW6.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/f5OKgJW6.gif" alt="p3" /></a> <a href="https://i.sstatic.net/BXHyh9zu.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/BXHyh9zu.gif" alt="p5" /></a> <a href="https://i.sstatic.net/26GwrW3M.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/26GwrW3M.gif" alt="p6" /></a> <a href="https://i.sstatic.net/ts2jKxyf.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/ts2jKxyf.gif" alt="p9" /></a> <a href="https://i.sstatic.net/lQtppqR9.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/lQtppqR9.gif" alt="p15" /></a></p>
<p>Abstract lattice construction:</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false" data-babel-preset-react="false" data-babel-preset-ts="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>public class FourSixTwelve extends AbstractLattice {
    public FourSixTwelve() {
        super(33, 19, 33, -19, new int[][] {
                {-4,4,11,15,15,11,4,-4,-11,-15,-15,-11},
                {-4,4,4,-4},
                {4,11,18,18,11,4},
                {11,15,22,18},
                {15,15,22,29,29,22},
                {15,11,18,22},
            }, new int[][] {
                {15,15,11,4,-4,-11,-15,-15,-11,-4,4,11},
                {15,15,23,23},
                {15,11,15,23,27,23},
                {11,4,8,15},
                {4,-4,-8,-4,4,8},
                {-4,-11,-15,-8},
            });
    }

    @Override
    public boolean isInterestingOscillationPeriod(int period) {
        return period != 2 &amp;&amp; period != 3 &amp;&amp; period != 5 &amp;&amp; period != 6 &amp;&amp; period != 9 &amp;&amp; period != 10 &amp;&amp; period != 30;
    }
}</code></pre>
</div>
</div>
</p>
</div>
<div id="pu5" class="pu"><h1>java, points-currently 11</h1>
<p>This is the new and improved version of the one above, except without a fatal flaw!</p>
<p>try it <a href="https://app.box.com/s/b3pfluzx8u9yk4qqased" rel="nofollow noreferrer">here</a>, now with random button! (press several times to get more fill)
Also included speed button.</p>
<p>First one, period 4 oscillator, 3 points</p>
<p><img src="https://i.sstatic.net/uYteT.gif" alt="enter image description here" /></p>
<p>Next, <s>2</s>  3 period 2 oscillators - 3 points</p>
<p><img src="https://i.sstatic.net/KMd69.gif" alt="enter image description here" /></p>
<p><img src="https://i.sstatic.net/18p0K.gif" alt="enter image description here" /></p>
<p><img src="https://i.sstatic.net/Qmlxw.gif" alt="enter image description here" /></p>
<p>2 more 2 period oscillators, courtesy of Martin Büttner (oooohhhhhhh... color)</p>
<p><img src="https://i.sstatic.net/UdfXq.gif" alt="enter image description here" /></p>
<p><img src="https://i.sstatic.net/JxwMB.gif" alt="enter image description here" /></p>
<p>I made a program to run it randomly and continuously, looking for oscillations. It found this one. period 5 +3 points</p>
<p><img src="https://i.sstatic.net/jaRG0.gif" alt="enter image description here" /></p>
<p>And another period 5, found by the randomizer.</p>
<p><img src="https://i.sstatic.net/CmqAi.gif" alt="enter image description here" /></p>
<p>And of course, a still life (as an example, there are many) 2 points</p>
<p><img src="https://i.sstatic.net/fMB0W.gif" alt="enter image description here" /></p>
<p>Code-
Main class</p>

<pre class="lang-java prettyprint-override"><code>import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.ArrayList;

import javax.swing.JApplet;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.Timer;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;

public class Main{
    public static void main(String[] args) {
        new Main();
    }

    Canvas canvas = new Canvas();
    JFrame frame = new JFrame();
    Timer timer;
    ShapeInfo info;
    int[][][] history;
    public Main() {
        JPanel panel = new JPanel();
        panel.setMinimumSize(new Dimension(500,500));
        panel.setLayout(new GridBagLayout());
        
        frame.setMinimumSize(new Dimension(500,500));
        frame.getContentPane().add(panel);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        //frame.setResizable(false);
        canvas.setMinimumSize(new Dimension(200,200));
        GridBagConstraints c = new GridBagConstraints();
        c.gridx = 0;
        c.gridy = 2;
        c.weightx = 1;
        c.weighty = 1;
        c.gridwidth = 3;
        c.fill = GridBagConstraints.BOTH;
        panel.add(canvas,c);
        
        JButton startButton = new JButton();
        startButton.setText(&quot;click to start&quot;);
        startButton.setMaximumSize(new Dimension(100,50));
        GridBagConstraints g = new GridBagConstraints();
        g.gridx =0;
        g.gridy = 0;
        g.weightx = 1;
        panel.add(startButton,g);
        
        JButton restartButton = new JButton();
        restartButton.setText(&quot;revert&quot;);
        GridBagConstraints b = new GridBagConstraints();
        b.gridx = 0;
        b.gridy = 9;
        panel.add(restartButton,b);
        
        JButton clearButton = new JButton();
        clearButton.setText(&quot;Clear&quot;);
        GridBagConstraints grid = new GridBagConstraints();
        grid.gridx = 1;
        grid.gridy = 0;
        panel.add(clearButton,grid);
        
        JButton randomButton = new JButton();
        randomButton.setText(&quot;fill randomly&quot;);
        GridBagConstraints rt = new GridBagConstraints();
        rt.gridx = 2;
        rt.gridy = 0;
        panel.add(randomButton,rt);
        
        JLabel speedLabel = new JLabel();
        speedLabel.setText(&quot;speed&quot;);
        GridBagConstraints rt2 = new GridBagConstraints();
        rt2.gridx = 3;
        rt2.gridy = 0;
        panel.add(speedLabel,rt2);
        
        final JTextField speed = new JTextField();
        speed.setText(&quot;300&quot;);
        GridBagConstraints rt21 = new GridBagConstraints();
        rt21.gridx = 4;
        rt21.gridy = 0;
        panel.add(speed,rt21);
        
        speed.getDocument().addDocumentListener(new DocumentListener(){

            @Override
            public void changedUpdate(DocumentEvent arg0) {
                doSomething();
                
            }
            @Override
            public void insertUpdate(DocumentEvent arg0) {
                doSomething();
                
            }
            @Override
            public void removeUpdate(DocumentEvent arg0) {
                doSomething();
                
            }   
            public void doSomething(){
                try{int s = Integer.valueOf(speed.getText());
                timer.setDelay(s);}
                catch(Exception e){}
            }
        });
        
        randomButton.addActionListener(new ActionListener(){
            @Override
            public void actionPerformed(ActionEvent arg0) { 
                for(int i = 0; i&lt; canvas.squaresHigh*canvas.squaresWide/2;i++){
                    double rx = Math.random();
                    double ry = Math.random();
                    int position = (int) Math.floor(Math.random() * 13);
                    int x = (int)(rx * canvas.squaresWide);
                    int y = (int)(ry * canvas.squaresHigh);
                    if(x!=0&amp;&amp;x!=canvas.squaresWide-1&amp;&amp;y!=0&amp;&amp;y!=canvas.squaresHigh-1){
                        info.allShapes[x][y][position] = 1;
                    }
                }
                history = cloneArray(info.allShapes);
                canvas.draw(info.allShapes);
            }
        });
        
        clearButton.addActionListener(new ActionListener(){
            @Override
            public void actionPerformed(ActionEvent arg0) {
                info = new ShapeInfo(canvas.squaresWide,canvas.squaresHigh);
                restart();
            }
        });
        
        final JTextField scaleFactor = new JTextField();
        scaleFactor.setText(&quot;5&quot;);
        GridBagConstraints gh = new GridBagConstraints();
        gh.gridx  = 0;
        gh.gridy = 1;
        panel.add(scaleFactor,gh);
        scaleFactor.getDocument().addDocumentListener(new DocumentListener(){

            @Override
            public void changedUpdate(DocumentEvent arg0) {
                doSomething();
            }

            @Override
            public void insertUpdate(DocumentEvent arg0) {
                doSomething();
            }

            @Override
            public void removeUpdate(DocumentEvent arg0) {
                doSomething();
            }
            public void doSomething(){
                try{
                canvas.size = Integer.valueOf(scaleFactor.getText());
                canvas.draw(info.allShapes);
                }
                catch(Exception e){}
            }
            
        });
        timer = new Timer(300, listener);
        frame.pack();
        frame.setVisible(true);
        info = new ShapeInfo(canvas.squaresWide, canvas.squaresHigh);
        info.width = canvas.squaresWide;
        info.height = canvas.squaresHigh;
        history = cloneArray(info.allShapes);
        //history[8][11][1] = 1;
        canvas.draw(info.allShapes);
        restartButton.addActionListener(new ActionListener(){
            @Override
            public void actionPerformed(ActionEvent arg0) {
                if(timer.isRunning() == true){
                    info.allShapes = cloneArray(history);
                    restart();
                }
            }
        });
        canvas.addMouseListener(new MouseListener(){
            @Override
            public void mouseClicked(MouseEvent e) {
                int x = e.getLocationOnScreen().x - canvas.getLocationOnScreen().x;
                int y = e.getLocationOnScreen().y - canvas.getLocationOnScreen().y;
                Point location = new Point(x,y);
                for(PolygonInfo p:canvas.polygons){
                    if(p.polygon.contains(location)){
                        if(info.allShapes[p.x][p.y][p.position] == 1){
                            info.allShapes[p.x][p.y][p.position] = 0;
                        }
                        else{
                            info.allShapes[p.x][p.y][p.position] = 1;
                        }
                    }
                }
                canvas.draw(info.allShapes);
                history = cloneArray(info.allShapes);
            }
            @Override
            public void mouseEntered(MouseEvent arg0) {
            }
            @Override
            public void mouseExited(MouseEvent arg0) {
            }
            @Override
            public void mousePressed(MouseEvent arg0) { 
            }
            @Override
            public void mouseReleased(MouseEvent arg0) {    
            }
        });
        startButton.addActionListener(new ActionListener(){
            @Override
            public void actionPerformed(ActionEvent arg0) {
                timer.start();
            }
        });
    }
    public int[][][] cloneArray(int[][][] array){
        int[][][] newArray = new int[array.length][array[0].length][array[0][0].length];
        for(int x = 0;x&lt;array.length;x++){
            int[][] subArray = array[x];
            for(int y = 0; y &lt; subArray.length;y++){
                int subSubArray[] = subArray[y];
                newArray[x][y] = subSubArray.clone();
            }
        }
        return newArray;
    }
    public void restart(){
        timer.stop();
        canvas.draw(info.allShapes);
    }
    public void setUp(){
        int[] boxes = new int[]{2,3,4,6,7,8};
        for(int box:boxes){
            info.allShapes[8][12][box-1] = 1;
            info.allShapes[9][13][box-1] = 1;
            info.allShapes[8][14][box-1] = 1;
            info.allShapes[9][15][box-1] = 1;
        }
    }
    public void update() {
        ArrayList&lt;Coordinate&gt; dieList = new ArrayList&lt;Coordinate&gt;();
        ArrayList&lt;Coordinate&gt; appearList = new ArrayList&lt;Coordinate&gt;();
        for (int x = 0; x &lt; canvas.squaresWide; x++) {
            for (int y = 0; y &lt; canvas.squaresHigh; y++) {
                for(int position = 0;position &lt;13;position++){
                    int alive = info.allShapes[x][y][position];
                    int touching = info.shapesTouching(x, y, position);
                    if(touching!=0){
                    }
                    if(alive == 1){
                        if(touching &lt; 2 || touching &gt; 3){
                            //cell dies
                            dieList.add(new Coordinate(x,y,position));
                        }
                    }
                    else{
                        if(touching == 3){
                            //cell appears
                            appearList.add(new Coordinate(x,y,position));
                        }
                    }
                }
            }
        }
        for(Coordinate die:dieList){
            info.allShapes[die.x][die.y][die.position] = 0;
        }
        for(Coordinate live:appearList){
            info.allShapes[live.x][live.y][live.position] = 1;
        }
    }
    boolean firstDraw = true;
    int ticks = 0;
    ActionListener listener = new ActionListener() {
        @Override
        public void actionPerformed(ActionEvent arg0) {
            canvas.draw(info.allShapes);
            if(ticks !=0){
            update();
            }
            ticks++;
        }
    };
}
</code></pre>
<p>Canvas -</p>
<pre class="lang-java prettyprint-override"><code>import java.awt.Color;
import java.awt.Graphics;
import java.awt.Polygon;
import java.util.ArrayList;

import javax.swing.JPanel;

public class Canvas extends JPanel {
    private static final long serialVersionUID = 1L;

    public int squaresWide = 30;
    public int squaresHigh = 30;
    public int size = 6;
    ArrayList&lt;PolygonInfo&gt; polygons = new ArrayList&lt;PolygonInfo&gt;();
    boolean drawTessalationOnly = true;
    private int[][][] shapes;

    public void draw(int[][][] shapes2) {
        shapes = shapes2;
        drawTessalationOnly = false;
        this.repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        //System.out.println(&quot;drawing&quot;);
        polygons.clear();
        super.paintComponent(g);
        g.setColor(Color.black);
        // draw tessellation
        for (int x = 0; x &lt; squaresWide; x++) {
            for (int y = 0; y &lt; squaresHigh; y++) {
                for (int position = 0; position &lt; 13; position++) {
                    // System.out.println(&quot;position = &quot; + position);
                    Polygon p = new Polygon();
                    int points = 0;
                    int[] xc = new int[] {};
                    int[] yc = new int[] {};
                    if (position == 0) {
                        xc = new int[] {-2,0,2,0};
                        yc = new int[] {0,-2,0,2};
                        points = 4;
                    }
                    if (position == 1) {
                        xc = new int[] {2,4,4,1};
                        yc = new int[] {0,0,2,1};
                        points = 4;
                    }
                    if (position == 2) {
                        xc = new int[] {4,6,7,4};
                        yc = new int[] {0,0,1,2};
                        points = 4;
                    }
                    if (position == 3) {
                        xc = new int[] {1,2,0,0};
                        yc = new int[] {1,4,4,2};
                        points = 4;
                    }
                    if (position == 4) {
                        xc = new int[] {1,4,4,2};
                        yc = new int[] {1,2,4,4};
                        points = 4;
                    }
                    if (position == 5) {
                        xc = new int[] {7,6,4,4};
                        yc = new int[] {1,4,4,2};
                        points = 4;
                    }
                    if (position == 6) {
                        xc = new int[] {7,8,8,6};
                        yc = new int[] {1,2,4,4};
                        points = 4;
                    }
                    if (position == 7) {
                        xc = new int[] {0,2,1,0};
                        yc = new int[] {4,4,7,6};
                        points = 4;
                    }
                    if (position == 8) {
                        xc = new int[] {1,2,4,4};
                        yc = new int[] {7,4,4,6};
                        points = 4;
                    }
                    if (position == 9) {
                        xc = new int[] {7,6,4,4};
                        yc = new int[] {7,4,4,6};
                        points = 4;
                    }
                    if (position == 10) {
                        xc = new int[] {8,6,7,8};
                        yc = new int[] {4,4,7,6};
                        points = 4;
                    }
                    if (position == 11) {
                        xc = new int[] {4,4,2,1};
                        yc = new int[] {6,8,8,7};
                        points = 4;
                    }
                    if (position == 12) {
                        xc = new int[] {4,4,6,7};
                        yc = new int[] {6,8,8,7};
                        points = 4;
                    }
                    int[] finalX = new int[xc.length];
                    int[] finalY = new int[yc.length];
                    for (int i = 0; i &lt; xc.length; i++) {
                        int xCoord = xc[i];
                        xCoord = (xCoord + (8 * x)) * size;
                        finalX[i] = xCoord;
                    }
                    for (int i = 0; i &lt; yc.length; i++) {
                        int yCoord = yc[i];
                        yCoord = (yCoord + (8 * y)) * size;
                        finalY[i] = yCoord;
                    }
                    p.xpoints = finalX;
                    p.ypoints = finalY;
                    p.npoints = points;
                    polygons.add(new PolygonInfo(p,x,y,position));
                    // for(int i = 0;i&lt;p.npoints;i++){
                    // / System.out.println(&quot;(&quot; + p.xpoints[i] + &quot;,&quot; +
                    // p.ypoints[i] + &quot;)&quot;);
                    // }
                    if (drawTessalationOnly == false) {
                        if (shapes[x][y][position] == 1) {
                            g.setColor(Color.black);
                            g.fillPolygon(p);
                        } else {
                            g.setColor(Color.black);
                            g.drawPolygon(p);
                        }
                    } else {
                        g.drawPolygon(p);
                    }
                }

            }
        }
    }
}
</code></pre>
<p>ShapeInfo -</p>
<pre class="lang-java prettyprint-override"><code>public class ShapeInfo {
    int[][][] allShapes; // first 2 dimensions are coordinates of large square,
                            // last is boolean - if shaded
    int width = 30;
    int height = 30;

    public ShapeInfo(int width, int height) {
        allShapes = new int[width][height][13];
        for (int[][] i : allShapes) {
            for (int[] h : i) {
                for (int g : h) {
                    g = 0;
                }
            }
        }
    }

    public int shapesTouching(int x, int y, int position) {
        int t = 0;
        if (x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; x &lt; width - 1 &amp;&amp; y &lt; height - 1) {
            int[] inShape = new int[]{};
            int[] rightOfShape = new int[]{};
            int[] aboveShape = new int[]{};
            int[] leftOfShape = new int[]{};
            int[] belowShape = new int[]{};
            int[] aboveRightOfShape = new int[]{};
            int[] aboveLeftOfShape = new int[]{};
            int[] belowRightOfShape = new int[]{};
            int[] belowLeftOfShape = new int[]{};
            if (position == 0) {
                inShape = new int[]{1,3,4};
                aboveShape = new int[]{7,8,11};
                leftOfShape = new int[]{2,5,6};
                aboveLeftOfShape = new int[]{10,12,9};
            }
            if (position == 1) {
                inShape = new int[]{0,3,4,5,2};
                aboveShape = new int[]{11,12};
            }
            if (position == 2) {
                inShape = new int[]{1,4,5,6};
                rightOfShape = new int[]{0};
                aboveShape = new int[]{12,11};
            }
            if (position == 3) {
                inShape = new int[]{0,1,4,8,7};
                leftOfShape = new int[]{6,10};
            }
            if (position == 4) {
                inShape = new int[]{0,1,3,2,7,5,8,9};
            }
            if (position == 5) {
                inShape = new int[]{2,6,1,10,4,9,8};
                rightOfShape = new int[]{0};
            }
            if (position == 6) {
                inShape = new int[]{2,5,9,10};
                rightOfShape = new int[]{0,3,7};
            }
            if (position == 7) {
                inShape = new int[]{3,4,8,11};
                leftOfShape =new int[]{6,10};
                belowShape = new int[]{0};
            }
            if (position == 8) {
                inShape = new int[]{5,4,9,3,12,7,11};
                belowShape = new int[]{0};
            }
            if (position == 9) {
                inShape = new int[]{4,5,8,6,11,12,10};
                belowRightOfShape = new int[]{0};
            }
            if (position == 10) {
                inShape = new int[]{6,5,9,12};
                rightOfShape = new int[]{3,7};
                belowRightOfShape = new int[]{0};
            }
            if (position == 11) {
                inShape = new int[]{7,8,9,12};
                belowShape = new int[]{0,1,2};
            }
            if (position == 12) {
                inShape = new int[]{11,8,9,10};
                belowShape = new int[]{1,2};
                belowRightOfShape = new int[]{0};
            }
            for(int a:inShape){
                if(allShapes[x][y][a] == 1){t++;}
            }
            for(int a:rightOfShape){
                if(allShapes[x+1][y][a] == 1){t++;}
            }
            for(int a:leftOfShape){
                if(allShapes[x-1][y][a] == 1){t++;}
            }
            for(int a:aboveShape){
                if(allShapes[x][y-1][a] == 1){t++;}
            }
            for(int a:belowShape){
                if(allShapes[x][y+1][a] == 1){t++;}
            }
            for(int a:aboveRightOfShape){
                if(allShapes[x+1][y-1][a] == 1){t++;}
            }
            for(int a:aboveLeftOfShape){
                if(allShapes[x-1][y-1][a] == 1){t++;}
            }
            for(int a:belowRightOfShape){
                if(allShapes[x+1][y+1][a] == 1){t++;}
            }
            for(int a:belowLeftOfShape){
                if(allShapes[x-1][y+1][a] == 1){t++;}
            }
        }
        return t;
    }
}
</code></pre>
<p>Coordinate -</p>
<pre class="lang-java prettyprint-override"><code>public class Coordinate {
    int x;
    int y;
    int position;
    public Coordinate(int X,int Y, int Position){
        x=X;
        y=Y;
        position = Position;
    }
}
</code></pre>
<p>PolygonInfo</p>
<pre class="lang-java prettyprint-override"><code>import java.awt.Polygon;

public class PolygonInfo {
    public Polygon polygon;
    public int x;
    public int y;
    public int position;
    public PolygonInfo(Polygon p,int X,int Y,int Position){
        x = X;
        y = Y;
        polygon = p;
        position = Position;
    }
}
</code></pre>
<p>If anyone finds any, they will be mentioned. (Which reminds me: my brother found the first 2 oscillators)</p>
</div>
<div id="pu6" class="pu"><h1>Javascript, HexagonSplit</h1>
<p>Disclaimer: Its pretty slow due to lots of dom manipulation and probably needs a bugfix for the x-axis to not wrap-around.</p>
<p>Fiddle</p>
<p><a href="http://jsfiddle.net/16bhsr52/9/" rel="nofollow noreferrer">http://jsfiddle.net/16bhsr52/9/</a></p>
<p>Fiddle now allows to toggle active cells.</p>
<p>Still Live</p>
<p><img src="https://i.sstatic.net/MYWRL.png" alt="enter image description here" />
<img src="https://i.sstatic.net/PRxY2.png" alt="enter image description here" />
<img src="https://i.sstatic.net/7iZtZ.png" alt="enter image description here" /></p>
<p>Oscillator</p>
<p><img src="https://i.sstatic.net/ltVDR.png" alt="2 phase" />
<img src="https://i.sstatic.net/BXL8x.png" alt="2 phase" /></p>
<p>Spaceship (2 phases, two variants)</p>
<p><img src="https://i.sstatic.net/dfhwt.png" alt="2 phase" />
<img src="https://i.sstatic.net/XzbZE.png" alt="variant of first" /></p>
<p>Spacehip (4 phases)</p>
<p><img src="https://i.sstatic.net/qmL9e.png" alt="enter image description here" /></p>
<p>Javascript</p>
<pre class="lang-js prettyprint-override"><code>//--  Prepare  --
var topX = 0;
var topY = 0;
var sizeX = 40;
var sizeY = 10;
var patternSizeX = 17;
var patternSizeY = 43;
var patternElements = 3;
var neighbourTopLeft = -(sizeX + 1) * patternElements;
var neighbourTop = -(sizeX) * patternElements;
var neighbourTopRight = -(sizeX - 1) * patternElements;
var neighbourLeft = -patternElements;
var neighbourRight = +patternElements;
var neighbourBottomLeft = +(sizeX - 1) * patternElements;
var neighbourBottom = +(sizeX) * patternElements;
var neighbourBottomRight = +(sizeX + 1) * patternElements;
var patternNeighbours = [
    [neighbourTopLeft + 2, neighbourTop + 2, neighbourTopRight + 2, neighbourLeft, neighbourLeft + 1, 1, neighbourRight],
    [neighbourLeft + 1, 0, 2, neighbourRight, neighbourRight + 1, neighbourRight + 2],
    [neighbourLeft + 1, neighbourLeft + 2, 1, neighbourRight + 2, neighbourBottomLeft, neighbourBottom, neighbourBottomRight]
];

for (i = 0; i &lt; sizeX; i++) {
    for (j = 0; j &lt; sizeY; j++) {
        var tileId = (j * sizeX + i) * patternElements;
        $(&quot;body&quot;).append('&lt;div id=&quot;t' + (tileId) + '&quot; class=&quot;shapeDown&quot; style=&quot;left:' + topX + patternSizeX * i + 'px;top:' + topY + patternSizeY * j + 'px;&quot;&gt;');
        $(&quot;body&quot;).append('&lt;div id=&quot;t' + (tileId + 1) + '&quot; class=&quot;shapeHexagon&quot; style=&quot;left:' + (8 + topX + patternSizeX * i) + 'px;top:' + (17 + topY + patternSizeY * j) + 'px;&quot;&gt;');
        $(&quot;body&quot;).append('&lt;div id=&quot;t' + (tileId + 2) + '&quot; class=&quot;shapeUp&quot; style=&quot;left:' + topX + patternSizeX * i + 'px;top:' + (34 + topY + patternSizeY * j) + 'px;&quot;&gt;');
    }
}

//--  Populate  --
for (i = 0; i &lt; (patternElements * sizeX * sizeY) / 5; i++) {
    $(&quot;#t&quot; + Math.floor((Math.random() * (patternElements * sizeX * sizeY)))).addClass(&quot;shapeAlive&quot;);
};

//--  Animate  --
setInterval(progress, 1000);

function progress() {
    var dying = [];
    var rising = [];

    for (i = 0; i &lt; sizeX; i++) {
        for (j = 0; j &lt; sizeY; j++) {
            var tileBaseId = (j * sizeX + i) * patternElements;
            for (k = 0; k &lt; patternElements; k++) {
                var tileSelect = &quot;#t&quot; + (tileBaseId + k);
                var alive = $(tileSelect).filter(&quot;.shapeAlive&quot;).length;
                var nbSelect = $.map(patternNeighbours[k], function (n, i) {
                    return (&quot;#t&quot; + (tileBaseId + n));
                }).join();
                var count = $(nbSelect).filter(&quot;.shapeAlive&quot;).length;
                if (alive &amp;&amp; (count &lt; 2 || count &gt; 3)) {
                    dying.push(tileSelect);
                };
                if (!alive &amp;&amp; count == 3) {
                    rising.push(tileSelect);
                };
            }
        }
    }

    $(dying.join()).removeClass(&quot;shapeAlive&quot;);
    $(rising.join()).addClass(&quot;shapeAlive&quot;);
};
</code></pre>
<p>CSS</p>
<pre class="lang-css prettyprint-override"><code>.shapeHexagon {
    background-color: black;
    height: 8px;
    width: 16px;
    position: absolute;
}
.shapeUp {
    background-color: black;
    height: 8px;
    width: 16px;
    position: absolute;
}
.shapeUp:after, .shapeHexagon:before {
    content:&quot;&quot;;
    position: absolute;
    top: -8px;
    left: 0px;
    width: 0;
    height: 0;
    border-style: solid;
    border-color: transparent transparent black;
    border-width: 0px 8px 8px 8px;
}
.shapeAlive.shapeUp {
    background-color: green;
}
.shapeAlive.shapeUp:after {
    border-color: transparent transparent green;
}
.shapeDown {
    background-color: black;
    height: 8px;
    width: 16px;
    position: absolute;
}
.shapeDown:after, .shapeHexagon:after {
    content:&quot;&quot;;
    position: absolute;
    top: 8px;
    left: 0px;
    width: 0;
    height: 0;
    border-style: solid;
    border-color: black transparent transparent transparent;
    border-width: 8px 8px 0 8px;
}
.shapeAlive.shapeUp:after, .shapeAlive.shapeHexagon:before {
    border-color: transparent transparent green;
}
.shapeAlive.shapeDown, .shapeAlive.shapeHexagon {
    background-color: green;
}
.shapeAlive.shapeDown:after, .shapeAlive.shapeHexagon:after {
    border-color: green transparent transparent transparent;
}
</code></pre>
</div>
<div id="pu7" class="pu"><h2>Rectangles of width 2<sup>row</sup> in Python 3, +2</h2>

<p>The shape of this grid is as follows:</p>

<pre><code> ______________
[______________]
[______][______]
[__][__][__][__]
[][][][][][][][]
</code></pre>

<p>Coincidentally, each cell in this grid has 8 neighbors, just like the original square tiling of the Game of Life.</p>

<p>Unfortunately, this tiling has the terrible property that each cell only has two north neighbors. That means a pattern can never propagate southward, including southeast or southwest. This property leads to a situation that makes oscillators rather unlikely, although one might exist of the sort that has walls on two sides and blinking cells in the middle.</p>

<p>It also seems to have the property (I'm not 100% sure yet) that no pattern can grow while moving north. A row will never grow to a wider maximum extent number of cells than the row below it. I think that means no gliders or more complicated forms.</p>

<p>That leaves us with a measly +2 bonus for a wide variety of still lifes, of which these are only a small sample:</p>

<pre><code>AA__
_BC_

AABB
_CD_

AA__BB
_CXXD_ &lt;-- XX can be any multiple of 2 wide

____YYYY____
__AA____BB__
___CXXXXD___ &lt;-- XX can be any multiple of 4 wide

____YYYYOOOO &lt;-- OOOO can continue to the right and could be the bottom of a stack of this pattern
__AA____BB__
___CXXXX____ &lt;-- XX can be any multiple of 4 wide

OOOOYYYYOOOO &lt;-- same stackability as above
__AA____BB__
____XXXX____ &lt;-- XX can be any multiple of 4 wide
</code></pre>

<p>Here is the code, which when run will draw an 8-row grid (1 cell in the top row, 128 cells in the bottom row). Any key will advance one step, except <code>r</code> will randomize the board and <code>q</code> will exit the program.</p>

<pre class="lang-python prettyprint-override"><code>#!/usr/bin/env python3

import random
import readchar

class board:
  def __init__(self, rows = 8):
    if rows&gt;10:
      raise ValueError("Too many rows!")
    self.rows = rows
    self.cells = [[cell() for c in range(int(2**(r)))] for r in range(rows)]
  def __str__(self):
    out = []
    for r,row in enumerate(self.cells):
      out.append(''.join([str(row[c])*(2**(self.rows-r-1)) for c in range(len(row))]))
    return "\n".join(out)
  def randomize(self):
    for row in self.cells:
      for c,cel in enumerate(row):
        row[c].state = random.choice([True,False])
  def state_at(self,r,c):
    if r==None or c==None:
      raise TypeError()
    if r&lt;0 or c&lt;0:
      return False
    if r&gt;=self.rows:
      return False
    if c&gt;=len(self.cells[r]):
      return False
    return self.cells[r][c].state
  def tick(self):
    new_cells = [[cell() for c in range(int(2**(r)))] for r in range(self.rows)]
    for r,row in enumerate(self.cells):
      for c,cel in enumerate(row):
        # print(f"cell {r} {c}")
        cur = cel.state
        # print(cur)
        neighbors = 0
        # same row, left and right
        neighbors += self.state_at(r,c-1)
        neighbors += self.state_at(r,c+1)
        # straight up
        neighbors += self.state_at(r-1,int(c/2))
        # straight down
        neighbors += self.state_at(r+1,c*2)
        neighbors += self.state_at(r+1,c*2+1)
        # down left
        neighbors += self.state_at(r+1,c*2-1)
        # down right
        neighbors += self.state_at(r+1,c*2+2)
        if c%2==0:
          # up left
          neighbors += self.state_at(r-1,int(c/2)-1)
        else:
          # up right
          neighbors += self.state_at(r-1,int(c/2)+1)
        # print(neighbors)
        if cur:
          if neighbors&lt;2 or neighbors&gt;3:
            # print("turn off")
            new_cells[r][c].state = False
          else:
            new_cells[r][c].state = True
          continue
        if neighbors==3:
          # print("turn on")
          new_cells[r][c].state = True
          continue
        new_cells[r][c].state = False
        continue
    self.cells = new_cells

class cell:
  def __init__(self, state = False):
    self.state = state
  def __str__(self):
    return self.state and "X" or "_"

b = board(8)
b.randomize()
print(b)
while(1):
  i = readchar.readchar()
  if i=='q':
    break
  if i=='r':
    b.randomize()
  b.tick()
  print()
  print(b)
</code></pre>

<p>PS: This grid is the equivalent of regular in a particularly shaped non-Euclidean space :)</p>
</div>
<div id="pu8" class="pu"><h1>Penrose rhombii in Python, +97 points</h1>

<p>I chose a penrose tiling composed of two different shaped rhombuses, meeting 3-8 per vertex. This penrose tiling is proven aperiodic elsewhere. The simulation is graphical (via pygame) and interactive. Comments indicate two places in the code where algorithm implementation was taken from another source.</p>

<p><img src="https://i.sstatic.net/Hne4R.gif" alt="animation of penrose life ending with p12 oscillator"></p>

<p>There are many small neighborhood still lifes:</p>

<p><img src="https://i.sstatic.net/UpPmB.png" alt="still life in penrose life">
<img src="https://i.sstatic.net/bLuKE.png" alt="still life in penrose life">
<img src="https://i.sstatic.net/oQe7F.png" alt="still life in penrose life"></p>

<p>Any vertex with four "on" neighbors is a still life:</p>

<p><img src="https://i.sstatic.net/7TaW4.png" alt="butterfly still life in penrose life">
<img src="https://i.sstatic.net/2yg7F.png" alt="spiky still life in penrose life">
<img src="https://i.sstatic.net/gtRCK.png" alt="pacman still life in penrose life"></p>

<p>Any loop where no dead interior cells touch three cells on the loop is also a still life:</p>

<p><img src="https://i.sstatic.net/iV1KG.png" alt="loop still life in penrose life">
<img src="https://i.sstatic.net/a8c6z.png" alt="loop still life in penrose life"></p>

<p>There are oscillators at various frequencies:</p>

<p>p2: (many variations)</p>

<p><img src="https://i.sstatic.net/QMr51.gif" alt="period 2 oscillator in penrose life"></p>

<p>p3:</p>

<p><img src="https://i.sstatic.net/eqFzU.gif" alt="period 3 oscillator in penrose life"></p>

<p>p4:</p>

<p><img src="https://i.sstatic.net/2K4nB.gif" alt="period 4 oscillator in penrose life">
<img src="https://i.sstatic.net/ns0aA.gif" alt="period 4 oscillator in penrose life">
<img src="https://i.sstatic.net/dWBeq.gif" alt="period 4 oscillator in penrose life"></p>

<p>p5:</p>

<p><img src="https://i.sstatic.net/s5cM4.gif" alt="period 5 oscillator in penrose life"></p>

<p>p6:</p>

<p><img src="https://i.sstatic.net/z2CZi.gif" alt="period 6 oscillator in penrose life"></p>

<p>p7:</p>

<p><img src="https://i.sstatic.net/rEJB0.gif" alt="period 7 oscillator in penrose life">
<img src="https://i.sstatic.net/0O4G4.gif" alt="period 7 oscillator in penrose life"></p>

<p>p12:</p>

<p><img src="https://i.sstatic.net/SbhJH.gif" alt="period 12 oscillator in penrose life"></p>

<p>p20:</p>

<p><img src="https://i.sstatic.net/ocOeY.gif" alt="period 20 oscillator in penrose life"></p>

<p>The rules and clarifications as written mostly do not allow for gliders or guns in a non-planned aperiodic tiling. That leaves infinite growth, which I would argue isn't likely, and a p30+ oscillator, which almost certainly exists but will take a while to find.</p>

<p><code>python penrose-life.py</code> will generate a single randomly colored periodic tiling
<code>python -O penrose-life.py</code> or just <code>./penrose-life.py</code> will actually run the simulation. While running it will try to identify oscillators, and when it finds one (p>2) it will screenshot it. After recording an oscillator, or a stalled board, the board is randomized.</p>

<p>Clicking a cell in the simulation will toggle it.</p>

<p>The following keyboard shortcuts exist in the simulation:</p>

<ul>
<li>Escape - quit the program</li>
<li>Space - randomize the whole board</li>
<li>P - pause the simulation</li>
<li>S - single step the simulation</li>
<li>F - toggle "fast" mode, rendering only every 25th frame</li>
</ul>

<p>The initial seed of the penrose tiling algorithm is a circle of ten narrow triangles. This could be changed to single triangle, or a different arrangement of triangles, symmetric or not.</p>

<p>Source:</p>

<pre class="lang-python prettyprint-override"><code>#!/usr/bin/env python -O

# tiling generation code originally from http://preshing.com/files/penrose.py

import sys
import math
import time
import cairo
import cmath
import random
import pygame

#TODO: command line parameters
#------ Configuration --------
IMAGE_SIZE = (1200, 1200)
OFFX = 600
OFFY = 600
RADIUS = 600
if __debug__: NUM_SUBDIVISIONS = 5
else: NUM_SUBDIVISIONS = 7
#-----------------------------

goldenRatio = (1 + math.sqrt(5)) / 2

class Triangle():
    def __init__(self, parent = None, color = 0, corners = []):
        self.parent = parent
        self.other_half = None
        # immediate neighbor 0 is on BA side, 1 is on AC side
        self.neighbors = [None, None]
        # all_neighbors includes diagonal neighbors
        self.all_neighbors = set()
        # child 0 is first on BA side, 1 is second, 2 is on AC side
        self.children = []
        self.color = color
        if __debug__: self.debug_color = (random.random(),random.random(),random.random())
        self.state = random.randint(0,1)
        self.new_state = 0
        self.corners = corners
        self.quad = None
    def __repr__(self):
        return "Triangle: state=" + str(self.state) + \
            " color=" + str(self.color) + \
            " parent=" + ("yes" if self.parent else "no") + \
            " corners=" + str(self.corners)
    # break one triangle up into 2-3 smaller triangles
    def subdivide(self):
        result = []
        A,B,C = self.corners
        if self.color == 0:
            # Subdivide red triangle
            P = A + (B - A) / goldenRatio
            result = [Triangle(self, 0, (C, P, B)), Triangle(self, 1, (P, C, A))]
        else:
            # Subdivide blue triangle
            Q = B + (A - B) / goldenRatio
            R = B + (C - B) / goldenRatio
            result = [Triangle(self, 1, (Q, R, B)), Triangle(self, 0, (R, Q, A)), Triangle(self, 1, (R, C, A))]
        self.children.extend(result)
        return result;
    # identify the left and right neighbors of a triangle
    def connect_immediate(self):
        o = None
        n = self.neighbors
        if self.parent:
            if self.color == 0: # red child
                if self.parent.color == 0: # red parent
                    if self.parent.neighbors[0]:
                        if self.parent.neighbors[0].color == 0: # red left neighbor
                            o = self.parent.neighbors[0].children[0]
                        else: # blue left neighbor
                            o = self.parent.neighbors[0].children[1]
                    n[0] = self.parent.children[1]
                    if self.parent.other_half:
                        n[1] = self.parent.other_half.children[0]
                else: # blue parent
                    if self.parent.neighbors[0]:
                        if self.parent.neighbors[0].color == 0: # red left neighbor
                            o = self.parent.neighbors[0].children[0]
                        else: # blue left neighbor
                            o = self.parent.neighbors[0].children[1]
                    n[0] = self.parent.children[0]
                    n[1] = self.parent.children[2]
            else: # blue child
                if self.parent.color == 0: # red parent
                    if self.parent.neighbors[1]:
                        if self.parent.neighbors[1].color == 0: # red right neighbor
                            o = self.parent.neighbors[1].children[1]
                        else: # blue right neighbor
                            o = self.parent.neighbors[1].children[2]
                    n[0] = self.parent.children[0]
                    if self.parent.neighbors[0]:
                        if self.parent.neighbors[0].color == 0: # red left neighbor
                            n[1] = self.parent.neighbors[0].children[1]
                        else: # blue left neighbor
                            n[1] = self.parent.neighbors[0].children[0]
                else: # blue child of blue parent
                    if self.corners[2] == self.parent.corners[1]: # first blue child
                        if self.parent.other_half:
                            o = self.parent.other_half.children[0]
                        n[0] = self.parent.children[1]
                        if self.parent.neighbors[0]:
                            if self.parent.neighbors[0].color == 0: # red left neighbor
                                n[1] = self.parent.neighbors[0].children[1]
                            else: #blue left neighbor
                                n[1] = self.parent.neighbors[0].children[0]
                    else: # second blue child
                        if self.parent.neighbors[1]:
                            if self.parent.neighbors[1].color == 0: # red right neighbor
                                o = self.parent.neighbors[1].children[1]
                            else: # blue right neighbor
                                o = self.parent.neighbors[1].children[2]
                        if self.parent.other_half:
                            n[0] = self.parent.other_half.children[2]
                        n[1] = self.parent.children[1]
        self.other_half = o
        if o:
            self.state = self.other_half.state
            if __debug__: self.debug_color = self.other_half.debug_color

#TODO: different seed triangle configurations
# Create wheel of red triangles around the origin
triangles = [[]]
for i in xrange(10):
    B = cmath.rect(RADIUS, (2*i - 1) * math.pi / 10)+OFFX+OFFY*1j
    C = cmath.rect(RADIUS, (2*i + 1) * math.pi / 10)+OFFX+OFFY*1j
    if i % 2 == 0:
        B, C = C, B  # Make sure to mirror every second triangle
    triangles[0].append(Triangle(None, 0, (OFFX+OFFY*1j, B, C)))

# identify the neighbors of the starting triangles
for i in xrange(10):
    if i%2:
        triangles[0][i].neighbors[0] = triangles[0][(i+9)%10]
        triangles[0][i].neighbors[1] = triangles[0][(i+1)%10]
    else:
        triangles[0][i].neighbors[1] = triangles[0][(i+9)%10]
        triangles[0][i].neighbors[0] = triangles[0][(i+1)%10]

# Perform subdivisions
for i in xrange(NUM_SUBDIVISIONS):
    triangles.append([])
    for t in triangles[i]:
        triangles[i+1].extend(t.subdivide())
    for t in triangles[i+1]:
        t.connect_immediate()

# from here on, we only deal with the most-subdivided triangles
tris = triangles[NUM_SUBDIVISIONS]

# make a dict of every vertex, containing a list of every triangle sharing that vertex
vertices = {}
for t in tris:
    for c in t.corners:
        if c not in vertices:
            vertices[c] = []
        vertices[c].append(t)

# every triangle sharing a vertex are neighbors of each other
for v,triset in vertices.iteritems():
    for t in triset:
        t.all_neighbors.update(triset)

# combine mirrored triangles into quadrilateral cells
quads = []
total_neighbors = 0
for t in tris:
    if t.quad == None and t.other_half != None:
        quads.append(t)
        q = t
        q.corners = (q.corners[0], q.corners[1], q.other_half.corners[0], q.corners[2])
        q.quad = q
        q.other_half.quad = q
        q.all_neighbors.update(q.other_half.all_neighbors)
        q.all_neighbors.remove(q.other_half)
        q.all_neighbors.remove(q)
        total_neighbors += len(q.all_neighbors)

# clean up quads who still think they have triangles for neighbors
for q in quads:
    new_neighbors = set()
    for n in q.all_neighbors:
        if len(n.corners)==3:
            if n.other_half:
                if len(n.other_half.corners)==4:
                    new_neighbors.add(n.other_half)
        else:
            new_neighbors.add(n)
    q.all_neighbors = new_neighbors


# # adopt your other half's neighbors, minus them and yourself. mark other half as dead.
# for t in tris:
#     if t.other_half:
#         t.all_neighbors.update(t.other_half.all_neighbors)
#     t.all_neighbors.remove(t)
#     if t.other_half and t.other_half in t.all_neighbors:
#         t.all_neighbors.remove(t.other_half)
#     if t.other_half and not t.dead_half:
#         t.other_half.dead_half = True

pygame.init()
screen = pygame.display.set_mode(IMAGE_SIZE, 0, 32)
pygame.display.set_caption("Penrose Life")
pygame.display.flip()

paused = False
fast = False
randomize = True
found_oscillator = 0
randomized_tick = 0
tick = 0
timed_tick = 0
timed_tick_time = time.clock()
render_countdown = 0

history_length = 45
quad_history = [[0]*len(quads)]*history_length
quad_pointer = 0

myfont = pygame.font.SysFont("monospace", 15)
guidish = random.randint(0,99999999)

while True:

    tick += 1
    if tick - randomized_tick &gt; 1000 and render_countdown == 0:
        randomize = True
    edited = False
    step = False
    if found_oscillator &gt; 0 and render_countdown == 0:
        print "Potential p" + str(found_oscillator) + " osillator"
        render_countdown = found_oscillator
    if render_countdown == 0: # don't handle input while rendering an oscillator
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                sys.exit(0)
            elif event.type == pygame.KEYDOWN:
                # print event
                if event.scancode == 53: # escape
                    sys.exit(0)
                elif event.unicode == " ": # randomize
                    randomize = True
                    edited = True
                elif event.unicode == "p": # pause
                    paused = not paused
                elif event.unicode == "f": # fast
                    fast = not fast
                elif event.unicode == "s": # step
                    paused = True
                    step = True
            elif event.type == pygame.MOUSEBUTTONDOWN:
            # click to toggle a cell
                x = event.pos[0]
                y = event.pos[1]
                for q in quads:
                    poly = [(c.real,c.imag) for c in q.corners]
                    # http://www.ariel.com.au/a/python-point-int-poly.html
                    n = len(poly)
                    inside = False
                    p1x,p1y = poly[0]
                    for i in range(n+1):
                        p2x,p2y = poly[i % n]
                        if y &gt; min(p1y,p2y):
                            if y &lt;= max(p1y,p2y):
                                if x &lt;= max(p1x,p2x):
                                    if p1y != p2y:
                                        xinters = (y-p1y)*(p2x-p1x)/(p2y-p1y)+p1x
                                    if p1x == p2x or x &lt;= xinters:
                                        inside = not inside
                        p1x,p1y = p2x,p2y
                    if inside:
                        edited = True
                        q.state = 0 if q.state==1 else 1

    if randomize and render_countdown == 0:
        randomized_tick = tick
        randomize = False
        for q in quads:
            q.state = random.randint(0,1)
            edited = True

    if (not fast) or (tick%25==0) or edited or render_countdown &gt; 0:
        # draw filled quads
        for q in quads:
            cs = [(c.real,c.imag) for c in q.corners]
            if __debug__:
                color = q.debug_color
                color = (int(color[0]*256)&lt;&lt;24)+(int(color[1]*256)&lt;&lt;16)+(int(color[2]*256)&lt;&lt;8)+0xFF
            else:
                if q.state == 0:
                    color = 0xFFFFFFFF
                else:
                    color = 0x000000FF
            pygame.draw.polygon(screen, color, cs, 0)
        # draw edges
        for q in quads:
            if len(q.corners)==3:
                exit(1)
            cs = [(c.real,c.imag) for c in q.corners]
            width = 3
            pygame.draw.lines(screen, 0x7F7F7FFF, 1, cs, int(width))
        now = time.clock()
        speed = (tick-timed_tick)/(now-timed_tick_time)
        timed_tick_time = now
        timed_tick = tick
        screen.blit(screen, (0, 0))
        label = myfont.render("%4.2f/s"%speed, 1, (255,255,255))
        screen.fill(pygame.Color("black"), (0, 0, 110, 15))
        screen.blit(label, (0, 0))        
        pygame.display.update()

    if __debug__:
        break

    if paused and not step and render_countdown == 0:
        time.sleep(0.05)
        continue

    # screenshot
    if render_countdown &gt; 0:
        filename = "oscillator_p%03d_%08d_%03d.png" % (found_oscillator, guidish, found_oscillator - render_countdown)
        pygame.image.save(screen,filename)
        render_countdown -= 1
        if render_countdown == 0:
            guidish = random.randint(0,99999999)
            found_oscillator = 0
            randomize = True
            continue


    # calculate new cell states based on the Game of Life rules
    for q in quads:
        a = sum([n.state for n in q.all_neighbors])
        q.new_state = q.state
        # dead cells with three neighbors spawn
        if q.state == 0 and a == 3:
            q.new_state = 1
        # live cells only survive with two or three neighbors
        elif a &lt; 2 or a &gt; 3:
            q.new_state = 0

    # update cell states
    for q in quads:
        q.state = q.new_state

    this_state = [q.state for q in quads]

    # don't bother checking
    if render_countdown == 0:
        # compare this board state to the last N-1 states
        for i in range(1,history_length):
            if quad_history[(quad_pointer-i)%history_length] == this_state:
                if i == 1 or i == 2: # stalled board or p2 oscillator (boring)
                    randomize = True
                    break
                #TODO: give up if the "oscillator" includes border cells
                #TODO: identify cases of two oprime oscillators overlapping
                elif i &gt; 2:
                    found_oscillator = i
                    break # don't keep looking

        # remember this board state
        quad_history[quad_pointer] = this_state
        quad_pointer = (quad_pointer+1)%history_length

if __debug__:
    filename = "penrose.png"
    pygame.image.save(screen,filename)
    time.sleep(1)
</code></pre>
</div>
<div id="pu9" class="pu"><h2>Penrose-esque projection of 7-dimensional lattice (64+ points)</h2>

<p>This is similar to the Penrose tiling (to get a Penrose tiling replace <code>N = 7</code> with <code>N = 5</code>) and qualifies for the <strong>aperiodic bonus</strong> (40 points).</p>

<p><strong>Still life</strong> (2 points): trivial because the protocells are convex, so any vertex of order 3 or more suffices. (Pick all of its faces if it is order 3, or any 4 of them otherwise).</p>

<p><strong>Short-period oscillators</strong> (15 points):</p>

<p>This tiling is rich in oscillators. The smallest period for which I've only found one oscillator is 11, and the smallest period for which I've found none is 13.</p>

<p><img src="https://i.sstatic.net/50Upy.gif" alt="p2"> <img src="https://i.sstatic.net/RMHZ9.gif" alt="p3"> <img src="https://i.sstatic.net/nGyDR.gif" alt="p4"> <img src="https://i.sstatic.net/ddnHi.gif" alt="p5"> <img src="https://i.sstatic.net/ttB7B.gif" alt="p6"> <img src="https://i.sstatic.net/2OUHK.gif" alt="p7"> <img src="https://i.sstatic.net/KKxfx.gif" alt="p8"> <img src="https://i.sstatic.net/ODRsX.gif" alt="p9"> <img src="https://i.sstatic.net/ekhs1.gif" alt="p10"> <img src="https://i.sstatic.net/QGTCE.gif" alt="p11"> <img src="https://i.sstatic.net/TfktG.gif" alt="p12"></p>

<p><strong>Long-period oscillator</strong> (7 points):</p>

<p>I deliberately chose one of the variants of this tiling which has rotational symmetry, and that turned out to be useful for the long-period oscillator. It does one-seventh of a rotation around the central point every 28 generations, making it a p196.</p>

<p><img src="https://i.sstatic.net/WaMmn.gif" alt="p196"></p>

<p>The code uses the framework which I posted in earlier answers together with the following tiling class:</p>

<pre class="lang-java prettyprint-override"><code>import java.awt.geom.Point2D;
import java.util.*;

public class Penrose7Tiling implements Tiling&lt;Penrose7Tiling.Rhomb&gt; {
    private Map&lt;String, Rhomb&gt; rhombs = new HashMap&lt;String, Rhomb&gt;();

    private static final int N = 7;
    private double scale = 16;
    private double[] gamma;
    // Nth roots of unity.
    private Point2D.Double[] zeta;

    public Penrose7Tiling() {
        gamma = new double[N];
        zeta = new Point2D.Double[N];
        for (int i = 0; i &lt; N; i++) {
            gamma[i] = 1.0 / N; // for global rotational symmetry
            zeta[i] = new Point2D.Double(Math.cos(2 * i * Math.PI / N), Math.sin(2 * i * Math.PI / N));
        }
    }

    private Rhomb getRhomb(int r, int s, int k_r, int k_s) {
        String key = String.format("%d,%d,%d,%d", r, s, k_r, k_s);
        Rhomb rhomb = rhombs.get(key);
        if (rhomb == null) rhombs.put(key, rhomb = new Rhomb(r, s, k_r, k_s));
        return rhomb;
    }

    private int round(double val) {
        return (int)Math.round(scale * val);
    }

    public class Rhomb {
        public int[] k;
        public int r, s;

        private int[] xs = new int[4];
        private int[] ys = new int[4];
        private Set&lt;Rhomb&gt; neighbours;

        public Rhomb(int r, int s, int k_r, int k_s) {
            assert 0 &lt;= r &amp;&amp; r &lt; s &amp;&amp; s &lt; N;

            this.r = r;
            this.s = s;

            // z_0 satisfies z_0 * zeta_{r,s} + gamma_{r,s} = k_{r,s}
            Point2D.Double z_0 = solveLinear(zeta[r].x, -zeta[r].y, gamma[r] - k_r, zeta[s].x, -zeta[s].y, gamma[s] - k_s);

            // Find base lattice point.
            Point2D.Double p = new Point2D.Double();
            k = new int[N];
            for (int i = 0; i &lt; N; i++) {
                int k_i;
                if (i == r) k_i = k_r;
                else if (i == s) k_i = k_s;
                else k_i = (int)Math.ceil(z_0.x * zeta[i].x - z_0.y * zeta[i].y + gamma[i]);

                k[i] = k_i;
                p.x += zeta[i].x * (k_i + gamma[i]);
                p.y += zeta[i].y * (k_i + gamma[i]);
            }

            xs[0] = round(p.x);
            ys[0] = round(p.y);
            xs[1] = round(p.x + zeta[r].x);
            ys[1] = round(p.y + zeta[r].y);
            xs[2] = round(p.x + zeta[r].x + zeta[s].x);
            ys[2] = round(p.y + zeta[r].y + zeta[s].y);
            xs[3] = round(p.x + zeta[s].x);
            ys[3] = round(p.y + zeta[s].y);
        }

        public Set&lt;Rhomb&gt; neighbours() {
            if (neighbours == null) {
                neighbours = new HashSet&lt;Rhomb&gt;();

                // There are quite a few candidates, but we have to check them...
                for (int nr = 0; nr &lt; N - 1; nr++) {
                    for (int ns = nr + 1; ns &lt; N; ns++) {
                        if (nr == r &amp;&amp; ns == s) continue; // Can't happen.
                        for (int nk_r = k[nr] - 1; nk_r &lt;= k[nr]; nk_r++) {
                            for (int nk_s = k[ns] - 1; nk_s &lt;= k[ns]; nk_s++) {
                                Rhomb candidate = getRhomb(nr, ns, nk_r, nk_s);

                                // Our lattice points are (k) plus one or both of vec[r] and vec[s]
                                // where vec[0] = (1, 0, 0, ...), vec[1] = (0, 1, 0, ...), etc.
                                // Candidate has a similar set of 4 lattice points. Is there any agreement?
                                boolean isNeighbour = true;
                                for (int i = 0; i &lt; N; i++) {
                                    int myMin = k[i], myMax = k[i] + ((i == r || i == s) ? 1 : 0);
                                    int cMin = candidate.k[i], cMax = candidate.k[i] + ((i == nr || i == ns) ? 1 : 0);
                                    if (myMin &gt; cMax || cMin &gt; myMax) isNeighbour = false;
                                }
                                if (isNeighbour) neighbours.add(candidate);
                            }
                        }
                    }
                }
            }

            return neighbours;
        }

        @Override
        public String toString() {
            return String.format("%d,%d,%d,%d", r, s, k[r], k[s]);
        }
    }

    // Solves ax + by + c = dx + ey + f = 0
    private Point2D.Double solveLinear(double a, double b, double c, double d, double e, double f) {
        double det = a*e - b*d;
        double x = (b*f - c*e) / det;
        double y = (c*d - a*f) / det;
        return new Point2D.Double(x, y);
    }

    public Set&lt;Rhomb&gt; neighbours(Rhomb cell) {
        return cell.neighbours();
    }

    public int[][] bounds(Rhomb cell) {
        // Will be modified. Copy-clone for safety.
        return new int[][]{ cell.xs.clone(), cell.ys.clone() };
    }

    public Rhomb initialCell() {
        return getRhomb(0, 1, 0, 0);
    }

    public boolean isInterestingOscillationPeriod(int period) {
        return period == 11 || period == 13 || (period &gt; 14 &amp;&amp; period != 26);
    }

    public Set&lt;Rhomb&gt; parseCells(String[] data) {
        Set&lt;Rhomb&gt; rv = new HashSet&lt;Rhomb&gt;();
        for (String key : data) {
            String[] parts = key.split(",");
            int r = Integer.parseInt(parts[0]);
            int s = Integer.parseInt(parts[1]);
            int k_r = Integer.parseInt(parts[2]);
            int k_s = Integer.parseInt(parts[3]);
            rv.add(getRhomb(r, s, k_r, k_s));
        }
        return rv;
    }

    public String format(Set&lt;Rhomb&gt; cells) {
        StringBuilder sb = new StringBuilder();
        for (Rhomb cell : cells) {
            if (sb.length() &gt; 0) sb.append(' ');
            sb.append(cell);
        }

        return sb.toString();
    }
}
</code></pre>
</div>
<div id="pu10" class="pu"><h2>"Hex Medley 3" (24+ points*)</h2>

<p>Inspired by the floret pentagonal tiling: a block of 7 hexagons tiles the plane, and we can chop the hexagons up in a lot of different ways. As the name suggests, this is the third such variation I tried, but it's worth posting because it's the first tiling to claim the 7 points for a p30+ oscillator.</p>

<p>The tiling is:</p>

<p><img src="https://i.sstatic.net/iCLIB.png" alt="The inner of the 7 hexagons is divided into 6 equilateral triangles; the outer six into 3 rhombi each, with alternating parity"></p>

<p>Since the protocells are convex, any order-3 vertex gives a <strong>still-life</strong> (2 points).</p>

<p>I have found <strong>five small-period oscillators</strong> (15 points): periods 2, 3, 4, 6, 12.</p>

<p><img src="https://i.sstatic.net/SlJLD.gif" alt="p2 oscillator"> <img src="https://i.sstatic.net/ymIvM.gif" alt="p3 oscillator"> <img src="https://i.sstatic.net/kH71z.gif" alt="p4 oscillator"> <img src="https://i.sstatic.net/KAyEI.gif" alt="p6 oscillator"> <img src="https://i.sstatic.net/51O7I.gif" alt="p12 oscillator"></p>

<p>And the <em>pièce de résistance</em>: a <strong>p48 oscillator</strong> (7 points) which rotates by 60 degrees every 8 generations:</p>

<p><img src="https://i.sstatic.net/xzjeA.gif" alt="p48 oscillator"></p>

<p>* Given the nature of this tiling I could pick a single hex which is divided into rhombi and rotate it 60 degrees. This would make the tiling aperiodic without technically breaking any rules, and wouldn't break any of the oscillators either. But I don't think it's in the spirit of the question, so I won't try to claim those 40 points.</p>

<p>The code relies on a lot of code I've posted in other answers; the unique part is</p>

<pre class="lang-java prettyprint-override"><code>public class HexMedley3 extends AbstractLattice {
    public HexMedley3() {
        super(35, -12, 28, 24, new int[][] {
                {0, 0, 7},
                {0, 7, 7},
                {0, 7, 0},
                {0, 0, -7},
                {0, -7, -7},
                {0, -7, 0},

                {0, 0, 7, 7},
                {7, 7, 14, 14},
                {7, 14, 7, 0},

                {7, 14, 21, 14},
                {14, 21, 21, 14},
                {14, 14, 7, 7},

                {7, 14, 14, 7},
                {7, 14, 7, 0},
                {7, 0, 0, 7},

                {0, 0, -7, -7},
                {-7, -7, -14, -14},
                {-7, -14, -7, 0},

                {-7, -14, -21, -14},
                {-14, -21, -21, -14},
                {-14, -14, -7, -7},

                {-7, -14, -14, -7},
                {-7, -14, -7, 0},
                {-7, 0, 0, -7},

            }, new int[][] {
                {0, 8, 4},
                {0, 4, -4},
                {0, -4, -8},
                {0, -8, -4},
                {0, -4, 4},
                {0, 4, 8},
                {8, 16, 20, 12},
                {12, 20, 16, 8},
                {12, 8, 4, 8},
                {4, 8, 4, 0},
                {0, 4, -4, -8},
                {0, -8, -4, 4},
                {-4, -8, -16, -12},
                {-12, -16, -20, -16},
                {-12, -16, -8, -4},

                {-8, -16, -20, -12},
                {-12, -20, -16, -8},
                {-12, -8, -4, -8},
                {-4, -8, -4, 0},
                {0, -4, 4, 8},
                {0, 8, 4, -4},
                {4, 8, 16, 12},
                {12, 16, 20, 16},
                {12, 16, 8, 4},
            });
    }

    @Override
    public boolean isInterestingOscillationPeriod(int period) {
        return period != 2 &amp;&amp; period != 4;
    }
}
</code></pre>
</div>
<div id="pu11" class="pu"><h2>Rhombille (30+ points)</h2>

<p>This grid has quite high connectivity (each cell has 10 neighbours), and curiously this seems to contribute more effectively to birth than to death. Most random grids seem to trigger <strong>infinite growth</strong> (25 points); e.g. this 5-cell starting position:</p>

<p><img src="https://i.sstatic.net/SVurf.gif" alt="Starting position"></p>

<p>evolves over 300 generations into something enormous:</p>

<p><img src="https://i.sstatic.net/JhKMw.gif" alt="Evolution of that starting position"></p>

<p>and the population grows quadratically with the generation for at least 3000 generations.</p>

<p>Perhaps this is why I've only found one <strong>oscillator</strong>, of period 2 (3 points):</p>

<p><img src="https://i.sstatic.net/6pZqK.gif" alt="3-cell oscillator"></p>

<p>As for <strong>still life</strong> (2 points): take any 4 cells around a single vertex.</p>

<p>The code (use with the generic framework and <code>AbstractLattice</code> classes I posted in earlier answers):</p>

<pre class="lang-java prettyprint-override"><code>public class Rhombille extends AbstractLattice {
    public Rhombille() {
        super(14, 0, 7, 12, new int[][] {
                {0, 7, 14, 7},
                {0, 7, 7, 0},
                {7, 14, 14, 7}
            }, new int[][] {
                {0, 4, 0, -4},
                {0, -4, -12, -8},
                {-4, 0, -8, -12}
            });
    }

    @Override
    public boolean isInterestingOscillationPeriod(int period) {
        return period != 2;
    }
}
</code></pre>
</div>
<div id="pu12" class="pu"><h1>Javascript [27+?]</h1>
<p><a href="http://jsfiddle.net/Therm/5n53auja/" rel="noreferrer">http://jsfiddle.net/Therm/5n53auja/</a></p>
<p>Round 2! Now with hexagons, squares, and triangles. <em>And interactivity</em><br><br>
This version supports clicking tiles to toggle their state, for you pattern hunters out there. Note: Some of the click handling may be a bit wonky, especially for low values of <code>s</code>, as click events are tracked as integers but calculations are done with floating point values</p>
<p><img src="https://i.sstatic.net/x3GvQ.gif" alt="enter image description here" /></p>
<p>Current score - 24 <br></p>
<pre><code>Still life           : +2
Period 2 oscillator  : +3
Period 4 oscillator  : +3
Period 6 oscillator  : +3
Period 10 oscillator : +3
Period 12 oscillator : +3
Spaceship            : +10
</code></pre>
<p>Period 4 oscillator : Found by Martin Büttner <br>
<img src="https://i.sstatic.net/eb5fv.gif" alt="enter image description here" /></p>
<p>Period 6 oscillator : Found by Martin Büttner<br>
<img src="https://i.sstatic.net/jFqFw.gif" alt="enter image description here" /></p>
<p>Period 10 oscillator: Found by Martin Büttner <br>
<img src="https://i.sstatic.net/8eew4.gif" alt="enter image description here" /></p>
<p>Period 12 oscillator : Found by Martin Büttner<br>
<img src="https://i.sstatic.net/nI274.gif" alt="enter image description here" /></p>
<p>Period 20 spaceship : Found by Martin Büttner<br>
<img src="https://i.sstatic.net/WURtM.gif" alt="enter image description here" /></p>
</div>
<div id="pu13" class="pu"><h1>Java - 11 (ish) points</h1>

<p>Comes with fully (mostly) functioning interactive environment!</p>

<p><strong>EDIT</strong></p>

<p>Fatal flaw discovered :(</p>

<p>The path of the alive regions is bounded by the area it is originally formed in. In order to pass the square - double-pentagon barrier, one must have a pre-shaded region on the other side. This is because each shape below it only touches 2 of the regions above it. This means no spaceships or expanding anything, which kind of limits the possibilities. I will try with a different pattern.</p>

<p>BUT!!! if you still want to try it...
try it <a href="https://app.box.com/s/c8vq85cu3ezcxn20cqyo" rel="noreferrer">here</a>.</p>

<p>oscillator</p>

<p><img src="https://i.sstatic.net/MFmPf.gif" alt="enter image description here"></p>

<p>Don't know what to call this one - another oscillator</p>

<p><img src="https://i.sstatic.net/WJVQk.gif" alt="enter image description here"></p>

<p>This one looks a little like a ninja star - still life</p>

<p><img src="https://i.sstatic.net/FSf2k.gif" alt="enter image description here"></p>

<p>this one looks like a fly - still life</p>

<p><img src="https://i.sstatic.net/tPY3J.gif" alt="enter image description here"></p>

<p>another oscillator</p>

<p><img src="https://i.sstatic.net/M99fF.gif" alt="enter image description here"></p>

<p><strong>EDIT</strong></p>

<p>another oscillator found. I am naming this one the eagle.</p>

<p><img src="https://i.sstatic.net/GCpNM.gif" alt="enter image description here"></p>

<p>Hey! another oscillator! (period 4) The windmill.</p>

<p><img src="https://i.sstatic.net/D0tHV.gif" alt="enter image description here"></p>

<p>A 2 period one.</p>

<p><img src="https://i.sstatic.net/UtUZj.gif" alt="enter image description here"></p>

<p>There seems to be a structure that insulates the outside from the inside. This (and the previous example) uses it. The only thing that can break the box is if one of the boundary squares is alive at the beginning (so far). This, by the way, is the blinker - period 2.</p>

<p><img src="https://i.sstatic.net/Q09RX.gif" alt="enter image description here"></p>

<p>I built this in eclipse, and there are multiple files. Here they are.</p>

<p>Main class - </p>



<pre class="lang-java prettyprint-override"><code>import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.ArrayList;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.Timer;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;

public class Main {

    public static void main(String[] args) {
        new Main();
    }

    Canvas canvas = new Canvas();
    JFrame frame = new JFrame();
    Timer timer;
    ShapeInfo info;
    int[][][] history;
    public Main() {
        JPanel panel = new JPanel();
        panel.setMinimumSize(new Dimension(500,500));
        panel.setLayout(new GridBagLayout());

        frame.setMinimumSize(new Dimension(500,500));
        frame.getContentPane().add(panel);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        //frame.setResizable(false);
        canvas.setMinimumSize(new Dimension(200,200));
        GridBagConstraints c = new GridBagConstraints();
        c.gridx = 0;
        c.gridy = 2;
        c.weightx = 1;
        c.weighty = 1;
        c.gridwidth = 2;
        c.fill = GridBagConstraints.BOTH;
        panel.add(canvas,c);

        JButton startButton = new JButton();
        startButton.setText("click to start");
        startButton.setMaximumSize(new Dimension(100,50));
        GridBagConstraints g = new GridBagConstraints();
        g.gridx =0;
        g.gridy = 0;
        g.weightx = 1;
        panel.add(startButton,g);

        JButton restartButton = new JButton();
        restartButton.setText("revert");
        GridBagConstraints b = new GridBagConstraints();
        b.gridx = 0;
        b.gridy = 9;
        panel.add(restartButton,b);

        JButton clearButton = new JButton();
        clearButton.setText("Clear");
        GridBagConstraints grid = new GridBagConstraints();
        grid.gridx = 1;
        grid.gridy = 0;
        panel.add(clearButton,grid);

        clearButton.addActionListener(new ActionListener(){
            @Override
            public void actionPerformed(ActionEvent arg0) {
                info = new ShapeInfo(canvas.squaresWide,canvas.squaresHigh);
                restart();
            }
        });

        final JTextField scaleFactor = new JTextField();
        scaleFactor.setText("5");
        GridBagConstraints gh = new GridBagConstraints();
        gh.gridx  = 0;
        gh.gridy = 1;
        panel.add(scaleFactor,gh);
        scaleFactor.getDocument().addDocumentListener(new DocumentListener(){

            @Override
            public void changedUpdate(DocumentEvent arg0) {
                doSomething();
            }

            @Override
            public void insertUpdate(DocumentEvent arg0) {
                doSomething();
            }

            @Override
            public void removeUpdate(DocumentEvent arg0) {
                doSomething();
            }
            public void doSomething(){
                try{
                canvas.size = Integer.valueOf(scaleFactor.getText());
                canvas.draw(info.allShapes);
                }
                catch(Exception e){}
            }

        });
        timer = new Timer(1000, listener);
        frame.pack();
        frame.setVisible(true);
        info = new ShapeInfo(canvas.squaresWide, canvas.squaresHigh);
        info.width = canvas.squaresWide;
        info.height = canvas.squaresHigh;
        history = cloneArray(info.allShapes);
        //history[8][11][1] = 1;
        canvas.draw(info.allShapes);
        restartButton.addActionListener(new ActionListener(){
            @Override
            public void actionPerformed(ActionEvent arg0) {
                if(timer.isRunning() == true){
                    info.allShapes = cloneArray(history);
                    restart();
                }
            }
        });
        canvas.addMouseListener(new MouseListener(){
            @Override
            public void mouseClicked(MouseEvent e) {
                int x = e.getLocationOnScreen().x - canvas.getLocationOnScreen().x;
                int y = e.getLocationOnScreen().y - canvas.getLocationOnScreen().y;
                Point location = new Point(x,y);
                for(PolygonInfo p:canvas.polygons){
                    if(p.polygon.contains(location)){
                        if(info.allShapes[p.x][p.y][p.position-1] == 1){
                            info.allShapes[p.x][p.y][p.position-1] = 0;
                        }
                        else{
                            info.allShapes[p.x][p.y][p.position-1] = 1;
                        }
                    }
                }
                canvas.draw(info.allShapes);
                history = cloneArray(info.allShapes);
            }
            @Override
            public void mouseEntered(MouseEvent arg0) {
            }
            @Override
            public void mouseExited(MouseEvent arg0) {
            }
            @Override
            public void mousePressed(MouseEvent arg0) { 
            }
            @Override
            public void mouseReleased(MouseEvent arg0) {    
            }
        });
        startButton.addActionListener(new ActionListener(){
            @Override
            public void actionPerformed(ActionEvent arg0) {
                timer.start();
            }
        });
    }
    public int[][][] cloneArray(int[][][] array){
        int[][][] newArray = new int[array.length][array[0].length][array[0][0].length];
        for(int x = 0;x&lt;array.length;x++){
            int[][] subArray = array[x];
            for(int y = 0; y &lt; subArray.length;y++){
                int subSubArray[] = subArray[y];
                newArray[x][y] = subSubArray.clone();
            }
        }
        return newArray;
    }
    public void restart(){
        timer.stop();
        canvas.draw(info.allShapes);
    }
    public void setUp(){
        int[] boxes = new int[]{2,3,4,6,7,8};
        for(int box:boxes){
            info.allShapes[8][12][box-1] = 1;
            info.allShapes[9][13][box-1] = 1;
            info.allShapes[8][14][box-1] = 1;
            info.allShapes[9][15][box-1] = 1;
        }
    }
    public void update() {
        ArrayList&lt;Coordinate&gt; dieList = new ArrayList&lt;Coordinate&gt;();
        ArrayList&lt;Coordinate&gt; appearList = new ArrayList&lt;Coordinate&gt;();
        for (int x = 0; x &lt; canvas.squaresWide; x++) {
            for (int y = 0; y &lt; canvas.squaresHigh; y++) {
                for(int position = 0;position &lt;9;position++){
                    int alive = info.allShapes[x][y][position];
                    int touching = info.shapesTouching(x, y, position+1);
                    if(touching!=0){
                    }
                    if(alive == 1){
                        if(touching &lt; 2 || touching &gt; 3){
                            //cell dies
                            dieList.add(new Coordinate(x,y,position));
                        }
                    }
                    else{
                        if(touching == 3){
                            //cell appears
                            appearList.add(new Coordinate(x,y,position));
                        }
                    }
                }
            }
        }
        for(Coordinate die:dieList){
            info.allShapes[die.x][die.y][die.position] = 0;
        }
        for(Coordinate live:appearList){
            info.allShapes[live.x][live.y][live.position] = 1;
        }
    }
    boolean firstDraw = true;
    int ticks = 0;
    ActionListener listener = new ActionListener() {
        @Override
        public void actionPerformed(ActionEvent arg0) {
            canvas.draw(info.allShapes);
            if(ticks !=0){
            update();
            }
            ticks++;
        }
    };
}
</code></pre>

<p>Canvas class - </p>

<pre class="lang-java prettyprint-override"><code>import java.awt.Color;
import java.awt.Graphics;
import java.awt.Polygon;
import java.util.ArrayList;

import javax.swing.JPanel;

public class Canvas extends JPanel {
    private static final long serialVersionUID = 1L;

    public int squaresWide = 30;
    public int squaresHigh = 30;
    public int size = 4;
    ArrayList&lt;PolygonInfo&gt; polygons = new ArrayList&lt;PolygonInfo&gt;();
    boolean drawTessalationOnly = true;
    private int[][][] shapes;

    public void draw(int[][][] shapes2) {
        shapes = shapes2;
        drawTessalationOnly = false;
        this.repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        //System.out.println("drawing");
        polygons.clear();
        super.paintComponent(g);
        g.setColor(Color.black);
        // draw tessellation
        for (int x = 0; x &lt; squaresWide; x++) {
            for (int y = 0; y &lt; squaresHigh; y++) {
                for (int position = 1; position &lt;= 9; position++) {
                    // System.out.println("position = " + position);
                    Polygon p = new Polygon();
                    int points = 0;
                    int[] xc = new int[] {};
                    int[] yc = new int[] {};
                    if (position == 1) {
                        xc = new int[] { 0, -2, 0, 2 };
                        yc = new int[] { 2, 0, -2, 0 };
                        points = 4;
                    }
                    if (position == 2) {
                        xc = new int[] { 2, 6, 7, 4, 1 };
                        yc = new int[] { 0, 0, 1, 2, 1 };
                        points = 5;
                    }
                    if (position == 3) {
                        xc = new int[] { 1, 4, 4, 2 };
                        yc = new int[] { 1, 2, 4, 4 };
                        points = 4;
                    }
                    if (position == 4) {
                        xc = new int[] { 4, 4, 7, 6 };
                        yc = new int[] { 4, 2, 1, 4 };
                        points = 4;
                    }
                    if (position == 5) {
                        xc = new int[] { 1, 2, 1, 0, 0 };
                        yc = new int[] { 1, 4, 7, 6, 2 };
                        points = 5;
                    }
                    if (position == 6) {
                        xc = new int[] { 7, 8, 8, 7, 6 };
                        yc = new int[] { 1, 2, 6, 7, 4 };
                        points = 5;
                    }
                    if (position == 7) {
                        xc = new int[] { 4, 2, 1, 4 };
                        yc = new int[] { 4, 4, 7, 6 };
                        points = 4;
                    }
                    if (position == 8) {
                        xc = new int[] { 4, 6, 7, 4 };
                        yc = new int[] { 4, 4, 7, 6 };
                        points = 4;
                    }
                    if (position == 9) {
                        xc = new int[] { 4, 7, 6, 2, 1 };
                        yc = new int[] { 6, 7, 8, 8, 7 };
                        points = 5;
                    }
                    int[] finalX = new int[xc.length];
                    int[] finalY = new int[yc.length];
                    for (int i = 0; i &lt; xc.length; i++) {
                        int xCoord = xc[i];
                        xCoord = (xCoord + (8 * x)) * size;
                        finalX[i] = xCoord;
                    }
                    for (int i = 0; i &lt; yc.length; i++) {
                        int yCoord = yc[i];
                        yCoord = (yCoord + (8 * y)) * size;
                        finalY[i] = yCoord;
                    }
                    p.xpoints = finalX;
                    p.ypoints = finalY;
                    p.npoints = points;
                    polygons.add(new PolygonInfo(p,x,y,position));
                    // for(int i = 0;i&lt;p.npoints;i++){
                    // / System.out.println("(" + p.xpoints[i] + "," +
                    // p.ypoints[i] + ")");
                    // }
                    if (drawTessalationOnly == false) {
                        if (shapes[x][y][position - 1] == 1) {
                            g.fillPolygon(p);
                        } else {
                            g.drawPolygon(p);
                        }
                    } else {
                        g.drawPolygon(p);
                    }
                }

            }
        }
    }
}
</code></pre>

<p>ShapeInfo class - </p>

<pre class="lang-java prettyprint-override"><code>public class ShapeInfo {
    int[][][] allShapes; //first 2 dimensions are coordinates of large square, last is boolean - if shaded
    int width = 20;
    int height = 20;
    public ShapeInfo(int width,int height){
        allShapes = new int[width][height][16];
        for(int[][] i:allShapes){
            for(int[] h:i){
                for(int g:h){
                    g=0;
                }
            }
        }
    }
    public int shapesTouching(int x,int y,int position){
        int t = 0;
        if(x&gt;0 &amp;&amp; y &gt;0 &amp;&amp; x &lt; width-1 &amp;&amp; y &lt; height-1){
        if(position == 1){
            if(allShapes[x][y][2-1] == 1){t++;}
            if(allShapes[x][y][5-1] == 1){t++;}
            if(allShapes[x-1][y][6-1] == 1){t++;}
            if(allShapes[x-1][y][2-1] == 1){t++;}
            if(allShapes[x][y-1][5-1] == 1){t++;}
            if(allShapes[x][y-1][9-1] == 1){t++;}
            if(allShapes[x-1][y-1][9-1] == 1){t++;}
            if(allShapes[x-1][y-1][6-1] == 1){t++;}
            if(allShapes[x][y][3-1] == 1){t++;}
            if(allShapes[x-1][y][4-1] == 1){t++;}
            if(allShapes[x][y-1][7-1] == 1){t++;}
            if(allShapes[x-1][y-1][8-1] == 1){t++;}
        }
        if(position == 2){
            if(allShapes[x][y][3-1] == 1){t++;}
            if(allShapes[x][y][4-1] == 1){t++;}
            if(allShapes[x][y][1-1] == 1){t++;}
            if(allShapes[x][y-1][9-1] == 1){t++;}
            if(allShapes[x+1][y][1-1] == 1){t++;}
            if(allShapes[x][y][6-1] == 1){t++;}
            if(allShapes[x][y][5-1] == 1){t++;}
        }
        if(position == 3){
            if(allShapes[x][y][2-1] == 1){t++;}
            if(allShapes[x][y][5-1] == 1){t++;}
            if(allShapes[x][y][4-1] == 1){t++;}
            if(allShapes[x][y][7-1] == 1){t++;}
            if(allShapes[x][y][1-1] == 1){t++;}
            if(allShapes[x][y][8-1] == 1){t++;}
        }
        if(position == 4){
            if(allShapes[x][y][2-1] == 1){t++;}
            if(allShapes[x][y][6-1] == 1){t++;}
            if(allShapes[x][y][3-1] == 1){t++;}
            if(allShapes[x][y][8-1] == 1){t++;}
            if(allShapes[x][y][7-1] == 1){t++;}
            if(allShapes[x+1][y][1-1] == 1){t++;}
        }
        if(position == 5){
            if(allShapes[x][y][3-1] == 1){t++;}
            if(allShapes[x][y][7-1] == 1){t++;}
            if(allShapes[x][y][1-1] == 1){t++;}
            if(allShapes[x][y+1][1-1] == 1){t++;}
            if(allShapes[x-1][y][6-1] == 1){t++;}
            if(allShapes[x][y][2-1] == 1){t++;}
            if(allShapes[x][y][9-1] == 1){t++;}
        }
        if(position == 6){
            if(allShapes[x][y][4-1] == 1){t++;}
            if(allShapes[x][y][8-1] == 1){t++;}
            if(allShapes[x+1][y][1-1] == 1){t++;}
            if(allShapes[x+1][y][5-1] == 1){t++;}
            if(allShapes[x+1][y+1][1-1] == 1){t++;}
            if(allShapes[x][y][2-1] == 1){t++;}
            if(allShapes[x][y][9-1] == 1){t++;}
        }
        if(position == 7){
            if(allShapes[x][y][3-1] == 1){t++;}
            if(allShapes[x][y][8-1] == 1){t++;}
            if(allShapes[x][y][5-1] == 1){t++;}
            if(allShapes[x][y][9-1] == 1){t++;}
            if(allShapes[x][y][4-1] == 1){t++;}
            if(allShapes[x][y+1][1-1] == 1){t++;}
        }
        if(position == 8){
            if(allShapes[x][y][9-1] == 1){t++;}
            if(allShapes[x][y][6-1] == 1){t++;}
            if(allShapes[x][y][7-1] == 1){t++;}
            if(allShapes[x][y][4-1] == 1){t++;}
            if(allShapes[x][y][3-1] == 1){t++;}
            if(allShapes[x+1][y+1][1-1] == 1){t++;}
        }
        if(position == 9){
            if(allShapes[x][y][7-1] == 1){t++;}
            if(allShapes[x][y][8-1] == 1){t++;}
            if(allShapes[x+1][y+1][1-1] == 1){t++;}
            if(allShapes[x][y+1][2-1] == 1){t++;}
            if(allShapes[x][y+1][1-1] == 1){t++;}
            if(allShapes[x][y][6-1] == 1){t++;}
            if(allShapes[x][y][5-1] == 1){t++;}
        }
        }
        return t;
    }
}
</code></pre>

<p>PolygonInfo class - </p>

<pre class="lang-java prettyprint-override"><code>import java.awt.Polygon;

public class PolygonInfo {
    public Polygon polygon;
    public int x;
    public int y;
    public int position;
    public PolygonInfo(Polygon p,int X,int Y,int Position){
        x = X;
        y = Y;
        polygon = p;
        position = Position;
    }
}
</code></pre>

<p>and finally... Coordinate class</p>

<pre class="lang-java prettyprint-override"><code>public class Coordinate {
    int x;
    int y;
    int position;
    public Coordinate(int X,int Y, int Position){
        x=X;
        y=Y;
        position = Position;
    }
}
</code></pre>
</div>
<div id="pu14" class="pu"><h2><a href="http://en.wikipedia.org/wiki/Rhombitrihexagonal_tiling" rel="noreferrer">Rhombitrihexagonal tiling</a>, 17+ points</h2>

<p>As requested by Martin Büttner.</p>

<p><strong>Still life</strong> (2 points):</p>

<p><img src="https://i.sstatic.net/uDe22.gif" alt="A chain with two loops"></p>

<p><strong>Oscillators</strong> of periods (clockwise from top-left) 2, 4, 5, 6, 11 (15 points):</p>

<p><img src="https://i.sstatic.net/paDbX.gif" alt="Various oscillators"></p>

<p>In general an oscillator has a set of cells which change (the <em>core</em>), a set of cells which neighbour the core (the <em>cladding</em>), and a set of cells which keep the cladding from changing (the <em>support</em>). With this tiling, the support of the oscillators can sometimes overlap: e.g.</p>

<p><img src="https://i.sstatic.net/bSI67.gif" alt="4-oscillator and 5-oscillator with overlapping support"></p>

<p>If the 4-oscillator were removed, the support of the 5-oscillator would fail and it would eventually evolve into a 2-oscillator. But if the 5-oscillator were removed, the support of the 4-oscillator would simply add one hex and stabilise, so this isn't really a 20-oscillator.</p>

<hr>

<p>The code which implements this tiling is extremely generic: building on my experience with an aperiodic tiling, I realised that expanding to a known boundary and doing a lookup by vertex is a very flexible technique, albeit possibly not efficient for simple lattices. But since we're interested in more complex lattices, I've taken that approach here.</p>

<p>Every periodic tiling is a lattice, and it's possible to identify a fundamental unit (in the case of this tiling it's a hexagon, two triangles, and three squares) which is repeated along two axes. Then just supply the axis offsets and the coordinates of the primitive cells of a fundamental unit and you're done.</p>

<p>All of this code can be downloaded as zip at <a href="https://gist.github.com/pjt33/becd56784480ddd751bf" rel="noreferrer">https://gist.github.com/pjt33/becd56784480ddd751bf</a> , and that also includes a <code>GenericLifeGui</code> which I haven't posted on this page.</p>

<pre class="lang-java prettyprint-override"><code>public class Rhombitrihexagonal extends AbstractLattice {
    public Rhombitrihexagonal() {
        super(22, 0, 11, 19, new int[][] {
                {-7, 0, 7, 7, 0, -7},
                {0, 4, 11, 7},
                {7, 11, 15},
                {7, 15, 15, 7},
                {7, 15, 11},
                {7, 11, 4, 0},
            }, new int[][] {
                {4, 8, 4, -4, -8, -4},
                {8, 15, 11, 4},
                {4, 11, 4},
                {4, 4, -4, -4},
                {-4, -4, -11},
                {-4, -11, -15, -8},
            });
    }

    @Override
    public boolean isInterestingOscillationPeriod(int period) {
        return period != 2 &amp;&amp; period != 4 &amp;&amp; period != 5 &amp;&amp; period != 6 &amp;&amp; period != 10 &amp;&amp; period != 12 &amp;&amp; period != 15 &amp;&amp; period != 30;
    }
}
</code></pre>

<p>The support for this is my previously posted generic framework plus the <code>AbstractLattice</code> class:</p>

<pre class="lang-java prettyprint-override"><code>import java.awt.Point;
import java.util.*;

public abstract class AbstractLattice implements Tiling&lt;AbstractLattice.LatticeCell&gt; {
    // Use the idea of expansion and vertex mapping from my earlier aperiod tiling implementation.
    private Map&lt;Point, Set&lt;LatticeCell&gt;&gt; vertexNeighbourhood = new HashMap&lt;Point, Set&lt;LatticeCell&gt;&gt;();
    private int scale = -1;

    // Geometry
    private final int dx0, dy0, dx1, dy1;
    private final int[][] xs;
    private final int[][] ys;

    protected AbstractLattice(int dx0, int dy0, int dx1, int dy1, int[][] xs, int[][] ys) {
        this.dx0 = dx0;
        this.dy0 = dy0;
        this.dx1 = dx1;
        this.dy1 = dy1;
        // Assume sensible subclasses, so no need to clone the arrays to prevent modification.
        this.xs = xs;
        this.ys = ys;
    }

    private void expand() {
        scale++;
        // We want to enumerate all lattice cells whose extreme coordinate is +/- scale.
        // Corners:
        insertLatticeNeighbourhood(-scale, -scale);
        insertLatticeNeighbourhood(-scale, scale);
        insertLatticeNeighbourhood(scale, -scale);
        insertLatticeNeighbourhood(scale, scale);

        // Edges:
        for (int i = -scale + 1; i &lt; scale; i++) {
            insertLatticeNeighbourhood(-scale, i);
            insertLatticeNeighbourhood(scale, i);
            insertLatticeNeighbourhood(i, -scale);
            insertLatticeNeighbourhood(i, scale);
        }
    }

    private void insertLatticeNeighbourhood(int x, int y) {
        for (int sub = 0; sub &lt; xs.length; sub++) {
            LatticeCell cell = new LatticeCell(x, y, sub);
            int[][] bounds = bounds(cell);
            for (int i = 0; i &lt; bounds[0].length; i++) {
                Point p = new Point(bounds[0][i], bounds[1][i]);

                Set&lt;LatticeCell&gt; adj = vertexNeighbourhood.get(p);
                if (adj == null) vertexNeighbourhood.put(p,  adj = new HashSet&lt;LatticeCell&gt;());
                adj.add(cell);
            }
        }
    }

    public Set&lt;LatticeCell&gt; neighbours(LatticeCell cell) {
        Set&lt;LatticeCell&gt; rv = new HashSet&lt;LatticeCell&gt;();

        // +1 because we will border cells from the next scale.
        int requiredScale = Math.max(Math.abs(cell.x), Math.abs(cell.y)) + 1;
        while (scale &lt; requiredScale) expand();

        int[][] bounds = bounds(cell);
        for (int i = 0; i &lt; bounds[0].length; i++) {
            Point p = new Point(bounds[0][i], bounds[1][i]);
            Set&lt;LatticeCell&gt; adj = vertexNeighbourhood.get(p);
            rv.addAll(adj);
        }

        rv.remove(cell);
        return rv;
    }

    public int[][] bounds(LatticeCell cell) {
        int[][] bounds = new int[2][];
        bounds[0] = xs[cell.sub].clone();
        bounds[1] = ys[cell.sub].clone();
        for (int i = 0; i &lt; bounds[0].length; i++) {
            bounds[0][i] += cell.x * dx0 + cell.y * dx1;
            bounds[1][i] += cell.x * dy0 + cell.y * dy1;
        }

        return bounds;
    }

    public LatticeCell initialCell() {
        return new LatticeCell(0, 0, 0);
    }

    public abstract boolean isInterestingOscillationPeriod(int period);

    public Set&lt;LatticeCell&gt; parseCells(String[] data) {
        Set&lt;LatticeCell&gt; rv = new HashSet&lt;LatticeCell&gt;();
        if (data.length % 3 != 0) throw new IllegalArgumentException("Data should come in triples");
        for (int i = 0; i &lt; data.length; i += 3) {
            if (data[i + 2].length() != 1) throw new IllegalArgumentException("Third data item should be a single letter");
            rv.add(new LatticeCell(Integer.parseInt(data[i]), Integer.parseInt(data[i + 1]), data[i + 2].charAt(0) - 'A'));
        }
        return rv;
    }

    public String format(Set&lt;LatticeCell&gt; cells) {
        StringBuilder sb = new StringBuilder();
        for (LatticeCell cell : cells) {
            if (sb.length() &gt; 0) sb.append(' ');
            sb.append(cell.x).append(' ').append(cell.y).append(' ').append((char)(cell.sub + 'A'));
        }

        return sb.toString();
    }

    static class LatticeCell {
        public final int x, y, sub;

        LatticeCell(int x, int y, int sub) {
            this.x = x;
            this.y = y;
            this.sub = sub;
        }

        @Override
        public int hashCode() {
            return (x * 0x100025) + (y * 0x959) + sub;
        }

        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof LatticeCell)) return false;
            LatticeCell other = (LatticeCell)obj;
            return x == other.x &amp;&amp; y == other.y &amp;&amp; sub == other.sub;
        }

        @Override
        public String toString() {
            return x + " " + y + " " + (char)('A' + sub);
        }
    }
}
</code></pre>
</div>
<div id="pu15" class="pu"><h2>Aperiodic <a href="http://www.ics.uci.edu/~eppstein/junkyard/labtile/" rel="noreferrer">Labyrinth tiling</a> (45+ points)</h2>

<p>This uses the generic framework from my earlier answer.</p>

<p><strong>Still life</strong> (2 points):</p>

<p><img src="https://i.sstatic.net/CW4Ay.gif" alt="Labyrinth still life: four triangles meet at an order-12 vertex"></p>

<p><strong>Oscillator</strong> (3 points):</p>

<p><img src="https://i.sstatic.net/l2quv.gif" alt="Oscillator image"></p>

<p>This oscillator is extremely common, turning up in the result of most random starting points.</p>

<p>Code:</p>

<pre><code>import java.awt.Point;
import java.util.*;

public class LabyrinthTiling implements Tiling&lt;String&gt; {
    private Map&lt;Point, Point&gt; internedPoints = new HashMap&lt;Point, Point&gt;();
    private Map&lt;String, Set&lt;Point&gt;&gt; vertices = new HashMap&lt;String, Set&lt;Point&gt;&gt;();
    private Map&lt;Point, Set&lt;String&gt;&gt; tris = new HashMap&lt;Point, Set&lt;String&gt;&gt;();

    private int level = 0;
    // 3^level
    private int scale = 1;

    public LabyrinthTiling() {
        linkSymmetric("", new Point(-8, 0));
        linkSymmetric("", new Point(8, 0));
        linkSymmetric("", new Point(0, 14));
    }

    private void linkSymmetric(String suffix, Point p) {
        int ay = Math.abs(p.y);
        link("+" + suffix, new Point(p.x, ay));
        link("-" + suffix, new Point(p.x, -ay));
    }

    private void link(String tri, Point p) {
        Point p2 = internedPoints.get(p);
        if (p2 == null) internedPoints.put(p, p);
        else p = p2;

        Set&lt;Point&gt; ps = vertices.get(tri);
        if (ps == null) vertices.put(tri, ps = new HashSet&lt;Point&gt;());

        Set&lt;String&gt; ts = tris.get(p);
        if (ts == null) tris.put(p, ts = new HashSet&lt;String&gt;());

        ps.add(p);
        ts.add(tri);
    }

    private void expand() {
        level++;
        scale *= 3;
        subdivideEq("", new Point(-8 * scale, 0), new Point(8 * scale, 0), new Point(0, 14 * scale), level, true);
    }

    private static Point avg(Point p0, Point p1, Point p2) {
        return new Point((p0.x + p1.x + p2.x) / 3, (p0.y + p1.y + p2.y) / 3);
    }

    private void subdivideEq(String suffix, Point p0, Point p1, Point p2, int level, boolean skip0) {
        if (level == 0) {
            linkSymmetric(suffix, p0);
            linkSymmetric(suffix, p1);
            linkSymmetric(suffix, p2);
            return;
        }

        Point p01 = avg(p0, p0, p1), p10 = avg(p0, p1, p1);
        Point p02 = avg(p0, p0, p2), p20 = avg(p0, p2, p2);
        Point p12 = avg(p1, p1, p2), p21 = avg(p1, p2, p2);
        Point c = avg(p0, p1, p2);
        level--;

        if (!skip0) subdivideEq(suffix + "0", p01, p10, c, level, false);
        subdivideIso(suffix + "1", p0, c, p01, level);
        subdivideIso(suffix + "2", p0, c, p02, level);
        subdivideEq(suffix + "3", p02, c, p20, level, false);
        subdivideIso(suffix + "4", p2, c, p20, level);
        subdivideIso(suffix + "5", p2, c, p21, level);
        subdivideEq(suffix + "6", c, p12, p21, level, false);
        subdivideIso(suffix + "7", p1, c, p12, level);
        subdivideIso(suffix + "8", p1, c, p10, level);
    }

    private void subdivideIso(String suffix, Point p0, Point p1, Point p2, int level) {
        if (level == 0) {
            linkSymmetric(suffix, p0);
            linkSymmetric(suffix, p1);
            linkSymmetric(suffix, p2);
            return;
        }

        Point p01 = avg(p0, p0, p1), p10 = avg(p0, p1, p1);
        Point p02 = avg(p0, p0, p2), p20 = avg(p0, p2, p2);
        Point p12 = avg(p1, p1, p2), p21 = avg(p1, p2, p2);
        Point c = avg(p0, p1, p2);
        level--;

        subdivideIso(suffix + "0", p0, p01, p02, level);
        subdivideEq(suffix + "1", p01, p02, p20, level, false);
        subdivideIso(suffix + "2", p01, p2, p20, level);
        subdivideIso(suffix + "3", p01, p2, c, level);
        subdivideIso(suffix + "4", p01, p10, c, level);
        subdivideIso(suffix + "5", p10, p2, c, level);
        subdivideIso(suffix + "6", p10, p2, p21, level);
        subdivideEq(suffix + "7", p10, p12, p21, level, false);
        subdivideIso(suffix + "8", p1, p10, p12, level);
    }

    public Set&lt;String&gt; neighbours(String cell) {
        Set&lt;String&gt; rv = new HashSet&lt;String&gt;();

        Set&lt;Point&gt; cellVertices;
        while ((cellVertices = vertices.get(cell)) == null) expand();
        for (Point p : cellVertices) {
            // If the point is on the edge of the current level, we need to expand once more.
            if (Math.abs(p.x) / 8 + Math.abs(p.y) / 14 == scale) expand();

            Set&lt;String&gt; adj = tris.get(p);
            rv.addAll(adj);
        }

        rv.remove(cell);
        return rv;
    }

    public int[][] bounds(String cell) {
        Set&lt;Point&gt; cellVertices;
        while ((cellVertices = vertices.get(cell)) == null) expand();

        int[][] bounds = new int[2][3];
        int off = 0;
        for (Point p : cellVertices) {
            bounds[0][off] = p.x;
            bounds[1][off] = p.y;
            off++;
        }

        return bounds;
    }

    public String initialCell() {
        return "+";
    }

    public boolean isInterestingOscillationPeriod(int period) {
        return period != 4;
    }

    public Set&lt;String&gt; parseCells(String[] data) {
        Set&lt;String&gt; rv = new HashSet&lt;String&gt;();
        for (String cell : data) rv.add(cell);
        return rv;
    }

    public String format(Set&lt;String&gt; cells) {
        StringBuilder sb = new StringBuilder();
        for (String cell : cells) {
            if (sb.length() &gt; 0) sb.append(' ');
            sb.append(cell);
        }

        return sb.toString();
    }
}
</code></pre>
</div>
<div id="pu16" class="pu"><h1>C++ w/ OpenGL (+17)</h1>

<p>So I tried 3-Isohedral convex pentagon grid. Works for me ;) Standard game of life rules apply, except the grid is not infinite - there are border cells outside the image. 30% of the cells are initially alive. </p>

<p><strong>This is how the grid looks like:</strong></p>

<p><img src="https://i.sstatic.net/bAMBe.gif" alt="enter image description here"></p>

<p><strong>The live version:</strong></p>

<p>Blue cells are alive, white are dead. Red cells just died, green were just born. Note that the artifacts in the image are the result of gif compression, SO doesn't like 10MB gifs :(.</p>

<p><img src="https://i.sstatic.net/fqJHf.gif" alt="enter image description here"></p>

<p><strong>Still life:</strong> (+2)</p>

<p><img src="https://i.sstatic.net/H4TEd.png" alt="enter image description here"></p>

<p><strong>Oscillators T=2, T=3, T=12:</strong> (+9)</p>

<p><img src="https://i.sstatic.net/dw18h.gif" alt="enter image description here">
<img src="https://i.sstatic.net/gHzDs.gif" alt="enter image description here"></p>

<p><strong>Oscillators T=6 , T=7:</strong> (+6)</p>

<p><img src="https://i.sstatic.net/5257y.gif" alt="enter image description here"></p>

<p>There are many more different oscillators... But it seems that the grid is not regular enough for a ship...</p>

<p><strong>This is nothing (no points), but I like it:</strong></p>

<p><img src="https://i.sstatic.net/iRSn3.gif" alt="enter image description here"></p>

<p>The code is a mess :) Uses some ancient fixed OpenGL. Otherwise used GLEW, GLFW, GLM and ImageMagick for gif export. </p>

<pre class="lang-cpp prettyprint-override"><code>/**
 * Tile pattern generation is inspired by the code 
 * on http://www.jaapsch.net/tilings/
 * It saved me a lot of thinkink (and debugging) - thank you, sir!
 */

#include &lt;GL/glew.h&gt;
#include &lt;GLFW/glfw3.h&gt;
#include &lt;FTGL/ftgl.h&gt;  //debug only
#include &lt;ImageMagick-6/Magick++.h&gt; //gif export
#include "glm/glm.hpp" 

#include &lt;iostream&gt;
#include &lt;array&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;unistd.h&gt;

typedef glm::vec2 Point;
typedef glm::vec3 Color;

struct Tile {
    enum State {ALIVE=0, DEAD, BORN, DIED, SIZE};

    static const int VERTICES = 5;
    static constexpr float SCALE = 0.13f;
    static constexpr std::array&lt;std::array&lt;int, 7&gt;, 18&gt; DESC 
    {{
        {{1, 0,0, 0,0,0, 0}},
        {{0, 1,2, 0,2,1, 0}},
        {{2, 2,3, 0,2,3, 1}},
        {{1, 0,4, 0,0,1, 0}},
        {{0, 1,2, 3,2,1, 0}},
        {{2, 2,3, 3,2,3, 1}},
        {{1, 0,4, 3,0,1, 0}},
        {{0, 1,2, 6,2,1, 0}},
        {{2, 2,3, 6,2,3, 1}},
        {{1, 0,4, 6,0,1, 0}},
        {{0, 1,2, 9,2,1, 0}},
        {{2, 2,3, 9,2,3, 1}},
        {{1, 0,4, 9,0,1, 0}},
        {{0, 1,2,12,2,1, 0}},
        {{2, 2,3,12,2,3, 1}},
        {{1, 0,4,12,0,1, 0}},
        {{0, 1,2,15,2,1, 0}},
        {{2, 2,3,15,2,3, 1}}
    }};

    const int ID;
    std::vector&lt;Point&gt; coords;
    std::set&lt;Tile*&gt; neighbours;
    State state;
    State nextState;
    Color color;

    Tile() : ID(-1), state(DEAD), nextState(DEAD), color(1, 1, 1) {
        const float ln = 0.6f;
        const float h = ln * sqrt(3) / 2.f;
        coords = {
            Point(0.f,      0.f), 
            Point(ln,       0.f), 
            Point(ln*3/2.f,h), 
            Point(ln,       h*4/3.f), 
            Point(ln/2.f,   h)
        };
        for(auto &amp;c : coords) {
            c *= SCALE;
        }
    }

    Tile(const int id, const std::vector&lt;Point&gt; coords_) : 
        ID(id), coords(coords_), state(DEAD), nextState(DEAD), color(1, 1, 1) {}

    bool operator== (const Tile &amp;other) const {
        return ID == other.ID;
    }

    const Point &amp; operator[] (const int i) const {
        return coords[i];
    }
    void updateState() {
        state = nextState;
    }
    /// returns "old" state
    bool isDead() const {
        return state == DEAD || state == DIED;
    }
    /// returns "old" state
    bool isAlive() const {
        return state == ALIVE || state == BORN;
    }

    void translate(const Point &amp;p) {
       for(auto &amp;c : coords) {
           c += p;
       }
    }

    void rotate(const Point &amp;p, const float angle) {
        const float si = sin(angle);
        const float co = cos(angle);
        for(auto &amp;c : coords) {
            Point tmp = c - p;
            c.x = tmp.x * co - tmp.y * si + p.x;
            c.y = tmp.y * co + tmp.x * si + p.y;
        }      
    }

    void mirror(const float y2) {
       for(auto &amp;c : coords) {
          c.y = y2 - (c.y - y2);
       }
    }

};
std::array&lt;std::array&lt;int, 7&gt;, 18&gt; constexpr Tile::DESC;
constexpr float Tile::SCALE;

class Game {
    static const int    CHANCE_TO_LIVE  = 30;       //% of cells initially alive
    static const int    dim             = 4;        //evil grid param

    FTGLPixmapFont &amp;font;
    std::vector&lt;Tile&gt; tiles;
    bool animate; //animate death/birth
    bool debug; //show cell numbers (very slow)
    bool exportGif;     //save gif
    bool run;

public: 
    Game(FTGLPixmapFont&amp; font) : font(font), animate(false), debug(false), exportGif(false), run(false) {
        //create the initial pattern
        std::vector&lt;Tile&gt; init(18);
        for(int i = 0; i &lt; Tile::DESC.size(); ++i) {
            auto &amp;desc = Tile::DESC[i];
            Tile &amp;tile = init[i];
            switch(desc[0]) {   //just to check the grid
                case 0: tile.color = Color(1, 1, 1);break;
                case 1: tile.color = Color(1, 0.7, 0.7);break;
                case 2: tile.color = Color(0.7, 0.7, 1);break;
            }

            if(desc[3] != i) {
                const Tile &amp;tile2 = init[desc[3]];
                tile.translate(tile2[desc[4]] - tile[desc[1]]);
                if(desc[6] != 0) {
                   float angleRad = getAngle(tile[desc[1]], tile[desc[2]]);
                   tile.rotate(tile[desc[1]], -angleRad);
                   tile.mirror(tile[desc[1]].y);
                   angleRad = getAngle(tile[desc[1]], tile2[desc[5]]);
                   tile.rotate(tile[desc[1]], angleRad);
                }
                else {
                   float angleRad = getAngle(tile[desc[1]], tile[desc[2]], tile2[desc[5]]);
                   tile.rotate(tile[desc[1]], angleRad);
                }
            }
        }

        const float offsets[4] {
            init[2][8].x - init[8][9].x,
            init[2][10].y - init[8][11].y,
            init[8][12].x - init[14][13].x,
            init[8][14].y - init[14][15].y 
        };

        // create all the tiles
        for(int dx = -dim; dx &lt;= dim; ++dx) { //fuck bounding box, let's hardcode it
            for(int dy = -dim; dy &lt;= dim; ++dy) {

                for(auto &amp;tile : init) {
                    std::vector&lt;Point&gt; vert;
                    for(auto &amp;p : tile.coords) {
                        float ax = dx * offsets[0] + dy * offsets[2];
                        float ay = dx * offsets[1] + dy * offsets[3];
                        vert.push_back(Point(p.x + ax, p.y + ay));
                    }
                    tiles.push_back(Tile(tiles.size(), vert));
                    tiles.back().color = tile.color;
                    tiles.back().state = tile.state;
                }
            }
        }

        //stupid bruteforce solution, but who's got time to think..
        for(Tile &amp;tile : tiles) { //find neighbours for each cell 
            for(Tile &amp;t : tiles) {
                if(tile == t) continue;
                for(Point &amp;p : t.coords) {
                    for(Point &amp;pt : tile.coords) {
                        if(glm::distance(p, pt) &lt; 0.01 ) {
                            tile.neighbours.insert(&amp;t);
                            break;
                        }
                    }
                }
            }
            assert(tile.neighbours.size() &lt;= 9);
        }   
    }

    void init() {
        for(auto &amp;t : tiles) {
            if(rand() % 100 &lt; CHANCE_TO_LIVE) {
                t.state = Tile::BORN;
            }
            else {
                t.state = Tile::DEAD;           
            }
        }
    }

    void update() {
        for(auto &amp;tile: tiles) {
            //check colors
            switch(tile.state) {
                case Tile::BORN:    //animate birth
                    tile.color.g -= 0.05;
                    tile.color.b += 0.05;
                    if(tile.color.b &gt; 0.9) {
                        tile.state = Tile::ALIVE;
                    }
                    break;
                case Tile::DIED:    //animate death
                    tile.color += 0.05;
                    if(tile.color.g &gt; 0.9) {
                        tile.state = Tile::DEAD;
                    }
                    break;
            }
            //fix colors after animation
            switch(tile.state) {
                case Tile::ALIVE:
                    tile.color = Color(0, 0, 1);
                    break;
                case Tile::DEAD:
                    tile.color = Color(1, 1, 1);
                    break;
            }

            //draw polygons
            glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
            glBegin(GL_POLYGON);
            glColor3f(tile.color.r, tile.color.g, tile.color.b);
            for(auto &amp;pt : tile.coords) {
                glVertex2f(pt.x, pt.y); //haha so oldschool!
            }
            glEnd();
        }

        //draw grid
        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
        glColor3f(0, 0, 0);
        for(auto &amp;tile : tiles) {
            glBegin(GL_POLYGON);
            Point c;    //centroid of tile
            for(auto &amp;pt : tile.coords) {
                glVertex2f(pt.x, pt.y);
                c += pt;
            }
            glEnd();
            if(debug) {
                c /= (float) Tile::VERTICES;
                glRasterPos2f(c.x - 0.025, c.y - 0.01);
                font.Render(std::to_string(tile.ID).c_str()); // 
            }
        }

        if(!run) {
            return;
        }

        //compute new generation
        for(Tile &amp;tile: tiles) {

            tile.nextState = tile.state; //initialize next state
            int c = 0;
            for(auto *n : tile.neighbours) {
                if(n-&gt;isAlive()) c++;
            }
            switch(c) {
                case 2:
                    break;
                case 3:
                    if(tile.isDead()) {
                        tile.nextState = animate ? Tile::BORN : Tile::ALIVE;
                        tile.color = Color(0, 1, 0);
                    }
                    break;
                default:
                    if(tile.isAlive()) {
                        tile.nextState = animate ? Tile::DIED : Tile::DEAD;
                        tile.color = Color(1, 0, 0);
                    }
                    break;
            }
        }
        //switch state to new
        for(Tile &amp;tile: tiles) {
            tile.updateState();
        }
    }

    void stop() {run = false;}
    void switchRun() {run = !run;}
    bool isRun() {return run;}
    void switchAnim() {animate = !animate;}
    bool isAnim() {return animate;}
    void switchExportGif() {exportGif = !exportGif;}
    bool isExportGif() {return exportGif;}
    void switchDebug() {debug = !debug;}
    bool isDebug() const {return debug;}
 private:
    static float getAngle(const Point &amp;p0, const Point &amp;p1, Point const &amp;p2) {
       return atan2(p2.y - p0.y, p2.x - p0.x) - atan2(p1.y - p0.y, p1.x - p0.x);
    }

    static float getAngle(const Point &amp;p0, const Point &amp;p1) {
       return atan2(p1.y - p0.y, p1.x - p0.x);
    }
};

class Controlls {
    Game *game;
    std::vector&lt;Magick::Image&gt; *gif;
    Controlls() : game(nullptr), gif(nullptr) {}
public:
    static Controlls&amp; getInstance() {
        static Controlls instance;
        return instance;
    }

    static void keyboardAction(GLFWwindow* window, int key, int scancode, int action, int mods) {
        getInstance().keyboardActionImpl(key, action);
    }

    void setGame(Game *game) {
        this-&gt;game = game;
    }
    void setGif(std::vector&lt;Magick::Image&gt; *gif) {
        this-&gt;gif = gif;
    }
private:    
    void keyboardActionImpl(int key, int action) {
        if(!game || action == GLFW_RELEASE) {
            return;
        }
        switch (key) {
            case 'R':
                game-&gt;stop();
                game-&gt;init();
                if(gif) gif-&gt;clear();
                break;
            case GLFW_KEY_SPACE:
                game-&gt;switchRun();
                break;
            case 'A':
                game-&gt;switchAnim();
                break;
            case 'D':
                game-&gt;switchDebug();
                break;
                break;
            case 'G':
                game-&gt;switchExportGif();
                break;
        };
    }
};

int main(int argc, char** argv) {
    const int width         = 620;      //window size
    const int height        = 620;
    const std::string window_title  ("Game of life!");
    const std::string font_file     ("/usr/share/fonts/truetype/arial.ttf");
    const std::string gif_file      ("./gol.gif");

    if(!glfwInit()) return 1;

    GLFWwindow* window = glfwCreateWindow(width, height, window_title.c_str(), NULL, NULL);
    glfwSetWindowPos(window, 100, 100);
    glfwMakeContextCurrent(window);

    GLuint err = glewInit();
    if (err != GLEW_OK) return 2;

    FTGLPixmapFont font(font_file.c_str());
    if(font.Error()) return 3;
    font.FaceSize(8);

    std::vector&lt;Magick::Image&gt; gif; //gif export
    std::vector&lt;GLfloat&gt; pixels(3 * width * height);

    Game gol(font);
    gol.init();
    Controlls &amp;controlls = Controlls::getInstance();
    controlls.setGame(&amp;gol);
    controlls.setGif(&amp;gif);

    glfwSetKeyCallback(window, Controlls::keyboardAction);

    glClearColor(1.f, 1.f, 1.f, 0);
    while(!glfwWindowShouldClose(window) &amp;&amp; !glfwGetKey(window, GLFW_KEY_ESCAPE)) {
        glClear(GL_COLOR_BUFFER_BIT);

        gol.update();

        //add layer to gif
        if(gol.isExportGif()) {
            glReadPixels(0, 0, width, height, GL_RGB, GL_FLOAT, &amp;pixels[0]);
            Magick::Image image(width, height, "RGB", Magick::FloatPixel, &amp;pixels[0]);
            image.animationDelay(50);
            gif.push_back(image);
        }

        std::string info = "ANIMATE (A): ";
        info += gol.isAnim() ? "ON " : "OFF";
        info += " | DEBUG (D): ";
        info += gol.isDebug() ? "ON " : "OFF";
        info += " | EXPORT GIF (G): ";
        info += gol.isExportGif() ? "ON " : "OFF";
        info += gol.isRun() ? " | STOP (SPACE)" : " | START (SPACE)";
        font.FaceSize(10);
        glRasterPos2f(-.95f, -.99f);
        font.Render(info.c_str());

        if(gol.isDebug()) font.FaceSize(8);
        if(!gol.isDebug()) usleep(50000); //not so fast please!

        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    //save gif to file
    if(gol.isExportGif()) {
        std::cout &lt;&lt; "saving " &lt;&lt; gif.size() &lt;&lt; " frames to gol.gif\n";
        gif.back().write("./last.png");
        Magick::writeImages(gif.begin(), gif.end(), gif_file);
    }

    glfwTerminate();
    return 0;
}
</code></pre>
</div>
<div id="pu17" class="pu"><h1>Python</h1>
<p>I place multiple points on a metatile, which is then copied periodically in a rectangular or hexagonal tiling (the metatiles are allowed to overlap).
From the set of all points i then compute the Voronoi diagram which makes up my grid.</p>
<h1>Some older examples</h1>
<p>Random graph, the Delaunay trinagulation is shown which is also used internally to find the neighbours</p>
<p><img src="https://i.sstatic.net/8pN43.gif" alt="Graph of Life" /></p>
<p>A periodic tiling which spells <code>GoL</code></p>
<p><img src="https://i.sstatic.net/j4x2C.gif" alt="enter image description here" /></p>
<p>Some more grids showing still lifes</p>
<p><img src="https://i.sstatic.net/ebfK9.png" alt="enter image description here" /></p>
<p>For any such grid there is a huge amount of still lifes with a wide variety of sizes, and some small 2-, 3- or 5-cycle oscillators, but I haven't found any gliders, probably due to the irregularities of the grid. I think about automatizing the search for lifeforms by checking cells for periodic oscillations.</p>
<pre><code>import networkx as nx
from scipy.spatial import Delaunay, Voronoi
from scipy.spatial._plotutils import _held_figure, _adjust_bounds
from numpy import *
import matplotlib.pyplot as plt

# copied from scipy.spatial._plotutils
@_held_figure
def voronoi_plot_2d(vor, ax=None):
    for simplex in vor.ridge_vertices:
        simplex = asarray(simplex)
        if all(simplex &gt;= 0):
            ax.plot(vor.vertices[simplex,0], vor.vertices[simplex,1], 'k-')
    center = vor.points.mean(axis=0)  
    _adjust_bounds(ax, vor.points)
    return ax.figure

def maketilegraph(tile, offsetx, offsety, numx, numy, hexa=0):
    # tile: list of (x,y) coordinates
    # hexa=0: rectangular tiling
    # hexa=1: hexagonal tiling
    R = array([offsetx,0])
    U = array([0,offsety]) - hexa*R/2
    points = concatenate( [tile+n*R for n in range(numx)])
    points = concatenate( [points+n*U for n in range(numy)])
    
    pos = dict(enumerate(points))
    D = Delaunay(points)

    graph = nx.Graph()
    for tri in D.vertices:
        graph.add_cycle(tri)    
    return graph, pos, Voronoi(points)

def rule(old_state, Nalive):
    if Nalive&lt;2: old_state = 0
    if Nalive==3: old_state = 1
    if Nalive&gt;3: old_state = 0
    return old_state

def propagate(graph):
    for n in graph: # compute the new state
        Nalive = sum([graph.node[m]['alive'] for m in graph.neighbors(n)])
        graph.node[n]['alive_temp'] = rule(graph.node[n]['alive'], Nalive)
    for n in graph: # apply the new state
        graph.node[n]['alive'] = graph.node[n]['alive_temp']

def drawgraph(graph):
    nx.draw_networkx_nodes(graph,pos,
                        nodelist=[n for n in graph if graph.node[n]['alive']],
                        node_color='k', node_size=150)
    # nx.draw_networkx_nodes(graph,pos,
                        # nodelist=[n for n in graph if not graph.node[n]['alive']],
                        # node_color='y', node_size=25, alpha=0.5)
    # nx.draw_networkx_edges(graph,pos, width=1, alpha=0.2, edge_color='b')

##################
# Lets get started
p_alive = 0.4   # initial fill ratio

#tile = random.random((6,2))
a = [.3*exp(2j*pi*n/5) for n in range(5)] +[.5+.5j, 0]
tile = array(zip(real(a), imag(a)))
grid, pos, vor = maketilegraph(tile, 1.,1.,8,8, hexa=1)

for n in grid: # initial fill
    grid.node[n]['alive'] = random.random() &lt; p_alive #random fill
    # grid.node[n]['alive'] = n%5==0 or n%3==0    # periodic fill

for i in range(45):propagate(grid) # run until convergence

for i in range(7):
    print i
    voronoi_plot_2d(vor)
    drawgraph(grid)
    plt.axis('off')
    plt.savefig('GoL %.3d.png'%i, bbox_inches='tight')
    plt.close()
    propagate(grid)
</code></pre>
</div>
<div id="pu18" class="pu"><h2><a href="http://en.wikipedia.org/wiki/Cairo_pentagonal_tiling" rel="noreferrer">Cairo pentagonal tiling</a> (+ generic framework), 17+ points</h2>

<p>This tiling is surprisingly easy to draw: the key is that the only irrational number which is important for drawing it, <code>sqrt(3)</code>, is very close to the rational number <code>7/4</code>, which has the added bonus that if you subtract <code>1</code> from the numerator and denominator you get <code>6/3 = 2</code>, so that the non-axis-aligned lines are nicely symmetric.</p>

<p>If you want grid paper, I've created a <a href="https://gist.github.com/pjt33/c24507d183723c7690e4" rel="noreferrer">PostScript gist</a> for A4. Feel free to fork it for other paper sizes.</p>

<p>The code is generic enough to support other tilings. The interface which needs to be implemented is:</p>

<pre class="lang-java prettyprint-override"><code>import java.util.Set;

interface Tiling&lt;Cell&gt; {
    /** Calculates the neighbourhood, which should not include the cell itself. */
    public Set&lt;Cell&gt; neighbours(Cell cell);
    /** Gets an array {xs, ys} of polygon vertices. */
    public int[][] bounds(Cell cell);
    /** Starting cell for random generation. This doesn't need to be consistent. */
    public Cell initialCell();
    /** Allows exclusion of common oscillations in random generation. */
    public boolean isInterestingOscillationPeriod(int period);
    /** Parse command-line input. */
    public Set&lt;Cell&gt; parseCells(String[] data);
}
</code></pre>

<p>Then the Cairo tiling is:</p>

<pre class="lang-java prettyprint-override"><code>import java.awt.Point;
import java.util.*;

/**
 * http://en.wikipedia.org/wiki/Cairo_pentagonal_tiling
 */
class CairoTiling implements Tiling&lt;Point&gt; {
    private static final int[][] SHAPES_X = new int[][] {
        { 0, 4, 11, 11, 4 },
        { 11, 4, 8, 14, 18 },
        { 11, 18, 14, 8, 4 },
        { 22, 18, 11, 11, 18 }
    };
    private static final int[][] SHAPES_Y = new int[][] {
        { 0, 7, 3, -3, -7 },
        { 3, 7, 14, 14, 7 },
        { -3, -7, -14, -14, -7 },
        { 0, -7, -3, 3, 7 }
    };

    public Set&lt;Point&gt; neighbours(Point cell) {
        Set&lt;Point&gt; neighbours = new HashSet&lt;Point&gt;();
        int exclx = (cell.y &amp; 1) == 0 ? -1 : 1;
        int excly = (cell.x &amp; 1) == 0 ? -1 : 1;
        for (int dx = -1; dx &lt;= 1; dx++) {
            for (int dy = -1; dy &lt;= 1; dy++) {
                if (dx == 0 &amp;&amp; dy == 0) continue;
                if (dx == exclx &amp;&amp; dy == excly) continue;
                neighbours.add(new Point(cell.x + dx, cell.y + dy));
            }
        }

        return neighbours;
    }

    public int[][] bounds(Point cell) {
        int x = cell.x, y = cell.y;

        int[] xs = SHAPES_X[(x &amp; 1) + 2 * (y &amp; 1)].clone();
        int[] ys = SHAPES_Y[(x &amp; 1) + 2 * (y &amp; 1)].clone();
        int xoff = 7 * (x &amp; ~1) + 7 * (y &amp; ~1);
        int yoff = 7 * (x &amp; ~1) - 7 * (y &amp; ~1);

        for (int i = 0; i &lt; 5; i++) {
            xs[i] += xoff;
            ys[i] += yoff;
        }

        return new int[][] { xs, ys };
    }

    public Point initialCell() { return new Point(0, 0); }

    public boolean isInterestingOscillationPeriod(int period) {
        // Period 6 oscillators are extremely common, and period 2 fairly common.
        return period != 2 &amp;&amp; period != 6;
    }

    public Set&lt;Point&gt; parseCells(String[] data) {
        if ((data.length &amp; 1) == 1) throw new IllegalArgumentException("Expect pairs of integers");

        Set&lt;Point&gt; cells = new HashSet&lt;Point&gt;();
        for (int i = 0; i &lt; data.length; i += 2) {
            cells.add(new Point(Integer.parseInt(data[i]), Integer.parseInt(data[i + 1])));
        }

        return cells;
    }
}
</code></pre>

<p>and the control code is</p>

<pre class="lang-java prettyprint-override"><code>import java.awt.*;
import java.awt.image.*;
import java.io.*;
import java.util.*;
import java.util.List;
import javax.imageio.*;
import javax.imageio.metadata.*;
import javax.imageio.stream.*;
import org.w3c.dom.Node;

/**
 * Implements a Life-like cellular automaton on a generic grid.
 * http://codegolf.stackexchange.com/q/35827/194
 *
 * TODOs:
 *  - Allow a special output format for gliders which moves the bounds at an appropriate speed and doesn't extend the last frame
 *  - Allow option to control number of generations
 */
public class GenericLife {
    private static final Color GRIDCOL = new Color(0x808080);
    private static final Color DEADCOL = new Color(0xffffff);
    private static final Color LIVECOL = new Color(0x0000ff);

    private static final int MARGIN = 15;

    private static void usage() {
        System.out.println("Usage: java GenericLife &lt;tiling&gt; [&lt;output.gif&gt; &lt;cell-data&gt;]");
        System.out.println("For CairoTiling, cell data is pairs of integers");
        System.out.println("For random search, supply just the tiling name");
        System.exit(1);
    }

    // Unchecked warnings due to using reflection to instantation tiling over unknown cell type
    @SuppressWarnings("unchecked")
    public static void main(String[] args) throws Exception {
        if (args.length == 0 || args[0].equals("--help")) usage();

        Tiling tiling = (Tiling)Class.forName(args[0]).newInstance();
        if (args.length &gt; 1) {
            String[] cellData = new String[args.length - 2];
            System.arraycopy(args, 2, cellData, 0, cellData.length);
            Set alive;
            try { alive = tiling.parseCells(cellData); }
            catch (Exception ex) { usage(); return; }

            createAnimatedGif(args[1], tiling, evolve(tiling, alive, 100));
        }
        else search(tiling);
    }

    private static &lt;Cell&gt; void search(Tiling&lt;Cell&gt; tiling) throws IOException {
        while (true) {
            // Build a starting generation within a certain radius of the initial cell.
            // This is a good place to tweak.
            Set&lt;Cell&gt; alive = new HashSet&lt;Cell&gt;();
            double density = Math.random();
            Set&lt;Cell&gt; visited = new HashSet&lt;Cell&gt;();
            Set&lt;Cell&gt; boundary = new HashSet&lt;Cell&gt;();
            boundary.add(tiling.initialCell());
            for (int r = 0; r &lt; 10; r++) {
                visited.addAll(boundary);
                Set&lt;Cell&gt; nextBoundary = new HashSet&lt;Cell&gt;();
                for (Cell cell : boundary) {
                    if (Math.random() &lt; density) alive.add(cell);
                    for (Cell neighbour : tiling.neighbours(cell)) {
                        if (!visited.contains(neighbour)) nextBoundary.add(neighbour);
                    }
                }

                boundary = nextBoundary;
            }

            final int MAX = 1000;
            List&lt;Set&lt;Cell&gt;&gt; gens = evolve(tiling, alive, MAX);
            // Long-lived starting conditions might mean a glider, so are interesting.
            boolean interesting = gens.size() == MAX;
            String desc = "gens-" + MAX;
            if (!interesting) {
                // We hit some oscillator - but was it an interesting one?
                int lastGen = gens.size() - 1;
                gens = evolve(tiling, gens.get(lastGen), gens.size());
                if (gens.size() &gt; 1) {
                    int period = gens.size() - 1;
                    desc = "oscillator-" + period;
                    interesting = tiling.isInterestingOscillationPeriod(period);
                    System.out.println("Oscillation of period " + period);
                }
                else {
                    String result = gens.get(0).isEmpty() ? "Extinction" : "Still life";
                    System.out.println(result + " at gen " + lastGen);
                }
            }

            if (interesting) {
                String filename = System.getProperty("java.io.tmpdir") + "/" + tiling.getClass().getSimpleName() + "-" + System.nanoTime() + "-" + desc + ".gif";
                createAnimatedGif(filename, tiling, gens);
                System.out.println("Wrote " + gens.size() + " generations to " + filename);
            }
        }
    }

    private static &lt;Cell&gt; List&lt;Set&lt;Cell&gt;&gt; evolve(Tiling&lt;Cell&gt; tiling, Set&lt;Cell&gt; gen0, int numGens) {
        Map&lt;Set&lt;Cell&gt;, Integer&gt; firstSeen = new HashMap&lt;Set&lt;Cell&gt;, Integer&gt;();
        List&lt;Set&lt;Cell&gt;&gt; gens = new ArrayList&lt;Set&lt;Cell&gt;&gt;();
        gens.add(gen0);
        firstSeen.put(gen0, 0);

        Set&lt;Cell&gt; alive = gen0;
        for (int gen = 1; gen &lt; numGens; gen++) {
            if (alive.size() == 0) break;

            Set&lt;Cell&gt; nextGen = nextGeneration(tiling, alive);
            Integer prevSeen = firstSeen.get(nextGen);
            if (prevSeen != null) {
                if (gen - prevSeen &gt; 1) gens.add(nextGen); // Finish the loop.
                break;
            }

            alive = nextGen;
            gens.add(alive);
            firstSeen.put(alive, gen);
        }

        return gens;
    }

    private static &lt;Cell&gt; void createAnimatedGif(String filename, Tiling&lt;Cell&gt; tiling, List&lt;Set&lt;Cell&gt;&gt; gens) throws IOException {
        OutputStream out = new FileOutputStream(filename);
        ImageWriter imgWriter = ImageIO.getImageWritersByFormatName("gif").next();
        ImageOutputStream imgOut = ImageIO.createImageOutputStream(out);
        imgWriter.setOutput(imgOut);
        imgWriter.prepareWriteSequence(null);

        Rectangle bounds = bbox(tiling, gens);
        Set&lt;Cell&gt; gen0 = gens.get(0);
        int numGens = gens.size();

        for (int gen = 0; gen &lt; numGens; gen++) {
            Set&lt;Cell&gt; alive = gens.get(gen);

            // If we have an oscillator which loops cleanly back to the start, skip the last frame.
            if (gen &gt; 0 &amp;&amp; alive.equals(gen0)) break;

            writeGifFrame(imgWriter, render(tiling, bounds, alive), gen == 0, gen == numGens - 1);
        }

        imgWriter.endWriteSequence();
        imgOut.close();
        out.close();
    }

    private static &lt;Cell&gt; Rectangle bbox(Tiling&lt;Cell&gt; tiling, Collection&lt;? extends Collection&lt;Cell&gt;&gt; gens) {
        Rectangle bounds = new Rectangle(-1, -1);
        Set&lt;Cell&gt; allGens = new HashSet&lt;Cell&gt;();
        for (Collection&lt;Cell&gt; gen : gens) allGens.addAll(gen);
        for (Cell cell : allGens) {
            int[][] cellBounds = tiling.bounds(cell);
            int[] xs = cellBounds[0], ys = cellBounds[1];
            for (int i = 0; i &lt; xs.length; i++) bounds.add(xs[i], ys[i]);
        }

        bounds.grow(MARGIN, MARGIN);
        return bounds;
    }

    private static void writeGifFrame(ImageWriter imgWriter, BufferedImage img, boolean isFirstFrame, boolean isLastFrame) throws IOException {
        IIOMetadata metadata = imgWriter.getDefaultImageMetadata(new ImageTypeSpecifier(img), null);

        String metaFormat = metadata.getNativeMetadataFormatName();
        Node root = metadata.getAsTree(metaFormat);

        IIOMetadataNode grCtlExt = findOrCreateNode(root, "GraphicControlExtension");
        grCtlExt.setAttribute("delayTime", isLastFrame ? "1000" : "30"); // Extra delay for last frame
        grCtlExt.setAttribute("disposalMethod", "doNotDispose");

        if (isFirstFrame) {
            // Configure infinite looping.
            IIOMetadataNode appExts = findOrCreateNode(root, "ApplicationExtensions");
            IIOMetadataNode appExt = findOrCreateNode(appExts, "ApplicationExtension");
            appExt.setAttribute("applicationID", "NETSCAPE");
            appExt.setAttribute("authenticationCode", "2.0");
            appExt.setUserObject(new byte[] { 1, 0, 0 });
        }

        metadata.setFromTree(metaFormat, root);
        imgWriter.writeToSequence(new IIOImage(img, null, metadata), null);
    }

    private static IIOMetadataNode findOrCreateNode(Node parent, String nodeName) {
        for (Node child = parent.getFirstChild(); child != null; child = child.getNextSibling()) {
            if (child.getNodeName().equals(nodeName)) return (IIOMetadataNode)child;
        }

        IIOMetadataNode node = new IIOMetadataNode(nodeName);
        parent.appendChild(node);
        return node ;
    }

    private static &lt;Cell&gt; Set&lt;Cell&gt; nextGeneration(Tiling&lt;Cell&gt; tiling, Set&lt;Cell&gt; gen) {
        Map&lt;Cell, Integer&gt; neighbourCount = new HashMap&lt;Cell, Integer&gt;();
        for (Cell cell : gen) {
            for (Cell neighbour : tiling.neighbours(cell)) {
                Integer curr = neighbourCount.get(neighbour);
                neighbourCount.put(neighbour, 1 + (curr == null ? 0 : curr.intValue()));
            }
        }

        Set&lt;Cell&gt; nextGen = new HashSet&lt;Cell&gt;();
        for (Map.Entry&lt;Cell, Integer&gt; e : neighbourCount.entrySet()) {
            if (e.getValue() == 3 || (e.getValue() == 2 &amp;&amp; gen.contains(e.getKey()))) {
                nextGen.add(e.getKey());
            }
        }

        return nextGen;
    }

    private static &lt;Cell&gt; BufferedImage render(Tiling&lt;Cell&gt; tiling, Rectangle bounds, Collection&lt;Cell&gt; alive) {
        // Create a suitable paletted image
        int width = bounds.width;
        int height = bounds.height;
        byte[] data = new byte[width * height];
        int[] pal = new int[]{ GRIDCOL.getRGB(), DEADCOL.getRGB(), LIVECOL.getRGB() };
        ColorModel colourModel = new IndexColorModel(8, pal.length, pal, 0, false, -1, DataBuffer.TYPE_BYTE);
        DataBufferByte dbb = new DataBufferByte(data, width * height);
        WritableRaster raster = Raster.createPackedRaster(dbb, width, height, width, new int[]{0xff}, new Point(0, 0));
        BufferedImage img = new BufferedImage(colourModel, raster, true, null);
        Graphics g = img.createGraphics();

        // Render the tiling.
        // We assume that either one of the live cells or the "initial cell" is in bounds.
        Set&lt;Cell&gt; visited = new HashSet&lt;Cell&gt;();
        Set&lt;Cell&gt; unvisited = new HashSet&lt;Cell&gt;(alive);
        unvisited.add(tiling.initialCell());
        while (!unvisited.isEmpty()) {
            Iterator&lt;Cell&gt; it = unvisited.iterator();
            Cell current = it.next();
            it.remove();
            visited.add(current);

            Rectangle cellBounds = new Rectangle(-1, -1);
            int[][] cellVertices = tiling.bounds(current);
            int[] xs = cellVertices[0], ys = cellVertices[1];
            for (int i = 0; i &lt; xs.length; i++) {
                cellBounds.add(xs[i], ys[i]);
                xs[i] -= bounds.x;
                ys[i] -= bounds.y;
            }

            if (!bounds.intersects(cellBounds)) continue;

            g.setColor(alive.contains(current) ? LIVECOL : DEADCOL);
            g.fillPolygon(xs, ys, xs.length);
            g.setColor(GRIDCOL);
            g.drawPolygon(xs, ys, xs.length);

            for (Cell neighbour : tiling.neighbours(current)) {
                if (!visited.contains(neighbour)) unvisited.add(neighbour);
            }
        }

        return img;
    }
}
</code></pre>

<p>Any vertex generates a <strong>still life</strong> (2 points):</p>

<pre><code>java GenericLife CairoTiling stilllife.gif 0 0 0 1 1 1 3 2 3 3 4 2 4 3
</code></pre>

<p><img src="https://i.sstatic.net/7yRYX.gif" alt="Still life"></p>

<p><strong>Oscillators</strong> (15 points): clockwise from top-left we have orders 2, 3, 4, 6, 11, 12.</p>

<p><img src="https://i.sstatic.net/BYvtb.gif" alt="Assorted oscillators"></p>
</div>
<div id="pu19" class="pu"><h2>Go, ? points</h2>

<p>So rather than pin myself down to a particular tiling, I wrote a program that takes a gif or png of a tiling and runs life on it.  The gif/png must use a single color for all the tiles.</p>

<pre><code>package main

import (
    "flag"
    "image"
    "image/color"
    "image/gif"
    "image/png"
    "math/rand"
    "os"
    "strings"
)

func main() {
    flag.Parse()
    filename := flag.Args()[0]
    r, err := os.Open(filename)
    if err != nil {
        panic(err)
    }
    var i image.Image
    if strings.HasSuffix(filename, ".gif") {
        i, err = gif.Decode(r)
        if err != nil {
            panic(err)
        }
    }
    if strings.HasSuffix(filename, ".png") {
        i, err = png.Decode(r)
        if err != nil {
            panic(err)
        }
    }

    // find background color
    back := background(i)

    // find connected regions
    n, m := regions(i, back)

    // find edges between regions
    edges := graph(i, m)

    // run life on the tiling
    life(i, n, m, edges)
}

// Find the most-common occurring color.
// This is the "background" color.
func background(i image.Image) color.Color {
    hist := map[color.Color]int{}
    b := i.Bounds()
    for y := b.Min.Y; y &lt; b.Max.Y; y++ {
        for x := b.Min.X; x &lt; b.Max.X; x++ {
            hist[i.At(x, y)]++
        }
    }
    maxn := 0
    var maxc color.Color
    for c, n := range hist {
        if n &gt; maxn {
            maxn = n
            maxc = c
        }
    }
    return maxc
}

// find connected regions.  Returns # of regions and a map from pixels to their region numbers.
func regions(i image.Image, back color.Color) (int, map[image.Point]int) {

    // m maps each background point to a region #
    m := map[image.Point]int{}

    // number regions consecutively
    id := 0

    b := i.Bounds()
    for y := b.Min.Y; y &lt; b.Max.Y; y++ {
        for x := b.Min.X; x &lt; b.Max.X; x++ {
            if i.At(x, y) != back {
                continue
            }
            p := image.Point{x, y}
            if _, ok := m[p]; ok {
                continue // already in a region
            }
            q := []image.Point{p}
            m[p] = id
            k := 0
            for k &lt; len(q) {
                z := q[k]
                k++
                for _, n := range [4]image.Point{{z.X - 1, z.Y}, {z.X + 1, z.Y}, {z.X, z.Y - 1}, {z.X, z.Y + 1}} {
                    if !n.In(b) || i.At(n.X, n.Y) != back {
                        continue
                    }
                    if _, ok := m[n]; ok {
                        continue
                    }
                    m[n] = id
                    q = append(q, n)

                }
            }
            if len(q) &lt; 10 {
                // really tiny region - probably junk in input data
                for _, n := range q {
                    delete(m, n)
                }
                continue
            }
            id++
        }
    }
    return id, m
}

// edge between two regions.  r &lt; s.
type edge struct {
    r, s int
}

// returns a set of edges between regions.
func graph(i image.Image, m map[image.Point]int) map[edge]struct{} {
    // delta = max allowed spacing between adjacent regions
    const delta = 6
    e := map[edge]struct{}{}
    for p, r := range m {
        for dx := -delta; dx &lt;= delta; dx++ {
            for dy := -delta; dy &lt;= delta; dy++ {
                n := image.Point{p.X + dx, p.Y + dy}
                if _, ok := m[n]; !ok {
                    continue
                }
                if m[n] &gt; r {
                    e[edge{r, m[n]}] = struct{}{}
                }
            }
        }
    }
    return e
}

// run life engine
// i = image
// n = # of regions
// m = map from points to their region #
// edges = set of edges between regions
func life(i image.Image, n int, m map[image.Point]int, edges map[edge]struct{}) {
    b := i.Bounds()
    live := make([]bool, n)
    nextlive := make([]bool, n)
    palette := []color.Color{color.RGBA{0, 0, 0, 255}, color.RGBA{128, 0, 0, 255}, color.RGBA{255, 255, 128, 255}} // lines, on, off
    var frames []*image.Paletted
    var delays []int

    // pick random starting lives
    for j := 0; j &lt; n; j++ {
        if rand.Int()%2 == 0 {
            live[j] = true
            nextlive[j] = true
        }
    }
    for round := 0; round &lt; 100; round++ {
        // count live neighbors
        neighbors := make([]int, n)
        for e := range edges {
            if live[e.r] {
                neighbors[e.s]++
            }
            if live[e.s] {
                neighbors[e.r]++
            }
        }

        for j := 0; j &lt; n; j++ {
            nextlive[j] = neighbors[j] == 3 || (live[j] &amp;&amp; neighbors[j] == 2)
        }

        // add a frame
        frame := image.NewPaletted(b, palette)
        for y := b.Min.Y; y &lt; b.Max.Y; y++ {
            for x := b.Min.X; x &lt; b.Max.X; x++ {
                frame.SetColorIndex(x, y, 0)
            }
        }
        for p, r := range m {
            if live[r] {
                frame.SetColorIndex(p.X, p.Y, 1)
            } else {
                frame.SetColorIndex(p.X, p.Y, 2)
            }
        }
        frames = append(frames, frame)
        delays = append(delays, 30)

        live, nextlive = nextlive, live
    }

    // write animated gif of result
    w, err := os.Create("animated.gif")
    if err != nil {
        panic(err)
    }
    gif.EncodeAll(w, &amp;gif.GIF{Image: frames, Delay: delays, LoopCount: 100})
    w.Close()
}
</code></pre>

<p>Then I just went on the web, grabbed some fun tiling images and ran the program on them.</p>

<pre><code>go run life.go penrose1.go
</code></pre>

<p>It generates a file called "animated.gif" which contains a 100-step life simulation of the given tiling.</p>

<p>Standard life:</p>

<p><img src="https://i.sstatic.net/3PkBe.gif" alt="enter image description here">
<img src="https://i.sstatic.net/BAOwA.gif" alt="enter image description here"></p>

<p>Penrose tiles:</p>

<p><img src="https://i.sstatic.net/nbY1w.png" alt="enter image description here">
<img src="https://i.sstatic.net/G83av.gif" alt="enter image description here"></p>

<p><img src="https://i.sstatic.net/gZ0MZ.png" alt="enter image description here">
<img src="https://i.sstatic.net/Ox1VC.gif" alt="enter image description here"></p>

<p>Above one has an oscillator of period 12.</p>

<p><img src="https://i.sstatic.net/ATvpm.gif" alt="enter image description here">
<img src="https://i.sstatic.net/q9RxP.gif" alt="enter image description here"></p>

<p>Above one has an oscillator of period 3.</p>
</div>
<div id="pu20" class="pu"><h1>Javascript [25+?]</h1>
<p><a href="http://jsfiddle.net/Therm/dqb2h2oc/" rel="noreferrer">http://jsfiddle.net/Therm/dqb2h2oc/</a></p>
<p><img src="https://i.sstatic.net/Z8gb9.gif" alt="enter image description here" /></p>
<p>House tessellations! There are two shapes: &quot;House&quot; and &quot;Upsidedown House&quot;, each with 7 neighbors.</p>
<p>Currently I have a score of 25.</p>
<pre><code>still life                  : +2
2-stage oscillator &quot;beacon&quot; : +3  (Credit to isaacg)
Spaceship &quot;Toad&quot;            : +10 (Credit to isaacg)
Glider                      : +10 (Credit to Martin Büttner)
</code></pre>
<p>Naming rights for patterns up for grabs if you find them :p</p>
<p>Still life - Star<br>
<img src="https://i.sstatic.net/0NMyq.png" alt="Star" /></p>
<p>2 Stage oscillator - &quot;Beacon&quot; : Found by isaacg<br>
<img src="https://i.sstatic.net/pRh5F.gif" alt="2stagOscillator" /></p>
<p>Spaceship - &quot;Toad&quot;: Found by isaacg <br>
<img src="https://i.sstatic.net/EzW2A.gif" alt="enter image description here" /></p>
<p>Glider - Unnamed: Found by Martin Büttner <br>
<img src="https://i.sstatic.net/i8PPb.gif" alt="enter image description here" /></p>
<p>The fiddle is currently set to randomly populate the world as an initial state.</p>
<p>Code:</p>
<pre><code>// An animation similar to Conway's Game of Life, using house-tessellations.
// B2/S23

var world;
var worldnp1;
var intervalTime = 2000;

var canvas = document.getElementById('c');
var context = canvas.getContext('2d');

var x = 32;
var y = 32;

var width = 20; // width of house
var height = 15; // height of house base
var theight = 5; // height of house roof
var deadC = '#3300FF';
var aliveC = '#00CCFF';

function initWorld() {
    world = new Array(x * y);
    
    /* Still life - box
        world[x/2 * y + y/2 + 1] = 1;
        world[x/2 * y + y/2] = 1;
        world[x/2 * y + y/2 + y] = 1;
        world[x/2 * y + y/2 + y + 1] = 1;
    */
    
    /* Still life - House
        world[x/2 * y + y/2 - y] = 1;
        world[x/2 * y + y/2 + 1] = 1;
        world[x/2 * y + y/2 - 1] = 1;
        world[x/2 * y + y/2 + y] = 1;
        world[x/2 * y + y/2 + y+1] = 1;
    */
    
    /* Oscillator on an infinite plane :(
    for(var i=0; i&lt;y; i++) {
        world[y/2 * y + i] = 1 ^ (i%2);
        world[y/2 * y + y + i] = 1 ^ (i%2);
    } */
    
    // Random state 
    for(var i=0; i&lt;x*y; i++) {
        world[i] = Math.round(Math.random());
    }
    
    drawGrid();
}

animateWorld = function () {
    computeNP1();
    drawGrid();
};

function computeNP1() {
    worldnp1 = new Array(x * y);
    var buddies;
    for (var i = 0; i &lt; x * y; i++) {
        buddies = getNeighbors(i);
        var aliveBuddies = 0;
        for (var j = 0; j &lt; buddies.length; j++) {
            if (world[buddies[j]]) {
                aliveBuddies++;
            }
        }
        if (world[i]) {
            if (aliveBuddies === 2 || aliveBuddies === 3) {
                worldnp1[i] = 1;
            }
        }
        else {
            if (aliveBuddies === 3) {
                worldnp1[i] = 1;
            }
        }
    }
    world = worldnp1.slice(0);
}

function drawGrid() {
    var dx = 0;
    var dy = 0;
    var shiftLeft = 0;
    var pointDown = 0;
    for (var i = 0; i &lt; y; i++) {
        // yay XOR
        shiftLeft ^= pointDown;
        pointDown ^= 1;
        if (shiftLeft) {
            dx -= width / 2;
        }
        for (var j = 0; j &lt; x; j++) {
            var c = world[i * y + j] ? aliveC : deadC ;
            draw5gon(dx, dy, pointDown, c);
            outline5gon(dx, dy, pointDown);
            dx += width;
        }
        dx = 0;
        if (pointDown) {
            dy += 2 * height + theight;
        }
    }
}

function getNeighbors(i) {
    neighbors = [];

    // Everybody has a L/R neighbor
    if (i % x !== 0) {
        neighbors.push(i - 1);
    }
    if (i % x != x - 1) {
        neighbors.push(i + 1);
    }

    // Everybody has &quot;U/D&quot; neighbor
    neighbors.push(i - x);
    neighbors.push(i + x);

    // Down facers (R1)
    if (Math.floor(i / x) % 4 === 0) {
        if (i % x !== 0) {
            neighbors.push(i - x - 1);
        }
        if (i % x != x - 1) {
            neighbors.push(i - x + 1);
            neighbors.push(i + x + 1);
        }
    }

    // Up facers (R2)
    else if (Math.floor(i / x) % 4 === 1) {
        if (i % x !== 0) {
            neighbors.push(i - x - 1);
            neighbors.push(i + x - 1);
        }
        if (i % x != x - 1) {
            neighbors.push(i + x + 1);
        }
    }

    // Down facers (R3)
    else if (Math.floor(i / x) % 4 === 2) {
        if (i % x !== 0) {
            neighbors.push(i - x - 1);
            neighbors.push(i + x - 1);
        }
        if (i % x != x - 1) {
            neighbors.push(i - x + 1);
        }
    }

    // Up facers (R4)
    // else if ( Math.floor(i/x) % 4 === 3 )
    else {
        if (i % x !== 0) {
            neighbors.push(i + x - 1);
        }
        if (i % x != x - 1) {
            neighbors.push(i - x + 1);
            neighbors.push(i + x + 1);
        }
    }

    return neighbors.filter(function (val, ind, arr) {
        return (0 &lt;= val &amp;&amp; val &lt; x * y);
    });
}

// If pointdown, x,y refer to top left corner
// If not pointdown, x,y refers to lower left corner
function draw5gon(x, y, pointDown, c) {
    if (pointDown) {
        drawRect(x, y, width, height, c);
        drawTriangle(x, y + height, x + width, y + height, x + width / 2, y + height + theight);
    } else {
        drawRect(x, y - height, width, height, c);
        drawTriangle(x, y - height, x + width / 2, y - height - theight, x + width, y - height);
    }
}

function outline5gon(x, y, pointDown) {
    context.beginPath();
    context.moveTo(x, y);
    if (pointDown) {
        context.lineTo(x + width, y);
        context.lineTo(x + width, y + height);
        context.lineTo(x + width / 2, y + height + theight);
        context.lineTo(x, y + height);
    } else {
        context.lineTo(x, y - height);
        context.lineTo(x + width / 2, y - height - theight);
        context.lineTo(x + width, y - height);
        context.lineTo(x + width, y);
    }
    context.lineWidth = 3;
    context.strokeStyle = '#000000';
    context.stroke();
}

function drawRect(x, y, w, h, c) {
    context.fillStyle = c;
    context.fillRect(x, y, w, h);
}

function drawTriangle(x1, y1, x2, y2, x3, y3, c) {
    context.beginPath();
    context.moveTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(x3, y3);
    context.fillStyle = c;
    context.fill();
}

$(document).ready(function () {
    initWorld();
    intervalID = window.setInterval(animateWorld, intervalTime);
});
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/35827/">35827</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




