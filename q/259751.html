<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::259751</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>259</td><td>JavaScript ES10</td><td>230405T110939Z</td><td><a href="https://codegolf.stackexchange.com/questions/259751/enumeration-of-free-polyominoes/259754#259754">Arnauld</a></td></tr>
<tr d-ix="1"><td>199</td><td>R</td><td>230418T210912Z</td><td><a href="https://codegolf.stackexchange.com/questions/259751/enumeration-of-free-polyominoes/260247#260247">Kirill L</a></td></tr>
<tr d-ix="2"><td>nan</td><td>Wolfram LanguageMathematica</td><td>230418T003807Z</td><td><a href="https://codegolf.stackexchange.com/questions/259751/enumeration-of-free-polyominoes/260222#260222">138 Aspe</a></td></tr>
<tr d-ix="3"><td>1374</td><td>Python3</td><td>230406T150427Z</td><td><a href="https://codegolf.stackexchange.com/questions/259751/enumeration-of-free-polyominoes/259823#259823">Ajax1234</a></td></tr>
<tr d-ix="4"><td>073</td><td>05AB1E</td><td>230405T134207Z</td><td><a href="https://codegolf.stackexchange.com/questions/259751/enumeration-of-free-polyominoes/259762#259762">Kevin Cr</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>JavaScript (ES10), 259 bytes</h1>
<p>For now, this is just a slightly modified version of <a href="https://codegolf.stackexchange.com/a/199797/58563">my answer</a> to <a href="https://codegolf.stackexchange.com/q/199789/58563">this other challenge</a> so that reflections are discarded. Supports <span class="math-container">\$n=0\$</span>.</p>

<pre class="lang-javascript prettyprint-override"><code>f=(n,m=[...o=Array(w=n)],i=c=0)=&gt;n?m.map((r,y)=&gt;m.map((_,x,[...m])=&gt;!i|1&lt;&lt;x&amp;~r&amp;(m[y+1]|r/2|r*2)&amp;&amp;f(n-1,m,m[y]|=1&lt;&lt;x)))|c:[...3/64+''].some(k=&gt;o[M=(k^6||m.reverse(),m=m.map(a=(_,y)=&gt;m.map(b=(v,x)=&gt;a|=b|=(v&gt;&gt;y&amp;1)&lt;&lt;w+~x)|b)).flatMap(v=&gt;v/(a&amp;-a)||[])])?0:o[M]=++c
</code></pre>
<p><a href="https://tio.run/##ZY7RaoNAEEXf@xd9MTN1XTVJLQTH0A/IF8i2rFaLjeuGNRiFJb9uV1ooxcdz5l7ufMlB9qVpLteg0x/VPNcEHVOUc841vRojJ7hRh4I1VFKElHVHxZW8ABg2OfyFdzaypaOEc4@NjdN09O7GA5VPfiysCbfWPG3R82rogpgp5g7C0pJDRFselvYuTPb@ZiN4r1UFZ8p0fiI4vyXWKm6qoTJ9Beje@1mV5Hb/nigIBjY6lJYK6yDLJi/GNL359xFtgcjrVl5PLjpQNoQgvUCitblAgcfo4MYE@X45l7rrdVvxVn9CDRHiw38Tr8x2ZXYrs1@Z55VJVuYFcf4G" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.r-project.org" rel="nofollow noreferrer">R</a>, <s>205</s> 199 bytes</h1>
<pre class="lang-r prettyprint-override"><code>f=\(n,o={},v=0,u=0,`~`=c,`?`=sort,d=-1~1i~1~-1i){for(j in u)F=F+`if`(length(p&lt;-?j~o)&lt;n,f(n,p,v,setdiff((u=u[-1])~j+d,v&lt;-j~v)),2^(-all(apply(Conj(p)%o%d,2,a&lt;-\(x)any(diff(p-?x))))-a(-p)-a(p*1i))/n);F}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=NY9BasMwEEWv4k1gppmhVVahtfCi4Es0LRJ11EgYSTiSSQjRRbpJFz1ET9Az9Da1GzrwZ_M_n_ffP4bL5TMnw-ufbyM34CnI05lGeUd5kipKvpJqlNyHIVEnWRRhiygsLJ5MGMBV1lcZW9kulTUK-q1_SzuINTeuBKw9mak00kj7beqsMQBZ5icWz1jcsqOxZldGRFq9AOu-Bx1jf4TH4B1EXIRFRyvSNW_ggNof4a8icnPA6VgDx_nHm4kHbz0-tOfrnK8Zzs5w4n6NVRysT2BgSl39_9m_" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>A variation of <a href="https://codegolf.stackexchange.com/a/200161/78274">my answer to the related challenge</a> adapted to account for reflections.</p>
<p>Specifically, since the polyominoes <span class="math-container">\$p\$</span> are stored as complex numbers, reflections across both axes and diagonals can be represented by their complex conjugates <span class="math-container">\$Conj(p)\$</span> multiplied by directional vectors in <span class="math-container">\$d\$</span>.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.wolfram.com/wolframscript/" rel="nofollow noreferrer">Wolfram Language(Mathematica)</a>, <del>532</del> <del>496</del> 366 bytes</h1>
<p>saved so many bytes thanks to the comment of @Aiden Chow</p>
<hr />
<p><strong>Modified from the Mathematica code provided by <a href="https://oeis.org/A000105" rel="nofollow noreferrer">A000105</a>.</strong> <strong>Really naive. I don't know what I'm doing.</strong></p>
<hr />
<pre><code>z[p_]:=Union[(#-(Min@Re@p+Min@Im@p*I))&amp;/@p];Q[1]={{0}};Q[n_]:=Module[{f,g,a={}},g=((f=#;({f,#+1,f,#+I,f,#-1,f,#-I}&amp;/@f))&amp;)/@Q[n-1];f=Select[Union[z/@Partition[Flatten@g,n]],Length@#==n&amp;];While[f!={},a={a,Z=f[[1]]};f=Complement[f,Union[z/@Flatten[{#,(#-2Re@#)&amp;/@#}&amp;/@Module[{i=Z,a={Z}},While[(i=I*i)!=Z,a~AppendTo~i];a],1]]]];Partition[Flatten@a,n]];F[n_]:=Length@Q@n
</code></pre>
<p><a href="https://tio.run/##ZZBRS8MwFIXf/RdrYaTbLbM@iSEQEQYFB5tOhIUgcUvaQJuGEV9Wur9eb9z0xZebm8vNd85Jq0KtWxXsXo3jSfgP@cDenO2cIGlOVtbxF839PDZly/2szLLpgntJN6KQrO9vhwFbF5@tusNXo0VvoALF@mGAihFiWEoJztJ5AbGWseY/fV4OyDJIzBYcIXkhqWGvutH7IC4mTgu@VsdgQ7wsGxWCdrwCJyU8a1eFmqeMuamk77VFbTNB3SiuYMeMQItyQORT1/pGt9oFYeAPfMWJPgXMeoc505gtjaZ@s1i2i7gdhrkoEMvKmc0mcX5@9F67w7Y7W0mVBFSTkv73q6Jfurz80tX2hrtxqz6RuD5a9JUokoCDJGMJ4Cbu38QDegcF3A9y/AY" rel="nofollow noreferrer">Try it online!</a></p>
<hr />
<p>The original Mathematica code looks like</p>
<pre><code>(* In this program by Jaime Rangel-Mondragón, polyominoes are represented as a list of Gaussian integers. *)
polyominoQ[p_List] := And @@ ((IntegerQ[Re[#]] &amp;&amp; IntegerQ[Im[#]])&amp; /@ p);
rot[p_?polyominoQ] := I*p;
ref[p_?polyominoQ] := (# - 2 Re[#])&amp; /@ p;
cyclic[p_] := Module[{i = p, ans = {p}}, While[(i = rot[i]) != p, AppendTo[ans, i]]; ans];
dihedral[p_?polyominoQ] := Flatten[{#, ref[#]}&amp; /@ cyclic[p], 1];
canonical[p_?polyominoQ] := Union[(# - (Min[Re[p]] + Min[Im[p]]*I))&amp; /@ p];
allPieces[p_] := Union[canonical /@ dihedral[p]];
polyominoes[1] = {{0}};
polyominoes[n_] := polyominoes[n] = Module[{f, fig, ans = {}}, fig = ((f = #1; ({f, #1 + 1, f, #1 + I, f, #1 - 1, f, #1 - I}&amp;) /@ f)&amp;) /@ polyominoes[n - 1]; fig = Partition[Flatten[fig], n]; f = Select[Union[canonical /@ fig], Length[#1] == n &amp;]; While[f != {}, ans = {ans, First[f]}; f = Complement[f, allPieces[First[f]]]]; Partition[Flatten[ans], n]];
a[n_] := a[n] = Length[ polyominoes[n]];
Table[Print[&quot;a(&quot;, n, &quot;) = &quot;, a[n]]; a[n], {n, 1, 12}] (* Jean-François Alcover, Mar 24 2015, after Jaime Rangel-Mondragón *)
</code></pre>
</div>
<div id="pu3" class="pu"><h1>Python3, 1374 bytes*:</h1>
<pre><code>R=range
E=enumerate
def U(b):
 q,s=[b],[b]
 while q:
  b=q.pop(0)
  if(T:=[i[::-1]for i in b])not in s:q+=T,;s+=T,
  if(T:=[*map(list,zip(*[i[::-1]for i in zip(*b)]))])not in s:q+=T,;s+=T,
  if(T:=[*map(list,zip(*b))])not in s:q+=T,;s+=T,
 return s
Z=lambda B:[[j[0]if j else j for j in i]for i in B]
def S(b):
 b=[[*i]for i in b if any(i)]
 if 1-any([*zip(*b)][0]):b=[i[1:]for i in b]
 if 1-any([*zip(*b)][-1]):b=[i[:-1]for i in b]
 return b
C=lambda b:[(x,y)for x,t in E(b)for y,j in E(t)if j]
P=[(1,0),(0,1),(-1,0),(0,-1)]
def M(b):
 t=C(b)
 q=[t.pop(0)]
 while q:
  x,y=q.pop()
  for j,k in P:
   c=(x+j,y+k)
   if c in t:t.remove(c);q+=c,
 return[]==t
V=lambda b,x,y:x*y==0 or len(b)==x or len(b[0])==y
def f(n):
 w=int(n**0.5)
 b=[[[1,0]for _ in R(w)]for _ in R(n//(w or 1))]+[[[1,0]for _ in R(n%(w or 1))]]*(n%(w or 1)&gt;0)
 B=[i+[0]*(max(map(len,b))-len(i))for i in b]
 q,s=[B],[Z(B)]
 while q:
  b=q.pop(0);c=C(b)
  for x,y in c:
   if 0==b[x][y][1]:
    for X,Y in c:
     if(X,Y)!=(x,y):
      for j,k in P:
       J,K=X-j,Y-k;B=eval(str(b));B[x][y]=0
       if(J,K)not in c:
        if K==len(B[0]):B=[i+[0]for i in B]
        if K&lt;0:B=[[0]+i for i in B];K=0
        if J==len(B):B=B+[[0 for _ in B[0]]]
        if J&lt;0:B=[[0 for _ in B[0]]]+B;J=0
        B[J][K]=[1,1]
        if M(S(Z(B)))and all(S(Q)not in s for Q in U(S(Z(B)))):q+=B,;s+=S(Z(B)),
 return len(s)
</code></pre>
<p><a href="https://tio.run/##lVRNb5tAED2XX7E9VNrFSwKKKlW40wNRLrYi5bNKslpVQHCDgzEGEkP/vDuzxhgnzaGWbO/Mvn3z8Wa3aOunZX7yrSg3mysow/x3Yp1Bkr8skjKsE@sxmbFbHgnfYitZgYq0xK/F1k9plrAVulkEq6NiWXBXoJHO@I0PKlW@73h6tixZytKcRVrky5pWlb8awY0cV/S7P2AvwoJnaVXLP2nB7XcExhsJLcR/MkUfnyiT@qVEr/UAWbiIHkMW@ErNlavTGZuzJKsS/KMU5nQ63WcTaNOY621jIlDKHuxGmAoL85anAjuFa88hS9m7IjCC8CPqkucPe/RvMLahQ79paV9BZJ3uKoh8xRvZCoI10lR9hlmS2cr51qwF1aetC1Dck66Q3JUe/jo7w/HEtsDzbYE1nOICJwBU3Ul9OAIYsRsCmgHTMflMwS5ol8XAm9FctqNn2qYiY9qs/fqoTBbL14THYozSxL0oSgPU1s@@KokR/MZuAVyG7FmSY0IATW9QSwFak/WM55T1GtK85rltu0dfxVYlhRWaDv6i@Fd8LYZWfnzM18To4cyM3qPzL/ttbQ/MHzT6ASo0wjRsvggbboYwySWOn0MJpkIcKGcuU4CX6YEH4qP7NI67xrOtnC2djv2uhy5ApBqtWq08bZwGdifv9zBzK9AjPoMZi875XiL6TOQU7py5vHeexwEkr2HGq7rEBMQ42AYCd4dFWoTvLlbcc1BiUwAqOTBjvmvL8O4Msd9dgiBglLIBZjzdxyLcpOMkwgC1cVkvDMXRB6STHelb0CgYTwa8gZpoNdWAQnsHBOf8mpMwQoT5IwuzDO3L/hUxrJe0vO1xgp6WwDwtnWv/wFDildj01ZlXlnsuqvGpKGlIZzQfm78" rel="nofollow noreferrer">Try it online!</a></p>
<p>* Rather long in bytes, but computes solutions up to and including <span class="math-container">\$n = 9\$</span> in under 40 seconds on TIO.</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 73 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<p><sup>Should have been 1 byte less by replacing <code>})}€ê</code> with <code>}){}</code>, but the many nested maps/loops cause a bug in 05AB1E here (<code>})ê}</code> and <code>})}€{</code> also doesn't work strangely enough..)</sup></p>
<pre><code>1ÝInãʒOQiyƶIô©Δ2Fø0δ.ø}2Fø€ü3}®Ā*εεÅsyøÅsM}}}˜Ùg&lt;]εIô2Føʒà}}4FDíDø})}€êÙg
</code></pre>
<p>Basically the exact same approach as <a href="https://codegolf.stackexchange.com/a/259760/52210">my answer</a> for the <a href="https://codegolf.stackexchange.com/questions/199789/how-many-unique-one-sided-polyominos">related challenge</a>, but with a single added <code>D</code>uplicate (in step 4) to also remove reflections in addition to the rotations.</p>
<p>Extremely slow brute-force, so is only able to output up to <span class="math-container">\$a(4)\$</span> on TIO.</p>
<p><a href="https://tio.run/##yy9OTMpM/f/f8PBcz7zDi09N8g/MrDy2zfPwlkMrz00xcju8w@DcFr3DO2pBzEdNaw7vMa49tO5Ig9a5ree2Hm4trjy8A0j61tbWnp5zeGa6Tey5rUC9IMWnJh1eUFtr4uZyeK0LUL9mLUj3KqCa//9N/uvq5uXr5iRWVQIA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/W9ybJKfvZLCo7ZJCkr2focnhCr9Nzw8NyLv8OJTkyKK/SMCMyuPbYs4vOXQynNTjNwO7zA4t0Xv8I5aEPNR05rDe4xrD6070qB1buu5rYdbiysP7wCSvrW1tafnHJ6ZbhN7bitQL0jxqUmHF9TWmri5HF7rAtSvWQvSvQqo5r@SXpjO//@6unn5ujmJVZUA" rel="nofollow noreferrer">verify the first few results</a>.</p>
<p><strong>Explanation:</strong><br />
<sup>Also mostly a copy-paste from my answer of the related challenge, except for step 4.</sup></p>

<p>Step 1: Create all possible <span class="math-container">\$n^2\$</span>-sized lists using <code>0</code>s and <code>1</code>s, consisting of <span class="math-container">\$n\$</span> amount of <code>1</code>s:</p>
<pre class="lang-python prettyprint-override"><code>1Ý          # Push pair [0,1]
  In        # Push the squared input
    ã       # Cartesian power
ʒ           # Filter this list of lists by:
   i        #  If
 O          #  the sum of the current list
  Q         #  is equal to the (implicit) input-integer:
            #   Continue with the check in step 2 below
            #  (implicit else: implicitly use the implicit input for the filter;
            #   this is only truthy for edge case n=1, which fails step 2 due to the `ü3`)
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f/f8PBcz7zDi09N8g/8/9/kv65uXr5uTmJVJQA" rel="nofollow noreferrer">Try just this first step online</a> (without trailing <code>i</code>).</p>
<p>Step 2: Filter it further to only keep single polynominos, using a flood-fill approach:</p>
<pre class="lang-python prettyprint-override"><code> y          #   Push the current list again
  ƶ         #   Multiply each value by its 1-based index
   Iô       #   Convert the list to an input-by-input block
     ©      #   Store this block in variable `®` (without popping)
 Δ          #   Loop until the result no longer changes to flood-fill the matrix:
  2Fø0δ.ø}  #    Add a border of 0s around the matrix:
  2F     }  #     Loop 2 times:
    ø       #      Zip/transpose; swapping rows/columns
      δ     #      Map over each row:
     0 .ø   #       Add a leading/trailing 0
  2Fø€ü3}   #    Convert it into overlapping 3x3 blocks: 
  2F    }   #     Loop 2 times again:
    ø       #      Zip/transpose; swapping rows/columns
     €      #      Map over each inner list:
      ü3    #       Convert it to a list of overlapping triplets
  ®Ā        #    Push matrix `®` and convert all its positive values back to 1s
    *       #    Multiply each 3x3 block by this matrix of 0s/1s (so 0s will remain 0s)
  εεÅsyøÅsM #    Get the largest value from the horizontal/vertical cross of each 3x3 block:
  εε        #     Nested map over each 3x3 block:
    Ås      #       Pop and push its middle row
      y     #       Push the 3x3 block again
       ø    #       Zip/transpose; swapping rows/columns
        Ås  #       Pop and push its middle rows as well (the middle column)
          M #       Push the flattened maximum of the entire (scoped) stack,
            #       which is the flattened maximum of the cross of the current 3x3 block
  }}        #     Close the nested map
 }˜         #   After the flood-fill loop: flatten the block to a list
   Ù        #   Uniquify its values
    g       #   Pop and push its length
     &lt;      #   Decrease it by 1 to account for the 0s
            #   (only 1 is truthy in 05AB1E, so only single islands remain)
]           # Close both the if-statement and filter
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f/f8PBcz7zDi09N8g/MrDy2zfPwlkMrz00xcju8w@DcFr3DO2pBzEdNaw7vMa49tO5Ig9a5ree2Hm4trjy8A0j61tbWnp5zeGa6Tez//yb/dXXz8nVzEqsqAQ" rel="nofollow noreferrer">Try just the first two steps online.</a></p>
<p>Step 3: Convert all valid lists to matrices, and slash off any rows/columns of 0s to have the actual polynominos:</p>
<pre class="lang-python prettyprint-override"><code>ε           # Map over each inner list
 Iô         #  Convert it to an n-by-n block
   2F       #  Inner loop 2 times:
     ø      #   Zip/transpose; swapping rows/columns
      ʒ     #   Filter this list of rows by:
       à    #    Get the maximum of the row (so if it only contains 0s, it'll be removed)
      }     #   Close the filter
    }       #  Close the inner loop
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f/f8PBcz7zDi09N8g/MrDy2zfPwlkMrz00xcju8w@DcFr3DO2pBzEdNaw7vMa49tO5Ig9a5ree2Hm4trjy8A0j61tbWnp5zeGa6Tey5rUC9IMWnJh1eUFv7/7/Jf13dvHzdnMSqSgA" rel="nofollow noreferrer">Try just the first three steps online.</a></p>
<p>Step 4: Remove all duplicated rotations and reflections, by first converting each polynomino to a quartet of its four sorted rotations, then get the reflection of each rotation, and then uniquify that list of octets.</p>
<pre class="lang-python prettyprint-override"><code> 4F         #  Inner loop 4 times:
   D        #   Duplicate the current polynomino-matrix
    í       #   Reverse each inner row to reflect it
     D      #   Duplicate this new reflected polynomino-matrix again
      ø     #   Zip/transpose the matrix; swapping rows/columns
  })        #  After the loop: wrap the eight rotations + reflections on the stack into a list

            # Explanation if the 05AB1E bug mentioned at the top wasn't present:
    {       #  Sort the octet of rotations + reflections
}Ù          # After the map: uniquify the list of polynomino-rotations/reflections

            # Actual explanation with bug:
}€          # After the map: open a new map:
  ê         #  Sort and uniquify each octet
   Ù        # After the map: uniquify the list of distinct polynomino-orientations/reflections
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f/f8PBcz7zDi09N8g/MrDy2zfPwlkMrz00xcju8w@DcFr3DO2pBzEdNaw7vMa49tO5Ig9a5ree2Hm4trjy8A0j61tbWnp5zeGa6Tey5rUC9IMWnJh1eUFtr4uZyeK0LUL9mLUj3qsMz//83@a@rm5evm5NYVQkA" rel="nofollow noreferrer">Try just the first four steps online.</a></p>
<p>Step 5: Get the amount of unique polynominos left, and output it as result:</p>
<pre class="lang-python prettyprint-override"><code>g           # Pop and push the length
            # (which is output implicitly as result)
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/259751/">259751</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




