<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::107193</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>005</td><td>Uiua</td><td>241210T163618Z</td><td><a href="https://codegolf.stackexchange.com/questions/107193/exit-code-golfing/277157#277157">noodle p</a></td></tr>
<tr d-ix="1"><td>139</td><td>Python 3</td><td>241206T231433Z</td><td><a href="https://codegolf.stackexchange.com/questions/107193/exit-code-golfing/277109#277109">whirling</a></td></tr>
<tr d-ix="2"><td>024</td><td>Bash 4.2 + extras</td><td>170118T013152Z</td><td><a href="https://codegolf.stackexchange.com/questions/107193/exit-code-golfing/107205#107205">Dennis</a></td></tr>
<tr d-ix="3"><td>014</td><td>Excel VBA</td><td>170118T034853Z</td><td><a href="https://codegolf.stackexchange.com/questions/107193/exit-code-golfing/107216#107216">Taylor R</a></td></tr>
<tr d-ix="4"><td>052</td><td>ZX81 BASIC >255 exit codes</td><td>170321T081505Z</td><td><a href="https://codegolf.stackexchange.com/questions/107193/exit-code-golfing/113442#113442">Shaun Be</a></td></tr>
<tr d-ix="5"><td>nan</td><td>INTERCAL CINTERCAL</td><td>170118T180805Z</td><td><a href="https://codegolf.stackexchange.com/questions/107193/exit-code-golfing/107263#107263">user6213</a></td></tr>
<tr d-ix="6"><td>640</td><td>SmileBASIC</td><td>170127T000539Z</td><td><a href="https://codegolf.stackexchange.com/questions/107193/exit-code-golfing/108310#108310">12Me21</a></td></tr>
<tr d-ix="7"><td>018</td><td>Jelly</td><td>170121T232610Z</td><td><a href="https://codegolf.stackexchange.com/questions/107193/exit-code-golfing/107629#107629">Dennis</a></td></tr>
<tr d-ix="8"><td>077</td><td>Node.js ES6</td><td>170121T194538Z</td><td><a href="https://codegolf.stackexchange.com/questions/107193/exit-code-golfing/107597#107597">username</a></td></tr>
<tr d-ix="9"><td>018</td><td>C90 gcc</td><td>170119T034524Z</td><td><a href="https://codegolf.stackexchange.com/questions/107193/exit-code-golfing/107305#107305">Dennis</a></td></tr>
<tr d-ix="10"><td>026</td><td>Unix Shell +ncurses +BSD utilities</td><td>170118T103250Z</td><td><a href="https://codegolf.stackexchange.com/questions/107193/exit-code-golfing/107229#107229">zeppelin</a></td></tr>
<tr d-ix="11"><td>066</td><td>Java</td><td>170118T091749Z</td><td><a href="https://codegolf.stackexchange.com/questions/107193/exit-code-golfing/107227#107227">corvus_1</a></td></tr>
<tr d-ix="12"><td>015</td><td>PHP</td><td>170118T004644Z</td><td><a href="https://codegolf.stackexchange.com/questions/107193/exit-code-golfing/107196#107196">Titus</a></td></tr>
<tr d-ix="13"><td>nan</td><td></td><td>170118T235852Z</td><td><a href="https://codegolf.stackexchange.com/questions/107193/exit-code-golfing/107291#107291">Brad Gil</a></td></tr>
<tr d-ix="14"><td>015</td><td>Python 3</td><td>170118T222353Z</td><td><a href="https://codegolf.stackexchange.com/questions/107193/exit-code-golfing/107286#107286">FlipTack</a></td></tr>
<tr d-ix="15"><td>002</td><td>Python 2</td><td>170118T010108Z</td><td><a href="https://codegolf.stackexchange.com/questions/107193/exit-code-golfing/107197#107197">Anthony </a></td></tr>
<tr d-ix="16"><td>019</td><td>Javascript node</td><td>170118T095126Z</td><td><a href="https://codegolf.stackexchange.com/questions/107193/exit-code-golfing/107228#107228">corvus_1</a></td></tr>
<tr d-ix="17"><td>230</td><td>C gcc under bash shell on x86</td><td>170118T020634Z</td><td><a href="https://codegolf.stackexchange.com/questions/107193/exit-code-golfing/107208#107208">Digital </a></td></tr>
<tr d-ix="18"><td>108</td><td>Perl</td><td>170118T125506Z</td><td><a href="https://codegolf.stackexchange.com/questions/107193/exit-code-golfing/107239#107239">el.pesca</a></td></tr>
<tr d-ix="19"><td>019</td><td>Scala</td><td>170118T085823Z</td><td><a href="https://codegolf.stackexchange.com/questions/107193/exit-code-golfing/107224#107224">corvus_1</a></td></tr>
<tr d-ix="20"><td>004</td><td>Turtlèd</td><td>170118T010429Z</td><td><a href="https://codegolf.stackexchange.com/questions/107193/exit-code-golfing/107199#107199">Destruct</a></td></tr>
<tr d-ix="21"><td>011</td><td>Python 2</td><td>170118T012255Z</td><td><a href="https://codegolf.stackexchange.com/questions/107193/exit-code-golfing/107203#107203">xnor</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Uiua, 2 exit codes, 5 bytes</h1>
<pre><code>⍥∘⋕&amp;sc
</code></pre>
<p><code>⋕&amp;sc</code> reads an integer from STDIN.
<code>⍥∘</code> applies the identity function repeatedly N times. If N is zero, nothing happens. If N is one, it attempts to apply identity to a value which doesn't exist, erroring.</p>
<p>Most cases which would result in behavior like this are disallowed by Uiua's stack signature checking, but here, the signature is known--1 input to 1 output--<em>except</em> in the case where the repetition count is zero, in which case nothing happens.</p>
<p>There has been discussion in the past of changing this behavior to do an N-wise identity, which means apply identity to N values, where N is the number of inputs and outputs handled by the repeated function. This idea has not been widely backed at this time, however, and this works correctly at least as of Uiua 0.14.0-dev.6.</p>
</div>
<div id="pu1" class="pu"><h1>Python 3, <s>64</s> 52 bytes, 3 exit codes <sub>(0, 1, 139)</sub></h1>
<h5>-12 from emanresu A</h5>
<pre class="lang-none prettyprint-override"><code>from ctypes import*
1//~-int(input())or string_at(0)
</code></pre>
<p>Try it out <a href="https://tio.run/##lYy7CsIwFIZ3n@InOCSCtqWTFPRRSo3RnKE5ITlCA@Krx6G66/xdLlP2tTrrGeqWeIaVEl0GzZGT7IauaV57CqIpxIdoYzghS6JwHyfRrVE4QVyWQyyb9dIqPBGLeA79Fw1YmVtIYPnqsD2rj9/96/fHX4ta3w" rel="nofollow noreferrer">here!</a> <em>(The TIO version uses a semicolon instead of newline, but it functions the same)</em></p>
<p>This works similarly to <a href="https://codegolf.stackexchange.com/a/107197/126194">this Python 2 answer</a>, but a few things are added:</p>
<ul>
<li>We first import everything from ctypes, since we need <code>string_at</code> later.</li>
<li>Since we are in Python 3, we need to cast the input to an int.</li>
<li>Then we decrement it, using <code>~-</code> which negates it then bitwise NOTs the value.</li>
<li>Then, we do floor division on it with 1:
<ul>
<li>If it is 0, <code>1//-1</code> will resolve to -1, so we exit successfully, since -1 is truthy</li>
<li>If it is 1, we error out trying to do floor division with 1.</li>
<li>If it is 3 or higher, <code>1//-x</code> will return 0, which is falsy, therefore we run the string_at function from ctypes. Targeted at an address of 0, this causes it to segfault.
<ul>
<li>Since we segfault, this means that for an input of 139, we return the correct exit code.</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div id="pu2" class="pu"><h1>Bash 4.2 + extras, 24 exit codes</h1>



<pre class="lang-bash prettyprint-override"><code>grep \#$1$ $0|sed 's:#.*::;s:T:tcc -run -&lt;&lt;&lt;main=:;s:C:curl -L x.org/! :'|sh;exit
man#1
C-#2
C/#3
sed#4
C-x/#5
C_#6
C0#7
man /#16
C-f#22
C-o/#23
C-L3#35
C--capath /#60
C--max-filesize 1#63
C--cacert /#77
timeout 1e-9 w#124
/#126
-#127
T6\;#132
T204\;#133
$[2**63%-1]#136
{0..1000000000}#137
T0\;#139
exit _#255
</code></pre>

<p><em>Thanks to @KenY-N for 3 exit codes. Thanks to @el.pescado for 1 exit code.</em></p>

<h3>Verification</h3>

<p>All tests have been performed on openSUSE 13.2.</p>

<pre class="lang-bash prettyprint-override"><code>$ for n in {0..255}; do bash exit.sh $n; (($? == $n)) &amp;&amp; echo $n &gt;&amp;0; done &amp;&gt; /dev/null
0
1
2
3
4
6
7
16
22
23
35
60
63
77
124
126
127
132
133
136
137
139
255
</code></pre>
</div>
<div id="pu3" class="pu"><h1>Excel VBA, <sub><s>414</s> 514</sub> 533 + 3 Bytes, 14 exit codes</h1>

<p>
Takes input as a <code>Conditional Compilation Argument</code>, <code>n=[input value]</code> and produces that number's associated error code. </p>

<pre class="lang-vb prettyprint-override"><code>Sub e()
Dim a As Application, b As Byte, s As String, v(), x
Set a=Application
#If n=3 Then
Return
#ElseIf n=5 Then
b=a.CommandBars("")
#ElseIf n=6 Then
b=2^8
#ElseIf n=7 Then
ReDim v(9^9)
#ElseIf n=9 Then
v=Sheets("")
#ElseIf n=10 Then
v=Array(1)
For Each x In v
ReDim v(9)
Next
#ElseIf n=11 Then
b=1/0
#ElseIf n=13 Then
Debug.?Int("X")
#ElseIf n=14 Then
Debug.?String(9E8,1)
#ElseIf n=20 Then
Resume
#ElseIf n=28 Then
f 256
#ElseIf n=35 Then
Call c
#ElseIf n=92 Then
For Each x In v
ReDim v(9)
Next
#ElseIf n=94 Then
b=Null
#End If
End Sub

Sub f(n):DoEvents:f n-1:End Sub
</code></pre>

<p>+3 for <code>n=[Value]</code> conditional compilation call</p>

<p>Handles Inputs where <code>n=</code></p>

<pre class="lang-vb prettyprint-override"><code>3
5
6
7
9
10
11
13
14
20
28
35
92
94    
</code></pre>

<p><em>Note:</em> VBA does not have exit codes <code>0</code> or <code>1</code>. I have included the solutions for <code>3</code> and <code>5</code>, which are the two lowest numbered exit codes available to VBA in their place</p>
</div>
<div id="pu4" class="pu"><h1>ZX81 BASIC &gt;255 exit codes - 52 bytes (listing)</h1>
<pre><code>1 INPUT N
2 GOTO 1+(2*(N&gt;0 AND N &lt;=255))
3 PRINT &quot;EXIT CODE &quot;;N
4 RAND USR N
</code></pre>
<p>Technically, <code>N</code> could be any 24 bit floating point number within the range, but we'll assume integers here. Line 2 is equivalent to <code>IF N&gt;0 AND N &lt;=255 THEN GOTO 3: ELSE GOTO 1</code> if ZX81 BASIC had <code>IF/ELSE</code> in its symbolic instructions.</p>
</div>
<div id="pu5" class="pu"><h1>INTERCAL (C-INTERCAL), 15 codes, 313 + 2 = 315 bytes</h1>

<pre><code>        PLEASE WRITE IN .1
(8)     PLEASE CREATE .1 A
        PLEASE A
        PLEASE COME FROM #2$!1/#1'

        DO X
(123)   DO (123) NEXT
        DO COME FROM (222)
(222)   DO STASH .2
(240)   DO ,1 &lt;- #0
(241)   DO ,1 SUB #0 &lt;- #1
(19)    DO .2 &lt;- #256 $ #0
(21)    DO .1 &lt;- #2
(148)   DO GO BACK
(180)   DO RETRIEVE .2
        DO COME FROM (50)
(50)    DO WRITE IN .2
(109)   DO RESUME #0
(120)   DO RESUME #9
        MAYBE COME FROM (223)
(223)   DO COME FROM (223)
(121)   PLEASE NOT X
</code></pre>

<p><a href="https://tio.run/nexus/intercal#bZFNT4QwEIbv/RVj2ERIXOx0FwOJl4KjS1aoabsuHlcTvejJ/y8Wyse6K4cGnrfzMJ22MDxPjyQNwV6XlqCsIUYWptFxVGiSLosRJDupOgOFqgjutaogEIsLvA7wkk177hQ0LESxivyHf62pscdbZkUohIhYv/rIWGk2EAvH1nxgVwi3Swh4x3BmZpc72EfuQJhFgz0WPRPJDSx8FU6RNzk7rtPB9KAgl8XWoXT8oSarS3qmro//20646zrho3cebafm2eQxO1fS9YCCn8BsUlfyJae/Q1n1QxmneBahP9JwI7Wy0LStqgnsXoHdaCL28/b@efj4bpeH169f" rel="noreferrer" title="INTERCAL – TIO Nexus">Try it online!</a></p>

<p><em>All</em> whitespace here is irrelevant. (The original program contained tabs, but I converted them to spaces so that it'd line up correctly on SE; it's conventional to use a tab width of 8 for INTERCAL. I've tested a version of the program with all tabs, spaces, and newlines deleted, though, and it works fine.)</p>

<p>Compile with <code>-abm</code> (2 byte penalty, because <code>-b</code> is required for the compiler to be deterministic).</p>

<p>As usual for INTERCAL, this takes numeric input in the format, e.g., <code>ONE TWO THREE</code> for <code>123</code>.</p>

<h2>Explanation</h2>

<p>When a C-INTERCAL program errors out, the exit status is the error code modulo 256. As a result, we can aim to write a program that's capable of producing as many runtime errors as possible. This program only omits two runtime errors that don't indicate internal compiler issues: ICL200I, because reproducing it requires the use of external libraries that are only compatible with a single-threaded program (and multithreaded programs have more errors available); and ICL533I, because 533 has the same value modulo 256 as 277 does, and the program's capable of producing ICL277I.</p>

<p>The program always starts the same way. First, we input (<code>WRITE IN</code>) a value for the variable <code>.1</code>. Then, we use a computed <code>CREATE</code> statement to create new syntax (here, <code>A</code>); but because it's computed, the definition of the syntax varies based on the value of <code>.1</code>. Finally, in most cases we run our new <code>A</code> statement, which has been defined to produce an error; the table of possible definitions we have contains a definition for each possible runtime error (other than the exceptions listed above).</p>

<p>First, there are two exceptions to this general scheme. <code>(0)</code> is not a valid line number, so if the user inputs <code>ZERO</code>, we jump from the second line (numbered <code>(8)</code>) to the fourth line by means of a computed <code>COME FROM</code> statement. This then falls through into a syntax error <code>DO X</code>, which produces error <code>ICL000I</code>. (In INTERCAL, syntax errors happen at runtime, due to the tendency of commands to be disabled, syntax to be redefined under you, etc.). The <code>COME FROM</code> statement also has a side effect, even if no actual <code>COME FROM</code> happens, creating an operand overload from <code>.1</code> to <code>#1</code> whenever a line with a line number is executed; this is used later on when producing output 21. (Random global side effects are fairly idiomatic in INTERCAL.)</p>

<p>The other exception is with input <code>ONE TWO NINE</code>. There's no line number <code>(129)</code> in the program, so we get an error for a missing line number, which is <code>ICL129I</code>. So I didn't have to write any code to cover that case at all.</p>

<p>Here are the other errors, and what causes them:</p>

<ul>
<li><strong>123</strong> is a <code>NEXT</code> stack overflow (<code>DO (123) NEXT</code>). The <code>NEXT</code> statement needs other modifiers (<code>FORGET</code> or <code>RESUME</code>) in order to retroactively determine what sort of control statement it was. Not having those causes error ICL123I once there are 80 unresolved `NEXT statements.</li>
<li><strong>222</strong> is a stash overflow (<code>DO STASH .2</code> in a <code>COME FROM</code> loop). The stashes are limited only by available memory, but that will run out eventually, causing error ICL222I.</li>
<li><strong>240</strong> is dimensions an array to size zero. That's exactly what <code>DO ,1 &lt;- #0</code> means, and it causes error ICL240I.</li>
<li><strong>241</strong> is caused by assigning outside the bounds of an array. In this case, <code>,1</code> hasn't been allocated (<code>,</code> is used for array-type variables in INTERCAL), so indexing it causes error ICL241I.</li>
<li><strong>19</strong> assigns 65536 (<code>#256 $ #0</code>) to a 16-bit variable <code>.2</code>. It doesn't fit, causing error ICL275I.</li>
<li><strong>21</strong> assigns <code>#2</code> to <code>.1</code>. That might look like a simple enough assignment, but we overloaded <code>.1</code> to mean <code>#1</code> earlier, and attempting to change the value of 1 with no <code>-v</code> option on the command line causes error ICL277I.</li>
<li><strong>148</strong> attempts to return to the top entry of the choicepoint stack (<code>GO BACK</code>), which doesn't exist at this point in the program (we haven't run any commands to manipulate the choicepoint stack, so it's still empty). That causes error ICL404I.</li>
<li><strong>180</strong> attempts to <code>RETRIEVE .2</code> from a nonexistent stash (because we didn't stash anything there in this branch of the program), causing error ICL436I.</li>
<li><strong>50</strong> requests input (<code>WRITE IN</code>) forever in a <code>COME FROM</code> loop. Eventually we'll end up reading past EOF, causing error ICL562I.</li>
<li><strong>109</strong> runs the statement <code>DO RESUME #0</code>, which is meaningless and specifically documented as causing an error (ICL621I).</li>
<li><strong>120</strong> runs the statement <code>DO RESUME #9</code>. We haven't run that many <code>NEXT</code> statements yet, and thus we get error ICL120I. (Intriguingly, this particular error is defined in the INTERCAL documentation as exiting the program normally and then causing the error, rather than exiting the program with an error. I don't believe these two cases are observably different, though.)</li>
<li><strong>223</strong> is basically a complex tangle of multithreading primitives that all point back to line 223, causing an infinite loop that blows up memory. Eventually, there's memory exhaustion in the multithreading subsystem, leading to error ICL991I.</li>
<li><strong>121</strong> is actually a valid statement (it's a comment), but it appears at the end of the program. As such, execution falls off the end of the program immediately after it executes, causing error ICL633I.</li>
</ul>

<h2>Verification</h2>

<p>Some of the errors involve intentionally running the program out of memory, so I suggest setting fairly small memory limits. Here's the shell command I used to test the program (with newlines added for readability; delete them if you run it yourself):</p>

<pre class="lang-sh prettyprint-override"><code>for x in "ZERO" "ONE NINE" "TWO ONE" "FIVE ZERO" "ONE ZERO NINE"
         "ONE TWO ZERO" "ONE TWO ONE" "ONE TWO THREE" "ONE TWO NINE"
         "ONE FOUR EIGHT" "ONE EIGHT ZERO" "TWO TWO TWO"
         "TWO TWO THREE" "TWO FOUR ZERO" "TWO FOUR ONE";
do  echo;
    echo $x;
    echo $x | (ulimit -Sd 40000; ulimit -Sv 40000; ulimit -Ss 40000;
               ./errors; echo $?);
done
</code></pre>

<p>And here's the output (with the line numbers and "PLEASE CORRECT SOURCE" messages deleted to save space), which I added partly to demonstrate the program working but mostly to show off INTERCAL's silly error messages:</p>

<pre><code>ZERO
ICL000I PLEASEWRITEIN.1(8)PLEASECREATE.1APLEASEAPLEASECOMEFROM#2$!1/#1'DOX(123)DO(123)NEXTDOCOMEFROM(222)(222)DOSTASH.2(240)DO,1&lt;-#0(241)DO,1SUB#0&lt;-#1(19)DO.2&lt;-#256$#0(21)DO.1&lt;-#2(148)DOGOBACK(180)DORETRIEVE.2DOCOMEFROM(50)(50)DOWRITEIN.2(109)DORESUME#0(120)DORESUME#9MAYBECOMEFROM(223)(223)DOCOMEFROM(223)(121)PLEASENOTX
0

ONE NINE
ICL275I DON'T BYTE OFF MORE THAN YOU CAN CHEW
19

TWO ONE
ICL277I YOU CAN ONLY DISTORT THE LAWS OF MATHEMATICS SO FAR
21

FIVE ZERO
ICL562I I DO NOT COMPUTE
50

ONE ZERO NINE
ICL621I ERROR TYPE 621 ENCOUNTERED
109

ONE TWO ZERO
ICL632I THE NEXT STACK RUPTURES.  ALL DIE.  OH, THE EMBARRASSMENT!
120

ONE TWO ONE
ICL633I PROGRAM FELL OFF THE EDGE
121

ONE TWO THREE
ICL123I PROGRAM HAS DISAPPEARED INTO THE BLACK LAGOON
123

ONE TWO NINE
ICL129I PROGRAM HAS GOTTEN LOST
129

ONE FOUR EIGHT
ICL404I I'M ALL OUT OF CHOICES!
148

ONE EIGHT ZERO
ICL436I THROW STICK BEFORE RETRIEVING!
180

TWO TWO TWO
ICL222I BUMMER, DUDE!
222

TWO TWO THREE
ICL991I YOU HAVE TOO MUCH ROPE TO HANG YOURSELF
223

TWO FOUR ZERO
ICL240I ERROR HANDLER PRINTED SNIDE REMARK
240

TWO FOUR ONE
ICL241I VARIABLES MAY NOT BE STORED IN WEST HYPERSPACE
241
</code></pre>
</div>
<div id="pu6" class="pu"><h1>SmileBASIC, 640 bytes, 39 exit codes (out of 52)</h1>
<pre><code>SPSET.,0INPUT C$GOTO&quot;@&quot;+C$@0
STOP@3
A
@4
CLS.@5@A
GOSUB@A@7?1/A@8
X$=3@9
A%=POW(2,31)@10
BEEP-1@11
DIM B[#ZL*#R]@13
READ A
@15
V&quot;OPTION STRICT?X
@16
CALL@D@17
V@A*2
@18
V&quot;VAR A,A
@19
V&quot;DEF A:END:DEF A
@20
V&quot;FOR I=0TO
@21
V&quot;NEXT
@22
V&quot;REPEAT
@23
V&quot;UNTIL
@24
V&quot;WHILE.
@25
V&quot;WEND
@26
V&quot;IF.THEN
@27
V&quot;IF.THEN&quot;+CHR$(10)+&quot;ELSE
@28
V&quot;ENDIF
@29
V&quot;DEF X
@30
RETURN@31
DIM E[-1]@32
V&quot;DEF A:DEF
@34
GOTO&quot;|
@36
XOFF MIC
MICSTOP
@37
XOFF MOTION
GYROSYNC
@38
PRGDEL
@39
DIM F[66]SPANIM.,1,F
@40
DIM G[2]SPANIM.,1,G
@42
MPSTART 2,@A@L
MPSEND&quot;A&quot;GOTO@L@44
PROJECT
@46
USE&quot;PRG1:A
@47
BGMPLAY&quot;`
@48
X=
@51
DLCOPEN&quot;
DEF V C
PRGEDIT 1PRGDEL-1PRGSET C
EXEC 1
END
</code></pre>
<p>This could definitely be made shorter.
SB only has error codes from 0 to 51, and some are impossible to trigger.</p>
</div>
<div id="pu7" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 4 exit codes, 18 bytes</h1>

<pre><code>ß€
2*
Ṁ¹Ŀ
RÇĿỌḊ?R
</code></pre>

<p>Supports exit codes <strong>0</strong>, <strong>1</strong>, <strong>137</strong> (killed), and <strong>139</strong> (segmentation fault).</p>

<p><a href="https://tio.run/nexus/jelly#ASMA3P//w5/igqwKMioK4bmAwrnEvwpSw4fEv@G7jOG4ij9S////MA" rel="nofollow noreferrer" title="Jelly – TIO Nexus">Try it online!</a></p>

<h3>How it works</h3>

<pre><code>RÇĿỌḊ?R  Main link. Argument: n (integer)

R        Range; yield [1, ..., n] if n &gt; 1 or [] if n = 0.
    Ḋ?   If the dequeued range, i.e., [2, ..., n] is non-empty:
 Ç         Call the third helper link.
  Ŀ        Execute the k-th helper link, where k is the the integer returned by Ç.
         Else, i.e., if n is 0 or 1:
   Ọ       Unordinal; yield [] for n = 0 and "\x01" for n = 1.
      R  Range. This maps [] to [] and causes and error (exit code 1) for "\x01".


Ṁ¹Ŀ      Third helper link. Argument: r (range)

Ṁ        Maximum; retrieve n from r = [1, ..., n].
 ¹Ŀ      Call the n-th helper link (modular).
         When n = 139, since 139 % 3 = 1, this calls the first helper link.
         When n = 137, since 137 % 3 = 2, this calls the second helper link.


2*       Second helper link. Argument: k

2*       Return 2**k.
         Since 2**137 % 3 = 174224571863520493293247799005065324265472 % 3 = 2,
         ÇĿ in the main link will once again call the second helper link.
         Trying to compute 2**2**137, a 174224571863520493293247799005065324265472-
         bit number, will get the program killed for excessive memory usage.


ß€       First helper link. Argument: k

ß€       Recursively map the first helper link over [1, ..., k].
         This creates infinite recursion. Due to Jelly's high recursion limit,
         a segmentation fault will be triggered.
</code></pre>
</div>
<div id="pu8" class="pu"><h1>Node.js (ES6), 77 bytes, 2 exit codes</h1>

<pre><code>require('readline').createInterface({input:process.stdin}).prompt("",i=&gt;i&amp;&amp;x)
</code></pre>
</div>
<div id="pu9" class="pu"><h1>C90 (gcc), 256 exit codes, <s>28</s> <s>27</s> 18 bytes</h1>

<pre class="lang-c prettyprint-override"><code>main(){getchar();}
</code></pre>

<p>I'm not sure if this is clever or cheaty, but I don't think it violates the rules as written: it technically doesn't use <code>exit</code>, <code>return</code>, or any error throwing mechanism, but simply relies on undefined behavior and the fact that gcc does something rather convenient as far as this challenge goes.</p>

<p><a href="https://tio.run/nexus/bash#TYyxDoIwGAb3PsU3YICBSkgYTFEnXX0BFvK3lA78NViTJsizoyZq3C6X3FEXcICJLpDXRhKaBunpck7XsXOc5bM1gYZuynK1rC8vLBGKW9B7y/ddicL/4r@LEL2fwHCMuZSyqutFQXtcJ8ehR9vGJPvwpqwiEs7xgNx@DwqGBo/k@K7YrE8" title="Bash – TIO Nexus">Try it online!</a></p>

<h3>How it works</h3>

<p>This simply uses <code>getchar</code> to read one byte from STDIN. By itself, this does nothing.</p>

<p>However, a compliant C90 program must end with a <code>return</code> statement or something equivalent; everything else is undefined behavior. gcc ends the generated assembly with a <code>ret</code> anyway, so whatever value was casually in the register EAX will get returned by the program. Luckily, glibc's <code>getchar</code> stores the byte it reads from STDIN in EAX, so the value of that byte is the exit code of our program.</p>
</div>
<div id="pu10" class="pu"><h1>Unix Shell (+ncurses +BSD utilities), <del>36</del>, 26 bytes, 256 exit codes</h1>
<p><strong>Golfed</strong></p>
<pre class="lang-bash prettyprint-override"><code>jot -bu0 $[252+$1]|tput -S
</code></pre>
<blockquote>
<p>If the -S option is used, tput checks for errors from each line, and if any errors are found, will set the exit code to 4 plus the number of lines with errors.  If no errors  are  found,  the exit  code  is  0.  No indication of which line failed can be given so exit code 1 will never appear.  Exit codes 2, 3, and 4 retain their usual interpretation.</p>
</blockquote>
<p>Once the <em>tput</em> exit code goes over 255, it just overflows, so 253 (errors on input) will result in the exit code of 1 e.t.c., thus yielding the desired exit status for the whole range of inputs.</p>
<p><em>Note</em>: whether <em>tput</em> will fail on not, when setting/getting a particular capability, depends on the terminal type, I've used: <code>xterm with 256 colors</code></p>
<p><a href="https://www.freebsd.org/cgi/man.cgi?jot(1)" rel="noreferrer">jot</a> is a <em>BSD</em> utility, which
prints sequential or random data, and (AFAIK) is also available out of the box on OSX systems.</p>
<p>If your system does not have <code>jot</code> available, you can use a slightly longer (29 bytes) version:</p>
<pre class="lang-bash prettyprint-override"><code>yes u0|sed $[252+$1]q|tput -S
</code></pre>
<p><a href="http://www.tutorialspoint.com/execute_bash_online.php?PID=0Bw_CjBb95KQMZ1RmQkN4TEpvMDQ" rel="noreferrer">Try It Online !</a> (the 29 bytes version)</p>
</div>
<div id="pu11" class="pu"><h1>Java, <s>71</s> 66 bytes, 2 exit codes</h1>

<p><em>4 bytes saved thanks to Holger</em></p>

<h3>Full program:</h3>

<pre><code>interface I{static void main(String[]a){a[a[0].charAt(0)-48]="";}}
</code></pre>

<h3>Function taking an int as an argument:</h3>

<pre><code>i-&gt;1/(i-1)
</code></pre>

<p>The program takes the first char of the first argumant (either <code>'0'</code> or <code>'1'</code> and subtracts 48 (ascii value of <code>'0'</code>) to get an integer (0 or 1). It then tries to set the argument at the position of that integer to the empty string. If the input is 1, the program crashes with an <code>ArrayIndexOutOfBoundsException</code>, beacuse the argument array only has one element at position 0 (zero-indexed).</p>
</div>
<div id="pu12" class="pu"><h1>PHP, 15 bytes, 2 exit codes</h1>
<p>Without <code>die</code>/<code>exit</code>, PHP cannot return anything but <code>0</code> or <code>255</code> (afaik; probably <code>~1</code>), so ...</p>
<pre class="lang-php prettyprint-override"><code>!$argv[1]?:p();
</code></pre>
<p>If command line argument is falsy, it evaluates to <code>1</code> and exits with <code>0</code>. If not, it tries to call a function and exits with <code>&lt;b&gt;Fatal error&lt;/b&gt;:  Uncaught Error: Call to undefined function p()</code>.</p>
<p>Run with <code>-r</code>.</p>
</div>
<div id="pu13" class="pu">

<h1><a href="https://perl6.org">Perl 6</a>, 57 bytes, 256 exit codes</h1>

<pre class="lang-perl6 prettyprint-override"><code>use Test;plan $_=@*ARGS[0];ok try {open ""} for ^($_%255)
</code></pre>

<p><a href="https://tio.run/nexus/perl6#bVHLTgJBELzPV5SI4RHklcABsokmEENi1Cx4MkoWaNgJy84yM@tKCD@jRz/BcOGH@ATsJb4OHrurqruqOzuEAx2H2L0jIh00cU7IHWJDGJCx7SjwQmSHzkXx0r3qP1Qf22oOq1dYq4hCZDIbTJXGUz47PKs3GoVDbvdREuKHjkoF1RJwisgzBl6gwhmsT5BhFFshWicqtowzwfpaJfASb4X@oHN7P2CQtP4P7LquaAthuMrQi7RjNaEW2yx/F/lChnE5xZ8OThwHv8bWAkgHLJctqyrdm06FFcDAJ03woog8bWAVRlxhFM/YMXLZ4l3XvS6P1SKSAenyTBqbL@RYx60FhRYc55hvv3092t9v3xDIkNJRhggLpdPwfLSFZ6UK07Ff/A7xmpRvaHyERhSoJDXVs0iUnhveojWDwQqJz@fvwfKTaALJBGl9PJM2qbJerTXLtTpLOZjYHA715ic" title="Perl 6 – TIO Nexus">Try it</a><br>
This is a translation of the Perl 5 example.</p>

<h2>Expanded</h2>

<pre class="lang-perl6 prettyprint-override"><code>use Test;  # bring in ｢plan｣ and ｢ok｣

plan $_ = @*ARGS[0]; # plan on having the input number of tests
                     # only actually needed for the 255 case
                     # if the plan is greater than the number of tests
                     # it fails with exitcode 255


  ok                 # increment the failure counter if the following is False
    try {            # don't let this kill the whole program
      open ""        # fails to open a file
    }

for                  # repeatedly do that

  ^(                 # upto Range
    $_ % 255         # either the input number of times, or 0 times for 255
  )
</code></pre>
</div>
<div id="pu14" class="pu"><h1><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python 3</a>, 15 bytes, 2 exit codes</h1>

<p>Obviously, this is longer than the <a href="https://codegolf.stackexchange.com/a/107203/60919">Python 2 solution</a>, because in Python 3 we can't take a literal input without calling <code>eval</code>. However, we can use string 
comparison techniques interestingly...</p>

<pre class="lang-py prettyprint-override"><code>1/(input()&lt;'1')
</code></pre>

<p>Input will be either the string <code>0</code> or <code>1</code> - if it's 1, the condition evaluates to 0 (false), resulting in an attempt to compute <code>1 / 0</code> which obviously crashes (exit code 1). Otherwise, nothing happens, and Python exits with the regular exit code 0.</p>

<p>As far as I'm aware, Python is incapable of crashing with other exit codes.</p>
</div>
<div id="pu15" class="pu"><h1>Python 2, 13 Bytes, 2 exit codes</h1>

<pre><code>1/(input()-1)
</code></pre>

<p>If you enter 0, it tries to print <code>1/-1</code> which is -1 which is perfectly fine thus exit code 0. If you enter 1, you get <code>1/0</code> which raises a <code>ZeroDivisionError</code> in which there is an exit code of 1. With my IDE, there is only 0 and 1 for the exit codes...</p>

<p>Outputs:</p>

<hr>

<p><a href="https://i.sstatic.net/rdgXr.png" rel="noreferrer"><img src="https://i.sstatic.net/rdgXr.png" alt="enter image description here"></a></p>

<hr>

<p><a href="https://i.sstatic.net/oK1ZY.png" rel="noreferrer"><img src="https://i.sstatic.net/oK1ZY.png" alt="enter image description here"></a></p>
</div>
<div id="pu16" class="pu"><h1>Javascript (node), 19 bytes, 2 exit codes</h1>

<p>Full program:</p>

<pre><code>+process.argv[2]&amp;&amp;a
</code></pre>

<p>Function:</p>

<pre><code>f=i=&gt;i&amp;&amp;f(i)
</code></pre>

<p><code>process.argv</code> is an array that contains the path to the node executable, the path to the javascript file executed and the command line arguments. In this case, this will be either <code>"1"</code> or <code>"0"</code>. The string is converted to a number with the unary <code>+</code> operator. If the number is zero the lazy <code>&amp;&amp;</code> operator won't evaluate the right hand side, if the number is truthy (not zero), the right hand side of <code>&amp;&amp;</code> is evaluated and an error is thrown because it's referencing an undefined variable, and the program exists with exit code 1.</p>

<p>The function expects the input as a number. If the input is truthy, the function calls itself, and crashes the node runtime with a stack overflow. If the input is 0, the lazy <code>&amp;&amp;</code> operator returns 0 without evaluating the right hand side.</p>
</div>
<div id="pu17" class="pu"><h1>C (gcc) under bash shell on x86, 230 bytes, 8 exit codes</h1>
<p>Newlines added to aid readability.  Comments ignored in score.</p>

<pre class="lang-bash prettyprint-override"><code>main(int c, char **v){
int p[2];
switch(atoi(v[1])-128){
case 2:__asm(&quot;UD2&quot;);        /* SIGILL: x86 undefined instruction */
case 5:__asm(&quot;int $3&quot;);     /* SIGTRAP: x86 breakpoint instruction */
case 6:abort();             /* SIGABRT: raise() is called under the covers */
case 8:c/=c-2;              /* SIGFPE: divide by 0 (c-2) */
case 11:c=*(int *)c;        /* SIGSEGV: dereference of invalid pointer */
                            /* SIGPIPE: write() to a pipe closed at the other end */
case 13:socketpair(1,1,0,p);close(p[1]);write(p[0],v,1);
case 14:alarm(1);sleep(2);  /* SIGALRM: kernel will send alarm signal after 1 sec */
}
}
</code></pre>
<p>A feature of the bash shell:</p>
<blockquote>
<p>When a command terminates on a fatal signal N, bash uses the value of 128+N as the exit status.</p>
</blockquote>
<p>So all we need to do is trigger various signals from within a c program.  At this point, I assume simply doing <code>kill(n-128);</code> is banned.  So instead we execute code that triggers various signals, which causes the corresponding error codes to be made available at the calling shell.</p>
<p>The exit codes are 0, 130, 133, 134, 136, 139, 141, 142.</p>
<p><a href="https://tio.run/nexus/c-gcc#Pc7BCsIwDAbg@55iiId0dGg6Fenw5it4kiExFCxurrRlO4jPPjd13vJ/CeEfGrIPsI@Yskz5Rj7Nsk48k0ncWVVlEnob@QYUWwvdGSuRo9qPF0zBpEpfLhQaWJyOaiHKL25nnJ4si7/vNF1bH2HOe82rA@fqFxE1H7JPl0zwjIUOLd9NdGQ9oES5lk6UXLfBgJvqlL23cZrXlewkzs9xo6km38AooTbGgRpXr@Q1DAMWxRs" rel="noreferrer">Try it online</a>.  Expand the &quot;Debug&quot; section to see the return code.</p>
<p>This can certainly be golfed deeper.  But I'd be more interested in adding more signals.</p>
</div>
<div id="pu18" class="pu"><h1>Perl, 108 bytes, 256 exit codes</h1>

<p>This program (ab)uses <a href="http://search.cpan.org/~exodist/Test-Simple-1.302075/lib/Test/More.pm#EXIT_CODES">Test::More</a> module. It tries to open file named <code>""</code> <em>n</em> times where <em>n</em> is given as command line argument. It fails every time, and each invocation is treated as a test. Test::More return number of failed tests as exit code. <code>plan tests =&gt; $ARGV[0]%255</code> is needed to get exit code 255.</p>

<pre><code>#!/usr/bin/perl
use Test::More;
plan tests =&gt; $ARGV[0]%255 if($ARGV[0]&gt;0);
ok(open(F,"")) for (1..$ARGV[0])
</code></pre>
</div>
<div id="pu19" class="pu"><h1>Scala, 19 bytes, 2 exit codes</h1>
<p><code>if(args(0)==&quot;1&quot;)1/0</code></p>
<p><code>1/(args(0).toInt-1)</code></p>
<p>The JVM supports only 1 and 0 as exit codes if you don't call <code>System.exit</code>.</p>
<p>The first program tries to calculate <code>1/0</code> if the first argument is <code>1</code>, which will crash the JVM with an exit code of 1. If the argument is 0, it wil exit succesfully.</p>
<p>The second program to converts the argument to integer, subtracts one and tries to divide 1 by that number. If the argument if 1, it calculates <code>1/0</code>, so the JVM will crash; if the argument is 0, it calculates <code>1/-1</code> and exits.</p>
</div>
<div id="pu20" class="pu"><h1>Turtlèd, 4 bytes, 2 exit codes</h1>

<p>I don't know if there are any ways to get more exit codes... are there even any more ways in the interpreter language</p>

<p>I found a few four length answers</p>

<pre><code>' ?;
</code></pre>

<p><a href="https://tio.run/nexus/turtled#@6@uYG/9/78hAA" rel="noreferrer" title="Turtlèd – TIO Nexus">Try it online!</a></p>

<pre><code>!.(0
</code></pre>

<p><a href="https://tio.run/nexus/turtled#@6@op2Hw/78hAA" rel="noreferrer" title="Turtlèd – TIO Nexus">Try it online!</a></p>

<pre><code>?;(*
</code></pre>

<p><a href="https://tio.run/nexus/turtled#@6@op2Hw/78hAA" rel="noreferrer" title="Turtlèd – TIO Nexus">Try it online!</a></p>

<h2>How these work:</h2>

<pre><code>' ?;
</code></pre>

<p>in my interpreter, there is a <s>bug</s> feature that causes errors when the grid in memory has more than one line, and has no non-space characters on it. this program erases the * on the origin cell <code>'[space]</code>, takes non-negative integer input <code>?</code> (0 or 1 really), and moves down that many <code>;</code>, if it is zero, the grid will only have one line and not error, otherwise it will move down and the error will occur</p>

<pre><code>!.(0
</code></pre>

<p>parentheses and stuff don't get parsed, they just get executed at run time to mean: "skip to the matching paren, if the cell symbol isn't right". in this program, inputting (<code>!</code>) one causes the program to write it to the cell (<code>.</code>), execute the paren, which checks if the cell symbol is 0, try to skip to the matching paren, but instead throw an error as there is none. if it is zero, it writes it down, checks the parentheses, finds itself on a 0, and then ignores it, and the program finishes</p>

<pre><code>?;(*
</code></pre>

<p>has elements of the previous answer, and the first. it takes non-negative integer input, moves down that many, and checks whether the cell is '*', searching for a non existing extra paren if it is not. if the input is 1, it will move off the starting space, and find the cell is a space, and error, if it is zero, it will stay on the start space and ignore the paren.</p>
</div>
<div id="pu21" class="pu"><h2>Python 2, 11 bytes, 2 exit codes</h2>



<pre class="lang-python prettyprint-override"><code>1&gt;&gt;-input()
1/~-input()
0&lt;input()&lt;x
</code></pre>

<p>Three different 11-byte solutions for three different errors! (Just for fun, this doesn't give points.) By default, Python only has exit codes 0 for successful exit and 1 for error. The successful runs don't output anything.</p>

<pre class="lang-python prettyprint-override"><code> 1&gt;&gt;-input()
</code></pre>

<p>On input 1, gives "ValueError: negative shift count". On input 0, a zero shift count succeeds and gives 1.</p>

<pre class="lang-python prettyprint-override"><code>1/~-input()
</code></pre>

<p>On input 1, gives "ZeroDivisionError: integer division or modulo by zero" due to <code>~-input()</code>, aka <code>input()-1</code> being 0. In input 1, <code>1/-1</code> gives -1. <code>0**-input()</code> would also work.</p>

<pre class="lang-python prettyprint-override"><code>0&lt;input()&lt;x
</code></pre>

<p>On input 1, gives "NameError: name 'x' is not defined". On input 0, these first inequality <code>0&lt;0</code> is evaluated to False, so the rest is not evaluated and the result is just False.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/107193/">107193</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




