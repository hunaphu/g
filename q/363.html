<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::363</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td></td><td>190617T185226Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/187015#187015">Jordan</a></td></tr>
<tr d-ix="1"><td>nan</td><td></td><td>180301T110642Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/156957#156957">Asone Tu</a></td></tr>
<tr d-ix="2"><td>nan</td><td></td><td>211109T045633Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/237027#237027">Dingus</a></td></tr>
<tr d-ix="3"><td>nan</td><td></td><td>201231T110705Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/217069#217069">vrintle</a></td></tr>
<tr d-ix="4"><td>nan</td><td></td><td>200430T135049Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/204184#204184">Dingus</a></td></tr>
<tr d-ix="5"><td>nan</td><td></td><td>161222T222031Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/104241#104241">G B</a></td></tr>
<tr d-ix="6"><td>nan</td><td></td><td>110212T220627Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/900#900">Arnaud L</a></td></tr>
<tr d-ix="7"><td>nan</td><td></td><td>160913T194347Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/93145#93145">Jordan</a></td></tr>
<tr d-ix="8"><td>nan</td><td></td><td>190617T184847Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/187014#187014">Jordan</a></td></tr>
<tr d-ix="9"><td>nan</td><td>The <=> spaceship operator compares two expressions and returns 1</td><td>190518T210943Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/185774#185774">Simply B</a></td></tr>
<tr d-ix="10"><td>nan</td><td></td><td>180713T231630Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/168549#168549">Asone Tu</a></td></tr>
<tr d-ix="11"><td>nan</td><td></td><td>180307T150731Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/157518#157518">Asone Tu</a></td></tr>
<tr d-ix="12"><td>nan</td><td></td><td>180127T141137Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/154208#154208">daniero</a></td></tr>
<tr d-ix="13"><td>nan</td><td></td><td>180102T123035Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/152326#152326">Unihedro</a></td></tr>
<tr d-ix="14"><td>nan</td><td>String split function uses $ or space by default if input is spaceseperated</td><td>171106T062515Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/147197#147197">Unihedro</a></td></tr>
<tr d-ix="15"><td>nan</td><td></td><td>171106T231902Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/147305#147305">Simply B</a></td></tr>
<tr d-ix="16"><td>nan</td><td>Save a byte when printing a word with symbols</td><td>161021T075109Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/96912#96912">Cyoce</a></td></tr>
<tr d-ix="17"><td>nan</td><td></td><td>160311T162855Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/75366#75366">Cyoce</a></td></tr>
<tr d-ix="18"><td>nan</td><td>Quick way to check if all items in a Ruby array are unique lists various ways to check whether everything in an array is unique. Unfortunately</td><td>170623T203219Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/128103#128103">ymbirtt</a></td></tr>
<tr d-ix="19"><td>nan</td><td></td><td>170521T010727Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/121844#121844">Simply B</a></td></tr>
<tr d-ix="20"><td>nan</td><td></td><td>160902T192252Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/92066#92066">daniero</a></td></tr>
<tr d-ix="21"><td>nan</td><td>Use the short predefined variables wherever possible</td><td>110202T094709Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/368#368">Nemo157</a></td></tr>
<tr d-ix="22"><td>nan</td><td></td><td>161201T221332Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/101857#101857">Cyoce</a></td></tr>
<tr d-ix="23"><td>nan</td><td></td><td>160828T202318Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/91468#91468">Jordan</a></td></tr>
<tr d-ix="24"><td>nan</td><td></td><td>161021T074441Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/96911#96911">Cyoce</a></td></tr>
<tr d-ix="25"><td>nan</td><td>To subtract one 1</td><td>160826T210709Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/91293#91293">Markus</a></td></tr>
<tr d-ix="26"><td>nan</td><td>To join an array</td><td>160826T211147Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/91295#91295">Markus</a></td></tr>
<tr d-ix="27"><td>nan</td><td></td><td>160415T194507Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/77872#77872">MegaTom</a></td></tr>
<tr d-ix="28"><td>nan</td><td></td><td>140806T061740Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/35812#35812">Cristian</a></td></tr>
<tr d-ix="29"><td>002</td><td>You may be able to save</td><td>150824T153456Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/55245#55245">Justin</a></td></tr>
<tr d-ix="30"><td>nan</td><td></td><td>151207T170020Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/65951#65951">MegaTom</a></td></tr>
<tr d-ix="31"><td>nan</td><td></td><td>151124T192142Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/64682#64682">daniero</a></td></tr>
<tr d-ix="32"><td>001</td><td>If you ever need to get a number from ARGV</td><td>140704T202548Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/32974#32974">addison</a></td></tr>
<tr d-ix="33"><td>nan</td><td>When a challenge requires that you output multiple lines</td><td>150816T165004Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/54792#54792">daniero</a></td></tr>
<tr d-ix="34"><td>001</td><td>When you are using string interpolation</td><td>150627T204419Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/52357#52357">daniero</a></td></tr>
<tr d-ix="35"><td>nan</td><td>Yet another way to use the splat operator if you want to assign a single array literal</td><td>150815T223236Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/54766#54766">Martin E</a></td></tr>
<tr d-ix="36"><td>nan</td><td>To check if a is an Array</td><td>150523T104730Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/50671#50671">rr-</a></td></tr>
<tr d-ix="37"><td>nan</td><td></td><td>150507T232319Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/49792#49792">blutoran</a></td></tr>
<tr d-ix="38"><td>nan</td><td></td><td>150403T150330Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/48410#48410">villu164</a></td></tr>
<tr d-ix="39"><td>002</td><td>When working with arrays</td><td>141105T131349Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/41044#41044">Cristian</a></td></tr>
<tr d-ix="40"><td>nan</td><td></td><td>140909T122454Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/37519#37519">Martin E</a></td></tr>
<tr d-ix="41"><td>nan</td><td></td><td>121220T225401Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/9268#9268">F&#225;b</a></td></tr>
<tr d-ix="42"><td>nan</td><td></td><td>120305T121838Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/5050#5050">Hauleth</a></td></tr>
<tr d-ix="43"><td>nan</td><td></td><td>140525T040300Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/28578#28578">kernigh</a></td></tr>
<tr d-ix="44"><td>nan</td><td></td><td>110202T130917Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/377#377">sepp2k</a></td></tr>
<tr d-ix="45"><td>nan</td><td>If the first line starts with #! and contains ruby</td><td>140523T031954Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/28474#28474">kernigh</a></td></tr>
<tr d-ix="46"><td>nan</td><td></td><td>140212T073757Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/20649#20649">S Shah</a></td></tr>
<tr d-ix="47"><td>nan</td><td>Build arrays using a=i</td><td>140127T174145Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/19493#19493">histocra</a></td></tr>
<tr d-ix="48"><td>nan</td><td>Use Goruby instead of Ruby</td><td>121223T215911Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/9289#9289">Patrick </a></td></tr>
<tr d-ix="49"><td>nan</td><td></td><td>120826T082352Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/7089#7089">knut</a></td></tr>
<tr d-ix="50"><td>nan</td><td>If you need to find if a particular element e is inside a range r</td><td>120601T142823Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/6132#6132">Cristian</a></td></tr>
<tr d-ix="51"><td>nan</td><td></td><td>110626T110144Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/2992#2992">Lowjacke</a></td></tr>
<tr d-ix="52"><td>nan</td><td>Scientific notation can often be used to shave off a char or two</td><td>110225T092231Z</td><td><a href="https://codegolf.stackexchange.com/questions/363/tips-for-golfing-in-ruby/1180#1180">anonymou</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>New features in Ruby 2.7 (experimental)</h1>
<p>Ruby 2.7 is in prerelease (as of 17 Jun 2019) and has some features that look great for golfing. Note that some of them might not make it into the final 2.7 release.</p>
<p>All changes in Ruby 2.7-preview1: <a href="https://github.com/ruby/ruby/blob/v2_7_0_preview1/NEWS" rel="nofollow noreferrer">https://github.com/ruby/ruby/blob/v2_7_0_preview1/NEWS</a></p>

<h3>Numbered block parameters</h3>
<p>This is my favorite. It lets you <em>finally</em> drop the <code>|a,b|</code> in a block:</p>
<p><strong>Edit:</strong> The syntax was changed from <code>@1</code> to <code>_1</code>.</p>
<pre class="lang-ruby prettyprint-override"><code>%w[a b c].zip(1..) { puts _1 * _2 }
# =&gt; a
#    bb
#    ccc
</code></pre>
<h3><s>Method reference operator: <code>.:</code></s></h3>
<p><strong>Edit:</strong> This was unfortunately removed before release.</p>
<p><code>.:</code> is syntactic sugar for the <code>.method</code> method, e.g.:</p>
<pre class="lang-ruby prettyprint-override"><code>(1..5).map(&amp;1r.:/)
# =&gt; [(1/1), (1/2), (1/3), (1/4), (1/5)]
</code></pre>
<h3>Pattern matching</h3>
<p>I'm not sure how much use this will see in golf, but it's a great feature for which I only have a contrived example:</p>
<pre class="lang-ruby prettyprint-override"><code>def div(*a)
  case a
    in [0, 0] then nil
    in [x, 0] if x &gt; 0 then Float::INFINITY
    in [x, 0] then -Float::INFINITY
    in [x, y] then x.fdiv(y)
  end
end

div(-3, 0) # =&gt; -Infinity
</code></pre>
<p>The pattern matching syntax has lots of features. For a complete list, check out this presentation: <a href="https://speakerdeck.com/k_tsj/pattern-matching-new-feature-in-ruby-2-dot-7" rel="nofollow noreferrer">https://speakerdeck.com/k_tsj/pattern-matching-new-feature-in-ruby-2-dot-7</a></p>
<p>This is also the feature most likely to change before 2.7 is finished; it even prints a warning when you try to use it, which you should heed:</p>
<blockquote>
<p>warning: Pattern matching is experimental, and the behavior may change in future versions of Ruby!</p>
</blockquote>
<h3>Beginless Range: <code>..3</code></h3>
<p>Analogous to the endless Range introduced in 2.6, it may or may not have much use in golfing:</p>
<pre class="lang-ruby prettyprint-override"><code>%w[a v o c a d o].grep(..?m)
# =&gt; [&quot;a&quot;, &quot;c&quot;, &quot;a&quot;, &quot;d&quot;]
</code></pre>
<h3><code>Enumerable#tally</code> to count like elements</h3>
<p>This could be useful in golfing:</p>
<pre class="lang-ruby prettyprint-override"><code>%w[a v o c a d o].tally
# =&gt; {&quot;a&quot;=&gt;2, &quot;v&quot;=&gt;1, &quot;o&quot;=&gt;2, &quot;c&quot;=&gt;1, &quot;d&quot;=&gt;1}
</code></pre>
<h3><code>Enumerable#filter_map</code> to <code>filter</code>+<code>map</code> in one</h3>
<pre class="lang-ruby prettyprint-override"><code>(1..20).filter_map {|i| 10 * i if i.even? }
# =&gt; [20, 40, 60, 80, 100]
</code></pre>
<p>If the block returns <code>nil</code> or <code>false</code> the element will be omitted from the result.</p>
<h3><code>Integer#[]</code> takes a second argument or range:</h3>
<p>You've long been able to get a specific bit from an integer with with subscript notation:</p>
<pre class="lang-ruby prettyprint-override"><code>n = 77 # (binary 01001101)
n[3] # =&gt; 1
</code></pre>
<p>Now you can get the value of a range of bits by a second length argument or a range.</p>
<pre class="lang-ruby prettyprint-override"><code>n = 0b01001101
n[2, 4] # =&gt; 3 (0011)
n[2..5] # =&gt; 3
</code></pre>
<p>Note that bits are indexed from least- to most-significant (right to left).</p>
</div>
<div id="pu1" class="pu"><h1>On looping</h1>

<h3><code>while...end</code></h3>
<p>If you need to <code>break</code> out of the loop, <code>while condition;code;end</code> will probably be shorter than <code>loop{code;condition||break}</code>.</p>
<p>The <code>;</code> before <code>end</code> is not always required, eg. <code>while condition;p(&quot;text&quot;)end</code></p>
<p><code>until c;...;end</code> is equivalent to <code>while !c;...;end</code> and 1 byte shorter.</p>
<p>Note that in most cases <code>code while condition</code> and <code>code until condition</code> are significantly shorter as they don't require the <code>end</code> keyword and can often drop semicolons. Also, <code>i+=1 while true</code> is equivalent to <code>i+=1while true</code> and 1 byte shorter.</p>
<h3><code>redo</code></h3>
<p>When run, the <code>redo</code> command jumps back to the beginning of the block it's in.</p>
<p>When using <code>redo</code> in a lambda, you will have to move any setup variables to the arguments to avoid them being reset at every iteration (see examples).</p>
<h3>recursion</h3>
<p>Recursion can be shorter is some cases. For instance, if you're working on an array element by element, something like <code>f=-&gt;s,*t{p s;t[0]&amp;&amp;f[*t]}</code> can be shorter than the alternatives depending on the <code>stuff</code>.</p>
<p>Note that per the <a href="https://codegolf.meta.stackexchange.com/a/6940/77598">current consensus</a>, if you're calling your function by name, you need to include the assignment (<code>f=</code>) in the byte count making all recursive lambdas 2 bytes longer by default.</p>
<h3><code>eval</code></h3>
<p>If you need to run some code <code>n</code> times, you can use <code>eval&quot;code;&quot;*n</code>.</p>
<p>This will concatenate <code>code;</code> <code>n</code> times and run the whole thing.</p>
<p>Note that in most cases you need to include a <code>;</code> after your code.</p>
<h2>Examples</h2>
<h3>A lambda to print all numbers from <code>1</code> to <code>a</code> inclusive:</h3>
<pre class="lang-ruby prettyprint-override"><code>-&gt;n{i=0;loop{p i+=1;i&lt;n||break}} # 32 bytes
f=-&gt;n,i=1{i&gt;n||p(i)&amp;&amp;f[n,i+1]}   # 30 bytes
-&gt;n,i=0{p(i+=1)&lt;n&amp;&amp;redo}         # 24 bytes
-&gt;n{i=0;p i+=1while i&lt;n}         # 24 bytes
-&gt;n{i=0;eval&quot;p i+=1;&quot;*n}         # 24 bytes
-&gt;n{n.times{|i|p i+1}}           # 22 bytes # thanks to @benj2240
-&gt;n{n.times{p _1+1}}             # 20 bytes # thanks to @AgentIvan
</code></pre>
<p>In this case, since the end-point is defined (<code>n</code>), the <code>n.times</code> loop is the shortest.</p>
<p>The <code>redo</code> loop works because <code>i+=1</code> modifies i and returns its new value and <code>p(x)</code> returns <code>x</code> (this is not true of <code>print</code> and <code>puts</code>).</p>
<h3>Given a function <code>g</code> and a number <code>n</code>, find the first number strictly larger than <code>n</code> for which <code>g[n]</code> is truthy</h3>
<pre class="lang-ruby prettyprint-override"><code>-&gt;g,n{loop{g[n+=1]&amp;&amp;break};n}     # 29 bytes
f=-&gt;g,n{g[n+=1]?n:f[g,n]}         # 25 bytes
-&gt;g,n{1until g[n+=1];n}           # 23 bytes
-&gt;g,n{(n+1..).find &amp;g}            # 22 bytes
-&gt;g,n{g[n+=1]?n:redo}             # 21 bytes
</code></pre>
<p>In this case, with an unknown end-point, <code>redo</code> is the best option.</p>
<p>The <code>(n+1..Inf)</code> loop is equivalent to simply <code>loop</code>ing indefinitely but more verbose.</p>
<p>A <code>1</code> (or anything else) is required before the <code>until</code> keyword to complete the syntax, using a number allows you to drop a space.</p>
<p>The <code>eval</code> method is not viable in this case because there is neither a defined end-point nor an upper bound.</p>
<p>Update: with the new open ranges <code>(n+1..Inf)</code> can be written simply as <code>(n+1..)</code>, also <code>.find{|x|g[x]}</code> is equivalent to <code>.find &amp;g</code> where <code>g</code> is converted to a block.</p>
<br>
<p>TL;DR check out <code>redo</code>, it can very often shave off a couple of bytes</p>
</div>
<div id="pu2" class="pu"><h1>Avoid <code>String#sub!</code></h1>
<p>Instead of</p>
<pre class="lang-ruby prettyprint-override"><code>a.sub!b,c
</code></pre>
<p>save a byte with</p>
<pre><code>a[b]&amp;&amp;=c
</code></pre>
<p>Both return <code>nil</code> if no substitution occurs. If a substitution does occur, be aware that the return values differ: <code>a.sub!b,c</code> returns the modified string <code>a</code> whereas <code>a[b]&amp;&amp;=c</code> returns <code>c</code>. However, given that you're using <code>sub!</code> (as opposed to <code>sub</code>) chances are that either:</p>
<ul>
<li>You just need to modify <code>a</code> in place and will be discarding the return value anyway; or</li>
<li>You just need the return value to be truthy.</li>
</ul>
<p>The shorter form meets your needs in both cases.</p>
</div>
<div id="pu3" class="pu"><h1>Filtering a specific class from an Array</h1>
<p>Suppose, you've to choose only <code>Integer</code> from</p>

<pre class="lang-ruby prettyprint-override"><code>a = [1, 2, &quot;3&quot;, 4.0, [5], &quot;6&quot;.to_sym, 7r]
</code></pre>
<p>then you can do,</p>
<pre class="lang-ruby prettyprint-override"><code>a.keep_if{|x|x.kind_of? Integer} # 32 bytes
a.keep_if{|x|x.is_a? Integer} # 29 bytes
a.select{|x|x.is_a? Integer} # 28 bytes
a.select{|x|Integer===x} # 24 bytes
a.grep(Integer) # 15 bytes
</code></pre>
<p><a href="https://tio.run/##dcpPC4IwGIDxu5/ixS4FY@TU/hxG5z6DyJj1KmKpbAs2ss@@pDwY1fHh@alb4byXwCGLCDACYRwSSOiaQJbmY25Cajqh3ZXAVuVB0IOkDWIv6vI@2MHSpm7PoisPcGwNVqgesICYQeEM6m9dayE/KNvPqMYLnsw/ufspJ8E5ty@VzFSlsF9OYDXOKH1P758" rel="nofollow noreferrer" title="Ruby â€“ Try It Online">Try it online!</a></p>
<hr />
<p>You can use <code>Numeric</code> class in case you want numbers only.</p>
</div>
<div id="pu4" class="pu"><h1>Avoid <code>Array#repeated_permutation</code> and <code>Array#repeated_combination</code></h1>
<p><em>Credit to @AsoneTuhid who golfed the code for repeated permutations of length <span class="math-container">\$\ge5\$</span>.</em></p>
<p>Some of Ruby's built-in methods have unfortunately long names. Never use <code>Array#repeated_permutation</code> or <code>Array#repeated_combination</code>; save bytes as follows.</p>
<h3>Repeated permutations</h3>
<p>Assume <code>a</code> is an array. To get repeated permutations of length <span class="math-container">\$L = n + 1\$</span> of the elements of <code>a</code>:</p>
<pre class="lang-ruby prettyprint-override"><code>a.product(a,a,a)  # L &lt;= 4; number of arguments = n
a.product(*[a]*n) # L &gt;= 5
</code></pre>
<p>Depending on context, the parentheses may not be required. Both of the above yield an array. To iterate over the permutations, simply call with a block.</p>
<h3>Repeated combinations</h3>
<p>For repeated combinations of length <span class="math-container">\$L\$</span>, use one of</p>
<pre class="lang-ruby prettyprint-override"><code>a.send(a.methods[42],L)    # enumerator
[*a.send(a.methods[42],L)] # array
</code></pre>
<p>The index that yields <code>:repeated_combination</code> depends on the Ruby version and possibly the OS (<code>42</code> is correct for Ruby 2.5.5 on Linux, which is the version on <a href="https://tio.run/#ruby" rel="nofollow noreferrer">TIO</a> at the time of writing). The default indexing may also be <a href="https://codegolf.stackexchange.com/a/212107/92901">disrupted</a> if any libraries are loaded. The correct index in any case can always be found using <code>[].methods.index(:repeated_combination)</code>.</p>
<hr />
<p>In general, calling a method by index using <code>Object#send</code> and <code>Object#methods</code>, as demonstrated above for repeated combinations, is shorter than a direct method call when the number of bytes in the method name and the index of the method in the <code>methods</code> array satisfy:</p>
<pre>
+-------+-------+
| <b>Bytes</b> | <b>Index</b> |
+-------+-------+
|  19+  |  0-9  |
|  20+  | 10-99 |
|  21+  | 100+  |
+-------+-------+
Subtract 1 from byte count if parentheses not needed for send.
</pre>
</div>
<div id="pu5" class="pu"><ul>
<li><p>To generate symmetric output, you can use a single range like (-x..x) and then map a function on the absolute value:
<code>(-8..8).map{|x|x.abs}</code></p></li>
<li><p>Use short-circuit evaluation of boolean expressions to avoid if...else: <code>x&gt;1&amp;&amp;s+=x</code></p></li>
<li><p>To check if an integer array <code>a</code> contains a number <code>x</code>, you can use <code>a-[x]!=a</code>, especially useful if  <code>x</code> is an expression.</p></li>
<li><p>Defining a variable as an accumulator is often shorter than using map and then reduce.</p></li>
<li><p>Use string interpolation with <code>%</code> for alignment: <code>"x%12s"%?x</code> is shorter than <code>?x+11*" "+?x</code> or for base conversions: <code>"%b"%65</code> vs <code>65.to_s(2)</code></p></li>
<li><p>Use complex number for trigonometric functions: <code>-1.arg</code>is PI, <code>1i.arg</code> is PI/2, <code>(a+b*1i).arg</code> is <code>Math.atan(b/a)</code> and works even when a and b are integers.</p></li>
</ul>
</div>
<div id="pu6" class="pu"><p>Use the splat operator to get the tail and head of an array:</p>

<pre><code>head, *tail = [1,2,3]
head =&gt; 1
tail =&gt; [2,3]
</code></pre>

<p>This also works the other way:</p>

<pre><code>*head, tail = [1,2,3]
head =&gt; [1,2]
tail =&gt; 3
</code></pre>

<p>Use the <code>*</code> method with a string on an array to join elements:</p>

<pre><code>[1,2,3]*?,
=&gt; "1,2,3"
</code></pre>
</div>
<div id="pu7" class="pu"><h1>New features in Ruby 2.3 and 2.4</h1>

<p>It's good to stay abreast of new language features that will help your golf game. There are a few great ones in the latest Rubies.</p>



<h2>Ruby 2.3</h2>

<h3>The safe navigation operator: <code>&amp;.</code></h3>

<p>When you call a method that might return <code>nil</code> but you want to chain additional method calls if it's not, you waste bytes handling the <code>nil</code> case:</p>

<pre class="lang-ruby prettyprint-override"><code>arr = ["zero", "one", "two"]
x = arr[5].size
# =&gt; NoMethodError: undefined method `size' for nil:NilClass

x = arr[5].size rescue 0
# =&gt; 0
</code></pre>

<p>The "safe navigation operator" stops the chain of method calls if one returns <code>nil</code> and returns <code>nil</code> for the whole expression:</p>

<pre class="lang-ruby prettyprint-override"><code>x = arr[5]&amp;.size || 0
# =&gt; 0
</code></pre>

<h3><code>Array#dig</code> &amp; <code>Hash#dig</code></h3>

<p>Deep access to nested elements, with a nice short name:</p>

<pre class="lang-ruby prettyprint-override"><code>o = { foo: [{ bar: ["baz", "qux"] }] }
o.dig(:foo, 0, :bar, 1) # =&gt; "qux"
</code></pre>

<p>Returns <code>nil</code> if it hits a dead end:</p>

<pre class="lang-ruby prettyprint-override"><code>o.dig(:foo, 99, :bar, 1) # =&gt; nil
</code></pre>

<h3><code>Enumerable#grep_v</code></h3>

<p>The inverse of <code>Enumerable#grep</code>â€”returns all elements that don't match the given argument (compared with <code>===</code>). Like <code>grep</code>, if a block is given its result is returned instead.</p>

<pre class="lang-ruby prettyprint-override"><code>(1..10).grep_v 2..5 # =&gt; [1, 6, 7, 8, 9, 10]
(1..10).grep_v(2..5){|v|v*2} # =&gt; [2, 12, 14, 16, 18, 20]
</code></pre>

<h3><code>Hash#to_proc</code></h3>

<p>Returns a Proc that yields the value for the given key, which can be pretty handy:</p>

<pre class="lang-ruby prettyprint-override"><code>h = { N: 0, E: 1, S: 2, W: 3 }
%i[N N E S E S W].map(&amp;h)
# =&gt; [0, 0, 1, 2, 1, 2, 3]
</code></pre>

<h2>Ruby 2.4</h2>

<p>Ruby 2.4 isn't out yet, but it will be soon and has some great little features. (When it's released I'll update this post with some links to the docs.) I learned about most of these in <a href="https://blog.blockscore.com/new-features-in-ruby-2-4/" rel="nofollow noreferrer">this great blog post</a>.</p>

<h3><code>Enumerable#sum</code></h3>

<p>No more <code>arr.reduce(:+)</code>. You can now just do <code>arr.sum</code>. It takes an optional initial value argument, which defaults to 0 for Numeric elements (<code>[].sum == 0</code>). For other types you'll need to provide an initial value. It also accepts a block that will be applied to each element before addition:</p>

<pre class="lang-ruby prettyprint-override"><code>[[1, 10], [2, 20], [3, 30]].sum {|a,b| a + b }
# =&gt; 66
</code></pre>

<h3><code>Integer#digits</code></h3>

<p>This returns an array of a number's digits in least-to-greatest significance order:</p>

<pre class="lang-ruby prettyprint-override"><code>123.digits # =&gt; [3, 2, 1]
</code></pre>

<p>Compared to, say, <code>123.to_s.chars.map(&amp;:to_i).reverse</code>, this is pretty nice.</p>

<p>As a bonus, it takes an optional radix argument:</p>

<pre class="lang-ruby prettyprint-override"><code>a = 0x7b.digits(16) # =&gt; [11, 7]
a.map{|d|"%x"%d} # =&gt; ["b", "7"]
</code></pre>

<h3><code>Comparable#clamp</code></h3>

<p>Does what it says on the tin:</p>

<pre class="lang-ruby prettyprint-override"><code>v = 15
v.clamp(10, 20) # =&gt; 15
v.clamp(0, 10) # =&gt; 10
v.clamp(20, 30) # =&gt; 20
</code></pre>

<p>Since it's in Comparable you can use it with any class that includes Comparable, e.g.:</p>

<pre class="lang-ruby prettyprint-override"><code>?~.clamp(?A, ?Z) # =&gt; "Z"
</code></pre>

<h3><code>String#unpack1</code></h3>

<p>A 2-byte savings over <code>.unpack(...)[0]</code>:</p>

<pre class="lang-ruby prettyprint-override"><code>"ðŸ‘»ðŸ’©".unpack(?U)    # =&gt; [128123]
"ðŸ‘»ðŸ’©".unpack(?U)[0] # =&gt; 128123
"ðŸ‘»ðŸ’©".unpack1(?U)   # =&gt; 128123
</code></pre>

<h3>Precision argument for <code>Numeric#ceil</code>, <code>floor</code>, and <code>truncate</code></h3>

<pre class="lang-ruby prettyprint-override"><code>Math::E.ceil(1) # =&gt; 2.8
Math::E.floor(1) # =&gt; 2.7
(-Math::E).truncate(1) # =&gt; -2.7
</code></pre>

<h3>Multiple assignment in conditionals</h3>

<p>This raises an error in earlier versions of Ruby, but is allowed in 2.4.</p>

<pre class="lang-ruby prettyprint-override"><code>(a,b=1,2) ? "yes" : "no" # =&gt; "yes"
(a,b=nil) ? "yes" : "no" # =&gt; "no"
</code></pre>
</div>
<div id="pu8" class="pu"><h1>New features in Ruby 2.5 and 2.6</h1>

<p>Ruby keeps getting new features that look like they could be handy for golfing. Here are some that caught my eye. If there's any you think should be added feel free to edit or mention them in the comments.</p>

<p>(See also <a href="https://codegolf.stackexchange.com/a/93145/11261">New features in Ruby 2.3 and 2.4</a>.)</p>

<h2>Ruby 2.5</h2>

<p>Here's an easy-to-read reference with all of the new features in Ruby 2.5: <a href="https://rubyreferences.github.io/rubychanges/2.5.html" rel="nofollow noreferrer">https://rubyreferences.github.io/rubychanges/2.5.html</a></p>

<h2>Regexp absence operator: <code>(?~foo)</code></h2>

<p>This matches any string that doesn't end with <code>foo</code>. I don't have a specific use for this one off the top of my head, but <a href="https://medium.com/rubyinside/the-new-absent-operator-in-ruby-s-regular-expressions-7c3ef6cd0b99" rel="nofollow noreferrer">here's a good article about it</a>.</p>

<h3><code>Enumerable#all?</code>, <code>any?</code>, <code>none?</code>, and <code>one?</code> accept objects that respond to <code>===</code></h3>

<p>Similar to <code>Enumerable#grep</code>:</p>

<pre><code>%w[Foo bar].one?(/[A-Z]/) # =&gt; true
%w[Foo bar].any?("bar") # =&gt; true
[1, 2, 3, 5, 7, 11].all?(0..10) # =&gt; false
</code></pre>

<h3><code>Hash#slice</code> gets a subset of a Hash</h3>

<p>I don't see a lot of Hashes in Ruby golf, but it might come in handy:</p>

<pre><code>{foo: 1, bar: 2, baz: 3}.slice(:bar, :baz) # =&gt; {foo: 1, bar: 2}
</code></pre>

<hr>

<h2>Ruby 2.6</h2>

<p>All of the changes in Ruby 2.6: <a href="https://rubyreferences.github.io/rubychanges/2.6.html" rel="nofollow noreferrer">https://rubyreferences.github.io/rubychanges/2.6.html</a></p>

<h3>Endless Range: <code>1..</code></h3>

<p>Lots of potential uses for this.</p>

<pre><code>%w[a b c].zip("X"..).to_a
# =&gt; [["a", "X"], ["b", "Y"], ["c", "Z"]]

[1, 2, 3, 5, 7, 11].any?(10..)
# =&gt; true
</code></pre>

<h3><code>String#split</code> takes a block</h3>

<p>Saves four bytes when iterating over the result of <code>String#split</code>, e.g.:</p>

<pre><code>"foo;bar;baz".split(?;).map {|s| x &lt;&lt; s.upcase if ... }
</code></pre>

<p>You can do this:</p>

<pre><code>"foo;bar;baz".split(?;) {|s| x &lt;&lt; s.upcase if ... }
</code></pre>

<p>Note that it still returns the original string, so it won't always be fewer bytes than <code>map</code>.</p>

<h3>Proc composition with <code>&gt;&gt;</code> and <code>&lt;&lt;</code></h3>

<p>Procs now have <code>&gt;&gt;</code> and <code>&lt;&lt;</code> methods that let them be combined with other procs, or any object that responds to <code>call</code>:</p>

<pre><code>double = -&gt;n{ n * 2 }
square = -&gt;n{ n ** 2 }
(double &gt;&gt; square)[5] # =&gt; 100
(double &lt;&lt; square)[5] # =&gt; 50
</code></pre>

<h3><code>%</code> operator for Range</h3>

<p>An alias for <code>Range#step</code>:</p>

<pre><code>((1..10) % 2).to_a
# =&gt; [1, 3, 5, 7, 9]
</code></pre>

<h3><code>Random.bytes</code></h3>

<p>Could be handy.</p>

<pre><code>Random.bytes(10)
# =&gt; "'\xB2\xD7\ny"
</code></pre>
</div>
<div id="pu9" class="pu"><p>The <code>&lt;=&gt;</code> <a href="https://stackoverflow.com/q/827649">(spaceship) operator</a> compares two expressions and returns -1, 0, or 1. Applies to anything that can be compared with <code>&lt;</code>, <code>&gt;</code>, and <code>==</code>.</p>

<p>Some example uses:</p>

<p><code>x&lt;=&gt;0</code> is equivalent to the <a href="https://en.wikipedia.org/wiki/Sign_function" rel="nofollow noreferrer">sign function</a>.</p>

<p><code>x.*x&lt;=&gt;0</code> is the absolute value of <code>x</code>.</p>
</div>
<div id="pu10" class="pu"><h1>Use <code>~//</code> and <code>!//</code> to match against <code>$_</code> (last line read)</h1>
<p>These can be used with the <code>-n</code> or <code>-p</code> flags.</p>
<p><code>~/regex/</code> is equivalent to <code>$_=~/regex/</code> returning the index of the first match or <code>nil</code>.</p>
<p><a href="https://tio.run/##KypNqvz/v0ChTj9R////RK6kf/kFJZn5ecX/dfMA" rel="nofollow noreferrer" title="Ruby â€“ Try It Online">Try it online!</a></p>
<p><code>!/regex/</code> equivalent to <code>$_!~/regex/</code> returning <code>true</code> or <code>false</code>.</p>
<p><a href="https://tio.run/##KypNqvz/v0BBUT9R////RK6kf/kFJZn5ecX/dfMA" rel="nofollow noreferrer" title="Ruby â€“ Try It Online">Try it online!</a></p>
<h3>Note that <code>!//</code> is weird as it doesn't call the <code>!</code> method on the regex but only if you use a literal.</h3>
<p><code>!/regex/</code> matches the expression.</p>
<p><code>r=/regex/;!r</code> calls the <code>!</code> (<code>not</code>) method and always returns <code>false</code>.</p>
<p>Also, <code>!r=/regex/</code> gives an <code>assignment in conditional</code> warning so there's some syntactic sugar going on.</p>
</div>
<div id="pu11" class="pu"><h2>Cloning strings</h2>

<p>Strings are mutable in Ruby so if you have two variables holding the same string (<code>a=b=&quot;string&quot;</code>) and you modify one (<code>a[0]=&quot;S&quot;</code>), the other will also change (<code>b==&quot;String&quot;</code>)</p>
<p>To clone a string:</p>
<pre class="lang-ruby prettyprint-override"><code>a=&quot;string&quot;

b=a.clone # 9 bytes
b=a.dup # 7 bytes
b=+-a # 5 bytes
b=-a # 4 bytes (b will be frozen)
</code></pre>
</div>
<div id="pu12" class="pu"><h1>Use <code>eval</code> instead of <code>reduce</code></h1>



<p>While <code>array.sum</code> is great and shorter than <code>array.reduce(:+)</code>, there are no similar methods for the other operators <code>*</code>, <code>-</code>, <code>/</code> ...</p>

<p>Joining arrays and <code>eval</code>ing them saves some space:</p>

<pre class="lang-rb prettyprint-override"><code>a = [1,2,3,4]

a.reduce(:*)   # =&gt; 24
eval(a*?*)     # =&gt; 24
          ^^   two bytes saved.
</code></pre>

<p>It also removes the need to map string input to numbers first:</p>

<pre class="lang-rb prettyprint-override"><code>b = "1 2 3 4".split

b.map(&amp;:to_i).reduce(:*)
eval(b*?*)
          ^^^^^^^^^^^^^^
</code></pre>
</div>
<div id="pu13" class="pu"><h2>Fun with arrays</h2>

<p>There are many ways to do the same thing in ruby, and often times the default methods are inefficient - as a case study, a new arrays with set size and initialized to all <code>10</code>:</p>

<pre><code>Array.new(20,10) # idiomatic
[10]*20
</code></pre>

<p>You may already be informed not to use this syntax, however, when you are initializing elements in an array that needs to not be shallow-cloned, for example 2D arrays:</p>

<pre><code>[[]]*20               # beware, all 20 elements points to the one same array
Array.new(20){[]}     # idiomatic
20.times.map{[]}
([0]*20).map{[]}      # free ticket, you can move any line into `0` to save newline
([a,b,c,d]*5).map{[]} # saves a char when you move 4 1-time use expressions
(1..20).map{[]}
</code></pre>

<p>Many operations in ruby will create new objects. Sometimes this is to our advantage. For example, to create a new array with the same size as another array, we can get by without even knowing its <code>.size</code> at all:</p>

<pre><code>[0]*a.size # looks kinda nice
a.map{0}   # -2 chars
</code></pre>

<p>(Note: the <code>[]*</code> version may be preferable in cases where you also want to reuse the value, so <code>[0]*b=a.size</code> might end up helping you cut a char elsewhere)</p>

<p>To shallow clone an array:</p>

<pre><code>b=a[0..-1] # makes sense
b=a.clone
b=a*1      # this returns new_ary
b=*a       # this version for assignments - use [*a] in expressions
</code></pre>
</div>
<div id="pu14" class="pu"><p>String split function uses <code>$;</code> or space by default; if input is space-seperated, you can omit the argument.</p>



<pre class="lang-ruby prettyprint-override"><code># Reads 3 integers from line 1 of input file
x,y,z=gets.split.map &amp;:to_i
</code></pre>

<p>Or, you can configure the behaviour of ARGF with <code>$/</code> (if there is only one line):</p>

<pre class="lang-ruby prettyprint-override"><code># Reads 3 integers from input file
# Not seperated by newlines, so in case of:
# 1 2
# 3 4
# You will get: 1 2 4 ("2\n3".to_i -&gt; 2)
$/=' '
x,y,z=$&lt;.map &amp;:to_i
</code></pre>

<p>Due to the predictable behaviour of <code>.to_i</code> / <code>.to_f</code>, if you only have two numbers, you can use <code>string.to_i</code>(/<strong>.to_f</strong>) to get the first number and substring after the non-digit (even simpler for space) for the two values. There are tricks if you already know the constraints on the length of the numbers and especially so if the first one is length 1-2:</p>

<pre class="lang-ruby prettyprint-override"><code>v=gets           # 1 2 / 11 22 / 11 22222222222222222222 / 123 4567890123456
v.to_i           # 1*    11*     11*                       123*
v[2,9].to_i      # 2*#$  22*#$   22222222                  3
v[2,99].to_i     # 2#$   22#$    22222222222222222222*#    3
v[2..-1].to_i    # 2#    22#     22222222222222222222*#    3
v[/\d+$/].to_i   # 2     22      22222222222222222222      4567890123456
<del>v[~/ /,9].to_i   # 2$    22$     22222222                  45678901
v[~/ /,99].to_i  # 2     22      22222222                  4567890123456*
v[~/ /..-1].to_i # 2     22      22222222                  4567890123456</del></code></pre>

<p><sub>*: recommend to use in cases as specific than this<br>
#: 1st int in string length is expected to be &lt;=2 (-10 &lt; x &lt; 100)<br>
$: 2nd int in string length is expected to be &lt;=8 (if 1st int is length 1: &lt;=9)<br>
Note: <code>[x,99]</code> will take <code>99</code> characters, while <code>..-1</code> goes all the way to end of string. <del>Because <code>~/ /</code> matches the index of the space, this should be accounted for: <code>[~/ /,9]</code> will get length 8 int at most, as first char is the space</del><br>
Note: If there are three+ numbers, please just use <code>split</code> or <code>map</code></sub></p>

<p>The above trick can be combined with <code>$_</code>:</p>

<pre class="lang-ruby prettyprint-override"><code>p *gets.to_i..$_[2,9].to_i
</code></pre>

<p>Handy ways to repeat strings:</p>

<pre class="lang-ruby prettyprint-override"><code># aaaaabcbcbcbcaaaaa,aaaaa,aaaaa
$&gt;&lt;&lt;?a*5+'bc'*4+[?a*5]*3*?,
</code></pre>

<p>Shorthand for size of input line:</p>

<pre class="lang-ruby prettyprint-override"><code>p (eval gets.chars*?+)/~/$/
# is equivalent to:
p (eval gets.chars*?+)/$_.size
</code></pre>
</div>
<div id="pu15" class="pu"><h1>Is it an array?</h1>

<p>Originally from <a href="https://codegolf.stackexchange.com/questions/139355/golf-a-number-bigger-than-tree3/145882#comment357699_145882">histocrat</a>.</p>

<p>Rather than writing</p>

<pre><code>a.class==Array  # 14 bytes
</code></pre>

<p>you could write</p>

<pre><code>a.is_a? Array   # 13 bytes
</code></pre>

<p>or even</p>

<pre><code>a!=[*a]         # 7 bytes
</code></pre>
</div>
<div id="pu16" class="pu"><h1>Save a byte when printing a word with symbols</h1>

<p>This is a bit situational, but every byte counts!</p>

<pre><code>puts"thing" # before
puts:thing  # after
          ^
</code></pre>
</div>
<div id="pu17" class="pu"><h1>Subscripting Numbers!</h1>

<p>I just discovered this yesterday. <code>n[i]</code> returns <code>n</code>'s bit at the <code>i</code>-th position.

Example:</p>

<pre><code>irb(main):001:0&gt; n = 0b11010010
=&gt; 210
irb(main):002:0&gt; n[0]
=&gt; 0
irb(main):003:0&gt; n[1]
=&gt; 1
irb(main):004:0&gt; n[2]
=&gt; 0
irb(main):005:0&gt; n[3]
=&gt; 0
irb(main):006:0&gt; n[4]
=&gt; 1
irb(main):007:0&gt; n[5]
=&gt; 0
</code></pre>
</div>
<div id="pu18" class="pu"><p><a href="https://stackoverflow.com/questions/17560382/quick-way-to-check-if-all-items-in-a-ruby-array-are-unique">Quick way to check if all items in a Ruby array are unique</a> lists various ways to check whether everything in an array is unique. Unfortunately, none of them are methods that I can send to a receiver, I need to have my array on both sides of an operator. Lame!</p>

<p>Fortunately, <code>uniq!</code> returns <code>nil</code> if no changes are made, and returns the modified array if changes are made, meaning that it can be placed at the end of a pipeline to check for uniqueness;</p>

<p><code>x.method1.method2.method3.uniq! ? "not unique" : "everything is unique!"</code></p>

<p>Various other shouty methods have similar behaviour - returning the modified array if changes are made and <code>nil</code> if no changes are made.</p>
</div>
<div id="pu19" class="pu"><h2>Default function arguments</h2>

<p>Pre-defining your variables within a function can save you from calling particular arguments if you already know what they are and are calling the function multiple times.</p>

<pre><code>def f(a,b,c)
  return a+b+c
end
puts f(f(3,3,3),f(3,3,3),f(3,3,3))
# =&gt; 27
</code></pre>

<p>One can shorten this quite easily:</p>

<pre><code>def f(a,b=3,c=3)
  return a+b+c
end
puts f(f(3),f(3),f(3))
# =&gt; 27
</code></pre>

<p>If you do not assign any second or third arguments, then <code>b=3</code> and <code>c=3</code> automatically.  One can shorten this further:</p>

<pre><code>def f(a,b=a,c=a)
  return a+b+c
end
puts f(f(3))
# =&gt; 27
</code></pre>

<p>Note however that you'll need to give it at least one variable, the first one, and I'm not quite sure how you can avoid assigning a value to <code>b</code> while assigning a value to <code>c</code>.</p>

<hr>

<p>See <a href="http://codeloveandboards.com/blog/2014/02/05/ruby-and-method-arguments/" rel="nofollow noreferrer">here</a> for more argument methods.</p>
</div>
<div id="pu20" class="pu"><h1>Re(ab)use predefined globals</h1>



<p>There is a whole bunch of predefined global variables that you can use instead of initialising new variables. </p>

<p>A very common example is that you have some golfed one-liner that loops, but you also need to keep a counter for later:</p>

<pre class="lang-rb prettyprint-override"><code>i=0
s.gsub!(/../){i+=1;"foo"}while s=~/.../
p i
</code></pre>

<p>So frustrating. Luckily, <code>$.</code> comes to the rescue! It is initially <code>0</code>, and is incremented each time you read a line from input. This is of course incredibly useful if you <a href="https://codegolf.stackexchange.com/a/88882/4372">actually need</a> to keep track of the amount of lines you have read, but otherwise you can just manually update it:</p>

<pre class="lang-rb prettyprint-override"><code>s.gsub!(/../){$.+=1;"foo"}while s=~/.../
p$.
</code></pre>

<p>That's 3 bytes saved.</p>

<p>If you for example need to append your counter to a string <code>s</code>, you may save some more bytes though string interpolation because the variable has a <a href="https://codegolf.stackexchange.com/a/52357/4372">sigil</a>:</p>

<pre class="lang-rb prettyprint-override"><code>i=0;i+=1;s+i.to_s
i=0;i+=1;s+"#{i}" 
$.+=1;s+"#$."
</code></pre>

<p>Another interesting global is <code>$:</code>. It's an alias for <code>$LOAD_PATH</code> and is an array full of strings. I haven't actually used this in a golf yet, but I imagine it could come in handy if you need a cache for checking previously visited values or something, and don't care if it's completely empty. Your values are unlikely to crash with any of its initial contents anyways.</p>
</div>
<div id="pu21" class="pu"><p>Use the short predefined variables wherever possible, e.g. <code>$*</code> instead of <code>ARGV</code>.  There's a good list of them <a href="http://www.zenspider.com/ruby/quickref.html#pseudo-variables" rel="noreferrer">here</a>, along with a lot of other useful information.</p>
</div>
<div id="pu22" class="pu"><h1>Use operator methods instead of parentheses</h1>



<p>Let's say you want to express <code>a*(b+c)</code>. Because of precedence, <code>a*b+c</code> won't work (obviously). Ruby's cool way of having operators as methods comes to the rescue! You can use <code>a.*b+c</code> to make the precedence of <code>*</code> lower than that of <code>+</code>.</p>

<pre class="lang-rb prettyprint-override"><code>a*(b+c) # too long
a*b+c   # wrong
a.*b+c  # 1 byte saved!
</code></pre>

<p>This can also work with the <code>!</code> and <code>~</code> operators (things like unary <code>+</code> or unary <code>-</code> don't work because their methods are <code>-@</code> and <code>+@</code>, saving <code>()</code> but adding <code>.@</code>)</p>

<pre class="lang-rb prettyprint-override"><code>(~x).to_s # too long
~x.to_s   # error
x.~.to_s  # 1 byte saved!
</code></pre>
</div>
<div id="pu23" class="pu"><h1><code>Array#assoc</code>/<code>rassoc</code></h1>

<p>When you have an array of arrays and want to find the sub-array that starts with a particular value, don't use <code>Enumerable#find</code>, use <a href="https://ruby-doc.org/core-2.3.1/Array.html#method-i-assoc" rel="nofollow"><code>Array#assoc</code></a>:</p>

<pre><code>a = [[0,"foo"],[0,"bar"],[1,"baz"],[0,"qux"]]
a.find{|x,|x==1} # =&gt; [1,"baz"]
a.assoc(1) # =&gt; [1,"baz"]
</code></pre>

<p>This is also a good replacement for <code>Enumerable#any?</code> in some situations.</p>

<p><a href="https://ruby-doc.org/core-2.3.1/Array.html#method-i-rassoc" rel="nofollow"><code>Array#rassoc</code></a> does the same thing, but checks the sub-arrays' last element:</p>

<pre><code>a = [[123,"good"],[456,"good"]]
a.any?{|*,x|x=="bad"} # =&gt; false
a.rassoc("bad") # =&gt; nil
</code></pre>
</div>
<div id="pu24" class="pu">

<h1>Save some bytes when removing repeated elements of an array</h1>

<pre class="lang-rb prettyprint-override"><code>a.uniq # before
a|[]   # after
    ^^
</code></pre>

<p>If you will be using an empty array <code>[]</code> in a variable, you can save even more bytes:</p>

<pre class="lang-rb prettyprint-override"><code>a.uniq;b=[] # before
a|b=[]      # after
      ^^^^^
</code></pre>
</div>
<div id="pu25" class="pu"><p>To subtract one (-1), instead of doing this</p>

<pre><code>(i - 1) * 2
</code></pre>

<p>do the following</p>

<pre><code>~-i * 2
</code></pre>

<p>which will save you 2 bytes in cases where you otherwise have to use brackets (e.g. arithmetics).</p>
</div>
<div id="pu26" class="pu"><p>To join an array, instead of this</p>

<pre><code>[...].join
</code></pre>

<p>do this</p>

<pre><code>[...]*''
</code></pre>

<p>which saves 2 bytes.
To join with a separator use</p>

<pre><code>[...]*?,
</code></pre>
</div>
<div id="pu27" class="pu"><h1>&lt;&lt; trick</h1>
<pre><code>a.push x
</code></pre>
<p>can be shortened to:</p>
<pre><code>a&lt;&lt;x
</code></pre>
<p>for -4 bytes.</p>
</div>
<div id="pu28" class="pu"><p>Don't use the <code>true</code> and <code>false</code> keywords.</p>

<p>Use:</p>

<ul>
<li><code>!p</code> for <code>true</code> (thanks, histocrat!)</li>
<li><code>!0</code> for <code>false</code>. If all you need is a falsy value, then you can simply use <code>p</code> (which returns <code>nil</code>).</li>
</ul>

<p>to save some chars.</p>
</div>
<div id="pu29" class="pu"><p>You may be able to save 2 chars and use</p>

<pre><code>[*(...)]
</code></pre>

<p>instead of </p>

<pre><code>(...).to_a
</code></pre>

<p>For example, suppose we have a range that we want as an array:</p>

<pre><code>(1..2000).to_a
</code></pre>

<p>Just do it like this:</p>

<pre><code>[*1..2000]  #  Parentheses around the (ran..ge) is not needed!
</code></pre>

<p>And now you have your range as an array.</p>
</div>
<div id="pu30" class="pu"><h1>Avoid <code>length</code> in <code>if a.length&lt;n</code></h1>
<p><code>length</code> is 6 bytes, a bit costly in code golf. in many situations, you can instead check if the array has anything at a given point. if you grab past the last index you will get <code>nil</code>, a falsey value.</p>
<p>So you can Change:</p>
<p><code>if a.length&lt;5</code> to <code>if !a[4]</code> for -5 bytes</p>
<p>or</p>
<p><code>if a.length&gt;5</code> to <code>if a[5]</code> for -6 bytes</p>
<p>or</p>
<p><code>if a.length&lt;n</code> to <code>if !a[n-1]</code> for -3 bytes</p>
<p>or</p>
<p><code>if a.length&gt;n</code> to <code>if a[n]</code> for -6 bytes</p>
<p><strong>Note</strong>: will only work with an array of all truthy values. having <code>nil</code> or <code>false</code> within the array may cause problems.</p>
</div>
<div id="pu31" class="pu"><p>When getting <strong>input of fixed length</strong> the optional integer parameter to <code>gets</code> may come in handy.</p>

<ul>
<li><p>Getting a substring:</p>

<p><code>gets 10</code> vs <code>gets[0,10]</code> -- saves 3 bytes</p></li>
<li><p>Cutting trailing newline:</p>

<p><code>gets 10</code> vs <code>gets.chop</code> -- saves <em>3 - log<sub>10</sub>(required_length)</em>  bytes (= 2 in this case)</p></li>
</ul>
</div>
<div id="pu32" class="pu"><p>If you ever need to get a number from <code>ARGV</code>, <code>get</code>, or something similar to do something that many times, instead of calling <code>to_i</code> on it, you can just use <code>?1.upto x{do something x times}</code> where x is a string.</p>

<p>So using <code>?1.upto(a){}</code> instead of <code>x.to_i.times{}</code> will save you 2 characters. </p>

<p>You can also re-write things like <code>p 1 while 1</code> or <code>p 1 if 1</code> as <code>p 1while 1</code> or <code>p 1if 1</code></p>

<p>That example isn't very useful, but it could be used for other things.</p>

<p>Also, if you need to assign the first element of an array to a variable, <code>a,=c</code> will save two characters as opposed to <code>a=c[0]</code> </p>
</div>
<div id="pu33" class="pu"><p>When a challenge requires that you output multiple lines, you don't have to <a href="https://codegolf.stackexchange.com/a/49792/4372">loop</a> through your results in order to print each line of e.g. an array. The <code>puts</code> method will flatten an array and print each element on a separate line.</p>

<pre><code>&gt; a = %w(testing one two three)
&gt; puts a
testing
one
two
three
</code></pre>

<p>Combining the splat operator with <a href="https://codegolf.stackexchange.com/a/9268/4372"><code>#p</code></a> you can make it even shorter:</p>

<pre><code>p *a
</code></pre>

<p>The splat operator (technically the <code>*@</code> method, I think) also casts your non-array enumerables to arrays:</p>

<pre><code>&gt; p a.lazy.map{|x|x*2}
#&lt;Enumerator::Lazy: #&lt;Enumerator::Lazy: [1, 2, 3]&gt;:map&gt;
</code></pre>

<p>vs</p>

<pre><code>&gt; p *a.lazy.map{|x|x*2}
2
4
6
</code></pre>
</div>
<div id="pu34" class="pu"><p>When you are using string interpolation, (as you should pr <a href="https://codegolf.stackexchange.com/a/37519/4372">Martin BÃ¼ttner's post</a>), you don't need the curly brackets if your object has a sigil (<code>$</code>, <code>@</code>) in front of it. Useful for magical variables like <code>$_</code>, <code>$&amp;</code>, <code>$1</code> etc:</p>

<pre><code>puts "this program has read #$. lines of input"
</code></pre>

<p>So also if you need to print a variable more than you use it otherwise, you may save some bytes.</p>

<pre><code>a=42; puts "here is a: #{a}"; puts "here is a again: #{a}"
$b=43; puts "here is b: #$b"; puts "here is b again: #$b"
</code></pre>
</div>
<div id="pu35" class="pu"><p>Yet another way to use the splat operator: if you want to assign a single array literal, a <code>*</code> on the left-hand side is shorter than brackets on the right-hand side:</p>

<pre><code>a=[0]
*a=0
</code></pre>

<p>With multiple values you don't even need the splat operator (thanks to histocrat for correcting me on that):</p>

<pre><code>a=[1,2]
a=1,2
</code></pre>
</div>
<div id="pu36" class="pu"><p>To check if <code>a</code> is an <code>Array</code>, instead of doing:</p>

<pre><code>a.kind_of?(Array)
</code></pre>

<p>you can do</p>

<pre><code>a.to_s['[']
</code></pre>

<p>Won't work if <code>a</code> can be a string that contains <code>[</code>.</p>
</div>
<div id="pu37" class="pu"><p>Don't use #each. You can loop over all elements just fine with #map. So instead of</p>



<pre class="lang-ruby prettyprint-override"><code>ARGV.each{|x|puts x}
</code></pre>

<p>you can do the same in less bytes.</p>

<pre class="lang-ruby prettyprint-override"><code>ARGV.map{|x|puts x}
</code></pre>

<p>Of course, in this case <code>puts $*</code> would be even shorter.</p>

<hr>

<p>There are literals for rational and complex numbers:</p>

<pre class="lang-ruby prettyprint-override"><code>puts 3/11r == Rational(3,11)
puts 3.3r == Rational(66,20)
puts 1-1.i == Complex(1,-1)

=&gt; true
true
true
</code></pre>

<hr>

<p>You can use most bytes within strings. <code>"\x01"</code> (6 bytes) can be shortened to <code>""</code> (3 bytes). If you only need this one byte, this can be shortened even further to <code>?</code> (2 bytes).</p>

<p>By the same token, you can get newlines shorter like this:</p>

<pre class="lang-ruby prettyprint-override"><code>(0..10).to_a.join'
'

 =&gt; "0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10"
</code></pre>

<p>You can use <code>?\n</code> and <code>?\t</code> as well, which is one byte shorter than <code>"\n"</code> and <code>"\t"</code>. For obfuscation, there also ?\s, a space.</p>

<hr>

<p>Use constants instead of passing arguments around, even if you need to change them. The interpreter will give warnings to <em>stderr</em>, but who cares. If you need to define more variables related to each other, you can chain them like this:</p>

<pre class="lang-ruby prettyprint-override"><code>A=C+B=7+C=9

=&gt; A=17, B=16, C=9
</code></pre>

<p>This is shorter than <code>C=9;B=16;A=17</code> or <code>C=0;B=C+7;A=C+B</code>.</p>

<hr>

<p>If you need an infinite loop, use <code>loop{...}</code>. Loops of unknown length may be shorter with other loops:</p>

<pre class="lang-ruby prettyprint-override"><code>loop{break if'
'==f(gets)}

while'
'!=f(gets);end
</code></pre>

<hr>

<p>Some more gsub/regexp tricks. Use the special <code>'\1'</code> escape characters instead of a block:</p>

<pre class="lang-ruby prettyprint-override"><code>"golf=great short=awesome".gsub(/(\w+)=(\w+)/,'(\1~&gt;\2)')

"golf=great short=awesome".gsub(/(\w+)=(\w+)/){"(#{$1}~&gt;#{$2})")
</code></pre>

<p>And the special variables <code>$1</code> etc. if you need to perform operations. Keep in mind they are defined not only inside the block:</p>

<pre class="lang-ruby prettyprint-override"><code>"A code-golf challenge." =~ /(\w+)-(\w+)/
p [$1,$2,$`,$']

=&gt; ["code", "golf", "A ", " challenge."] 
</code></pre>

<hr>

<p>Get rid of spaces, newlines, and parentheses. You can omit quite a bit in ruby. If in doubt, always try if it works without, and keep in mind this might break some editor syntax highlighting...</p>

<pre class="lang-ruby prettyprint-override"><code>x+=1if$*&lt;&lt;A==????::??==??
</code></pre>
</div>
<div id="pu38" class="pu"><p>Addition to w0lf</p>

<blockquote>
  <p>When working with arrays, <code>.compact</code> can be replaced with <code>-[nil]</code> to save 2 chars.</p>
</blockquote>

<p>Combined with above -> you can make it even shorter with <code>-[p]</code> to save another 2 chars.</p>
</div>
<div id="pu39" class="pu"><p>When working with arrays, <a href="http://www.ruby-doc.org/core-2.1.4/Array.html#method-i-compact" rel="nofollow"><code>.compact</code></a> can be replaced with <code>-[nil]</code> to save 2 chars.</p>
</div>
<div id="pu40" class="pu"><p>Use string interpolation!</p>

<ol>
<li><p>To replace <code>to_s</code>. If you need parentheses around whatever you want to turn into a string, <code>to_s</code> is two bytes longer than string interpolation:</p>

<pre><code>(n+10**i).to_s
"#{n+10**i}"
</code></pre></li>
<li><p>To replace concatenation. If you concatenate something surrounded by two other strings, interpolation can save you one byte:</p>

<pre><code>"foo"+c+"bar"
"foo#{c}bar"
</code></pre>

<p>Also works if the middle thing is itself concatenated, if you just move the concatenation inside the interpolation (instead of using multiple interpolations):</p>

<pre><code>"foo"+c+d+e+"bar"
"foo#{c+d+e}bar"
</code></pre></li>
</ol>
</div>
<div id="pu41" class="pu"><p><a href="http://ruby-doc.org/core-2.1.2/Kernel.html#method-i-p" rel="noreferrer">Kernel#p</a> is a fun method.</p>

<p>Use <code>p var</code> instead of <code>puts var</code>. This works perfectly with integers and floats, but not with all types. It prints quotation marks around strings, which is probably not what you want.</p>

<p>Used with a single argument, <code>p</code> returns the argument after printing it.</p>

<p>Used with multiple arguments, <code>p</code> returns the arguments in an array.</p>

<p>Use <code>p</code> (with no arguments) instead of <code>nil</code>.</p>
</div>
<div id="pu42" class="pu"><p><code>$_</code> is last read line.</p>

<ul>
<li><code>print</code> - if no argument given print content of <code>$_</code></li>
<li><code>~/regexp/</code> - short for <code>$_=~/regexp/</code></li>
</ul>

<p>In Ruby 1.8, you have four methods in <code>Kernel</code> that operate on <code>$_</code>:</p>

<ul>
<li><code>chop</code></li>
<li><code>chomp</code></li>
<li><code>sub</code></li>
<li><code>gsub</code></li>
</ul>

<p>In Ruby 1.9, these four methods exist only if your script uses <code>-n</code> or <code>-p</code>.</p>

<p>If you want to print some variable often then use <code>trace_var(:var_name){|a|p a}</code></p>
</div>
<div id="pu43" class="pu"><h1>End your <code>end</code>.</h1>

<p>Try to remove <code>end</code> from your code.</p>

<p>Don't use <code>def...end</code> to define functions. Make a lambda with the new -> operator in Ruby 1.9. (The -> operator is a <a href="https://stackoverflow.com/q/8476627/3614563">"stabby lambda", or "dash rocket"</a>.) This saves 5 characters per function.</p>

<pre><code># 28 characters
def c n
/(\d)\1/=~n.to_s
end

# 23 characters, saves 5
c=-&gt;n{/(\d)\1/=~n.to_s}
</code></pre>

<p>Method calls are <code>c n</code> or <code>c(n)</code>. Lambda calls are <code>c[n]</code>. Changing each <code>c n</code> to <code>c[n]</code> costs 1 character, so if you can use <code>c n</code> more than 5 times, then keep the method.</p>

<p>All methods that take <code>do...end</code> blocks can take <code>{...}</code> blocks instead. This saves 3 to 5 characters. If the precedence of <code>{...}</code> is too high, then use parentheses to fix it.</p>

<pre><code># 48 characters
(?a..?m).zip (1..5).cycle do|a|puts a.join','end

# WRONG: passes block to cycle, not zip
(?a..?m).zip (1..5).cycle{|a|puts a.join','}

# 45 characters, saves 3
(?a..?m).zip((1..5).cycle){|a|puts a.join','}
</code></pre>

<p>Replace <code>if...else...end</code> with the <a href="https://codegolf.stackexchange.com/a/5315/4065">ternary operator</a> <code>?:</code>. If a branch has two or more statements, wrap them in parentheses.</p>

<pre><code># 67 characters
if a&lt;b
puts'statement 1'
puts'statement 2'else
puts'statement 3'end

# 62 characters, saves 5
a&lt;b ?(puts'statement 1'
puts'statement 2'):(puts'statement 3')
</code></pre>

<p>You probably don't have <code>while</code> or <code>until</code> loops, but if you do, then write them in modifier form.</p>

<pre><code>(a+=1
b-=1)while a&lt;b
</code></pre>
</div>
<div id="pu44" class="pu"><ul>
<li>The numbers 100 to 126 can be written as <code>?d</code> to <code>?~</code> in 1.8.</li>
<li>On a similar note if you need a single-character string in 1.9 ?x is shorter than "x".</li>
<li>If you need to print a string without appending a newline, <code>$&gt;&lt;&lt;"string"</code> is shorter than <code>print"string"</code>.</li>
<li>If you need to read multiple lines of input <code>$&lt;.map{|l|...}</code> is shorter than <code>while l=gets;...;end</code>. Also you can use <code>$&lt;.read</code> to read it all at once.</li>
<li>If you're supposed to read from a file, <code>$&lt;</code> and <code>gets</code> will read from a file instead of stdin if the filename is in <code>ARGV</code>. So the golfiest way to reimplement <code>cat</code> would be: <code>$&gt;&lt;&lt;$&lt;.read</code>.</li>
</ul>
</div>
<div id="pu45" class="pu"><p>If the first line starts with <code>#!</code> and contains <code>ruby</code>, then Ruby will take command-line switches from it.</p>

<p>For example, if you require two libraries, you can golf</p>

<pre><code>require'benchmark'
require'prime'
</code></pre>

<p>into</p>

<pre><code>#!ruby -rbenchmark -rprime
</code></pre>

<p>which saves 7 bytes.</p>
</div>
<div id="pu46" class="pu"><p>I just attempted a TDD code-golf challenge i.e. Write shortest code to make specs pass. The specs were something like</p>

<pre><code>describe PigLatin do
  describe '.translate' do
    it 'translates "cat" to "atcay"' do
      expect(PigLatin.translate('cat')).to eq('atcay')
    end
    # And similar examples for .translate
  end
end
</code></pre>

<p>For the sake of code-golf, one need not create a module or class.</p>

<p>Instead of</p>

<pre><code>module PigLatin def self.translate s;'some code'end;end
</code></pre>

<p>one can do</p>

<pre><code>def(PigLatin=p).translate s;'some code'end
</code></pre>

<p>Saves 13 characters!</p>
</div>
<div id="pu47" class="pu"><p>Build arrays using <code>a=i,*a</code> to get them in reverse order. You don't even need to initialize <code>a</code>, and if you do <a href="http://golf.shinh.org/reveal.rb?count+up+digits/Histocrat_1390488293&amp;rb">it doesn't have to be an array</a>.</p>
</div>
<div id="pu48" class="pu"><p>Use Goruby instead of Ruby, which is something like an abbreviated version of Ruby. You can install it with rvm via</p>

<pre><code>rvm install goruby
</code></pre>

<p>Goruby allows you to write most of your code as you would be writing Ruby, but has additional abbreviations built in. To find out the shortest available abbreviation for something, you can use the helper method <code>shortest_abbreviation</code>, for example:</p>

<pre><code>shortest_abbreviation :puts
#=&gt; "pts"

Array.new.shortest_abbreviation :map
#=&gt; "m"

String.new.shortest_abbreviation :capitalize
#=&gt; "cp"

Array.new.shortest_abbreviation :join
#=&gt; "j"
</code></pre>

<p>Also very handy is the alias <code>say</code> for <code>puts</code> which itself can be abbreviated with <code>s</code>. So instead of</p>

<pre><code>puts [*?a..?z].map(&amp;:capitalize).join
</code></pre>

<p>you can now write</p>

<pre><code>s [*?a..?z].m(&amp;:cp).j
</code></pre>

<p>to print the alphabet in capitals (which is not avery good example). <a href="http://rbjl.net/34-do-you-know-the-official-ruby-interpreter-goruby" rel="noreferrer">This blog post</a> explains more stuff and some of the inner workings if you are interested in further reading.</p>

<p>PS: don't miss out on the <code>h</code> method ;-)</p>
</div>
<div id="pu49" class="pu"><p>Use <code>||</code> instead <code>or</code> and <code>&amp;&amp;</code> instead <code>and</code>.</p>

<p>Beside the one character from <code>and</code> you can save the spaces 
(and perhaps the bracket) around the operator.</p>

<pre><code>p true and false ? 'yes' :'no'   #-&gt; true (wrong result)
p (true and false) ? 'yes' :'no' #-&gt; 'no'
p true&amp;&amp;false ? 'yes' :'no'      #-&gt; 'no', saved 5 characters


p true or false ? 'yes' :'no'   #-&gt; true (wrong result)
p (true or false) ? 'yes' :'no' #-&gt; 'yes'
p true||false ? 'yes' :'no'      #-&gt; 'yes', saved 4 characters
</code></pre>

<hr>

<p>If you loop on an array you normally use <code>each</code>. But <code>map</code> loops also over an array and it is one character shorter.</p>
</div>
<div id="pu50" class="pu"><p>If you need to find if a particular element <code>e</code> is inside a range <code>r</code>, you can use</p>

<pre><code>r===e
</code></pre>

<p>instead of the longer:</p>

<pre><code>r.cover?(e) # only works if `r.exclude_end?` is false
</code></pre>

<p>or</p>

<pre><code>r.member?(e)
</code></pre>

<p>or</p>

<pre><code>r.include?(e)
</code></pre>
</div>
<div id="pu51" class="pu"><ul>
<li>Use <code>abort</code> to terminate the program and print a string to STDERR - shorter than <code>puts</code> followed by <code>exit</code></li>
<li>If you read a line with <code>gets</code>, you can then use <code>~/$/</code> to find its length (this doesn't count a trailing newline if it exists)</li>
<li>Use <code>[]</code> to check if a string contains another: <code>'foo'['f'] #=&gt; 'f'</code></li>
<li>Use <code>tr</code> instead of <code>gsub</code> for character-wise substitutions: <code>'01011'.tr('01','AB') #=&gt; 'ABABB'</code></li>
<li>If you need to remove trailing newlines, use <code>chop</code> instead of <code>chomp</code></li>
</ul>
</div>
<div id="pu52" class="pu"><p>Scientific notation can often be used to shave off a char or two:</p>

<pre><code>x=1000
#versus
x=1e3
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/363/">363</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




