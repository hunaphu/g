<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::51337</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>010</td><td>Vyxal 3</td><td>250622T210519Z</td><td><a href="https://codegolf.stackexchange.com/questions/51337/count-the-crossing-words/282364#282364">pacman25</a></td></tr>
<tr d-ix="1"><td>038</td><td>J</td><td>210213T194931Z</td><td><a href="https://codegolf.stackexchange.com/questions/51337/count-the-crossing-words/218993#218993">Jonah</a></td></tr>
<tr d-ix="2"><td>nan</td><td></td><td>150605T161842Z</td><td><a href="https://codegolf.stackexchange.com/questions/51337/count-the-crossing-words/51349#51349">edc65</a></td></tr>
<tr d-ix="3"><td>011</td><td>CJam</td><td>150605T141306Z</td><td><a href="https://codegolf.stackexchange.com/questions/51337/count-the-crossing-words/51338#51338">Martin E</a></td></tr>
<tr d-ix="4"><td>013</td><td>Pyth</td><td>150605T153703Z</td><td><a href="https://codegolf.stackexchange.com/questions/51337/count-the-crossing-words/51347#51347">Jakube</a></td></tr>
<tr d-ix="5"><td>nan</td><td>Slip</td><td>150605T144322Z</td><td><a href="https://codegolf.stackexchange.com/questions/51337/count-the-crossing-words/51343#51343">Sp3000</a></td></tr>
<tr d-ix="6"><td>081</td><td>Haskell</td><td>150605T150135Z</td><td><a href="https://codegolf.stackexchange.com/questions/51337/count-the-crossing-words/51344#51344">nimi</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal/tree/version-3/" rel="nofollow noreferrer">Vyxal 3</a>, 10 bytes</h1>
<pre><code>TJ¨※“⎘⌊\“L
</code></pre>
<p><a href="https://vyxal.github.io/latest.html#H4sIAAAAAAAACqtWSssvyk0sUbIy1lHKSE1MSS1SslJS0lFKzk9JBbJCvA6teNSw-1HDnEd9Mx71dMXEAJk-QPm0_PwSmNq0nMT0YiWr6Fgdpcy8gtISEDtayb0ov7RAwVBJJ1opOjpGyTBGSUcBnTLAJohVCT6VRJiCQcXqKFDuKAqVUNlRRFBUdhR1rDLARhFQSdhR5AYYBQENcRSFCZY6EU1x9FEnFHFpJ9VRxCUK2oUUhYaT60SiEjpVg4-U3EeXSCHebaTmPhpVLNjSFDkRT71kR-UigaRIoWbuG7ASncKQIjkvEpX7aGE_BfpokPsodzfNmy50zH20bZXSwFHExzBOR8UCkQ6sJ2EE60ngyAlYqgCwAcBeSVlqUXFmfh6wt2KsZ65noFQLAO9SHhT3DAAA" rel="nofollow noreferrer">Vyxal It Online!</a></p>
<p>flagless ten, takes input with 0 for black space and 1 for white space</p>
<pre><code>TJ¨※“⎘⌊\“L­⁡​‎‎⁪⁡⁪⁠⁪⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁪‏‏​⁡⁠⁡‌⁢​‎‎⁪⁡⁪⁠⁪⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁪‏⁠⁪⁪‏​⁡⁠⁡‌⁣​‎‎⁪⁡⁪⁠⁪⁢⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁪‏‏​⁡⁠⁡‌⁤​‎⁪⁪⁠‎⁪⁡⁪⁠⁪⁢⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁡⁪‏‏​⁡⁠⁡‌⁢⁡​‎‎⁪⁡⁪⁠⁪⁣⁢⁪‏‏​⁡⁠⁡‌­
TJ          # ‎⁡Join with transpose
  ¨※        # ‎⁢group each row/column by consecutive equal values
    “⎘⌊     # ‎⁣join on nothing and convert to number, giving a unary length for each word in the puzzle and 0 to represent some amount black spaces
       \“   # ‎⁤reject by absolute value less than or equal to 1
         L  # ‎⁢⁡length of remaining list
💎
</code></pre>
<p>Created with the help of <a href="https://vyxal.github.io/Luminespire" rel="nofollow noreferrer">Luminespire</a>.</p>
</div>
<div id="pu1" class="pu"><h1><a href="http://jsoftware.com/" rel="nofollow noreferrer">J</a>, 38 bytes</h1>
<pre><code>1#.1&lt;[:#;._1 1:,@,.[:(,!.1|:)'#'&amp;=;._2
</code></pre>
<p><a href="https://tio.run/##dVJBasMwELzvK6YZqGNwhVUCKUoMgUJPPfUaSg@loeTSD/Tvruxk7V05FbbkGe2uZkc@96tQndAlVGjQIuX3IeD57fWljwxxf0zchY@ImJpDE45p3dyF@JvqitV9l3ce@1q@Pr9/sEWHE96HGq0gD7q5lkvYxoZxHEINvCLmZ1o4Lpq@fSqPAafpNobDVDDgofa4O7IUMcgmaAXRj2ueCA0axJtgl6AneoFLrH3GTVs0Si/NqiNusSjZGVMbRtGg2lIY5cyc4jmzxoWFBuUpTtWkoci90GqsVyH0JY3JKO0RG8dFF6bD@dq8F1bDf06WGvx9uN9hZvMl938" rel="nofollow noreferrer" title="J – Try It Online">Try it online!</a></p>
</div>
<div id="pu2" class="pu"><h1>JavaScript (<em>ES6</em>) 87 <s>121 147</s></h1>

<p>Build the transposition of input string and append it to input, then count the strings of 2 or more spaces. </p>

<p>Run the snippet in Firefox to test.</p>

<p>Credits @IsmaelMiguel, a solution for ES5 (122 bytes):</p>

<pre class="lang-js prettyprint-override"><code>function F(z){for(r=z.split(/\n/),i=0;i&lt;r[j=0][L='length'];i++)for(z+='#';j&lt;r[L];)z+=r[j++][i];return~-z.split(/  +/)[L]};
</code></pre>

<p><div class="snippet" data-lang="js" data-hide="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>F=z=&gt;
(
  r=z.split(/\n/),
  [r.map(r=&gt;z+=r[i],z+='#')for(i in r[0])],
  ~-z.split(/  +/).length
)

// TEST
out=x=&gt;O.innerHTML += x + '\n';

[
'     #    #    \n     #    #    \n          #    \n   #   #       \n###     ##   ##\n               \n     ##   #    \n   #       #   \n    #   ##     \n               \n##   ##     ###\n       #   #   \n    #          \n    #    #     \n    #    #     ', '##\n #\n##', '    #\n    #\n    #',
 '######\n#    #\n  ####\n# ## #\n# ## #\n#### #',
 '   #    ##   #       \n   #    #    #       \n   #         #       \n       #     ###   ##\n    #       #        \n##   #   #           \n        #       ##   \n      #   ##         \n   #        ##      #\n         #   ###   ##\n#   ##         ##   #\n##   ###   #         \n#      ##        #   \n         ##   #      \n   ##       #        \n           #   #   ##\n        #       #    \n##   ###     #       \n       #         #   \n       #    #    #   \n       #   ##    #   '  
].forEach(x=&gt;out(x.replace(/ /g,'.')+'\n'+F(x)+'\n'))</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;pre id=O&gt;&lt;/pre&gt;</code></pre>
</div>
</div>
</p>
</div>
<div id="pu3" class="pu"><h1>CJam, <s>18</s> <s>17</s> <s>13</s> 11 bytes</h1>

<p><em>2 bytes saved by Dennis.</em></p>

<p>Uses spaces for filled cells and <code>1</code> for empty cells:</p>

<pre><code>qN/_z+:~1-,
</code></pre>

<p><a href="http://cjam.aditsu.net/#code=qN%2F_z%2B%3A~1-%2C&amp;input=11111%201111%201111%0A11111%201111%201111%0A1111111111%201111%0A111%20111%201111111%0A%20%20%2011111%20%20111%20%20%0A111111111111111%0A11111%20%20111%201111%0A111%201111111%20111%0A1111%20111%20%2011111%0A111111111111111%0A%20%20111%20%2011111%20%20%20%0A1111111%20111%20111%0A1111%201111111111%0A1111%201111%2011111%0A1111%201111%2011111" rel="noreferrer">Test it here.</a></p>

<h2>Explanation</h2>

<pre><code>q    e# Read the entire input.
N/   e# Split into lines.
_z   e# Make a copy and transpose it.
+    e# Add the lines of the two grids together.
:~   e# Evaluate each line which will push a rep-digit number for each empty-cell chunk.
1-   e# Remove all the 1s as these correspond to individual empty cells.
,    e# Get the length of the array.
</code></pre>
</div>
<div id="pu4" class="pu"><h1>Pyth, <s>15</s> <s>14</s> 13 bytes</h1>

<pre><code>lftTcjd+.zC.z
</code></pre>

<p>I'm using <code></code> as seperator and <code>#</code> as fill characters instead of their opposite meaning from the OP. Try it online: <a href="https://pyth.herokuapp.com/?code=lftTcjd%2B.zC.z&amp;input=%23%23%23+%23%23%23%23++%23%23%23+%23%23%23%23%23%23%23%0A%23%23%23+%23%23%23%23+%23%23%23%23+%23%23%23%23%23%23%23%0A%23%23%23+%23%23%23%23%23%23%23%23%23+%23%23%23%23%23%23%23%0A%23%23%23%23%23%23%23+%23%23%23%23%23+++%23%23%23++%0A%23%23%23%23+%23%23%23%23%23%23%23+%23%23%23%23%23%23%23%23%0A++%23%23%23+%23%23%23+%23%23%23%23%23%23%23%23%23%23%23%0A%23%23%23%23%23%23%23%23+%23%23%23%23%23%23%23++%23%23%23%0A%23%23%23%23%23%23+%23%23%23++%23%23%23%23%23%23%23%23%23%0A%23%23%23+%23%23%23%23%23%23%23%23++%23%23%23%23%23%23+%0A%23%23%23%23%23%23%23%23%23+%23%23%23+++%23%23%23++%0A+%23%23%23++%23%23%23%23%23%23%23%23%23++%23%23%23+%0A++%23%23%23+++%23%23%23+%23%23%23%23%23%23%23%23%23%0A+%23%23%23%23%23%23++%23%23%23%23%23%23%23%23+%23%23%23%0A%23%23%23%23%23%23%23%23%23++%23%23%23+%23%23%23%23%23%23%0A%23%23%23++%23%23%23%23%23%23%23+%23%23%23%23%23%23%23%23%0A%23%23%23%23%23%23%23%23%23%23%23+%23%23%23+%23%23%23++%0A%23%23%23%23%23%23%23%23+%23%23%23%23%23%23%23+%23%23%23%23%0A++%23%23%23+++%23%23%23%23%23+%23%23%23%23%23%23%23%0A%23%23%23%23%23%23%23+%23%23%23%23%23%23%23%23%23+%23%23%23%0A%23%23%23%23%23%23%23+%23%23%23%23+%23%23%23%23+%23%23%23%0A%23%23%23%23%23%23%23+%23%23%23++%23%23%23%23+%23%23%23&amp;debug=0" rel="nofollow">Demonstration</a></p>

<p>Instead of <code>#</code> as fill character this accepts also letters. So you could actually take the solved crossword puzzle, and it would print the number of words. And if you remove the <code>l</code> command, it even prints all words. Test it here: <a href="https://pyth.herokuapp.com/?code=lftTcjd%2B.zC.z%0A%3BftTcjd%2B.zC.z%0A&amp;input=TKT+OVUM++VAG+ROPEWAY%0AUNH+NANO+DENY+ATEDIRT%0ALEE+CUCAMONGA+GOGGLED%0AILLTELL+OFTEN+++LIL++%0APLOY+TEARFUL+GREENING%0A++CPA+ANT+ROLLINGGAIT%0AGRUELING+MASTIFF++MNO%0ARESOLD+EVE++SALIENCES%0AACT+ALBRIGHT++ENDEAR+%0ABUTCHERED+YAO+++OAR++%0A+RRR++BROKENRIB++TLC+%0A++EOS+++WIN+BRANGHOFF%0A+BECOME++NATIONAL+SLR%0APRISCILLA++CTN+NORWAY%0AION++DIAGRAM+EGGWHITE%0ALIFEISSWEET+PRO+NEL++%0AELLIOTTS+MAYISEE+ILLS%0A++ODD+++DONUT+SPANIEL%0AREWEAVE+EVERAGAIN+AAA%0AEXERTED+RENT+SPCA+MSN%0ACORSETS+ADD++TEST+SET&amp;debug=0" rel="nofollow">May 10's Sunday NY Times puzzle</a></p>

<h3>Explanation</h3>

<pre><code>        .z      all input rows
          C.z   all input columns (C transposes)
       +        add them (all rows and columns)
     jd         join by spaces
    c           split by spaces
 f              filter for pieces T, which satisfy:
  tT              len(T) &gt; 1
l               length, implicitly printed
</code></pre>
</div>
<div id="pu5" class="pu"><h1><a href="https://codegolf.stackexchange.com/questions/47311/language-design-2-d-pattern-matching">Slip</a>, 18 + 3 = 21 bytes</h1>

<pre><code>&gt;? ( +(X|$^)&lt;&lt;){2}
</code></pre>

<p>Run with the flags <code>no</code> (hence the +3), and uses space/<code>X</code> instead of space/<code>#</code>. Annoyingly this is longer than CJam/Pyth, but I guess Slip wasn't designed to be particular golfy...</p>

<p><a href="https://slip-online.herokuapp.com/?code=%3E%3F%28%20%20%2B%28X%7C%24%5E%29%3C%3C%29%7B2%7D&amp;input=%20%20%20%20%20X%20%20%20%20X%20%20%20%20%0A%20%20%20%20%20X%20%20%20%20X%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20X%20%20%20%20%0A%20%20%20X%20%20%20X%20%20%20%20%20%20%20%0AXXX%20%20%20%20%20XX%20%20%20XX%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20XX%20%20%20X%20%20%20%20%0A%20%20%20X%20%20%20%20%20%20%20X%20%20%20%0A%20%20%20%20X%20%20%20XX%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0AXX%20%20%20XX%20%20%20%20%20XXX%0A%20%20%20%20%20%20%20X%20%20%20X%20%20%20%0A%20%20%20%20X%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20X%20%20%20%20X%20%20%20%20%20%0A%20%20%20%20X%20%20%20%20X%20%20%20%20%20&amp;config=no" rel="nofollow">Try it online</a>. Note that the first example is missing spaces on a few lines.</p>

<h2>Explanation</h2>

<pre><code>&gt;?           Optionally turn right, hence matching either horizontally or vertically
[space]      Match a space
(    ){2}    Group, twice:
[space]+       Match 1+ spaces
(X|$^)         Either an X or the boundary of the grid
&lt;&lt;             Reverse the match pointer by turning left twice
</code></pre>

<p>The <code>n</code> flag makes output print the number of matches, and the <code>o</code> flag enables overlapping matches starting from the same square. The reason for the back-and-forth is because Slip tries matches starting from every square, and we want to make sure we only match a full row rather than a partial one. Slip only returns unique matches, even if they started from different positions.</p>

<p>Note: Originally I had <code>&gt;?(  +(X|$^)&lt;&lt;){2}</code>, with the first space on the inside. This would miss some cases with 2 space long words at the edge, since the pointer would go like this:</p>

<pre><code>XXX       XXX       XXX       XXX
X&gt;        X &gt;       X&lt;        &lt;
XXX       XXX       XXX       XXX

[sp]    [sp]+$^    &lt;&lt;[sp]    [sp]+   (uh oh match fails)
</code></pre>
</div>
<div id="pu6" class="pu"><h1>Haskell, 81 bytes</h1>

<pre><code>import Data.List
m x=sum[1|(_:_:_)&lt;-words x]
f x=m x+m(unlines$transpose$lines x)
</code></pre>

<p>Uses spaces <code></code> as block characters and any other (non whitespace) character as an empty cell.</p>

<p>How it works: split input into list of words at spaces. Take a <code>1</code> for every word with at lease 2 characters and sum those <code>1</code>s. Apply the same procedure to the transposition (split at <code>\n</code>) of the input. Add both results.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/51337/">51337</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




