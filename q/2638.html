<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::2638</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>523</td><td>Python3</td><td>250822T185615Z</td><td><a href="https://codegolf.stackexchange.com/questions/2638/fill-in-the-lakes-2d/283284#283284">Ajax1234</a></td></tr>
<tr d-ix="1"><td>246</td><td>Python</td><td>120401T215515Z</td><td><a href="https://codegolf.stackexchange.com/questions/2638/fill-in-the-lakes-2d/5380#5380">hallvabo</a></td></tr>
<tr d-ix="2"><td>471</td><td>Python</td><td>110526T200427Z</td><td><a href="https://codegolf.stackexchange.com/questions/2638/fill-in-the-lakes-2d/2676#2676">ESultani</a></td></tr>
<tr d-ix="3"><td>258</td><td>Haskell</td><td>110526T054457Z</td><td><a href="https://codegolf.stackexchange.com/questions/2638/fill-in-the-lakes-2d/2675#2675">MtnViewM</a></td></tr>
<tr d-ix="4"><td>491</td><td>Python</td><td>110523T194910Z</td><td><a href="https://codegolf.stackexchange.com/questions/2638/fill-in-the-lakes-2d/2650#2650">System D</a></td></tr>
<tr d-ix="5"><td>833</td><td>Common Lisp</td><td>110525T181937Z</td><td><a href="https://codegolf.stackexchange.com/questions/2638/fill-in-the-lakes-2d/2668#2668">Dr. Pain</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Python3, 523 bytes</h1>
<pre class="lang-py prettyprint-override"><code>E=enumerate
M=[(1,0),(-1,0),(0,-1),(0,1),(1,1),(-1,1),(-1,-1),(1,-1)]
def f(L):
 d,t={(x,y):v for x,r in E(L)for y,v in E(r)},[]
 for i in d.values():
  q={j for j in d if d[j]==i and j not in t}
  while q:
   v=[*q][0];Q,s={v},{v}
   while Q:e=[*Q][0];Q-={e};x,y=e;l={V for X,Y in M if(V:=(x+X,y+Y))in d and d[V]&lt;=d[v]and V not in s};Q={*Q,*l};s={*s,*l}
   q-=s;t+=[*s]*all(d.get((x+X,y+Y),-1)&gt;d[(x,y)]or(x+X,y+Y)in[*t,*s]for x,y in s for X,Y in M)
 for x,y in t:L[x][y]='*'
 return'\n'.join(''.join(map(str,i))for i in L)
</code></pre>
<p><a href="https://tio.run/##jVNNj9owED3Xv8LiEjs4COJ8Qere9sZW4oJ25UYVVZxuUDaBxFAQ4rezHoeFbdXDjpR59rw3Hxo5m6N@aWqebNrL5UGoeveq2pVW6FFIMmFjyojXw5h5EwvgJ9Z7N/D6oIEM5arABZnTGcI50@JEDuxIZ3tcNC0@sBaXNX4wNFyPbN9fW3pmMkNWU0IoH@1X1U51BMrgrTitLbe2HC4LnMt1JkSJV3VuonWjgdFnI/7zUlYKbyEP74V0t5kcZ@mCdeK0PzPzAdGLFjNlBIte4ImTOqdmWKHSSpyWtuETe4bCj6YlWc4EOQyf2HH4TKmdA5rncpl9FbncZ3Bbvo/SndOFOLkL5lbn1LR2OzhB660nulQPTeMuc1dVRfLRb6XJrTRs8Vsu7dqypr3Fy1q6mpmkfpFH2@WvISnCHzg9m8tDJo@ZcFwH4VbpXVs7P2pntG7KmjhXfF1tSKdbVlJ62/6cXroJFngwGKDkZiiMooCPeTBNUBQkIff9ZArROOQxj6IIxUkcGjOAILXz7zVQwhPEDVqCX4kYDMVhFIKPwccRROIgvtYIrtJwCoam3BhAFFkIQwv@ZGygl9i08J/xURIEiRnYHkLf5/xD5F0DCfB8dfPzV7Nqc9KZ5/el3xyW0oVdlbU2u8ruT7UoK61a8r2pFcPdqNtUpSawZ2p@BrRpTQIpyL3khFJ6DTue4wZj@h@R/xkR/4wo@IwoNKLLGw" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h2>Python, 246 chars</h2>

<pre><code>import os
a=list(os.read(0,2e3))
w=a.index('\n')+1
a+=' '*w
def f(p,t):
    if e&lt;a[p]or p in t:return
    t[p]=1
    return'*'&gt;a[p]or any(f(p+d,t)for d in(~w,-w,-w+1,-1,1,w-1,w,w+1))
z=0
for e in a:
    if(' '&lt;e)*~-f(z,{}):a[z]='*'
    z+=1
print''.join(a[:~w])
</code></pre>

<p>The solution works by doing a DFS from each position to determine whether or not to fill.</p>

<p>If trailing whitespace on each line is allowed, it may be shortened by using w=80 and padding the input lines with whitespace to 80 chars.</p>
</div>
<div id="pu2" class="pu"><h2>Python, <strike>478</strike> 471 characters</h2>

<p>(Not including comments.  <strike>452</strike> 450 characters not including the imports.)</p>

<pre><code>import sys,itertools
i=[list(x)for x in sys.stdin.read().strip().split('\n')]
h=len(i)
w=len(i[0])
n=h*w
b=n+1
e=range(h)
d=range(w)
# j is, at first, the adjancency matrix of the graph.
# The last vertex in j is the "drain" vertex.
j=[[[b,1][(t-r)**2+(v-c)**2&lt;=1 and i[r][c]&gt;=i[t][v]] for t in e for v in d]+[[b,1][max([r==0,r&gt;h-2,c==0,c&gt;w-2])]]for r in e for c in d]+[[0]*b]
r=range(b)
for k,l,m in itertools.product(r,repeat=3):
    # This is the Floyd-Warshall algorithm
    if j[l][k]+j[k][m]&lt;j[l][m]:
        j[l][m]=j[l][k]+j[k][m]
# j is now the distance matrix for the graph.
for k in r:
    if j[k][-1]&gt;n:
        # This means that vertex k is not connected to the "drain" vertex, and is therefore flooded.
        i[k/w][k-w*(k/w)]='*'
for r in e:print(''.join(i[r]))
</code></pre>

<p>The idea here is that I construct a directed graph where each grid cell has its own vertex (plus one additional "drain" vertex).  There is an edge in the graph from each higher valued cell to its neighboring lower valued cells, plus there is an edge from all exterior cells to the "drain" vertex.  I then use <a href="http://en.wikipedia.org/wiki/Floyd-Warshall_algorithm" rel="nofollow">Floyd-Warshall</a> to calculate which vertices are connected to the "drain" vertex; any vertices that are <em>not</em> connected will be flooded and are drawn with an asterisk.</p>

<p>I don't have much experience with condensing Python code, so there's probably a more succinct way I could have implemented this method.</p>
</div>
<div id="pu3" class="pu"><h2>Haskell, 258 characters</h2>

<pre><code>a§b|a&lt;b='*'|1&lt;3=a
z=[-1..1]
l m=zipWith(§)m$(iterate(b.q)$b(\_ _-&gt;'9'))!!(w*h)where
 w=length m`div`h
 h=length$lines m
 q d i=max$minimum[d!!(i+x+w*y)|x&lt;-z,y&lt;-z]
 b f=zipWith(\n-&gt;n`divMod`w¶f n)[0..]m
 (j,i)¶g|0&lt;i&amp;&amp;i&lt;w-2&amp;&amp;0&lt;j&amp;&amp;j&lt;h-1=g|1&lt;3=id
main=interact l
</code></pre>

<p>Example run:</p>

<pre><code>$&gt; runhaskell 2638-Lakes2D.hs &lt;&lt;TEST
&gt; 8888888888
&gt; 5664303498
&gt; 6485322898
&gt; 5675373666
&gt; 7875555787
&gt; TEST
8888888888
566*****98
6*85***898
5675*7*666
7875555787
</code></pre>

<p>Passes all unit tests. No arbitrary limits on size.</p>

<hr>

<ul>
<li>Edit (281 → 258): don't test for stability, just iterate to the upper bound; stop passing constant argument <code>m</code></li>
</ul>
</div>
<div id="pu4" class="pu"><h2>Python, <s>483</s> 491 characters</h2>

<pre><code>a=dict()
def s(n,x,y,R):
 R.add((x,y))
 r=range(-1,2)
 m=set([(x+i,y+j)for i in r for j in r if(i,j)!=(0,0)and(x+i,y+j)not in R])
 z=m-set(a.keys())
 if len(z)&gt;0:return 1
 else:return sum(s(n,k[0],k[1],R)for k in[d for d in m-z if a[(d[0],d[1])]&lt;=n])
i=[list(x)for x in input().strip().split('\n')]
h=len(i)
w=len(i[0])
e=range(0,w)
j=range(0,h)
for c in[(x,y)for x in e for y in j]:a[c]=int(i[c[1]][c[0]])
for y in j:print(''.join([('*',str(a[(x,y)]))[s(a[(x,y)],x,y,set())&gt;0] for x in e]))
</code></pre>

<p>I'm pretty sure there's a better (and shorter) way of doing this</p>
</div>
<div id="pu5" class="pu"><h2>Common Lisp, 833</h2>

<pre><code>(defun drains (terr dm a b)
  (cond
    ((= (aref dm a b) 1) t)
    ((= (aref dm a b) -1) nil)
    ((or (= a 0) (= b 0)
     (= a (1- (array-dimension terr 0)))
     (= b (1- (array-dimension terr 1)))) t)
    (t (loop for x from -1 to 1
       do (loop for y from 0 to 1
           do (if (and (or (&gt; x 0) (&gt; y 0))
                   (drains terr dm (+ a x) (+ b y))
                   (&lt;= (aref terr (+ a x) (+ b y))
                   (aref terr a b)))
              (progn
                (setf (aref dm a b) 1)
                (return-from drains t)))))
    (setf (aref dm a b) -1)
    nil)))

(defun doit (terr)
  (let ((dm (make-array (array-dimensions terr))))
    (loop for x from 0 to (- (array-dimension terr 0) 1)
       do (loop for y from 0 to (- (array-dimension terr 1) 1)
         do (format t "~a"
            (if (drains terr dm x y)
                (aref terr x y)
                "*"))
         finally (format t "~%")))))
</code></pre>

<p>No attempt has been made to golf this, I just found the problem interesting.  Input is the 2D array of the map.  The solution checks each square to see if it "drains" -- a square drains if it is on the outer edge or if it is adjacent to an equal or lower height square that drains.  To keep from recursing endlessly, the code keeps a "drain map" (dm) where it stores the drainage status of squares that have already been determined.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/2638/">2638</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




