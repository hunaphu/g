<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::54</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td></td><td>241212T032025Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/277198#277198">tsh</a></td></tr>
<tr d-ix="1"><td>nan</td><td></td><td>240818T003330Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/275034#275034">Lucenapo</a></td></tr>
<tr d-ix="2"><td>nan</td><td>Although python doesn't have very golfable switch statements the match/case syntax since Python 3.10</td><td>140412T194400Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/25791#25791">Justin</a></td></tr>
<tr d-ix="3"><td>nan</td><td></td><td>220119T163743Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/241400#241400">quintopi</a></td></tr>
<tr d-ix="4"><td>nan</td><td>A common pattern is to use listmaplambda c c.func</td><td>240325T180711Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/272078#272078">TheUltim</a></td></tr>
<tr d-ix="5"><td>nan</td><td>Multiline Integer Inputs</td><td>231008T084341Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/265855#265855">Nishant </a></td></tr>
<tr d-ix="6"><td>nan</td><td></td><td>231228T200732Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/268825#268825">l4m2</a></td></tr>
<tr d-ix="7"><td>nan</td><td>Another tip this is a pretty useful but rarely useable alternative ternary operator which we use in Scratch * and +. This uses the fact the booleans are equal to 0 and 1</td><td>221223T130725Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/255968#255968">SectorCo</a></td></tr>
<tr d-ix="8"><td>002</td><td>Check if a number is a power of</td><td>171227T025926Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/151831#151831">xnor</a></td></tr>
<tr d-ix="9"><td>nan</td><td></td><td>230522T164302Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/261165#261165">Hunaphu</a></td></tr>
<tr d-ix="10"><td>nan</td><td></td><td>230505T122713Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/260704#260704">mousetai</a></td></tr>
<tr d-ix="11"><td>nan</td><td></td><td>230302T010102Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/258661#258661">ShadowRa</a></td></tr>
<tr d-ix="12"><td>nan</td><td></td><td>230210T212053Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/257664#257664">ShadowRa</a></td></tr>
<tr d-ix="13"><td>nan</td><td></td><td>141107T082054Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/41217#41217">xnor</a></td></tr>
<tr d-ix="14"><td>nan</td><td></td><td>221113T121628Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/254535#254535">SectorCo</a></td></tr>
<tr d-ix="15"><td>nan</td><td></td><td>221104T030430Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/254159#254159">DialFros</a></td></tr>
<tr d-ix="16"><td>nan</td><td></td><td>170803T143439Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/137377#137377">Dead Pos</a></td></tr>
<tr d-ix="17"><td>011</td><td>Instead of not in</td><td>220901T171451Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/251535#251535">naffetS</a></td></tr>
<tr d-ix="18"><td>nan</td><td></td><td>220629T084804Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/249267#249267">nTerior</a></td></tr>
<tr d-ix="19"><td>nan</td><td></td><td>201226T161418Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/216900#216900">Danis</a></td></tr>
<tr d-ix="20"><td>nan</td><td></td><td>191125T135750Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/196360#196360">Dead Pos</a></td></tr>
<tr d-ix="21"><td>nan</td><td></td><td>110128T033220Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/97#97">Ming-Tan</a></td></tr>
<tr d-ix="22"><td>nan</td><td>Conditionals can be lengthy. In some cases</td><td>110128T001242Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/62#62">moinudin</a></td></tr>
<tr d-ix="23"><td>nan</td><td></td><td>110127T235809Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/55#55">moinudin</a></td></tr>
<tr d-ix="24"><td>nan</td><td></td><td>110703T211501Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/3082#3082">zhazam</a></td></tr>
<tr d-ix="25"><td>nan</td><td></td><td>220519T074516Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/247525#247525">jezza_99</a></td></tr>
<tr d-ix="26"><td>nan</td><td>When you want to compare 2 booleans to see if they are different</td><td>220501T190823Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/246764#246764">TKirishi</a></td></tr>
<tr d-ix="27"><td>nan</td><td></td><td>210720T094107Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/231603#231603">ATO</a></td></tr>
<tr d-ix="28"><td>nan</td><td></td><td>220315T033317Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/244155#244155">jixperso</a></td></tr>
<tr d-ix="29"><td>nan</td><td></td><td>220314T215717Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/244140#244140">Joao-3</a></td></tr>
<tr d-ix="30"><td>nan</td><td></td><td>220225T202821Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/243409#243409">TRG078</a></td></tr>
<tr d-ix="31"><td>nan</td><td>To convert a 2D list to a 1D flat list</td><td>220225T031201Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/243371#243371">DialFros</a></td></tr>
<tr d-ix="32"><td>nan</td><td></td><td>220120T210111Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/241476#241476">pxeger</a></td></tr>
<tr d-ix="33"><td>nan</td><td></td><td>211218T015503Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/239726#239726">pxeger</a></td></tr>
<tr d-ix="34"><td>nan</td><td></td><td>211111T155912Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/237171#237171">pxeger</a></td></tr>
<tr d-ix="35"><td>nan</td><td></td><td>180109T222911Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/152933#152933">xnor</a></td></tr>
<tr d-ix="36"><td>nan</td><td>Special characters in string literals</td><td>210210T230843Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/218868#218868">xnor</a></td></tr>
<tr d-ix="37"><td>nan</td><td></td><td>210916T075422Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/235406#235406">xnor</a></td></tr>
<tr d-ix="38"><td>nan</td><td></td><td>161002T033640Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/95156#95156">xnor</a></td></tr>
<tr d-ix="39"><td>001</td><td>Shorten while</td><td>210831T202905Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/233871#233871">dingledo</a></td></tr>
<tr d-ix="40"><td>nan</td><td></td><td>150626T181436Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/52317#52317">xnor</a></td></tr>
<tr d-ix="41"><td>nan</td><td></td><td>210726T045538Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/231807#231807">dingledo</a></td></tr>
<tr d-ix="42"><td>nan</td><td>Use a=b=c=0 instead of a</td><td>110129T185200Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/202#202">moinudin</a></td></tr>
<tr d-ix="43"><td>nan</td><td></td><td>191116T134745Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/195960#195960">bfontain</a></td></tr>
<tr d-ix="44"><td>nan</td><td></td><td>150217T072941Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/45792#45792">Sp3000</a></td></tr>
<tr d-ix="45"><td>nan</td><td></td><td>210413T171638Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/223410#223410">Ryan Lau</a></td></tr>
<tr d-ix="46"><td>nan</td><td>When you want to use map with list then cast it to list</td><td>210316T165225Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/220783#220783">HK boy</a></td></tr>
<tr d-ix="47"><td>nan</td><td></td><td>160121T045827Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/69815#69815">xnor</a></td></tr>
<tr d-ix="48"><td>nan</td><td></td><td>110128T000533Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/58#58">JPvdMerw</a></td></tr>
<tr d-ix="49"><td>nan</td><td></td><td>150518T220247Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/50412#50412">xnor</a></td></tr>
<tr d-ix="50"><td>nan</td><td>Printing the elements of a list</td><td>201215T033930Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/216352#216352">vrintle</a></td></tr>
<tr d-ix="51"><td>nan</td><td></td><td>200929T093502Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/211783#211783">Sisyphus</a></td></tr>
<tr d-ix="52"><td>nan</td><td></td><td>200612T112330Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/205999#205999">user9572</a></td></tr>
<tr d-ix="53"><td>nan</td><td></td><td>200509T205029Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/204550#204550">dingledo</a></td></tr>
<tr d-ix="54"><td>nan</td><td></td><td>161013T143048Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/96103#96103">xnor</a></td></tr>
<tr d-ix="55"><td>nan</td><td></td><td>191016T000444Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/194319#194319">xnor</a></td></tr>
<tr d-ix="56"><td>nan</td><td></td><td>190217T014409Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/180041#180041">xnor</a></td></tr>
<tr d-ix="57"><td>nan</td><td>Note The below makes sense only in the program is scored as characters</td><td>190907T213627Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/191456#191456">Petar Do</a></td></tr>
<tr d-ix="58"><td>nan</td><td></td><td>190907T074003Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/191437#191437">xnor</a></td></tr>
<tr d-ix="59"><td>nan</td><td></td><td>190826T135117Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/190897#190897">user8505</a></td></tr>
<tr d-ix="60"><td>nan</td><td></td><td>190811T055547Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/189704#189704">user8505</a></td></tr>
<tr d-ix="61"><td>nan</td><td></td><td>190510T222531Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/185422#185422">Erik the</a></td></tr>
<tr d-ix="62"><td>nan</td><td></td><td>190427T223957Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/184881#184881">xnor</a></td></tr>
<tr d-ix="63"><td>nan</td><td></td><td>181212T220240Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/177505#177505">Sparr</a></td></tr>
<tr d-ix="64"><td>nan</td><td>In Python</td><td>181114T002252Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/175902#175902">cobaltp</a></td></tr>
<tr d-ix="65"><td>nan</td><td></td><td>181022T094822Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/174477#174477">Tim Rija</a></td></tr>
<tr d-ix="66"><td>nan</td><td></td><td>180823T055434Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/171091#171091">Chas Bro</a></td></tr>
<tr d-ix="67"><td>nan</td><td></td><td>180730T002616Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/169511#169511">Esolangi</a></td></tr>
<tr d-ix="68"><td>nan</td><td></td><td>180724T002719Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/169115#169115">xnor</a></td></tr>
<tr d-ix="69"><td>nan</td><td></td><td>180705T094923Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/167980#167980">user2027</a></td></tr>
<tr d-ix="70"><td>023</td><td>To assign to a tuple</td><td>160610T075758Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/82547#82547">Erik the</a></td></tr>
<tr d-ix="71"><td>nan</td><td>Large hard coded numbers can be represented in larger bases</td><td>180622T202914Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/167323#167323">mypetlio</a></td></tr>
<tr d-ix="72"><td>nan</td><td></td><td>141101T054124Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/40795#40795">xnor</a></td></tr>
<tr d-ix="73"><td>nan</td><td></td><td>151214T120748Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/66574#66574">Tim Pede</a></td></tr>
<tr d-ix="74"><td>nan</td><td>Use Splat * to pass a bunch of single character strings into a function</td><td>180413T182720Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/162170#162170">hyperneu</a></td></tr>
<tr d-ix="75"><td>nan</td><td></td><td>180220T210956Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/156301#156301">xnor</a></td></tr>
<tr d-ix="76"><td>nan</td><td></td><td>180112T224431Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/153115#153115">fejfo</a></td></tr>
<tr d-ix="77"><td>nan</td><td></td><td>180103T180833Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/152433#152433">lynn</a></td></tr>
<tr d-ix="78"><td>nan</td><td></td><td>171222T204955Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/151571#151571">fejfo</a></td></tr>
<tr d-ix="79"><td>nan</td><td></td><td>110128T000555Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/59#59">moinudin</a></td></tr>
<tr d-ix="80"><td>nan</td><td></td><td>170119T071952Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/107311#107311">G B</a></td></tr>
<tr d-ix="81"><td>nan</td><td></td><td>171024T082126Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/146172#146172">Neil</a></td></tr>
<tr d-ix="82"><td>035</td><td>If transforming from list to a tuple or set to a set</td><td>170904T101215Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/141546#141546">Blue</a></td></tr>
<tr d-ix="83"><td>nan</td><td></td><td>170825T151313Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/140484#140484">Bite cod</a></td></tr>
<tr d-ix="84"><td>nan</td><td></td><td>170825T144327Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/140478#140478">Bite cod</a></td></tr>
<tr d-ix="85"><td>nan</td><td></td><td>170825T143929Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/140477#140477">Bite cod</a></td></tr>
<tr d-ix="86"><td>nan</td><td></td><td>170825T143151Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/140475#140475">Bite cod</a></td></tr>
<tr d-ix="87"><td>nan</td><td></td><td>151118T032731Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/64169#64169">quintopi</a></td></tr>
<tr d-ix="88"><td>nan</td><td></td><td>131207T072637Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/15683#15683">Strigoid</a></td></tr>
<tr d-ix="89"><td>nan</td><td>Access list</td><td>170803T144429Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/137380#137380">Dead Pos</a></td></tr>
<tr d-ix="90"><td>nan</td><td>If you're drawing</td><td>161015T235640Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/96360#96360">Albert R</a></td></tr>
<tr d-ix="91"><td>nan</td><td></td><td>150604T124342Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/51270#51270">Tim Rija</a></td></tr>
<tr d-ix="92"><td>083</td><td>Store 8bit numbers compactly as a bytes object  in Python 3</td><td>150612T040903Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/51622#51622">xnor</a></td></tr>
<tr d-ix="93"><td>nan</td><td></td><td>161216T091505Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/103309#103309">kon psyc</a></td></tr>
<tr d-ix="94"><td>nan</td><td>When mapping a function on a list in Python 3</td><td>161119T222310Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/100506#100506">TuxCraft</a></td></tr>
<tr d-ix="95"><td>nan</td><td>Booleans are integers</td><td>161114T184822Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/99778#99778">user4594</a></td></tr>
<tr d-ix="96"><td>nan</td><td></td><td>151003T075809Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/59506#59506">xnor</a></td></tr>
<tr d-ix="97"><td>nan</td><td></td><td>161105T002655Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/98613#98613">xnor</a></td></tr>
<tr d-ix="98"><td>nan</td><td></td><td>160302T200443Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/74654#74654">lynn</a></td></tr>
<tr d-ix="99"><td>nan</td><td></td><td>160825T193028Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/91128#91128">xnor</a></td></tr>
<tr d-ix="100"><td>nan</td><td></td><td>160801T040910Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/87181#87181">xnor</a></td></tr>
<tr d-ix="101"><td>nan</td><td></td><td>150117T140934Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/44645#44645">Jakube</a></td></tr>
<tr d-ix="102"><td>nan</td><td></td><td>150921T174653Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/58404#58404">Juan Cor</a></td></tr>
<tr d-ix="103"><td>nan</td><td></td><td>160414T161528Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/77783#77783">Richie L</a></td></tr>
<tr d-ix="104"><td>nan</td><td></td><td>160304T030701Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/74743#74743">cat</a></td></tr>
<tr d-ix="105"><td>002</td><td>cmp in Python</td><td>160302T204606Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/74661#74661">mbomb007</a></td></tr>
<tr d-ix="106"><td>nan</td><td></td><td>160113T030827Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/69310#69310">Cyoce</a></td></tr>
<tr d-ix="107"><td>nan</td><td></td><td>141125T093019Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/41861#41861">Sp3000</a></td></tr>
<tr d-ix="108"><td>nan</td><td></td><td>160216T101007Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/73268#73268">Sp3000</a></td></tr>
<tr d-ix="109"><td>nan</td><td></td><td>151130T030522Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/65292#65292">J Atkin</a></td></tr>
<tr d-ix="110"><td>nan</td><td></td><td>110218T104732Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/1020#1020">gmunkhba</a></td></tr>
<tr d-ix="111"><td>nan</td><td></td><td>160201T005833Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/70670#70670">Dennis</a></td></tr>
<tr d-ix="112"><td>nan</td><td></td><td>160127T200652Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/70319#70319">Morgan T</a></td></tr>
<tr d-ix="113"><td>nan</td><td>For integer n</td><td>140910T033701Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/37553#37553">xnor</a></td></tr>
<tr d-ix="114"><td>nan</td><td></td><td>150507T231336Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/49791#49791">xnor</a></td></tr>
<tr d-ix="115"><td>nan</td><td></td><td>151130T005441Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/65288#65288">J Atkin</a></td></tr>
<tr d-ix="116"><td>nan</td><td></td><td>151117T052824Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/64091#64091">quintopi</a></td></tr>
<tr d-ix="117"><td>003</td><td>Printing a string without a trailing newline in Python</td><td>151110T093248Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/63521#63521">Sp3000</a></td></tr>
<tr d-ix="118"><td>nan</td><td></td><td>151023T053853Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/61529#61529">xnor</a></td></tr>
<tr d-ix="119"><td>nan</td><td></td><td>151023T042512Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/61526#61526">xnor</a></td></tr>
<tr d-ix="120"><td>nan</td><td></td><td>150525T005813Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/50719#50719">Sp3000</a></td></tr>
<tr d-ix="121"><td>nan</td><td></td><td>150705T122411Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/52640#52640">Sp3000</a></td></tr>
<tr d-ix="122"><td>nan</td><td></td><td>150418T151026Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/48994#48994">Sp3000</a></td></tr>
<tr d-ix="123"><td>nan</td><td></td><td>150530T090107Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/51022#51022">xnor</a></td></tr>
<tr d-ix="124"><td>nan</td><td>Instead of rangex</td><td>120304T213210Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/5047#5047">Blazer</a></td></tr>
<tr d-ix="125"><td>nan</td><td></td><td>110627T020600Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/3006#3006">gnibbler</a></td></tr>
<tr d-ix="126"><td>nan</td><td></td><td>150717T221851Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/53329#53329">aditsu q</a></td></tr>
<tr d-ix="127"><td>nan</td><td></td><td>111221T071056Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/4389#4389">JBernard</a></td></tr>
<tr d-ix="128"><td>nan</td><td></td><td>150705T122612Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/52641#52641">Sp3000</a></td></tr>
<tr d-ix="129"><td>nan</td><td></td><td>150705T120746Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/52639#52639">Sp3000</a></td></tr>
<tr d-ix="130"><td>nan</td><td>When squaring single letter variables</td><td>150629T101426Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/52396#52396">Beta Dec</a></td></tr>
<tr d-ix="131"><td>nan</td><td></td><td>150626T160857Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/52309#52309">Sp3000</a></td></tr>
<tr d-ix="132"><td>nan</td><td></td><td>150519T021033Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/50428#50428">Sp3000</a></td></tr>
<tr d-ix="133"><td>nan</td><td></td><td>150622T215754Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/52028#52028">xnor</a></td></tr>
<tr d-ix="134"><td>nan</td><td></td><td>150616T205442Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/51783#51783">xnor</a></td></tr>
<tr d-ix="135"><td>nan</td><td></td><td>150612T033504Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/51621#51621">xnor</a></td></tr>
<tr d-ix="136"><td>nan</td><td></td><td>150525T074905Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/50730#50730">Sp3000</a></td></tr>
<tr d-ix="137"><td>nan</td><td></td><td>150423T081334Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/49156#49156">user3340</a></td></tr>
<tr d-ix="138"><td>nan</td><td></td><td>150423T055324Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/49155#49155">xnor</a></td></tr>
<tr d-ix="139"><td>nan</td><td></td><td>150421T052607Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/49081#49081">xnor</a></td></tr>
<tr d-ix="140"><td>nan</td><td>When using Python 3</td><td>150419T040710Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/49008#49008">Justin</a></td></tr>
<tr d-ix="141"><td>nan</td><td>If you're using a builtin function repeatedly</td><td>110128T000828Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/61#61">moinudin</a></td></tr>
<tr d-ix="142"><td>003</td><td>Extended iterable unpacking "Starred assignment"</td><td>141202T151758Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/42123#42123">Sp3000</a></td></tr>
<tr d-ix="143"><td>nan</td><td></td><td>141122T010009Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/41742#41742">xnor</a></td></tr>
<tr d-ix="144"><td>nan</td><td></td><td>141122T005129Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/41741#41741">xnor</a></td></tr>
<tr d-ix="145"><td>nan</td><td></td><td>110203T131249Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/407#407">gnibbler</a></td></tr>
<tr d-ix="146"><td>nan</td><td></td><td>141107T091257Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/41223#41223">xnor</a></td></tr>
<tr d-ix="147"><td>nan</td><td></td><td>110128T000712Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/60#60">Champo</a></td></tr>
<tr d-ix="148"><td>nan</td><td></td><td>141101T052026Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/40791#40791">xnor</a></td></tr>
<tr d-ix="149"><td>nan</td><td>If you are doing something small in a for loop whose only purpose is to invoke a side effect pop</td><td>141025T054650Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/40308#40308">Justin</a></td></tr>
<tr d-ix="150"><td>nan</td><td>You can use default arguments of a function to save some indentation</td><td>140821T163007Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/36583#36583">Falko</a></td></tr>
<tr d-ix="151"><td>nan</td><td></td><td>140926T024359Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/38203#38203">DLosc</a></td></tr>
<tr d-ix="152"><td>nan</td><td></td><td>131206T235352Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/15677#15677">Justin</a></td></tr>
<tr d-ix="153"><td>nan</td><td></td><td>140401T182647Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/25192#25192">Justin</a></td></tr>
<tr d-ix="154"><td>nan</td><td></td><td>140925T222736Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/38195#38195">Claudiu</a></td></tr>
<tr d-ix="155"><td>nan</td><td></td><td>140928T084335Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/38265#38265">Beta Dec</a></td></tr>
<tr d-ix="156"><td>nan</td><td></td><td>131018T062235Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/12877#12877">Coding m</a></td></tr>
<tr d-ix="157"><td>001</td><td>If you rely on data mostly for kolmogorovcomplexity problems</td><td>140925T223022Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/38196#38196">Claudiu</a></td></tr>
<tr d-ix="158"><td>nan</td><td></td><td>140416T200505Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/25955#25955">Eyrofire</a></td></tr>
<tr d-ix="159"><td>nan</td><td>For ages it bothered me that I couldn't think of a short way to get the entire alphabet. If you use range enough that R=range is worth having in your program</td><td>140414T145433Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/25836#25836">undergro</a></td></tr>
<tr d-ix="160"><td>nan</td><td>Run your code through an spaceremover</td><td>140405T163710Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/25385#25385">ɐɔıʇǝɥʇu</a></td></tr>
<tr d-ix="161"><td>nan</td><td>If you need to import a lot of modules you can reassign __import__ to something shorter</td><td>140320T092540Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/24599#24599">Justin F</a></td></tr>
<tr d-ix="162"><td>nan</td><td>When you have two boolean values</td><td>131220T065322Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/16086#16086">Justin</a></td></tr>
<tr d-ix="163"><td>001</td><td>If you represent boolean values as numbers you can save characters. This is especially true for using 1 as True.</td><td>140121T044025Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/18983#18983">Justin</a></td></tr>
<tr d-ix="164"><td>nan</td><td></td><td>140111T191716Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/18265#18265">AMK</a></td></tr>
<tr d-ix="165"><td>nan</td><td></td><td>140108T234434Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/18030#18030">Tim Rija</a></td></tr>
<tr d-ix="166"><td>nan</td><td></td><td>140106T002518Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/17685#17685">Timtech</a></td></tr>
<tr d-ix="167"><td>nan</td><td>Be aware of all</td><td>140105T234014Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/17679#17679">Martin T</a></td></tr>
<tr d-ix="168"><td>nan</td><td></td><td>131215T185224Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/15945#15945">Wasi</a></td></tr>
<tr d-ix="169"><td>nan</td><td></td><td>110703T052924Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/3068#3068">boothby</a></td></tr>
<tr d-ix="170"><td>nan</td><td></td><td>110627T234601Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/3011#3011">rplnt</a></td></tr>
<tr d-ix="171"><td>nan</td><td></td><td>110429T234114Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/2365#2365">cemper93</a></td></tr>
<tr d-ix="172"><td>003</td><td>Just found out two new things. First</td><td>110203T233216Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/444#444">Champo</a></td></tr>
<tr d-ix="173"><td>nan</td><td></td><td>110203T203222Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/416#416">gnibbler</a></td></tr>
<tr d-ix="174"><td>nan</td><td></td><td>110203T131847Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/408#408">gnibbler</a></td></tr>
<tr d-ix="175"><td>nan</td><td></td><td>110203T131012Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/406#406">gnibbler</a></td></tr>
<tr d-ix="176"><td>002</td><td>Sometimes you can use Python's execstatement combined with string repetition</td><td>110128T001451Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/64#64">JPvdMerw</a></td></tr>
<tr d-ix="177"><td>nan</td><td>If you're doing somewhat more complex golfing that require something from the standard library to be used a lot</td><td>110128T003744Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/71#71">Rafe Ket</a></td></tr>
<tr d-ix="178"><td>nan</td><td></td><td>110128T002641Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/68#68">moinudin</a></td></tr>
<tr d-ix="179"><td>nan</td><td></td><td>110128T000017Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/56#56">JPvdMerw</a></td></tr>
<tr d-ix="180"><td>nan</td><td></td><td>110128T000212Z</td><td><a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/57#57">Alexandr</a></td></tr>
</table>
<div id="pu0" class="pu"><h2>Use slicing when try to return single element list with-in <code>and</code> &amp; <code>or</code></h2>
<p>We all known that following two statements are the same. So we prefer to use <code>and</code>-<code>or</code> in place of <code>if</code>-<code>else</code> when possible.</p>
<pre class="lang-python prettyprint-override"><code>[v]if p&gt;0else f(x)
p&gt;0and[v]or f(x)
</code></pre>
<p>But whenever the return value is a single element in array, it can be further shorten as</p>
<pre class="lang-python prettyprint-override"><code>[v][:p]or f(x)
</code></pre>
<p>The same idea may apply to multiple different conditions:</p>
<pre class="lang-python prettyprint-override"><code>a&gt;0and[v]or f(x)
(a&gt;0)*[v]or f(x)
a*[v]or f(x) # if `a&lt;=1` or dupe is acceptable
[v][:a]or f(x)

a&lt;0and[v]or f(x)
[v][:-a]or f(x)

a==0and[v]or f(x)
[v][a*a:]or f(x)
</code></pre>
</div>
<div id="pu1" class="pu"><h1>Repr trick</h1>
<p>Suppose you are using Python 3.
You can use <code>'%r'%a</code> instead of <code>repr(a)</code>:</p>
<pre><code>&gt;&gt;&gt; a=456
&gt;&gt;&gt; repr(a)
'456'
&gt;&gt;&gt; '%r'%a # 1 byte shorter
'456'
</code></pre>
<p>Note: In Python 2, you should use <code>`a`</code>.</p>
</div>
<div id="pu2" class="pu"><p>Although python doesn't have very golfable switch statements (the <code>match</code>/<code>case</code> syntax since Python 3.10), you can emulate them with dictionaries. For example, if you wanted to golf this:</p>

<pre class="lang-python prettyprint-override"><code>match a:
 case 1: runCodeOne()
 case 2: runCodeTwo()
 case 3: runCodeThree()
 case _: runDefault()
</code></pre>
<p>You could use <code>if</code> statements, or you could use one of these:</p>
<pre class="lang-python prettyprint-override"><code># Code as strings
exec{1:&quot;runCodeOne()&quot;,2:&quot;runCodeTwo()&quot;,3:&quot;runCodeThree()&quot;}[a]

# Functions with non-consecutive indices
{1:runCodeOne,4:runCodeFour,30:runCodeThirty)[a]()

# Functions with consecutive indices
# (you can't add a default value)
(0,runCodeOne,runCodeTwo,runCodeThree)[a]()

# Code as strings (and default code)
exec{ &lt;same as before&gt; }.get(a,&quot;runDefault()&quot;)

# Run functions (and default function)
{ &lt;same as before&gt; }­.get(a,runDefault)()
</code></pre>
<p>This can be used to condense return statements:</p>
<pre class="lang-python prettyprint-override"><code># Before
def getValue(k):
 if k=='blah':return 1
 if k=='foo':return 2
 if k=='bar':return 3
 return 4

# After
# getValue = ...
lambda k:{'blah':1,'foo':2,'bar':3}.get(k,4)
</code></pre>
</div>
<div id="pu3" class="pu"><h1>Signum Function</h1>
<p>Python doesn't have a nice signum built-in, even though its a very useful function for golfing. It takes a lot of bytes to use <code>math.copysign</code> or <code>numpy.sign</code> once you include the imports, and the latter doesn't even return ints, so you waste even more bytes if you need to use it in a list index, for example.</p>
<p>Here's a decent version you can use in that one answer where you really need integer signs multiple times:</p>
<pre class="lang-py prettyprint-override"><code>s=lambda x:(x&gt;0)-(x&lt;0)
</code></pre>
<p>As per Jakque, in Python 2, you can use the cmp function.</p>
</div>
<div id="pu4" class="pu"><p>A common pattern is to use <code>list(map(lambda c: c.func(), iterable))</code>. This can be shortened to <code>list(map(&lt;c's type&gt;.func, iterable))</code>. For example: <code>list(map(lambda c:c.strip(), lines))</code> can be shortened to <code>list(map(str.strip, lines))</code></p>
</div>
<div id="pu5" class="pu"><p><strong>Multiline Integer Inputs, works in Linux and Windows</strong></p>
<p>This may be much shorter for Python3 and inputs as integer</p>
<pre><code>a,b,c=map(int,open(0))
</code></pre>
<p>For example expected input is:</p>
<pre><code>23
45
56
</code></pre>
<p>The above golf code will assign respective integer values a=23, b=45, c=56</p>
</div>
<div id="pu6" class="pu"><p>If inverting result is fine:</p>
<pre><code>a==123or b==123  # 15 bytes
123in[a,b]       # 10 bytes
a!=123!=b        #  9 bytes
</code></pre>
</div>
<div id="pu7" class="pu"><p>Another tip: this is a pretty useful (but rarely useable) alternative ternary operator which we use in Scratch: <code>*</code> and <code>+</code>. This uses the fact the booleans are equal to 0 and 1, and the rules of multiplying, but can only be used in limited situations.</p>
<p>For example, in string manipulations, you can use these. I used this in my code.golf submission:</p>
<pre class="lang-python prettyprint-override"><code>for i in range(1,101):print(f'{i}'*bool(i%3and i%5)+'Fizz'*(i%3==0)+'Buzz'*(i%5==0))
</code></pre>
<p>These can be sometimes long, so you can only use in limited situations. Note that string conversions may be necessary, as used in <code>f'{i}'</code>, thus making this impractical with multiple datatypes.</p>
<p><s>This is also dangerous in recursive solutions, as all the conditions will be checked (so it doesn't terminate at a <code>True</code> value, thus recursing unnecessarily; the exact opposite of a short-circuit operator).</p>
<p>So in factorials, this will fail to <code>RecursionError</code>:</p>
<pre class="lang-python prettyprint-override"><code>x=lambda n:n*(x(n-1)*(n!=1)+1*(n==1))
</code></pre>
</s>
<p><strong>EDIT:</strong> It turns out that using this with <code>and</code> or <code>or</code> can actually solve the short-circuit problem mentioned above. See <a href="https://codegolf.stackexchange.com/a/264855/110681">this</a> as an example.</p>
<p>And for the factorial example (25 bytes):</p>
<pre class="lang-py prettyprint-override"><code>x=lambda n:n&lt;2or n*x(n-1)
</code></pre>
</div>
<div id="pu8" class="pu"><h2>Check if a number is a power of 2</h2>
<p>Check whether a positive integer <code>n</code> is a perfect power of 2, that is one of <code>1, 2, 4, 8, 16, ...</code>, with any of these expressions:</p>

<pre class="lang-python prettyprint-override"><code>n&amp;~-n&lt;1
n&amp;-n==n
n^n-1&gt;=n
2**n%n&lt;1
</code></pre>
<p>The third expression also works for <code>n==0</code> giving <code>False</code>. The last is easy to modify to checking for, say, powers of 3.</p>
</div>
<div id="pu9" class="pu"><h3>Should you set variable?</h3>
<p><sub>This is perhaps already be posted but I could not find it with an explanation.</sub></p>
<pre class="lang-python prettyprint-override"><code>gsetn = lambda n, k, c=3: n+c &lt; (n-1) * k
gset = lambda n, s, c=3: gsetn(n, len(s), c)

gset(3,'range')       # == True
gsetn(3, 4)           # == True
</code></pre>
<p>The cost of using <code>f</code> of length <code>k</code> <code>n</code> times is <code>nk</code> and if it is set, the cost is <code>n+cost of setting</code>. So if <code>f</code> is used <code>n</code> times it is worth setting if
<span class="math-container">$$
n+c+k &lt; n\cdot k\Leftrightarrow n+c &lt; (n-1)\cdot k.
$$</span>
Typically it costs <code>x=</code>+<code>k</code>+<code>\n</code>(or <code>;</code>) = 3 + <code>k</code> to set the variable.
Example:</p>
<pre class="lang-python prettyprint-override"><code>len('r,a,s=range,abs,sum;') == len('range')+len('abs')+len('sum')+3*3
</code></pre>
<p>But, it could be different:</p>
<pre class="lang-python prettyprint-override"><code>from math import factorial as f
</code></pre>
</div>
<div id="pu10" class="pu"><h1>Use Annotations to save on indentation</h1>
<p>Hurry up before this feature goes away</p>
<p>If you have code like this:</p>
<pre class="lang-py prettyprint-override"><code>a:b = c
</code></pre>
<p>Is syntactically equivalent to</p>
<pre class="lang-py prettyprint-override"><code>a = c
__annotations[&quot;a&quot;] = b
</code></pre>
<p>Note that if b is a expression, it can be evaluated. You can use this for side effects, for example consider this python quine:</p>
<pre class="lang-py prettyprint-override"><code>c:print(c%c)=&quot;c:print(c%%c)=%s&quot;
</code></pre>
<p>In this case, this is the exact same length as</p>
<pre class="lang-py prettyprint-override"><code>c=&quot;c:print(c%%c)=%s&quot;
print(c%%c)
</code></pre>
<p>However, in a indented context, it can save some bytes:</p>
<pre class="lang-py prettyprint-override"><code>if abcd:
   for defg in hijk:k:print(k(k))=eval(input())
</code></pre>
<p>Saves 5 bytes over:</p>
<pre class="lang-py prettyprint-override"><code>if abcd:
    for defg in hijk:
        k=eval(input())
        print(k(k))
</code></pre>
</div>
<div id="pu11" class="pu"><h3>Integer ceiling division with no repeated terms and no extra parentheses fighting operator precedence</h3>
<p>You have <code>n</code>, the numerator, and <code>d</code>, the denominator, or an expression, <code>a+b</code> as the denominator. Floor division is trivial:</p>
<pre><code>n//d      # 4 characters. On Py2, n/d works, but Py2 is dead, move on
n//(a+b)  # 8 characters if denominator is expression with operator that is lower precedence
          # than division (or equal and same associativity), dumb parens
</code></pre>
<p>The naive approaches to ceiling division is one of:</p>
<pre><code>math.ceil(n/d)      # 14 characters, and needs an import. Wrong if inputs large enough to hit
                    # C double integer representation limits (~53 bits)
math.ceil(n/(a+b))  # 18 characters; bad, but at least the denominator being an expression
                    # didn't make it proportionately worse

(n+d-1)//d          # 10 characters. No import needed, no C double precision limitations
                    # Repeats d twice though, so if d is a more complicated expression...
(n+a+b-1)//(a+b)    # 16 characters, and gets worse if d is more complicated or involves
                    # operators with precedence below +/-
</code></pre>
<p>As mentioned off-hand in <a href="https://codegolf.stackexchange.com/a/58404/70305">another answer</a>, you can turn floor division into ceiling division with:</p>
<pre><code>-(-n//d)        # 8 characters, shortest so far, and it only uses each term once, so...
-(-n//(a+b))    # 12 characters (whew, only paying for d expression once again)
</code></pre>
<p>but there is still one more optimization to be had. Unary negation is too high precedence, so we needed a second set of parentheses to separate negation of the numerator from the negation of the result of floor division (getting us ceil division as an end result). That's too much. But thankfully, subtraction is lower precedence than unary negation, so we can just subtract from zero, and get:</p>
<pre><code>0--n//d      # 7 characters! Only three more than floor division!
0--n//(a+b)  # 11 characters, still only use d term once!
</code></pre>
<p>This is probably one of the only time Python code golfers are <em>glad</em> that Python doesn't offer a <code>--</code> decrement operator; since it doesn't exist, each <code>-</code> is separate, the first is a subtraction operand (relatively low precedence), the second unary negation (very high precedence), so no parentheses are needed; unary negation attaches <em>before</em> floor division, subtraction <em>after</em>, achieving ceiling division at the cost of one <code>0</code>, instead of open and close parentheses.</p>
</div>
<div id="pu12" class="pu"><h4>(Destructively) Iterate any iterable in reverse</h4>
<pre><code>for x in s[::-1]:f(x)
</code></pre>
<p>can shorten to:</p>
<pre><code>while s:f(s.pop())
</code></pre>
<p>when <code>s</code> is a <code>list</code> and destructive iteration is acceptable. But if you need to use the value multiple times, even with the walrus, this doesn't work so hot:</p>
<pre><code>for x in s[::-1]:f(x);g(x)

while s:x=s.pop();f(x);g(x)  # Longer!
while s:f(x:=s.pop());g(x)   # Same length, and := precedence means it doesn't always work in larger expressions
</code></pre>
<p>And of course, <code>pop</code> calls don't work at all when <code>s</code> isn't already a <code>list</code>. In Python 3 though, you can use unpacking to do the <code>pop</code> work with fewer characters <em>and</em> it works on things that aren't <code>list</code>s (though they become a <code>list</code> after the first loop):</p>
<pre><code>for x in s[::-1]:f(x);g(x)
while s:*s,x=s;f(x);g(x)
</code></pre>
<p>which shaves two characters, and (since it's already doing top-level statement work) doesn't have the issues with precedence in larger expressions that the walrus has.</p>
<p>Even for the single expression case, this can be useful:</p>
<pre><code>for x in s[::-1]:f(x) # Works on any sequence
while s:f(s.pop())    # 3 characters shorter but works only on lists
while s:*s,x=s;f(x)   # Only 2 characters shorter, but works on *any* iterable
</code></pre>
<p>Since the minimal number of characters to convert iterables to a <code>list</code> is 2-3 (depending on use), paying one extra character to avoid the conversion can be worth it.</p>
</div>
<div id="pu13" class="pu"><h2>Collapse two numerical loops into one</h2>
<p>Say you're iterating over the cells of an <code>m*n</code> grid. Instead of two nested <code>for</code> loops, one for the rows and one for the columns, it's usually shorter to write a single loop to iterate over the <code>m*n</code> cells of the grid. You can extract the row and column of the cell inside the loop.</p>
<p><strong>Original code:</strong></p>

<pre class="lang-python prettyprint-override"><code>for i in range(m):
 for j in range(n):
  do_stuff(i,j)
</code></pre>
<p><strong>Golfed code:</strong></p>
<pre class="lang-python prettyprint-override"><code>for k in range(m*n):
 do_stuff(k/n,k%n)
</code></pre>
<p>In effect, you're iterating over the Cartesian product of the two ranges, encoding the pair <code>(i,j)</code> as <code>x=i*n+j</code>. You've save a costly <code>range</code> call and a level of indentation inside the loop. The order of iteration is unchanged.</p>
<p>Use <code>//</code> instead of <code>/</code> in Python 3. If you refer to <code>i</code> and <code>j</code> many times, it may be shorter to assign their values <code>i=k/n</code>, <code>j=k%n</code> inside the loop.</p>
</div>
<div id="pu14" class="pu"><h1>Use <code>**.5</code> instead of <code>math.sqrt()</code></h1>
<p>This is a very useful tip, especially if square roots are the base of your answer.</p>
<p>Instead of</p>
<pre class="lang-python prettyprint-override"><code>from math import*
x=sqrt(4)
</code></pre>
<p>which is 27 bytes, we can simply use</p>
<pre class="lang-python prettyprint-override"><code>x=4**0.5
</code></pre>
<p>Golfed, of course, it's</p>
<pre class="lang-python prettyprint-override"><code>x=4**.5
</code></pre>
<p>saving 20 bytes!</p>
<p>Note that this trick can be used for finding any root. Here is  a function that does this:</p>
<pre class="lang-python prettyprint-override"><code>lambda x,y:x**1/y
</code></pre>
</div>
<div id="pu15" class="pu"><h1>Long numbers to <code>1e_</code></h1>
<p>I'm not sure if this has been mentioned before (likely), so either I'm going crazy or I'm blind.</p>
<p>Long numbers like <code>10000</code> can be written as <code>1e4</code> for short. Do note that using <code>1e_</code> gives a decimal, <strong>not</strong> a integer, so <code>1e4</code> in fact gives <code>10000.0</code>, so be wary when  doing stuff like:</p>
<pre><code>for x in range(1,1e4):print(x%5)
</code></pre>
<p>which gives an error since when using <code>range</code> you have to use integers.</p>
</div>
<div id="pu16" class="pu"><p><strong>Python 2 and 3 differences</strong></p>
<p>A <a href="https://codegolf.stackexchange.com/questions/137040/fake-divisor-sum-polyglots">recent challenge</a> pushed me to search for differences in two major versions of Python. More precisely, code that returns different results in different versions. This might be helpful in other polyglot challenges.</p>
<ol>
<li>Strings and bytes comparison</li>
</ol>
<ul>
<li>Python 2: <code>'' == b''</code></li>
<li>Python 3: <code>'' != b''</code></li>
</ul>
<ol start="2">
<li>Rounding (Luis Mendo <a href="https://codegolf.stackexchange.com/a/137062/66855">answer</a>)</li>
</ol>
<ul>
<li>Python 2: <code>round(1*0.5) = 1.0</code></li>
<li>Python 3: <code>round(1*0.5) = 0</code></li>
</ul>
<ol start="3">
<li>Division (Jonathan Allan <a href="https://codegolf.stackexchange.com/a/137119/66855">answer</a>)</li>
</ol>
<ul>
<li>Python 2: <code>10/11 = 0</code></li>
<li>Python 3: <code>10/11 = 0.9090909090909091</code></li>
</ul>
<ol start="4">
<li>Suggestions?</li>
</ol>
</div>
<div id="pu17" class="pu"><h1>Instead of <code>not in</code>, use <code>in</code> with <code>^1</code> or <code>1-</code></h1>
<p>Often, it helps to replace <code>a not in b</code> with <code>(a in b)^1</code>. By themselves,it doesn't save any bytes, but it often means that you can remove whitespace:</p>
<p>For example, <code>if a not in b:</code> can just be <code>if(a in b)^1:</code> to save a byte.</p>
</div>
<div id="pu18" class="pu"><p>You can use list checking instead of using <code>or</code>s in a clause statement.</p>
<p>e.g. instead of using</p>
<pre class="lang-python prettyprint-override"><code>if i % 3 == 0 or i % 5 == 0 or i % 7 == 0 ...:
# Golfed:
if i%3==0or i%5==0or i%7==0 ...:
</code></pre>
<p>use</p>
<pre class="lang-python prettyprint-override"><code>if 0 in [i % 3, i % 5, i % 7, ...]:
# Golfed:
if 0in[i%3,i%5,i%7,...]:
</code></pre>
<p>This saves around <code>2-3</code> characters per condition, but can only be used in certain circumstances.</p>
</div>
<div id="pu19" class="pu"><h1>The best way to check whether is a number even or not</h1>
<p>Usually you do it this way (6 bytes):</p>
<pre class="lang-python prettyprint-override"><code>n%2==0
</code></pre>
<p>But you can reduce it to 5 bytes:</p>
<pre class="lang-python prettyprint-override"><code>n%2&lt;1
</code></pre>
<p>And even 4 bytes:</p>
<pre class="lang-python prettyprint-override"><code>~n&amp;1
</code></pre>
<p>Bonus tip: when you use <code>if</code> you can ignore spacebetween <code>if</code> and <code>~n&amp;1</code> this way:</p>
<pre class="lang-python prettyprint-override"><code>if~n&amp;1:
</code></pre>
</div>
<div id="pu20" class="pu"><h2>Multiple <strong>if</strong> statements in comprehensions</h2>
<p>If you need to keep multiple conditions inside comprehension, you can replace <strong>and</strong> with <strong>if</strong> to save a byte each time.</p>
<p>Works in Python 2 and 3.</p>
<pre class="lang-python prettyprint-override"><code>[a for a in 'abc'if cond1()and cond2()or cond3()and cond4()and cond5()]
[a for a in 'abc'if cond1()if cond2()or cond3()if cond4()if cond5()]
</code></pre>
<p><a href="https://tio.run/##hZC9CgIxEIT7PMV20cLi/hpbQbCxshOLmOx5i7o5Yg706WMIGhTBlMPufDs748MPlusQDPagLZtqNl8KGB2xB7kaUJ@JT2lCnixDBQvYuQmlAId@cpyUeNvrgr2O9rW63D78SWZAUwA0P/flBtQV2HrAO@rJo5GZ1hZobSlOVwB0EbD9Ov0vlhB7Bb11oIDihjpqSbl2yg3GhVcVlN@gnOcQwhM" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>
</div>
<div id="pu21" class="pu"><p>Use string substitution and <code>exec</code> to deal with long keywords like <code>lambda</code> that are repeated often in your code.</p>
<pre class="lang-python prettyprint-override"><code>a=lambda b:lambda c:lambda d:lambda e:lambda f:0   # 48 bytes  (plain)
exec&quot;a=`b:`c:`d:`e:`f:0&quot;.replace('`','lambda ')    # 47 bytes  (replace)
exec&quot;a=%sb:%sc:%sd:%se:%sf:0&quot;%(('lambda ',)*5)     # 46 bytes  (%)
</code></pre>
<p>The target string is very often <code>'lambda '</code>, which is 7 bytes long. Suppose your code snippet contains <code>n</code> occurences of <code>'lambda '</code>, and is <code>s</code> bytes long. Then:</p>
<ul>
<li>The <code>plain</code> option is <code>s</code> bytes long.</li>
<li>The <code>replace</code> option is <code>s - 6n + 29</code> bytes long.</li>
<li>The <code>%</code> option is <code>s - 5n + 22 + len(str(n))</code> bytes long.</li>
</ul>
<p>From a <a href="https://i.sstatic.net/wSeF2.png" rel="noreferrer">plot of <em>bytes saved over <code>plain</code></em></a> for these three options, we can see that:</p>
<ul>
<li>For <em>n &lt; 5</em> lambdas, you're better off not doing anything fancy at all.</li>
<li>For <em>n = 5</em>, writing <code>exec&quot;...&quot;%(('lambda ',)*5)</code> saves 2 bytes, and is your best option.</li>
<li>For <em>n &gt; 5</em>, writing <code>exec&quot;...&quot;.replace('`','lambda ')</code> is your best option.</li>
</ul>
<p><strong>For other cases, you can index the table below:</strong></p>
<pre><code>          1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 (occurences)
       +---------------------------------------------------------
     3 |  -  -  -  -  -  -  -  -  -  -  -  -  -  -  r  r  r  r  r  
     4 |  -  -  -  -  -  -  -  -  -  r  r  r  r  r  r  r  r  r  r  
     5 |  -  -  -  -  -  -  -  r  r  r  r  r  r  r  r  r  r  r  r  
     6 |  -  -  -  -  -  r  r  r  r  r  r  r  r  r  r  r  r  r  r  
     7 |  -  -  -  -  %  r  r  r  r  r  r  r  r  r  r  r  r  r  r  
     8 |  -  -  -  %  %  r  r  r  r  r  r  r  r  r  r  r  r  r  r  
     9 |  -  -  -  %  %  r  r  r  r  r  r  r  r  r  r  r  r  r  r  
    10 |  -  -  %  %  %  r  r  r  r  r  r  r  r  r  r  r  r  r  r  
    11 |  -  -  %  %  %  r  r  r  r  r  r  r  r  r  r  r  r  r  r  
    12 |  -  -  %  %  %  r  r  r  r  r  r  r  r  r  r  r  r  r  r   r = replace
    13 |  -  -  %  %  %  r  r  r  r  r  r  r  r  r  r  r  r  r  r   % = string %
    14 |  -  %  %  %  %  r  r  r  r  r  r  r  r  r  r  r  r  r  r   - = do nothing
    15 |  -  %  %  %  %  r  r  r  r  r  r  r  r  r  r  r  r  r  r  
  (length)
</code></pre>
<p>For example, if the string <code>lambda x,y:</code> (length 11) occurs 3 times in your code, you're better off writing <code>exec&quot;...&quot;%(('lambda x,y:',)*3)</code>.</p>
</div>
<div id="pu22" class="pu"><p>Conditionals can be lengthy. In some cases, you can replace a simple conditional with <code>(a,b)[condition]</code>. If <code>condition</code> is true, then <code>b</code> is returned.</p>
<p>Compare</p>
<pre class="lang-python prettyprint-override"><code>if a&lt;b:return a
else:return b
</code></pre>
<p>To this</p>
<pre class="lang-python prettyprint-override"><code>return(b,a)[a&lt;b]
</code></pre>
</div>
<div id="pu23" class="pu"><p>Use <code>`n`</code> to convert an integer to a string instead of using <code>str(n)</code>:</p>
<pre class="lang-python prettyprint-override"><code>&gt;&gt;&gt; n=123
&gt;&gt;&gt; `n`
'123'
</code></pre>
<p>Note: Only works in Python 2.</p>
</div>
<div id="pu24" class="pu"><p>List comprehension.</p>
<pre class="lang-python prettyprint-override"><code>shortList = []
for x in range(10):
    shortList += [x * 2]
</code></pre>
<p>can be shortened into</p>
<pre class="lang-python prettyprint-override"><code>shortList = [x*2 for x in range(10)]
</code></pre>
<p>Or even shorter:</p>
<pre class="lang-python prettyprint-override"><code>shortList = range(0,20,2)
</code></pre>
</div>
<div id="pu25" class="pu"><h2>Use the walrus operator <code>:=</code> in list comprehension to store the previous value of the iterable</h2>
<p>Instead of the convoluted</p>
<pre><code>f=[s[i]for i in range(len(s))if s[i-1]!=s[i]]
</code></pre>
<p>You can use</p>
<pre><code>e=&quot;&quot;
f=[c for c in s if e!=(e:=c)]
</code></pre>
<p>Which saves 11 bytes in this example. Care needs to be taken that <code>e</code> is reassigned after being evaluted. It also needs to be initialised before the list, which is quite easy to do with default function arguments</p>
</div>
<div id="pu26" class="pu"><p>When you want to compare 2 booleans to see if they are different, it's preferable to use <code>^</code> (XOR) rather than <code>!=</code> (it can save one byte)</p>
<p>Example with:
<code>a: bool</code> and <code>b: bool</code></p>
<pre class="lang-py prettyprint-override"><code>if a!=b: # 8 bytes
</code></pre>
<pre class="lang-py prettyprint-override"><code>if a^b: # 7 bytes
</code></pre>
</div>
<div id="pu27" class="pu"><h2>Combine assignments of reused values with unused for-loop variables</h2>
<p>If you need to loop a number of times but you don't care about the iteration variable, you can co-opt the loop to assign a variable.</p>
<pre class="lang-python prettyprint-override"><code>r=reused;for _ in&quot;_&quot;*n:stuff
r=reused;exec(&quot;r;&quot;*n)                          # [note 1]
r=reused;exec&quot;r;&quot;*n                            # [note 1]; Python 2 only
for r in[reused]*n:r

lambda args:((r:=reused)for _ in&quot;_&quot;*n)         # generally needs parentheses
lambda args,r=reused:(r for _ in&quot;_&quot;*n)         # only works with constants
lambda args:(r for r in[reused]*n)
</code></pre>
<p>This is generally a more versatile approach for assignment than the <code>:=</code> operator or using default arguments of functions, because it supports assigning to attributes <code>.x</code>, subscripts <code>[x]</code>, and unpacking with <code>*</code> or <code>,</code>.</p>
<pre class="lang-python prettyprint-override"><code>(stuff+(a[0]:=value)for _ in&quot;_&quot;*n)                   # syntax error
(stuff+a[0]for a[0]in[value]*n)                      # works, and shorter!

(stuff+a+b for*a,b in[value]*n)                      # works!
</code></pre>
<p>The only pitfall is that scope inside comprehensions is sometimes quite confusing, because the body of the comprehension is compiled as a separate implicit function.</p>
<p><a href="https://codegolf.stackexchange.com/a/216302">Taken from @xnor's use of it here</a>.</p>
<p><sup>[note 1]: and longer if backslashes/quotes/newlines/... need to be escaped inside the string</sup></p>
<hr />
<p><em>This is a bot account operated by pxeger. I'm posting this to get enough reputation to use chat.</em></p>
</div>
<div id="pu28" class="pu"><p>From what i learned:</p>
<ol>
<li>Encode your long codes to base64 and use eval to run them: <code>eval(ENCODEFUNC(CODE))</code>. Something like zlib has half the size of b64 but there are even more efficient hash function that you can look up.</li>
<li>Use ternary operators and lambdas.</li>
<li>If the the task you trying to accomplish is a trivial thing then probably there is a builtin function for it somewhere.</li>
<li>Always look for a case for using list comprehensions and generators stuff.</li>
</ol>
</div>
<div id="pu29" class="pu"><p>Do a ternary operator when you can.</p>
<p>Factorial example:</p>
<pre class="lang-python prettyprint-override"><code>def f(x):return 1 if x==1 else x*f(x-1)
</code></pre>
</div>
<div id="pu30" class="pu"><p><code>!=</code> can be replaced with <code>-</code><br />
here is a example</p>
<pre><code>n=int(input())
if n!=69:
 print(&quot;thanks for being mature&quot;)
</code></pre>
<p>instead of using <code>!=</code> you can use <code>-</code><br />
after that it should look like this</p>
<pre><code>n=int(input())
if n-69:
 print(&quot;thanks for being mature&quot;)
</code></pre>
</div>
<div id="pu31" class="pu"><p>To convert a 2D list to a 1D flat list, you can do <code>sum(2d_list,[])</code> instead of the long way of <code>import numpy;list=list.flatten()</code>, which requires to create a <code>numpy.array</code> at the start as well, which is way longer than the first one</p>
</div>
<div id="pu32" class="pu"><h1><code>0in</code> instead of <code>not all</code></h1>
<p>(or, under <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws" rel="noreferrer">DeMorgan's Law</a>, <code>any(not ...)</code>)</p>
<pre class="lang-python prettyprint-override"><code>not all(...)
~-all(...)  # shorter than `not`, and with more forgiving precedence
0in(...)
</code></pre>
<pre class="lang-python prettyprint-override"><code>not all map(f,a)
0in map(f,a)  # the reduction is more significant here because you can omit the parentheses
</code></pre>
<p>This only works if the falsey values in the <code>...</code> sequence are actually <code>False</code> (or <code>0</code>/<code>0.0</code>/etc.) (<strong>not</strong> <code>[]</code>/<code>&quot;&quot;</code>/<code>{}</code> etc.).</p>
<h1><code>1in</code> instead of <code>any</code></h1>
<p>This one isn't shorter with a comprehension:</p>
<pre class="lang-python prettyprint-override"><code>any(f(x)for x in a)
1in(f(x)for x in a)
</code></pre>
<p>But it sometimes saves bytes with other kinds of expression by letting you omit the parentheses:</p>
<pre class="lang-python prettyprint-override"><code>any(map(f,a))
1in map(f,a)
</code></pre>
<p>This has a similar truthiness-related caveat to the above, though.</p>
<hr />
<h1>Notes</h1>
<p>These might sometimes have less favourable precedence, because they use the <code>in</code> operator. However, if you're combining this with a comparison you may be able to make additional use of <a href="https://codegolf.stackexchange.com/a/60" title="wow, answer ID 60">this tip</a> about comparison condition chaining.</p>
<p>You can also use these if you want the entire <code>for</code>-comprehension in <code>any</code>/<code>all</code> to always be fully evaluated:</p>
<pre class="lang-python prettyprint-override"><code>any([... for x in a])
1in[... for x in a]
</code></pre>
<hr />
<p>This one's rare, but if you need to evaluate and discard an extra expression for every item in a comprehension, you could use a dictionary here at no extra cost:</p>
<pre class="lang-python prettyprint-override"><code>1in[(condition,side_effect)[0]for x in a]
1in{condition:side_effect for x in a}
</code></pre>
<p>because <code>dict</code>'s <code>in</code> checks only the keys.</p>
</div>
<div id="pu33" class="pu"><h1>Access static methods on instances</h1>
<p>If you're accessing a static method or class method, for example <code>int.from_bytes</code> or <code>dict.fromkeys</code>, you can also still access them on instances of that class - it doesn't have to be on the class itself. It's very often shorter to do this:</p>
<pre><code>int.from_bytes(...
0 .from_bytes(...

dict.fromkeys(...
{}.fromkeys(...
</code></pre>
<p>Often you already have an instance of that class stored in a one-letter variable, so it can be even shorter:</p>
<pre><code>x.from_bytes
</code></pre>
<p>It doesn't matter what value <code>x</code> is, and it isn't changed.</p>
</div>
<div id="pu34" class="pu"><h1>The shortest infinite for comprehension</h1>
<p>You may know the trick to easily create an infinite generator using the two-argument form of <code>iter</code>:</p>
<pre><code>(... for _ in iter(lambda:0,1))
</code></pre>
<p>where <code>0</code> and <code>1</code> can be any two non-equal values.</p>
<p>As <a href="https://codegolf.stackexchange.com/questions/236762/write-an-infinitely-nested-generator-comprehension/236763#comment537666_236763">@ovs once pointed out to me</a>, you can replace <code>lambda:0</code> with <code>int</code>, because <code>int</code> returns 0 when called with no arguments.</p>
<pre><code>(... for _ in iter(int,1))
</code></pre>
<p>However, we can do one byte better!:</p>
<pre><code>(... for()in iter(set,1))
</code></pre>
<p>This uses the fact that <code>()</code> is a valid L-value (assignment target) in Python as long as the RHS is an empty sequence, and <code>set</code> returns an empty set when called with no arguments.</p>
<p>You can also use <code>str</code> instead of <code>set</code> for the same byte count.</p>
</div>
<div id="pu35" class="pu"><h2>List all substrings</h2>

<p>You can generate the nonempty contiguous substrings of a string <code>s</code> with a recursive function (Python 3 for <code>[*s]</code>).</p>
<p><strong>40 bytes</strong> <a href="https://tio.run/##K6gsycjPM/7/P802JzE3KSVRodgqWqs4NjEvJbo4VjtNozja0CpWE8yw0jWM1fxfbKuUmJScosRVUJSZV6IBlNDU/A8A" rel="nofollow noreferrer" title="Python 3 – Try It Online">(TIO)</a></p>

<pre class="lang-python prettyprint-override"><code>f=lambda s:[*s]and[s]+f(s[1:])+f(s[:-1])
</code></pre>
<p>This will repeat substrings multiple times even if each substring appears once. You can making this a set to remove duplicates. This won't run if <code>s</code> is a list instead of a string, but a tuple will work.</p>
<p><strong>40 bytes</strong> <a href="https://tio.run/##K6gsycjPM/7/P802JzE3KSVRodiqWqu4NjEvpbq4tiZNozja0CpWE8yw0jWM1fxfbKuUmJScosRVUJSZV6IBlNDU/A8A" rel="nofollow noreferrer" title="Python 3 – Try It Online">(TIO)</a></p>

<pre class="lang-python prettyprint-override"><code>f=lambda s:{*s}and{s}|f(s[1:])|f(s[:-1])
</code></pre>
<p>Or, you can do this to make a list where each substring appears one for each time it's present:</p>
<p><strong>46 bytes</strong> <a href="https://tio.run/##K6gsycjPM/7/P802JzE3KSVRoVgnyVbX0Cpaqzg2MS8lujhWO02jONrQKlbHQBPMtEqK1fxfbKuUmJScosRVUJSZV6IBFNfU/A8A" rel="nofollow noreferrer" title="Python 3 – Try It Online">(TIO)</a></p>

<pre class="lang-python prettyprint-override"><code>f=lambda s,b=-1:[*s]and[s]+f(s[1:],0)+f(s[:b])
</code></pre>
<p><em>Thanks for loopy walt for the <code>s[:b]</code> optimization.</em></p>
<p>This can be used to sum over some expression <code>g</code> over all substrings, for instance to count nonempty substrings with some Boolean property <code>g</code>.</p>
<p><strong>48 bytes</strong> <a href="https://tio.run/##PcuxCoAgEADQva84blIqSNoE@5FwOBMrqCs6l77egqDtLe@883JwX0pyG@0hEkgTXGusDIjEEWYluk5KRmN90320wesiDilMEav5nxYJgY8MK4NAdV4rZ/UGrcsD" rel="nofollow noreferrer" title="Python 3 – Try It Online">(TIO)</a></p>

<pre class="lang-python prettyprint-override"><code>f=lambda s,b=-1:s&gt;&quot;&quot;and g(s)+f(s[1:],0)+f(s[:b])
</code></pre>
</div>
<div id="pu36" class="pu"><h2>Special characters in string literals</h2>
<p>When you write a quoted literal string in your code, perhaps to compress a big blob of data, certain characters must be replaced by a two-character escape sequence.</p>
<p><strong>Null byte <code>\0</code> (ASCII 0)</strong></p>
<p>The null byte can't be present verbatim in Python code. Write it as <code>\0</code>.</p>
<p><strong>Newline <code>\n</code> (ASCII 10)</strong></p>
<p>An actual newline <code>\n</code> can't appear in a string literal because the Python lexer will read it and think the line has ended without closing the initial quote. But, a triple-quoted string like <code>'''stuff'''</code> or <code>&quot;&quot;&quot;stuff&quot;&quot;&quot;</code> may contain newlines. This saves bytes with 5+ newlines, which can be useful in ASCII art.</p>
<p><strong>Carriage return <code>\r</code> (ASCII 13)</strong></p>
<p>A carriage return always needs escaping as <code>\r</code>. Though allowed in a triple-quoted string, a literal <code>\r</code> is misread as a newline <code>\n</code>.</p>
<p><strong>Quotes <code>&quot;</code> (ASCII 34) and <code>'</code> (ASCII 39)</strong></p>
<p>A single-quoted string can contain double quotes like <code>'&quot;'</code>, but must escape single-quotes like <code>'\''</code>, and vice-versa for double-quoted strings. Choose whichever option leads to less escaping.</p>
<p>A triple-quoted string is OK with unescaped quotes of the same type like <code>'''it's'''</code>. But, having quotes at the start and end or three-in-a-row can confuse the lexer into giving a SyntaxError.</p>
<p><strong>Backslash <code>\</code> (ASCII 92)</strong></p>
<p>A backslash can be escaped as <code>\\</code>. But, Python allows just writing <code>\</code> if it's followed by a character that can't make it an escape sequence. This is any character not in <code>abfnrtvx0123456789&quot;'\</code> or literal newline <code>\n</code>.</p>
<p>You can use a <code>r</code>-prefixed raw string like <code>r'\n'</code> to ignore most escape sequences, so <code>r'\n'</code> is just a backslash followed by a letter <code>n</code> and <code>r'\\'</code> is two backslashes. Quote characters still get escaped but don't consume the backslash, so <code>r'\''</code> is backslash then single-quote. This can cause complications: <code>r'\'</code>, <code>r'\\\'</code>, and <code>r'\\''</code> all give SyntaxError.</p>
<hr />
<p>For reference, the special characters are ASCII values <code>[0, 10, 13, 39, 34, 92]</code>. When doing compression, you might tweak your method to avoid hitting these values.</p>
<p>Some weird characters can be written verbatim without escaping, such as:</p>
<ul>
<li>bell <code>\a</code> (ASCII 7)</li>
<li>backspace <code>\b</code> (ASCII 8)</li>
<li>tab <code>\t</code> (ASCII 9)</li>
<li>vertical tab (ASCII 11)</li>
<li>form feed <code>\f</code> (ASCII 12)</li>
<li>DEL (ASCII 127)</li>
</ul>
<p>StackExchange posts won't render these, but Python clients and <a href="https://tio.run/#python2" rel="nofollow noreferrer">TIO</a> should handle them fine. <a href="https://tio.run/##TY3RCoJAEEUfq8mPuAwIRfuiPVhCXxKx6LqStKmsEvTUp2@uaThPM4c797Tv/t7UsXO5NkYmGOcCXjHlmXp0baa0PHmyZuqzXJ7xz2yYXtKzKJrIlqls7LPUupBR7EnAARXaDFcyv32YyAzL9acUWIgERofAXCywLBSYum7eA4WqhknR2qruweGxSxkhGlvs1B4HKOe@" rel="nofollow noreferrer">Here they are for copy-pasting.</a></p>
<p>Characters with ASCII codes 128 and up can't be included in Python 2 code without a extra line declaring an encoding <a href="https://tio.run/##K6gsycjPM/r/Xzk1Lzk/JTMv3aq0JI2roCgzr0RB6fAqpf//AQ" rel="nofollow noreferrer">like this</a>. Python 3, though, <a href="https://tio.run/##K6gsycjPM/7/v6AoM69EQ@nwKiVNLij70doJSpr//wMA" rel="nofollow noreferrer">handles them fine</a>, including multibyte Unicode characters.</p>
</div>
<div id="pu37" class="pu"><h2>Trig without imports</h2>
<p>You can compute <code>cos</code> and <code>sin</code> without needing to <code>import math</code> by using complex arithmetic. For an angle of <code>d</code> degrees, its cosine is</p>
<pre><code>(1j**(d/90)).real
</code></pre>
<p>and its sine is</p>
<pre><code>(1j**(d/90)).imag
</code></pre>
<p>Here, <code>1j</code> is how Python writes the imaginary unit <span class="math-container">\$i\$</span>. If your angle is <code>r</code> radians, you'll need to use <code>1j**(r/(pi/2))</code>, using a decimal approximation of <code>pi/2</code> if the challenge allows it.</p>
<p>If you're curious, this all works because of <a href="https://en.wikipedia.org/wiki/Euler%27s_formula" rel="noreferrer">Euler's formula</a>:</p>
<p><span class="math-container">$$i^x = (e^{i \pi /2})^x = e^{i \pi /2 \cdot x} = \cos(\pi/2 \cdot x) + i \sin(\pi /2 \cdot  x)$$</span></p>
</div>
<div id="pu38" class="pu"><h2>Object method as answer</h2>

<p>Your submission can be a method of an object</p>
<pre class="lang-python prettyprint-override"><code>range(123,790,111).count
</code></pre>
<p>This defines an anonymous function much shorter than</p>
<pre class="lang-python prettyprint-override"><code>lambda n:range(123,790,111).count(n)
</code></pre>
<p>The object method is a valid function that meets our definition. For example, it could be bound and called</p>
<pre class="lang-python prettyprint-override"><code>f=range(123,790,111).count
print f(99)
</code></pre>
<p>Because it avoids a costly <code>lambda</code>, this saves characters even rewriting from</p>
<pre class="lang-python prettyprint-override"><code>lambda n:n in range(123,790,111)
</code></pre>
<p>Consider using an object method when your solution is a simple two-input function of your input and some concrete object. You can use <code>dir()</code> to get a list of methods of an object. Note in particular methods like <code>.__add__</code> that are called for an operator like <code>+</code>. Most infix operators correspond to a method.</p>
<p>Other examples:</p>
<pre class="lang-python prettyprint-override"><code>&quot;prefix{}suffix&quot;.format
lambda s:&quot;prefix&quot;+s+&quot;suffix&quot;

2 .__rpow__    #Space for lexer
lambda n:n*n

[0,0].__le__
lambda l:[0,0]&lt;=l
</code></pre>
<p>You can even sometimes save bytes with two input <a href="http://meta.codegolf.stackexchange.com/a/8427/20260">by currying</a>. For example, compare</p>
<pre class="lang-python prettyprint-override"><code>lambda l:expression_in_l.count
lambda n,l:n in expression_in_l
</code></pre>
<p>where <code>expression_in_l</code> produces a list with no duplicates and has favorable spacing and precedence.</p>
</div>
<div id="pu39" class="pu"><h1>Shorten <code>while 1</code></h1>
<p>It is possible to shorten a <code>while 1:</code> by replacing the <code>1</code> with an existing expression inside of the loop body. Common ways to make use of this in Python 3 include embedding</p>
<ul>
<li>a <code>print()</code> statement:</li>
</ul>
<pre class="lang-py prettyprint-override"><code>while 1:print(x);...
# vs
while[print(x)]:...
</code></pre>
<ul>
<li>a chained expression:</li>
</ul>
<pre class="lang-py prettyprint-override"><code>while 1:x&gt;1==print(x);...
# vs
while[x&gt;1==print(x)]:...
</code></pre>
<ul>
<li>a walrus operator (Python 3.8 and above):</li>
</ul>
<pre class="lang-py prettyprint-override"><code>while 1:x=1;...
while x:=1:...
</code></pre>
<p>In general, any expression (one that returns a value), can be used as the <code>while</code> condition to save a byte or two. Often it's necessary to wrap the expression in <code>[]</code> to ensure it maintains a truthy value.</p>
</div>
<div id="pu40" class="pu"><h2>Length tradeoff reference</h2>

<p>I've think it would be useful to have a reference for the character count differences for some common alternative ways of doing things, so that I can know when to use which. I'll use <code>_</code> to indicate an expression or piece of code.</p>
<p><strong>Assign to a variable: +4</strong></p>
<pre class="lang-python prettyprint-override"><code>x=_;x
_
</code></pre>
<p>So, this breaks even if you</p>
<ul>
<li>Use <code>_</code> a second time: <code>_</code> has length 5</li>
<li>Use <code>_</code> a third time: <code>_</code> has length 3</li>
</ul>
<p><strong>Assign variables separately: 0</strong></p>
<pre class="lang-python prettyprint-override"><code>x,y=a,b
x=a;y=b
</code></pre>
<ul>
<li>-2 when <code>a</code> equals <code>b</code> for <code>x=y=a</code></li>
</ul>
<p><strong>Expand <code>lambda</code> to function <code>def</code>: +7</strong></p>
<pre class="lang-python prettyprint-override"><code>lambda x:_
def f(x):return _
</code></pre>
<ul>
<li>-2 for named functions</li>
<li>-1 if <code>_</code> can touch on the left</li>
<li>-1 in Python 2 if can <code>print</code> rather than return</li>
<li>+1 for starred input <code>*x</code></li>
</ul>
<p>Generically, if you're <code>def</code> to save an expression to a variable used twice, this breaks even when the expression is length 12.</p>
<pre class="lang-python prettyprint-override"><code>lambda x:g(123456789012,123456789012)
def f(x):s=123456789012;return g(s,s)
</code></pre>
<p><strong>STDIN rather than function: +1</strong></p>
<pre class="lang-python prettyprint-override"><code>def f(x):_;print s
x=input();_;print s
</code></pre>
<ul>
<li>-1 for line of code needed in <code>_</code> if not single-line</li>
<li>+4 if <code>raw_input</code> needed in Python 2</li>
<li>-4 if input variable used only once</li>
<li>+1 if function must <code>return</code> rather than <code>print</code> in Python 2</li>
</ul>
<p><strong>Use <code>exec</code> rather than looping over <code>range(n)</code>: +0</strong></p>
<pre class="lang-python prettyprint-override"><code>for i in range(n):_
i=0;exec&quot;_;i+=1;&quot;*n
</code></pre>
<ul>
<li>+2 for Python 3 <code>exec()</code></li>
<li>-4 if shifted range <code>range(c,c+n)</code> for single-char <code>c</code></li>
<li>-5 when going backwards from <code>n</code> to <code>1</code> via <code>range(n,0,-1)</code></li>
<li>-9 if index variable never used</li>
</ul>
<p><strong>Apply <code>map</code> manually in a loop: +0</strong></p>
<pre class="lang-python prettyprint-override"><code>for x in l:y=f(x);_
for y in map(f,l):_
</code></pre>
<p><strong>Apply <code>map</code> manually in a list comprehension: +8</strong></p>
<pre class="lang-python prettyprint-override"><code>map(f,l)
[f(x)for x in l]
</code></pre>
<ul>
<li>-12 when <code>f</code> must be written in the <code>map</code> as the <code>lambda</code> expression <code>lambda x:f(x)</code>, causing overall 4 char loss.</li>
</ul>
<p><strong>Apply <code>filter</code> manually in a list comprehension: +11</strong></p>
<pre class="lang-python prettyprint-override"><code>filter(f,l)
[x for x in l if f(x)]
</code></pre>
<ul>
<li>-1 if <code>f(x)</code> expression can touch on the left</li>
<li>-12 when <code>f</code> must be written in the <code>filter</code> as the <code>lambda</code> expression <code>lambda x:f(x)</code>, causing overall 1 char loss.</li>
</ul>
<p><em><em>Import</em> versus import single-use: +4</em>*</p>
<pre class="lang-python prettyprint-override"><code>import _;_.f
from _ import*;f
</code></pre>
<ul>
<li>Breaks even when <code>_</code> has length 5</li>
<li><code>import _ as x;x.f</code> is always worse except for multiple imports</li>
<li><code>__import__('_').f</code> is also worse</li>
</ul>
<p>Thanks to @Sp3000 for lots of suggestions and fixes.</p>
</div>
<div id="pu41" class="pu"><h1>Long function names</h1>
<p>Here's a trick to shorten long function names. The basic idea is to fetch the name by using <code>dir()</code>. This would return the name as a string, so we must follow it with an <code>eval</code> to make it usable. Below is an exaggerated example from the <code>itertools</code> module:</p>
<pre class="lang-py prettyprint-override"><code>from itertools import*

combinations_with_replacement('ABC',2)
eval(dir()[7])('ABC',2)
</code></pre>
<p>In the minimal case, if the function name is 15 bytes or longer, there's a <em>chance</em> that it can still save bytes. This is assuming, that the name can be accessed by <code>dir</code> with a single-digit index:</p>
<pre class="lang-py prettyprint-override"><code>???????????????()
eval(dir()[?])()
</code></pre>
</div>
<div id="pu42" class="pu"><p>Use <code>a=b=c=0</code> instead of <code>a,b,c=0,0,0</code>. (Note that this uses the same instance for each variable, so don't do this with objects like lists if you intend to mutate them independently)</p>
<p>Use <code>a,b,c='123'</code> instead of <code>a,b,c='1','2','3'</code>.</p>
</div>
<div id="pu43" class="pu"><h1 id="dict.get-as-a-first-class-function-2w99"><code>dict.get</code> as a first-class function</h1>

<pre class="lang-py prettyprint-override"><code># all keys in the dict G with a truthy value
[k for k in G if G[k]]
filter(G.get,G)

# all keys in the dict G with a falsy value
[k for k in G if not G[k]]
G.keys()-filter(G.get,G)
</code></pre>
<h1 id="d-or-ab-to-merge-dicts-in-python-4je0"><code>{…,**d}</code> or <code>a|b</code> to merge <code>dict</code>s in Python</h1>
<pre class="lang-py prettyprint-override"><code># merge two dicts
a={…}
b={…}
# Python &lt;3.9
merged={**a,**b} # the order lets you decide which overrides which
# Python ≥3.9
merged=a|b

# set a defaut value
G.setdefault(a,1)
G[a]=G.get(a,1)
# Python &lt;3.9
G={a:1,**G} 
# Python ≥3.9
G={a:1}|G
</code></pre>
<h1 id="extract-elements-from-a-list-using-f24z">Extract elements from a list using <code>::</code></h1>
<pre class="lang-py prettyprint-override"><code># This is a very specific tip when you want to get both an element at
# the near beginning of a list and one somewhere near the end.
# For example, let's assume you want to take the elements at indices i=6 and j=37
# from a list L of length l=40 (it works only if i+j*2&lt;l)

# ok
a=L[5];b=L[36]
# equivalent
a,b=L[5],L[36]
# 36 = 5 + 31
a,b=L[5::31]
</code></pre>
<h1 id="set-literals-qzd8">Set literals</h1>
<p><code>set()</code> is 5 chars just to create an empty set. If you can have an initial element <code>e</code>, you can save 2 chars with <code>{e}</code>.</p>
<h1 id="generators-instead-of-comprehension-lists-in-function-calls-fy12">Generators instead of comprehension lists in function calls</h1>
<pre class="lang-py prettyprint-override"><code># assuming the function iterates on its argument
f([x**2 for x in range(4)])
f(x**2 for x in range(4))
</code></pre>
</div>
<div id="pu44" class="pu"><h1>Arithmetic tricks</h1>
<p>Here are some arithmetic tricks which are either shorter or are more useful due to precedence rules.</p>
<pre><code>Assumptions                  Version 1        Version 2
-------------------------------------------------------------------
n &gt;= 0 float                 n==0             0**n
n &gt;= 0 integer               n==0             1&gt;&gt;n
n &gt;  0 integer               n!=1             1%n
n &gt;  0 integer, Python 2     n==1             1/n
n, m float                   n!=m             n-m
</code></pre>
</div>
<div id="pu45" class="pu"><p><strong>Checking if a boolean value is false and an integer is a specific odd integer</strong></p>
<p><code>~True</code> is <code>~1</code> is <code>-2</code> and <code>~False</code> is <code>~0</code> is <code>-1</code></p>
<p><code>-1&amp;int</code> is always <code>int</code></p>
<p><code>-2&amp;int</code> is always even</p>
<p>Therefore, despite operator order, <code>~bool&amp;int==odd_int</code> works fine.</p>
<p>It's shorter than all of these equivalents:</p>
<p><code>not bool and int==odd_int</code></p>
<p><code>-~bool and int==odd_int</code></p>
<p><code>-~bool&amp;int==odd_int</code></p>
</div>
<div id="pu46" class="pu"><p>When you want to use <code>map</code> with list then cast it to list, use <code>*</code> instead of <code>list(...)</code>.</p>
<pre class="lang-python prettyprint-override"><code>new_a=list(map(f,a))
new_a=[*map(f,a)]     # -3 char
</code></pre>
<p>Moreover, you also can convert some iterable things to list with saving 3 characters:</p>
<pre class="lang-python prettyprint-override"><code>a=list(&quot;abc&quot;)
a=[*&quot;abc&quot;]
b=list(range(x,y))
b=[*range(x,y)]
</code></pre>
</div>
<div id="pu47" class="pu"><h2>Logical short-circuiting in recursive functions</h2>
<p><strong>A detailed guide</strong></p>

<p>I had worked with short-circuiting <code>and/or</code>'s for a while without really grasping how they work, just using <code>b and x or y</code> just as a template. I hope this detailed explanation will help you understand them and use them more flexibly.</p>
<hr />
<p>Recursive named <code>lambda</code> functions are <a href="https://codegolf.stackexchange.com/a/61526/20260">often shorter</a> than programs that loop. For evaluation to terminate, there must be control flow to prevent a recursive call for the base case. Python has a <a href="https://stackoverflow.com/questions/394809/does-python-have-a-ternary-conditional-operator">ternary condition operator</a> that fits the bill.</p>
<pre class="lang-python prettyprint-override"><code>f=lambda x:base_value if is_base_case else recursive_value
</code></pre>
<p>Note that <a href="https://codegolf.stackexchange.com/a/62/20260">list selection</a> won't work because Python evaluates both options. Also, regular <code>if _:</code> isn't an option because we're in a <code>lambda</code>.</p>
<hr />
<p>Python has another option to short-circuit, the logical operator keywords <code>and</code> and <code>or</code>. The idea is that</p>
<pre class="lang-python prettyprint-override"><code>True or b == True
False and b == False
</code></pre>
<p>so Python can skip evaluate <code>b</code> in these cases because the result is known. Think of the evaluation of <code>a or b</code> as &quot;Evaluate <code>a</code>. If it's True, output <code>a</code>. Otherwise, evaluate and output <code>b</code>.&quot; So, it's equivalent to write</p>
<pre class="lang-python prettyprint-override"><code>a or b
a if a else b
</code></pre>
<p>It's the same for <code>a or b</code> except we stop if <code>a</code> is False.</p>
<pre class="lang-python prettyprint-override"><code>a and b
a if (not a) else b
</code></pre>
<p>You might wonder why we didn't just write <code>False if (not a) else b</code>. The reason is that this works for non-Boolean <code>a</code>. Such values are <a href="https://docs.python.org/2.4/lib/truth.html" rel="nofollow noreferrer">first converted to a Boolean</a>. The number <code>0</code>, <code>None</code>, and the empty list/tuple/set become <code>False</code>, and are so called &quot;Falsey&quot;. The rest are &quot;Truthy&quot;.</p>
<p>So, <code>a or b</code> and <code>a and b</code> always manages to produce either <code>a</code> or <code>b</code>, while forming a correct Boolean equation.</p>
<pre class="lang-python prettyprint-override"><code>(0 or 0) == 0
(0 or 3) == 3
(2 or 0) == 2
(2 or 3) == 2
(0 and 0) == 0
(0 and 3) == 0
(2 and 0) == 0
(2 and 3) == 3
('' or 3) == 3
([] and [1]) == []
([0] or [1]) == [0]
</code></pre>
<hr />
<p>Now that we understand Boolean short-circuiting, let's use it in recursive functions.</p>
<pre class="lang-python prettyprint-override"><code>f=lambda x:base_value if is_base_case else recursive_value
</code></pre>
<p>The simplest and most common situation is when the base is something like <code>f(&quot;&quot;) = &quot;&quot;</code>, sending a Falsey value to itself. Here, it suffices to do <code>x and</code> with the argument.</p>
<p>For example, this function doubles each character in a string, <code>f(&quot;abc&quot;) == &quot;aabbcc&quot;</code>.</p>
<pre class="lang-python prettyprint-override"><code>f=lambda s:s and s[0]*2+f(s[1:])
</code></pre>
<p>Or, this recursively sums the cubes of numbers <code>1 through n</code>, so <code>f(3)==36</code>.</p>
<pre class="lang-python prettyprint-override"><code>f=lambda n:n and n**3+f(n-1)
</code></pre>
<p>Another common situation is for your function to take non-negative numbers to lists, with a base case of <code>0</code> giving the empty list. We need to transform the number to a list while preserving Truthiness. One way is <code>n*[5]</code>, where the list can be anything nonempty. This seems silly, but it works.</p>
<p>So, the following returns the list <code>[1..n]</code>.</p>
<pre class="lang-python prettyprint-override"><code>f=lambda n:n*[5]and f(n-1)+[n]  
</code></pre>
<p>Note that negative <code>n</code> will also give the empty list, which works here, but not always. For strings, it's similar with any non-empty string. If you've previously defined such a value, you can save chars by using it.</p>
<p>More generally, when your base value is an empty list, you can use the arithmetic values <code>True == 1</code> and <code>False == 0 </code> to do:</p>
<pre class="lang-python prettyprint-override"><code>[5]*(is_not_base_case)and ...
</code></pre>
<p>TODO: Truthy base value</p>
<hr />
<p>TODO: <code>and/or</code></p>
</div>
<div id="pu48" class="pu"><p>Sometimes your Python code requires you to have 2 levels of indentation. The obvious thing to do is use one and two spaces for each indentation level.</p>
<p>However, Python 2 considers the tab and space characters to be different indenting levels.</p>
<p>This means the first indentation level can be one space and the second can be one tab character.</p>
<p>For example:</p>
<pre><code>if 1:
 if 1:
&#9pass</code></pre>
</div>
<div id="pu49" class="pu"><h2>Use map for side effects</h2>
<p>Usually you use <code>map</code> to transform a collection</p>
<pre class="lang-python prettyprint-override"><code>&gt;&gt; map(ord,&quot;abc&quot;)
[97, 98, 99]
</code></pre>
<p>But you can also use it to repeatedly act on object by a built-in method that modifies it.</p>
<pre class="lang-python prettyprint-override"><code>&gt;&gt; L=[1,2,3,4,5]
&gt;&gt; map(L.remove,[4,2])
[None, None]
&gt;&gt; L
[1, 3, 5]
</code></pre>
<p>Be aware that the calls are done in order, so earlier ones might mess up later ones.</p>
<pre class="lang-python prettyprint-override"><code>&gt;&gt; L=[1,2,3,4,5]
&gt;&gt; map(L.pop,[0,1])
[1, 3]
&gt;&gt; L
[2, 4, 5]
</code></pre>
<p>Here, we intended to extract the first two elements of <code>L</code>, but after extracting the first, the next second element is the original third one. We could sort the indices in descending order to avoid this.</p>
<p>An advantage of the evaluation-as-action is that it can be done inside of a <code>lambda</code>. Be careful in Python 3 though, where <code>map</code> objects are not evaluated immediately. You might need an expression like <code>[*map(...)]</code> or <code>*map(...),</code> to force evaluation.</p>
</div>
<div id="pu50" class="pu"><h1>Printing the elements of a list, with spaces</h1>
<p><a href="/questions/tagged/python-3.x" class="post-tag" title="show questions tagged &#39;python-3.x&#39;" rel="tag">python-3.x</a></p>
<p>Suppose we have to print a list as a string <em>with spaces</em>, like square of numbers upto <code>10</code>. Then,</p>
<p><a href="https://tio.run/##K6gsycjPM7YoKPr/v6AoM69EQ11BXS8rPzNPo7ikSCNTS8tIMy2/SCFTITNPoSgxLz1Vw9BQU1Pz/38A" rel="nofollow noreferrer" title="Python 3.8 (pre-release) – Try It Online">Instead of</a>,</p>

<pre class="lang-python prettyprint-override"><code>print(' '.join(str(i**2)for i in range(11))) # 44 chars
</code></pre>
<p><a href="https://tio.run/##K6gsycjPM7YoKPr/v6AoM69EQ0sjU0vLKC2/SCFTITNPoSgxLz1Vw9BQU1Pz/38A" rel="nofollow noreferrer" title="Python 3.8 (pre-release) – Try It Online">We can do</a>,</p>
<pre class="lang-python prettyprint-override"><code>print(*(i**2for i in range(11))) # 32 chars
</code></pre>
</div>
<div id="pu51" class="pu"><h2>Abuse <code>==</code> short circuiting</h2>
<p>If you have:</p>
<ul>
<li>A function with a side effect (such as <code>print</code>);</li>
<li>That you only want to run if some condition is (or is not) met.</li>
</ul>
<p>Then you might be able to use <code>==</code> over <code>or </code> to save a byte.</p>
<p>Here's printing all numbers <code>n</code> under 100 that have <code>f(n)</code> less than 2:</p>
<pre class="lang-python prettyprint-override"><code># Naive
for n in range(100):f(n)&lt;2and print(n)
# Invert condition
for n in range(100):f(n)&gt;1or print(n)
# Use ==
for n in range(100):f(n)&lt;2==print(n)
</code></pre>
</div>
<div id="pu52" class="pu"><p>To set lots of variables to the same thing use:</p>

<pre><code># x is a list of the names of the variables you want and y is
# the value you want all of them to have
exec(("%s="*len(x))%tuple(x)+str(y))
</code></pre>
</div>
<div id="pu53" class="pu"><h1>Using <code>exec</code> to remove repeated  <code>print</code></h1>



<p>This is not quite often applicable, but can save some bytes, especially in ASCII art. Take the following code, which prints the flag where <code>n=4</code>.</p>

<pre class="lang-python prettyprint-override"><code># 43 bytes                  |  ***
n=input()                   |  **
while~-n:n-=1;print'*'*n    |  *
print'|'                    |  |
</code></pre>

<p>Notice that we repeat <code>print</code> twice. We can remove this using <code>exec</code> in the following code, saving 3 bytes.</p>

<pre class="lang-python prettyprint-override"><code># 40 bytes
n=input()
exec"'*'*n;n-=1;print"*n+"'|'"
</code></pre>
</div>
<div id="pu54" class="pu"><h2>Iterate over adjacent pairs</h2>



<p>It's common to want to iterate over adjacent pairs of items in a list or string, i.e. </p>

<pre class="lang-python prettyprint-override"><code>"golf" -&gt; [('g','o'), ('o','l'), ('l','f')]
</code></pre>

<p>There's a few methods, and which is shortest depends on specifics.</p>

<p><strong>Shift and zip</strong></p>

<pre class="lang-python prettyprint-override"><code>## 47 bytes
l=input()
for x,y in zip(l,l[1:]):do_stuff(x,y)
</code></pre>

<p>Create a list of adjacent pairs, by removing the first element and zipping the original with the result. This is most useful in a list comprehension like </p>

<pre class="lang-python prettyprint-override"><code>sum(abs(x-y)for x,y in zip(l,l[1:]))
</code></pre>

<p>You can also use <code>map</code> with a two-input function, though note that the original list is no longer truncated.</p>

<pre class="lang-python prettyprint-override"><code>## Python 2
map(cmp,l[:-1],l[1:])
</code></pre>

<p><strong>Keep the previous</strong></p>

<pre class="lang-python prettyprint-override"><code>## 41 bytes, Python 3
x,*l=input()
for y in l:do_stuff(x,y);x=y
</code></pre>

<p>Iterate over the elements of the list, remembering the element from a previous loop. This works best with Python 3's ability to unpack to input into the initial and remaining elements. </p>

<p>If there's an initial value of <code>x</code> that serves as a null operation in <code>do_stuff(x,y)</code>, you can iterate over the whole list.</p>

<pre class="lang-python prettyprint-override"><code>## 39 bytes
x=''
for y in input():do_stuff(x,y);x=y
</code></pre>

<p><strong>Truncate from the front</strong></p>

<pre class="lang-python prettyprint-override"><code>## 46 bytes
l=input()
while l[1:]:do_stuff(*l[:2]);l=l[1:]
</code></pre>

<p>Keep shortening the list and act on the first two elements. This works best when your operation is better-expressed on a length-two list or string than on two values. </p>

<hr>

<p>I've written these all as loops, but they also lend to a recursive functions. You can also adjust to get cyclic pairs by putting the first element at the end of the list, or as the initial previous-value.</p>

<hr>

<p>The Python 3.8 "walrus" <a href="https://codegolf.stackexchange.com/a/180041/20260">assignment expressions</a> allow a short expression to give pairs, though with an extra initial element.</p>

<pre class="lang-python prettyprint-override"><code>&gt;&gt;&gt; p=''
&gt;&gt;&gt; [(p,p:=c)for c in"golf"]
[('', 'g'), ('g', 'o'), ('o', 'l'), ('l', 'f')]
</code></pre>
</div>
<div id="pu55" class="pu"><h2>Math built-ins in 3.8</h2>



<p>In addition to the famous <a href="https://codegolf.stackexchange.com/a/180041/20260">walrus operator</a>, Python 3.8 introduces useful new math features.</p>

<p><strong>Modular inverse</strong></p>

<p>The modular-power built-in <a href="https://docs.python.org/3/library/functions.html#pow" rel="noreferrer"><code>pow(base, exp, mod)</code></a> can now compute the modular inverse using <code>exp=-1</code>. This requires that <code>base</code> and <code>mod</code> are relatively prime integers.</p>

<pre class="lang-python prettyprint-override"><code>&gt;&gt;&gt; pow(38, -1, 97)
23
&gt;&gt;&gt; 23 * 38 % 97 == 1
True
</code></pre>

<p><code>exp</code> may be any negative integer, which lets you compute modular powers of the modular inverse.</p>

<hr>

<p>The <a href="https://docs.python.org/3/library/math.html" rel="noreferrer">math</a> library has useful new functions for combinatorics and distances. Access them with <code>import math</code>. Or, write <code>from math import*</code> to import them without the <code>math.</code>, which is worth it if you write more than one call.</p>

<p><strong>Combinatorics</strong></p>

<ul>
<li><a href="https://docs.python.org/3/library/math.html#math.comb" rel="noreferrer"><code>math.comb(n,k)</code></a>: The binomial coefficient <code>n choose k</code>, which equals <code>n! / (k! * (n - k)!)</code>.</li>
<li><a href="https://docs.python.org/3/library/math.html#math.perm" rel="noreferrer"><code>math.perm(n,k)</code></a>: The number of ordered choices of <code>k</code> elements from <code>n</code>, which is <code>n! / (n - k)!</code>. Calling just <code>math.perm(n)</code> gives <code>n!</code>, useful as a synonym for <code>math.factorial(n)</code>.</li>
<li><a href="https://docs.python.org/3/library/math.html#math.prod" rel="noreferrer"><code>math.prod(l)</code></a>: The product of the elements of a list or iterable <code>l</code>, analogous to <code>sum</code>.</li>
</ul>

<p><strong>Distances and square roots</strong></p>

<ul>
<li><a href="https://docs.python.org/3/library/math.html#math.dist" rel="noreferrer"><code>math.dist(p,q)</code></a>: The Euclidean distance between two points <code>p</code> and <code>q</code>. The inputs <code>p</code> and <code>q</code> must be lists or iterables that are the same length.</li>
<li><a href="https://docs.python.org/3/library/math.html#math.hypot" rel="noreferrer"><code>math.hypot(*p)</code></a>: The Euclidean distance from a point <code>p</code> to zero. Now takes any number of arguments; before it took only two. For some reason, arguments still must be splatted like <code>math.hypot(1,2,3)</code> rather than <code>math.hypot([1,2,3])</code>.</li>
<li><a href="https://docs.python.org/3/library/math.html#math.isqrt" rel="noreferrer"><code>math.isqrt(n)</code></a>: The integer square root, that is the floor of the square root of <code>n</code>. Requires than <code>n</code> is a non-negative integer. Usually <code>n**.5//1</code> suffices instead, but this gives exact integer output rather than a float.</li>
</ul>
</div>
<div id="pu56" class="pu"><h1>Assignment expressions</h1>



<p><a href="https://www.python.org/dev/peps/pep-0572/" rel="noreferrer">Assignment expressions</a> are a powerful language feature introduced in <a href="https://www.python.org/downloads/release/python-380a1/" rel="noreferrer">Python 3.8</a> (<a href="https://tio.run/#python38pr" rel="noreferrer">TIO</a>). Use the "walrus operator" <code>:=</code> to assign a variable inline as part of expression.</p>

<pre class="lang-python prettyprint-override"><code>&gt;&gt;&gt; (n:=2, n+1)
(2, 3)
</code></pre>

<p>You can save an expression to a variable inside a <code>lambda</code>, where assignments are not ordinarily allowed. Compare:</p>

<pre class="lang-python prettyprint-override"><code>def f(s):t=s.strip();return t+t[::-1]
lambda s:s.strip()+s.strip()[::-1]
lambda s:(t:=s.strip())+t[::-1]
</code></pre>

<p>An assignment expression can be used in a comprehension to iteratively update a value, storing the result after each step in a list or other collection. This example computes a running sum by updating the running total <code>t</code>.</p>

<pre class="lang-python prettyprint-override"><code>&gt;&gt;&gt; t=0
&gt;&gt;&gt; l=[1,2,3]
&gt;&gt;&gt; print([t:=t+x for x in l])
[1, 3, 6]
&gt;&gt;&gt; t
6
</code></pre>

<p>This can be done in a <code>lambda</code> with the initial value as an optional argument:</p>

<pre class="lang-python prettyprint-override"><code>&gt;&gt;&gt; f=lambda l,t=0:[t:=t+x for x in l]
&gt;&gt;&gt; f([1,2,3])
[1, 3, 6]
</code></pre>

<p>This function is reusable: each call with start <code>t</code> back at 0.</p>
</div>
<div id="pu57" class="pu"><p><strong>Note: The below makes sense only in the program is scored as characters, not as bytes.</strong></p>

<p>I haven't seen this, though somebody may have posted it somewhere. </p>

<p>I needed to have some long literal ASCII strings in the code so somehow shortening them (as characters, not bytes) would be beneficial. After some experiments I came up with what I call the "Chinese reencoding". I call it that way because ASCII characters mostly seem to be squashed in unicode code points that represent Chinese characters. You take an ASCII string S, encode it in bytes as ASCII, and then decode it in UTF16-BE, like that:</p>

<pre><code>E=S.encode().decode('utf16-be')
</code></pre>

<p>The resulting string is half the length. It has to be big endian, as the reverse reencoding may not work - and on most systems the shorter 'utf16' is little endian. You also may need to add a character like space if the original string has odd length, but many times this is OK. Also, for non ASCII characters this does not save length, because they result in too big unicode code points that are represented in the liong form ("\uXXXX")</p>

<p>In you code, use the following:</p>

<pre><code>[E].encode('utf16-be').decode()
</code></pre>

<p>in order to get the original longer string, where [E] is the literal shortened string. This costs 29 additional characters, so the original string has to be longer than 58, obviously.</p>

<p>One example - below is my 12 days of Christmas (it can be shortened additionally, but let's use that as an example):</p>

<pre><code>for i in range(12):print('On the %s day of Christmas\nMy true love sent to me\n%s'%('First Second Third Fourth Fifth Sixth Seventh Eighth Ninth Tenth Eleventh Twelfth'.split()[i],'\n'.join('Twelve Drummers Drumming,+Eleven Pipers Piping,+Ten Lords-a-Leaping,+Nine Ladies Dancing,+Eight Maids-a-Milking,+Seven Swans-a-Swimming,+Six Geese-a-Laying,+Five Gold Rings,+Four Calling Birds,+Three French Hens,+Two Turtle Doves, and+A Partridge in a Pear Tree.\n'.split('+')[11-i:])))
</code></pre>

<p>It's 477 characters long. Let's apply the "Chinese" trick to the two longer string:</p>

<pre><code>r=lambda s:s.encode('utf-16be').decode();for i in range(12):print('On the %s day of Christmas\nMy true love sent to me\n%s'%(r('䙩牳琠卥捯湤⁔桩牤⁆潵牴栠䙩晴栠卩硴栠卥癥湴栠䕩杨瑨⁎楮瑨⁔敮瑨⁅汥癥湴栠呷敬晴栠').split()[i],'\n'.join(r('呷敬癥⁄牵浭敲猠䑲畭浩湧Ⱛ䕬敶敮⁐楰敲猠偩灩湧Ⱛ呥渠䱯牤猭愭䱥慰楮本⭎楮攠䱡摩敳⁄慮捩湧Ⱛ䕩杨琠䵡楤猭愭䵩汫楮本⭓敶敮⁓睡湳ⵡⵓ睩浭楮本⭓楸⁇敥獥ⵡⵌ慹楮本⭆楶攠䝯汤⁒楮杳Ⱛ䙯畲⁃慬汩湧⁂楲摳Ⱛ周牥攠䙲敮捨⁈敮猬⭔睯⁔畲瑬攠䑯癥猬\u2061湤⭁⁐慲瑲楤来\u2069渠愠健慲⁔牥攮ਠ').split('+')[11-i:])))
</code></pre>

<p>That's 362, including the lambda (it happens to be worth it, as it is used twice).</p>

<p>Now, all code is mostly ASCII characters, so you may have already guessed that you can use that with exec. There is higher overhead - 43 chars for "exec(''.encode('utf-16be').decode())" (in addition to the whole compressed program) and you may need to double escape some escaped characters in your literal strings (like '\n' in mine has to become '\n'). As a bonus you can always easily add that one space. The compressed porogram looks like:</p>

<pre><code>exec("景爠椠楮\u2072慮来⠱㈩㩰物湴⠧佮⁴桥‥猠摡礠潦⁃桲楳瑭慳屮䵹⁴牵攠汯癥\u2073敮琠瑯\u206d敜渥猧┨❆楲獴⁓散潮搠周楲搠䙯畲瑨⁆楦瑨⁓楸瑨⁓敶敮瑨⁅楧桴栠乩湴栠呥湴栠䕬敶敮瑨⁔睥汦瑨✮獰汩琨⥛楝Ⱗ屮✮橯楮⠧呷敬癥⁄牵浭敲猠䑲畭浩湧Ⱛ䕬敶敮⁐楰敲猠偩灩湧Ⱛ呥渠䱯牤猭愭䱥慰楮本⭎楮攠䱡摩敳⁄慮捩湧Ⱛ䕩杨琠䵡楤猭愭䵩汫楮本⭓敶敮⁓睡湳ⵡⵓ睩浭楮本⭓楸⁇敥獥ⵡⵌ慹楮本⭆楶攠䝯汤⁒楮杳Ⱛ䙯畲⁃慬汩湧⁂楲摳Ⱛ周牥攠䙲敮捨⁈敮猬⭔睯⁔畲瑬攠䑯癥猬\u2061湤⭁⁐慲瑲楤来\u2069渠愠健慲⁔牥攮屮✮獰汩琨✫✩嬱ㄭ椺崩⤩".encode('utf-16be').decode())
</code></pre>

<p>and it's 299 characters long. You can see some high code points can always appear. I have not found a way to eliminate them, as the added handling code is not worth the benefit.</p>

<p>This is a cheap trick, in fact, but it can always be applied on top of your solution when the program is longish and there are no or few non-ASCII characters. Often you can devise a custom encoding that can stuff more than two ASCII chars in an unicode one, but it is specific for the task.</p>
</div>
<div id="pu58" class="pu"><h2>Recursive functions that print</h2>

<p>Functions <a href="https://codegolf.meta.stackexchange.com/a/2457/20260">are allowed to print as programs do</a>. A recursive function that prints can be shorter than both a pure function and a pure program.</p>

<p>Compare these Python 2 submissions to make a list of iteratively floor-halving a number while it's positive, like <code>10 -&gt; [10, 5, 2, 1]</code>.</p>



<pre class="lang-python prettyprint-override"><code># 30 bytes: Program 
n=input()
while n:print n;n/=2

# 29 bytes: Function
f=lambda n:n*[0]and[n]+f(n/2)

# 27 bytes: Function that prints
def g(n):1/n;print n;g(n/2)
</code></pre>

<p><a href="https://tio.run/##NYvJCsMgGAbv/1N41PTgcjT4JCEHi0uE5KsUS@nT2yzkNsMw9deWF0zvcAX107ig71LWyGDru6AxjJDOECW3@u0Z/B4wTGr2CBPmR@KQRhCFmFjmEFZLjPeZz9gvTVwrQRfng7tWfw" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>

<p>The function that prints uses <code>1/n</code> to terminate with error on hitting <code>n=0</code> after having printing the desired numbers. This saves characters over the program's <code>while</code> and the pure function's base case, giving it the edge in byte count. Often, the termination can be shorter as part of the expression to print or the recursive call. It might even happen on its own for free, like terminating on an empty string when the first character is read.</p>

<p>The key property of our function here is that we're repeatedly applying an operation and listing the results at each step, in order. Additional variables can still be used this way by having them as optional inputs to the function that are passed in the recursive call. Moreover, because we're <code>def</code>'ing a function rather than writing a <code>lambda</code>, we can put statements such as variable assignments in its body.</p>
</div>
<div id="pu59" class="pu"><h2>Replace <code>not</code> with <code>1-</code></h2>

<p>In python, the negation operator <code>not</code> wastes bytes, so we have to find a shorter way. Negation can be implemented as subtraction from 1 (obtained from my Keg experiece), which saves 1 byte. (Also, <code>True</code> and <code>False</code> can be alternatively represented as <code>1</code> and <code>0</code> internally, so this will not matter much.)</p>

<p>Compare <a href="https://codegolf.stackexchange.com/questions/190892/bot-problem-how-to-solve-this-problem#190892">this program</a>:</p>

<pre><code>lambda s:not(s[0]+s[-1]).isdigit()
</code></pre>

<p>With this program:</p>

<pre><code>lambda s:1-(s[0]+s[-1]).isdigit()
</code></pre>

<p>Some straightforward tricks that might help:</p>

<pre><code>and -&gt; *
or -&gt; +
</code></pre>
</div>
<div id="pu60" class="pu"><p>I discovered a clever trick used <a href="https://codegolf.stackexchange.com/questions/189695/generate-brainfuck-for-the-numbers-1-255">here</a>.</p>

<p>Instead of using the for loop to repeat multiple times, repeat exec multiple times.</p>

<pre><code>p='+'
i=1
exec"print[p*i,i/9*p+'[&gt;'+p*9+'&lt;-]&gt;'+i%9*p][i&gt;20];i+=1;"*255
</code></pre>

<p>Compare this with</p>

<pre><code>print"\n".join("&gt;"+"+"*(i/16)+"[&lt;"+"+"*16+"&gt;-]&lt;"+"+"*(i%16)if i&gt;31 else"+"*i for i in range(256))
</code></pre>
</div>
<div id="pu61" class="pu"><h1>Shortening <code>a%b==a</code> if <code>b</code> has a constant sign</h1>

<p>For two expressions <code>a</code> and <code>b</code>, where each one results in an <code>int</code> (or <code>long</code> in Python 2) or <code>float</code>, you can replace these:</p>

<pre><code>a%b==a
</code></pre>

<p>&#9;</p>

<pre><code>a==a%b
</code></pre>

<p>with these, if <code>b</code> is positive:</p>

<pre><code>0&lt;=a&lt;b
</code></pre>

<p>&#9;</p>

<pre><code>b&gt;a&gt;=0
</code></pre>

<p>or these, if <code>b</code> is negative:</p>

<pre><code>b&lt;a&lt;=0
</code></pre>

<p>&#9;</p>

<pre><code>0&gt;=a&gt;b
</code></pre>

<p>I'm presenting two expressions for each case because sometimes you may want to use one over the other to eliminate a space to separate expression <code>b</code> from an adjacent token. They both have the same precedence, so you're not usually going to need to surround the second expression with <code>()</code> if you don't need to do so to the first one.</p>

<p>This is useful if expression <code>a</code> is more than 1 byte long or <code>b</code> is negative, because it removes one occurrence of <code>a</code> from the expression. If <span class="math-container">\$a,b\$</span> are the lengths of expressions <code>a</code> and <code>b</code> respectively, and <span class="math-container">\$l\$</span> is the length of the original expression, the resulting expression will be <span class="math-container">\$l-a+1\$</span> bytes long. Note that this method is always going to be shorter than assigning expression <code>a</code> to a separate variable.</p>

<h2>Example</h2>

<p>For example,</p>

<pre><code>(a+b)%c==a+b
</code></pre>

<p>can be replaced with</p>

<pre><code>0&lt;=a+b&lt;c
</code></pre>

<p>for a total saving of 4 bytes.</p>

<h2>Proof</h2>

<p>Let's define the operator <span class="math-container">\$x\mathbin\%y\$</span> for <span class="math-container">\$x,y\in\mathbb Q\$</span>.</p>

<p><a href="https://en.wikipedia.org/wiki/Euclidean_division" rel="nofollow noreferrer">Every rational number <span class="math-container">\$a\$</span> can be represented as <span class="math-container">\$a=bq+r\$</span>, where <span class="math-container">\$q\in\mathbb Z,0\le r&lt;|b|\$</span></a>. Therefore, we can define an operator <span class="math-container">\$a\mathbin\%b\$</span>, where the result has the same sign as <span class="math-container">\$b\$</span>:</p>

<p><span class="math-container">$$a=bq+r,q\in\mathbb Z,0\le r&lt;|b|\\a\mathbin\%b=\begin{cases}\begin{align}r\quad b&gt;0\\-r\quad b&lt;0\end{align}\end{cases}$$</span></p>

<p>This represents the <code>%</code> operator in Python, which calculates the remainder of the division of two numbers. <code>a % b</code> is the same as <code>abs(a) % b</code>, and the result has the same sign as the divisor, <code>b</code>. For the <span class="math-container">\$a\mathbin\%b\$</span> operator, this equality holds:</p>

<p><span class="math-container">$$(a\pm b)\mathbin\%b=a\mathbin\%b$$</span></p>

<p>Proof:</p>

<p><span class="math-container">$$a=bq+r\leftrightarrow a\pm b=bq+r\pm b=(bq\pm b)+r=b(q\pm1)+r$$</span></p>

<p>Moreover, for <span class="math-container">\$b&gt;0\$</span>, we have:</p>

<p><span class="math-container">$$a\mathbin\%b=a\leftrightarrow r=a\leftrightarrow0\le a&lt;b$$</span></p>

<p>Proof for <span class="math-container">\$r=a\leftarrow0\le a&lt;b\$</span>:</p>

<p><span class="math-container">$$0\le a&lt;b\leftrightarrow0\le bq+r&lt;b\leftrightarrow bq=0\leftrightarrow a=r$$</span></p>

<p>Similarly, for <span class="math-container">\$b&lt;0\$</span>, we have <span class="math-container">\$b&lt;a\le0\$</span>.</p>

<p>Therefore, <span class="math-container">\$a\mathbin\%b=a\leftrightarrow\begin{cases}\begin{align}0\le a&lt;b\quad b&gt;0\\b&lt;a\le0\quad b&lt;0\end{align}\end{cases}\$</span>, or, equivalently, <span class="math-container">\$(0\le a&lt;b)\lor(b&lt;a\le0)\$</span>.</p>
</div>
<div id="pu62" class="pu"><h2>Split into chunks</h2>

<p>You can split a list into chunks of a given size using <code>zip</code> and <code>iter</code>, as explained in <a href="https://stackoverflow.com/q/2233204">this SO question</a>.</p>



<pre class="lang-python prettyprint-override"><code>&gt;&gt;&gt; l=range(12)
&gt;&gt;&gt; zip(*[iter(l)]*4)
[(0, 1, 2, 3), (4, 5, 6, 7), (8, 9, 10, 11)]
</code></pre>

<p>Of course, substituting in <code>l</code> as <code>zip(*[iter(range(12))]*4)</code> gives the same result.</p>

<p>The <code>4</code> is the number of elements per chunk. If the length isn't a multiple of this, any elements in the remainder are not included. For example, <code>l=range(13)</code> would give the same result.</p>

<p>The result is a list of tuples. If your input is a string and you want to produce a list of strings, you can do </p>

<pre class="lang-python prettyprint-override"><code>&gt;&gt;&gt; l="Code_golf"
&gt;&gt;&gt; map(''.join,zip(*[iter(l)]*3)) 
['Cod', 'e_g', 'olf'] # Python 3 would give a map object
</code></pre>

<p>When the list <code>l</code> is defined by a list comprehension, instead of converting to an iterable as <code>iter(l)</code>, you can instead write it as a generator comprehension with <code>(...)</code> instead of <code>[...]</code>.</p>

<pre class="lang-python prettyprint-override"><code>&gt;&gt;&gt; l=(n for n in range(18)if n%3!=1)
&gt;&gt;&gt; zip(*[l]*4)
[(0, 2, 3, 5), (6, 8, 9, 11), (12, 14, 15, 17)]
</code></pre>

<p>This consumes the generator, so <code>l</code> will appear empty afterwards. Note as before that we can inline <code>l</code> as <code>zip(*[(n for n in range(18)if n%3!=1)]*4)</code>.</p>
</div>
<div id="pu63" class="pu"><ol>
<li><p><code>from lib import func as F</code></p></li>
<li><p><code>from lib import*;F=func</code></p></li>
<li><p><code>import lib;F=lib.func</code></p></li>
</ol>

<p>#2 is better than #1 except in rare cases where something in lib clobbers another name that's important to you.</p>

<p>#3 uses <code>lib</code> twice, winning with short library names.</p>
</div>
<div id="pu64" class="pu"><p>In Python,</p>



<pre class="lang-python prettyprint-override"><code>True == 1   # true
False == 0  # true
</code></pre>

<p>So,</p>

<pre class="lang-python prettyprint-override"><code>(a&lt;b)*2-1
</code></pre>

<p>returns 1 if b is larger than a. If not, returns -1.</p>

<p>More golfing,</p>

<pre class="lang-python prettyprint-override"><code>-(a&gt;b)|1
</code></pre>

<p>returns exactly same value as mentioned above.</p>

<p>Useful when modify iterator index by comparable values.</p>
</div>
<div id="pu65" class="pu"><h3>Unpacking in Python3</h3>

<p>If you only need the first few values in the array</p>

<pre><code>&gt;&gt;&gt; a, b, *c = [1, 2, 3, 4, 5]
&gt;&gt;&gt; a
1
&gt;&gt;&gt; b
2
&gt;&gt;&gt; c
[3, 4, 5]
</code></pre>

<p>Same applies to when you need last few values</p>

<pre><code>&gt;&gt;&gt; *a, b, c = [1, 2, 3, 4, 5]
&gt;&gt;&gt; a
[1, 2, 3]
&gt;&gt;&gt; b
4
&gt;&gt;&gt; c
5
</code></pre>

<p>Or even with the first few and last few</p>

<pre><code>&gt;&gt;&gt; a, *b, c = [1, 2, 3, 4, 5]
&gt;&gt;&gt; a
1
&gt;&gt;&gt; b
[2, 3, 4]
&gt;&gt;&gt; c
5
</code></pre>
</div>
<div id="pu66" class="pu"><h1>Slicing tricks for hard-wired lists of strings</h1>
<p><em>Warning: Python is the language which worships readability above all else; so coding this way is a Mortal Sin.</em></p>
<p>This sort of thing comes up a lot; such as <a href="https://codegolf.stackexchange.com/a/171080/69880">here</a> where for a given digit in <code>0&lt;=d&lt;=9</code>, we can get the 7-bit segment <code>b</code> value as a hex string from the list</p>
<pre><code>b=['7e','30','6d','79','33','5b','5f','70','7f','7b'][d]
</code></pre>
<p>If the length of such a list is more than just a few elements, you're usually better off at least using <code>split</code> because you can replace a bunch of <code>&quot;','&quot;</code>s with a single character <code>&quot; &quot;</code> as delimiter. E.g.:</p>
<pre><code>b='7e 30 6d 79 33 5b 5f 70 7f 7b'.split()[d]
</code></pre>
<p>This can be used for almost any list of strings (possibly at a small additional cost using a delimiter such as <code>&quot;,&quot;</code>).</p>
<p>But if in addition, the strings we are selecting for all have the same length <code>k</code> (<code>k==2</code> in our example), then with the magic of Python slicing, we can write the above as:</p>
<pre><code>b='7e306d79335b5f707f7b'[2*d:][:2]
</code></pre>
<p>which saves a lot of bytes because we don't need character delimiters at all. But in that case, usually even shorter would be:</p>
<pre><code>b='7367355777e0d93bf0fb'[d::10]
</code></pre>
</div>
<div id="pu67" class="pu"><h1>Formatting a Matrix</h1>

<p>I've seen this code to get a character matrix (2D array) as a string.</p>

<pre><code>'\n'.join(''.join(i)for i in M)
</code></pre>

<p>It's shorter to use a <code>map</code> instead:</p>

<pre><code>'\n'.join(map(''.join,M))
</code></pre>

<p>If you're printing the result, it's shortest to use a <code>for</code> loop:</p>

<pre><code>print('\n'.join(map(''.join,M)))
for i in M:print(*i,sep='')      # -5 bytes
</code></pre>

<p>If you're using Python 2, you can't use the <code>print</code> trick, but you can still use the <code>for</code> loop:</p>

<pre><code>for i in M:print(''.join(i))     # -3 bytes
</code></pre>
</div>
<div id="pu68" class="pu"><h2>Binomial coefficient</h2>

<p>The binomial coefficient \$\binom{n}{k} \ = \frac{n!}{k!(n-k)!}\$ can be expressed arithmetically as</p>

<pre><code>((2**n+1)**n&gt;&gt;n*k)%2**n
</code></pre>

<p><a href="https://tio.run/##K6gsycjPM/r/P802JzE3KSVRIU8n20pDw0hLK0/bUBNI2tnlaWVrqoIE/qflFynkKWTmKRQl5qWnahgaaFpxKYAEsxGCIG1WBUWZeSUKaRpAwzR1uBTA3P8A" rel="noreferrer" title="Python 2 – Try It Online">Try it online!</a> </p>

<p>This works for \$n,k \geq 0\$, except for \$n=k=0\$ it gives \$0\$ rather than \$1\$. More generally, it works to use</p>

<pre><code>(b+1)**n/b**k%b
</code></pre>

<p><a href="https://tio.run/##RYxBCoAgEADvvmIvgZpQdlPoMS5libWKdOn1Zl06zsBMvq890VQrzsYY5ufDnbg4IBUtx14LKWlAKWOH1acCBIGgONpWrkdhGbwy/pJaYnMJdIHnbSIUgw/rAw" rel="noreferrer" title="Python 2 – Try It Online">(TIO)</a>, where \$b\$ is any value strictly greater than the result. The first expression uses \$b=2^n\$, which exceeds \$\binom{n}{k}\$ except for \$n=k=0\$.</p>

<hr>

<p>Why does this work? Let's look at an example with <code>b=1000</code>. Then, for <code>n=6</code>, we have</p>

<pre><code>(b+1)**n = 1001 ** 6 = 1006015020015006001
</code></pre>

<p>Note how triples of digits encode the binomial coefficients in the <code>n=6</code> row of Pascal's triangle:</p>

<pre><code>1   6  15  20  15   6   1
1 006 015 020 015 006 001
</code></pre>

<p>This works because the binomial coefficients are the coefficients of the polynomial</p>

<p>$$ (b+1)^n = \sum_{k=0}^n\binom{n}{k}b^k$$</p>

<p>and so can be read off as digits in base <code>b</code>, as long no binomial coefficient exceeds <code>b</code> which would cause regrouping.</p>

<p>We can extract a given triple of digits, say for \$\binom{6}{2}=15\$, by floor-dividing by <code>1000000</code> to delete the last 6 digits leaving <code>1006015020015</code>, then take <code>%1000</code> to extract the last triplet <code>015</code>. More generally, doing <code>/b**k%b</code> extracts the <code>k</code>-th digit from the end zero-indexed in base <code>b</code>, that is the digit with multiplier <code>b**k</code>.</p>
</div>
<div id="pu69" class="pu"><h1>Shorter way to copy/clone a list</h1>

<p>(not deep clone. For deep clone see <a href="https://codegolf.stackexchange.com/a/51022/69850">this answer</a>)</p>

<p>(credit to <a href="https://codegolf.stackexchange.com/a/137890/69850">this answer</a>)</p>

<pre><code>a=x[:]
b=[*x]
c=x*1
</code></pre>

<p><a href="https://tio.run/##K6gsycjPM/5fYRttqGOkYxz7P9G2ItoqlivJNlqrIpYr2bZCy/B/SmqOAli0oCgzr0SjQidRJ0knWfM/AA" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
</div>
<div id="pu70" class="pu"><p>To assign to a tuple, don't use parentheses. For example, <code>a=1,2,3</code> assigns <code>a</code> to the tuple <code>(1, 2, 3)</code>. <code>b=7,</code> assigns <code>b</code> to the tuple <code>(7,)</code>. This works in both Python 2 and Python 3.</p>
</div>
<div id="pu71" class="pu"><p>Large hard coded numbers can be represented in larger bases, but there is a trade off. Higher bases only become worthwhile after a certain cutoff.</p>

<p>The only three bases you're likely to need to worry about are <code>10</code>, <code>16</code>, and <code>36</code>. These are the cutoffs:</p>

<pre><code>1000000000000 (13 bytes)                            -&gt; 0xe8d4a51000 (12 bytes)
0x10000000000000000000000000000000000000 (40 bytes) -&gt; int("9gmd8o3gbbaz3m2ydgtgwn9qo6xog",36) (39 bytes)
</code></pre>
</div>
<div id="pu72" class="pu"><p><strong>Choosing one of two numbers based on a condition</strong></p>

<p>You <a href="https://codegolf.stackexchange.com/a/62/20260">already know</a> to use the list selection <code>[x,y][b]</code> with a Boolean <code>b</code> for the ternary expression <code>y if b else x</code>. The variables <code>x</code>, <code>y</code>, and <code>b</code> can also be expressions, though note that both <code>x</code> and <code>y</code> are evaluated even when not selected.</p>

<p>Here's some potential optimizations when <code>x</code> and <code>y</code> are numbers.</p>

<ul>
<li><code>[0,y][b] -&gt; y*b</code> </li>
<li><code>[1,y][b] -&gt; y**b</code> </li>
<li><code>[x,1][b] -&gt; b or x</code></li>
<li><code>[x,x+1][b] -&gt; x+b</code></li>
<li><code>[x,x-1][b] -&gt; x-b</code></li>
<li><code>[1,-1][b] -&gt; 1|-b</code></li>
<li><code>[x,~x][b] -&gt; x^-b</code></li>
<li><code>[x,y][b] -&gt; x+z*b</code> (or <code>y-z*b</code>), where z=y-x.</li>
</ul>

<p>You can also switch <code>x</code> and <code>y</code> if you can rewrite <code>b</code> to be its negation instead.</p>
</div>
<div id="pu73" class="pu"><h1>Negating Booleans</h1>

<p>So you have a Boolean... a real Boolean, not one <a href="https://codegolf.stackexchange.com/a/18983/13959">represented as an integer</a>. You have a condition where it needs to be negated, and you can't just go back and negate it where you got it (e.g. <code>!=</code> instead of <code>==</code>), maybe because you use it once straight and once negated.</p>

<p>Well, who says your Booleans aren't longing to be integers deep in their little hearts?</p>

<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; False &lt; 1
True
&gt;&gt;&gt; True &lt; 1
False
</code></pre>

<p>8 bytes, not counting the colon:</p>

<pre class="lang-py prettyprint-override"><code>if not C:
</code></pre>

<p>6 bytes:</p>

<pre class="lang-py prettyprint-override"><code>if C&lt;1:
</code></pre>

<p><strong>EDIT:</strong> 5 bytes, thanks to user202729 in the comments:</p>

<pre class="lang-py prettyprint-override"><code>if~-C:
</code></pre>

<p>This works because:</p>

<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; -False
0
&gt;&gt;&gt; -True
-1
&gt;&gt;&gt; ~-False
-1
&gt;&gt;&gt; ~-True
0
</code></pre>
</div>
<div id="pu74" class="pu"><h1>Use Splat (<code>*</code>) to pass a bunch of single character strings into a function</h1>

<p>For example:</p>

<pre><code>a.replace("a","b")
a.replace(*"ab")    -2 bytes

some_function("a","b","c")
some_function(*"abc")       -5 bytes
</code></pre>

<p>In fact, if you have <code>n</code> single-character strings, you will save <code>3(n - 1) - 1</code> or <code>3n - 4</code> bytes by doing this (because each time, you remove the <code>","</code> for each one and add a constant <code>*</code>).</p>
</div>
<div id="pu75" class="pu"><h2>Difference of two parallel expressions</h2>



<p>Say you have a challenge to find the difference of some characteristic on two inputs. Your solution has the form <code>lambda a,b:e(b)-e(a)</code>, where <code>e</code> is some long expression you've written. Repeating <code>e</code> twice is wasteful, so what do you do?</p>

<p>Here are templates sorted by length. Assume that <code>e</code> stands for a long expression, not one that's already defined as a function. Also assume inputs can be taken in either order. </p>

<p><a href="https://tio.run/##K6gsycjPM/qfapuTmJuUkqhQYVWhVcGVZhvzHyKglWOVWpaYo6GeqqFarKmrrmWkmqOtbqCu@b@gKDOvRCFNw0THWPM/AA" rel="noreferrer" title="Python 2 – Try It Online"><strong>31 bytes*</strong></a></p>



<pre class="lang-python prettyprint-override"><code>lambda*l:eval('e(%s)-'*2%l+'0')
</code></pre>

<p>*Requires that <code>e</code> only mentions its variable once. Assumes <code>-e(x)</code> negates the whole expression, otherwise requires parens like <code>-(e(x))</code> for two more bytes.</p>

<p><a href="https://tio.run/##K6gsycjPM/qfapuTmJuUkqhQYVWhVfE/DcZN1NFKskrVSNTU1Uiy09BMzEtRSNPQStLU/F9QlJlXAuSY6Bhr/gcA" rel="noreferrer" title="Python 2 – Try It Online"><strong>34 bytes</strong></a></p>



<pre class="lang-python prettyprint-override"><code>f=lambda a,*b:e(a)-(b&gt;()and f(*b))
</code></pre>

<p><a href="https://tio.run/##K6gsycjPM/qfapuTmJuUkqhQYVWhVcGVZhvzHyqQqJNklaKRpKmbopGoyZWCUJeqUaH5v6AoM69EIU3DWMdE8z8A" rel="noreferrer" title="Python 2 – Try It Online"><strong>36 bytes</strong></a></p>



<pre class="lang-python prettyprint-override"><code>lambda a,b:d(b)-d(a)
d=lambda x:e(x)
</code></pre>

<p><a href="https://tio.run/##K6gsycjPM/qfapuTmJuUkqhQYVWhVfE/USfJNjpVo0IzLb9IoUIhMw@ICkpLNDRjuQqKMvNKFJJ0E///N9YxAQA" rel="noreferrer" title="Python 2 – Try It Online"><strong>36 bytes</strong></a></p>



<pre class="lang-python prettyprint-override"><code>a,b=[e(x)for x in input()]
print b-a
</code></pre>

<p><a href="https://tio.run/##K6gsycjPM/qfapuTmJuUkqhQYVWhVfG/yNaAKy2/SKFCITMPiApKSzQ0rYpsUzUqNHWLuAqKMvNKFIr@/zfWMQEA" rel="noreferrer" title="Python 2 – Try It Online"><strong>37 bytes</strong></a></p>



<pre class="lang-python prettyprint-override"><code>r=0
for x in input():r=e(x)-r
print r
</code></pre>

<p><a href="https://tio.run/##K6gsycjPM/qfapuTmJuUkqhQYVWhVcGVZhvzHyKglWOVmVeiFx9fXJoUH6@hFZ2qUaGZll@kUKGQmaeQE6v5v6AIqEAhTcNEx1jzPwA" rel="noreferrer" title="Python 2 – Try It Online"><strong>39 bytes</strong></a></p>



<pre class="lang-python prettyprint-override"><code>lambda*l:int.__sub__(*[e(x)for x in l])
</code></pre>
</div>
<div id="pu76" class="pu"><h1>Fuse list comprehensions</h1>
<p>You can write</p>
<pre><code>[f(x)for x in l]+[g(x)for x in l]
</code></pre>
<p>As</p>
<pre><code>sum([[f(x),g(x)]for x in l],[])
</code></pre>
<p>It gets even better with more comprehensions or if you have to take out more values</p>
<p>If you need to expand a list you can even turn <code>l+[f(x)for x in l]+[g(x)for x in l]</code> into <code>sum([[f(x),g(x)]for x in l],l)</code></p>
</div>
<div id="pu77" class="pu"><h1>Common helper functions</h1>

<p>These are some golfed implementations of number theoretic functions that come up in challenges a lot. Many of these are due to xnor, especially the “Wilson’s theorem prime machines” of the form <code>lambda n,i=1,p=1</code>. The coprime/totient functions are Dennis’s <a href="https://codegolf.stackexchange.com/a/104681/3852">(explanation here)</a>.</p>

<p>It is instructive to study what exactly these are doing, so that you can adapt them to your needs or roll them into another recursive function. That often ends up being shorter than pasting these directly into your solution as-is!</p>

<p>All of these assume <code>n</code> is a positive integer. The ones marked with an asterisk produce the wrong result if <code>n = 1</code>. Furthermore, these snippets assume Python 2. For Python 3, you might need to replace <code>/</code> by <code>//</code> here and there.</p>



<pre class="lang-python prettyprint-override"><code># Function                                                   Output of f(360)
#========================================================================================
f=lambda n,i=2:n/i*[0]and[f(n,i+1),[i]+f(n/i)][n%i&lt;1]      # [2, 2, 2, 3, 3, 5] (slow!)
f=lambda n,i=2:n/i*[0]and f(n,i+1)if n%i else[i]+f(n/i)    # [2, 2, 2, 3, 3, 5]
f=lambda n,i=2:n/i*[0]and(n%i and f(n,i+1)or[i]+f(n/i))    # [2, 2, 2, 3, 3, 5]
f=lambda n,i=2:n&lt;2and{1}or n%i and f(n,i+1)or{i}|f(n/i)    # {1, 2, 3, 5}
f=lambda n,i=2:n&lt;2and{i}or n%i and f(n,i+1)or{i}|f(n/i,i)  #*{2, 3, 5}
f=lambda n,i=2:n/i and[f(n,i+1),i+f(n/i)][n%i&lt;1]           # 2+2+2+3+3+5 (slow!)
f=lambda n,i=2:n/i and f(n,i+1)if n%i else i+f(n/i)        # 2+2+2+3+3+5
f=lambda n,i=2:n/i and(n%i and f(n,i+1)or i+f(n/i))        # 2+2+2+3+3+5
f=lambda n,i=1,p=1:n*[0]and p%i*[i]+f(n-p%i,i+1,p*i*i)     # first n primes
f=lambda n,i=1,p=1:n*[0]and p%i*[i]+f(n-1,i+1,p*i*i)       # primes &lt;= n
f=lambda n,i=1,p=1:n/i and p%i*i+f(n,i+1,p*i*i)            # sum of primes &lt;= n
f=lambda n,i=1,p=1:n/i and p%i+f(n,i+1,p*i*i)              # count primes &lt;= n
f=lambda n,i=1,p=1:n and-~f(n-p%i,i+1,p*i*i)               # nth prime
f=lambda n:all(n%m for m in range(2,n))                    #*is n prime? (not recursive)
f=lambda n:1&gt;&gt;n or n*f(n-1)                                # factorial
f=lambda n:sum(k/n*k%n&gt;n-2for k in range(n*n))             # totient phi(n) (not recursive)
f=lambda n:[k/n for k in range(n*n)if k/n*k%n==1]          # coprimes up to n (not recursive)
</code></pre>

<p><a href="https://tio.run/##tdXBkppAEAbgu0/RkbJ2BnEVLHMgYm655gFYDsSF2CU0FDMk2TLm1U2P4kqpqDkEsEos/ab9e2Yo3/SqIG@HeVlUGtSb6vHrWSW6SpZ1pbCgDHPUYjrhQ/bSmpYKAuj3@y87C77wrebvwL8fX2td1hqKFFIx/ci0Ffyno5cGWZx/e42BHAw8n8Zoh5MoptcwFfzR0JVOiNGQb8Yoo5AGOHejQ5UWhJ4Dh2u6v2YRCJUVPz/IbheOLqbAGiSZSk4jdLndnjBI2y2qE/e4N/fY2LjbooJLcIPb3@36Nu4Rm207JLwjOcay7E0nM97/9NQFvNqDphHe0JxTPmc3OgAd8QO20r8AO6Arub87j0CuUwauT8dZUQ64oYe@jfi9EZ3SRrspyoIUK6WBoKwwT9TDlnsuGetgwDwAugo1URln/5cujQZSdW5W6ePeDc14y6ImfZcz2OhPR1JtjvTqgLUYP84y7l0OKTcsBySoYvqeCM8hKa9tRpaN6pj7ZxBUaGj2vx9Je5b57mJBYGa9vQ9e3tvluKfxUhcVxlmb4UzFekz2ekALGnmmzPWpTLLPy7RAFxoTk9sKBclbJYYMwxWRF0MzZBC0l5bpSNONuuRxOIczfce7fc@ImRH3j4BnnqgVlkI@qzLjx8PTCz3J0PMjH5JfyRKyTyZMrjcV3kTu/gI" rel="noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>

<p>Additions and byte saves are very welcome!</p>
</div>
<div id="pu78" class="pu"><h1>Checking the length of a list</h1>
<pre><code>Empty      : `a==[]` but just checking if it's non empty and swapping the if and the else can be shorter 
Non-Empty  : `a` (assuming it is in a situation where it will be interpreted as a boolean)
len(a)&gt;i   : `a&gt;a[:i]` if the list is non-empty
</code></pre>
</div>
<div id="pu79" class="pu"><p>Multiple statements can be put on one line separated by <code>;</code>. This can save a lot of whitespace from indentation.</p>

<pre><code>while foo(a):
 print a;a*=2
</code></pre>

<p>Or even better:</p>

<pre><code>while foo(a):print a;a*=2
</code></pre>
</div>
<div id="pu80" class="pu"><p>If you want to know the type of a variable x:</p>

<pre><code>x*0is 0  # -&gt; integer
x*0==0   # -&gt; float (if the previous check fails)
x*0==""  # -&gt; string
x*0==[]  # -&gt; array
</code></pre>
</div>
<div id="pu81" class="pu"><p>Use powers of the imaginary unit to calculate sines and cosines.</p>

<p>For example, given an angle <code>d</code> in degrees, you can calculate the sine and cosine as follows:</p>



<pre class="lang-python prettyprint-override"><code>p=1j**(d/90.)
s=p.real
c=p.imag
</code></pre>

<p>This can also be used for related functions such as the side length of a unit <code>n</code>-gon:</p>

<pre class="lang-python prettyprint-override"><code>l=abs(1-1j**(4./n))
</code></pre>
</div>
<div id="pu82" class="pu"><p>If transforming from list to a tuple or set to a set, list or tuple is needed, as of Python 3.5 you can use the splat operator:</p>

<pre><code>tuple(iterable) -&gt; (*iterable,)  (-3 bytes)
set(iterable)   -&gt; {*iterable}   (-2 bytes)
list(iterable)  -&gt; [*iterable]   (-3 bytes)
</code></pre>

<p>If you're doing this as well as appending/prepending, you can do the following for an extra bonus:</p>

<pre><code>iterable+[1]       -&gt; *iterable,1          (-2 bytes, 3 for tuples)
iterable+iter2     -&gt; *iterable,*iterable2 (+1 byte, 0 for tuples, though can combine types)
[1]+iterable+[1]   -&gt; 1,*iterable,1        (-3 bytes, -4 for tuples)
iterable+[1]+iter2 -&gt; *iterable,1,*iter2   (0 bytes, -1 for tuples)
</code></pre>

<p>Basically, <code>,*</code> instead of <code>,</code> gives a +1 byte penalty and <code>,</code> instead of <code>,[]</code> gives -2 bytes.</p>

<p>This shows <code>[1,*iterable,1]</code> is a golfier way of doing <code>[1]+iterable+[1]</code> by one byte, even when we're not doing any type conversion.</p>

<p>And just for fun, <code>{*{}}</code> is the same length as <code>set()</code> for challenges without letters.</p>
</div>
<div id="pu83" class="pu"><p>Pathlib from shorter files manipulations:</p>

<pre><code># get current dir, go up one dir, go down one dir, list all "py" files
# and get the whole file bytes

import os.path as p
import glob

d = p.join(p.dirname(p.abspath(__file__))), 'foo', '*.py')
for x in glob.glob(d):
    with open(x, 'rb') as f:
        do_stuff(f)
</code></pre>

<p>Becomes:</p>

<pre><code>import pathlib as p

d = p.Path(__file__).absolute().parent / 'foo'
for f in d.glob('*.py'):
    do_stuff(f.read_bytes())
</code></pre>
</div>
<div id="pu84" class="pu"><p>Tricks with dicts:</p>

<pre><code># create a dict from iterable
d = {k: None for k in iterable}
# merge 2 dicts
d.merge(d1)
d.merge(d2)
# access a key, if it doesn't exist set a default value and return it
if 'foo' not in d:
    res = d['foo'] = 'bar'
    res = 'bar
else:
    res = d['foo']
</code></pre>

<p>Becomes:</p>

<pre><code>d = {**dict.fromkeys(iterable), **d1, **d2}
res = d.setdefault('foo', 'bar')
</code></pre>

<p>Or if you need repeated access:</p>

<pre><code>import collections as c
d = c.ChainMap(dict.fromkeys(iterable), d1, d2, {'foo': 'bar'})
res = d['foo']
</code></pre>
</div>
<div id="pu85" class="pu"><p>Slicing can assign:</p>

<p>Converting BGR pixels array to RGB:</p>

<pre><code>l = len(pixels)
for idx in range(0, l - 2, 3):
    pixels[idx + 2], pixels[idx] = pixels[idx], pixels[idx + 2]
</code></pre>

<p>Becomes:</p>

<pre><code>l = len(pixels)
pixels[2:l:3], pixels[0:l:3] = pixels[0:l:3], pixels[2:l:3]
</code></pre>

<p>It's not just shorter. It's 5 times faster. Except on pypy, where the first version is 2x times faster :)</p>
</div>
<div id="pu86" class="pu"><p>Format() works on dates:</p>

<pre><code>"We are in year: %s" % (date.strftime('%y'))
</code></pre>

<p>Becomes:</p>

<pre><code>"We are in year: {:%y}".format(date)
</code></pre>

<p>Or even better with f-strings:</p>

<pre><code>f"We are in year: {date:%y}"
</code></pre>
</div>
<div id="pu87" class="pu"><h1>Rename <strong>everything</strong></h1>

<p>Here's a little Python 2 snippet that takes a module and a string, and renames every function in that module whose name is longer than 2 characters to a single character with the provided string prefixed. If you're writing a VERY LONG python program that uses many library or builtin functions (and if you manage to golf this snippet better than I have), it has the potential to save quite a few characters. On short programs or programs that use few functions, it will be useless. Since dir() sorts the names in a module, this will always provide the same names to the same functions, and you can use globals() to inspect which names it has given to which functions.</p>

<pre><code>import string
def _(x,y):
 for c,f in zip(string.letters,[x.__dict__[q]for q in dir(x)if q in x.__dict__ and(len(q)&gt;2)*type(x.__dict__[q]).__name__.find('eth')&gt;0]):globals()[y+c]=f
</code></pre>

<p>You can use it to rename all the string and builtin functions like so:</p>

<pre><code>_(str,'s')
_(__builtins__,'')
</code></pre>

<p>And then see what you actually ended up naming them like so:</p>

<pre><code>for k in sorted(globals().keys(),key=lambda x:`len(x)`+x):print k,globals()[k]
</code></pre>

<p>If you only want to rename the builtin functions, it's best not to define the function and just use the body directly:</p>

<pre><code>import string
b=__builtins__
for c,f in zip(string.letters,[b.__dict__[q]for q in dir(b)if(len(q)&gt;2)*type(x.__dict__[q]).__name__.find('eth')&gt;0]):globals()[c]=f
</code></pre>
</div>
<div id="pu88" class="pu"><p>You can use the good old alien smiley face to reverse sequences:</p>

<pre class="lang-python prettyprint-override"><code>[1, 2, 3, 4][::-1] # =&gt; [4, 3, 2, 1]
</code></pre>
</div>
<div id="pu89" class="pu"><p><strong>Access list, while building it inside comprehension</strong></p>

<p>In python version 2.4 (and &lt;2.3 with some tweaks) it is possible to access list, from list comprehension. <a href="http://code.activestate.com/recipes/204297/" rel="nofollow noreferrer">Source #1</a>,  <a href="https://www.safaribooksonline.com/library/view/python-cookbook-2nd/0596007973/ch16s11.html" rel="nofollow noreferrer">Source #2 (Safari, Python Cookbook, 2nd edition)</a></p>

<p>Python creates secret name <code>_[1]</code> for list, while it is created and store it in <code>locals</code>. Also names <code>_[2]</code>, <code>_[3]</code>... are used for nested lists.</p>

<p>So to access list, you may use <code>locals()['_[1]']</code>.</p>

<p>In earlier versions this is not enough. You'll need to use <code>locals()['_[1]'].__self__</code></p>

<p>I couldn't find evidence, that somethins like that is possible in versions >2.4</p>

<p>Don't think, that it might be usefull often, but who knows! At least it helps with building one-liners.</p>

<p>Example:</p>

<pre><code># Remove duplicates from a list:
&gt;&gt;&gt; L = [1,2,2,3,3,3]
&gt;&gt;&gt; [x for x in L if x not in locals()['_[1]']]
[1,2,3]
</code></pre>
</div>
<div id="pu90" class="pu"><p>If you're drawing, for colors, instead of typing: </p>

<p><code>'#000'</code> for black you can just use <code>0</code> <em>(no apostrophes)</em><br>
<code>'#fff'</code> for white you can simply use <code>~0</code> <em>(no apostrophes)</em><br>
<code>'#f00'</code> for red you can just use <code>'red'</code><br></p>

<hr>

<p>Example of white being used with <code>~0</code></p>

<pre><code>from PIL.ImageDraw import*
i=Image.new('RGB',(25,18),'#d72828')
Draw(i).rectangle((1,1,23,16),'#0048e0',~0)
i.show()
</code></pre>
</div>
<div id="pu91" class="pu"><h2><strong>Easiest way to swap two values</strong></h2>

<pre><code>&gt;&gt;&gt; a=5
&gt;&gt;&gt; b=4
&gt;&gt;&gt; a,b=b,a
&gt;&gt;&gt; a
4
&gt;&gt;&gt; b
5
</code></pre>
</div>
<div id="pu92" class="pu"><h2>Store 8-bit numbers compactly as a bytes object  in Python 3</h2>



<p>In Python 3, a <em>bytes object</em> is written as a string literal preceded by a <code>b</code>, like <code>b"golf"</code>. It acts much like a tuple of the <code>ord</code> values of its characters.</p>

<pre class="lang-python prettyprint-override"><code>&gt;&gt;&gt; l=b"golf"
&gt;&gt;&gt; list(l)
[103, 111, 108, 102]
&gt;&gt;&gt; l[2]
108
&gt;&gt;&gt; 108 in l
True
&gt;&gt;&gt; max(l)
111
&gt;&gt;&gt; for x in l:print(x)
103
111
108
102
</code></pre>

<p>Python 2 also has bytes objects but they act as strings, so this only works in Python 3.</p>

<p>This gives a shorter way to express an explicit list of numbers between 0 to 255. Use this to hardcode data. It uses one byte per number, plus three bytes overhead for <code>b""</code>.  For example, the list of the first 9 primes <code>[2,3,5,7,11,13,17,19,23]</code> compresses to 14 bytes rather than 24. (An extra byte is used for a workaround explained below for character 13.)</p>

<p>In many cases, your bytes object will contain non-printable characters such as <code>b"\x01x02\x03"</code> for <code>[1, 2, 3]</code>. These are written with hex escape characters, but <a href="http://meta.codegolf.stackexchange.com/q/4922/20260">you may use them a single characters in your code</a> (unless the challenge says otherwise) even though SE will not display them. But, characters like the carriage return <code>b"\x0D"</code> will break your code, so you need to use the two-char escape sequence <code>"\r"</code>.</p>
</div>
<div id="pu93" class="pu"><p>A condition like</p>

<pre><code>s = ''
if c:
    s = 'a'
</code></pre>

<p>can be written as </p>

<pre><code>s = c*'a'
</code></pre>

<p>and there is possibly a need for parenthesis for condition.</p>

<p>This can also be combined with other conditions as (multiple ifs)</p>

<pre><code>s = c1*'a' + c2*'b'
</code></pre>

<p>or (multiple elifs)</p>

<pre><code>s = c1*'a' or c2*'b'
</code></pre>

<p>For example FizzBuzz problem's solution will be</p>

<pre><code>for i in range(n):
    print((i%3&lt;1)*"Fizz"+(i%5&lt;1)*"Buzz" or i)
</code></pre>
</div>
<div id="pu94" class="pu"><p>When mapping a function on a list in Python 3, instead of doing <code>[f(x)for x in l]</code> or <code>list(map(f,l))</code>, do <code>[*map(f,l)]</code>.</p>

<p>It works for all other functions returning generators too (like <code>filter</code>).</p>

<p>The best solution is still switching to Python 2 though</p>
</div>
<div id="pu95" class="pu"><h2>Booleans are integers, too!</h2>

<pre class="lang-py prettyprint-override"><code>assert True == 1
assert False == 0
assert 2 * True == 2
assert 3 * False == 0
assert (2&gt;1)+(1&lt;2) == 2
</code></pre>
<p>If you have a statement like <code>[a,a+x][c]</code> (where <code>c</code> is some boolean expression), you can do <code>a+x*c</code> instead and save a few bytes. Doing arithmetic with booleans can save you lots of bytes!</p>
</div>
<div id="pu96" class="pu"><h2>Use IDLE 3.3 to take multiline input</h2>

<p>In IDLE versions 3.1 to 3.3, the command <code>input()</code> reads an entire multiline string like <code>"line1\nline2"</code>, rather than a single line at a time as per <a href="https://docs.python.org/3.1/library/functions.html#input" rel="nofollow noreferrer">the spec</a>. This was <a href="http://bugs.python.org/issue20058" rel="nofollow noreferrer">fixed in version 3.4</a>.</p>

<p>Calling <code>input()</code> only once is very convenient for golfing. Whether one can take advantage of this is debatable, but I think it is an acceptable <a href="http://meta.codegolf.stackexchange.com/a/5852/20260">interpreter- or environment-specific behavior</a>.</p>
</div>
<div id="pu97" class="pu"><h2>Use <code>.center</code> in ASCII art</h2>

<p>In drawing a symmetrical ASCII art, you can center-justify each line in a fixed width of spaces. For example, <code>"&lt;|&gt;".center(7)</code> gives <code>'  &lt;|&gt;  '</code>. This can be shorter than computing how many spaces are needed to center it.</p>

<p>You can also pad with a different character by doing <code>"&lt;|&gt;".center(7,'_')</code></p>
</div>
<div id="pu98" class="pu"><h1>Use <em>f-strings</em></h1>

<p>Python 3.6 <a href="https://docs.python.org/3.6/reference/lexical_analysis.html#f-strings" rel="noreferrer">introduces a new string literal</a> that is vastly more byte-efficient at variable interpolation than using <code>%</code> or <code>.format()</code> in non-trivial cases. For example, you can write:</p>

<pre><code>l='Python';b=40;print(f'{l}, {b} bytes')
</code></pre>

<p>instead of</p>

<pre><code>l='Python';b=43;print('%s, %d bytes'%(l,b))
</code></pre>
</div>
<div id="pu99" class="pu"><h2>Find the n'th number meeting a condition</h2>



<p>Many sequence challenges ask you to find the n'th number in a sequence of increasing positive integers. When you have a expression <code>p(i)</code> that checks membership, you can do this with the recursive function:</p>

<pre class="lang-python prettyprint-override"><code>f=lambda n,i=1:n and-~f(n-p(i),i+1)
</code></pre>

<p>Note that expression <code>p(i)</code> must give 0 or 1, not just Falsey or Truthy. The outputs are one-indexed, so say for the sequence of primes, it would give</p>

<pre class="lang-python prettyprint-override"><code>f(1) = 2
f(2) = 3
...
</code></pre>

<p>For 0-indexed outputs, shift the base case</p>

<pre class="lang-python prettyprint-override"><code>f=lambda n,i=1:n+1and-~f(n-p(i),i+1)
</code></pre>

<p>The recursive function <code>f=lambda n,i=1:n and-~f(n-p(i),i+1)</code> works by decrementing the required count <code>n</code> each time it gets a hit, and incrementing the output value each time for each value it checks. It might seem weird to redundantly track <code>i</code>, but it's longer to do:</p>

<pre class="lang-python prettyprint-override"><code>f=lambda n,i=1:n and f(n-p(i),i+1)or~-i
</code></pre>

<p>Also compare the natural list strategy (zero-indexed here)</p>

<pre class="lang-python prettyprint-override"><code>lambda n:[i for i in range(n*n)if p(i)][n]
</code></pre>

<p>(You might need a larger bound than <code>n*n</code>.)</p>
</div>
<div id="pu100" class="pu"><h1>Omit needless spaces</h1>

<p>Python tokens only need to separated by a space for</p>

<ul>
<li>A letter followed by a letter</li>
<li>A letter followed by a digit</li>
</ul>

<p>In all other cases, the space can be omitted (with a few exceptions). Here's a table.</p>

<pre><code>  L D S
 +-----
L|s s n
D|n - n
S|n n n    

First token is row, second token is column
L: Letter
D: Digit
S: Symbol

s: space
n: no space
-: never happens (except multidigit numbers)
</code></pre>

<h2>Examples</h2>

<p><strong>Letter followed by letter: Space</strong></p>



<pre class="lang-python prettyprint-override"><code>not b
for x in l:
lambda x:
def f(s):
x in b"abc"
</code></pre>

<p><strong>Letter followed by digit: Space</strong></p>

<pre class="lang-python prettyprint-override"><code>x or 3
while 2&lt;x:
</code></pre>

<p><strong>Letter followed by symbol: No space</strong></p>

<pre class="lang-python prettyprint-override"><code>c&lt;d
if~x:
x and-y
lambda(a,b):
print"yes"
return[x,y,z]
</code></pre>

<p><strong>Digit followed by letter: No space</strong></p>

<pre class="lang-python prettyprint-override"><code>x+1if x&gt;=0else 2
0in l
</code></pre>

<p>(Some versions of Python 2 will fail on a digit followed by <code>else</code> or <code>or</code>.)</p>

<p><strong>Digit followed by digit: Never occurs</strong></p>

<p>Consecutive digits make a multidigit number. I am not aware of any situation where two digits would be separated by a space.</p>

<p><strong>Digit followed by symbol: No space</strong></p>

<pre class="lang-python prettyprint-override"><code>3&lt;x
12+n
l=0,1,2
</code></pre>

<p>A space is needed for <code>1 .__add__</code> and other built-ins of integers, since otherwise the <code>1.</code> is parsed as a float.</p>

<p><strong>Symbol followed by letter: No space</strong></p>

<pre class="lang-python prettyprint-override"><code>~m
2876&lt;&lt;x&amp;1
"()"in s
</code></pre>

<p><strong>Symbol followed by digit: No space</strong></p>

<pre class="lang-python prettyprint-override"><code>-1
x!=2
</code></pre>

<p><strong>Symbol followed by symbol: No space</strong></p>

<pre class="lang-python prettyprint-override"><code>x*(a+b)%~-y
t**=.5
{1:2,3:4}.get()
"% 10s"%"|"
</code></pre>
</div>
<div id="pu101" class="pu"><p><code>map</code> can take multiple iterable arguments and apply the function in parallel. </p>

<p>Instead of </p>

<pre><code>a=[1,4,2,6,4]
b=[2,3,1,8,2]
map(lambda x,y:...,zip(a,b))
</code></pre>

<p>you can write</p>

<pre><code>map(lambda x,y:...,a,b)
</code></pre>
</div>
<div id="pu102" class="pu"><h1>Ceil and Floor</h1>
<p>If you ever want to get the rounded-up result for a division, much like you'd do with <code>//</code> for floor, you could use <code>math.ceil(3/2)</code> for 15 or the much shorter <code>-(-3//2)</code> for 8 bytes.</p>
<pre><code>math.floor(n)   : 13 bytes+12 for import
n//1            : 4  bytes

math.ceil(n)    : 12 bytes+12 for import
-(-n//1)        : 8  bytes
</code></pre>
</div>
<div id="pu103" class="pu"><p>One trick I have encountered concerns returning or printing Yes/No answers: </p>

<pre><code> print 'YNeos'[x::2]
</code></pre>

<p>x is the condition and can take value 0 or 1. </p>

<p>I found this rather brilliant. </p>
</div>
<div id="pu104" class="pu"><h1>Abuse of <code>or</code> in <code>lambda</code>s</h1>
<p>I'm surprised this isn't in here yet, but if you need a multi-statement <code>lambda</code>, <code>or</code> evaluates both of its operands, as opposed to <code>and</code> which doesn't evaluate the second one if the first one is not <code>True</code>. For instance, a contrived example, to print the characters in a string one by one with an interval:</p>
 
<pre class="lang-python prettyprint-override"><code>list(
    map(
        (lambda i: 
            sleep(.06) or print(i) or print(ord(i)) # all of these get executed
        ), 
        &quot;compiling... &quot;
    )
)
            
</code></pre>
<p>In this case it isn't shorter, but I've found it to be, sometimes.</p>
</div>
<div id="pu105" class="pu"><h1><a href="https://docs.python.org/2/library/functions.html#cmp" rel="nofollow noreferrer"><code>cmp</code></a> in Python 2</h1>
<p>Say you want to output <code>P</code> if <code>x&gt;0</code>, <code>N</code> if <code>x&lt;0</code>, and <code>Z</code> if <code>x==0</code>.</p>

<pre class="lang-python prettyprint-override"><code>&quot;ZPN&quot;[cmp(x,0)]
</code></pre>
<p><a href="https://repl.it/BsRE" rel="nofollow noreferrer">Try it online</a></p>
<p>This function was <a href="https://docs.python.org/3.0/whatsnew/3.0.html#ordering-comparisons" rel="nofollow noreferrer">removed in Python 3.0.1</a>, although it <a href="http://python3porting.com/differences.html#comparisons" rel="nofollow noreferrer">remained in Python 3.0 by mistake</a>.</p>
</div>
<div id="pu106" class="pu"><h1>Use slicing + assignment instead of mutator methods</h1>

<pre><code>l.insert(x,y) # before
l[x:x]=y,     # after

l.reverse()   # before
l[::-1]=l     # after

l.append(x)   # before
l[L:]=x,      # after (where L is any integer &gt;= len(l))

l[:]=x        # set the contents of l to the contents of x
</code></pre>

<p><strong>EDIT</strong>: thanks to @quintopia for pointing this out, these are <em>statements</em>, not <em>expressions</em>. The mutator methods are void functions, so they are expressions which evaluate to <code>None</code>. This means that things like <code>[l.reverse() for x in L]</code> and <code>condition or l.reverse()</code> are valid, whereas <code>[l[::-1]=l for x in L]</code> and <code>condition or l[::-1]=l</code> are not.</p>
</div>
<div id="pu107" class="pu"><h1>Use complex numbers to find the distance between two points</h1>

<p>Say you have two 2-element tuples which represent points in the Euclidean plane, e.g. <code>x=(0, 0)</code> and <code>y=(3, 4)</code>, and you want to find the distance between them. The naïve way to do this is</p>

<pre><code>d=((x[0]-y[0])**2+(x[1]-y[1])**2)**.5
</code></pre>

<p>Using complex numbers, this becomes:</p>

<pre><code>c=complex;d=abs(c(*x)-c(*y))
</code></pre>

<p>If you have access to each coordinate individually, say <code>a=0, b=0, c=3, d=4</code>, then</p>

<pre><code>abs(a-c+(b-d)*1j)
</code></pre>

<p>can be used instead.</p>
</div>
<div id="pu108" class="pu"><h2>Optional empty sequence argument</h2>

<p>Suppose we want to write a recursive function that prepends to a sequence (e.g. list, tuple) each time. For example, the Python 3 program</p>



<pre class="lang-py prettyprint-override"><code>def f(n,k,L=[]):n and[f(n-1,k,[b]+L)for b in range(k)]or print(L)
</code></pre>

<p>works like <code>itertools.product</code>, taking <code>n,k</code> and printing all length <code>n</code> lists of numbers  taken from <code>range(k)</code>. <em>(Example thanks to @xnor)</em></p>

<p>If we don't need <code>L</code> to be a list specifically, we can save on the optional empty list argument by making use of unpacking, like so:</p>

<pre class="lang-py prettyprint-override"><code>def f(n,k,*T):n and[f(n-1,k,b,*T)for b in range(k)]or print(T)
</code></pre>

<p>where <code>T</code> is now a tuple instead. In the general case, this saves 3 bytes!</p>

<p>In Python 3.5+, this also works if we're appending to the end of a sequence, i.e. we can change <code>f(n-1,k,L+[b])</code> to <code>f(n-1,k,*T,b)</code>. The latter is a syntax error in earlier versions of Python though.</p>
</div>
<div id="pu109" class="pu"><h1>Take multi-line input</h1>

<p>Use <code>list(iter(input,eof))</code> to take multi-line input. <code>eof</code> can be any string that you want to stop taking input on if you see it. An example would be <code>eof = ''</code>. The python 2 version is <code>list(iter(raw_input,eof))</code>, however you may want to use <code>sys.stdin.readlines()</code> instead if you have already imported <code>sys</code>.</p>
</div>
<div id="pu110" class="pu"><pre><code>&gt;&gt;&gt; for i in range(x):s+=input()
</code></pre>

<p>if value of <strong>i</strong> is useless:</p>

<pre><code>&gt;&gt;&gt; for i in[0]*x:s+=input()
</code></pre>

<p>or</p>

<pre><code>&gt;&gt;&gt; exec's+=input();'*x
</code></pre>
</div>
<div id="pu111" class="pu"><h1>Reading multi-line input</h1>

<p>In Python 3, the built-in function <code>open</code> underwent some changes. In particular, its first argument</p>

<blockquote>
  <p><em>file</em> is either a string or bytes object giving the pathname (absolute or relative to the current working directory) of the file to be opened or an integer file descriptor of the file to be wrapped.</p>
</blockquote>

<p>(<a href="https://docs.python.org/3/library/functions.html#open" rel="noreferrer">source</a>)</p>

<p>That means</p>

<pre><code>open(0).read()
</code></pre>

<p>suffices to read all input from STDIN.</p>

<p>Try it online on <a href="http://ideone.com/duzBEE" rel="noreferrer">Ideone</a>.</p>
</div>
<div id="pu112" class="pu"><p>You can assign to a list inside of a for loop.</p>

<p>For example:</p>

<pre><code>L=[1, 2, 3, 4, 6]
queue = [None]*len(L)
for e, queue[e] in enumerate(L):
    print("adding", queue[e], "to processing queue")
</code></pre>

<p>This can also be helpful if you need to switch the object you're assigning to.</p>

<pre><code>class Foo:
    def __init__(self):
        self.x = None
a = Foo()
b = Foo()
for q, (lambda x: a if x%2==0 else b)(q).x in enumerate(range(10)):
    print(a.x, b.x)
</code></pre>
</div>
<div id="pu113" class="pu"><p>For integer <code>n</code>, you can write </p>

<ul>
<li><code>n+1</code> as <code>-~n</code></li>
<li><code>n-1</code> as  <code>~-n</code> </li>
</ul>

<p>because the bit flip <code>~x</code> equals <code>-1-x</code>. This uses the same number of characters, but can indirectly cut spaces or parens for operator precedence.</p>

<p>Compare:</p>

<pre class="lang-python prettyprint-override"><code>while n-1:  #Same as while n!=1 
while~-n:

c/(n-1)
c/~-n

or f(n)+1
or-~f(n) 

(n-1)/10+(n-1)%10
~-n/10+~-n%10
</code></pre>

<p>The operators <code>~</code> and unary <code>-</code> are higher precedence than <code>*</code>, <code>/</code>, <code>%</code>, unlike binary <code>+</code>.</p>
</div>
<div id="pu114" class="pu"><h2>Exploit Python 2 string representations</h2>

<p>Python 2 lets you convert an object <code>x</code> to its string representation <code>`x`</code> at a cost of only 2 chars. Use this for tasks that are easier done on the object's string than the object itself.</p>

<p><strong>Join characters</strong></p>

<p>Given a list of characters <code>l=['a','b','c']</code>, one can produce <code>''.join(l)</code> as <code>`l`[2::5]</code>, which saves a byte. </p>

<p>The reason is that <code>`l`</code> is  <code>"['a', 'b', 'c']"</code> (with spaces), so one can extract the letters with a list slice, starting that the second zero-indexed character <code>a</code>, and taking every fifth character from there. This doesn't work to join multi-character strings or escape characters represented like <code>'\n'</code>.</p>

<p><strong>Concatenate digits</strong></p>

<p>Similarly, given a non-empty list of digits like <code>l=[0,3,5]</code>, one can concatenate them into a string <code>'035'</code> as <code>`l`[1::3]</code>. </p>

<p>This saves doing something like <code>map(str,l)</code>. Note that they must be single digits, and can't have floats like <code>1.0</code> mixed in. Also, this fails on the empty list, producing <code>]</code>.</p>

<p><strong>Check for negatives</strong></p>

<p>Now, for a non-string task. Suppose you have a list <code>l</code> of real numbers and want to test if it contains any negative numbers, producing a Boolean.</p>

<p>You can do</p>



<pre class="lang-python prettyprint-override"><code>'-'in`l`
</code></pre>

<p>which checks for a negative sign in the string rep. This shorter than either of</p>

<pre class="lang-python prettyprint-override"><code>any(x&lt;0for x in l)
min(l+[0])&lt;0   
</code></pre>

<p>For the second, <code>min(l)&lt;0</code> would fail on the empty list, so you have to hedge.</p>
</div>
<div id="pu115" class="pu"><h1>Use a list if you have multiple choices based on int</h1>

<p>Say for example you have some output that will be <code>1, 0, or -1</code> and you need a different output for each case. You could do something like this:</p>

<pre><code>print('0'if x==0else('1'if x&gt;0else'-1'))
</code></pre>

<p>However, the better way is to use <code>x</code> as an index to a list like so:</p>

<pre><code>print(['0','1','-1'][x])
</code></pre>

<p>which is <code>16</code> bytes shorter.</p>
</div>
<div id="pu116" class="pu"><h1>Convert modules to lists</h1>

<p>This will work for CPython (probably both 2 and 3), and lets you maybe shave a few bytes if you need to use a lot of different functions and classes with long names from the same module, but you aren't using any of them often enough to rename individually. You'll have to do some research first to figure out which magic numbers give you which functions. Example (rot13):</p>

<pre><code>d=sorted
e=".__dict__.values()"
b=d(eval("__builtins__"+e))
s=d(eval("str"+e))
t=b[12]('string').maketrans
r=''.join(map(chr,range(65,91)))
w=r[13:]+r[:13]
l=t(r+s[4](r),w+s[4](w))
print s[28](b[53](),l)
</code></pre>

<p>Translated back to plain python, this is the same as:</p>

<pre><code>t=__import__('string').maketrans
r=''.join(map(chr,range(65,91)))
w=r[13:]+r[:13]
l=t(r+r.lower(),w+w.lower())
print raw_input().translate(l)
</code></pre>

<p>which is obviously much shorter, but it should be clear how this methodology would eventually save bytes on much longer, more complicated programs that use more modules.</p>
</div>
<div id="pu117" class="pu"><h1>Printing a string without a trailing newline in Python 3</h1>

<p>Suppose you have a string <code>s</code>, and need to print it without a trailing newline. The canonical way of doing this would be</p>



<pre class="lang-py prettyprint-override"><code>print(s,end='')
</code></pre>

<p>However, if we look at the <a href="https://docs.python.org/3/library/functions.html#print">documentation for <code>print</code></a>, we can see that <code>print</code> takes in a variable number of objects as its first parameter, with "variable number" including zero. This means that we can do</p>

<pre class="lang-py prettyprint-override"><code>print(end=s)
</code></pre>

<p>instead, for a saving of 3 bytes.</p>

<p>Note that this only works when <code>s</code> is a string, since otherwise the conversion to string would be too expensive:</p>

<pre class="lang-py prettyprint-override"><code>print(1,end='')
print(end=str(1))
</code></pre>

<p>Thanks to <a href="https://codegolf.stackexchange.com/questions/49950/capitalize-first-letter-of-each-word-of-input/49998#comment118031_49998">@Reticality</a> for this tip.</p>
</div>
<div id="pu118" class="pu"><h2>Dictionary defaults as entries</h2>



<p>Say you have an dictionary literal, which I'll denote <code>{...}</code>, and you want to get the value for a key <code>k</code>, with a default of <code>d</code> if <code>k</code> is missing.</p>

<p>You can save two bytes by prepending an entry rather than using <code>get</code></p>

<pre class="lang-python prettyprint-override"><code>{k:d,...}[k]
{...}.get(k,d)
</code></pre>

<p>Because later entries override earlier ones of the same key, the entry <code>k:d</code> gets overwritten if it appears in the dict, but remains if key <code>k</code> isn't present.</p>

<p>Note that this required writing <code>k</code> twice, which is fine for a variable, but poor when <code>k</code> is an expression.</p>
</div>
<div id="pu119" class="pu"><h2>Try a lambda expression</h2>



<p>By default, <a href="https://codegolf.meta.stackexchange.com/a/2422/20260">submissions may be functions</a> and <a href="https://codegolf.meta.stackexchange.com/a/1503/20260">functions may be anonymous</a>. A <code>lambda</code> expression is often the shortest framework for input/output. Compare:</p>

<pre class="lang-python prettyprint-override"><code>lambda s:s+s[::-1]
def f(s):return s+s[::-1]
s=input();print s+s[::-1]
</code></pre>

<p>(These concatenate a string with its reverse.)</p>

<p>The big limitation is that the body of a <code>lambda</code> must be a single expression, and so cannot contain assignments. For built-ins, you can do assignments like <code>e=enumerate</code> outside the function body or as an optional argument. </p>

<p>This doesn't work for expressions in terms of the inputs. But, note that using a <code>lambda</code> might still be worth repeating a long expression.</p>

<pre class="lang-python prettyprint-override"><code>lambda s:s.lower()+s.lower()[::-1]
def f(s):t=s.lower();return t+t[::-1]
</code></pre>

<p>The <code>lambda</code> is shorter even though we save a char in the named function by having it <code>print</code> rather than <code>return</code>. The break-even point for two uses is length 12.</p>

<p>However, if you have many assignments or complex structures like loops (that are hard to make recursive calls), you're probably be better off taking the hit and write a named function or program.</p>
</div>
<div id="pu120" class="pu"><h1>PEP448 – <a href="https://www.python.org/dev/peps/pep-0448/" rel="noreferrer">Additional Unpacking Generalizations</a></h1>

<p>With the release of <a href="https://www.python.org/downloads/release/python-350/" rel="noreferrer">Python 3.5</a>, manipulation of lists, tuples, sets and dicts just got golfier.</p>

<h2>Turning an iterable into a set/list</h2>



<p>Compare the pairs:</p>

<pre class="lang-py prettyprint-override"><code>set(T)
{*T}

list(T)
[*T]

tuple(T)
(*T,)
</code></pre>

<p>Much shorter! Note, however, that if you just want to convert something to a list and assign it to a variable, normal <a href="https://www.python.org/dev/peps/pep-3132/" rel="noreferrer">extended iterable unpacking</a> is shorter:</p>

<pre class="lang-py prettyprint-override"><code>L=[*T]
*L,=T
</code></pre>

<p>A similar syntax works for tuples:</p>

<pre class="lang-py prettyprint-override"><code>T=*L,
</code></pre>

<p>which is like extended iterable unpacking, but with the asterisk and comma on the other side.</p>

<h2>Joining lists/tuples</h2>

<p>Unpacking is slightly shorter than concatenation if you need to append a list/tuple to both sides:</p>

<pre class="lang-py prettyprint-override"><code>[1]+T+[2]
[1,*T,2]

(1,)+T+(2,)
(1,*T,2)
</code></pre>

<h2>Printing the contents of multiple lists</h2>

<p>This isn't limited to <code>print</code>, but it's definitely where most of the mileage will come from. PEP448 now allows for multiple unpacking, like so:</p>

<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; T = (1, 2, 3)
&gt;&gt;&gt; L = [4, 5, 6]
&gt;&gt;&gt; print(*T,*L)
1 2 3 4 5 6
</code></pre>

<h2>Updating multiple dictionary items</h2>

<p>This probably won't happen very often, but the syntax can be used to save on updating dictionaries if you're updating at least three items:</p>

<pre class="lang-py prettyprint-override"><code>d[0]=1;d[1]=3;d[2]=5
d={**d,0:1,1:3,2:5}
</code></pre>

<p>This basically negates any need for <code>dict.update</code>.</p>
</div>
<div id="pu121" class="pu"><h2>Avoid the <code>repeat</code> argument of <code>itertools.product</code></h2>

<p>As @T.Verron points out, in most cases (e.g. ranges and lists), you can instead do</p>

<pre><code>product(*[x]*n)
</code></pre>

<p>However, even if you have a generator which you can only use once, like a Python 3 <code>map</code>, the <code>repeat</code> argument is still unnecessary. In such a case you can use <code>itertools.tee</code>:</p>

<pre><code>product(x,repeat=n)
product(*tee(x,n))
</code></pre>

<p>For <code>n = 2</code> you don't even need to include <code>n</code>, since 2 is the default argument to <code>tee</code>.</p>
</div>
<div id="pu122" class="pu">

<h1>Translating chars in a string</h1>

<p>I've seen this situation pop up a few times, so I thought a tip would be good.</p>

<p>Suppose you have a string <code>s</code> and you want to translate some chars of <code>s</code> to other chars (think ROT-13 like ciphers). For a more concrete example, suppose we want to swap just the <code>a</code>s and <code>b</code>s in a string, e.g.</p>

<pre class="lang-py prettyprint-override"><code>"abacus" -&gt; "babcus"
</code></pre>

<p>The naïve way to do this would be:</p>

<pre class="lang-py prettyprint-override"><code>lambda s:s.replace('a','T').replace('b','a').replace('T','b')
</code></pre>

<p>Note how we need to introduce a temporary <code>'T'</code> to get the swapping right.</p>

<p>With <code>eval</code>, we can shorten this a bit:</p>

<pre class="lang-py prettyprint-override"><code>lambda s:eval("s"+".replace('%s','%s')"*3%tuple("aTbaTb"))
</code></pre>

<p>For this particular example, iterating char-by-char gives a slightly better solution (feel free to try it!). But even so, the winner is <strong><code>str.translate</code></strong>, which takes a dictionary of <code>from: to</code> code points:</p>

<pre class="lang-py prettyprint-override"><code># Note: 97 is 'a' and 98 is 'b'
lambda s:s.translate({97:98,98:97})
</code></pre>

<p>In Python 2 this only works for Unicode strings, so unfortunately the code here is slightly longer:</p>

<pre class="lang-py prettyprint-override"><code>lambda s:(u''+s).translate({97:98,98:97})
</code></pre>

<p>Some important points which make <code>str.translate</code> so useful are:</p>

<ul>
<li>It's easily extendable.</li>
<li>Any char not specified is untouched by default, e.g. the <code>"cus"</code> in <code>"abacus"</code> above.</li>
<li>The <code>to</code> part of the dictionary can actually be a (Unicode) string as well, e.g. <code>{97:"XYZ"}</code> (<code>u"XYZ"</code> in Python 2) would turn <code>abacus -&gt; XYZbXYZcus</code>. It can also be <code>None</code>, but that doesn't save any bytes compared to <code>""</code> or <code>u""</code>.</li>
</ul>
</div>
<div id="pu123" class="pu"><h2>Make a mutable matrix</h2>



<p>If you want to make a 3*4 grid of zeroes, the natural expression <code>M=[[0]*4]*3</code> gives an unpleasant surprise if you modify an entry:</p>

<pre class="lang-python prettyprint-override"><code>&gt;&gt;&gt; M=[[0]*4]*3
&gt;&gt;&gt; M
[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]
&gt;&gt;&gt; M[0][0]=1
&gt;&gt;&gt; M
[[1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0]]
</code></pre>

<p>Since each row is a copy of the same list by reference, modifying one row modifies all of them, which is usually not the behavior you want. </p>

<p>In Python 2, avoid this with the hack (19 chars):</p>

<pre class="lang-python prettyprint-override"><code>M=eval(`[[0]*4]*3`)
</code></pre>

<p>Doing <code>eval(`_`)</code> converts to the string representation, then re-evaluates it, converting the object to the code of how it's displayed. In effect, it's doing <code>copy.deepcopy</code>.</p>

<p>If you're OK getting a tuple of lists, you can do (18 chars):</p>

<pre class="lang-python prettyprint-override"><code>M=eval('[0]*4,'*3)
</code></pre>

<p>to get <code>([0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0])</code>. This lets you do <code>M[0][0]=1</code> but not <code>M[0]=[1,2,3,4]</code>. It also works in Python 3.</p>
</div>
<div id="pu124" class="pu"><p>Instead of <code>range(x)</code>, you can use the <code>*</code> operator on a list of anything, if you don't actually need to use the value of <code>i</code>:</p>

<pre><code>for i in[1]*8:pass
</code></pre>

<p>as opposed to</p>

<pre><code>for i in range(8):pass
</code></pre>

<p>If you need to do this more than twice, you could assign any iterable to a variable, and multiply that variable by the range you want:</p>

<pre><code>r=1,
for i in r*8:pass
for i in r*1000:pass
</code></pre>

<p><strong>Note</strong>: this is often longer than <code>exec"pass;"*8</code>, so this trick should only be used when that isn't an option.</p>
</div>
<div id="pu125" class="pu"><h2>set literals in Python2.7</h2>

<p>You can write sets like this <code>S={1,2,3}</code> This also means you can check for membership using <code>{e}&amp;S</code> instead of <code>e in S</code> which saves one character.</p>
</div>
<div id="pu126" class="pu"><h1>Shorter isinstance</h1>

<p>Instead of</p>

<pre><code>isinstance(x,C) # 15 bytes
</code></pre>

<p>there are several alternatives:</p>

<pre><code>x.__class__==C  # 14 bytes
'a'in dir(x)    # 12 bytes, if the class has a distinguishing attribute 'a'
type(x)==C      # 10 bytes, doesn't work with old-style classes
'K'in`x`        # 8 bytes, only in python 2, if no other classes contain 'K'
                # watch out for false positives from the hex address
</code></pre>

<p>Some of them may save extra bytes depending on the context, because you can eliminate a space before or after the expression.</p>

<p>Thanks Sp3000 for contributing a couple of tips.</p>
</div>
<div id="pu127" class="pu"><p>A nice way to convert an iterable to list on <strong>Python 3</strong>:</p>

<p>imagine you have some iterable, like</p>

<pre><code>i = (1,2,3,4)
i = range(4)
i = (x**2 for x in range(5))
</code></pre>

<p>But you need a list:</p>

<pre><code>x=list(i)  #the default way
*x,=i      #using starred assignment -&gt; 4 char fewer
</code></pre>

<p>It's very useful to make a list of chars out of a string</p>

<pre><code>s=['a','b','c','d','e']
s=list('abcde')
*s,='abcde'
</code></pre>
</div>
<div id="pu128" class="pu"><h1>Alternatives to builtin string functions</h1>



<h3>str.capitalize for single words</h3>

<p>Use <code>str.title</code> instead for single words. The difference between the two functions is that <code>capitalize</code> only capitalises the first word, while <code>title</code> capitalises all words:</p>

<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; "the quick brown fox".capitalize()
'The quick brown fox'
&gt;&gt;&gt; "the quick brown fox".title()
'The Quick Brown Fox'
</code></pre>

<h3>str.index</h3>

<p><code>str.find</code> is almost always better, and even returns -1 if the substring is not present rather than throwing an exception.</p>

<h3>str.startswith</h3>

<p>See <a href="https://codegolf.stackexchange.com/a/51783/21487">this tip</a> by @xnor.</p>

<h3>str.splitlines</h3>

<p><code>str.split</code> is shorter:</p>

<pre class="lang-py prettyprint-override"><code>s.splitlines()
s.split('\n')
</code></pre>

<p>However, <code>str.splitlines</code> may be useful if you need to preserve trailing newlines, which can be done by passing <code>1</code> as the <code>keepends</code> argument.</p>
</div>
<div id="pu129" class="pu"><h1>Avoid <code>list.insert</code></h1>



<p>Instead of <code>list.insert</code>, appending to a slice is shorter:</p>

<p></p>

<pre class="lang-py prettyprint-override"><code>L.insert(i,x)
L[:i]+=x,
</code></pre>

<p>For example:</p>

<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; L = [1, 2, 3, 4]
&gt;&gt;&gt; L[:-2]+=5,
&gt;&gt;&gt; L
[1, 2, 5, 3, 4]
&gt;&gt;&gt; L[:0]+=6,
&gt;&gt;&gt; L
[6, 1, 2, 5, 3, 4]
</code></pre>
</div>
<div id="pu130" class="pu"><p>When squaring single letter variables, it is shorter to times it by itself</p>

<pre><code>&gt;&gt;&gt; x=30
&gt;&gt;&gt; x*x
900
</code></pre>

<p>Is one byte shorter than</p>

<pre><code>&gt;&gt;&gt; x=30
&gt;&gt;&gt; x**2
900
</code></pre>
</div>
<div id="pu131" class="pu"><h1>Leak variables to save on assignment</h1>

<p>Combining with <a href="https://codegolf.stackexchange.com/a/1020/21487">this tip</a>, suppose you have a situation like</p>



<pre class="lang-py prettyprint-override"><code>for _ in[0]*x:doSomething()
a="blah"
</code></pre>

<p>You can instead do:</p>

<pre class="lang-py prettyprint-override"><code>for a in["blah"]*x:doSomething()
</code></pre>

<p>to skip out on a variable assignment. However, be aware that</p>

<pre class="lang-py prettyprint-override"><code>exec"doSomething();"*x;a="blah"
</code></pre>

<p>in Python 2 is <em>just</em> shorter, so this only really saves in cases like assigning a char (via <code>"c"*x</code>) or in Python 3.</p>

<p>However, where things get fun is with Python 2 list comprehensions, where this idea still works due to a <a href="https://stackoverflow.com/questions/4198906/python-list-comprehension-rebind-names-even-after-scope-of-comprehension-is-thi">quirk with list comprehension scope</a>:</p>

<pre class="lang-py prettyprint-override"><code>[doSomething()for a in["blah"]*x]
</code></pre>

<p><em>(Credits to @xnor for expanding the former, and @Lembik for teaching me about the latter)</em></p>
</div>
<div id="pu132" class="pu">

<h1><code>None</code> arguments in Python builtins</h1>

<h2>map (Python 2 only)</h2>

<p>Mapping with <code>None</code> in place of a function assumes the identity function instead. This allows it to be used as an alternative to <code>itertools.izip_longest</code> for zipping lists to the length of the longest list:</p>

<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; L = [[1, 2], [3, 4, 5, 6], [7]]
&gt;&gt;&gt; map(None,*L)
[(1, 3, 7), (2, 4, None), (None, 5, None), (None, 6, None)]
</code></pre>

<p>For visualisation (with <code>.</code> representing <code>None</code>):</p>

<pre class="lang-py prettyprint-override"><code>1 2                1 3 7
3 4 5 6      -&gt;    2 4 .
7                  . 5 .
                   . 6 .
</code></pre>

<h2>filter</h2>

<p><code>filter</code> with <code>None</code> also assumes the identity function, thus removing falsy elements.</p>

<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; L = ["", 1, 0, [5], [], None, (), (4, 2)]
&gt;&gt;&gt; filter(None, L)
[1, [5], (4, 2)]
</code></pre>

<p>This is a bit better than a list comprehension:</p>

<pre class="lang-py prettyprint-override"><code>filter(None,L)
[x for x in L if x]
</code></pre>

<p>However, as @KSab notes, if all elements are of the same type then there may be shorter alternatives, e.g. <code>filter(str,L)</code> if all elements are strings.</p>
</div>
<div id="pu133" class="pu"><h2>Safely get the first element</h2>



<p>You can check if a possibly-empty list <code>l</code> starts with a value <code>x</code> by doing</p>

<pre class="lang-python prettyprint-override"><code>l[:1]==[x]
</code></pre>

<p>This gives <code>False</code> on an empty list, while <code>l[0]==x</code> gives an out-of-bounds error. Strings works similarly</p>

<pre class="lang-python prettyprint-override"><code>s[:1]=='a'
</code></pre>

<p>In general, you can safely check the <code>n</code>'th element as </p>

<pre class="lang-python prettyprint-override"><code>l[n:n+1]==[a]
</code></pre>

<p>or as <code>l[n:][:1]==[a]</code> when <code>n</code> is a long expression.</p>
</div>
<div id="pu134" class="pu"><h2>Avoid <code>startswith</code></h2>



<p>The string method <code>startswith</code> is too long. There are shorter ways to check if a string <code>s</code> starts with a prefix <code>t</code> of unknown length. </p>

<pre class="lang-python prettyprint-override"><code>t&lt;=s&lt;t+'~'     #Requires a char bigger than any in s,t
s.find(t)==0
s[:len(t)]==t    
s.startswith(t)
</code></pre>

<p>The second one is well-suited for the truth/falsity of the negation.</p>

<pre class="lang-python prettyprint-override"><code>if s.find(t):
</code></pre>
</div>
<div id="pu135" class="pu"><h2>Replace a value in a list</h2>



<p>To replace every entry of value <code>a</code> with <code>b</code> in a list <code>L</code>, use: </p>

<p><code>map({a:b}.get,L,L)</code></p>

<p>For example, </p>

<pre class="lang-python prettyprint-override"><code>L=[1,2,3,1,2,3]
a=2
b=3
print map({a:b}.get,L,L)

[1, 3, 3, 1, 3, 3]  #Output
</code></pre>

<p>In Python 3, this returns a <code>map</code> object rather than a list. The list entries can be any hashable values (ints, floats, strings, tuples, etc).  </p>

<p>Here's how this works. A dictionary's <code>get</code> method takes a key and default value, and returns the dictionary's entry for that key, using the default value is the key is not present. This method is mapped method over each entry in <code>L</code> both as the key and the default value, which results in</p>

<pre class="lang-python prettyprint-override"><code>[{a:b}.get(x,x) for x in L]
</code></pre>

<p>If <code>x</code> is <code>a</code>, then the dictionary transforms it to <code>b</code>, and otherwise, it defaults to itself. You can perform multiple replacements at the same time using a larger dictionary. </p>

<p>Credit to <a href="http://golf.shinh.org/reveal.rb?Swap%20The%20Characters/twobit_1413325607&amp;py">twobit on Anarchy Golf</a> for exposing me to this trick.</p>
</div>
<div id="pu136" class="pu"><h1>String keys to dicts</h1>

<p>For a dictionary with string keys which also happen to be valid Python variable names, you can get a saving if there's at least three items by using <code>dict</code>'s keyword arguments:</p>

<pre class="lang-py prettyprint-override"><code>{'a':1,'e':4,'i':9}
dict(a=1,e=4,i=9)
</code></pre>

<p>The more string keys you have, the more quote characters you'll save, so this is particularly beneficial for large dictionaries (e.g. for a kolmogorov challenge).</p>
</div>
<div id="pu137" class="pu"><p>Not read all the answers but you can instead of </p>

<pre><code>if x==3:
    print "yes"
else:
    print "no"
</code></pre>

<p>use </p>

<pre><code>print "yes" if x==3 else "no"
</code></pre>
</div>
<div id="pu138" class="pu"><h2>Use eval to iterate</h2>

<p>Say you want to apply <code>f</code> composed <code>k</code> times to the number <code>1</code>, then print the result.</p>

<p>This can be done via an <code>exec</code> loop,</p>

<pre class="lang-python prettyprint-override"><code>n=1
exec("n=f(n);"*k)
print(n)
</code></pre>

<p>which runs code like <code>n=1;n=f(n);n=f(n);n=f(n);n=f(n);n=f(n);print(n)</code>.</p>

<p>But, it's one character shorter to use <code>eval</code> </p>

<pre class="lang-python prettyprint-override"><code>print(eval("f("*k+'1'+")"*k))
</code></pre>

<p>which evaluates code like <code>f(f(f(f(f(1)))))</code> and prints the result.</p>

<p>This does not save chars in Python 2 though, where <code>exec</code> doesn't need parens but <code>eval</code> still does. It does still help though when <code>f(n)</code> is an expression in which <code>n</code> appears only once as the first or last character, letting you use only one string multiplication. </p>
</div>
<div id="pu139" class="pu"><h2>Build a string instead of joining</h2>

<p>To concatenate strings or characters, it can be shorter to repeatedly append to the empty string than to <code>join</code>.</p>

<p><strong>23 chars</strong></p>

<pre class="lang-python prettyprint-override"><code>s=""
for x in l:s+=f(x)
</code></pre>

<p><strong>25 chars</strong></p>

<pre class="lang-python prettyprint-override"><code>s="".join(f(x)for x in l)
</code></pre>

<p>Assume here that <code>f(x)</code> stands for some expression in <code>x</code>, so you can't just <code>map</code>. </p>

<p>But, the <code>join</code> may be shorter if the result doesn't need saving to a variable or if the <code>for</code> takes newlines or indentation.</p>
</div>
<div id="pu140" class="pu"><p>When using Python 3, for your final print statement, use <code>exit</code> to save one char (note: this prints to STDERR, so you might not be able to use this):</p>



<pre class="lang-python prettyprint-override"><code>print('x')
exit('x')
</code></pre>

<p><code>exit</code> even adds a trailing newline. There is one caveat, however: <code>exit(some_integer)</code> will not print.</p>
</div>
<div id="pu141" class="pu"><p>If you're using a built-in function repeatedly, it might be more space-efficient to give it a new name, if using different arguments:</p>

<pre><code>r=range
for x in r(10):
 for y in r(100):print x,y
</code></pre>
</div>
<div id="pu142" class="pu"><h1><a href="https://www.python.org/dev/peps/pep-3132/" rel="noreferrer">Extended iterable unpacking</a> ("Starred assignment", Python 3 only)</h1>

<p>The best way to explain this is via an example:</p>

<pre class="lang-python prettyprint-override"><code>&gt;&gt;&gt; a,*b,c=range(5)
&gt;&gt;&gt; a
0
&gt;&gt;&gt; b
[1, 2, 3]
&gt;&gt;&gt; c
4
</code></pre>

<p>We've already seen a use for this — <a href="https://codegolf.stackexchange.com/a/4389/21487">turning an iterable into a list in Python 3</a>:</p>

<pre class="lang-python prettyprint-override"><code>a=list(range(10))
*a,=range(10)
</code></pre>

<p>Here are a few more uses.</p>

<h2>Getting the last element from a list</h2>

<pre class="lang-python prettyprint-override"><code>a=L[-1]
*_,a=L
</code></pre>

<p>In some situations, this can also be used for getting the first element to save on parens:</p>

<pre class="lang-python prettyprint-override"><code>a=(L+[1])[0]
a,*_=L+[1]
</code></pre>

<h2>Assigning an empty list and other variables</h2>

<pre class="lang-python prettyprint-override"><code>a=1;b=2;c=[]
a,b,*c=1,2
</code></pre>

<h2>Removing the first or last element of a non-empty list</h2>

<pre class="lang-python prettyprint-override"><code>_,*L=L
*L,_=L
</code></pre>

<p>These are shorter than the alternatives <code>L=L[1:]</code> and <code>L.pop()</code>. The result can also be saved to a different list.</p>

<p><em>Tips courtesy of @grc</em></p>
</div>
<div id="pu143" class="pu"><h2>Store lookup tables as magic numbers</h2>

<p>Say you want to hardcode a Boolean lookup table, like which of the first twelve English numbers contain an <code>n</code>.</p>

<pre class="lang-python prettyprint-override"><code>0: False
1: True
2: False
3: False
4: False
5: False
6: False
7: True
8: False
9: True
10:True
11:True
12:False
</code></pre>

<p>Then, you can implement this lookup table concisely as:</p>

<pre class="lang-python prettyprint-override"><code>3714&gt;&gt;i&amp;1
</code></pre>

<p>with the resulting <code>0</code> or <code>1</code> being equal to <code>False</code> to <code>True</code>.</p>

<p>The idea is that the magic number stores the table as a bitstring <code>bin(3714)</code> = <code>0b111010000010</code>, with the <code>n</code>-th digit (from the end) corresponding the the <code>n</code>th table entry. We access the <code>n</code>th entry by bitshifting the number <code>n</code> spaces to the right and taking the last digit by <code>&amp;1</code>.</p>

<p>This storage method is very efficient. Compare to the alternatives</p>

<pre class="lang-python prettyprint-override"><code>n in[1,7,9,10,11]
'0111010000010'[n]&gt;'0'
</code></pre>

<p>You can have your lookup table store multibit entries that can be extracted like</p>

<pre class="lang-python prettyprint-override"><code> 340954054&gt;&gt;4*n&amp;15
</code></pre>

<p>to extract the relevant four-bit block.</p>
</div>
<div id="pu144" class="pu"><h2>Use ~ to index from the back of a list</h2>

<p>If <code>L</code> is a list, use <code>L[~i]</code> to get the <code>i</code>'th element from the back.</p>

<p>This is the <code>i</code>'th element of the reverse of <code>L</code>. The bit complement <code>~i</code> equals <code>-i-1</code>, and so fixes the off-by-one error from <code>L[-i]</code>.  </p>
</div>
<div id="pu145" class="pu"><p>Use extended slicing to select one string from many</p>

<pre class="lang-python prettyprint-override"><code>&gt;&gt;&gt; for x in 0,1,2:print"fbboaaorz"[x::3]
... 
foo
bar
baz
</code></pre>

<p>vs</p>

<pre class="lang-python prettyprint-override"><code>&gt;&gt;&gt; for x in 0,1,2:print["foo","bar","baz"][x]
... 
foo
bar
baz
</code></pre>

<p>In this Boolean two-string case, one can also write</p>

<pre class="lang-python prettyprint-override"><code>b*"string"or"other_string"
</code></pre>

<p>for </p>

<pre class="lang-python prettyprint-override"><code>["other_string","string"][b]
</code></pre>

<p>Unlike interleaving, this works for strings of any length, but can have operator precedence issues if <code>b</code> is instead an expression.</p>
</div>
<div id="pu146" class="pu"><p><strong>Adding vectors</strong></p>

<p>Python doesn't have a built-in way to do vector (component-wise) addition except with libraries. Say <code>a</code> and <code>b</code> are two equal-length lists of numbers you want to add. Instead of the list comprehension</p>

<pre class="lang-python prettyprint-override"><code>c=[a[i]+b[i]for i in range(len(a))]
</code></pre>

<p>you can use</p>

<pre class="lang-python prettyprint-override"><code>c=map(sum,zip(a,b))
</code></pre>

<p>This produces an annoying <code>map</code> object in Python 3, but it's shorter even if you have to convert to a list.</p>
</div>
<div id="pu147" class="pu"><p>A great thing I did once is:</p>

<pre class="lang-python prettyprint-override"><code>if 3 &gt; a &gt; 1 &lt; b &lt; 5: foo()
</code></pre>

<p>instead of:</p>

<pre class="lang-python prettyprint-override"><code>if a &gt; 1 and b &gt; 1 and 3 &gt; a and 5 &gt; b: foo()
</code></pre>

<p>Python’s comparison operators rock.</p>

<hr>

<p>Using that everything is comparable in Python 2, you can also avoid the <code>and</code> operator this way. For example, if <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code> are integers,</p>

<pre class="lang-python prettyprint-override"><code>if a&lt;b and c&gt;d:foo()
</code></pre>

<p>can be shortened by one character to:</p>

<pre class="lang-python prettyprint-override"><code>if a&lt;b&lt;[]&gt;c&gt;d:foo()
</code></pre>

<p>This uses that every list is larger than any integer.</p>

<p>If <code>c</code> and <code>d</code> are lists, this gets even better:</p>

<pre class="lang-python prettyprint-override"><code>if a&lt;b&lt;c&gt;d:foo()
</code></pre>
</div>
<div id="pu148" class="pu"><p><strong>Iterating over indices in a list</strong></p>

<p>Sometimes, you need to iterate over the indices of a list <code>l</code> in order to do something for each element that depends on its index. The obvious way is a clunky expression:</p>

<pre class="lang-python prettyprint-override"><code># 38 chars
for i in range(len(l)):DoStuff(i,l[i])
</code></pre>

<p>The Pythonic solution is to use <code>enumerate</code>:</p>

<pre class="lang-python prettyprint-override"><code># 36 chars
for i,x in enumerate(l):DoStuff(i,x)
</code></pre>

<p>But that nine-letter method is just too long for golfing.</p>

<p>Instead, just manually track the index yourself while iterating over the list.</p>

<pre class="lang-python prettyprint-override"><code># 32 chars
i=0
for x in l:DoStuff(i,x);i+=1
</code></pre>

<p>Here's some alternatives that are longer but might be situationally better</p>

<pre class="lang-python prettyprint-override"><code># 36 chars
# Consumes list
i=0
while l:DoStuff(i,l.pop(0));i+=1

# 36 chars
i=0
while l[i:]:DoStuff(i,l[i]);i+=1
</code></pre>
</div>
<div id="pu149" class="pu"><p>If you are doing something small in a for loop whose only purpose is to invoke a side effect (<code>pop</code>, <code>print</code> in Python 3, <code>append</code>), it might be possible to translate it to a list-comprehension. For example, from Keith Randall's answer <a href="https://codegolf.stackexchange.com/revisions/40297/1">here</a>, in the middle of a function, hence the indent:</p>



<pre class="lang-python prettyprint-override"><code>  if d&gt;list('XXXXXXXXX'):
   for z in D:d.pop()
   c=['X']
</code></pre>

<p>Can be converted to:</p>

<pre class="lang-python prettyprint-override"><code>  if d&gt;list('XXXXXXXXX'):
   [d.pop()for z in D]
   c=['X']
</code></pre>

<p>Which then allows this golf:</p>

<pre class="lang-python prettyprint-override"><code>  if d&gt;list('XXXXXXXXX'):[d.pop()for z in D];c=['X']
</code></pre>

<p>An <code>if</code> within a <code>for</code> works just as well:</p>

<pre class="lang-python prettyprint-override"><code>for i in range(10):
 if is_prime(i):d.pop()
</code></pre>

<p>can be written as</p>

<pre class="lang-python prettyprint-override"><code>[d.pop()for i in range(10)if is_prime(i)]
</code></pre>
</div>
<div id="pu150" class="pu"><p>You can use default arguments of a function to save some indentation, since</p>



<pre class="lang-python prettyprint-override"><code>def f(a,l=[1,2,3]):
 return sum(a==i for i in l)
</code></pre>

<p>is one byte shorter than</p>

<pre class="lang-python prettyprint-override"><code>def f(a):
 l=[1,2,3]
 return sum(a==i for i in l)
</code></pre>
</div>
<div id="pu151" class="pu">

<p>Abusing <code>try</code>/<code>except</code> blocks can sometimes save characters, especially for exiting out of nested loops or list comprehensions.  This:</p>

<pre class="lang-python prettyprint-override"><code>for c in s:
 for i in l:
  q=ord(c)==i
  if q:print i,c;break
 if q:break
</code></pre>

<p>... can become this, saving 3 characters:</p>

<pre class="lang-python prettyprint-override"><code>try:
 for c in s:
  for i in l:
   if ord(c)==i:print i,c;1/0
except:0
</code></pre>

<p>... which in this particular instance can be compressed even further using list comprehensions:</p>

<pre class="lang-python prettyprint-override"><code>try:[1/(ord(c)-i)for c in s for i in l]
except:print i,c
</code></pre>

<p>For an example, see e.g. <a href="https://codegolf.stackexchange.com/a/36492/16766">https://codegolf.stackexchange.com/a/36492/16766</a>.</p>
</div>
<div id="pu152" class="pu">

<p>When your program needs to return a value, you might be able to use a <code>yield</code>, saving one character:</p>

<pre class="lang-python prettyprint-override"><code>def a(b):yield b
</code></pre>

<p>However, to print it you'd need to do something like</p>

<pre class="lang-python prettyprint-override"><code>for i in a(b):print i
</code></pre>
</div>
<div id="pu153" class="pu">

<p>To find the all the indexes of a certain element in a list <code>l</code>, use </p>

<pre class="lang-python prettyprint-override"><code>filter(lambda x:l[x]==element,range(len(l)))
</code></pre>

<p>To find the next index after a certain index:</p>

<pre class="lang-python prettyprint-override"><code>l[:index].index(element)
</code></pre>

<p>To find the <code>n</code>th index:</p>

<pre class="lang-python prettyprint-override"><code>list(filter(lambda x:l[x]==element,range(len(l))))[n]
</code></pre>
</div>
<div id="pu154" class="pu">

<p>Cut out newlines wherever you can.</p>

<p>At the top-level, it doesn't matter.</p>

<pre class="lang-python prettyprint-override"><code>a=1
b=9
</code></pre>

<p>Takes the same amount of characters as:</p>

<pre class="lang-python prettyprint-override"><code>a=1;b=9
</code></pre>

<p>In the first case you have a newline instead of a <code>;</code>. But in function bodies, you save however deep the nesting level is:</p>

<pre class="lang-python prettyprint-override"><code>def f():
 a=1;b=9
</code></pre>

<p>Actually in this case, you can have them all on one line:</p>

<pre class="lang-python prettyprint-override"><code>def f():a=1;b=9
</code></pre>

<p>If you have an <code>if</code> or a <code>for</code>, you can likewise have everything on one line:</p>

<pre class="lang-python prettyprint-override"><code>if h:a=1;b=9
for g in(1,2):a=1;b=9
</code></pre>

<p>But if you have a nesting of control structures (e.g. <code>if</code> in a <code>for</code>, or <code>if</code> in a <code>def</code>), then you need the newline:</p>

<pre class="lang-python prettyprint-override"><code>if h:for g in(1,2):a=1;b=9 #ERROR

if h:
 for g in(1,2):a=1;b=9 # SAUL GOODMAN
</code></pre>
</div>
<div id="pu155" class="pu"><p>1 or 0 can act as boolean operators in Python:</p>



<pre class="lang-python prettyprint-override"><code>func = lambda x:1 if x//2==x/2 else 0
while 1:
    if func(n):
         print('Hello')
    else:
         exit()
</code></pre>

<p>Which is 10 characters shorter than:</p>

<pre class="lang-python prettyprint-override"><code>func = lambda x:True if x//2==x/2 else False
while True:
    if func(n):
         print('Hello')
    else:
         exit()
</code></pre>
</div>
<div id="pu156" class="pu"><h3>Use <code>+=</code> instead of <code>append</code> and <code>extend</code></h3>

<pre class="lang-python prettyprint-override"><code>A.append(B)  
</code></pre>

<p>can be shortened to:</p>

<pre class="lang-python prettyprint-override"><code>A+=B,
</code></pre>

<p><code>B,</code> here creates a one-element tuple which can be used to extend <code>A</code> just like <code>[B]</code> in <code>A+=[B]</code>.</p>

<hr>

<pre class="lang-python prettyprint-override"><code>A.extend(B)
</code></pre>

<p>can be shortened to:</p>

<pre class="lang-python prettyprint-override"><code>A+=B
</code></pre>
</div>
<div id="pu157" class="pu"><p>If you rely on data (mostly for kolmogorov-complexity problems), use the built-in zip encoding/decoding and store the data in a file (add +1 for the filename):</p>

<pre><code>open('f','rb').read().decode('zip')
</code></pre>

<p>If you have to store the data in the source code, then you need to encode the zip with base64 and do:</p>

<pre><code>"base64literal".decode('base64').decode('zip')
</code></pre>

<p>These don't necessarily save characters in all instances, though.</p>
</div>
<div id="pu158" class="pu"><p>You can generate pseudo random numbers using hash.</p>

<p><code>hash('V~')%10000</code></p>

<p>Will print 2014.</p>
</div>
<div id="pu159" class="pu"><p>For ages it bothered me that I couldn't think of a short way to get the entire alphabet. If you use <code>range</code> enough that <code>R=range</code> is worth having in your program, then</p>

<pre><code>[chr(i+97)for i in R(26)]
</code></pre>

<p>is shorter than the naive</p>

<pre><code>'abcdefghijklmnopqrstuvwxyz'
</code></pre>

<p>, but otherwise it's longer by a single character. It haunted me that the clever one that required some knowledge of ascii values ended up being more verbose than just typing all the letters.</p>

<p>Until I saw <a href="https://codegolf.stackexchange.com/a/25627/14509">this</a> answer for <a href="https://codegolf.stackexchange.com/questions/25625/my-daughters-alphabet">My Daughter's Alphabet</a>. I can't follow the edit history well enough to figure out if this genius was the work of the OP or if it was a suggestion by a commenter, but this is (I believe) the shortest way to create an iterable of the 26 letters in the Roman alphabet.</p>

<pre><code>map(chr,range(97,123))
</code></pre>

<p>If case doesn't matter, you can strip off another character by using uppercase:</p>

<pre><code>map(chr,range(65,91))
</code></pre>

<p>I use <code>map</code> way too much, I don't know how this never occurred to me.</p>
</div>
<div id="pu160" class="pu"><p>Run your code through an space-remover, like this one:</p>

<pre><code>#Pygolfer
a=raw_input()
for i in [i for i in range(len(a)) if a[i]==" "]:
    try:b=a[:i]+a[i+1:];eval(b);a=b;print a
    except:pass
</code></pre>

<p>(This just tries to remove the spaces one by one, and try if the code still works. Please still do check your code manually.)</p>

<p>Manual things to do:
<code>print'string'</code> works.</p>

<p><code>[str(i)for i in(1,2,3,4)]</code> works.</p>

<p>etc.</p>
</div>
<div id="pu161" class="pu"><p>If you need to import a lot of modules you can reassign <code>__import__</code> to something shorter, this also has the advantage of being able to name imports anything you want.</p>

<pre><code>i=__import__;s=i('string');x=i('itertools');
</code></pre>
</div>
<div id="pu162" class="pu"><p>When you have two boolean values, <code>a</code> and <code>b</code>, if you want to find out if both <code>a</code> and <code>b</code> are true, use <code>*</code> instead of <code>and</code>:</p>

<pre><code>if a and b: #7 chars
</code></pre>

<p>vs</p>

<pre><code>if a*b: #3 chars
</code></pre>

<p>if either value is false, it will evaluate as <code>0</code> in that statement, and an integer value is only true if it is nonzero.</p>
</div>
<div id="pu163" class="pu"><p>If you represent boolean values as numbers you can save characters. This is especially true for using <code>-1</code> as <code>True</code>.</p>

<p>Bitty conditionals work (Truth table):</p>

<pre><code>a  b   &amp;  |  ^ 
0  0   0  0  0
0  -1  0 -1 -1
-1 0   0 -1 -1
-1 -1 -1 -1  0
</code></pre>

<p>And <code>~</code> works as not:</p>

<pre><code> a ~a
 0 -1
-1  0
</code></pre>

<p>Even though the <code>-</code> for initializing <code>-1</code> costs one character, this can easily save characters overall.</p>

<p>Compare:</p>

<pre><code>while~a:
</code></pre>

<p>to:</p>

<pre><code>while not a:
</code></pre>
</div>
<div id="pu164" class="pu"><p>Sometimes you need convert boolean expression into integer (0/1)
Simple use this Boolean (in examples below <code>c &gt; 0</code>) in ariphmetic</p>

<pre><code>a=b+(c&gt;0)
a+=c&gt;0
a=sum(c&gt;0 for c in b) # space in "0 for" may be omitted
</code></pre>

<p>And sometimes you need simple convert boolean to int (for example for printing or convert to binary string). In programm you may use some variants</p>

<pre><code>1 if c&gt;0 else 0
c&gt;0and 1or 0
(0,1)[c&gt;0]
int(c&gt;0)
</code></pre>

<p>but shortest way is</p>

<pre><code>+(c&gt;0)
</code></pre>
</div>
<div id="pu165" class="pu"><p>If you have multidimensional array of numbers and for instance need to count all numbers greater than n.</p>

<p>First flatten the array, then apply filter function to match condition:</p>

<pre><code>l=[[1,[8,4,7,1],3],[5,[7],3,9],[7,3,9,[[[8]]]]]
n=5
flatten=lambda l: sum(map(flatten,l),[]) if isinstance(l,list) else [l]
len(filter(lambda x:x&gt;n,flatten(l)))
</code></pre>
</div>
<div id="pu166" class="pu"><p>Change <code>import *</code> to <code>import*</code></p>

<hr>

<p>If you haven't heard, <code>import*</code> saves chars!</p>

<pre><code>from math import*
</code></pre>

<p>is only 1 character longer than <code>import math as m</code> and you get to remove all instances of <code>m.</code></p>

<p>Even one time use is a saver!</p>
</div>
<div id="pu167" class="pu"><p>Be aware of <a href="http://docs.python.org/2/library/functions.html#all" rel="noreferrer"><code>all</code></a>, <a href="http://docs.python.org/2/library/functions.html#any" rel="noreferrer"><code>any</code></a> and <a href="http://docs.python.org/2/library/functions.html#map" rel="noreferrer"><code>map</code></a>:</p>

<pre><code>if isdigit(a) and isdigit(b) and isdigit(c)
if all(map(isdigit,[a,b,c]))
</code></pre>
</div>
<div id="pu168" class="pu"><p>Lets play with some list tricks</p>

<pre><code>a=[5,5,5,5,5,5,5]
</code></pre>

<p>can be written as:</p>

<pre><code>a=[5]*7
</code></pre>

<p>It can be expanded in this way. Lets, say we need to do something like</p>

<pre><code>for i in range(0,100,3):a[i]=5
</code></pre>

<p>Now using the slicing trick we can simply do:</p>

<pre><code>a[0:100:3]=[5]*(1+99//3)
</code></pre>
</div>
<div id="pu169" class="pu"><p>You only need to indent nested control structures:</p>

<pre><code>def baz(i):
 if i==0:i=1;print i;bar()
 while i:i+=foo(i-1)
</code></pre>
</div>
<div id="pu170" class="pu"><p>Was somewhat mentioned but I want to expand:</p>

<pre><code>[a,b],[c,d]=[[1,2],[3,4]]
</code></pre>

<p>works as well as simple a,b=[1,2]. Another great thing is to use ternary operator (similiar to C-like ?:)</p>

<pre><code>x if x&lt;3 else y
</code></pre>

<p>and no one mentioned map. Map will call first function given as first argument on each item from second argument. For example assume that a is a list of strings of integers (from user input for example):</p>

<pre><code>sum(map(int,a)) 
</code></pre>

<p>will make sum of all integers.</p>
</div>
<div id="pu171" class="pu"><p>Abuse the fact that in case of an expression yielding <code>True</code> boolean operators return the first value that decides about the outcome of the expression instead of a boolean:</p>

<pre><code>&gt;&gt;&gt; False or 5
5
</code></pre>

<p>is pretty straightforward. For a more complex example:</p>

<pre><code>&gt;&gt;&gt; i = i or j and "a" or ""
</code></pre>

<p>i's value remains unchanged if it already had a value set, becomes "a" if j has a value or in any other case becomes an empty string (which can usually be omitted, as i most likely already was an empty string).</p>
</div>
<div id="pu172" class="pu"><p>Just found out two new things. First, <code>input()</code> can parse tuples, like <code>1, 2, 3</code> is equivalent to the tuple <code>(1, 2, 3)</code>.</p>

<p>And if you need to convert a value to float, just multiply by <code>1.</code>. Yes, <code>1.</code> is valid syntax (At least in 2.6).</p>
</div>
<div id="pu173" class="pu"><p>use <code>os.urandom()</code> as a random source instead of <code>random.randint()</code></p>
</div>
<div id="pu174" class="pu"><p>loops up to 4 items may be better to supply a tuple instead of using range</p>

<pre><code>for x in 0,1,2:
</code></pre>

<p>vs</p>

<pre><code>for x in range(3):
</code></pre>
</div>
<div id="pu175" class="pu"><p>Use extended slicing to select one of two strings</p>

<pre><code>&gt;&gt;&gt; for x in-2,2:print"WoolrlledH"[::x]
... 
Hello
World
</code></pre>

<p>vs</p>

<pre><code>&gt;&gt;&gt; for x in 0,1:print["Hello","World"][x]
... 
Hello
World
</code></pre>
</div>
<div id="pu176" class="pu"><p>Sometimes you can use Python's <code>exec</code>-statement combined with string repetition, to shorten loops. Unfortunately, you can't often use this, but when you can you can get rid of a lot of long loop constructs. Additionally, because <code>exec</code> is a statement you can't use it in lambdas, but <code>eval()</code> might work (but <code>eval()</code> is quite restricted in what you can do with it) although it's 2 characters longer.</p>

<p>Here is an example of this technique in use: <a href="https://stackoverflow.com/questions/2892126/file-fix-it-codegolf-gcj-2010-1b-a/2892339#2892339">GCJ 2010 1B-A Codegolf Python Solution</a></p>
</div>
<div id="pu177" class="pu"><p>If you're doing somewhat more complex golfing that require something from the standard library to be used a lot, <code>import x as y</code> can save some space:</p>

<pre><code>import itertools as i
i.groupby(...) # same as itertools.groupby
</code></pre>
</div>
<div id="pu178" class="pu"><p>Use <code>os.read</code> to read all input:</p>

<pre><code>import os
s=os.read(0,1e9)
</code></pre>

<p>Which is shorter than</p>

<pre><code>import sys
s=sys.stdin.read()
</code></pre>

<p>Note that this has a limitation on input length, but it's so ridiculously large I'd say we're safe from the angry mob.</p>
</div>
<div id="pu179" class="pu"><p>Unless the following token starts with <code>e</code> or <code>E</code>. You can remove the space following a number.</p>

<p>For instance:</p>

<pre><code>if i==4 and j==4:
    pass
</code></pre>

<p>Becomes:</p>

<pre><code>if i==4and j==4:
    pass
</code></pre>

<p>Using this in complicated one line statements can save quite a few characters.</p>

<p>EDIT: as @marcog pointed out, <code>4or a</code> will work, but not <code>a or4</code> as this gets confused with a variable name.</p>
</div>
<div id="pu180" class="pu"><p>A one line function can be done with lambda:</p>

<pre><code>def c(a):
  if a &lt; 3: return a+10
  else: return a-5
</code></pre>

<p>can be converted to (note missing space <code>3and</code> and <code>10or</code>)</p>

<pre><code>c=lambda a:a&lt;3and a+10or a-5
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/54/">54</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




