<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::6671</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td></td><td>140506T194247Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/26721#26721">Geobits</a></td></tr>
<tr d-ix="1"><td>nan</td><td></td><td>180322T124917Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/159922#159922">Olivier </a></td></tr>
<tr d-ix="2"><td>nan</td><td></td><td>210527T152442Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/226350#226350">HK boy</a></td></tr>
<tr d-ix="3"><td>3295</td><td>You don't have to use Character.toLowerCasechar c. Instead use c|32. Instead of Character.toUpperCasechar c use c&95. This only works with ASCII letters.</td><td>141222T132319Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/42672#42672">TheNumbe</a></td></tr>
<tr d-ix="4"><td>nan</td><td></td><td>161117T103929Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/100149#100149">Kevin Cr</a></td></tr>
<tr d-ix="5"><td>nan</td><td></td><td>181127T162016Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/176628#176628">Olivier </a></td></tr>
<tr d-ix="6"><td>nan</td><td></td><td>150804T222719Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/54258#54258">ankh-mor</a></td></tr>
<tr d-ix="7"><td>nan</td><td></td><td>140408T170641Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/25499#25499">Ilya Gaz</a></td></tr>
<tr d-ix="8"><td>nan</td><td></td><td>171205T125955Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/149944#149944">Bernat</a></td></tr>
<tr d-ix="9"><td>nan</td><td></td><td>140629T203443Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/32732#32732">kernigh</a></td></tr>
<tr d-ix="10"><td>nan</td><td></td><td>170823T110537Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/140181#140181">Olivier </a></td></tr>
<tr d-ix="11"><td>nan</td><td></td><td>170810T150425Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/138424#138424">Kevin Cr</a></td></tr>
<tr d-ix="12"><td>nan</td><td></td><td>170504T070504Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/118806#118806">Kevin Cr</a></td></tr>
<tr d-ix="13"><td>nan</td><td>Sometimes</td><td>170807T051651Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/137905#137905">SoniEx2</a></td></tr>
<tr d-ix="14"><td>nan</td><td>If you use Java 8</td><td>170702T215720Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/129485#129485">Łukasz</a></td></tr>
<tr d-ix="15"><td>nan</td><td></td><td>160621T190928Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/83500#83500">SE is de</a></td></tr>
<tr d-ix="16"><td>nan</td><td></td><td>160707T124706Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/84753#84753">Kevin Cr</a></td></tr>
<tr d-ix="17"><td>nan</td><td></td><td>161028T135757Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/97838#97838">Kevin Cr</a></td></tr>
<tr d-ix="18"><td>nan</td><td>Sometimes</td><td>170105T202604Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/105792#105792">Addison </a></td></tr>
<tr d-ix="19"><td>nan</td><td></td><td>140221T101105Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/21634#21634">masterX2</a></td></tr>
<tr d-ix="20"><td>nan</td><td></td><td>161201T200850Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/101829#101829">Magic Oc</a></td></tr>
<tr d-ix="21"><td>nan</td><td></td><td>160621T111713Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/83475#83475">Kevin Cr</a></td></tr>
<tr d-ix="22"><td>nan</td><td></td><td>140418T200943Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/26026#26026">Geobits</a></td></tr>
<tr d-ix="23"><td>nan</td><td></td><td>140416T174712Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/25948#25948">Geobits</a></td></tr>
<tr d-ix="24"><td>nan</td><td>In most cases</td><td>160630T014226Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/84057#84057">SE is de</a></td></tr>
<tr d-ix="25"><td>nan</td><td></td><td>160621T154508Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/83486#83486">user9023</a></td></tr>
<tr d-ix="26"><td>nan</td><td></td><td>151125T022733Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/64713#64713">TheNumbe</a></td></tr>
<tr d-ix="27"><td>nan</td><td></td><td>151215T120930Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/66667#66667">Addison </a></td></tr>
<tr d-ix="28"><td>nan</td><td>If you need Integer.MAX_VALUE 2147483647</td><td>150925T190008Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/58736#58736">dfeuer</a></td></tr>
<tr d-ix="29"><td>nan</td><td></td><td>131220T131200Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/16100#16100">AJMansfi</a></td></tr>
<tr d-ix="30"><td>nan</td><td>We all know about the bitwise xor ^</td><td>140416T181005Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/25950#25950">Justin</a></td></tr>
<tr d-ix="31"><td>1010</td><td>If you ever have to use the boolean expressions true or false</td><td>140221T231628Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/21704#21704">user1220</a></td></tr>
<tr d-ix="32"><td>nan</td><td>If you use enum instead of class</td><td>120720T064917Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/6689#6689">user unk</a></td></tr>
<tr d-ix="33"><td>nan</td><td>If you are going to be using some method a lot</td><td>131220T073217Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/16089#16089">Justin</a></td></tr>
<tr d-ix="34"><td>006</td><td>For golfing that doesn't require input</td><td>131220T105315Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/16099#16099">Fabinout</a></td></tr>
<tr d-ix="35"><td>nan</td><td>Rather than using the import static java.lang.System.* technique to save on println statements</td><td>131231T183436Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/16948#16948">asteri</a></td></tr>
<tr d-ix="36"><td>nan</td><td>The argument to main doesn't have to be called args</td><td>120729T232022Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/6819#6819">daniero</a></td></tr>
<tr d-ix="37"><td>nan</td><td></td><td>120720T063950Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/6688#6688">user unk</a></td></tr>
<tr d-ix="38"><td>nan</td><td>I don't know if you would consider this 'pure' Java</td><td>120719T180147Z</td><td><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java/6680#6680">Noah</a></td></tr>
</table>
<div id="pu0" class="pu">
<p>This may seem obvious, but there are shorter options for some <code>Math</code> functions:</p>
<pre class="lang-java prettyprint-override"><code>a=Math.max(b,c);
a=b&gt;c?b:c;

a=Math.min(b,c);
a=b&lt;c?b:c;

a=Math.abs(b);
a=b&lt;0?-b:b;
(In certain situations, (a|1)%2*a, may be shorter)

a=Math.round(b);
a=(int)(b+.5);          // watch for precision loss if it matters
</code></pre>
</div>
<div id="pu1" class="pu"><h1>Use Java 10's <code>var</code></h1>
<p>If you define a single variable of a specific type, use <code>var</code>.</p>
<h3>Examples</h3>
<pre><code>var i=0;                        // int
var l=0L;                       // long
var s=&quot;&quot;;                       // String
var a=new int[]{1,2,3};         // int[]
var i=java.math.BigInteger.ONE; // BigInteger
var m=new java.util.HashMap();  // HashMap
var i=3+&quot;abc&quot;.length()          // int
var a=&quot;a b c&quot;.split(&quot; &quot;);       // String[]
for(var a:&quot;a b c&quot;.split(&quot; &quot;))   // String
</code></pre>
<h3>Not usable in any of the following examples</h3>
<p><code>var</code> cannot be used in many examples</p>
<pre><code>var i=1,j=2;           // only one variable is accepted at a time
var a={1,2,3};         // arrays must be explicitly declared
var f=a-&gt;a+&quot; &quot;;        // can't know what type a is.
var f=String::replace; // method references aren't properly inferred (weirdly, though)
</code></pre>
</div>
<div id="pu2" class="pu"><h2>Convert number to string</h2>
<p>It may seem obvious, you can shorten your code by adding the number to &quot;&quot;:</p>
<pre class="lang-java prettyprint-override"><code>// int a = 123
Integer.toString(a) // 0
String.valueOf(a)   // -2 chars
&quot;&quot;.valueOf(a)       // -6 chars
(&quot;&quot;+a)              // -13 chars
</code></pre>
</div>
<div id="pu3" class="pu"><p>You don't have to use <code>Character.toLowerCase(char c)</code>. Instead use <code>(c|32)</code>. Instead of <code>Character.toUpperCase(char c)</code> use <code>(c&amp;95)</code>. This only works with ASCII letters.</p>
</div>
<div id="pu4" class="pu">

<h1>Some small code-golfing tips</h1>

<p>These tips were a bit too small for a separated answers, so I will use this answer for very small codegolfing tips that I found or came up with, and aren't mentioned in the other tips yet:</p>

<h3>Removing the last character of a String:</h3>

<pre class="lang-java prettyprint-override"><code>// I used to do something like this:
s.substring(0,s.length()-1)     // 27 bytes

// But this is shorter:
s.replaceAll(".$","")           // 21 bytes
</code></pre>

<p>In some cases you know what the last character is beforehand, and you also know this character only occurs once in the String. In that case you can use <code>.split</code> instead:</p>

<pre class="lang-java prettyprint-override"><code>// As example: "100%" to "100"
s.split("%")[0]                 // 15 bytes
</code></pre>

<h3>Encoding shortcuts:</h3>

<pre class="lang-java prettyprint-override"><code>// When you want to get the UTF-8 bytes I used to do this:
s.getBytes("UTF-8");     // 20 bytes

// But you can also use "UTF8" for the same result:
s.getBytes("UTF8");      // 19 bytes
</code></pre>

<p>All encodings have a canonical name used in the <code>java.nio</code> API, as well as a canonical name used in the <code>java.io</code> and <code>java.lang</code> APIs. <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html" rel="noreferrer">Here is a full list of all supported encodings in Java.</a> So always use the shortest of the two; the second is usually shorter (like <code>UTF-8</code> vs <code>utf8</code>, <code>Windows-1252</code> vs <code>Cp1252</code>, etc.), but not always (<code>UTF-16BE</code> vs <code>UnicodeBigUnmarked</code>).</p>

<h3>Random boolean:</h3>

<pre class="lang-java prettyprint-override"><code>// You could do something like this:
new java.util.Random().nextBoolean()     // 36 bytes

// But as mentioned before in @Geobits' answer, Math.random() doesn't require an import:
Math.random()&lt;.5                         // 16 bytes
</code></pre>

<h3>Primes:</h3>

<p>There are a lot of different ways to check for primes or get all primes. <a href="https://codegolf.stackexchange.com/a/181611/52210">@SaraJ's answer here</a> is the shortest for positive integers (<span class="math-container">\$\geq1\$</span>), and <em>@primo</em>'s method is the shortest for integers <span class="math-container">\$\geq2\$</span>.</p>

<pre class="lang-java prettyprint-override"><code>// Check if n (≥ 1) is a prime (@SaraJ's method):
n-&gt;{int i=1;for(;n%++i%n&gt;0;);return n==i;}

// Check if n (≥ 2) is a prime (@primo's method):
n-&gt;{int i=n;for(;n%--i&gt;0;);return i&lt;2;}
</code></pre>

<p>These prime checks can be modified to loop over primes. Here doing so with <em>@SaraJ</em>'s approach for example:</p>

<pre class="lang-java prettyprint-override"><code>v-&gt;{for(int n=2,i;;){for(i=1;n%++i%n&gt;0;);if(n++==i)/*do something with prime `i` here*/;}}
</code></pre>

<p>NOTE: Usually you can merge it with other existing loops depending on how you want to use it, so you won't need a separate method. This saved a lot of bytes in <a href="https://codegolf.stackexchange.com/a/128774/52210">this answer</a> for example.</p>

<h3>Integer truncation instead of Math.floor/Math.ceil:</h3>

<p>If you are using <strong><em>positive</em></strong> doubles/floats and you want to <code>floor</code> them, don't use <code>Math.floor</code> but use an <code>(int)</code>-cast instead (since Java truncates on integers):</p>

<pre class="lang-java prettyprint-override"><code>double d = 54.99;

int n=(int)Math.floor(d);     // 25 bytes

int m=(int)d;                 // 13 bytes

// Outputs 54 for both
</code></pre>

<p>The same trick can be applied to <strong><em>negative</em></strong> doubles/floats you want to <code>ceil</code> instead:</p>

<pre class="lang-java prettyprint-override"><code>double d = -54.99;

int n=(int)Math.ceil(d);     // 24 bytes

int m=(int)d;                // 13 bytes

// Outputs -54 for both
</code></pre>

<h3>Use <code>&amp;1</code> instead of <code>%2</code> to get rid of parenthesis:</h3>

<p>Because the <a href="http://www.cs.bilkent.edu.tr/~guvenir/courses/CS101/op_precedence.html" rel="noreferrer">Operator Precedence</a> of <code>&amp;</code> is lower than default arithmetic operators like <code>*/+-</code> and <code>%</code>, you can get rid of parenthesis in some cases.</p>

<pre class="lang-java prettyprint-override"><code>// So instead of this:
(i+j)%2     // 7 bytes

// Use this:
i+j&amp;1       // 5 bytes
</code></pre>

<p>Note that this doesn't really help in boolean-checks, because then you'd still need parenthesis, they're just moved a bit:</p>

<pre class="lang-java prettyprint-override"><code>(i+j)%2&lt;1    // 9 bytes
(i+j&amp;1)&lt;1    // 9 bytes
</code></pre>

<h3>BigIntegers and creating variables for static method calls:</h3>

<p>When using BigIntegers, only create it once which you can then re-use. As you may know, BigInteger contains static fields for <code>ZERO</code>, <code>ONE</code> and <code>TEN</code>. So when you only use those three, you don't need an <code>import</code> but can use <code>java.Math.BigInteger</code> directly.</p>

<pre class="lang-java prettyprint-override"><code>// So instead of this:
import java.math.BigInteger.*;
BigInteger a=BigInteger.ONE,b=BigInteger.ZERO;                // 76 bytes

// or this:
java.math.BigInteger a=java.math.BigInteger.ONE,b=a.ZERO;     // 57 bytes

// Use this:
java.math.BigInteger t=null,a=t.ONE,b=t.ZERO;                 // 45 bytes                  
</code></pre>

<p>NOTE: You have to use <code>=null</code> so <code>t</code> is initialized in order to use <code>t.</code>.</p>

<p>Sometimes you can add multiple BigIntegers to create another to save bytes. So let's say you want to have the BigIntegers <code>1,10,12</code> for some reason:</p>

<pre class="lang-java prettyprint-override"><code>// So instead of this:
BigInteger t=null,a=t.ONE,b=t.TEN,c=new BigInteger(12);     // 55 bytes

// Use this:
BigInteger t=null,a=t.ONE,b=t.TEN,c=b.add(a).add(a);        // 52 bytes
</code></pre>

<p>As correctly pointed out in the comments, the trick with <code>BigInteger t=null;</code> for it's static method calls can also be used with other classes.<br>
For example, <a href="https://codegolf.stackexchange.com/a/1525/52210">this answer</a> from 2011 can be golfed:</p>

<pre class="lang-java prettyprint-override"><code>// 173 bytes:
import java.util.*;class g{public static void main(String[]p){String[]a=p[0].split(""),b=p[1].split("");Arrays.sort(a);Arrays.sort(b);System.out.print(Arrays.equals(a,b));}}

// 163 bytes
class g{public static void main(String[]p){java.util.Arrays x=null;String[]a=p[0].split(""),b=p[1].split("");x.sort(a);x.sort(b);System.out.print(x.equals(a,b));}}
</code></pre>

<h3><code>getBytes()</code> instead of <code>toCharArray()</code></h3>

<p>When you want to loop over the characters of a String, you'll usually do this:</p>

<pre class="lang-java prettyprint-override"><code>for(char c:s.toCharArray())    // 27 bytes
// or this:
for(String c:s.split(""))      // 25 bytes
</code></pre>

<p>Looping over the characters can be useful when printing them, or appending them to a String, or something similar.</p>

<p>However, if you only use the chars for some unicode-number calculations, you can replace the <code>char</code> with <code>int</code>, AND you can replace <code>toCharArray()</code> with <code>getBytes()</code>:</p>

<pre class="lang-java prettyprint-override"><code>for(int c:s.getBytes())        // 23 bytes
</code></pre>

<p>Or even shorter in Java 8+:</p>

<pre class="lang-java prettyprint-override"><code>s.chars().forEach(c-&gt;...)      // 22 bytes
</code></pre>

<p>In Java 10+ looping over the character to print can now also be done in 22 bytes:</p>

<pre class="lang-java prettyprint-override"><code>for(var c:s.split(""))         // 22 bytes
</code></pre>

<h3>Random item from a <code>List</code>:</h3>

<pre class="lang-java prettyprint-override"><code>List l=...;

// When we have an `import java.util.*;` in our code, shuffling is shortest:
return l.get(new Random().nextInt(l.size()));     // 45 bytes
return l.get((int)(Math.random()*l.size()));      // 44 bytes
Collections.shuffle(l);return l.get(0);           // 39 bytes

// When we don't have an `import java.util.*` in our code, `Math.random` is shortest:
return l.get(new java.util.Random().nextInt(l.size()));     // 55 bytes
return l.get((int)(Math.random()*l.size()));                // 44 bytes
java.util.Collections.shuffle(l);return l.get(0);           // 49 bytes
</code></pre>

<h3>Check if a String contains leading/trailing spaces</h3>

<pre class="lang-java prettyprint-override"><code>String s=...;

// I used to use a regex like this:
s.matches(" .*|.* ")     // 20 bytes
// But this is shorter:
!s.trim().equals(s)      // 19 bytes
// And this is even shorter due to a nice feature of String#trim:
s!=s.trim()              // 11 bytes
</code></pre>

<p>Why does this work, when <code>!=</code> on Strings is to check for reference instead of value in Java? Because <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#trim()" rel="noreferrer"><code>String#trim</code></a> will return "<em>A copy of this string with leading and trailing white space removed, or <strong>this string if it has no leading or trailing white space</strong>.</em>" I've used this, after someone suggested this to me, in <a href="https://codegolf.stackexchange.com/a/143387/52210">this answer of mine</a>.</p>

<h3>Palindrome:</h3>

<p>To check if a String is a palindrome (keeping in mind both even and odd lengths of Strings), this is the shortest (<code>.contains</code> works here because we know both the String itself and its reversed form are of equal length):</p>

<pre class="lang-java prettyprint-override"><code>String s=...;
s.contains(new StringBuffer(s).reverse())    // 41 bytes
</code></pre>

<p><code>.contains(...)</code> instead of <code>.equals(...+"")</code> thanks to <a href="https://codegolf.stackexchange.com/questions/153249/list-all-palindromic-prime-dates-between-0000-01-01-and-99999-12-31/153255#comment374815_153255"><em>@assylias</em>'s comment here</a>.</p>

<h3>Either is 0, or both are 0?</h3>

<p>I think most already know this one: if you want to check if either <code>a</code> or <code>b</code> is zero, multiply instead to save bytes:</p>

<pre class="lang-java prettyprint-override"><code>a==0|b==0    // 9 bytes
a*b==0       // 6 bytes
</code></pre>

<p>And if you want to check if both <code>a</code> and <code>b</code> are zero, you could use a bitwise-OR, or add them together if they are always positive:</p>

<pre class="lang-java prettyprint-override"><code>a==0&amp;b==0    // 9 bytes
(a|b)==0     // 8 bytes (if either `a`, `b` or both can be negative)
a+b&lt;1        // 5 bytes (this only works if neither `a` nor `b` can be negative)
</code></pre>

<h3>Even = 1, odd = -1; or vice-versa</h3>

<pre class="lang-java prettyprint-override"><code>// even = 1; odd = -1:
n%2&lt;1?1:-1        // 10 bytes
1-n%2*2           // 7 bytes

// even = -1; odd = 1:
n%2&lt;1?-1:1        // 10 bytes
n%2*2-1           // 7 bytes
</code></pre>

<p>The reason I add this was after seeing <code>k+(k%2&lt;1?1:-1)</code> in <a href="https://codegolf.stackexchange.com/a/64269/52210">this answer</a>:</p>

<pre class="lang-java prettyprint-override"><code>k+(k%2&lt;1?1:-1)    // 14 bytes

// This would already have been shorter:
k%2&lt;1?k+1:k-1     // 13 bytes

// But it can also be:
k%2*-2-~k         // 9 bytes
</code></pre>

<h3>Loop <code>n</code> times in Full Program</h3>

<p>If we have a challenge where a full program is mandatory, and we need to loop a specific amount of times, we can do the following:</p>

<pre class="lang-java prettyprint-override"><code>// instead of:
interface M{static void main(String[]a){for(int n=50;n--&gt;0;)/*do something*/}}  // 78 bytes
// we could do:
interface M{static void main(String[]a){for(M m:new M[50])/*do something*/}}    // 76 bytes
</code></pre>

<p>The same applies when we have to take this range as input:</p>

<pre class="lang-java prettyprint-override"><code>interface M{static void main(String[]a){for(int n=new Byte(a[0]);n--&gt;0;)/*do something*/}}  // 90 bytes
interface M{static void main(String[]a){for(M m:new M[new Byte(a[0])])/*do something*/}}    // 88 bytes
</code></pre>

<p>Credit to <a href="https://codegolf.stackexchange.com/questions/67921/what-is-the-smallest-positive-base-10-integer-that-can-be-printed-by-a-program-s#comment165935_67983"><em>@JackAmmo</em> in this comment</a>.</p>

<h3>try-finally instead of try-catch(Exception e), and when/how to use it</h3>

<p>If you have to catch and ignore an Exception, in most cases it's shorter to use <code>finally{...;}</code> instead of <code>catch(Exception){}</code>. Some examples:</p>

<p>When you want to return the result as soon as you hit an error:</p>

<pre class="lang-java prettyprint-override"><code>try{...}catch(Exception e){return ...;}    // 33 bytes
try{...}finally{return ...;}               // 22 bytes
</code></pre>

<p>I've used this initially to save bytes in <a href="https://codegolf.stackexchange.com/a/153993/52210">this answer of mine</a> (credit for the indirect golf goes to <em>@KamilDrakari</em>). In this challenge we have to loop diagonally over an NxM matrix, so we have to determine whether the amount of columns or amount of rows is the lowest as our maximum in the for-loop (which is quite expensive in terms of bytes: <code>i&lt;Math.min(a.length,a[0].length)</code>). So, simply catching the <code>ArrayIndexOutOfBoundsException</code> using <code>catch-finally</code> is shorter than this check, and thus saves bytes:</p>

<pre class="lang-java prettyprint-override"><code>int[] a = ...;

int r=0,i=0;for(;i&lt;Math.min(a.length,a[0].length);)r=...i++...;return r;    // 66 bytes

int r=0,i=0;try{for(;;)r=...i++...;}finally{return r;}                      // 48 bytes
</code></pre>

<p>This also works with a void <code>return;</code>, like this:</p>

<pre class="lang-java prettyprint-override"><code>try{...}catch(Exception e){}  // 25 bytes
try{...}finally{return;}      // 21 bytes
</code></pre>

<p>Which actually saved an additional byte in that same linked answer above by putting the answer in the very first cell, like <a href="https://codegolf.stackexchange.com/a/154011/52210"><em>@KamilDrakari</em> does in his C# answer</a> as well:</p>

<pre class="lang-java prettyprint-override"><code>m-&gt;{try{for(...);}finally{return;}}
</code></pre>

<p>But what about a try-catch where you don't want to immediately return? Unfortunately, you can't have a completely empty <code>finally{}</code> block as alternative to catch an Exception. You can however still use it inside a loop by using <code>continue</code> (or <code>break</code>) as alternatives. Here an example where we want to continue with the next iteration of the loop when an Exception occurs:</p>

<pre class="lang-java prettyprint-override"><code>for(...)try{...}catch(Exception e){}  // 30 bytes
for(...)try{...}finally{continue;}    // 28 bytes
</code></pre>

<p>I've used this approach in <a href="https://codegolf.stackexchange.com/a/154563/52210">this answer of mine</a> to save 2 bytes.</p>

<p>So when you can use a <code>return</code>, <code>continue</code> or <code>break</code>, it's always better to use <code>try{...}finally{...;}</code> instead of <code>try{...}catch(Exception e){}</code>. And in most cases, especially when checking boundaries of matrices, it's shorter to <code>try-finally</code> any <code>ArrayIndexOutOfBoundsExceptions</code>, instead of doing manual checks to see whether the indices are still in bounds.</p>

<h3>Math.pow(2,n)</h3>

<p>When you want a power of 2, a bit-wise approach is much shorter:</p>

<pre class="lang-java prettyprint-override"><code>(int)Math.pow(2,n)    // 16 bytes
(1&lt;&lt;n)                // 6 bytes
</code></pre>

<h3>Combining bit-wise and logical checks instead of using parenthesis</h3>

<p>I think it is well-known by now that <code>&amp;</code> and <code>|</code> can be used instead of <code>&amp;&amp;</code> and <code>||</code> in Java (boolean) logical checks. In some cases you'd still want to use <code>&amp;&amp;</code> instead of <code>&amp;</code> to prevent errors though, like <code>index &gt;= 0 &amp;&amp; array[index].doSomething</code>. If the <code>&amp;&amp;</code> would be changed to <code>&amp;</code> here, it will still evaluate the part where it uses the index in the array, causing an <code>ArrayIndexOutOfBoundsException</code>, hence the use of <code>&amp;&amp;</code> in this case instead of <code>&amp;</code>.</p>

<p>So far the basics of <code>&amp;&amp;</code>/<code>||</code> vs <code>&amp;</code>/<code>|</code> in Java.</p>

<p>When you want to check <code>(A or B) and C</code>, the shortest might seem to use the bit-wise operators like this:</p>

<pre class="lang-java prettyprint-override"><code>(A|B)&amp;C    // 7 bytes
</code></pre>

<p>However, because the bit-wise operators have <a href="https://introcs.cs.princeton.edu/java/11precedence/" rel="noreferrer">operator precedence</a> over the logical checks, you can combine both to save a byte here:</p>

<pre class="lang-java prettyprint-override"><code>A|B&amp;&amp;C     // 6 bytes
</code></pre>

<h3>Use <code>n+=...-n</code> instead of <code>(long)...</code></h3>

<p>When you have a long as both in and output in a lambda, for example when using <code>Math.pow</code>, you can save a byte by using <code>n+=...-n</code> instead of <code>(long)...</code>.<br>
For example:</p>

<pre class="lang-java prettyprint-override"><code>n-&gt;(long)Math.pow(10,n)    // 23 bytes
n-&gt;n+=Math.pow(10,n)-n     // 22 bytes
</code></pre>

<p>This saved a byte in <a href="https://codegolf.stackexchange.com/questions/161281/make-an-emergency-corridor/161346#161346">this answer of mine</a>, and even two bytes by combining <code>-n-1</code> to <code>+~n</code> in <a href="https://codegolf.stackexchange.com/questions/163737/return-the-highest-possible-placement-value-based-on-the-input/163783#163783">this answer of mine</a>.</p>
</div>
<div id="pu5" class="pu"><h1>Bit twiddling actions</h1>

<h2>Swap variables</h2>

<p>You might want to swap <code>int</code> and <code>long</code> variables. The usual way is to have a temporary variable:</p>

<pre><code>void swap(int a, int b) {
  int t=a;a=b;b=t;     //  16 bytes
  System.out.printf("a=%d, b=%d%n", a, b);
}
</code></pre>

<p>But you can shorten it like this:</p>

<pre><code>void swap(int a, int b) {
  a^=b^(b=a);          // 11 bytes
  System.out.printf("a=%d, b=%d%n", a, b);
}
</code></pre>

<p>Even if you reuse a temporary variable, it's just shorter to write that code, no matter the length of each variable name.</p>

<p>Does work with <code>short</code> and <code>byte</code> but at the cost of casting.</p>

<h2>Swap the variables so that the min is in a specific variable and the max is in the other</h2>

<p>You have <code>a</code> and <code>b</code> and you don't know which is greater. But you want <code>a</code> to contain the lowest and <code>b</code> to contain the greatest.</p>

<pre><code>void swapMinMax(int a, int b) {
  a^=b&lt;a?b^(b=a):0;            // 17 bytes
  System.out.printf("a=%d, b=%d%n", a, b);
}
</code></pre>
</div>
<div id="pu6" class="pu">

<h1>Try using <code>int</code> instead of <code>boolean</code></h1>

<p>In some cases I've found that it's shorter to return an integer value from a method that would normally return a boolean, similarly to what might be done in C programs.</p>

<p>Right off the bat <code>int</code> is 4 bytes shorter than <code>boolean</code>. Each time you write <code>return 0</code> instead of <code>return 1&lt;0</code>, you save an additional 2 bytes and the same for <code>return 1</code>  over <code>return 1&gt;0</code>.</p>

<p>The pitfall here is that each time you want to use the return value directly as a boolean, it costs 2 bytes (<code>if(p(n))</code> v. <code>if(p(n)&gt;0)</code>). This can be made up for by use of boolean arithmetic. Given a contrived scenario where you want to write</p>

<pre class="lang-java prettyprint-override"><code>void a(int[]t){t[0]+=p(n)?10:0;}
</code></pre>

<p>you can instead write </p>

<pre class="lang-java prettyprint-override"><code>void a(int[]t){t[0]+=p(n)*10;}
</code></pre>

<p>in order to save 2 bytes.</p>
</div>
<div id="pu7" class="pu"><p>Using Java Applet can save you a lot of space:</p>



<pre class="lang-java prettyprint-override"><code>import java.applet.Applet;

public class B extends Applet{
    public B(){
        System.out.print("Hello world!");
    }
}
</code></pre>

<p><strong>Output:</strong> </p>

<blockquote>
  <p>Hello world!</p>
</blockquote>

<p>Also this can be even more shorten by making <code>B</code> to extends nothing.</p>

<pre class="lang-java prettyprint-override"><code>public class B{
    public B(){
        System.out.print("Hello world!");
    }
}
</code></pre>

<p>How ever in additional to desired output we will also get exception:</p>

<p><strong>Output:</strong> </p>

<blockquote>
  <p>Hello world!<br>
  java.lang.ClassCastException: B cannot be cast to
  java.applet.Applet<br>
  at sun.applet.AppletPanel.createApplet(Unknown Source)<br>
  at sun.applet.AppletPanel.runLoader(Unknown Source)<br>
  at sun.applet.AppletPanel.run(Unknown Source)<br>
  at java.lang.Thread.run(Unknown Source)</p>
</blockquote>

<p>Also you can combine this with constructor block and save another 10 bytes like this:</p>

<pre class="lang-java prettyprint-override"><code>public class B{
    {
        System.out.println("Hello world!");
    }
}
</code></pre>

<p>Same output with exception as above.</p>
</div>
<div id="pu8" class="pu"><h1>Use <em>Try it online</em> to share lambdas</h1>
<p>If the solution can be writen in a lambda, <a href="https://tio.run/##nVVNbxoxEL33V4x86aIQRz3TIgH5PLSHpq3SVD14dw27ibHR2ouAKL@djr8WlgBJKiUSMDNvnp/fjB/YnJ2qGZcP@eN6nQmmNXxlpXz6AHB2BjfS8GrMMq7BFMwAqzjUmucwVhUINk1zpmHKlqCkWEKmpMFaYKBLOREcptwUKqcfEKyMSDCw2ABzVebAkk7P9vmmEHpST7k0IBG64qauJOY9t2uHW7Vpcmsq7APaY4RvEaeLQAdxRh4nlGQvWXRj7BDCeQsh38/FqpQqU6B4fHNAJvMdWG2YKTMYoHJfIOmc9p9ul9rwKVW1oTOEMkImZAAD0uk99zYFQ0ixQO/P1@3cEWQBnIxgRBxNXajKOJauqScFPr5dew6576NPCJzv1upNaYhjrffP91pKlqITDHtED0nVVqFgunVLod0DmpIKJie0qefHhLmAiygM9hwpqbFFFXrGhroLaW2OtqxNKei4lpkplaQR57O/zD6MX9faXn09m4myab915C0G7C0EIlJDYBIv8Aqujl6gi0dClwHvpR7xCt7EJsIENnFA@lBsrHH9ijWuozU2c3TXmqNFnCPWDGDqJ@rGQIlMhVYwU1qXzlQK6c9xzdTClDOxGTHtBqs5zR0srHKsm6JIDHmQk3RXPh@MZGNSY@QD7bPC7ju/CD9qCj8KzMK/jAmBWzKrq2rpxLJS4@@4O8e1cB0zlfOJEmMb9j1SnjFMAHbaT5EKpfTZ1nyCdGm452ptVTDZ0LU577u1d9xsH5Yom2ezX7XA9JBoP7W7Svhl17WshdhMfxRzR5DTqEgjxvw1JbZk2LjqvuWqVeIYzDu9ti/uYYUHxA7kHu53rTvfmicX9sea1anA0oDgHqIpeiD49s9fe0Td8e0Zte@b@5jSNCFDGJLwfc8OySi@Q4fDOc0Tck5iBqdVLcO71WxJO8z2qXGh8Ppam/IFz2pUzsa8WR3GmLIs4zOTkEu4JB6r2Z4RK6SgxG9A3MN7Qifc2IO1lmNEd7H/wi0oQ6xlQq5JAG8WXUPdJbzO/FCLBV0k5I508f/IxSwjkd@ks/XxcMGKrhI7DZ3gx@f1@h8" rel="nofollow noreferrer">Try it online</a> can help you format and reduce what characters need to be included in the solution.</p>
<p>See <a href="https://codegolf.stackexchange.com/a/149859/75506">this</a> for an example.</p>
</div>
<div id="pu9" class="pu">

<p>Don't use <code>public class</code>. The main method needs to be public, but its class doesn't. This code works:</p>

<pre class="lang-java prettyprint-override"><code>class S{public static void main(String[]a){System.out.println("works");}}
</code></pre>

<p>You may run <code>java S</code> even though <code>class S</code> is not a public class.  (<em>Update:</em> I was using Java 7 when I wrote this tip.  In Java 8, <a href="https://codegolf.stackexchange.com/a/64713/4065">your main method should be in an interface</a>.  In Java 5 or 6, <a href="https://codegolf.stackexchange.com/a/140181/4065">your main method should be in an enum</a>.)</p>

<p>Plenty of Java programmers don't know this! About half the answers to <a href="https://stackoverflow.com/q/12524322/3614563">a Stack Overflow question about main in non-public class</a> wrongly claim that the main method must be in a public class. Now you know better. Delete the <code>public</code> in <code>public class</code> and save 7 characters.</p>
</div>
<div id="pu10" class="pu"><h1>Shortest full program templates.</h1>

<h3>Introduction</h3>

<p>The <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html" rel="noreferrer">Java spec</a> never ever say that a full program must contain a <code>main</code> method. It only says:</p>

<blockquote>
  <p>The Java Virtual Machine starts execution by invoking the method main of some specified class, passing it a single argument, which is an array of strings.</p>
</blockquote>

<p>So to the best of our efforts, we can define a Java program as something which when invoked in this way will provide an output:</p>

<pre><code>$ javac A.java
$ java A
</code></pre>

<p>All the following templates do that.</p>

<h3>Java 8 (42 bytes)</h3>

<pre><code>interface A{static void main(String[]a){/* Your code here */}}
</code></pre>

<h3>Java 7 (45 bytes)</h3>

<pre><code>class A{public static void main(String[]a){/* Your code here */}}
</code></pre>

<h3>Java 5, 6 (12 or 27 bytes)</h3>

<pre><code>enum A{A;{/* Your code here */}}
</code></pre>

<p>This code above <strong>will</strong> write something on <code>stderr</code>. Usually something like <code>java.lang.NoSuchMethodError: main\nException in thread "main"</code>. If you can write on <code>stderr</code> after execution, use this!</p>

<pre><code>enum A{A;{/* Your code here */System.exit(0);}}
</code></pre>

<p>This code above is longer (27 bytes), but it <strong>will</strong> execute your code <strong>and</strong> avoid writing anything on <code>stderr</code>.</p>

<h3>Conclusion</h3>

<ol>
<li>Don't ever use Java 7.</li>
<li>If your program can be written in Java 5 or 6, use it. If your program can be written in Java 5 or 6, but is longer than a Java 8 version, always check if it could be shorter to write it in Java 5 or 6.</li>
</ol>
</div>
<div id="pu11" class="pu"><h1>Use <code>new Stack()</code> when you need basic <code>List</code> functionality</h1>

<p>When you need a <code>java.util.List</code> (for example when you want to <code>.add(Object)</code>, <code>.remove(Object)</code>, <code>java.util.Collections.shuffle(java.util.Collection)</code>, etc.), I used to use <code>java.util.ArrayList</code> in most of my answers. But I was recently tipped to use <code>java.util.Vector</code> instead, and <code>java.util.Stack</code> is even shorter:</p>
<pre class="lang-java prettyprint-override"><code>import java.util.*;

List a=new ArrayList();   // 23 bytes
List b=new Vector();      // 20 bytes
List c=new Stack();       // 19 bytes
</code></pre>
</div>
<div id="pu12" class="pu"><h1>Use <code>String#isEmpty()</code></h1>
<p>To check if a String is empty, you could use either of these:</p>
<pre><code>s.length()&lt;1  // 12 bytes
s.equals(&quot;&quot;)  // 12 bytes
</code></pre>
<p>However, using <code>.isEmpty()</code> is one byte shorter:</p>
<pre><code>s.isEmpty()   // 11 bytes
</code></pre>
<hr />
<p>Note that for Lists it's still shorter to check the size instead of using <code>isEmpty()</code>:</p>
<pre><code>l.size()&lt;1    // 10 bytes
l.isEmpty()   // 11 bytes
</code></pre>
</div>
<div id="pu13" class="pu"><p>Sometimes, you can use lambdas with iterators:</p>



<pre class="lang-java prettyprint-override"><code>// SUBOPTIMAL: Don't use lambdas here!
Iterator&lt;A&gt;i=a.iterator();for(A x:(Iterable&lt;A&gt;)()-&gt;i){if(x==y)break;}return i.hasNext()?i.next():null;
Iterator&lt;A&gt;i=a.iterator();for(;i.hasNext();){if(i.next()==y)break;}return i.hasNext()?i.next():null;
Iterator&lt;A&gt;i=a.iterator();while(i.hasNext()){if(i.next()==y)break;}return i.hasNext()?i.next():null;

// Lambdas save 11 bytes here!
Iterator&lt;A&gt;i=a.iterator();Iterable&lt;A&gt;j=()-&gt;i;for(A x:j){if(x==y)break;}for(A x:j){if(x==z)break;}return i.hasNext()?i.next():null;
Iterator&lt;A&gt;i=a.iterator();for(;i.hasNext();){if(i.next()==y)break;}for(;i.hasNext();){if(i.next()==z)break;}return i.hasNext()?i.next():null;
Iterator&lt;A&gt;i=a.iterator();while(i.hasNext()){if(i.next()==y)break;}while(i.hasNext()){if(i.next()==z)break;}return i.hasNext()?i.next():null;
</code></pre>
</div>
<div id="pu14" class="pu"><p>If you use Java 8, then you can:</p>

<h2>Replace Lambda expressions with method references</h2>

<p>Lambda expressions can be replaced with method references. Method reference has following form:</p>

<pre><code>ClassName::methodName
</code></pre>

<p>so if you use one letter names for classes it's shorter then lambda. Here are the rules</p>

<pre><code>lambda form                  |  reference method form
-------------------------------------------------------------------------------------------------
p -&gt; ClassName.methodName(p) |  ClassName::methodName
p -&gt; new ClassName(p)        |  ClassName::new
p -&gt; p.methodName()          |  ClassName::methodName // where ClassName is class of object p
(p, q) -&gt; p.methodName(q)    |  ClassName::methodName // where ClassName is class of object p
</code></pre>

<p>Examples (respectivly):</p>

<pre><code>lambda                       |  reference method
-------------------------------------------------------------------------------------------------
p -&gt; System.out.println(p)   |  System.out::println
p -&gt; new HashSet&lt;&gt;(p)        |  HashSet::new
p -&gt; p.getName()             |  Beer::getName 
(p, q) -&gt; p.compareTo(q)     |  String::compareTo
</code></pre>

<p>So, if ClassName is "C", then we have following length diffs:</p>

<pre><code>lambda form                  |  reference method form | length diff
-----------------------------------------------------------------------
p-&gt;C.methodName(p)           |  C::methodName         | 5 bytes
p-&gt;new C(p)                  |  C::new                | 5 bytes
p-&gt;p.methodName()            |  C::methodName         | 4 bytes
(p,q)-&gt;p.methodName(q)       |  C::methodName         | 9 bytes
</code></pre>

<h2>Simplify lambda expressions</h2>

<p>And here are some rules of simplifying lambda expressions.</p>

<p>General form of lambda expression is</p>

<pre><code>(parameters) -&gt; { statements;}  // (String a, String b) -&gt; {return a.compareTo(b);}
</code></pre>

<p>When there is only one expresion, it can be simplified as follows (<strong><code>return</code> should me ommitted</strong>):</p>

<pre><code>(parameters) -&gt; expression      // (String a, String b) -&gt; a.compareTo(b)
</code></pre>

<p>When <strong>type declaration can be ommited</strong>, it can be simplified as follows:</p>

<pre><code>(parameters) -&gt; expression      // (a, b) -&gt; a.compareTo(b)
</code></pre>

<p>When there is only one parameter and there is <strong>no need to declare type</strong>, it can be simplified as follows:</p>

<pre><code>parameter -&gt; expression         // (String s) -&gt; System.out.printout(s)
                                // to
                                // s -&gt; System.out.println(s)
</code></pre>
</div>
<div id="pu15" class="pu"><h1>Avoid <code>StringBuilder</code>s</h1>

<p>Appending stuff to a <code>String</code> takes up much fewer bytes.</p>

<pre><code>// s is a StringBuilder
s.append("Hello, World!");

// S is a String
S+="Hello, World!";
</code></pre>

<p>If you have to reverse a string and print it right away, use a <code>StringBuffer</code>.</p>

<pre><code>System.out.print(new StringBuilder("Hello, World!").reverse());
System.out.print(new StringBuffer("Hello, World!").reverse()); // Note that you can omit toString() when printing a non-String object
</code></pre>

<p>If you have to reverse a string and then do something else than printing it, use a <code>for</code>each loop.</p>

<pre><code>String b=new StringBuffer("Hello, World!").reverse().toString();
String B="";for(String c:"Hello, World!".split(""))B=c+B;
</code></pre>
</div>
<div id="pu16" class="pu"><h1>Convert String to number</h1>

<p>There are multiple ways to convert a String to an numeric value:</p>
<pre class="lang-java prettyprint-override"><code>String s = &quot;12&quot;;
</code></pre>
<p><em>ABC.parseABC</em>:</p>
<pre class="lang-java prettyprint-override"><code>Short.parseShort(s); // 20 bytes
Integer.parseInt(s); // 20 bytes
Long.parseLong(s);   // 18 bytes
</code></pre>
<p><em>ABC.valueOf</em>:</p>
<pre class="lang-java prettyprint-override"><code>Short.valueOf(s);    // 17 bytes
Integer.valueOf(s);  // 19 bytes
Long.valueOf(s);     // 16 bytes
</code></pre>
<p><em>ABC.decode</em>:</p>
<pre class="lang-java prettyprint-override"><code>// Note: does not work for numeric values with leading zeros,
// since these will be converted to octal numbers instead
Short.decode(s);     // 16 bytes
Integer.decode(s);   // 18 bytes
Long.decode(s);      // 15 bytes
</code></pre>
<p><em>new ABC</em>:</p>
<pre class="lang-java prettyprint-override"><code>new Short(s);        // 13 bytes
new Integer(s);      // 15 bytes
new Long(s);         // 12 bytes
</code></pre>
<p>So, for code-golfing, it's best to use the constructor when converting a String to a numeric value.</p>
<p>The same applies to <code>Double</code>; <code>Float</code>; and <code>Byte</code>.</p>
<hr />
<p>This doesn't always apply when you can re-use an already present primitive as object.<br />
As example, let's say we have the following code:</p>
<pre class="lang-java prettyprint-override"><code>// NOTE: Pretty bad example, because changing the short to int would probably be shorter..
//       but it's just an example to get the point across

short f(short i,String s){
  short r=new Short(s);  // 21 bytes
  ... // Do something with both shorts
}
</code></pre>
<p>You can use <code>.decode</code> instead of the shorter constructor by re-using the parameter as object:</p>
<pre class="lang-java prettyprint-override"><code>short f(Short i,String s){   // Note the short parameter has changed to Short here
  short r=i.decode(s);   // 20 bytes
  ... // Do something with both shorts
}
</code></pre>
</div>
<div id="pu17" class="pu">

<h1>Using <code>...</code> (varags) as parameter</h1>

<p>In some cases it's shorter to use a Java varargs as parameter instead of loose ones.<br>
For example:</p>

<pre class="lang-java prettyprint-override"><code>// Example input/output: 5, 4, 3 -&gt; 60000
int calculateVolumeInLiters(int width, int height, int depth){
  return width * height * depth * 1000;
}
</code></pre>

<p>Would be golfed by most to this:</p>

<pre class="lang-java prettyprint-override"><code>int c(int w,int h,int d){return w*h*d*1000;} // 44 bytes
</code></pre>

<p>But can be golfed an additional byte to this:</p>

<pre class="lang-java prettyprint-override"><code>int c(int...a){return a[0]*a[1]*a[2]*1000;}  // 43 bytes
</code></pre>

<p>Note that all three integers are only accessed once in the method itself. Since <code>int</code> is pretty short it is only beneficial if you use them each only once inside the method, and have three or more of them as parameter.</p>

<p>With longer parameters this is usually more useful though. For example, this was my original answer for <a href="https://codegolf.stackexchange.com/a/95457/52210">this challenge</a> (calculate occurances of input character in input string):</p>

<pre class="lang-java prettyprint-override"><code>// Example input/output: tttggloyoi, t -&gt; 3

int c(String a,char b){return a.replaceAll("[^"+b+"]","").length();} // 68 bytes
</code></pre>

<p>And I was recommended to golf it to this:</p>

<pre class="lang-java prettyprint-override"><code>int c(String a,char b){return a.split(b+"").length-1;}               // 54 bytes
</code></pre>

<p>But I ended up golfing it to this using <code>...</code>:</p>

<pre class="lang-java prettyprint-override"><code>int c(String...a){return a[0].split(a[1]).length-1;}                 // 52 bytes
</code></pre>

<hr>

<p>NOTE: If the question/challenge asks for a flexible input, the <code>...</code> can be shortened to <code>[]</code> of course. If the question/challenge specifically asks for, let's say, three <code>String</code> inputs and disallows an <code>String</code>-array containing three values, you can use <code>String...</code> instead of <code>String a,String b,String c</code>.</p>
</div>
<div id="pu18" class="pu"><p>Sometimes, a single for-loop statement might be replaceable. Consider the following code:</p>

<pre><code>int m(int x){int i=1;for(;x%++i==0;);return i;}
</code></pre>

<p>This is a simple for-loop which is a solution to <a href="https://codegolf.stackexchange.com/q/105412/44713">this question</a>.</p>

<p>Since we know that <code>i</code> will not be large enough to cause StackOverflow errors, we can replace the for-loop with recursion instead:</p>

<pre><code>int m(int x,int i){return x%++i&gt;0?i:m(x,i);}
</code></pre>

<p>We can simulate a loop by using a ternary operator in the return statement to cause recursion. </p>

<p>This reduction is rather specific, but I can imagine more situations where this would come in handy.</p>
</div>
<div id="pu19" class="pu"><p>With <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/language/varargs.html" rel="noreferrer">varargs</a> you can "cast" a parameter to an array of the same type:
</p>

<pre class="lang-java prettyprint-override"><code>void f(String...x){
    x=x[0].split("someregex");
    // some code using the array
}
</code></pre>

<p>instead of</p>

<pre class="lang-java prettyprint-override"><code>void f(String s){
    String[]x=s.split("someregex");
    // some code using the array
}
</code></pre>
</div>
<div id="pu20" class="pu"><h1>How to Draw in Java...</h1>

<p>Here's the shortest possible GUI paint boiler-plate:</p>

<pre><code>import java.awt.*;
static void main(String[]x){
    new Frame(){
        public void paint(Graphics g){
            // Draw your stuff here.
        }    
    }.show();
}
</code></pre>

<h1>Golfed for 111 Bytes:</h1>

<pre><code>import java.awt.*;static void main(String[]x){new Frame(){public void paint(Graphics g){/*CodeHere*/}}.show();}
</code></pre>
</div>
<div id="pu21" class="pu">

<p>When you have a method that should return a <code>boolean</code> or <code>Boolean</code>, i.e.:</p>

<pre class="lang-java prettyprint-override"><code>// Return true if the (non-negative) input is dividable by 5
boolean c(int i){return i%5&lt;1;}
</code></pre>

<p>You can change the <code>boolean</code>/<code>Boolean</code> return-type to <code>Object</code> to save 1 byte:</p>

<pre class="lang-java prettyprint-override"><code>Object c(int i){return i%5&lt;1;}
</code></pre>

<hr>

<p>In addition, as you may have noticed, you can use a <code>&lt;1</code> check instead of <code>==0</code> to save a byte. Although that is more a general code-golf tip instead of Java-specific.<br>
This is mostly used when the integer can't be negative, like checking for length:</p>

<pre class="lang-java prettyprint-override"><code>a.length&lt;1
</code></pre>

<p>instead of</p>

<pre class="lang-java prettyprint-override"><code>a.length==0
</code></pre>
</div>
<div id="pu22" class="pu">

<p><strong>Don't use <code>Random</code>!</strong></p>

<p><em>In general,</em> if you need random numbers, <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Random.html" rel="nofollow noreferrer"><code>Random</code></a> is a horrible way to go about it*. Much better to use <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#random--" rel="nofollow noreferrer"><code>Math.random()</code></a> instead. To use <code>Random</code>, you need to do this (let's say we need an <code>int</code>):</p>

<pre class="lang-java prettyprint-override"><code>import java.util.*;
Random r=new Random();
a=r.nextInt(9);
b=r.nextInt(9);
</code></pre>

<p>Compare that to:</p>

<pre class="lang-java prettyprint-override"><code>a=(int)(Math.random()*9);
b=(int)(Math.random()*9);
</code></pre>

<p>and:</p>

<pre class="lang-java prettyprint-override"><code>int r(int m){return(int)(Math.random()*m);}
a=r(9);
b=r(9);
</code></pre>

<p>The first method takes <code>41+15n</code> characters (<code>n</code> is number of calls).
The second is <code>25n</code> characters, and the third is <code>43+7n</code>.</p>

<p>So, if you only need it once or twice, use the inline <code>Math.random()</code> method. For three or more calls, you'll save by using a function. Either one saves characters on the <em>first use</em> over <code>Random</code>.</p>

<hr>

<p>If you're already using <code>Math.random()</code> for <code>double</code>, remember that at four uses, it's still a savings to pull it out into:</p>

<pre class="lang-java prettyprint-override"><code>double r(){return Math.random();}
</code></pre>

<p>For 33 characters, you'll save 10 on each call to <code>r()</code></p>

<hr>

<p><strong>Update</strong> </p>

<p>If you need an integer and want to save on casting, <em>don't cast it!</em> Java auto-casts if you do an operation instead of an assignment. Compare:</p>

<pre class="lang-java prettyprint-override"><code>a=(int)(Math.random()*9);
a=9;a*=Math.random();
</code></pre>

<p><sup>* <em>Unless you have to seed the PRNG for predictable results. Then, I don't see much of a way around it.</em></sup></p>
</div>
<div id="pu23" class="pu">

<p>If you need to grab <em>a number</em> from an argument (or any other string), normally you see something like:</p>

<pre class="lang-java prettyprint-override"><code>public static void main(String[]a){
    int n=Integer.valueOf(a[0]);
    ...
}
</code></pre>

<p>Many times, you don't <em>need</em> an <code>Integer</code>. Plenty of challenges don't use large numbers. Since <code>Short</code> and <code>Byte</code> will both unbox to an <code>int</code>, use the more appropriate <code>valueOf()</code> instead and save a couple bytes.</p>

<p>Keep your actual <em>variable</em> as an <code>int</code>, though, since it's shorter than both <code>byte</code> and <code>short</code>:</p>

<pre class="lang-java prettyprint-override"><code>int n=Byte.valueOf(a[0]);
</code></pre>

<p>If you need to do this for multiple numbers, you can combine with <a href="https://codegolf.stackexchange.com/a/16089/14215">this method</a>:</p>

<pre class="lang-java prettyprint-override"><code>Byte b=1;
int n=b.valueOf(a[0]),m=b.valueOf(a[1])...
</code></pre>
</div>
<div id="pu24" class="pu"><p>In most cases, your program will be single-threaded, i.e it'll have only one thread running. You can exploit this fact by <code>return</code>ing from the main method when you have to exit instantly.</p>

<pre><code>static void main(String[]a){if(condition)return;}
</code></pre>

<p>Compare it to "properly" terminating the program:</p>

<pre><code>static void main(String[]a){if(condition)System.exit(0);}
</code></pre>

<p>Or pointing to <code>null</code>:</p>

<pre><code>static void main(String[]a){if(condition)throw null;}
</code></pre>

<p>Or dividing by 0:</p>

<pre><code>static void main(String[]a){if(condition)int A=1/0;}
</code></pre>
</div>
<div id="pu25" class="pu"><h1>Don't be afraid to use scientific notation</h1>
<p>If you are dealing with doubles, or floats, you can use scientific notation for numbers. So instead of writing <code>double a=1000</code> you can change it to <code>double a=1e3</code> to save 1 byte.</p>
</div>
<div id="pu26" class="pu">

<p><strong>Use <code>interface</code> instead of <code>class</code>.</strong></p>

<p>In java 8, static methods were added to interfaces. In interfaces, all methods are public by default. Consequently</p>

<pre class="lang-java prettyprint-override"><code>class A{public static void main(String[]a){}}
</code></pre>

<p>can now be shortened to</p>

<pre class="lang-java prettyprint-override"><code>interface A{static void main(String[]a){}}
</code></pre>

<p>which is obviously shorter.</p>

<p>For example, <a href="https://codegolf.stackexchange.com/a/64567/32700">I used</a> this feature in the <a href="https://codegolf.stackexchange.com/q/55422/32700">Hello, World!</a> challenge.</p>
</div>
<div id="pu27" class="pu"><h2>Shortening returning</h2>

<p>You can shorten return statements of strings by a byte with:</p>

<pre><code>return "something";</code></pre>

<p>to</p>

<pre><code>return"something";</code></pre>

<p>And, if you happen to begin your return statement with a parenthesis, you can do the same thing with them:</p>

<pre><code>return (1+taxRate)*value;</code></pre>

<p>to</p>

<pre><code>return(1+taxRate)*value;</code></pre>

<p>I guess quotes are considered like parentheticals? I actually picked this up through AppleScript, funnily enough, and thought it might be worth mentioning.</p>
</div>
<div id="pu28" class="pu"><p>If you need <code>Integer.MAX_VALUE</code> (2147483647), use <code>-1&gt;&gt;&gt;1</code>. <code>Integer.MIN_VALUE</code> (-2147483648) is better written <code>1&lt;&lt;31</code>.</p>
</div>
<div id="pu29" class="pu">

<ul>
<li><p>Use the most recent possible java. Java 8 lets you use lambda expressions, so use it if you need anything even <em>like</em> functional objects.</p></li>
<li><p>Define shortened functions for things you use a lot. For instance, you have a hundred calls to <code>exampleClassInstance.doSomething(someParameter)</code>, define a new function <code>void d(ParameterType p){exampleClassInstance.doSomething(p)}</code> and use it to save yourself some characters.</p></li>
<li><p>If you are using a particular long class name more than once, like</p>

<pre class="lang-java prettyprint-override"><code>MyEventHandlerProxyQueueExecutorServiceCollectionAccessManagerFactory
</code></pre>

<p>instead define a new class:</p>

<pre class="lang-java prettyprint-override"><code>class X extends MyEventHandlerProxyQueueExecutorServiceCollectionAccessManagerFactory{}
</code></pre>

<p>If you are only using one particular method of that class (but still need to instantiate it), you can define a shortened version inside the new class at the same time.</p></li>
<li><p>Use function type parameters to shorten things, where possible, like this:</p>

<pre class="lang-java prettyprint-override"><code>&lt;T&gt;void p(T o){System.out.println(o);}
</code></pre></li>
<li><p>Use <code>for(;;)</code> instead of <code>while(true)</code>.</p></li>
<li><p>Do not use access modifiers unless absolutely necessary.</p></li>
<li><p>Do not use <code>final</code> for anything.</p></li>
<li><p>Never put a block after a <code>for</code> loop (but a foreach loop <code>for(x:y)</code> is different). Additional statements should be placed inside the <code>for</code> statement itself, like <code>for(int i=0;i&lt;m;a(i),b(++i))c(i);</code>.</p></li>
<li><p>Use inline assignment, incrementation, instantiation. Use anonymous inline classes where appropriate. Use lambdas instead if possible. Nest function calls. Some functions are guaranteed to return their parent object, these ones are actually even <em>meant</em> to be chained together.</p></li>
<li><p>Your <code>main</code> method <code>throws Exception</code>s, not catches them.</p></li>
<li><p><code>Error</code> is shorter than <code>Exception</code>. If for some reason you <em>really</em> need to <code>throw</code> messages up the stack, use an <code>Error</code>, even if it is perfectly normal situation.</p></li>
<li><p>If some condition would require immediate termination, use <code>int a=1/0;</code> rather than <code>throw null;</code> or <code>System.exit(0);</code>. At run time, this throws an <code>ArithmeticException</code>.  If you already have a numeric variable in your code, use it instead. (If you already have <code>import static java.lang.System.*;</code>, go with <code>exit(0);</code>.)</p></li>
<li><p>Instead of implementing interfaces, like <code>List&lt;E&gt;</code>, extend an immediate (or not-so-immediate, if there is any advantage to doing so at all) child class, like <code>AbstractList&lt;E&gt;</code>, which provides default implementations of most of the methods, and requires only the implementation of a few key pieces.</p></li>
<li><p>Write your code out in longhand first, with newlines, indentation, and full variable names. Once you have working code, then you can shorten names, move declarations around, and add shortcut methods. By writing it out long to start, you give yourself more opportunity to simplify the program as a whole.</p></li>
<li><p>Compare alternative optimizations to a piece of code, because the most optimal strategy can change dramatically with very small changes to the code. For instance:</p>

<ul>
<li>If you have only up to two calls to <code>Arrays.sort(a)</code>, the most efficient way to is to call it with its fully qualified name, <code>java.util.Arrays.sort(a)</code>.</li>
<li>With three or more calls, it is more efficient to instead add a shortcut method <code>void s(int[]a){java.util.Arrays.sort(a);}</code>. This should still use the fully-qualified name in this case. (If you need more than one overload, you are probably doing it wrong.)</li>
<li>However, if your code needs to also copy an array at some point (usually done with a short <code>for</code> loop in golfing, in the absence of an easily-accessible library method), you can take advantage of <code>Arrays.copyOf</code> to do the task. When more than one method is used, and there are 3 or more calls, doing <code>import static java.util.Arrays.*;</code> is the most efficient way of referring to those methods. After that, only if you have more than 8 separate calls to <code>sort</code> should you be using a shortcut method for it, and only at 5 or more calls is a shortcut warranted for <code>copyOf</code>.</li>
</ul>

<p>The only real way of performing such analysis on code is to actually perform potential modifications on copies of the code, and then compare the results.</p></li>
<li><p>Avoid using <code>someTypeValue.toString();</code> method, instead just append <code>someTypeValue+""</code>.</p></li>
<li><p>If you do need windows, don't use Swing, use AWT (unless you really need something from Swing). Compare <code>import javax.swing.*;</code> and <code>import java.awt.*;</code>. Additionally, components in Swing have a <code>J</code> prepended to their name (<code>JFrame</code>, <code>JLabel</code>, etc), but components in AWT don't (<code>Frame</code>, <code>Label</code>, etc)</p></li>
</ul>
</div>
<div id="pu30" class="pu"><p>We all know about the bitwise xor (<code>^</code>), but it is also a logical xor. </p>

<p>So <code>(a||b)&amp;&amp;!(a&amp;&amp;b)</code> simply becomes <code>a^b</code>.</p>

<p>Now we can use xor.</p>

<p><a href="https://codegolf.stackexchange.com/questions/6671/tips-for-golfing-in-java#comment56317_25950" title="Thanks to Geobits">Additionally</a>, the operators <code>|</code> and <code>&amp;</code> <a href="http://ideone.com/rG4XIq" rel="noreferrer">also work</a>, just remember that operator precedence changes.</p>
</div>
<div id="pu31" class="pu"><p>If you ever have to use the boolean expressions <code>true</code> or <code>false</code>, replace them with <code>1&gt;0</code> and <code>1&lt;0</code> respectively.</p>

<p>For example:</p>



<pre class="lang-java prettyprint-override"><code>boolean found=false;
for(i=0; i&lt;10; i++) if(a[i]==42) found=true;
</code></pre>

<p>This linear search example can be reduced to</p>

<pre class="lang-java prettyprint-override"><code>boolean f=1&lt;0;
for(i=0;i&lt;10;)if(a[i++]==42)f=1&gt;0;
</code></pre>
</div>
<div id="pu32" class="pu"><p>If you use <strong>enum instead of class</strong>, you save one character. </p>

<pre class="lang-java prettyprint-override"><code>enum NoClass {
    F, G, H;    
    public static void main (String[] args) {

    }
}
</code></pre>

<p>But you have to introduce at least one enum instance (F, G, H in this example) which have to payoff themselves. </p>
</div>
<div id="pu33" class="pu"><p>If you are going to be using some method a lot, assign its resident class to a variable. For example, assign <code>System.out</code> to a variable:</p>

<pre class="lang-java prettyprint-override"><code>java.io.PrintStream o=System.out;
//now I can call o.print() or o.println() to the same effect as System.out.println()
</code></pre>

<p>Also for <code>Integer.parseInt()</code>:</p>

<pre class="lang-java prettyprint-override"><code>Integer i=1;
i.parseInt("some string");
</code></pre>

<p>This will almost surely trigger an ide warning about "accessing static method from variable"</p>
</div>
<div id="pu34" class="pu"><p>For golfing that doesn't require input, you can use static blocks, and run it just fine without any main method, just compile it with Java 6.</p>

<pre class="lang-java prettyprint-override"><code>public class StaticExample{
    static {
        //do stuff
    }
}
</code></pre>
</div>
<div id="pu35" class="pu"><p>Rather than using the <code>import static java.lang.System.*</code> technique to save on <code>println()</code> statements, I've found that defining the following method is much more effective at saving characters:</p>

<pre class="lang-java prettyprint-override"><code>static&lt;T&gt;void p(T p){
    System.out.println(p);
}
</code></pre>

<p>This is because it can be invoked as <code>p(myString)</code> rather than <code>out.println(myString)</code> which has a much quicker and more dramatic character payoff.</p>
</div>
<div id="pu36" class="pu"><p>The argument to <code>main</code> doesn't have to be called <code>args</code>, and you can cut some whitespace:</p>

<pre class="lang-java prettyprint-override"><code>public static void main(String[]a){}
</code></pre>

<p>will do just fine.</p>
</div>
<div id="pu37" class="pu"><p>With a <strong>static import</strong>:</p>

<pre class="lang-java prettyprint-override"><code>import static java.lang.System.out;
// even shorter (thanks to Johannes Kuhn):
import static java.lang.System.*;
</code></pre>

<p>you can save some boilerplate later, but you need multiple invocations to reach a payoff:</p>

<pre class="lang-java prettyprint-override"><code>public static void main (String[] args) {
    out.println ("foo");    
    out.println ("bar");    
    out.println ("baz");    
}
</code></pre>
</div>
<div id="pu38" class="pu"><p>I don't know if you would consider this 'pure' Java, but <a href="http://www.processing.org">Processing</a> allows you to create programs with little initial setup (completed automatically).</p>

<p>For console output, you can have something as simple as:</p>

<pre><code>println("hi"); //done
</code></pre>

<p>for graphical output, a little more:</p>

<pre><code>void setup() {
  size(640,480);
}
void draw() {
  fill(255,0,0); //color used to fill shapes
  rect(50,50,25,25); //25x25 pixel square at x=50,y=50
}
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/6671/">6671</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




