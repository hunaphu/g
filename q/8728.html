<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::8728</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>524</td><td>APLNARS</td><td>250225T212556Z</td><td><a href="https://codegolf.stackexchange.com/questions/8728/balance-chemical-equations/278388#278388">Rosario</a></td></tr>
<tr d-ix="1"><td>442</td><td>C gcc</td><td>121016T230611Z</td><td><a href="https://codegolf.stackexchange.com/questions/8728/balance-chemical-equations/8733#8733">baby-rab</a></td></tr>
<tr d-ix="2"><td>510</td><td>Wolfram Language Mathematica</td><td>121018T155211Z</td><td><a href="https://codegolf.stackexchange.com/questions/8728/balance-chemical-equations/8744#8744">DavidC</a></td></tr>
<tr d-ix="3"><td>879</td><td>Python 2</td><td>121017T202834Z</td><td><a href="https://codegolf.stackexchange.com/questions/8728/balance-chemical-equations/8740#8740">jadkik94</a></td></tr>
<tr d-ix="4"><td>640</td><td>Python 2</td><td>161225T000334Z</td><td><a href="https://codegolf.stackexchange.com/questions/8728/balance-chemical-equations/104463#104463">Adalynn</a></td></tr>
<tr d-ix="5"><td>682</td><td>JavaScript</td><td>161231T004420Z</td><td><a href="https://codegolf.stackexchange.com/questions/8728/balance-chemical-equations/105142#105142">Adalynn</a></td></tr>
<tr d-ix="6"><td>705</td><td>Javascript</td><td>161225T064925Z</td><td><a href="https://codegolf.stackexchange.com/questions/8728/balance-chemical-equations/104480#104480">kuilin</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>APL(NARS), 524 chars</h1>
<pre><code>r←f w;t;m;n;d;b;h;lb;a;la;i;j;M;z
r←'Nope'⋄w,←' '⋄lb←≢b←∪{(⍵∊⎕A∪⎕a)⊂⍵}t←∊2{(((⍵∊⎕A)∧⍺∊⎕a)∨(⍵∊'-+ &gt;')∧⍺∊⎕A∪⎕a)∨∧/(⍺⍵)∊⎕A:⍺,'1'⋄⍺}/w
m←(t≠'-')⊂t⋄d←{((⍵∊⎕A∪⎕a)⊂⍵)(⍺×⍎¨(⍵∊⎕D)⊂⍵)}⋄h←{(∼⍵∊'+-&gt; ')⊂⍵}
a←1 d¨h 1⊃m⋄la←≢a,←¯1 d¨h 2⊃m⋄i←1⋄M←⍬
A:→D×⍳i&gt;la⋄(m n)←i⊃a⋄j←0⋄i+←1
B:j+←1⋄→A×⍳j&gt;lb⋄→C×⍳∼⍬≢t←⍸{⍵≡↑b[j]}¨m⋄M,←+/n[t]⋄→B
C:M,←0⋄→B
D:→E×⍳∼(+/M)≡0⍴⍨↑⍴M←⍉(la)(⌊la÷⍨≢M)⍴M←M×1x⋄m←1⍴⍨2⊃⍴M⋄→L
E:→0×⍳0&gt;z←-/⌽⍴M⋄n←+/-M[;⍳z]⋄→0×⍳0=-.×M←0 z↓M⋄m←(z⍴1),n⌹M
L:→0×⍳∨/m≤0⋄m←{⍵≡,'1':''⋄⍵}¨⍕¨m×←∧/÷¨m⋄r←∊t[≢t],⍨2{⍺[≢⍺]='-':⍺,'&gt;'⋄⍺,'+'}/t←m,¨(∼w∊'+&gt;')⊂w
</code></pre>
<p>//34+97+62+38+30+51+10+55+57+90=524</p>
<p>If the homogeneous linear system has more equation than unknows (the matrix has more rows than columns), I return &quot;Nope&quot; (if the sum of each rows is not 0) even if one solution could exist because some rows could be linear combination other rows in the matrix.
If the system has less equation than unknows, I consider the vector is the sum of the first
z=N unknows-N equatios=N column-N rows columns, vector <code>n←+/-M[;⍳z]</code> the matrix
<code>M←0 z↓M</code> for find solution
with <code>(z⍴1),n⌹M</code>.<br />
if the system has equation=unknows, z=0, I don't know what happen worse than other cases...
What would be <code>n</code> in <code>n←+/-M[;⍳z]</code>? What would be <code>m</code> in <code>m←(z⍴1),n⌹M</code>?</p>
<p>Test:</p>
<pre><code>  f 'Pb-&gt;Au'
Nope
  f 'Pb3-&gt;Pb'
Pb3-&gt;3Pb 
  f 'H2+O3-&gt;HO+O'
H2+O3-&gt;2HO+O 
  f 'Al+Fe2O3-&gt;Fe+Al2O3'
2Al+Fe2O3-&gt;2Fe+Al2O3 
  f 'Al+FeO3-&gt;Fe+Al2O3'
2Al+FeO3-&gt;Fe+Al2O3 
  f 'C7H16+O2-&gt;CO2+H2O'
C7H16+11O2-&gt;7CO2+8H2O 
  f 'Al+Fe2O-&gt;Fe+Al2O3'
2Al+3Fe2O-&gt;6Fe+Al2O3 
  f 'H2+O-&gt;H2O'
H2+O-&gt;H2O 
  f 'H+O2-&gt;H2O'
4H+O2-&gt;2H2O 
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C (gcc)</a>, 442 bytes</h1>
<pre class="lang-C prettyprint-override"><code>u,t[99];char*s,*m[99];c,v[99][99];i,j,n;
b(k){if(k&lt;0)for(n=j=0;!n&amp;&amp;j&lt;u;j++)for(i=0;i&lt;=c;i++)n+=t[i]*v[i][j];else for(t[k]=0;n&amp;&amp;t[k]++&lt;30;)b(k-1);}
main(int r,char**a){for(s=m[0]=a[1];*s;){if(*s==45)r=0,s++;if(*s&lt;65)m[++c]=++s;j=*s++;if(*s&gt;96)j=*s+++j&lt;&lt;8;for(i=0,t[u]=j;t[i]-j;i++);u+=i==u;for(n=0;*s&gt;&gt;4==3;)n=n*10+*s++-48;n+=!n;v[c][i]=r?n:-n;}b(c);for(i=0,s=n?&quot;Nope!&quot;:a[1];*s;putchar(*s++))s==m[i]&amp;&amp;t[i++]&gt;1?printf(&quot;%d&quot;,t[i-1]):0;putchar(10);}
</code></pre>
<p><a href="https://tio.run/##PVDLbsIwEPwVQCqKvYnk8Cqw2XDgwql8QORDcKG1aQyKEy6Ib0/t0HKxd8ee3ZlRyZdSXdfGTbFaSVTfZc1dzKtnF9/C3dc6NrHFQ3Rmd32Kzplgp0sdWTIkcGjHY5O1aAB6VHtMZ6RQe8ACNYWW/OaPwkg8/rjjIPxqirP0Hz03VADZVCDzC5KU4aMqtY20bQZ13GviJbsHkqOqEJLKIpXIHfZiuCOazVlNInYA2CPZYs6qAkBJAnBoiL@e8tWCPXswWbbEP8U@gVaSwSA2Mb10bIE0UYtPq8JvzPMZ0RSZJctTAWFKMluiNzm0eCuU9GyqN3adWHwcIsVe4x3Zzejjcj0OR@t/@de2Ce6iMIYxb6Py9JCH3y7zdHOtfQSnaPT2OfLydJJKthYvVip8UF3Xbd936QL2kyTf7iewm@x/AQ" rel="nofollow noreferrer" title="C (gcc) – Try It Online">Try it online!</a></p>
<p>Ungolfed version</p>
<pre class="lang-C prettyprint-override"><code>// element use table, then once parsed reused as molecule weights
u,t[99];

// molecules
char*s,*m[99]; // name and following separator
c,v[99][99]; // count-1, element vector

i,j,n;

// brute force solver, n==0 upon solution - assume at most 30 of each molecule
b(k){
    if(k&lt;0)for(n=j=0;!n&amp;&amp;j&lt;u;j++)for(i=0;i&lt;=c;i++)n+=t[i]*v[i][j]; // check if sums to zero
    else for(t[k]=0;n&amp;&amp;t[k]++&lt;30;)b(k-1); // loop through all combos of weights
}

main(int r,char**a){
    // parse
    for(s=m[0]=a[1];*s;){
        // parse separator, advance next molecule
        if(*s==45)r=0,s++;
        if(*s&lt;65)m[++c]=++s;
        // parse element
        j=*s++;
        if(*s&gt;96)j=*s+++j&lt;&lt;8;            
        // lookup element index
        for(i=0,t[u]=j;t[i]-j;i++);
        u+=i==u;
        // parse amount
        for(n=0;*s&gt;&gt;4==3;)n=n*10+*s++-48;
        n+=!n;
        // store element count in molecule vector, flip sign for other side of '-&gt;'
        v[c][i]=r?n:-n;
    }
    // solve
    b(c);
    // output
    for(i=0,s=n?&quot;Nope!&quot;:a[1];*s;putchar(*s++))s==m[i]&amp;&amp;t[i++]&gt;1?printf(&quot;%d&quot;,t[i-1]):0;
    putchar(10);
}
<span class="math-container">```</span>
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.wolfram.com/wolframscript/" rel="nofollow noreferrer">Wolfram Language (Mathematica)</a>, 510 bytes</h1>
<p>I employed the augmented chemical composition matrix approach described in</p>
<p>L.R.Thorne, An innovative approach to balancing chemical - reaction equations : a simplified matrix - inverse technique for determining the matrix null space. <em>Chem.Educator</em>, 2010, 15, 304 - 308.</p>
<p>One slight tweak was added:  I divided the transpose of the null-space vector by the greatest common divisor of the elements to ensure integer values in any solutions.  My implementation does not yet handle cases where there is more than one solution to balancing the equation.</p>
<pre class="lang-math prettyprint-override"><code>b@t_ :=Quiet@Check[Module[{s = StringSplit[t, &quot;+&quot; | &quot;-&gt;&quot;], g = StringCases, k = Length, 
  e, v, f, z, r},
e = Union@Flatten[g[#, _?UpperCaseQ ~~ ___?LowerCaseQ] &amp; /@ s];v = k@e;
s_~f~e_ := If[g[s, e] == {}, 0, If[(r = g[s, e ~~ p__?DigitQ :&gt; p]) == {}, 1, 
   r /. {{x_} :&gt; ToExpression@x}]];z = k@s - v;
r = #/(GCD @@ #) &amp;[Inverse[Join[SparseArray[{{i_, j_} :&gt; f[s[[j]], e[[i]]]}, k /@ {e, s}], 
Table[Join[ConstantArray[0, {z, v}][[i]], #[[i]]], {i, k[#]}]]][[All, -1]] &amp;
   [IdentityMatrix@z]];
Row@Flatten[ReplacePart[Riffle[Partition[Riffle[Abs@r, s], 2], &quot; + &quot;],2 Count[r,_?Negative]-&gt;&quot; -&gt; &quot;]]],&quot;Nope!&quot;]
</code></pre>
<p><a href="https://tio.run/##PVJdb@IwEHzPr9gLUtUKcxw83ElFQFB6d6VqS4H2ybIiQzfBJXUi26SUXPjr3AbaPlhazaxnZz9epVvhq3RqKQ@HReAiuOxPNwpdEK5wueZ32fMmRV5a6MPcGaWTeZ4qxx0Dv@nDP/BbA18wSL74UFq0DNYE3KJO3IqBB4AMCgYxgx0DUzEPiX7SKtPBn1Q6h5onvMEgGj7lOZpaYwr7PURRNLzN3j4QAWfQDsCKXkHf1wH2PBvt4z3WrmEckwZVRgH9PpQVgx@sBs8NJZ@YWjInySuVKDeFywHk4uIzu3M0Cgba36Est1FV84/Z721u0Nra6rYSorc7lrbQgqLn1dKN9vnf8AqCABoXcMbHukBjkd9kSvN5LikeGSPfeVmqiMHLSTfmlvMXQZNDzpUQoqpHRs2VNClbEe49ykX6IRNm2jqp3UmI2ippjEUljl8ZNE4SBCtS4Q1BPokbpSmDVkfQ2OrG@PgZtVPu/U7SorbBjprxZtnb1wZmmKdyiQ/SOD5TcUzV61g56v0TGC1sYMghFevS86EJtP4uhNlGO25YNLzHhM6pQEGHAa0B0eTMv89y/OaLwwOdiOML7oe/rjs/m5NuaxBOus3r7oTyDof/" rel="nofollow noreferrer" title="Wolfram Language (Mathematica) – Try It Online">Try it online!</a></p>
<p><strong>Analysis</strong></p>
<p>It works by setting up the following chemical composition table, consisting of chemical species by elements, to which an addition nullity vector is added (becoming the augmented chemical composition table:</p>
<p><img src="https://i.sstatic.net/pjLf6.png" alt="chemical composition table" /></p>
<p>The inner cells are removed as a matrix and inverted, yielding.</p>
<p><img src="https://i.sstatic.net/M6Mqx.png" alt="inversion" /></p>
<p>The right-most column is extracted, yielding:</p>
<blockquote>
<p>{-(1/8), -(11/8), 7/8, 1}</p>
</blockquote>
<p>Each element in the vector is divided by the gcd of the elements (1/8), giving:</p>
<blockquote>
<p>{-1, -11, 7, 8}</p>
</blockquote>
<p>where the negative values will be placed on the left side of the arrow.
The absolute values of these are the numbers needed to balance the original equation:</p>
<p><img src="https://i.sstatic.net/psbPN.png" alt="solution" /></p>
</div>
<div id="pu3" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>, 879 bytes</h1>

<pre class="lang-python prettyprint-override"><code>import sys,re
from sympy.solvers import solve
from sympy import Symbol
from fractions import gcd
from collections import defaultdict

Ls=list('abcdefghijklmnopqrstuvwxyz')
eq=sys.argv[1]
Ss,Os,Es,a,i=defaultdict(list),Ls[:],[],1,1
for p in eq.split('-&gt;'):
 for k in p.split('+'):
  c = [Ls.pop(0), 1]
  for e,m in re.findall('([A-Z][a-z]?)([0-9]*)',k):
   m=1 if m=='' else int(m)
   a*=m
   d=[c[0],c[1]*m*i]
   Ss[e][:0],Es[:0]=[d],[[e,d]]
 i=-1
Ys=dict((s,eval('Symbol(&quot;'+s+'&quot;)')) for s in Os if s not in Ls)
Qs=[eval('+'.join('%d*%s'%(c[1],c[0]) for c in Ss[s]),{},Ys) for s in Ss]+[Ys['a']-a]
k=solve(Qs,*Ys)
if k:
 N=[k[Ys[s]] for s in sorted(Ys)]
 g=N[0]
 for a1, a2 in zip(N[0::2],N[1::2]):g=gcd(g,a2)
 N=[i/g for i in N]
 pM=lambda c: str(c) if c!=1 else ''
 print '-&gt;'.join('+'.join(pM(N.pop(0))+str(t) for t in p.split('+')) for p in eq.split('-&gt;'))
else:print 'Nope!'
</code></pre>
<p><a href="https://tio.run/##bVLBbtswDL37K9QChaRYzmofNsyAOgxFgR7SBEVOnaCDaiuuGttyTTdbWuzbM8putm7YiTbfe@SjyG4/PPg2Oxxc0/l@ILAH0dto0/sGv5tuPwdf72wP5EgIv@/wY369b@59PQGb3hSD8@1vUVWUE1L4urZ/Y6XdmOd6KF0xRNECZO1gYNTcFwhUD@5xWzet7556GJ5333/sXyiP7JNEn3PTVzuV6mgNYgXiCoQRTr4rx0IpLhagci2UFqlIo43vSUdcS@zTHLraYavkgvI8IgHZBqQ7AvGYJwWRRC1g3vmOnXNBsCMZ2VY0gd/b@ca1palrRpn6mnzTyiQv@gtn6jz5rGeciu1YiDQyJW6DQVJKbA0W5QNreMDMTDYhllIV6lyLAiebNTMXmpE1KKtVjukrCEGqEidSVpQacSeTNLoDOc7MQNidQSvTQtgpjSGmp5xyPpqGYHkFwQeQ1g/hdwE8ugWpJmFM54/etYyelbMzoGcsWBHB1FShCBJ0BJqL15/iDt4VXoOO1R0oaqhOjI62crwXdgtihsQIu27xKZZSbQMNtP6jBbwGWzKk4UyVXGLDaSsmFcRkgfLiOob5PM@0WKo0RJ5XEs@LVcJkfKzsPlSjzAXFEmt0N7I2zX1pSJETGHpW8DB@cYLrGLdAKZJ63AUJx/A2/fEZuhu2fNs9j4N6mOYd/r2VKf2f48KDxS75W4el7@wJPRwOl5@u04/xKksuLldZfJ2tfgE" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>
<p>Could be much less than 880, but my eyes are killing me already...</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>, 640 bytes</h1>
<p>previous byte counts: 794, 776, 774, 765, 759, 747, 735, 734, 720, 683, 658, 655, 654, 653, 651, 640</p>
<p>The second indentation level is only a tab, the third is a tab then a space.</p>
<p>To be honest, this is jadkik94's answer, but so many bytes were shaved, I had to do it. Tell me if I can shave any bytes off!</p>
<pre class="lang-py prettyprint-override"><code>from sympy import*
import sys,re
from sympy.solvers import*
from collections import*
P=str.split
L=map(chr,range(97,123))
q=sys.argv[1]
S,O,a,i,u,v=defaultdict(list),L[:],1,1,'+','-&gt;'
w=u.join
for p in P(q,v):
 for k in P(p,u):
  c=L.pop(0)
  for e,m in re.findall('([A-Z][a-z]*)(\d*)',k):
   m=int(m or 1)
   a*=m
   S[e][:0]=[c,m*i],
 i=-1
Y=dict((s,Symbol(s))for s in set(O)-set(L))
Q=[eval(w('%d*%s'%(c[1],c[0])for c in S[s]),{},Y)for s in S]+[Y['a']-a]
k=solve(Q,*Y)
if k:
 N=[k[Y[s]]for s in sorted(Y)]
 g=gcd(N[:1]+N[1::2])
 print v.join(w((lambda c:str(c)*(c!=1))(N.pop(0)/g)+str(t)for t in P(p,u))for p in P(q,v))
else:print'Nope!'
</code></pre>
<p><a href="https://tio.run/##XVHPb9sgGL3zV9BDBNjYiz1p1SxRaeqlhyhplVPGOFBMUhZsU0NcZVP/9gzcaZEmDp94732/3ufO4WXo68tlPw4d9OfOnaHp3DCGDHzECHo6anAVlH6wkx79P@FMqcFarYIZ@ivxyHwYS@@sCWDFOumwehnpKPuDxl9vaVV/JgS8stihlONh4pUAW7qhkhp6ohNr9V6ebGiNCtgaHwhd8UbQKj6UI4qKOwTe2Kn8OZge7IcROmh6@Ihf6UQaABNy/EAcPSUEKrYq3eDwksRP4jXtkmLU5d70rbQWI8y/Fd8Fl8UvkRH8o80Iosc5G3bM9AF3MCZWqQKUGetS3HIteLMUjCvaZUZQAA0rKrBj8/DY0@25ex4s9oSktj419TrgDSlSWEUfnhjXk7T4DaNFmy08WmAVHaGKL8WcpFLSlntB6O93ursW2oqc7ziSSBRSgCOb74OfaLYjwOzhMc6@ZvwYNV6Ia/t4It3iHREAHthBtXjNm0rka141TS3ifm6M68Jp9jeOha3snlsJVROvihXJsLphFSF4/dfTTweSJyrMo4Wr9eS/4xCgrdfNXB@tB6dv0OVyub99qL7km7q4u9/U@UO9@QM" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu5" class="pu"><h1>JavaScript, 682 bytes</h1>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>x=&gt;{m=1;x.split(/\D+/g).map(i=&gt;i?m*=i:0);e=new Set(x.replace(/\d+|\+|-&gt;/g,"").match(/([A-Z][a-z]*)/g));e.delete``;A=[];for(let z of e){t=x.split`-&gt;`;u=[];for(c=1;Q=t.shift();c=-1)Q.split`+`.map(p=&gt;u.push(c*((i=p.indexOf(z))==-1?0:(N=p.substring(i+z.length).match(/^\d+/g))?N[0]:1)));A.push(u)}J=A.length;for(P=0;P&lt;J;P++){for(i=P;!A[i][P];i++);W=A.splice(i,1)[0];W=W.map(t=&gt;t*m/W[P]);A=A.map(r=&gt;r[P]?r.map((t,j)=&gt;t-W[j]*r[P]/m):r);A.splice(P,0,W)}f=e.size;if(!A[0][f])return"Nope!";g=m=-m;_=(a,b)=&gt;b?_(b,a%b):a;c=[];A.map(p=&gt;c.push(t=p.pop())&amp;(g=_(g,t)));c.push(m);j=x.match(/[^+&gt;]+/g);return c.map(k=&gt;k/g).map(t=&gt;(t^1?t:"")+(z=j.shift())+(z.endsWith`-`?"&gt;":"+")).join``.slice(0,-1);}</code></pre>
</div>
</div>
</p>

<p>This is a much more golfed (decades of characters!) of Kuilin's answer. Might be noncompeting because certain JS features postdate the challenge.</p>
</div>
<div id="pu6" class="pu"><h1>Javascript, 705 bytes</h1>

<p><strong>(non-competing, some features postdate the challenge)</strong></p>

<p>Other solutions all had elements of brute-forcing. I tried for a more deterministic approach by representing the chemical equation as a set of linear equations, and then solving using the Gauss-Jordan algorithm to take the reduced row-echelon form of that matrix. In order to isolate out the trivial case where everything is zero, I assume that one of the elements is a constant number - and that number is determined by just all the numbers multiplied together, in order to not have fractions. Then as a final step we'll divide each by the gcd to satisfy the last condition. </p>

<p>Ungolfed:</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>function solve(x) {
	//firstly we find bigNumber, which will be all numbers multiplied together, in order to assume the last element is a constant amount of that
	bigNumber = 1;
	arrayOfNumbers = new Set(x.split(/\D+/g));
	arrayOfNumbers.delete("");
	for (let i of arrayOfNumbers) bigNumber *= parseInt(i);
	
	//first actual step, we split into left hand side and right hand side, and then into separate molecules
	//number of molecules is number of variables, number of elements is number of equations, variables refer to the coefficients of the chemical equation
	//note, the structure of this is changed a lot in the golfed version since right is the same as negative left
	left = x.split("-&gt;")[0].split("+");
	righ = x.split("-&gt;")[1].split("+");
	molecules = left.length + righ.length;
	
	//then let's find what elements there are - this will also become how many equations we have, or the columns of our matrix minus one
	//we replace all the non-element characters, and then split based on the uppercase characters
	//this also sometimes adds a "" to the array, we don't need that so we just delete it
	//turn into a set in order to remove repeats
	elems = new Set(x.replace(/\d+|\+|-&gt;/g,"").match(/([A-Z][a-z]*)/g));
	elems.delete("");
	
	rrefArray = [];//first index is rows, second index columns - each row is an equation x*(A11)+y*(A21)+z*(A31)=A41 etc etc, to solve for xyz as coefficients
	//loop thru the elements, since for each element we'll have an equation, or a row in the array
	for (let elem of elems) {
		buildArr = [];
		//loop thru the sides
		for (let molecule of left) {
			//let's see how many of element elem are in molecule molecule
			//ASSUMPTION: each element happens only once per molecule (no shenanigans like CH3COOH)
			index = molecule.indexOf(elem);
			if (index == -1) buildArr.push(0);
			else {
				index += elem.length;
				numberAfterElement = molecule.substring(index).match(/^\d+/g);
				if (numberAfterElement == null) buildArr.push(1);
				else buildArr.push(parseInt(numberAfterElement));
			}
		}
		//same for right, except each item is negative
		for (let molecule of righ) {
			index = molecule.indexOf(elem);
			if (index == -1) buildArr.push(0);
			else {
				index += elem.length;
				numberAfterElement = molecule.substring(index).match(/^\d+/g);
				if (numberAfterElement == null) buildArr.push(-1);
				else buildArr.push(parseInt(numberAfterElement)*(-1));
			}
		}
		rrefArray.push(buildArr);
	}
	
	//Gauss-Jordan algorithm starts here, on rrefArray
	for (pivot=0;pivot&lt;Math.min(molecules, elems.size);pivot++) {
		//for each pivot element, first we search for a row in which the pivot is nonzero
		//this is guaranteed to exist because there are no empty molecules
		for (i=pivot;i&lt;rrefArray.length;i++) {
			row = rrefArray[i];
			if (row[pivot] != 0) {
				workingOnThisRow = rrefArray.splice(rrefArray.indexOf(row), 1)[0];
			}
		}
		//then multiply elements so the pivot element of workingOnThisRow is equal to bigNumber we determined above, this is all to keep everything in integer-space
		multiplyWhat = bigNumber / workingOnThisRow[pivot]
		for (i=0;i&lt;workingOnThisRow.length;i++) workingOnThisRow[i] *= multiplyWhat
		//then we make sure the other rows don't have this column as a number, the other rows have to be zero, if not we can normalize to bigNumber and subtract
		for (let i in rrefArray) {
			row = rrefArray[i];
			if (row[pivot] != 0) {
				multiplyWhat = bigNumber / row[pivot]
				for (j=0;j&lt;row.length;j++) {
					row[j] *= multiplyWhat;
					row[j] -= workingOnThisRow[j];
					row[j] /= multiplyWhat;
				}
				rrefArray[i]=row;
			}
		}
		//finally we put the row back
		rrefArray.splice(pivot, 0, workingOnThisRow);
	}
	
	//and finally we're done!
	//sanity check to make sure it succeeded, if not then the matrix is insolvable
	if (rrefArray[0][elems.size] == 0 || rrefArray[0][elems.size] == undefined) return "Nope!";
	
	//last step - get the results of the rref, which will be the coefficients of em except for the last one, which would be bigNumber (1 with typical implementation of the algorithm)
	bigNumber *= -1;
	gcd_calc = function(a, b) {
		if (!b) return a;
		return gcd_calc(b, a%b);
	};
	coEffs = [];
	gcd = bigNumber;
	for (i=0;i&lt;rrefArray.length;i++) {
		num = rrefArray[i][molecules-1];
		coEffs.push(num);
		gcd = gcd_calc(gcd, num)
	}
	coEffs.push(bigNumber);
	for (i=0;i&lt;coEffs.length;i++) coEffs[i] /= gcd;
	
	//now we make it human readable
	//we have left and right from before, let's not forget those!
	out = "";
	for (i=0;i&lt;coEffs.length;i++) {
		coEff = coEffs[i];
		if (coEff != 1) out += coEff;
		out += left.shift();
		if (left.length == 0 &amp;&amp; righ.length != 0) {
			out += "-&gt;";
			left = righ;
		} else if (i != coEffs.length-1) out += "+";
	}
	return out;
}
console.log(solve("Al+Fe2O4-&gt;Fe+Al2O3"));
console.log(solve("Al+Fe2O3-&gt;Fe+Al2O3"));
console.log(solve("C7H16+O2-&gt;CO2+H2O"));
console.log(solve("Pb-&gt;Au"));</code></pre>
</div>
</div>
</p>

<p>Golfed</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>s=x=&gt;{m=1;x.split(/\D+/g).map(i=&gt;i!=""?m*=i:0);e=(new Set(x.replace(/\d+|\+|-&gt;/g,"").match(/([A-Z][a-z]*)/g)));e.delete("");A=[];for(let z of e){t=x.split("-&gt;");u=[];for(c=1;Q=t.shift();c=-1)Q.split("+").map(p=&gt;u.push(c*((i=p.indexOf(z))==-1?0:(N=p.substring(i+z.length).match(/^\d+/g))?N[0]:1)));A.push(u)}J=A.length;for(P=0;P&lt;J;P++){for(i=P;!A[i][P];i++);W=A.splice(i,1)[0];W=W.map(t=&gt;t*m/W[P]);A=A.map(r=&gt;!r[P]?r:r.map((t,j)=&gt;t-W[j]*r[P]/m));A.splice(P,0,W)}f=e.size;if (!A[0][f])return "Nope!";g=m=-m;_=(a,b)=&gt;b?_(b,a%b):a;c=[];A.map(p=&gt;c.push(t=p.pop())&amp;(g=_(g,t)));c.push(m);j=x.match(/[^+&gt;]+/g);return c.map(k=&gt;k/g).map(t=&gt;(t==1?"":t)+(z=j.shift())+(z.endsWith("-")?"&gt;":"+")).join("").slice(0,-1);}

console.log(s("Al+Fe2O4-&gt;Fe+Al2O3"));
console.log(s("Al+Fe2O3-&gt;Fe+Al2O3"));
console.log(s("C7H16+O2-&gt;CO2+H2O"));
console.log(s("Pb-&gt;Au"));</code></pre>
</div>
</div>
</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/8728/">8728</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




