<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::282899</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>121</td><td>C clang</td><td>250805T134541Z</td><td><a href="https://codegolf.stackexchange.com/questions/282899/whats-left-after-repeatedly-removing-palindromes/282961#282961">jdt</a></td></tr>
<tr d-ix="1"><td>053</td><td>Pyth</td><td>250804T220202Z</td><td><a href="https://codegolf.stackexchange.com/questions/282899/whats-left-after-repeatedly-removing-palindromes/282955#282955">Synoli</a></td></tr>
<tr d-ix="2"><td>103</td><td>Perl 5 pl</td><td>250801T231611Z</td><td><a href="https://codegolf.stackexchange.com/questions/282899/whats-left-after-repeatedly-removing-palindromes/282916#282916">good old</a></td></tr>
<tr d-ix="3"><td>140</td><td>Python</td><td>250803T231053Z</td><td><a href="https://codegolf.stackexchange.com/questions/282899/whats-left-after-repeatedly-removing-palindromes/282934#282934">Lucenapo</a></td></tr>
<tr d-ix="4"><td>118</td><td>JavaScript ES6</td><td>250801T102802Z</td><td><a href="https://codegolf.stackexchange.com/questions/282899/whats-left-after-repeatedly-removing-palindromes/282903#282903">Arnauld</a></td></tr>
<tr d-ix="5"><td>210</td><td>C64 Basic</td><td>250803T181810Z</td><td><a href="https://codegolf.stackexchange.com/questions/282899/whats-left-after-repeatedly-removing-palindromes/282933#282933">OSI8</a></td></tr>
<tr d-ix="6"><td>047</td><td>Charcoal</td><td>250803T125737Z</td><td><a href="https://codegolf.stackexchange.com/questions/282899/whats-left-after-repeatedly-removing-palindromes/282931#282931">Neil</a></td></tr>
<tr d-ix="7"><td>083</td><td>Retina</td><td>250802T194431Z</td><td><a href="https://codegolf.stackexchange.com/questions/282899/whats-left-after-repeatedly-removing-palindromes/282927#282927">Neil</a></td></tr>
<tr d-ix="8"><td>233</td><td>Python3</td><td>250801T153528Z</td><td><a href="https://codegolf.stackexchange.com/questions/282899/whats-left-after-repeatedly-removing-palindromes/282907#282907">Ajax1234</a></td></tr>
<tr d-ix="9"><td>214</td><td>JavaScript Node.js</td><td>250801T084636Z</td><td><a href="https://codegolf.stackexchange.com/questions/282899/whats-left-after-repeatedly-removing-palindromes/282902#282902">rydwolf</a></td></tr>
<tr d-ix="10"><td>014</td><td>Nekomata</td><td>250801T034829Z</td><td><a href="https://codegolf.stackexchange.com/questions/282899/whats-left-after-repeatedly-removing-palindromes/282900#282900">alephalp</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="http://clang.llvm.org/" rel="nofollow noreferrer">C (clang)</a>, <s>212</s> <s>199</s> <s>148</s> <s>140</s> <s>133</s> 121 bytes</h1>

<pre class="lang-c prettyprint-override"><code>i,j,m,n;f(*s){for(i=0;s[i];i++)for(j=wcslen(s);--j&gt;i+1;){for(m=i,n=j;m&lt;n&amp;s[m]==s[n];n--)m++;n&gt;m||wcscpy(s+i,s-~j)+f(s);}}
</code></pre>
<p><a href="https://tio.run/##XVBRcoMgEP1uTsE4044EnabfhJwgN7B@IEqClV1H7GSaxB69djVJJ@kCA7x978GuSU2jYTeOLqkTn4C08TLwk8UudmolQ@Zy6YTgE1CrgwlNBXHgMk3rjRNv8kL1yiWgaunX8BIynysVMsglpCn3QkjY@POZtKb9ioNwSUi/ay7s5DMMo4Oeee0g5uy0YBQTsOyr0IcsZ@oKTrGNCn1E/NCF9oUDjJKHlNcNLYMGi8cMou0QO20qozvQGuhiEcsH1g7/D8DDAwOw1Y2DskNfBfrk3gWEiihP28ho0LRK7Pf0CNC84ARSFNFsM8jFX4FAlQV3rNDGc6n89f6WrXIuZy61l8WTwJFgJWlbM5BMCMfvOkOEJZuURKJGl5/t1cfdfGavGSTgqe1IYePouQlMbRht7/RhdtNcTlflsBjGH2MbvQtjevgF" rel="nofollow noreferrer" title="C (clang) – Try It Online">Try it online!</a></p>
<p>-11 bytes thanks to @ceilingcat!</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/isaacg1/pyth" rel="nofollow noreferrer">Pyth</a>, 53 bytes</h1>
<pre><code>L&amp;&gt;lb2qb_bL{u+G|{m|s-Fdkm,dy#df.EyMT./H]HbYh.mlbu'G]w
</code></pre>
<p><a href="https://tio.run/##K6gsyfj/30fNLifJqDApPsmnulTbvaY6t6ZY1y0lO1cnpVI5JU3PtdI3RE/fI9YjKTJDLzcnqVTdPbb8///kxLxEIE7JL8lIBdJABAA" rel="nofollow noreferrer" title="Pyth – Try It Online">Try it online!</a></p>
<h2>Explanation</h2>
<h3>Is <code>b</code> an eligible palindrome?</h3>
<pre><code>L                   # Declare a lambda `g(b)` …
 &amp;                  # … which tests if both of the following are true:
  &gt;lb2              #   b is more than 2 characters long?
      qb_b          #   b is equal to the reversed form of itself?
</code></pre>
<h3>Remove a single palindrome</h3>
<p>This lambda tries to find all the ways to remove a single palindrome.
We accept a list of strings. For each string, we try to remove a single
palindrome. If we can’t find any palindromes, then that means the string
can’t be made smaller and is a potential winning candidate, so we keep it
in the list. If we have a palindrome, then we remove it and keep the
result. If we find more than one palindrome, we don’t know yet which one
is best, so we remove each palindrome separately and keep all the results.</p>
<pre><code>                                Y # We’re going to use reduce, so start with an empty list.
                               b  # Our input, the list of strings. Let’s feed it into reduce.
                              H   # Maybe the string contains no palindromes. If so, keep it around …
                             ]    # … but for interface parity, let’s wrap it in a singleton list.
                            H     # With that out of the way, take the characters from our string …
                          ./      # and explode it into a massive list of all possible substring partitions.
                       yMT        # For each substring, check whether it is a valid palindrome …
                     .E           # … and if that happens at least once in our partition, then …
                    f             # … keep the partition around, otherwise throw it away.
                 y#d              # In our right hand, we take the substrings that are palindromes …
              m,d                 # … in our left hand, we take the partition itself …
          -Fd                     # … and fold them into each other, eliminating the palindrome.
                                  # Conveniently, folding has removed each palindrome separately,
                                  # and multiple palindromes have automatically split into two separate
                                  # intermediate results. This is good, because we don’t know yet
                                  # which palindrome was the best one to remove, so let’s keep all the options.
       m s                        # Each result is still in form of a partition, so mend it back into a string.
        |    k                    # Is our partition empty? If so, fix the mess that `s` has made with its default value 0.
      {                           # Our power-set shenanigans are causing abysmal performance, so let’s
                                  # deduplicate what we have to counteract the effect at least a little.
     |                            # If there were no palindromes at all, fall back to the singleton list we prepared earlier.
  u+G                             # Repeat for each input string and collect results.
 {                                # Deduplicate the resulting list once again …
L                                 # … and define a lambda named `'` so we can repeat all of the above over and over.
</code></pre>
<h3>Main routine</h3>
<pre><code>         w          # Start with the input string …
        ]           # … and wrap it inside a singleton list. That’s our initial state.
      'G            # From each list element, try removing a single palindrome …
                    # … while keeping track of intermediate solutions …
     u              # … over and over again, until our list no longer changes.
                    # The list elements are now our potential winning candidates.
   lb               # Look at the number of characters …
 .m                 # … of each candidate. Those with minimal length are our solutions.
h                   # More than one solution? If so, pick the first one.
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.perl.org/" rel="nofollow noreferrer">Perl 5</a> <code>-pl</code>, 103 bytes</h1>

<pre class="lang-perl prettyprint-override"><code>@,=$s=$_;/((.)(?1)\2|(.)(.)\4?\3)?(??{$1?push@,,$`.$':length$s&gt;y!!!c?$s=$_:1;0})/,$_=pop@,while@,;$_=$s
</code></pre>
<p><a href="https://tio.run/##XZDNTsMwEITP@ClcYYlEMiktcGlUnAeJVDauU1s4u5btqCo/r05wESd2dzTzXeawwUT/vGhLU2hvbjlS5gFi5jTyRH7OjlByQn/hmXg2KfMJ8MIdhjmnYhx40tEYHGe/dHIv0l4c2nVVNXWlNnW//bympu6fVP9Yq0qpD7FRYU62k1K8NuJu5w2eshXp5bJarbT6bdht2oevei3FYR8odPJsnTedbAuLtCwDvBO9wQDT4JBYcfBFmjQNbCAaI1EEbTREBMACI9GRnej/Ip0ZUgDv8BhpMslhti4RGqYBoehI2ZYeLMcKlxkY/IVvCtcHpeU@@B8" rel="nofollow noreferrer" title="Perl 5 – Try It Online">Try it online!</a></p>
<p>More readable:</p>
<pre class="lang-perl prettyprint-override"><code>@, = $s = $_;
/
    ( (.)(?1)\2 | (.)(.)\4?\3 )?
    (??{ 
        $1 ? push @,, $` . $'
           : length $s &gt; y!!!c ? $s = $_ : 1;
        0
    })
/x,
$_ = pop @, while @,;
$_ = $s
</code></pre>
<h1><a href="https://www.perl.org/" rel="nofollow noreferrer">Perl 5</a>, (non-competing) 458 bytes</h1>

<pre class="lang-perl prettyprint-override"><code>$s = $_;
%seen = ();
while () {
    /
        (?&gt;^.*?)
        ( 
            (
                (.)(?-3)\g-1|(.)(.)\g-1?\g-2 
            )
            (?{ 
                $x = substr( $_, 0, $-[2] ) . substr( $_ , $+[2] );
                unless ( $seen{ $x } ++ ) {
                    push @a, $x;
                    $s = $x if length( $s ) &gt; length( $x )
                }
            })
        )
    /x;
    last unless @a;
    $_ = pop @a
}
$_ = $s;
</code></pre>
<p><a href="https://tio.run/##fVDLbsMgELzzFXsgkqljp03VE0rIf6QPuRWxLVFAwVYsuf710gU3dZ1UXSQ0MyzDDlYe1YN/q8y75Z462AB94WThpNSIE8bJqaqVRAQ9AaxV3EMlYvuc3wg2CfADI52xqOQsEdk9eyyzu49A8ggFbuv5XTZ3Ej1cmdEOB3Ttq2uOCQ69hNsl0Gy/fgIG@a8DQDmNMr/yaLWSzuHgNATug@cAaQrnsJdlW1fBrkDHjv/ZMP5gB/UBlNRlUwVrtNtOtLsIF2qYKcPUMKLV92uqcM155l0xahhwA9ZYFMhAIqOOe1@a/5c2p09jm9po5zOrvgA" rel="nofollow noreferrer" title="Perl 5 – Try It Online">Try it online!</a></p>
<p>Short version is terribly inefficient. Just for fun, this is a much faster version (approx. 1 sec for 16 &quot;go&quot;'s in linked TIO's input vs. 9 in the challenge's test case), which hopefully generates correct results.</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.python.org" rel="nofollow noreferrer">Python</a>, <s>146</s> <s>145</s> 140 bytes</h1>
<pre class="lang-python prettyprint-override"><code>def f(s):
 L=len(s);w=[s]
 for a in range(L):
  for b in range(a+3,L+1):s[a:b]==s[a:b][::-1]==(w:=w+[f(s[:a]+s[b:])])
 return min(w,key=len)
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=XVFLbsMgEFW37iXYxcjJIuqmovINfAPkxWBDjGLPWEBkJWfoDbrJpr1Te5pOalUtAUbD-0hvBG8f8zkNhNfr-ym53fPna2-dcGWUqhBNPVrk68tS69gWwlEQIDyKAHiwZXPz_JDmj4TqadtUe6miBmXaul67Vmq3Z1Quql4qzQFaQVtFbVQrW1mIYNMpoJg8lsv2aM-3aLnO9PXwOAePqXTlxsCF6AgGJuORNlIW_6QJRq6OOjK5QuQCUYDOdhAQABk4oj5zHeh-Iy2ZA2mG0WMfaLKRucFHQptZOkDg6ikNnIV8Mpk1Xvl09xAymIHEaH2T3__6Bg" rel="nofollow noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu4" class="pu"><h1>JavaScript (ES6), 118 bytes</h1>
<p>I/O format: arrays of characters.</p>

<pre class="lang-javascript prettyprint-override"><code>f=(s,_=o=s)=&gt;s.map((n,i)=&gt;s.map(_=&gt;(q=[...s],p=q.splice(i,n=-~n))[2]&amp;&amp;p+&quot;&quot;==p.reverse()&amp;&amp;f(q,0)),s[o.length]?0:o=s)&amp;&amp;o
</code></pre>
<p><a href="https://tio.run/##bZFBbsMgEEX3OQXywgLVIVGXjUhXPYVlRWOMbRJ7hoCVqF306i7EVZtWGZjF6L8/fIkjXCBob920RmrMPLeKh@KgSAWh9kGO4DjHwv4MB7XnZ1VKKUNVOHWWwQ1WG24LVOtPFKJ8rvLcPWWZUk56czE@GC7yvOXnYitEEUqSg8Fu6qvX7Ut6J89p3pUrxrIaPohOUMNYW6SsYHe12bBFvmkLPcIQW5Om@i@caG5GN72zMHmLnbgZiFpP5EEbDR4BMA4tURPNaX2ToI7@H6Tr9/YIXROD5GCw2HgaTbA49TYQmgWKzGM5GTUgxG5o6mMEjPc3dzRquFMSH@FYdcYeVEq8qlayJf8GuueBqT3ThIEGIwfqeMuXbxLySBZ5lgkhdvMX" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<h3>Commented</h3>
<pre class="lang-javascript prettyprint-override"><code>f = (               // f is a recursive function taking:
  s,                //   s[] = input
  _ = o = s         //   o[] = output, initialized to the input
) =&gt;                //
s.map((n, i) =&gt;     // for each character at index i in s[],
                    // with n zero'ish:
  s.map(_ =&gt;        //   for each character in s[]:
    (               //
      q = [...s],   //     q[] = copy of s[]
      p = q.splice( //     p[] = palindrome candidate
        i,          //       extracted from q[] at index i
        n = -~n     //       with a length of (at most) n
      )             //       where n is incremented
    )[2] &amp;&amp;         //     if p[] is at least 3 characters long
    p + &quot;&quot; ==       //     and is a palindrome, i.e. it's equal
    p.reverse() &amp;&amp;  //     to its reversed form:
      f(q, 0)       //       do a recursive call with q[]
                    //       (the 2nd argument is here only
                    //       to leave o[] unchanged)
  ),                //   end of inner map()
  s[o.length] ?     //   if s[] is longer than o[]:
    0               //     do nothing
  :                 //   else:
    o = s           //     update o[] to s[]
) &amp;&amp; o              // end of outer map(); return o[]
</code></pre>
</div>
<div id="pu5" class="pu"><h1><a href="https://www.c64-wiki.com/wiki/BASIC" rel="nofollow noreferrer">C64 Basic</a>, 210 bytes</h1>
<pre><code>0inputa$
1l=len(a$):i=1:j=l:ifl&lt;3tH8
2ifmI(a$,i,1)=mI(a$,j,1)tHm=i+1:n=j-1:gO5
3j=j-1:ifj=i+1tHi=i+1:j=l:ifi=l-1tH8
4gO2
5ifm&gt;=ntHa$=leF(a$,i-1)+mI(a$,j+1):gO1
6ifmI(a$,m,1)&lt;&gt;mI(a$,n,1)tH3
7m=m+1:n=n-1:gO5
8?a$
</code></pre>
<p><a href="https://i.sstatic.net/J3NpPl2C.png" rel="nofollow noreferrer"><img src="https://i.sstatic.net/J3NpPl2C.png" alt="C64 screenshot" /></a></p>
<p><a href="https://stigc.dk/c64/basic/?s=2NY2xCsMgFAB3v8OhYoS-2LRB8tKt2Cnf4FDDE5UM9v9rTLodHNxdKW_f4jiDiPGTL44LQwgmYDTk46SLHVlPPr2r6qgDgQeGisUmJAkmY1Bg1mVgOjQkH3ZRLDV_xAijgj13W5eeDbU5Yy7W8Tp-tboCIc-6BFGDwO7_daq_aT44t7dmj4Sp7fO5H5-O_wA" rel="nofollow noreferrer">Try in emulator</a></p>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 47 bytes</h1>
<pre><code>⊞υＳＦυＦＬιＦＥι✂ικμＦ∧›Ｌλ²⁼λ⮌λ⊞υΦι÷⁻ξκＬλ§υ⌕ＥυＬι⌊ＥυＬι
</code></pre>
<p><a href="https://tio.run/##ZY7NCsIwEITvPsUeNxAvXj0J/iBYEH2C2K7tYprWNCm@fdxU68WFsAmTmfnKxviyMzalcxwajBqOro/hGjy7GpVaL@6dB4wKpn0iV4cGWX3fhemRNVwtl5QvDw2tmsWNq/DgyQTys9EqDSs5u2c0dkCr4UIj@YFEyb4ZYs82uzjjhC2PXBEW7OKALymRgF@eyoxnoQ24CUdX0evjl@4MF39fhVmDZHAb239pyknJlEbmlpajfQM" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Explanation:</p>
<pre><code>⊞υＳＦυ
</code></pre>
<p>Start searching for palindromic substrings starting with the input.</p>
<pre><code>ＦＬιＦＥι✂ικμＦ∧›Ｌλ²⁼λ⮌λ
</code></pre>
<p>If this substring is long enough and palindromic, then...</p>
<pre><code>⊞υΦι÷⁻ξκＬλ
</code></pre>
<p>... filter it out from the string and push the result to the list of strings to test.</p>
<pre><code>§υ⌕ＥυＬι⌊ＥυＬι
</code></pre>
<p>Output the shortest resulting string.</p>
</div>
<div id="pu7" class="pu"><h1><a href="https://github.com/m-ender/retina/wiki/The-Language" rel="nofollow noreferrer">Retina</a>, 83 bytes</h1>
<pre><code>+%/(.)+(.)\2?(?&lt;-1&gt;\1)+(?(1)^)/&amp;L$w`(.)+(.)\2?(?&lt;-1&gt;\1)+(?(1)^)
$`$'
O#$`
$.&amp;
L`^.*
</code></pre>
<p><a href="https://tio.run/##fYtBCoMwEEX3c41GGytV0nWpy26EXkAkkxgxVGdKKhR6@XRO0OE/Pg/@pLBHQpMLfbe5LlrdVLUwXDrdXc/mNhjxTptqrNqyVx/7ZwDKqiM8DsqCakro7diccnb4ZX6iw81FYpDGVfDs2YFjnhNzQh88JkIkkZl5AuIXrpGmxFt4R9qX@GYK4JFQmHhf5IMkIC7nfg" rel="nofollow noreferrer" title="Retina – Try It Online">Try it online!</a> Link includes faster¹ test cases. Explanation:</p>
<pre><code>+%/(.)+(.)\2?(?&lt;-1&gt;\1)+(?(1)^)/&amp;`
</code></pre>
<p>Repeat on those lines that contain a palindrome...</p>
<pre><code>L$w`(.)+(.)\2?(?&lt;-1&gt;\1)+(?(1)^)
</code></pre>
<p>... for all overlapping matches...</p>
<pre><code>$`$'
</code></pre>
<p>... remove the match to give the resulting line.</p>
<pre><code>O#$`
$.&amp;
</code></pre>
<p>Sort the lines in ascending order of length.</p>
<pre><code>L`^.*
</code></pre>
<p>Output only the first (i.e. shortest) line.</p>
<p>¹<code>gogogogogogogogogonow</code> is too slow for the <code>w</code> style of overlapping match but the <code>v</code> style also happens to work in this case within TIO's time limit.</p>
</div>
<div id="pu8" class="pu"><h1>Python3, 233 bytes</h1>
<pre class="lang-py prettyprint-override"><code>def f(s):
 q,r,S=[s],[],[s]
 for s in q:
  if[]==(o:=[(i,j)for i in range(len(s))for j in range(i+1,len(s)+1)if s[i:j]==s[i:j][::-1]and j-i&gt;2]):r+=[s]
  for i,j in o:
   if(U:=s[:i]+s[j:])not in S:S+=[U];q+=[U]
 return min(r,key=len)
</code></pre>
<p><a href="https://tio.run/##XY7BboMwDIbvPEVuTQQ9dLtMmdhLVD1FOQRIWtNiU4dp6l6eGXrYWGzLij/bv8fHdCF8fRt5nruYVNLZ2ELdK66Otcu@cuLZFyoRq6wA1V2wguR8XWuytdNQ9WahsFAOeI76FlH2rNX@twrloXqS8mAgqezA9rLmmZ21@4MP2Kl@Dx8v3lgu61V61RaVZRMt6iKvT1bmLPgyu956gzQt@GiPMnTy7/c1FYrj9MmoBkDN1TU@ajnAzCMDTjrpXRO@ia6hCUMDSDtjij9oCDeJllpqtoQoMRGHNraBMQSUTyLqNl1n@m9IX5sOpDHcADumIWapXSATxk1LGzBIdDRdRAvFN1iYvOW6@Qc" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu9" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 214 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>f=s=&gt;[...s,t=[]].map((_,i,a)=&gt;[...Array(i).keys()].map(j=&gt;j&lt;i-2&amp;&amp;s.slice(j,(j+i)/2|0)==a.slice((j+i+1)/2|0,i).reverse().join``&amp;&amp;t.push(s.slice(0,j)+s.slice(i))))&amp;&amp;0 in t?t.map(f).sort((x,y)=&gt;x.length-y.length)[0]:s
</code></pre>
<p><a href="https://tio.run/##hU7bTsMgGL73KZZdNJAxrLtUO@NzLIv7S@lKR/kbwG01vnvF0pl4qOOQwHf8aziCE1a1fmmwkH1fZi5bbzjnjvlss93yBlpCXphiQCPxbC10RFF@kJ0jNCrqbF0/quUqSRx3WglJakbqhaK3q/eUZhmM6Ce2uBtQFiKsPErrJKG8RmV2uyTxvH11FbmkpKymi8tH0bCSJJ0pM/NPfiguKXdoPSFn1oUBz1xLs/fVshsfdJNu710v0DjUkmvcE2KzksznNIw1nzNLH25@sxBpmORzMSrCY0KjUV8p@VJM9lSgg0hpqP6PyuEN8QA5NLkyGLURi8CkrQEdrkCB@ZUGxNIiWhBSgDUAJnxKxGIsK6aMe/y5DZ6i6TTlMdiCVqaw2EinjK@UQyOjaYL7O0mAgXAL9FUY24QzZHyHBm//AQ" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<h3>Explanation</h3>
<ul>
<li><code>f=s=&gt;...</code>: Define a function <code>f</code> (named so recursion is possible) which solves the challenge for a string <code>s</code></li>
<li><code>[...s,t=[]].map((_,i,a)=&gt;...)</code>: For every integer <code>i</code> from <code>0</code> to the length of <code>s</code>, do the following... (with the characters of <code>s</code> stored in the array <code>a</code>)
<ul>
<li><code>[...Array(i).keys()].map(j=&gt;j&lt;i-2&amp;&amp;...)</code>: For every integer <code>j</code> from <code>0</code> to <code>i-1</code>, where <code>j &lt; i-2</code>, do the following...
<ul>
<li><code>s.slice(j,(j+i)/2|0)==a.slice((j+i+1)/2|0,i).reverse().join``</code>: Check if the slice of <code>s</code> ranging from <code>j</code> to <code>i</code> is a palindrome</li>
<li><code>...&amp;&amp;t.push(s.slice(0,j)+s.slice(i))</code> If so, push the section of <code>s</code> without the palindrome to <code>t</code></li>
</ul>
</li>
</ul>
</li>
<li><code>&amp;&amp;0 in t?...:s</code>: Now, if <code>t</code> is empty, return <code>s</code> unchanged. Otherwise, one or more palindromes was found</li>
<li><code>t.map(f)</code>: For each palindrome found in <code>s</code>, recursively apply <code>f</code> to the parts of <code>s</code> without that palindrome</li>
<li><code>.sort((x,y)=&gt;x.length-y.length)[0]</code>: Choose the shortest result possible</li>
</ul>
</div>
<div id="pu10" class="pu"><h1><a href="https://github.com/AlephAlpha/Nekomata" rel="noreferrer">Nekomata</a>, 14 bytes</h1>
<pre><code>ʷ{;;$ƀ=tŁ¿,}aş
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m70iLzU7PzexJHFNtJJurpKOgpKuoVLsgqWlJWm6FptPba-2tlY51mBbcrTx0H6d2sSj85cUJyUXQ-UX3MxWykjMycnPycxJzFDiUkpKrMrPz05MSsxNyszLBwvkJuYAcXJ-cn4SkJ-eD4N5-eVAfl5-QWJOZl5KUX5uanFmXklGZnF-XipQIjkxLxGIU_JLMlKBNBApQewEAA" rel="noreferrer">Attempt This Online!</a></p>
<p>Extremely slow for long inputs that contain many palindromes.</p>
<pre><code>ʷ{;;$ƀ=tŁ¿,}aş
ʷ{         }      Loop until failure
  ;;                Split the input into three parts
    $ƀ=             Check that the second part is a palindrome
       tŁ           Check that the second part has length &gt;= 3
         ¿,         If so, join the first and third parts; otherwise fail
            aş    Find the shortest possible solution
</code></pre>
<p>If there are multiple shortest solutions, Nekomata will print all of them. You can add the <code>-1</code> flag to only print the first one.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/282899/">282899</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




