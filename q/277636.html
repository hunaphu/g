<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::277636</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>146</td><td>C clang</td><td>250117T190010Z</td><td><a href="https://codegolf.stackexchange.com/questions/277636/ranking-of-binary-trees/277727#277727">Unrelate</a></td></tr>
<tr d-ix="1"><td>034</td><td>Charcoal</td><td>250114T180438Z</td><td><a href="https://codegolf.stackexchange.com/questions/277636/ranking-of-binary-trees/277655#277655">Neil</a></td></tr>
<tr d-ix="2"><td>115</td><td>Python</td><td>250114T125736Z</td><td><a href="https://codegolf.stackexchange.com/questions/277636/ranking-of-binary-trees/277643#277643">Mukundan</a></td></tr>
<tr d-ix="3"><td>094</td><td>Maple</td><td>250114T220509Z</td><td><a href="https://codegolf.stackexchange.com/questions/277636/ranking-of-binary-trees/277658#277658">dharr</a></td></tr>
<tr d-ix="4"><td>004</td><td>Jelly</td><td>250114T163145Z</td><td><a href="https://codegolf.stackexchange.com/questions/277636/ranking-of-binary-trees/277652#277652">Unrelate</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="http://clang.llvm.org/" rel="nofollow noreferrer">C (clang)</a>, 146 bytes</h1>

<pre class="lang-c prettyprint-override"><code>g(*n){return*n&amp;8388607;}f(n,r,i,l,t){for(float b,a=r=0;a++&lt;n;r+=l){for(b=i=l=0;b++&lt;n;l+=t&amp;a&gt;b)i+=t=(g(&amp;a)-g(&amp;b)?:a-b)&lt;0;for(;i;)l*=i--;}return r;}
</code></pre>
<p><a href="https://tio.run/##RVDLbsIwELzzFVMkkE2SAkWlCOP2R3pxUiey5K4rP0AI5dvp0hx62V3NzI5mt2s6b2i43wexInmLNpdIK1oedofDfvOmxl5QHWtX@zrLWx@i6H0wGW1tdNQbZarqRCpW2k9sq532jLd/uK90Xpr3VjoetBjE0siGays/jqZp5WmjHkvKKelX2jWNGqcEiGq8fxtHQuI2A1gF4SiDoLFV3E7cX3moKon1Gtt9hXC2kdNdwMJniELJDWS/4AMNCOSvSCWe3dkm5ICXHQxdL@aamiYFXCxiIYSSEfqHA36i7VxygcAitJYzWEzX/1OdIabYCS6lYp8khwXzbNCL@aIcP/OifNK8BtXoxfQ9CZJSzcb7Lw" rel="nofollow noreferrer" title="C (clang) – Try It Online">Try it online!</a></p>
<p>Inaccurate for <span class="math-container">\$n&gt;15\$</span> due to integer width. Explicit <code>unsigned long</code> types are good for all <span class="math-container">\$n \leq 23\$</span>.</p>
<p>I'm definitely not the best C golfer out there, but this idea was just too fun not to use... For porting <a href="https://codegolf.stackexchange.com/a/277652/85334">my Jelly solution</a>, C may not have any built-in functionality for converting an integer to a string representation of its binary digits to compare with a costly <code>strcmp</code>, but that's not to say it doesn't still have built-in functionality for <em>right-aligning</em> integers’ binary digits. Namely, <em><strong>representing them as floats</strong></em>.</p>
<p>Ignoring irrelevant special cases, floating point represents numbers as essentially the product of a fixed-point real in <span class="math-container">\$[1, 2)\$</span> with an integer power of 2 by encoding the exponent of the power of 2 and the fractional part (the &quot;significand&quot;) of the fixed-point real--this can also be thought of as the exponent encoding where to put the radix point within the significand's binary digits infinitely 0-padded to the left and right, hence the name &quot;floating point&quot;. How and why the exponent works is entirely besides the point here, because all the solution does with its <code>float</code>s (single precision--the factorial-heavy solution outgrows 64-bit ints long before it outgrows 32-bit floats!) is discard the sign bit and exponent to compare the significands directly.</p>
<p>Single-precision <code>float</code> has one sign bit and 8 exponent bits, so type punning to <code>int</code> (conveniently implicit in the declaration of <code>g</code>! Which actually saves two bytes over a <code>#define</code>) then masking to the lower 23 bits with <code>&amp;8388607</code> yields the significand as a signed integer (<code>&lt;&lt;9</code> clobbers the exponent and sign just the same, but requires casting to unsigned for useful comparisons because the top bit of the significand ends up in the sign bit instead).</p>
<p>Unlike variable-length bit strings, floating-point significands don’t distinguish trailing zeroes, so in order to determine if node <code>a</code> precedes node <code>b</code> in the permutation, instead of just checking <code>g(&amp;a)&lt;g(&amp;b)</code> it's necessary to use the Elvis operator in <code>(g(&amp;a)-g(&amp;b)?:a-b)&lt;0</code> to defer to a comparison of the original integers as a tiebreaker if the significands' difference is 0. For each node <code>a</code>, the solution compares it with every node <code>b</code>, and: counts as <code>i</code> the true comparisons to determine <code>a</code>’s index from the <em>right</em> end of the permutation, counts as <code>l</code> the true comparisons for which it also holds that <code>a &gt; b</code> (<code>a</code>’s corresponding term in the permutation’s <a href="https://en.wikipedia.org/wiki/Lehmer_code" rel="nofollow noreferrer">Lehmer code</a>), multiplies <code>l</code> by the factorial of <code>i</code> (<code>for(;i;)l*=i--</code>), and finally adds it to a running sum <code>r</code> across all <code>a</code> in order to compute the permutation’s rank as the factoradic valuation of its Lehmer code.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, <s>42</s> 34 bytes</h1>
<pre><code>≔ＥＮ↨⊕ι²θ≔⁰ηＷ⁻θυ≔∧⊞Ｏυ⌊ι⁺×ηＬι⌕ι⌊ιηＩη
</code></pre>
<p><a href="https://tio.run/##VY3LCsIwEEX3fkWWE4ggroSuqiAIrXbhD8R2aAaStM1DPz9OsRs3A3Pm3Du90aGftC2ljpFGD62e4ebnnO7ZvTCAVOKsIzLrAzr0CQcghkfJY5HVbssdlDC8fQxZFNCSzxEWJbKUYjNqP0CXo3nMGHSaAmQl2COXHTdyW2c58ySHEYwSDfoxmd/lSpylP33F68MukE9w0TGBkbIq5VT2b/sF" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Explanation: Uses @UnrelatedString's observation.</p>
<pre><code>≔ＥＮ↨⊕ι²θ
</code></pre>
<p>Generate the binary representations of the numbers <code>1..n</code>.</p>
<pre><code>≔⁰η
</code></pre>
<p>Start calculating the rank as if sorted.</p>
<pre><code>Ｗ⁻θυ
</code></pre>
<p>While there are binary representations left to be ranked...</p>
<pre><code>≔∧⊞Ｏυ⌊ι⁺×ηＬι⌕ι⌊ιη
</code></pre>
<p>... add the minimum to the list of representations that have been ranked, and then update the rank. This code was inspired by the Java code on the linked Rosetta Code page, but it's been rewritten to avoid having to sort the representations first, which in fact simplifies the code, since the number of remaining integers lower than the current integer is simply the position of the minimum representation in the list.</p>
<pre><code>Ｉη
</code></pre>
<p>Output the final rank.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.python.org" rel="nofollow noreferrer">Python</a>, 115 bytes</h1>
<pre class="lang-python prettyprint-override"><code>lambda n:[*permutations(range(n))].index((t:=lambda x:x&lt;n and(x,)+t(2*x+1)+t(2*x+2)or())(0))
from itertools import*
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=NY1BDoIwEEX3nGJWZgbQCHFhGjmJuqih1SYwbcqQ1LO4YYN38jaagH_z_uIl7_UOT3l4nmYLDVzmUez2-Bk63d9aDazOeTCxH0WL8zxg1Hw3yETXnePWJERRzSonlU4MmltMJRWCdZ6K6n9q8hGJcE-U2eh7cGKieN8N4Prgo-RremN9BAeOYWkdSqgqUhn8FqJjQYuOaLGnaeEX" rel="nofollow noreferrer">Attempt This Online!</a></p>
<hr />
<h1><a href="https://www.python.org" rel="nofollow noreferrer">Python</a>, <sup><s>93</s></sup> 91 bytes</h1>
<p><em>-2 bytes thanks to <a href="https://codegolf.stackexchange.com/users/53748/jonathan-allan">@Jonathan Allan</a> by using the range [0, n] instead of [1, n]</em></p>
<pre class="lang-python prettyprint-override"><code>lambda n:[*permutations(r:=range(n+1))].index((*sorted(r,key=bin),))
from itertools import*
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=LY0xDoJAEEV7TjGV2UE0IbEwJJwELJawqxPZ2c0wJHIWGxq8k7eRBF_zm5f_3p806yPysnqooV0n9afrtxls6HoLXDV5chImtUqRRyNVLZbvzvCxRLydiXv3MiYfo6jrjRRPN9cdMRaImZcYgNSJxjiMQCFtVv5PHHwUICCG_fBSQFlilcFGEmI13hDibi_Lvj8" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Port of <a href="https://codegolf.stackexchange.com/a/277652/91267">Unrelated String's amazing answer</a></p>
<hr />
<h1><a href="https://www.python.org" rel="nofollow noreferrer">Python</a> + <a href="https://docs.sympy.org/latest/index.html" rel="nofollow noreferrer">SymPy</a>, <sup><s>111</s></sup> 88 bytes</h1>
<p><em>-23 bytes thanks to <a href="https://codegolf.stackexchange.com/users/53748/jonathan-allan">@Jonathan Allan</a> by switching to @Unrelated String's approach</em></p>
<pre class="lang-python prettyprint-override"><code>lambda n:Permutation(sorted(range(n+1),key=bin)).rank()
from sympy.combinatorics import*
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=LYw7DsIwEER7TrEdNoQooUKRcgdKChonsWEVvGttnMJnoUkT7sRtsBSmGWk-7_0JKT6ZltVBC_d1ju50-d5exneDAWquVvwcTUQmNbFEOygx9LCKjrUuRpvaDknrMoej0jsn7GFKPqSyZ58rE1mwnwB9yO_Dn793LICABBusLuBcVbrZQVYQpKicQq23-bJs_gM" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Use of sympy was inspired by the program provided in <a href="https://oeis.org/A379905" rel="nofollow noreferrer">A379905</a></p>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.maplesoft.com/" rel="nofollow noreferrer">Maple</a>, 94 bytes</h1>
<pre><code>proc(n)sort(convert~([$n],binary),key=String);combinat:-rankperm(convert~(%,decimal,2))-1;end;
</code></pre>
<p>This is @Unrelated String's nice algorithm. Take [1,...,n], convert to binary, sort in string (lex) order, convert back to decimal, and find the rank (builtin).</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="noreferrer">Jelly</a>, <s>8</s> 4 bytes</h1>
<pre><code>BÞŒ¿
</code></pre>
<p><a href="https://tio.run/##y0rNyan8/9/p8Lyjkw7t/3@4/VHDTM3I//8NDQA" rel="noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p><em>-4 because WHY exactly did I think Hamming weight was involved again??</em></p>
<p>Returns the rank 1-indexed, but the test harness converts to 0-indexed for convenience.</p>
<pre><code> Þ      Sort [1 .. n] by lexicographic comparisons of
B       their binary digits.
  Œ¿    Builtin permutation index.
</code></pre>
<h3>Intuition:</h3>
<p>If you label the nodes with <span class="math-container">\$[1, n]\$</span> instead of <span class="math-container">\$[0, n-1]\$</span>, the labels at each &quot;tier&quot; of the tree all have the same length in bits:</p>
<pre><code>                    1
                .../ \...
           ..../         \....
          /                   \
         10                   11
        /  \                 /  \
       /    \               /    \
      /      \             /      \
     /        \           /        \
   100        101       110        111
  /   \      /   \     /   \      /   \
1000 1001  1010 1011 1100 1101  1110 1111 
</code></pre>
<p>and not only that, but the tree is a prefix tree of the binary representations--the direct children of every node are labeled with precisely its label with either 0 or 1 appended. Hence, lexicographic comparison of the bits will sort correctly within each tier, sort all nodes after their immediate parents, and sort all nodes before later nodes than their parents in their parents' tier.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/277636/">277636</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




