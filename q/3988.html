<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::3988</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>826</td><td>Rust</td><td>250219T213225Z</td><td><a href="https://codegolf.stackexchange.com/questions/3988/advanced-code-golf-write-a-small-http-server/278316#278316">jan</a></td></tr>
<tr d-ix="1"><td>434</td><td>Lua 5.1 in</td><td>150117T034404Z</td><td><a href="https://codegolf.stackexchange.com/questions/3988/advanced-code-golf-write-a-small-http-server/44634#44634">thenumbe</a></td></tr>
<tr d-ix="2"><td>655</td><td>Python 3</td><td>141120T144920Z</td><td><a href="https://codegolf.stackexchange.com/questions/3988/advanced-code-golf-write-a-small-http-server/41689#41689">Tuomas L</a></td></tr>
<tr d-ix="3"><td>636</td><td>Node.js</td><td>140622T160457Z</td><td><a href="https://codegolf.stackexchange.com/questions/3988/advanced-code-golf-write-a-small-http-server/32231#32231">user344</a></td></tr>
<tr d-ix="4"><td>3504</td><td>VB.Net</td><td>140222T140010Z</td><td><a href="https://codegolf.stackexchange.com/questions/3988/advanced-code-golf-write-a-small-http-server/21757#21757">Toothbru</a></td></tr>
<tr d-ix="5"><td>575</td><td>Erlang escript</td><td>130419T174147Z</td><td><a href="https://codegolf.stackexchange.com/questions/3988/advanced-code-golf-write-a-small-http-server/11412#11412">Hynek -P</a></td></tr>
<tr d-ix="6"><td>354</td><td>Bash+netcat</td><td>130303T161641Z</td><td><a href="https://codegolf.stackexchange.com/questions/3988/advanced-code-golf-write-a-small-http-server/10832#10832">manatwor</a></td></tr>
<tr d-ix="7"><td>nan</td><td>Python 2</td><td>111227T163657Z</td><td><a href="https://codegolf.stackexchange.com/questions/3988/advanced-code-golf-write-a-small-http-server/4412#4412">cemper93</a></td></tr>
<tr d-ix="8"><td>869</td><td>C#</td><td>111211T143302Z</td><td><a href="https://codegolf.stackexchange.com/questions/3988/advanced-code-golf-write-a-small-http-server/4308#4308">ICR</a></td></tr>
<tr d-ix="9"><td>485</td><td>Groovy</td><td>111205T163150Z</td><td><a href="https://codegolf.stackexchange.com/questions/3988/advanced-code-golf-write-a-small-http-server/4121#4121">Armand</a></td></tr>
<tr d-ix="10"><td>383</td><td>Ruby</td><td>111126T191330Z</td><td><a href="https://codegolf.stackexchange.com/questions/3988/advanced-code-golf-write-a-small-http-server/3993#3993">Howard</a></td></tr>
<tr d-ix="11"><td>7203</td><td>VB.NET</td><td>111130T040335Z</td><td><a href="https://codegolf.stackexchange.com/questions/3988/advanced-code-golf-write-a-small-http-server/4017#4017">Ry-</a></td></tr>
<tr d-ix="12"><td>653</td><td>Scala</td><td>111127T132658Z</td><td><a href="https://codegolf.stackexchange.com/questions/3988/advanced-code-golf-write-a-small-http-server/3998#3998">Gareth</a></td></tr>
<tr d-ix="13"><td>636</td><td>Haskell</td><td>111127T005644Z</td><td><a href="https://codegolf.stackexchange.com/questions/3988/advanced-code-golf-write-a-small-http-server/3995#3995">hammar</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="http://rust-lang.org" rel="nofollow noreferrer">Rust</a>, 826 bytes</h1>
<pre class="lang-rust prettyprint-override"><code>use{io::*,std::*,ErrorKind as E};fn
main(){let
t=net::TcpListener::bind(&quot;[::1]:36895&quot;).unwrap();loop{let
mut s=t.accept().unwrap().0;let
mut i=(&amp;mut s).bytes().map(|c|c.unwrap());let(m,mut
p)=((&amp;mut i).take_while(|c|*c!=b' ').collect::&lt;Vec&lt;u8&gt;&gt;(),b&quot;/var/www&quot;.to_vec());p.append(&amp;mut(&amp;mut i).take_while(|c|*c!=b' ').collect());let(z,k)=if
m==b&quot;GET&quot;{match
fs::read(unsafe{str::from_utf8_unchecked(&amp;p)}){Ok(c)=&gt;(200,c),Err(e)=&gt;match
e.kind(){E::NotFound=&gt;(404,b&quot;404 Not Found&quot;.into()),E::IsADirectory=&gt;(415,vec![]),_=&gt;(500,b&quot;500 Internal Server Error&quot;.into())}}}else{(405,b&quot;405 Not Supported&quot;.into())};p.reverse();write!(&amp;mut
s,&quot;HTTP/1.1 {}
Content-Type:{}
Content-Length:{}

&quot;,z,if p[..5]==*b&quot;lmth.&quot;{&quot;text/html&quot;}else if p[..4]==*b&quot;txt.&quot;||z!=200{&quot;text/plain&quot;}else{&quot;application/octet-stream&quot;},k.len());s.write_all(&amp;k);s.flush();}}
</code></pre>
<p>Uses IPv6. It is somehow janky, as it sometimes gets a BrokenPipe error on the writes, which are the last things being done per connection. I've turned off the Firewall, which stopped another ErrorKind from happening, but maybe not this one. Let other people have Ideas for me about why it occurs.</p>
</div>
<div id="pu1" class="pu"><h1>Lua 5.1 in <s>435</s> 434 bytes</h1>

<pre><code>s=require'socket'.bind('*',36895)while{}do
c=s:accept()u=c:receive'*l':match'GET (.*) HTTP'f,_,e=io.open('/var/www'..u,'rb')d=z
x=z if f then d,_,x=f:read'*a'end
h=u and(x==21 and''or(e==2 and'404 File Not Found'or d
and('200 OK\r\nContent-Type:'..(({txt='text/plain',html='text/html'})[u:match'%.(.-)$']or'application/octet-stream'))or'500 Server Error'))or'405 Not Supported'c:send('HTTP/1.1 '..h..'\r\n\r\n'..(d
or h))c:close()end
</code></pre>
<p>...and the proof...</p>
<p><img src="https://i.sstatic.net/v6WDs.png" alt="" /></p>
</div>
<div id="pu2" class="pu"><h1>Python 3 - 655</h1>

<pre><code>from socket import*
import re
import threading
def x(c):
    u=str(c.recv(1024))
    if not'GET'in u:conn.sendall(t("HTTP/1.1 405 Not Supported"))
    u=re.search('GET [^\s]+ HTTP/1.1',u).group(0).split(" ")[1];u="/index.html" if u == "/" else u;e=u.split(".")[1]
    try:c.sendall(t("HTTP/1.1 200 OK\nContent-Type: "+({'txt':'text/plain','html':'text/html'}[e]if e in'txthtml'else'application/octet-stream')+"\n\n")+open("."+u,'rb').read())
    except:c.sendall(t("HTTP/1.1 404 File Not Found\n\n404 File Not Found"))
t=lambda s: bytes(s,'utf8')
s=socket(AF_INET,SOCK_STREAM)
s.bind(('',36895))
s.listen(10)
while 1:threading.Thread(target=x,args=[s.accept()[0]]).run()
</code></pre>

<p><img src="https://i.sstatic.net/oQ0Yv.jpg" alt="enter image description here"></p>
</div>
<div id="pu3" class="pu"><h1>Node.js - 636</h1>

<p>Only tested on Linux, won't work on Windows.</p>

<pre><code>a=require
b=a('fs')
function c(){g+=o+h+i+j+f+f+o+f}
a('net').createServer(function(d){d.on('data',function(e){f='\r\n'
g='HTTP/1.1 '
h=f+'Content-Type: '
i='text/'
j='plain'
if(k=/^GET (\S+)/.exec((e+'').split(f)[0])){k=k[1]
l=k.slice(k.lastIndexOf('.')+1)
m='www'+k
if(b.existsSync(m)){if(b.lstatSync(m).isDirectory()){g+='200 OK'+h+i+j+f}else{try{n=b.readFileSync(m)
g+='200 OK'+h
if(l=='txt')g+=i+j
else if(l=='html')g+=i+l
else g+='application/octet-stream'
g+=f+f+n}catch(_){o='500 Server Error'
c()}}}else{o='404 File Not Found'
c()}}else{o='405 Not Supported'
c()}
d.write(g)
d.end()})
d.on('error',function(){})}).listen(36895)
</code></pre>

<p><img src="https://i.sstatic.net/BrIbO.png" alt="Screenshot"></p>
</div>
<div id="pu4" class="pu"><h1>VB.Net (3504 characters):</h1>

<pre><code>Imports System.IO:Imports System.Net:Imports System.Net.Sockets:Imports System.Text:Imports System.Text.RegularExpressions:Module x:Dim s=1024,ct As New Dictionary(Of String,String)From{{".htm","text/html"},{".html","text/html"},{".js","text/javascript"},{".css","text/css"},{".png","image/png"},{".jpg","image/jpeg"},{".jpeg","image/jpeg"},{".gif","image/gif"}}:Function b$(f$):Dim ext$=Path.GetExtension(f$):Return If(ct.ContainsKey(ext$),ct(ext$),"text/plain"):End Function:Sub Main(a$()):Try:Dim z As New Dictionary(Of String,String)From{{"--port","8080"},{"--address","127.0.0.1"},{"--base",""}}:For i As Integer=0 To a.Length-2:If a$(i).StartsWith("-")AndAlso z.ContainsKey(a$(i))Then:z(a$(i))=a$(i+1):Next:Dim b$=Path.Combine(My.Computer.FileSystem.CurrentDirectory,z("--base")),s As New TcpListener(IPAddress.Parse(z("--address")),Integer.Parse(z("--port"))),c As TcpServer:s.Start():Do:c=s.AcceptTcpServer():Dim ns As NetworkStream=c.GetStream():Dim sd As New Text.StringBuilder(),rd(s-1)As Byte,r As Integer:Do:r=ns.Read(rd,0,s):sd.Append(Encoding.UTF8.GetString(rd,0,r)):Loop While r=s:Try:If sd.Length&gt;0 Then:Dim dd$=sd.ToString(),h$()=dd$.Split({ControlChars.Cr,ControlChars.Lf},StringSplitOptions.RemoveEmptyEntries),br$()=h$(0).Split(" "c),mt$=br$(0),f$=br$(1).Substring(1),af$=Path.Combine(b$,Uri.UnescapeDataString(Regex.Replace(f$,"\?.*$","")).TrimStart("/"c).Replace("/"c,"\"c)),hv$=br$(2),rh As New Dictionary(Of String,String),sc$="200",sr$="OK",rc()As Byte={}:If hv$&lt;&gt;"HTTP/1.0"AndAlso hv$&lt;&gt;"HTTP/1.1"Then:sc$="505":sr$="HTTP Version Not Supported":rc=Encoding.UTF8.GetBytes("505"&amp;sr$):Else:Try:If f$=String.Empty OrElse f$="/"Then:af$=Path.Combine(b$,"index.html"):f$="/":ElseIf Directory.Exists(af$)Then:af$=Path.Combine(af$,"index.html"):End If:Catch:End Try:If mt$="GET"Then:If f$.Contains("..")Then:sc$="403":sr$="Forbidden":rc=Encoding.UTF8.GetBytes(sc$&amp;" "&amp;sr$):Console.WriteLine("{0} forbidden.",f$):ElseIf Not File.Exists(af$)Then:sc$="404":sr$="Not Found":rc=Encoding.UTF8.GetBytes(sc$&amp;" "&amp;sr$):Console.WriteLine("{0} resulted in 404 Not Found. Path {1}.",f$,af$):Else:Try:rc=File.ReadAllBytes(af$):rh.Add("Content-Length",rc.Length&amp;""):rh.Add("Content-Type",b$(af$)):Catch:sc$="403":sr$="Forbidden":rc = Encoding.UTF8.GetBytes(sc$&amp;" "&amp;sr$):End Try:End If:ElseIf mt$="HEAD"Then:If f$.Contains("..")Then:sc$="403":sr$="Forbidden":rc=Encoding.UTF8.GetBytes(sc$&amp;" "&amp;sr$):Console.WriteLine("{0} forbidden.",f$):ElseIf Not File.Exists(af$)Then:sc$="404":sr$="Not Found":rc=Encoding.UTF8.GetBytes(sc$&amp;" "&amp;sr$):Console.WriteLine("404 Not Found: {0}",f$):Else:Try:rh.Add("Content-Length",New FileInfo(af$).Length&amp;""):rh.Add("Content-Type",b$(af$)):Catch:sc$="403":sr$="Forbidden":rc = Encoding.UTF8.GetBytes(sc$&amp;" "&amp;sr$):End Try:End If:Else:sc$="405":sr$="Method Not Allowed":End If:Dim rr As New List(Of Byte):rr.AddRange(Encoding.UTF8.GetBytes("HTTP/1.1 "&amp;sc$&amp;sr$&amp;ControlChars.CrLf)):Dim cr As New List(Of String):For Each h As KeyValuePair(Of String,String)In rh:cr.Add(h.Key&amp;": "&amp;h.Value):Next:rr.AddRange(Encoding.UTF8.GetBytes(String.Join(ControlChars.CrLf,cr.ToArray()))):rr.Add(13):rr.Add(10):rr.Add(13):rr.Add(10):rr.AddRange(rc):ns.Write(rr.ToArray(),0,rr.Count):End If:End If:Catch ex As Exception:Console.WriteLine("Error:"):Console.WriteLine(ex.ToString()):Dim e()As Byte=Encoding.UTF8.GetBytes("HTTP/1.1 500 Internal x Error"&amp;ControlChars.CrLf &amp;ControlChars.CrLf &amp;"500 Internal x Error"):ns.Write(e,0,e.Length):End Try:c.Close():Loop:Catch:End Try:End Sub:End Module
</code></pre>

<p>Golfed from @minitech's answer.</p>
</div>
<div id="pu5" class="pu"><h2>Erlang (escript) 575</h2>

<p>Very dirty Erlang escript. There have to be one blank line at beginning of file to work well:</p>

<pre><code>$ cat hgolf.erl

main(_)-&gt;{ok,L}=gen_tcp:listen(36895,[]),s(L).
s(L)-&gt;{ok,S}=gen_tcp:accept(L),receive{tcp,S,"GET "++R}-&gt;[F|_]=string:tokens("/var/www"++R," "),case case file:read_file_info(F)of{ok,{_,_,regular,read,_,_,_,_,_,_,_,_,_,_}}-&gt;a;{ok,_}-&gt;"500 Server Error";_-&gt;"404 File Not Found"end of a-&gt;h(S,"200 OK\r\nContent-Type: "++case lists:reverse(F)of"lmth."++_-&gt;"text/html";"txt."++_-&gt;"text/plain";_-&gt;"application/octet-stream"end,[]),file:sendfile(F,S);E-&gt;h(S,E,E)end;_-&gt;E="405 Not Supported",h(S,E,E)end,gen_tcp:close(S),s(L).
h(S,H,B)-&gt;gen_tcp:send(S,["HTTP/1.1 ",H,"\r\n\r\n",B]).
</code></pre>

<p>How to run</p>

<pre><code>$ escript hgolf.erl
</code></pre>

<p><img src="https://i.sstatic.net/rvGSR.png" alt="Screenshot"></p>

<p><strong>Edit:</strong></p>

<p>I have squeezed out 20 chars. <code>case</code> is surprisingly shorter than function with even one argument and three clauses.</p>
</div>
<div id="pu6" class="pu"><h1>Bash+netcat: 354 characters</h1>
<ul>
<li>Two script files are used.</li>
<li>No URL decoding, thus file names with spaces and special characters not supported.</li>
<li>Single threaded, so concurrent requests may fail.</li>
<li>Tested on Linux, works nicely with Firefox and Opera.</li>
</ul>
<p><strong>webserver.sh</strong> (33 characters):</p>
<pre class="lang-bash prettyprint-override"><code>while :;do nc -lp36895 -e./w;done
</code></pre>
<p><strong>w</strong> (321 characters):</p>
<pre class="lang-bash prettyprint-override"><code>read m p v
p=/var/www$p
t=text/plain
[[ -r $p ]]||s='500 Server Error'
[[ -e $p ]]||s='404 Not Found'
[[ $m != GET ]]&amp;&amp;s='405 Not Supported'
[[ $s||-d $p ]]||case ${p##*.} in
txt);;html)t=text/html;;*)t=application/octet-stream;;esac
echo &quot;$v ${s-200 Ok}
Content-Type:$t
&quot;
[[ $s ]]&amp;&amp;echo $s||{ [[ -d $p ]]&amp;&amp;echo||cat $p;}
</code></pre>
<p>Sample run:</p>
<pre><code>bash-4.2$ ./webserver.sh 
</code></pre>
<p>Sample visit (Firefox 19.0):</p>
<p><img src="https://i.sstatic.net/M7MCK.png" alt="enter image description here" /></p>
</div>
<div id="pu7" class="pu"><h2>Python 2, <strike>525 510</strike> 493 (bending the rules 483) chars</h2>
<pre><code>from socket import*
from os.path import*
a=socket(2,1)
a.bind((&quot;&quot;,80))
a.listen(5)
while 1:
 c,_=a.accept();i=c.recv(512).split(&quot;\n&quot;)[0].split();z=i[1][1:];m=i[2]+(i[0]!=&quot;GET&quot;and&quot;405 Not Supported\n\n&quot;*2or exists(z)-1and&quot;404 File Not Found\n\n&quot;*2or&quot;200 OK\n&quot;)
 if(len(m)&gt;16)+isdir(z)&lt;1:
    try:f=open(z,&quot;rb&quot;);m+=&quot;Content-Type: &quot;+{&quot;.txt&quot;:&quot;text/plain&quot;,&quot;html&quot;:&quot;text/html&quot;}.get(z[-4:],&quot;application/octet-stream&quot;)+&quot;\n\n&quot;+f.read()
    except:m=i[2]+&quot;500 Server Error\n\n&quot;*2
 c.send(m);c.close()
</code></pre>
<p>I stated that I only need 483 chars if I bend the rules because the last <code>;c.close()</code> could be omitted. This is because the moment the next client gets accepted, the socket gets closed anyway. This will of course increase waiting time somewhat (Firefox will only display the page when the next client connects, Chrome will display it before, but will continue to load), but the rules do not require me to respond to the request <em>immediately</em>, only to do so <em>at some point</em>.</p>
<p>I am not certain whether this will work on Unixes because I used send instead of sendall and send does not guarantee to actually send everything it is fed. It does work on Windows.</p>
<p><img src="https://i.sstatic.net/hly3p.png" alt="The screenshot that doesn't proof anything because there is no way to tell whether I used Apache or my own server to create it" /></p>
</div>
<div id="pu8" class="pu"><h1>C# (869)</h1>

<p><img src="https://i.sstatic.net/DQPRL.png" alt="It worked"></p>

<pre><code>using E=System.Text.Encoding;using System.IO;class C{static void Main(){var l=new System.Net.Sockets.TcpListener(new System.Net.IPEndPoint(16777343,36895));l.Start();while(0&lt;1){using(var c=l.AcceptTcpClient()){try{string v="200 OK",r="",t="text/plain",p;var s=c.GetStream();var b=new byte[c.ReceiveBufferSize];s.Read(b,0,b.Length);var h=E.UTF8.GetString(b).Split();b=null;try{if(h[0]=="GET"){p="/var/www"+h[1];if(File.Exists(p)){b=File.ReadAllBytes(p);t=p.EndsWith(".txt")?t:p.EndsWith(".html")?"text/html":"application/octet-stream";}else if(!Directory.Exists(p)){v=r="404 Not Found";}}else{v=r="405 Not Supported";}}catch(IOException){v=r="500 Server Error";}b=b??E.UTF8.GetBytes(r);var m=E.UTF8.GetBytes("HTTP/1.1 "+v+"\r\nContent-Type:"+t+";charset=utf-8\r\nContent-Length:"+b.Length+"\r\n\r\n");s.Write(m,0,m.Length);s.Write(b,0,b.Length);}catch(IOException){}}}}}
</code></pre>

<p>Ungolfed</p>

<pre><code>using System.Text;
using System.IO;

class C {
    static void Main() {
        var listener = new System.Net.Sockets.TcpListener(new System.Net.IPEndPoint(16777343,36895));
        listener.Start();

        while (true){
            using (var client = listener.AcceptTcpClient()) {
                try {
                    string responseCode = "200 OK", responseBody = "", contentType = "text/plain", path;
                    var stream = client.GetStream();

                    var bytes = new byte[client.ReceiveBufferSize];
                    stream.Read(bytes,0,bytes.Length);

                    var requestHeaders = Encoding.UTF8.GetString(bytes).Split();
                    bytes = null;

                    try{
                        if(requestHeaders[0] == "GET"){
                            path = "/var/www" + requestHeaders[1];

                            if (File.Exists(path)) {
                                bytes = File.ReadAllBytes(path);
                                contentType = path.EndsWith(".txt") ? contentType : path.EndsWith(".html") ? "text/html" : "application/octet-stream";
                            } else if (!Directory.Exists(path)){
                                responseCode = responseBody = "404 Not Found";
                            }
                        } else {
                            responseCode = responseBody = "405 Not Supported";
                        }
                    } catch(IOException) {
                        responseCode = responseBody = "500 Server Error";
                    }
                    bytes = bytes ?? Encoding.UTF8.GetBytes(responseBody);

                    var responseHeader=Encoding.UTF8.GetBytes("HTTP/1.1 " + responseCode + "\r\nContent-Type:" + contentType + ";charset=utf-8\r\nContent-Length:" + bytes.Length + "\r\n\r\n");
                    stream.Write(responseHeader, 0, responseHeader.Length);
                    stream.Write(bytes, 0, bytes.Length);
                } catch(IOException) {
                    // If a client disconnects in the middle of a request (e.g. by refreshing the browser) an IOException is thrown.
                }
            }
        }
    }
}
</code></pre>
</div>
<div id="pu9" class="pu"><h1>Groovy, <s>507</s> <s>500</s> <s>489</s> 485</h1>

<pre><code>for(ServerSocket s=new ServerSocket(36895);;){t=s.accept()
o=t.outputStream
o&lt;&lt;"HTTP/1.1 "
e='\r\n'*2
d={o&lt;&lt;"$it$e$it"}
p=t.inputStream.newReader().readLine().split()
if(p[0]!='GET')d'405 Not Supported'else{f=new File('/var/www/',p[1])
if(!f.exists())d'404 File Not Found'else if(f.isFile()){x=f.name=~/\.(.*)/
o&lt;&lt;"200 OK\r\nContent-Type: ${[html:'text/html',txt:'text/plain'][!x?:x[0][1]]?:'application/octet-stream'}$e"
try{o.bytes=f.bytes}catch(t){d"500 Server Error"}}}
o.close()}
</code></pre>

<p><img src="https://i.sstatic.net/YxRjE.png" alt="enter image description here"></p>

<p>Added the image download to show binary files are working properly - had a few issues with them to begin with.</p>

<p>Can anyone suggest a shorter way to read the input?</p>
</div>
<div id="pu10" class="pu"><h3>Ruby, 383 characters</h3>
<pre><code>require 'socket'
v=TCPServer.new 36895
while c=v.accept
h=&quot;200 OK&quot;;m=&quot;&quot;;t=&quot;&quot;
(c.gets=~/GET (\S*)/)?File.directory?(s='C:/hgolf'+$1)?0:File.exist?(s)?(h+=&quot;\r\nContent-Type: &quot;+(s=~/\.txt$/?&quot;text/plain&quot;:s=~/\.html$/?&quot;text/html&quot;:&quot;application/octet-stream&quot;);t=&quot;IO.copy_stream(s,c)&quot;):(h=m=&quot;404 File Not Found&quot;):(h=m=&quot;405 Not Supported&quot;)
c.puts &quot;HTTP/1.1 #{h}\r\n\r\n&quot;+m
eval(t)
c.close
end
</code></pre>
<p>The restructuring of the code to pack the essential logic into one line which makes the code shorter. Nevertheless, I hope this version can be golfed a little bit further.</p>
<p><img src="https://i.sstatic.net/3anmo.png" alt="enter image description here" /></p>
<p>Note: I didn't yet implement the &quot;500 Server Error&quot; because I couldn't find an appropriate structure (maybe packaging everything into begin/rescue/end but reading the file is done after the header was sent).</p>
</div>
<div id="pu11" class="pu"><h1>VB.NET, 7203</h1>

<p><img src="https://i.sstatic.net/27LXi.png" alt="Picture of server running"></p>

<p>You can define any port and any base directory using <code>--port</code> and <code>--base</code>, respectively.</p>

<p>No, this isn't really a golfing solution. But being VB.NET, there's really no point anyway. On the plus side, this one has lots more features.</p>

<pre><code>Imports System.IO
Imports System.Net
Imports System.Net.Sockets
Imports System.Text
Imports System.Text.RegularExpressions

Public Module Server
    Private Const READ_BUFFER_SIZE As Integer = 1024

#Region "Content-Type Identification"
    Private ReadOnly ContentTypes As New Dictionary(Of String, String) From {
            {".htm", "text/html"},
            {".html", "text/html"},
            {".js", "text/javascript"},
            {".css", "text/css"},
            {".png", "image/png"},
            {".jpg", "image/jpeg"},
            {".jpeg", "image/jpeg"},
            {".gif", "image/gif"}
        } 'Feel free to add more.

    ''' &lt;summary&gt;
    ''' Retrieves the Content-Type of the specified file.
    ''' &lt;/summary&gt;
    ''' &lt;param name="filepath"&gt;The file for which to retrieve the Content-Type.&lt;/param&gt;
    Private Function GetContentType(ByVal filepath As String) As String
        Dim ext As String = IO.Path.GetExtension(filepath)

        If ContentTypes.ContainsKey(ext) Then _
            Return ContentTypes(ext)

        Return "text/plain"
    End Function
#End Region

#Region "Server Main()"
    Public Sub Main(ByVal args() As String)
        Try
            'Get a dictionary of options passed:
            Dim options As New Dictionary(Of String, String) From {
                {"--port", "8080"},
                {"--address", "127.0.0.1"},
                {"--base", String.Empty}
            }

            For i As Integer = 0 To args.Length - 2
                If args(i).StartsWith("-") AndAlso options.ContainsKey(args(i)) Then _
                    options(args(i)) = args(i + 1)
            Next

            'Get the base directory:
            Dim basedir As String = Path.Combine(My.Computer.FileSystem.CurrentDirectory, options("--base"))

            'Start listening:
            Dim s As New TcpListener(IPAddress.Parse(options("--address")), Integer.Parse(options("--port"))) 'Can be changed.
            Dim client As TcpClient

            s.Start()

            Do
                'Wait for the next TCP client, and accept the connection:
                client = s.AcceptTcpClient()

                'Read the data being sent to the server:
                Dim ns As NetworkStream = client.GetStream()
                Dim sendingData As New Text.StringBuilder()
                Dim rdata(READ_BUFFER_SIZE - 1) As Byte
                Dim read As Integer

                Do
                    read = ns.Read(rdata, 0, READ_BUFFER_SIZE)
                    sendingData.Append(Encoding.UTF8.GetString(rdata, 0, read))
                Loop While read = READ_BUFFER_SIZE

                'Get the method and requested file:
#If Not Debug Then
                Try
#End If
                If sendingData.Length &gt; 0 Then
                    Dim data As String = sendingData.ToString()

                    Dim headers() As String = data.Split({ControlChars.Cr, ControlChars.Lf}, StringSplitOptions.RemoveEmptyEntries)
                    Dim basicRequestInfo() As String = headers(0).Split(" "c)
                    Dim method As String = basicRequestInfo(0)
                    Dim filepath As String = basicRequestInfo(1).Substring(1)
                    Dim actualFilepath As String = Path.Combine(basedir, Uri.UnescapeDataString(Regex.Replace(filepath, "\?.*$", "")).TrimStart("/"c).Replace("/"c, "\"c))
                    Dim httpVersion As String = basicRequestInfo(2)

                    'Set up the response:
                    Dim responseHeaders As New Dictionary(Of String, String)

                    Dim statusCode As String = "200"
                    Dim statusReason As String = "OK"
                    Dim responseContent() As Byte = {}

                    'Check the HTTP version - we only support HTTP/1.0 and HTTP/1.1:
                    If httpVersion &lt;&gt; "HTTP/1.0" AndAlso httpVersion &lt;&gt; "HTTP/1.1" Then
                        statusCode = "505"
                        statusReason = "HTTP Version Not Supported"
                        responseContent = Encoding.UTF8.GetBytes("505 HTTP Version Not Supported")
                    Else

                        'Attempt to check if the requested path is a directory; if so, we'll add index.html to it:
                        Try
                            If filepath = String.Empty OrElse filepath = "/" Then
                                actualFilepath = Path.Combine(basedir, "index.html")
                                filepath = "/"
                            ElseIf Directory.Exists(actualFilepath) Then
                                actualFilepath = Path.Combine(actualFilepath, "index.html")
                            End If
                        Catch
                            'Ignore the error; it will appear once again when we try to read the file.
                        End Try

                        'Check the method - we only support GET and HEAD:
                        If method = "GET" Then
                            'Make sure nobody's trying to hack the system by requesting ../whatever or an absolute path:
                            If filepath.Contains("..") Then
                                statusCode = "403"
                                statusReason = "Forbidden"
                                responseContent = Encoding.UTF8.GetBytes("403 Forbidden")
                                Console.WriteLine("Access to {0} was forbidden.", filepath)
                            ElseIf Not File.Exists(actualFilepath) Then
                                statusCode = "404"
                                statusReason = "Not Found"
                                responseContent = Encoding.UTF8.GetBytes("404 Not Found")
                                Console.WriteLine("A request for file {0} resulted in a 404 Not Found. The actual path was {1}.", filepath, actualFilepath)
                            Else
                                Try
                                    'Read the requested file:
                                    responseContent = File.ReadAllBytes(actualFilepath)

                                    'Get the requested file's length:
                                    responseHeaders.Add("Content-Length", responseContent.Length.ToString())

                                    'And get its content type too:
                                    responseHeaders.Add("Content-Type", GetContentType(actualFilepath))
                                Catch
                                    'Couldn't get the file's information - assume forbidden.
                                    statusCode = "403"
                                    statusReason = "Forbidden"
                                    responseContent = Encoding.UTF8.GetBytes("403 Forbidden")
                                End Try
                            End If
                        ElseIf method = "HEAD" Then
                            'Make sure nobody's trying to hack the system by requesting ../whatever or an absolute path:
                            If filepath.Contains("..") Then
                                statusCode = "403"
                                statusReason = "Forbidden"
                                responseContent = Encoding.UTF8.GetBytes("403 Forbidden")
                                Console.WriteLine("Access to {0} was forbidden.", filepath)
                            ElseIf Not File.Exists(actualFilepath) Then
                                statusCode = "404"
                                statusReason = "Not Found"
                                responseContent = Encoding.UTF8.GetBytes("404 Not Found")
                                Console.WriteLine("A request for file {0} resulted in a 404 Not Found.", filepath)
                            Else
                                Try
                                    'Get the requested file's length:
                                    responseHeaders.Add("Content-Length", New FileInfo(actualFilepath).Length.ToString())

                                    'And get its content type too:
                                    responseHeaders.Add("Content-Type", GetContentType(actualFilepath))
                                Catch
                                    'Couldn't get the file's information - assume forbidden.
                                    statusCode = "403"
                                    statusReason = "Forbidden"
                                    responseContent = Encoding.UTF8.GetBytes("403 Forbidden")
                                End Try
                            End If
                        Else
                            'Unknown method:
                            statusCode = "405"
                            statusReason = "Method Not Allowed"
                        End If

                        'Prepare the response:
                        Dim response As New List(Of Byte)

                        'Prepare the response's HTTP version and status:
                        response.AddRange(Encoding.UTF8.GetBytes("HTTP/1.1 " &amp; statusCode &amp; statusReason &amp; ControlChars.CrLf))

                        'Prepare the response's headers:
                        Dim combinedResponseHeaders As New List(Of String)
                        For Each header As KeyValuePair(Of String, String) In responseHeaders
                            combinedResponseHeaders.Add(header.Key &amp; ": " &amp; header.Value)
                        Next
                        response.AddRange(Encoding.UTF8.GetBytes(String.Join(ControlChars.CrLf, combinedResponseHeaders.ToArray())))

                        'Prepare the response's content:
                        response.Add(13)
                        response.Add(10)
                        response.Add(13)
                        response.Add(10)
                        response.AddRange(responseContent)

                        'Finally, write the response:
                        ns.Write(response.ToArray(), 0, response.Count)
                    End If
                End If
#If Not Debug Then
                Catch ex As Exception
                    Console.WriteLine("Serious error while processing request:")
                    Console.WriteLine(ex.ToString())
                    Dim errorResponse() As Byte = Encoding.UTF8.GetBytes("HTTP/1.1 500 Internal Server Error" &amp; ControlChars.CrLf &amp; ControlChars.CrLf &amp; "500 Internal Server Error")
                    ns.Write(errorResponse, 0, errorResponse.Length)
                End Try
#End If

                'And at last, close the connection:
                client.Close()
            Loop
        Catch ex As SocketException
            Console.WriteLine("SocketException occurred. Is the socket already in use?")
            Console.ReadKey(True)
        End Try
    End Sub
#End Region

End Module
</code></pre>

<p>I even decided to put it on GitHub :) <a href="https://github.com/minitech/DevServ" rel="nofollow noreferrer">https://github.com/minitech/DevServ</a></p>
</div>
<div id="pu12" class="pu"><h2>Scala, 653 characters</h2>

<pre><code>import java.net._
import java.io._
object I extends App{val l=new ServerSocket(36895)
while(true){var (s,e,c,b)=(l.accept,"200 OK","text/html","")
var h=io.Source.fromInputStream(s.getInputStream).getLines.next.split(" ")
if(h(0)!="GET"){e="405 Not Supported"
b=e}else{var f=new File("/var/www"+h(1))
if(!f.isDirectory){if(f.exists){var q=h(1).split("\\.").last
if(q=="txt")c="text/plain"else if(q!="html")c="application/octet-stream"
try b=io.Source.fromFile(f).mkString catch{case _=&gt;e="500 Server Error";b=e}}else{e="404 File Not Found"
b=e}}}
var o=new PrintWriter(s.getOutputStream)
o.print("HTTP/1.1 "+e+"\nContent-Encoding:"+c+"\n\n"+b)
o.close}}
</code></pre>

<p>A screenshot of it running on my MacBook:</p>

<p><img src="https://i.sstatic.net/mFYiM.jpg" alt="Screenshot"></p>

<p>Not great, but I'll have a go at squashing it a bit when I've got some time later.</p>
</div>
<div id="pu13" class="pu"><h1>Haskell, 636</h1>

<pre><code>import Data.List;import Network;import System.Directory;import System.IO
main=listenOn(PortNumber 36895)&gt;&gt;=l;l s=(n s`catch`\_-&gt;u())&gt;&gt;l s
n s=do(h,_,_)&lt;-accept s;z h&gt;&gt;=q.words&gt;&gt;=hPutStr h;hClose h
q("GET":p:_)=d$"/var/www"++p;q _=c"405 Not Supported"
d p=doesFileExist p&gt;&gt;=f p;e x|x=u$s""""|1&lt;3=c"404 File Not Found"
f p x|x=t p`catch`\_e-&gt;c"500 Server Error"|1&lt;3=doesDirectoryExist p&gt;&gt;=e
t p=fmap(s$"\nContent-Type: "++g p)$z=&lt;&lt;openBinaryFile p ReadMode
r s h b=["HTTP/1.0 ",s,h,"\n\n",b]&gt;&gt;=id
g p|b".html"p="text/html"|b".txt"p="text/plain"|1&lt;3="application/octet-stream"
s=r"200 OK";c s=u$r s[]s;u=return;b=isSuffixOf;z=hGetContents
</code></pre>

<p>Files are streamed lazily, so serving large files does not use much memory, but this also means that only errors at the start of transmission (e.g. permission errors) result in a <code>500 Server Error</code>.</p>

<p><img src="https://i.sstatic.net/NzJxw.png" alt="Serving a HTML page"></p>

<p>Tested on Ubuntu 10.10. Can be ported to Windows by changing the <code>/var/www</code> to <code>C:/hgolf</code> and changing <code>main=</code> to <code>main=withSocketsDo$</code>, since the sockets library on Windows requires explicit initialization.</p>

<p><strong>Ungolfed version:</strong></p>

<pre><code>import Data.List
import Network
import System.Directory
import System.IO

root = "/var/www"

main = do
    s &lt;- listenOn (PortNumber 36895)
    loop s

loop s = (next s `catch` \e -&gt; return ()) &gt;&gt; loop s

next s = do
    (h, _, _) &lt;- accept s
    hGetContents h &gt;&gt;= serve &gt;&gt;= hPutStr h
    hClose h

serve req =
    case words req of
        ("GET" : path : _) -&gt; deliver (root ++ path)
        _ -&gt; complain "405 Not Supported"

deliver path = do
    isFile &lt;- doesFileExist path
    if isFile
        then transfer path `catch` (\e -&gt; complain "500 Server Error")
        else do isDir &lt;- doesDirectoryExist path
                if isDir
                    then return $ response "200 OK" [] ""
                    else complain "404 File Not Found"

transfer path = do
   body &lt;- hGetContents =&lt;&lt; openBinaryFile path ReadMode
   return $ response "200 OK" ["Content-Type: " ++ guessType path] body

response status headers body =
  concat [unlines $ ("HTTP/1.0 " ++ status) : headers, "\n", body]

complain status = return $ response status [] status

guessType path
    | ".html" `isSuffixOf` path = "text/html"
    | ".txt"  `isSuffixOf` path = "text/plain"
    | otherwise                 = "application/octet-stream"
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/3988/">3988</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




