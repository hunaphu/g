<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::36384</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>004</td><td>Thunno 2 h</td><td>230722T165214Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/263183#263183">The Thon</a></td></tr>
<tr d-ix="1"><td>005</td><td>Vyxal</td><td>221128T005529Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/254926#254926">emanresu</a></td></tr>
<tr d-ix="2"><td>6564</td><td>Regex Perl / PCRE</td><td>190118T044621Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/178889#178889">Deadcode</a></td></tr>
<tr d-ix="3"><td>037</td><td>Factor + math.primes.factors</td><td>210328T033747Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/222492#222492">chunes</a></td></tr>
<tr d-ix="4"><td>5571</td><td>Husk</td><td>201115T132115Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/215230#215230">Dominic </a></td></tr>
<tr d-ix="5"><td>009</td><td>Stax</td><td>201115T122656Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/215229#215229">Razetime</a></td></tr>
<tr d-ix="6"><td>009</td><td>MathGolf</td><td>190305T151756Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/180925#180925">maxb</a></td></tr>
<tr d-ix="7"><td>005</td><td>Brachylog</td><td>190304T091840Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/180829#180829">Unrelate</a></td></tr>
<tr d-ix="8"><td>100</td><td>ECMAScript 2016</td><td>190123T162530Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/179048#179048">M Dirr</a></td></tr>
<tr d-ix="9"><td>044</td><td>Charcoal</td><td>190119T172830Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/178932#178932">Neil</a></td></tr>
<tr d-ix="10"><td>006</td><td>05AB1E</td><td>190118T112553Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/178903#178903">Kevin Cr</a></td></tr>
<tr d-ix="11"><td>183</td><td>Whispers v2</td><td>181110T185153Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/175669#175669">caird co</a></td></tr>
<tr d-ix="12"><td>007</td><td>Pyth</td><td>180908T100601Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/171866#171866">Mr. Xcod</a></td></tr>
<tr d-ix="13"><td>058</td><td>Julia</td><td>180710T152426Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/168352#168352">Sundar R</a></td></tr>
<tr d-ix="14"><td>008</td><td>Japt g</td><td>180709T100510Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/168215#168215">Shaggy</a></td></tr>
<tr d-ix="15"><td>nan</td><td>Jelly</td><td>170222T152326Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/110929#110929">user6213</a></td></tr>
<tr d-ix="16"><td>020</td><td>MATL noncompetitive</td><td>151221T104640Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/67232#67232">Luis Men</a></td></tr>
<tr d-ix="17"><td>nan</td><td>Seriously</td><td>160201T044536Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/70680#70680">user4594</a></td></tr>
<tr d-ix="18"><td>067</td><td>Python 2</td><td>150611T065324Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/51561#51561">xnor</a></td></tr>
<tr d-ix="19"><td>016</td><td>J</td><td>150324T052902Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/48099#48099">algorith</a></td></tr>
<tr d-ix="20"><td>019</td><td>J</td><td>140820T120243Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/36504#36504">FireFly</a></td></tr>
<tr d-ix="21"><td>nan</td><td>Java 8  422</td><td>150308T025856Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/47540#47540">Michael </a></td></tr>
<tr d-ix="22"><td>039</td><td>Mathematica</td><td>140819T100821Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/36413#36413">Martin E</a></td></tr>
<tr d-ix="23"><td>161</td><td>C#</td><td>140821T155312Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/36579#36579">Richard </a></td></tr>
<tr d-ix="24"><td>084</td><td>Python 2</td><td>140823T014857Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/36679#36679">xnor</a></td></tr>
<tr d-ix="25"><td>262</td><td>C# LINQ</td><td>140820T091032Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/36499#36499">ldam</a></td></tr>
<tr d-ix="26"><td>nan</td><td></td><td>140821T101419Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/36564#36564">isaacg</a></td></tr>
<tr d-ix="27"><td>056</td><td>Bash+coreutils</td><td>140819T051219Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/36403#36403">Digital </a></td></tr>
<tr d-ix="28"><td>078</td><td> K</td><td>140819T201355Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/36465#36465">Arthur B</a></td></tr>
<tr d-ix="29"><td>129</td><td>Regex</td><td>140820T193119Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/36532#36532">Martin E</a></td></tr>
<tr d-ix="30"><td>166</td><td>Lua</td><td>140819T195239Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/36464#36464">Adriweb</a></td></tr>
<tr d-ix="31"><td>083</td><td>Perl 5.10+</td><td>140821T062706Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/36559#36559">hobbs</a></td></tr>
<tr d-ix="32"><td>062</td><td>Ruby</td><td>140820T170513Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/36521#36521">histocra</a></td></tr>
<tr d-ix="33"><td>085</td><td>PowerShell</td><td>140820T183325Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/36527#36527">Rynant</a></td></tr>
<tr d-ix="34"><td>083</td><td>R</td><td>140820T180636Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/36525#36525">shadowta</a></td></tr>
<tr d-ix="35"><td>113</td><td>Ruby</td><td>140820T002119Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/36484#36484">John Ter</a></td></tr>
<tr d-ix="36"><td>080</td><td>Haskell</td><td>140819T192609Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/36461#36461">proud ha</a></td></tr>
<tr d-ix="37"><td>170</td><td>Clojure</td><td>140819T011437Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/36394#36394">Michael </a></td></tr>
<tr d-ix="38"><td>120</td><td>Haskell</td><td>140819T130949Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/36423#36423">Taylor F</a></td></tr>
<tr d-ix="39"><td>095</td><td>Python 2</td><td>140819T004447Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/36391#36391">isaacg</a></td></tr>
<tr d-ix="40"><td>150</td><td>Cobra</td><td>140819T072253Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/36405#36405">Œüurous</a></td></tr>
<tr d-ix="41"><td>095</td><td>C</td><td>140819T003957Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/36390#36390">Todd Leh</a></td></tr>
<tr d-ix="42"><td>176</td><td>Lua</td><td>140819T005212Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/36392#36392">AndoDaan</a></td></tr>
<tr d-ix="43"><td>013</td><td>CJam</td><td>140819T001652Z</td><td><a href="https://codegolf.stackexchange.com/questions/36384/find-the-smoothest-number/36389#36389">aditsu q</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/Thunno/Thunno2" rel="nofollow noreferrer">Thunno 2</a> <code>h</code>, 4 <a href="https://github.com/Thunno/Thunno2/blob/main/docs/codepage.md" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>I√ûfG
</code></pre>
<p><a href="https://Not-Thonnu.github.io/run#aGVhZGVyPSZjb2RlPUklQzMlOUVmRyZmb290ZXI9JmlucHV0PTUlMEExMSZmbGFncz1o" rel="nofollow noreferrer">Try it online!</a></p>
<h4>Explanation</h4>
<pre class="lang-python prettyprint-override"><code>I√ûfG  # Implicit input
I     # Range between the inputs
 √û    # Sorted by the following:
  f   #  Prime factors of the number
   G  #  Take the maximum of this list
      # Implicit output of first item
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a>, 5 bytes</h1>
<pre><code>·π°‚Ä°«êt‚àµ
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/#WyIiLCIiLCLhuaHigKHHkHTiiLUiLCIiLCI1XG4xMCJd" rel="nofollow noreferrer">Try it Online!</a></p>
<pre><code>·π°     # Range from a to b
    ‚àµ # Minimum by...
 ‚Ä°--  # Next two as function
   t  # Last
  «ê   # Prime factor
</code></pre>
</div>
<div id="pu2" class="pu"><h1>Regex (Perl / PCRE), <s>66</s> 65 (64üêå) bytes</h1>
<p>Inspired by seeing that both <a href="https://codegolf.stackexchange.com/users/8478/martin-ender">Martin Ender</a> and <a href="https://codegolf.stackexchange.com/users/75057/jaytea">jaytea</a>, two regex geniuses, wrote regex solutions to this code golf, I wrote my own from scratch. The famous prime-checking regex does not appear anywhere in my solution.</p>
<p>Do not read this if you don't want some unary regex magic spoiled for you. If you do want to take a shot at figuring out this magic yourself, I highly recommend starting by solving some problems in ECMAScript regex:</p>
<ol>
<li><sub>Match prime numbers (if you aren't already familiar with doing this in regex)</sub></li>
<li><sub>Match powers of 2 (if you haven't already done so). Or just work your way through <a href="https://alf.nu/RegexGolf" rel="nofollow noreferrer">Regex Golf</a>, which includes Prime and Powers. Make sure to do both the Classic and Teukon problem sets.</sub></li>
<li>
<blockquote class="spoiler">
<p> <sub>Find the shortest way to match powers of N where N is some constant (i.e. specified in the regex, not the input) which can be composite (but is not required to be). For example, match powers of 6.</sub></p>
</blockquote>
</li>
<li>
<blockquote class="spoiler">
<p> <sub>Find a way of matching Nth powers, where N is some constant &gt;=2. For example, match perfect squares. (For a warmup, match <a href="https://oeis.org/A000961" rel="nofollow noreferrer">prime powers</a>.)</sub></p>
</blockquote>
</li>
<li>
<blockquote class="spoiler">
<p> <sub>Match correct multiplication statements. Match triangular numbers.</sub></p>
</blockquote>
</li>
<li>
<blockquote class="spoiler">
<p> <sub>Match Fibonacci numbers (if you're as crazy as I am), or if you want to stick to something shorter, match correct statements of exponentiation (for a warmup, return as a match the logarithm in base 2 of a power of 2 ‚Äì bonus, do the same for any number, rounding it however you like), or factorial numbers (for a warmup, match <a href="https://oeis.org/A002110" rel="nofollow noreferrer">primorial numbers</a>).</sub></p>
</blockquote>
</li>
<li>
<blockquote class="spoiler">
<p> <sub>Match abundant numbers (if you're as crazy as I am)</sub></p>
</blockquote>
</li>
<li>
<blockquote class="spoiler">
<p> <sub>Calculate an irrational number to requested precision (e.g. divide the input by the square root of 2, returning the rounded result as a match)</sub></p>
</blockquote>
</li>
</ol>
<p><sub>(The <a href="https://github.com/Davidebyzero/RegexMathEngine" rel="nofollow noreferrer">regex engine I wrote</a> may be of help, as it is very fast at unary math regexes and includes a unary numerical mode which can test ranges of natural numbers (but also has a strings mode which can evaluate non-unary regexes, or unary with delimiters). By default it is ECMAScript compatible, but has optional extensions (which can selectively add subsets of PCRE, or even molecular lookahead, something that no other regex engine has).)</sub></p>
<p>Otherwise, read on, and also read <a href="https://gist.github.com/Davidebyzero/9090628" rel="nofollow noreferrer">this GitHub Gist</a> (warning, many spoilers) which chronicles the journey of pushing ECMAScript regex to tackle natural number functions of increasing difficulty (starting with teukon's set of puzzles, not all of them mathematical, which sparked this journey).</p>
<p>As with the other regex solutions to this problem, the input is given as two numbers in bijective unary, separated by a comma, representing an inclusive range. Only one number is returned. The regex could be modified to return all of the numbers that share the same smallest largest prime factor, as separate matches, but that would require variable-length lookbehind and either putting <code>\K</code> in a lookahead or returning the result as a capture instead of a match.</p>
<p>The technique used here of repeated implicit division by smallest prime factor is identical to that used in the <a href="https://codegolf.stackexchange.com/a/21951/17216">Match strings whose length is a fourth power</a> answer I posted a while back.</p>
<p>With no further ado:</p>
<pre><code>((.+).*),(?!.*(?=\1)((?=(..+)(\4+$))\5)*(?!\2)).*(?=\1)\K(?3)*\2$
</code></pre>
<p><a href="https://tio.run/##RZDfasIwFMbv@xSxBHOOpjWpdn@MtZU5GIy5G@8WKduoIHTqWgcO6S73AHvEvUiXRmU3@c73nV8@QrZZkYf12yehhSKHfPP6nBPaU8ZGo@lkPhlXznJTEKBlJNRorJAcHEKSPCq3@WoHjDNefryUuwJoyj3JJWbvrl678X8qTI5DmqIyN7fFar0DUxc31NB10U/yJ7HwTVMzSTOR3@8fwiy@WgIA27O9hdBSZy8XiNFXjxY9PNjaxDPMKLJou510jYyticGKZ4FTiV17x9w872QboMryMjs2stkjeZjMb@5aTFXmC6Sq0vR2Nk3TGsDvot9BDnHL70AcaYlgBHyTgx50KaIO0WxaOkA8I/oe4j52dEDrOuRSONdchs1x4cjwkgeDKycQQvJAyP4f" rel="nofollow noreferrer" title="Perl 5 ‚Äì Try It Online">Try it online!</a> - Perl<br />
<a href="https://tio.run/##XVBfa9swEH/3p3CEIXepolhO3Db1jBnrxsLaDta@VUG4rhKb2Y6QNSiUve4D7CPui2TnQF/6cjp@/@50trbHD4WtbRi5nC2YsM7stTO2LSsD04WYFVrXZet1dehs0xqnQGGmfiyGKZ9O@Y4gvTcj3XvT@wG0/rK5@aw1comCErOg6Rs9GA/MVs6Ip7L66R0V3TZd4xlnq2S9Wp9fJOuUYRbsDg6iIY@zqM13lDzA/cP15g4zAiW@BmHY7CBqHwfvWtNTh3O5zXOmeoZkGX49EUMwj/lcYhYSZl5se3g2QLM46TPKMFV9oDHFaLtiDAUlxltBirGT1IX//vwNmYDTQbrSVzVEjlP2eB1TepD85MGT6T0ut8ijDou3LbtRecXuvoe3Hx8@fZ3QT3@/OyxgdgQQZyhmyKGYiBkUuZII9IAgHNTqLEJUKRIzUQnim0R9g2KJM5VEx2PKZRysuUzHch7I9IInq8sgiWPJk1gu/wM" rel="nofollow noreferrer" title="PHP ‚Äì Try It Online">Try it online!</a> - PCRE<br />
<a href="https://regex101.com/r/BmJzgw/2" rel="nofollow noreferrer">Try it on regex101</a></p>
<p>And the free-spacing version, with comments:</p>
<pre><code>                        # No ^ anchor needed, because this algorithm always returns a
                        # match for valid input (in which the first number is less than
                        # or equal to the second number), and even in /g mode only one
                        # match can be returned. You can add an anchor to make it reject
                        # invalid ranges.
                        
((.+).*),               # \1 = low end of range; \2 = conjectured number that is the
                        # smallest number in the set of the largest prime factor of each
                        # number in the range; note, it is only in subsequent tests that
                        # this is implicitly confined to being prime.
                        # We shall do the rest of our work inside the &quot;high end of range&quot;
                        # number.

(?!                     # Assert that there is no number in the range whose largest prime
                        # factor is smaller than \2.
  .*(?=\1)              # Cycle tail through all numbers in the range, starting with \1.

  # Subroutine call (?3) - defines one loop iteration, and needs to be called as (?3)*
  # Finds the largest prime factor of tail, and leaves it in tail. It will both be
  # evaluated here as-is, and later as a subroutine call. Here, it's followed by an
  # assertion that tail is less than something; if this fails to match, the regex
  # engine will try to backtrack, but that will never result in a match because
  # backtracking will only make tail larger.
  (                     # Repeatedly divide tail by its smallest prime factor, leaving
                        # only the largest prime factor at the end.

    (?=(..+)(\4+$))     # \5 = tool to make tail = \4 = largest nontrivial factor of
                        # current tail, which is implicitly the result of dividing it
                        # by its smallest prime factor.
    \5                  # tail = \4
  )*
  (?!\2)                # matches iff tail &lt; \ 2
)

# At this point, \2 is guaranteed to be less than or equal to the smallest number in the
# set containing the largest prime factor of each of the numbers in the inputted range.
# The first time the regex engine reaches this point, \2 will be equal to the smallest
# number in that set, but if it backtracks, \2 will become smaller.

# now, pick a number in the range whose largest prime factor is \2
.*(?=\1)                # Cycle tail through all numbers in the range, starting with \1.
\K                      # Set us up to return tail as the match.
(?3)*                   # tail = largest prime factor of tail
\2$                     # Match iff tail == \2, then return the number whose largest
                        # prime factor is \2 as the match. If this fails to match, the
                        # regex engine will try to backtrack, but that will never result
                        # in a match, because backtracking makes tail a composite number
                        # that is larger than the largest prime factor of the currently
                        # marked return value, which makes it larger than any value \2
                        # can have.
</code></pre>
<p>Note that <code>((.+).*)</code> can be changed to <code>((.+)+)</code>, dropping the size by 1 byte (from 65 to <strong>64 bytes</strong>) with no loss of correct functionality ‚Äì but the regex exponentially explodes in üêå slowness:</p>
<pre><code>((.+)+),(?!.*(?=\1)((?=(..+)(\4+$))\5)*(?!\2)).*(?=\1)\K(?3)*\2$
</code></pre>
<p><a href="https://tio.run/##RZDfSsMwFMbv9xRZCcs5a9o10wou65/hBEGcN7szo6h0UIjbbCtMRr30AXxEX6Sm2YY3@c73nV8@QnZ5qcP27ZPQUpKD3r4@a0JH0thoOp8tZ3HTW29LArSKAjmNJZJDj5BUR9VOFzUwznj18VLVJdCMe4ILzN8dtXGS/zQwOU5ohtLc3JXFpgZTl3TUxHHQT/VTsPJNUzcJM5Hf7x/CLF6sAYDt2d5CaKmzFyvE6GtEyxEebG3qGWYaWXQwSF0jsTUJWPEscCqxa@@Ym@edbAc0ua7yYyNbPJKH2fLmrs9kY75AyCbLbhfzLGsBfBdd5JD0/SEkkRIIRsA3MahLlyKqEM2mr8aIZ0TdQ3KBQzWmbRtyEfSuuQi74@oP" rel="nofollow noreferrer" title="Perl 5 ‚Äì Try It Online">Try it online!</a> - Perl<br />
<a href="https://tio.run/##XVDNSsNAEL73KdIl0Jl23XZrq9QYgviDxT9Qb25ZYtw2wSRdNisI4tUH8BF9kTop9NLL7PD9zezY3G5OE5vbIHQxGzJhnVlpZ2yZZgZ6Q9FPtM7T0utsXdmiNE6Bwkg9Dpse7/X4kiC9Mi1de1P7BrS@mt9eao1coqDEqFPUhW6MB2YzZ8Rrmr17R0WXRVV4xtlkPJvMjo7HsynDqLNcOwibeBSFZbyk5Aaeni/m9xgRKPGrEwTFEsLypfGuNDV1eCAXccxUzZAszccrMQTzET@QGAWEmU9brt8M0CxO@ogyTJavaUzS2k4YQ0GJo4UgRdtJ6oK/n9@ACdgepEp9lkPoOGW31zGpB8m3Htya9nG5QB5WmOy2rFrlCbt/CO7Ons@vu/TT773DAkYbADHAAXJIuqIPSawkAj0gCAY1GYSIaorEdNUYcSdRN5AcYl@Nw81myuWoM@Ny2pajfw" rel="nofollow noreferrer" title="PHP ‚Äì Try It Online">Try it online!</a> - PCRE</p>
<h1>Regex (ECMAScript), 80 (79üêå) bytes</h1>
<p>The algorithm can be easily ported to ECMAScript by replacing the subroutine call with a copy of the subroutine, and returning the match as capture group <code>\6</code> instead of using <code>\K</code>. The result is <strong>80 bytes</strong> in length:</p>
<pre><code>((x+)x*),(?!.*(?=\1)((?=(xx+)(\4+$))\5)*(?!\2)).*(?=\1)(((?=(xx+)(\8+$))\9)*\2$)
</code></pre>
<p><a href="https://tio.run/##TU/dTsIwFL7fU2yGZOeMObcJCDaVGGOiF2Ki3jEvKnSj2pWlKzoRbn0AH9EXwaoYvDk9/X5Ovu@RPbN6okVl9utKTLku5@qJv240VfzFveHFeVMBLOnJQbABaNrYBBjC0IsCGNIsQbAPNBaHrNNuIWZdtIyXpYg7yU7T/9EMMMjSFm6CgyVGZn5rtFAFYFRLMeHQC/c7iCSfa8hpQkBSzdlUCsUB0aNqISXJaYxvIgcvx8qaDSBx7BcKKqO6ksKAH/o2guSqMDOPpquVqEdsBIxWTNf80lqKcXyP@Ec8/CcSS@BbtTC10bB3qZ6ZFFNXKIsc7yHZEhLJZK6MUAtO1k5JwW/8SPOKMwMM2zZB@x/yYOOUzExmoG3Y3YntVtKfZkPf/Xz/cEfX7tXp3dmF5x//Aj4S26/8rY9/nnHvflsRyXrTDZPYGYRJ93v0nKR7FKadvpPGcRKmcXL4BQ" rel="nofollow noreferrer" title="JavaScript (SpiderMonkey) ‚Äì Try It Online">Try it online!</a> - <strong>80 byte</strong> version<br />
<a href="https://tio.run/##TU9LTsMwEN3nFEmFlJkmhCQ0hWKZCiEkWFAkYEdYmNZJDY4TOS4UClsOwBG5SDGlqN2Mx@8zeu@RPbN2rEVjdttGTLiuavXEX5eaKv7iXvPybN4AvNHjve4SYB5ggCEMvagLQ5onCPaBuYUh7wU7iHmGlvHyFHEj2WgOV5oBdvN0B5fdvTeMTH1jtFAlYNRKMebQD3d7iKSoNRQ0ISCp5mwiheKA6FE1k5IUNMaFKMArsLFmA0gc@4WSyqhtpDDgh76NILkqzdSj6fu7aEdsBIw2TLf8wlrKu/ge8Z942CYSS@CimZnWaOhcqGcmxcQVyiJHHSRrQiIZ18oINePkw6ko@HM/0rzhzADDwCYItpAHG6diZjwFbcNuTqy3iq6aDX33@/PLHV25lye3p@eef/QH@Ehsv@qvPv577vr364pIPpZZmMTOIEyy39F3kuwgTHuHThrHSZjGyf4P" rel="nofollow noreferrer" title="JavaScript (SpiderMonkey) ‚Äì Try It Online">Try it online!</a> - <strong>79 byte</strong> exponential-slowdown üêå version <sub><sup>(amazingly, this can handle all the test cases in 49 seconds)</sup></sub></p>
</div>
<div id="pu3" class="pu"><h1><a href="https://factorcode.org/" rel="nofollow noreferrer">Factor</a> + <code>math.primes.factors</code>, 37 bytes</h1>
<pre><code>[ [a,b) [ factors last ] infimum-by ]
</code></pre>
<p><a href="https://tio.run/##NcuxCsIwFEbh3af4V0FDWpz0AcTFRZxCh9two8Ekrcnt0KdPS8X18B1HVoZcn4/b/XrGh3PigEjyVmP2kYtyGyi/lim9uGDMLDKvIAkKfydOdq2XXat1g1Y3p2pg6NDvYfD/AxVBB5@cj1M89jO6aikEqLoA" rel="nofollow noreferrer" title="Factor ‚Äì Try It Online">Try it online!</a></p>
<h2>Explanation:</h2>
<p>This is a quotation (anonymous function) that takes two integers from the data stack as input and leaves one integer on the data stack as output. Assuming <code>2001 2014</code> is on top of the data stack when this quotation is called...</p>
<ul>
<li><code>[a,b)</code> Create a range object from two integers. The lower bound is included but the upper bound is excluded. <strong>Stack:</strong> <code>T{ range f 2001 13 1 }</code></li>
<li><code>[ factors last ]</code> Push a quotation to the data stack to be used later by the <code>infimum-by</code> word. <strong>Stack:</strong> <code>T{ range f 2001 13 1 } [ factors last ]</code></li>
<li><code>infimum-by</code> Apply a quotation to each element of a sequence, returning the element whose result is smallest. (Inside the quotation now...) <strong>Stack:</strong> <code>2001</code></li>
<li><code>factors</code> Get the sorted list of prime factors given an integer. <strong>Stack:</strong> <code>{ 3 23 29 }</code></li>
<li><code>last</code> Get the last element of a sequence. <strong>Stack:</strong> <code>29</code></li>
<li>Now <code>infimum-by</code> takes note of <code>29</code> and moves onto the next element in its input range...</li>
</ul>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/barbuz/Husk" rel="nofollow noreferrer">Husk</a>, 5 bytes = 5.71 characters</h1>
<pre><code>‚óÑo‚ñ≤p‚Ä¶
</code></pre>
<p><a href="https://tio.run/##yygtzv6f@6ip8f@j6S35j6ZtKnjUsOz////R0aY6hgaxOtGWOoamEMoMSBmamusYmVgAWUYGBoY6RgaGxrGxAA" rel="nofollow noreferrer" title="Husk ‚Äì Try It Online">Try it online!</a></p>
<p><strong>How?</strong></p>
<pre><code>‚óÑ       # element that minimizes result of
 o      # combining these 2 functions:
  ‚ñ≤     # maximum of
   p    # prime factors
    ‚Ä¶   # for the range from arg 1 ... arg 2
</code></pre>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/tomtheisen/stax" rel="nofollow noreferrer">Stax</a>, 9 <a href="https://github.com/tomtheisen/stax/blob/master/docs/packed.md#packed-stax" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>√ºwœÄ‚îº‚ô¶Œ£j√¥‚â§
</code></pre>
<p><a href="https://staxlang.xyz/#p=8177e3c504e46a93f3&amp;i=5+11%0A9+16%0A9+17%0A157+249%0A2001+2014&amp;m=2" rel="nofollow noreferrer">Run and debug it</a></p>
<p>Thought this would be shorter.</p>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/maxbergmark/mathgolf" rel="nofollow noreferrer">MathGolf</a>, 9 bytes</h1>

<pre><code>‚Ü®√°√¶‚îÄg¬∂‚ïô0¬ß
</code></pre>

<p><a href="https://tio.run/##y00syUjPz0n7//9R24rDCw8vezSlIf3QtkdTZxocWv7/v6mCoQGXpYKhKYgw4zI0NVcwMrHgMjIwMFQwMjA0/g8A" rel="nofollow noreferrer" title="MathGolf ‚Äì Try It Online">Try it online!</a></p>

<h2>Explanation</h2>

<p>Could be 1-2 bytes shorter with a "get prime factorization" operator.</p>

<pre><code>‚Ü®           pop a, b, loop from a to b (inclusive)
 √°          sort by comparator
  √¶         start block of length 4
   ‚îÄ        get divisors
    g       pop a, (b), pop operator from code, filter
     ¬∂      is_prime(n)
      ‚ïô     maximum of two elements, max of list, maximum by filter
       0    push 0
        ¬ß   get from array
</code></pre>
</div>
<div id="pu7" class="pu"><h1><a href="https://github.com/JCumin/Brachylog" rel="nofollow noreferrer">Brachylog</a>, 5 bytes</h1>

<pre><code>‚ü¶‚ÇÉ·∏ã·µíh
</code></pre>

<p><a href="https://tio.run/##SypKTM6ozMlPN/r/qG3Do6bGh1snlP9/NH/Zo6bmhzu6H26dlPH/f3S0qY6hYaxOtKWOoRmEMgdShqbmOkYmlkCWkYGBoY6RgaFJbCwA" rel="nofollow noreferrer" title="Brachylog ‚Äì Try It Online">Try it online!</a></p>

<p>Takes input as a list of two (or more, actually) values in no particular order, and outputs a single value through the output variable of the predicate (if you try to run it as a full program, it'll just print <code>true.</code> at you, unless you stick a <code>w</code> on the end). The input is interpreted as a Python-style range because to feed <code>‚ü¶</code> multiple values I need to give it a subscript no matter whether it's <code>‚ÇÇ</code>, <code>‚ÇÉ</code>, or <code>‚ÇÑ</code> so I may as well choose the one that matches the test cases.</p>

<pre><code>    h The first item of
‚ü¶‚ÇÉ    the range represented by the input
   ·µí  after it's been sorted by
  ·∏ã   prime factorization.
</code></pre>

<p>Saves three bytes over the more obvious <code>‚ü¶‚ÇÉ{·∏ãh}·µíh</code> by taking advantage of that Brachylog sorts its lists by elements first rather than lengths, such that the first step of sorting by prime factorizations is sorting by largest prime factors.</p>
</div>
<div id="pu8" class="pu"><h1>ECMAScript 2016 - 100 characters</h1>
<pre><code>m=&gt;M=&gt;(r=_=&gt;M-m?[m,...r(++m)]:[])().sort((x,y)=&gt;(s=(n,p=2)=&gt;n&gt;p?n%p?s(n,p+1):s(n/p,p):p)(x)-s(y))[0]
</code></pre>
<p>Definitely gets hurt by the lack of a built-in range.</p>
<p>This is a pretty standard anonymous function. It takes in a minimum (inclusive) and a maximum (exclusive), and then spits out the smallest smoothest number in that range.</p>
</div>
<div id="pu9" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 44 bytes</h1>

<pre><code>ÔºÆŒ∏‚âî‚Ä¶Œ∏ÔºÆŒ∑‚âî¬πŒ∂Ôº∑¬¨‚ÑñŒ∑¬π¬´‚â¶‚äïŒ∂Ôº∑‚äôŒ∑¬¨Ôπ™ŒªŒ∂ÔºµÔº≠Œ∑‚éáÔπ™ŒªŒ∂Œª√∑ŒªŒ∂¬ªÔº©‚Å∫Œ∏‚åïŒ∑¬π
</code></pre>

<p><a href="https://tio.run/##VY/LCsIwEEXX5iuyTCAuKopIV6UiuKiI@AOxDW0gndQ8KlX89thQRV0O95zLnbLhptRchbCHzruDby/CkCtNUWatrIGcONSCXBn@zSlluPkyCcP38bo1UglMDtqRXHtwpGE4oZTiB5oVvHvDeyiNaAU4UU3a7O1lMEQj6oWuvNJERSAWjHau25ZDFYmzMMDN8EcxrOJEt5W9rMTHTNETHY0cp@TcOnJU3sZXdnIqiuNoGkKyWuPFchPmvXoB" rel="nofollow noreferrer" title="Charcoal ‚Äì Try It Online">Try it online!</a> Link is to verbose version of code. Takes input as a half-open range and returns the lowest smoothest number from that range. Works by trial division of all the numbers in the range until at least one has become completely factorised (in which case it is the smoothest). Explanation:</p>

<pre><code>ÔºÆŒ∏
</code></pre>

<p>Input the lower end of the range.</p>

<pre><code>‚âî‚Ä¶Œ∏ÔºÆŒ∑
</code></pre>

<p>Create an array covering the whole range.</p>

<pre><code>‚âî¬πŒ∂
</code></pre>

<p>Set the initial factor to 1.</p>

<pre><code>Ôº∑¬¨‚ÑñŒ∑¬π¬´
</code></pre>

<p>Repeat until there is at least one <code>1</code> in the array.</p>

<pre><code>‚â¶‚äïŒ∂
</code></pre>

<p>Increment the factor.</p>

<pre><code>Ôº∑‚äôŒ∑¬¨Ôπ™ŒªŒ∂
</code></pre>

<p>Repeat while at least one element is divisible by the factor.</p>

<pre><code>ÔºµÔº≠Œ∑‚éáÔπ™ŒªŒ∂Œª√∑ŒªŒ∂¬ª
</code></pre>

<p>Divide all divisible elements by the factor.</p>

<pre><code>Ôº©‚Å∫Œ∏‚åïŒ∑¬π
</code></pre>

<p>Look up the (first) index of the <code>1</code>, add on the lower end of the range, and print the result as a string.</p>
</div>
<div id="pu10" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 6 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<p>Input as a list of two items, outputs just one found integer in the <code>[A,B]</code> range (inclusive on both sides):</p>
<pre><code>≈∏Œ£fŒ∏}–Ω
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//6I5zi9PO7ai9sPf//2hLHUPTWAA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/V9Waa@k8KhtkoKSfeX/ozvOLU47t6P2wt7/Ov@jo011DA1jdRSiLXUMjaC0KZQ2g9LmINrQ1FzHyMQSxDQyMDDUMTIwNImNBQA" rel="nofollow noreferrer">verify all test cases</a>.</p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>≈∏          # Create a list in the inclusive range of the (implicit) input
           #  i.e. [9,15] ‚Üí [9,10,11,12,13,14,15]
 Œ£  }      # Sort it by:
  f        #  Get the prime factors
           #   i.e. 9 ‚Üí [3]
           #   i.e. 10 ‚Üí [2,5]
   Œ∏       #  Pop and push the last item
           #   i.e. [3] ‚Üí 3
           #   i.e. [2,5] ‚Üí 5
           #  i.e. [9,10,11,12,13,14,15] ‚Üí [9,12,10,15,14,11,13]
     –Ω     # After sorting, pop and push the first item
           #  i.e. [9,12,10,15,14,11,13] ‚Üí 9
           # (and output the result implicitly as result)
</code></pre>

<hr />
<p><strong>8 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></strong> alternative with same input-format, but outputs all found integers (as string) instead of one:</p>
<pre class="lang-none prettyprint-override"><code>≈∏Df‚Ç¨Œ∏WQ√è
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//6A6XtEdNa87tCA883P//f7SljqFpLAA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/V9Waa@k8KhtkoKSfeX/oztc0h41rTm3IzzwcP9/nf/R0aY6hoaxOgrRljqGRlDaFEqbQWlzEG1oaq5jZGIJYhoZGBjqGBkYmsTGAgA" rel="nofollow noreferrer">verify all test cases</a>.</p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>≈∏          # Create a list in the inclusive range of the (implicit) input
           #  i.e. [9,15] ‚Üí [9,10,11,12,13,14,15]
 D         # Duplicate this list
  f        # Get the prime factors of each
           #  i.e. [9,10,11,12,13,14,15] ‚Üí [[3],[2,5],[11],[2,3],[13],[2,7],[3,5]]
   ‚Ç¨Œ∏      # Only leave the last value of each inner list
           #  i.e. [[3],[2,5],[11],[2,3],[13],[2,7],[3,5]] ‚Üí [3,5,11,3,13,7,5]
     W     # Get the minimum of this list (without popping the list itself)
           #  i.e. [3,5,11,3,13,7,5] ‚Üí 3
      Q    # Check for each value in the list if it is equal to this minimum
           #  i.e. [3,5,11,3,13,7,5] and 3 ‚Üí [1,0,0,1,0,0,0]
       √è   # Leave only the values of the duplicated list at the truthy indices
           #  i.e. [9,10,11,12,13,14,15] and [1,0,0,1,0,0,0] ‚Üí [&quot;9&quot;,&quot;12&quot;]
           # (and output the result implicitly as result)
</code></pre>
</div>
<div id="pu11" class="pu"><h1><a href="https://github.com/cairdcoinheringaahing/Whispers" rel="nofollow noreferrer">Whispers v2</a>, 183 bytes</h1>

<pre><code>&gt; Input
&gt; Input
&gt;&gt; 1‚Ä¶2
&gt;&gt; ‚à§L
&gt;&gt; L‚Äô
&gt;&gt; Each 4 3
&gt;&gt; Select‚àß 5 L
&gt;&gt; Each 7 6
&gt;&gt; L‚Åø10
&gt; -1
&gt;&gt; Each 9 8
&gt;&gt; L‚ÄñR
&gt;&gt; Each 12 11 3
&gt;&gt; 13·¥∫
&gt;&gt; Each 9 14
&gt; 0
&gt;&gt; 15‚Åø16
&gt;&gt; Output 17
</code></pre>

<p><a href="https://tio.run/##K8/ILC5ILSo2@v/fTsEzr6C0hAtO2ykYPmpYZgRiPOpY4gOifR41zATRronJGQomCsYgdnBqTmpyyaOO5QqmCj5wSXMFM4iGxv2GBkAzdQ3hUpYKFlCzpgXBBQ2NFAwNIQYaGj/csgtJtaEJUL8BWMYUZBzYYP/SEqAjFQzN//83NDXnMjKxAAA" rel="nofollow noreferrer" title="Whispers v2 ‚Äì Try It Online">Try it online!</a></p>

<p>Aside from revamping the algorithm, the only real golfing opportunity can be found on lines <strong>9</strong> and <strong>10</strong>, but swapping them. When they're the other way round, the code is <a href="https://tio.run/##K8/ILC5ILSo2@v/fTsEzr6C0hAtO2ykYPmpYZgRiPOpY4gOifR41zATRronJGQomCsYgdnBqTmpyyaOO5QqmCj5wSXMFM6BJuoYQXY37LeEyhgYKFlCzpgUhRI0UDA0hBhoaP9yyC1m5oQnQKAOwlCnQKEMzENO/tAToSgVD8///DU3NuYxMLAA" rel="nofollow noreferrer">1 byte longer</a>, due to the repeated use of <code>9</code> or <code>10</code>.</p>

<p>The structure tree for this program is:</p>

<p><a href="https://i.stack.imgur.com/Y6FuS.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/Y6FuS.png" alt="tree"></a></p>

<p>Red represents nilad lines, green represents function arguments. Arrows from <span class="math-container">\$a \to b\$</span> show the use of line <span class="math-container">\$a\$</span> as an argument for line <span class="math-container">\$b\$</span>.</p>

<h2>How it works.</h2>

<p>We start at lines <strong>1</strong>, <strong>2</strong> and <strong>3</strong>. The first two simply take and store the inputs <span class="math-container">\$\alpha\$</span> and <span class="math-container">\$\beta\$</span> on lines <strong>1</strong> and <strong>2</strong> respectively. There two values are then passed to line <strong>3</strong>, <code>1‚Ä¶2</code>, which form the range </p>

<p><span class="math-container">$$R := [\alpha, \alpha+1, ..., \beta-1, \beta]$$</span></p>

<p>As you can see from the tree above, <span class="math-container">\$R\$</span> is used in two places: line <strong>6</strong> and line <strong>13</strong>. As line <strong>6</strong> eventually leads to line <strong>13</strong>, we'll take the path down <strong>6</strong>.</p>

<p>Line <strong>6</strong> is an <code>Each</code> statement, that maps a function (the first line reference) over an array (the second line reference). Here, the function is defined on line <strong>4</strong> as <span class="math-container">\$f(x) = \{i \: | \: (i | x), (i \le x), i \in \mathbb{N}\}\$</span> i.e. the array of <span class="math-container">\$x\$</span>'s divisors. The array is <span class="math-container">\$R\$</span>, so line <strong>6</strong> iterates over <span class="math-container">\$R\$</span>, returning the divisors of each integer, forming a new array</p>

<p><span class="math-container">$$D := [f(\alpha), f(\alpha+1), ..., f(\beta-1), f(\beta)]$$</span></p>

<p>We then get more complicated as we skip down to line <strong>8</strong>. Line <strong>8</strong> is also an <code>Each</code> statement, but its function argument, line <strong>7</strong> is split over two lines, <strong>7</strong> and <strong>5</strong>:</p>

<pre><code>&gt;&gt; L‚Äô
&gt;&gt; Select‚àß 5 L
</code></pre>

<p>Mathematically, this is the function <span class="math-container">\$g(A) = \{i \: | \: (i \in \mathbb{P}), (i \in A)\}\$</span>, that takes a set <span class="math-container">\$A\$</span> and returns all the primes in <span class="math-container">\$A\$</span>. Line <strong>8</strong> is iterating over <span class="math-container">\$D\$</span>, essentially filtering all composite numbers from each subarray in <span class="math-container">\$D\$</span>, to form</p>

<p><span class="math-container">$$A := [g(f(\alpha)), g(f(\alpha+1)), ..., g(f(\beta-1)), g(f(\beta))]$$</span></p>

<p>Then, we encounter yet another <code>Each</code> statement on line <strong>11</strong>, which iterates line <strong>9</strong> over <span class="math-container">\$A\$</span>. Line <strong>9</strong> takes an array and returns the final element of that array. As <span class="math-container">\$g(A)\$</span> returns the array sorted, this is equivalent to return the largest value in that array. At this point, we remember that <span class="math-container">\$g(f(x))\$</span> returns the list of prime factors of <span class="math-container">\$x\$</span>, so line <strong>9</strong> maps each <span class="math-container">\$x\$</span> to its largest prime factor, returning</p>

<p><span class="math-container">$$B := [\max(g(f(\alpha))), \max(g(f(\alpha+1))), ..., \max(g(f(\beta-1))), \max(g(f(\beta)))]$$</span></p>

<p>Once we have <span class="math-container">\$B\$</span>, we now have an array we can sort <span class="math-container">\$R\$</span> by, e.g. we sort each value <span class="math-container">\$x\$</span> in <span class="math-container">\$R\$</span> by the resulting value of <span class="math-container">\$\max(g(f(x)))\$</span>. However, we do not have a sort-by command in Whispers, only the simple Python <code>sort(list)</code>. Luckily, due to how <code>sort</code> sorts lists of lists, we can concatenate each <span class="math-container">\$x\$</span> with <span class="math-container">\$\max(g(f(x))\$</span> and sort by the first element, what Python does naturally.</p>

<p>Lines <strong>12</strong> and <strong>13</strong> perform this concatenation, by iterating a concatenate function (line <strong>12</strong>) over <span class="math-container">\$B\$</span> and <span class="math-container">\$R\$</span>. This forms an array of pairs of numbers, in the form <span class="math-container">\$[\max(g(f(x))), x]\$</span>. Next, we sort this array on line <strong>14</strong>, which, due to the way Python compares lists, places the numbers with the lowest largest prime factor towards the end.</p>

<p>Almost finished. The only things left to do are to extract <span class="math-container">\$R\$</span>, sorted by <span class="math-container">\$B\$</span> (we'll call this array <span class="math-container">\$R_B\$</span>. This is done simply by taking the last element of each subarray (line <strong>9</strong> already does this for us, so we simply need <code>Each 9 14</code> on line <strong>15</strong>, rather than defining a new function). Once that's done, we simply take the first element in <span class="math-container">\$R_B\$</span>, which will be (one of) the number with the lowest largest prime factor i.e. the smoothest number.</p>
</div>
<div id="pu12" class="pu"><h1><a href="https://pyth.readthedocs.io" rel="nofollow noreferrer">Pyth</a>, 7 bytes</h1>

<pre><code>.mePbrF
</code></pre>

<p><a href="https://pyth.herokuapp.com/?code=.mePbrF&amp;input=9%2C+16&amp;debug=0" rel="nofollow noreferrer">Try it here!</a></p>

<p>Outputs all smooth integers in the range \$[a, b)\$. For the smooth integers in \$[a, b]\$, just use <code>}</code> in place of <code>r</code>.</p>

<pre><code>.mePbrF ‚Äì Full program with arguments a and b.
     rF ‚Äì Fold by half-inclusive range. Yields the integers in [a, b).
.m      ‚Äì Values b in that list which give minimal results when applied f.
  ePb   ‚Äì function / block f. 
   Pb   ‚Äì Prime factors of b.
  e     ‚Äì Last element. This is guaranteed to yield the largest, as they're sorted.
</code></pre>
</div>
<div id="pu13" class="pu"><h1>Julia, 58 bytes</h1>

<pre><code>using Primes
!r=[r;][indmin(max(factor(Set,n)...)for n=r)]
</code></pre>

<p>Takes a <code>Range</code> object of the form <code>5:9</code> as input, returns the smallest of the smoothest numbers in the range. (No TIO link, because TIO doesn't seem to have the <code>Primes</code> package.)  </p>
</div>
<div id="pu14" class="pu"><h1><a href="https://github.com/ETHproductions/japt" rel="nofollow noreferrer">Japt</a> <code>-g</code>, 8 bytes</h1>
<pre><code>√µV √±_k √å
</code></pre>
<p><a href="https://ethproductions.github.io/japt/?v=1.4.6&amp;code=9VYg8V9rIMw=&amp;input=NQoxMQotZw==" rel="nofollow noreferrer">Try it</a></p>
<hr />
<h2>Explanation</h2>
<pre><code>             :Implicit input of integers U &amp; V
√µV           :Range [U,V]
   √±_        :Sort by passing each through a function
     k       :  Prime factors
       √å     :  Last element
             :Implicitly output the first element in that array
</code></pre>
</div>
<div id="pu15" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 7 bytes, score = 7√∑7√ó8 = 8, language postdates challenge</h1>

<pre><code>r√Üf·πÄ$√ê·πÇ
</code></pre>

<p><a href="https://tio.run/nexus/jelly#@190uC3t4c4GlcMTHu5s@v//v6Gp@X8jE0sA" rel="nofollow noreferrer" title="Jelly ‚Äì TIO Nexus">Try it online!</a></p>

<p>Takes the lower and upper range endpoints as two separate arguments. Outputs a list of all the smoothest numbers in the range. (This can be viewed as a function, in which case the output is a Jelly list, or as a full program, in which case the output happens to use the same list representation that JSON does.)</p>

<h2>Explanation</h2>

<p>Those times when your Jelly program is just a literal translation of the spec‚Ä¶</p>

<pre><code>r√Üf·πÄ$√ê·πÇ
r        Range from {first argument} to {second argument}
     √ê·πÇ  Return the elements which have the minimum
   ·πÄ$      largest
 √Üf          prime factor
</code></pre>
</div>
<div id="pu16" class="pu"><h1><a href="https://esolangs.org/wiki/MATL" rel="nofollow noreferrer">MATL</a> (<em>non-competitive</em>), 20 bytes</h1>
<p><em>This language was designed after the challenge</em></p>
<p>Range is inclusive at both ends. The numbers are taken as two separate inputs.</p>
<pre><code>2$:t[]w&quot;@YfX&gt;v]4#X&lt;)
</code></pre>
<p><a href="http://matl.tryitonline.net/#code=MiQ6dFtddyJAWWZYPnZdNCNYPCk&amp;input=MTU3CjI0OA" rel="nofollow noreferrer"><strong>Try it online!</strong></a></p>
<h3>Explanation</h3>
<pre><code>2$:          % implicitly input two numbers. Inclusive range
t            % duplicate                      
[]           % empty array
w            % swap elements in stack         
&quot;            % for each                  
  @          %   push loop variable
  Yf         %   prime factors                  
  X&gt;         %   maximum value
  v          %   vertical concatenation         
]            % end for each                         
4#X&lt;         % arg min 
)            % index with this arg min into initial range of numbers
</code></pre>
</div>
<div id="pu17" class="pu"><h2>Seriously, 8*14/7 = 16 (non-competitive)</h2>
<pre><code>,x;`yM`M;m@√≠@E
</code></pre>
<p>Seriously was created after this challenge, but I wanted to post this answer because it exemplifies the type of challenges Seriously is good at.</p>
<p><a href="http://seriously.tryitonline.net/#code=LHg7YHlNYE07bUDDrUBF&amp;input=NSwxMQ" rel="nofollow noreferrer">Try it online!</a></p>
<p>Explanation:</p>
<pre><code>,x;`yM`M;m@√≠@E
,x;             make two copies of range(a,b) (a,b = input())
   `  `M;       make two copies of the result of the map:
    yM            push maximum prime factor
         m@√≠    push index of minimum element from prime factors
            @E  push element from range with given index
</code></pre>
</div>
<div id="pu18" class="pu"><h1>Python 2, 67</h1>



<pre class="lang-python prettyprint-override"><code>f=lambda R,F=1,i=2:[n for n in range(*R)if F**n%n&lt;1]or f(R,F*i,i+1)
</code></pre>

<p>Thinking about another golf gave me an idea for a new algorithm to check smoothness, hence the late answer. </p>

<p>The prime factorization of the factorial <code>i!</code> includes exactly the primes at most <code>i</code>. So, if <code>n</code> is a product of distinct primes, its smoothness (largest prime factor) is the smallest <code>i</code> for which <code>n</code> is a divisor of <code>i!</code>. To account for repeated prime factors in <code>n</code>, we can instead use a sufficiently high power of <code>i!</code>. In particular, <code>(i!)**n</code> suffices.</p>

<p>The code tries increasing factorials <code>F=i!</code>, updated recursively. We filter for the divisors of <code>F</code> in the input range, and output them if there are any, and otherwise move on to <code>(i+1)!</code>.</p>

<p>Test case:</p>

<pre class="lang-python prettyprint-override"><code>&gt;&gt; f([157, 249])
[162, 192, 216, 243]
</code></pre>
</div>
<div id="pu19" class="pu"><h1>J - 16 char</h1>

<p>Using the (<em>start</em>, <em>length</em>) style of range, as allowed by the comments.</p>

<pre><code>(0{+/:{:@q:@+)i.
</code></pre>

<p>To be used as a dyadic verb: left argument is <em>start</em>, right is <em>length</em>.</p>

<pre><code>   5 (+)i. 6              NB. range
5 6 7 8 9 10
   5 (q:@+)i. 6           NB. prime factorizations
5 0 0
2 3 0
7 0 0
2 2 2
3 3 0
2 5 0
   5 ({:@q:@+)i. 6        NB. largest prime factors
5 3 7 2 3 5
   5 (+/:{:@q:@+)i. 6     NB. sort range by smallest factors
8 6 9 5 10 7
   5 (0{+/:{:@q:@+)i. 6   NB. take first entry
8
   f=:(0{+/:{:@q:@+)i.    NB. can also be named
   2001 f 13
2002
</code></pre>

<p>A (<em>start</em>, <em>end</em>) solution is +2 chars, and excludes the end; including the end is +2 more. But on the bright side, it looks rather nice since we match up all the {braces}.</p>

<pre><code>(0{}./:{:@q:@}.)i.    NB. excluding
(0{}./:{:@q:@}.)1+i.  NB. including
</code></pre>
</div>
<div id="pu20" class="pu"><h2>J, <s>22 20</s> 19 chars</h2>

<pre><code>({.@/:{:@q:)@(}.i.)
</code></pre>

<p>E.g.</p>

<pre><code>   2001 ({.@/: {:@q:)@(}. i.) 2014
2002
</code></pre>

<p>(Functions taking two arguments are infix in J.)</p>
</div>
<div id="pu21" class="pu"><h2>Java 8 - 422 <strike>454</strike> chars</h2>

<p>I'm learning Java 8, and wanted to give this a shot relative to Java (or even Java 8 streams). </p>

<p>Compared to other languages, this is brutal but an interesting exercise.</p>

<p>Golfed:</p>

<pre><code>import java.util.stream.*;import java.math.*;
class F{int v;int i;public int getV() { return v; }
F(int i){this.i = i;v=IntStream.range(2,i+1).map(j-&gt;((i%j==0)&amp;&amp;new BigInteger(""+j).isProbablePrime(1))?j:0).max().getAsInt();}}
public class T{
int s(int a, int b){return IntStream.range(a,b+1).boxed().map(F::new).sorted(java.util.Comparator.comparingInt(F::getV)).collect(java.util.stream.Collectors.toList()).get(0).i;}}
</code></pre>

<p>Ungolfed:</p>

<pre><code>import java.util.stream.*;
import java.math.*;

class F {
    int v;
    int i;
    public int getV() { return v; }
    F (int i) { 
        this.i = i;
        v = IntStream.range(2,i+1)
                     .map( j -&gt; ((i%j==0) &amp;&amp; 
                           new BigInteger(""+j).isProbablePrime(1))?j:0)
                     .max()
                     .getAsInt();
    }
}

public class T {
    int s(int a, int b) {
        return IntStream.range(a,b+1)
                    .boxed()
                    .map(F::new)
                    .sorted(java.util.Comparator.comparingInt(F::getV))
                    .collect(java.util.stream.Collectors.toList())
                    .get(0).i;
    }
}
</code></pre>

<p>example run using:</p>

<pre><code>public static void main(String[] s) {
    System.out.println(new T().s(157,249));
}

192
</code></pre>
</div>
<div id="pu22" class="pu"><h2>Mathematica, <s>61</s> <s>45</s> 39 characters</h2>

<pre><code>Range@##~MinimalBy~Last@*FactorInteger&amp;
</code></pre>

<p>Very straightforward implementation of the spec as an unnamed function.</p>

<ul>
<li>Get the range (inclusive).</li>
<li>Factor all integers.</li>
<li>Find the minimum, sorted by largest prime factor.</li>
</ul>
</div>
<div id="pu23" class="pu"><h1>C#, <s>240</s> <s>234</s> <s>226</s> 161 characters</h1>

<p><br></p>

<pre><code>int S(int i,int b){int s=2&lt;&lt;29,n=0,k,j,p;for(k=i;i&lt;b;k=++i){for(;k&gt;1;--k){if(i%k&lt;1){p=1;for(j=2;j&lt;k;++j)if(k%j&lt;1)p=0;if(p&gt;0)break;}}if(k&lt;s){s=k;n=i;}}return n;}}
</code></pre>

<p><br><strong>Acknowledgements &amp; Reduction Explanations</strong><br>
- Thanks to CodesInChaos for reductions to 226, see comments for specifics<br>
- Reduced to 161 after re-reading the rules and seeing that a mere function is allowed (i.e., a free-standing program is not required.)</p>

<p><strong>Usage</strong><br>
function:<br>
- input: two integers<br>
- output: if multiple valid answers exist, returns the smallest</p>

<p><br><strong>Explanation (with comments and runnable test-wrapper)</strong></p>

<pre><code>class Test
{
    int S(int i, int b)
    {
        //s = lowest gpf found so far
        //n = best answer so far
        //i = range iterator
        //p = prime indicator (1=true, 0=false)
        int s = 2 &lt;&lt; 29, n = 0, k, j, p;
        for(k=i; i&lt;b; k=++i)
        {
            //iterate through the factors of i
            for(;k&gt;1;--k)
            {
                if (i % k &lt; 1)
                {
                    p=1;
                    //determine if k is prime
                    for (j = 2; j &lt; k; ++j)
                        if (k % j &lt; 1)
                            p = 0;
                    if (p&gt;0) break;
                }
            }
            if (k &lt; s)
            {
                s = k;
                n = i;
            }
        }
        return n;
    }

    public static void Main(string[] args)
    {
        var d = new D();
        System.Diagnostics.Debug.Assert(d.S(5, 11) == 8);
        System.Diagnostics.Debug.Assert(d.S(9, 16) == 9);
        System.Diagnostics.Debug.Assert(d.S(9, 17) == 16);
        System.Diagnostics.Debug.Assert(d.S(157, 249) == 162);
        System.Diagnostics.Debug.Assert(d.S(2001, 2014) == 2002);
    }
}
</code></pre>
</div>
<div id="pu24" class="pu"><h1>Python 2 (84)</h1>

<pre class="lang-python prettyprint-override"><code>f=lambda n,p=2:n&gt;1and f(n/p**(n%p&lt;1),p+(n%p&gt;0))or p
print min(range(*input()),key=f)
</code></pre>

<p><a href="https://codegolf.stackexchange.com/a/36391/20260">@isaacg's solution</a>, but with a <code>min</code> by function key in place of explicit min-finding, and a recursive function playing the role of the iteration.</p>

<p>Run in <a href="http://www.stackless.com/" rel="nofollow noreferrer">Stackless Python</a> to avoid recursion limits.</p>

<p>It looks wasteful to use the paranthesized condition <code>(n%p&lt;1)</code>, then repeat its negation also in parantheses <code>(n%p&gt;0)</code>, but that was the best I got. I tried things a bunch of things, but they turned out worse.</p>

<pre class="lang-python prettyprint-override"><code>f(n/p**(n%p&lt;1),p+(n%p&gt;0))     # Current for comparison
f(*[n/p,n,p,p+1][n%p&gt;0::2])
n%p and f(n,p+1)or f(n/p,p)
f(*n%p and[n,p+1]or[n/p,p])
</code></pre>

<p>I welcome any improvements you can think of.</p>
</div>
<div id="pu25" class="pu"><h2>C# LINQ: <s>317</s> <s>303</s> <s>289</s> 262</h2>

<pre><code>using System.Linq;class P{static void Main(string[]a){System.Console.Write(Enumerable.Range(int.Parse(a[0]),int.Parse(a[1])).Select(i=&gt;new{i,F=F(i)}).Aggregate((i,j)=&gt;i.F&lt;j.F?i:j).i);}static int F(int a){int b=1;for(;a&gt;1;)if(a%++b&lt;1)while(a%b&lt;1)a/=b;return b;}}
</code></pre>

<p>Ungolfed:</p>

<pre><code>using System.Linq;

class P
{
  static void Main(string[]a)
  {
    System.Console.Write(
      Enumerable.Range(int.Parse(a[0]), int.Parse(a[1])) //create an enumerable of numbers containing our range (start, length)
        .Select(i =&gt; new { i, F = F(i) }) //make a sort of key value pair, with the key (i) being the number in question and the value (F) being the lowest prime factor
        .Aggregate((i, j) =&gt; i.F &lt; j.F ? i : j).i); //somehow sort the array, I'm still not entirely sure how this works
  }
  static int F(int a)
  {
    int b=1;
    for(;a&gt;1;)
      if(a%++b&lt;1)
        while(a%b&lt;1)
          a/=b;
    return b;
  }
}
</code></pre>

<p>It takes in the start and the length from the command line and will return the largest smooth number.</p>

<p>I used answers from <a href="https://stackoverflow.com/a/2736385/1492861">here</a> and <a href="https://stackoverflow.com/a/5873129/1492861">here</a> to make my answer.</p>

<p>Thanks to VisualMelon for tweaking it and shaving 12 bytes off! I also got rid of the braces in the if saving 2 bytes, and CodeInChaos pointed out some obvious stuff I missed (thanks again).</p>
</div>
<div id="pu26" class="pu"><h1>Note: This answer is not allowable.</h1>
<p>This answer uses multiple features of Pyth added after the challenge was asked.</p>
<p>I added another new feature, calling unary range on a 2 element tuple, which shortens the solution by two characters, to this:</p>
<h1><a href="https://github.com/isaacg1" rel="nofollow noreferrer">Pyth</a>, 7</h1>
<pre><code>hoePNUQ
</code></pre>
<p>Input is now taken comma separated. The rest is the same.</p>
<hr />
<p>This answer uses a feature of Pyth that was added after this question was asked, specifically after seeing @aditsu's wonderful CJam solution. That being said, I wanted to demonstrate what adding that feature has made possible. The feature is <code>P</code>, which is an arity-1 function which on integer input returns a list of all prime factors of the input, sorted smallest to largest.</p>
<h1><a href="https://github.com/isaacg1" rel="nofollow noreferrer">Pyth</a>, 9</h1>
<pre><code>hoePNrQvw
</code></pre>
<p>Uses Python-style ranges, newline separated on STDIN. Outputs smallest solution to STDOUT.</p>
<p><strong>Explanation:</strong></p>
<pre><code>      Q = eval(input())                         Implicit, because Q is present.
h     head(                                     First element of
 o         order_by(                            Sort, using lambda expression as key.
                    lambda N:                   Implicit in o
  e                          end(               Last element of
   PN                            pfact(N)),     List containing all prime factors of N.
  r                 range(                      Python-style range, lower inc, upper exc.
   Q                      Q,                    A variable, initialized as shown above.
   vw                     eval(input()))))      The second entry of the range, same way.
</code></pre>
<p><strong>Tests:</strong></p>
<pre><code>$ newline='
'

$ echo &quot;9${newline}16&quot; | ./pyth.py -c 'hoePNrQvw'
9

$ echo &quot;9${newline}17&quot; | ./pyth.py -c 'hoePNrQvw'
16

$ echo &quot;157${newline}249&quot; | ./pyth.py -c 'hoePNrQvw'
162

$ echo &quot;2001${newline}2014&quot; | ./pyth.py -c 'hoePNrQvw'
2002
</code></pre>
</div>
<div id="pu27" class="pu"><h1>Bash+coreutils, 56 bytes</h1>
<pre><code>seq $@|factor|sed 's/:.* / /'|sort -nk2|sed '1s/ .*//;q'
</code></pre>
<p>Input is from from exactly two command-line arguments (Thanks @nyuszika7h !!!).  Output is a singular result printed to STDOUT.</p>
<ul>
<li><code>seq</code> provides the range of numbers, one per line, from the command-line arguments.</li>
<li><code>factor</code> reads those numbers and outputs each number followed by a colon and the sorted list of prime factors of that number.  So the largest prime factor is at the end of each line.</li>
<li>The first <code>sed</code> removes the colon and all but the last/largest prime factor, so leaves a list of each number (column 1) and its largest prime factor (column 2).</li>
<li><code>sort</code> numerically in increasing order by the column 2.</li>
<li>The final <code>sed</code> matches line 1 (number whose largest prime factor is the smallest in the list), removes everything including and after the first space, then quits.  <code>sed</code> automatically prints the result of this substitution before quitting.</li>
</ul>
<h3>Output:</h3>
<pre><code>$ ./smooth.sh 9 15
12
$ ./smooth.sh 9 16
16
$ ./smooth.sh 157 249
162
$ ./smooth.sh 2001 2014
2002
$ 
</code></pre>
<p>Note ranges in this context are <em>inclusive</em> of both endpoints.</p>
</div>
<div id="pu28" class="pu"><h2><strike>Q, 91 characters</strike> K, 78 characters</h2>
<pre><code>{(x+{where x=min x}{(-2#{x div 2+(where 0=x mod 2_til x)@0}\[{x&gt;0};x])@0}'[(x)_til y+1])@0}
</code></pre>
<p>k would probably shave a dozen characters</p>
<p>edit:
indeed, treating the upper bound as non inclusive this time</p>
<pre><code>{*:x+{&amp;:x=min x}{*:-2#{6h$x%2+*:&amp;:x={y*6h$x%y}[x]'[2_!x]}\[{x&gt;0};x]}'[(x)_!y]}
</code></pre>
</div>
<div id="pu29" class="pu"><h2>Regex (<s>.NET</s> PCRE flavour), <s>183</s> 129 bytes</h2>

<p>Don't try this at home!</p>

<p>This is not really a contender for the win. But Eric Tressler suggested solving this problem with nothing but a regex, and I couldn't resist giving it a go. This <s>might be</s> is possible in PCRE as well (and even shorter, see below), but I chose .NET because my solution needs arbitrary-length lookbehinds. Here we go:</p>

<pre><code>(?&lt;=^(1+),.*)(?=\1)(?=((11+)(?=.*(?=\3$)(?!(11+?)\4+$))(?=\3+$)|(?!(11+)\5+$)1+))(?!.+(?=\1)(?:(?!\2)|(?=((11+)(?=.*(?=\7$)(?!(11+?)\8+$))(?=\7+$)|(?!(11+)\9+$)1+)).*(?=\2$)(?=\6)))1+
</code></pre>

<p>The input is encoded as an inclusive comma-separated range, where both numbers are given in unary notation using <code>1</code>s. The match will be the trailing <code>S</code> 1s where <code>S</code> is the smoothest number in the range. Ties are broken in favour of the smallest number.</p>

<p>So the second example from the question would be the following string (match underlined)</p>

<pre><code>111111111,1111111111111111
                 =========
</code></pre>

<p>It is based on the (by now rather well-known) <a href="https://stackoverflow.com/questions/2795065/how-to-determine-if-a-number-is-a-prime-with-regex">prime-checking regex</a>, variations of which are embedded in there a whopping 6 times.</p>

<p>Here is a version using free-spacing and comments for those who want to know what's going on.</p>

<pre><code># Note that the beginning of the match we're looking for is somewhere
# in the second part of the input.
(?&lt;=^(1+),.*)          # Pick up the minimum range MIN in group 1
(?=\1)                 # Make sure there are at least MIN 1s ahead

                       # Now there will be N 1s ahead of the cursor
                       # where MIN &lt;= N &lt;= MAX.


(?=(                   # Find the largest prime factor of this number
                       # store it in group 2.
  (11+)                # Capture a potential prime factor P in group 3
  (?=                  # Check that it's prime
    .*(?=\3$)          # Move to a position where there are exactly 
                       # P 1s ahead
    (?!(11+?)\4+$)     # Check that the remaining 1s are not composite
  )
  (?=\3+$)             # Now check that P is a divisor of N.
|                      # This does not work for prime N, so we need a 
                       # separate check
  (?!(11+)\5+$)        # Make sure that N is prime.
  1+                   # Match N
))

(?!                    # Now we need to make sure that here is not 
                       # another (smaller) number M with a smaller 
                       # largest prime factor

  .+                   # Backtrack through all remaining positions
  (?=\1)               # Make sure there are still MIN 1s ahead

  (?:
    (?!\2)             # If M is itself less than P we fail 
                       # unconditionally.
  |                    # Else we compare the largest prime factors.
    (?=(               # This is the same as above, but it puts the
                       # prime factor Q in group 6.
      (11+)
      (?=
        .*(?=\7$)
        (?!(11+?)\8+$)
      )
      (?=\7+$)
    |
      (?!(11+)\9+$)
      1+
    ))
    .*(?=\2$)          # Move to a position where there are exactly 
                       # P 1s ahead
    (?=\6)             # Try to still match Q (which means that Q is
                       # less than P)
  )
)
1+                     # Grab all digits for the match
</code></pre>

<p>You can test it online <a href="http://regexhero.net/tester/?id=c01109dc-6236-4f04-a8dd-02d6a1f9b0b4" rel="noreferrer">over here</a>. Don't try too large inputs though, I make no guarantees about the performance of this monster.</p>

<p><strong>Edit:</strong></p>

<p>I ended up porting this to PCRE (which only requires two steps), and shortening the regex by almost a third. Here is the new version:</p>

<pre><code>^(1+),.*?\K(?=\1)(?=((11+)(?=.*(?=\3$)(?!(11+?)\4+$))(?=\3+$)|(?!(11+)\5+$)1+))(?!.+(?=\1)(?:(?!\2)|(?=((?2))).*(?=\2$)(?=\6)))1+
</code></pre>

<p>This is essentially the same, with two changes:</p>

<ul>
<li>PCRE does not support arbitrary-length lookbehind (which I used to get the <code>MIN</code> into group <code>1</code>). However, <code>PCRE</code> does support <code>\K</code> which resets the beginning of the match to the current cursor position. Hence <code>(?&lt;=^(1+),.*)</code> becomes <code>^(1+),.*?\K</code>, which already saves two bytes.</li>
<li>The real savings come from PCRE's recursion feature. I'm not actually using recursion, but you can use <code>(?n)</code> to match group <code>n</code> again, similar to a subroutine call. Since the original regex contained the code for finding a number's largest prime factor twice, I was able to replace the whole bulk of the second one with a simple <code>(?2)</code>.</li>
</ul>
</div>
<div id="pu30" class="pu"><h1>Lua - 166 chars</h1>
<p><em>I <s>don't</s>didn't have (yet!) enough reputation to comment on <a href="https://codegolf.stackexchange.com/a/36392/30855">AndoDaan's solution</a>, but here are some improvements on his code</em></p>
<pre><code>a,b=io.read(&quot;*n&quot;,&quot;*n&quot;)s=b for i=a,b do f={}n=i d=2 while n&gt;1 do while n%d&lt;1 do f[#f+1]=d n=n/d end d=d+1 end p=math.max(unpack(f))if p&lt;s then s=p c=i end end print(c)
</code></pre>
<p>Changes :</p>
<ul>
<li>The <code>n%d==0</code> by <code>n%d&lt;1</code> which is equivalent in this case</li>
<li>Removed a space</li>
<li>Replaced <code>table.insert(f,d)</code> by <code>f[#f+1]=d</code>  (<code>#f</code> is the number of elements of f)</li>
</ul>
</div>
<div id="pu31" class="pu"><h2>Perl (5.10+), 83</h2>

<pre><code>for(&lt;&gt;..&lt;&gt;){$n=$_;$p=2;$_%$p&amp;&amp;$p++or$_/=$p while$_&gt;1;$m=$p,$r=$n if$p&lt;$m||!$m}
say$r
</code></pre>

<p>(linebreak can be removed). Takes two endpoints of an inclusive range on two lines of stdin (because <code>&lt;&gt;</code> is cheaper than accessing <code>ARGV</code>) and outputs the smoothest to stdout. If there's a tie for smoothest, prints the smallest. Could print the biggest at the cost of one character.</p>

<p>The algorithm is basically isaacg's way of finding the greatest prime factor, although we came up with it independently. That part golfs down beautifully to a single statement in perl, the rest has more overhead than I'd like though.</p>

<p>Should be run under <code>perl -E</code> or with a <code>use 5.012</code> preamble. If you can't do that, replace <code>say$r</code> with <code>print$r,$/</code>.</p>
</div>
<div id="pu32" class="pu"><h1>Ruby, <s>65</s> 62</h1>

<pre><code>require'prime'
s=-&gt;a,b{(a..b).min_by{|x|x.prime_division[-1]}}
</code></pre>

<p>With apologies to <a href="https://codegolf.stackexchange.com/a/36484/6828">https://codegolf.stackexchange.com/a/36484/6828</a>, this is the golfed (and slightly simplified) version of that. Uses an inclusive range since it's a character shorter.</p>

<pre><code>1.9.3-p327 :004 &gt; s[157,249]
 =&gt; 192 
1.9.3-p327 :005 &gt; s[5,11]
 =&gt; 8 
1.9.3-p327 :006 &gt; s[9,15]
 =&gt; 12 
1.9.3-p327 :007 &gt; s[9,16]
 =&gt; 16 
</code></pre>

<p>And thanks to YenTheFirst for saving three characters.</p>
</div>
<div id="pu33" class="pu"><h2>PowerShell - 85</h2>
<pre><code>($args[0]..$args[1]|sort{$d=2
while($_-gt1){while(!($_%$d)){$m=$d;$_/=$d}$d++}$m})[0]
</code></pre>
<p>This will sort a range of numbers (inclusive) based on each number's max prime factor. It returns the lowest sorted element.</p>
<pre><code>&gt; smooth 5 10
8
&gt; smooth 9 15
12
&gt; smooth 9 16
16
&gt; smooth 157 248
243
&gt; smooth 2001 2013
2002
</code></pre>
</div>
<div id="pu34" class="pu"><h2>R, 83</h2>

<pre><code>library(gmp)
n=a:b
n[which.min(lapply(lapply(lapply(n,factorize),max),as.numeric))]
</code></pre>

<p>where the bottom of the input range is assigned to <code>a</code> and the top (inclusive) is assigned to <code>b</code>.</p>

<p><code>gmp</code> is a package that is available on CRAN. It felt dirty until I saw that absurd <code>mf</code> function in CJam. Install by typing <code>install.packages("gmp")</code> in the console.</p>
</div>
<div id="pu35" class="pu"><h1>Ruby - 113 chars</h1>

<p>Using the stdlib. Returns one result. Tested on ruby 2.1.2.</p>

<pre><code>require 'prime'
def smooth_range(a,b)
  (a...b).sort_by{|e|e.prime_division.flat_map{|f,p|[f]*p}.uniq.max}[0]
end
</code></pre>
</div>
<div id="pu36" class="pu"><h1>Haskell, <s>96</s> <s>94</s> <s>93</s> <s>86</s> 80 characters</h1>

<pre><code>x%y|x&lt;2=y|mod x y&lt;1=div x y%y|0&lt;1=x%(y+1)
a#b=snd$minimum$map(\x-&gt;(x%2,x))[a..b]
</code></pre>

<p>usage via GHCi (a Haskell shell):</p>

<pre><code>&gt;5 # 9
8
&gt;9 # 15
9
</code></pre>

<p><b>EDIT:</b> now a much simpler algorithm.</p>

<p>this solution includes both numbers in the range (so <code>8 # 9</code> and <code>7 # 8</code> are both 8)</p>

<p>explanation:</p>

<p>the (%) function takes two parameters, x and y. when y is 2, the function returns the smoothness of x.</p>

<p>the algorithm from here is simple - get the combined list of all smoothnesses of numbers in the input with each smoothness storing a reference to it's original number, sort then to get the smallest, and return it's referenced number.</p>

<p><br>
here is an ungolfed javascript version with the same algorithm:</p>

<pre><code>function smoothness(n,p)
{
    p = p || 2
    if (x == 1)
        return p
    if (x % p == 0)
        return smoothness(x/p, p)
    else
        return smoothness(x,p+1);
}
function smoothnessRange(a, b)
{
    var minSmoothness = smoothness(a);
    var min=a;
    for(var i=a+1;i &lt;= b;i++)
        if(minSmoothness &gt; smoothness(i))
        {
            minSmoothness = smoothness(i)
            min = i
        }
    return min;
}
</code></pre>
</div>
<div id="pu37" class="pu"><h2>Clojure - <strike>173</strike> 170 chars</h2>

<p>I'm a Clojure newbie. Golfed:</p>

<pre><code>(defn g[x,d](if(and(= 0(mod x d))(.isProbablePrime(biginteger d) 1))d 0))(defn f[i](apply max-key(partial g i)(range 2(inc i))))(defn s[a,b](first(sort-by f(range a b))))
</code></pre>

<p>Sample runs:</p>

<p>Ranges include low-end, exclude high-end: [a,b)
Only prints one of the smoothest numbers, if multiple occur.</p>

<pre><code>(println (s 5 11))
(println (s 9 16))
(println (s 9 17))
(println (s 157, 249))
(println (s 2001, 2014))
</code></pre>

<p>yields:</p>

<pre><code>bash$ java -jar clojure-1.6.0.jar range.clj
8
9
16
192
2002
</code></pre>

<p>Ungolfed:</p>

<pre><code>(defn g [x,d] (if (and (= 0(mod x d)) (.isProbablePrime (biginteger d) 1)) d 0))
(defn f [i] (apply max-key (partial g i) (range 2 (inc i))))
(defn s [a,b] (first (sort-by f (range a b))))
</code></pre>
</div>
<div id="pu38" class="pu"><h1>Haskell - 120</h1>



<pre class="lang-hs prettyprint-override"><code>import Data.List
import Data.Ord
x!y=(minimumBy(comparing(%2)))[x..y]
x%y|x&lt;y=y|x`mod`y==0=(x`div`y)%y|otherwise=x%(y+1)
</code></pre>

<p>Example usage:</p>

<pre class="lang-hs prettyprint-override"><code>&gt; 5 ! 10
8
&gt; 9 ! 15
9
&gt; 9 ! 16
16
&gt; 157 ! 248
162
&gt; 2001 ! 2013
2002
</code></pre>
</div>
<div id="pu39" class="pu"><h1>Python 2, 95</h1>

<pre><code>i=input()
for a in range(*i):
 s=a;p=2
 while~-a:b=a%p&lt;1;p+=1-b;a/=p**b
 if p&lt;i:i=p;j=s                                        
print j
</code></pre>

<p>Finds the smoothness of the the numbers by trial division until the number is 1. <code>i</code> stores the smallest smoothness so far, <code>j</code> stores the number that gave that smoothness.</p>

<p>Thanks to @xnor for the golfs.</p>
</div>
<div id="pu40" class="pu"><h1>Cobra - 150</h1>

<pre class="lang-cobra prettyprint-override"><code>def f(r as vari int)
    x,y=r
    c,o=y,0
    for n in x:y,for m in n:0:-1
        p=1
        for l in 2:m,if m%l&lt;1,p=0
        if n%m&lt;=0&lt;p
            if m&lt;c,c,o=m,n
            break
    print o
</code></pre>

<p>Not even sure why I bothered, cobra just can't compete here.</p>
</div>
<div id="pu41" class="pu"><h2>C, <s>&nbsp;149&nbsp;</s> &nbsp;95</h2>

<p><strong>Edited answer:</strong></p>

<p>I cannot claim credit for this solution. This updated answer borrows the beautiful method used by <em>isaacg</em> in his Python solution. I wanted to see if it was possible to write it in C as a nested <code>for</code>/<code>while</code> loop with no curly braces, and it is!</p>

<pre><code>R(a,b,n,q,p,m){for(;a&lt;b;m=p&lt;q?a:m,q=p&lt;q?p:q,n=++a,p=2)while(n&gt;1)if(n%p)p++;else n/=p;return m;}
</code></pre>

<p><strong>Explanation:</strong></p>

<ul>
<li>Function <code>R(a,b,n,q,p,m)</code> scans the range <code>a</code> to <code>b-1</code> and returns the first smoothest number found. Invocation requires adherence to the following form: <code>R(a,b,a,b,2,0)</code> so that variables inside the function are effectively initialized as follows: <code>n=a;q=b;p=2;m=0;</code>.</li>
</ul>

<hr>

<p><strong>Original answer</strong>:</p>

<p>This was my original answer...</p>

<pre><code>P(n,f,p){for(;++f&lt;n;)p=p&amp;&amp;n%f;return p;}
G(n,f){for(;--f&gt;1;)if(n%f==0&amp;&amp;P(f,1,1))return f;}
R(a,b,p,n){for(;++p;)for(n=a;n&lt;b;n++)if(G(n,n)==p)return n;}
</code></pre>

<p><strong>Explanation:</strong></p>

<ul>
<li>Function <code>P(n,f,p)</code> tests value <code>n</code> for primality and returns true (nonzero) if <code>n</code> is prime or false (zero) if <code>n</code> is non-prime. <code>f</code> and <code>p</code> must both be passed as 1.</li>
<li>Function <code>G(n,f)</code> returns the greatest prime factor of <code>n</code>. <code>f</code> must be passed as <code>n</code>.</li>
<li>Function <code>R(a,b,p,n)</code> scans the range <code>a</code> to <code>b-1</code> and returns the first smoothest number found. <code>p</code> must be passed as 1. <code>n</code> can be any value.</li>
</ul>

<p><strong>Test driver:</strong></p>

<pre><code>test(a,b){printf("smooth_range(%d, %d)\n%d\n",a,b,S(a,b,1,0));}
main(){test(5,11);test(9,16);test(9,17);test(157,249);test(2001,2014);}
</code></pre>

<p><strong>Output:</strong></p>

<pre><code>smooth_range(5, 11)
8
smooth_range(9, 16)
9
smooth_range(9, 17)
16
smooth_range(157, 249)
162
smooth_range(2001, 2014)
2002
</code></pre>
</div>
<div id="pu42" class="pu"><h1>Lua - 176 characters</h1>
<pre><code>a,b=io.read(&quot;*n&quot;,&quot;*n&quot;)s=b for i=a,b do f={}n=i d=2 while n&gt;1 do while n%d==0 do table.insert(f, d)n=n/d end d=d+1 end p=math.max(unpack(f))if p&lt;s then s=p c=i end end print(c)
</code></pre>
<p>I really should stop golfing in Lua. There's no point.</p>
</div>
<div id="pu43" class="pu"><h1>CJam - 13</h1>

<pre><code>q~,&gt;{mfW=}$0=
</code></pre>

<p>Try it at <a href="http://cjam.aditsu.net/">http://cjam.aditsu.net/</a></p>

<p>Example input: <code>2001 2014</code><br>
Example output: <code>2002</code></p>

<p><strong>Explanation:</strong></p>

<p><code>q~</code> reads and evaluates the input, pushing the 2 numbers on the stack (say min and max)<br>
<code>,</code> makes an array [0 1 ... max-1]<br>
<code>&gt;</code> slices the array starting at min, resulting in [min ... max-1]<br>
<code>{‚Ä¶}$</code> sorts the array using the block to calculate the sorting key<br>
<code>mf</code> gets an array with all the prime factors of a number, in order<br>
<code>W=</code> gets the last element of the array (W=-1), thus obtaining the largest prime factor to be used as a sorting key<br>
<code>0=</code> gets the first element of the (sorted) array</p>
</div>
<!-- TYYY -->

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/36384/">36384</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




