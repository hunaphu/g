<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::54162</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>218</td><td>Swift 5.9</td><td>240327T144538Z</td><td><a href="https://codegolf.stackexchange.com/questions/54162/symbolic-differentiation-of-polynomials/272138#272138">macOSist</a></td></tr>
<tr d-ix="1"><td>063</td><td>Perl</td><td>150801T173952Z</td><td><a href="https://codegolf.stackexchange.com/questions/54162/symbolic-differentiation-of-polynomials/54173#54173">Jarmex</a></td></tr>
<tr d-ix="2"><td>174</td><td>Python 2</td><td>170521T160602Z</td><td><a href="https://codegolf.stackexchange.com/questions/54162/symbolic-differentiation-of-polynomials/121913#121913">pjmv</a></td></tr>
<tr d-ix="3"><td>229</td><td>Python 2</td><td>170521T123947Z</td><td><a href="https://codegolf.stackexchange.com/questions/54162/symbolic-differentiation-of-polynomials/121893#121893">nog642</a></td></tr>
<tr d-ix="4"><td>041</td><td>CJam</td><td>150801T161114Z</td><td><a href="https://codegolf.stackexchange.com/questions/54162/symbolic-differentiation-of-polynomials/54169#54169">Dennis</a></td></tr>
<tr d-ix="5"><td>176</td><td>Python 3</td><td>150803T051403Z</td><td><a href="https://codegolf.stackexchange.com/questions/54162/symbolic-differentiation-of-polynomials/54204#54204">El&#39;e</a></td></tr>
<tr d-ix="6"><td>049</td><td>CJam</td><td>150801T165418Z</td><td><a href="https://codegolf.stackexchange.com/questions/54162/symbolic-differentiation-of-polynomials/54170#54170">Reto Kor</a></td></tr>
<tr d-ix="7"><td>166</td><td>Python 2</td><td>150802T075221Z</td><td><a href="https://codegolf.stackexchange.com/questions/54162/symbolic-differentiation-of-polynomials/54187#54187">DLosc</a></td></tr>
<tr d-ix="8"><td>162</td><td>C</td><td>150801T190855Z</td><td><a href="https://codegolf.stackexchange.com/questions/54162/symbolic-differentiation-of-polynomials/54176#54176">Cole Cam</a></td></tr>
<tr d-ix="9"><td>035</td><td>Retina</td><td>150801T155733Z</td><td><a href="https://codegolf.stackexchange.com/questions/54162/symbolic-differentiation-of-polynomials/54168#54168">Martin E</a></td></tr>
<tr d-ix="10"><td>220</td><td>Julia</td><td>150801T194022Z</td><td><a href="https://codegolf.stackexchange.com/questions/54162/symbolic-differentiation-of-polynomials/54177#54177">Alex A.</a></td></tr>
<tr d-ix="11"><td>108</td><td>JavaScript ES6</td><td>150801T185635Z</td><td><a href="https://codegolf.stackexchange.com/questions/54162/symbolic-differentiation-of-polynomials/54175#54175">George R</a></td></tr>
<tr d-ix="12"><td>062</td><td>Pyth</td><td>150801T144357Z</td><td><a href="https://codegolf.stackexchange.com/questions/54162/symbolic-differentiation-of-polynomials/54164#54164">orlp</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Swift 5.9, 218 bytes</h1>
<pre class="lang-swift prettyprint-override"><code>let f={{$0.split(separator:&quot; + &quot;).flatMap{let h=$0.contains,d=h(&quot;^&quot;) ?Int($0.split{$0==&quot;^&quot;}[1])!:h(&quot;x&quot;) ?1:0,c=d*Int($0.prefix{$0&lt;&quot;x&quot;})!
return c==0 ?nil:&quot;\(c)\(d&lt;2 ?&quot;&quot;:&quot;x&quot;)\(d&lt;3 ?&quot;&quot;:&quot;^\(d-1)&quot;)&quot;}.joined}($0+&quot;&quot;)(&quot; + &quot;)}
</code></pre>
</div>
<div id="pu1" class="pu"><h1>Perl, <s>64</s> 63 bytes</h1>

<p>62b code + 1 command line (-p)</p>

<pre><code>s/(\d+)x.(\d+)/$1*$2."x^".($2-1)/eg;s/\^1\b|^\d+ . |x(?!\^)//g
</code></pre>

<p>Usage example:</p>

<pre><code>echo "1 + 2x + 3x^2" | perl -pe 's/(\d+)x.(\d+)/$1*$2."x^".($2-1)/eg;s/\^1\b|^\d+ . |x(?!\^)//g'
</code></pre>

<p><em>Thanks Denis for -1b</em></p>
</div>
<div id="pu2" class="pu"><h1>Python 2, 174 bytes</h1>



<pre class="lang-python prettyprint-override"><code>print' + '.join(['%d%s%s'%(b[0]*b[1],'x'*(b[1]&gt;1),'^%d'%(b[1]-1)*(b[1]&gt;2))for b in[map(int,a.split('x^')if 'x^'in a else[a[:-1],1])for a in input().split(' + ')if 'x'in a]])
</code></pre>

<p>Unfortunately, DLosc's trick to rename the split method and perform the differentiation in a specific function does not shorten my code...</p>
</div>
<div id="pu3" class="pu"><h2>Python 2, 229 bytes</h2>

<pre><code>import os
print' + '.join([i,i[:-2]][i[-2:]=='^1'].replace('x^0','')for i in[`a*b`+'x^'+`b-1`for a,b in[map(int,a.split('x^'))for a in[[[i+'x^0',i+'^1'][i[-1]=='x'],i]['^'in i]for i in os.read(0,9**9).split(' + ')]]]if i[0]!='0')
</code></pre>
</div>
<div id="pu4" class="pu"><h1>CJam, <s>43</s> 41 bytes</h1>

<pre><code>Qleu'^/';*'+/{~:E[*'x['^E(]]E&lt;}/]1&gt;" + "*
</code></pre>

<p><em>Thanks to @jimmy23013 for pointing out one bug and golfing off two bytes!</em></p>

<p>Try it online in the <a href="http://cjam.aditsu.net/#code=Qleu&#39;%5E%2F&#39;%3B*&#39;%2B%2F%7B~%3AE%5B*&#39;x%5B&#39;%5EE(%5D%5DE%3C%7D%2F%5D1%3E%22%20%2B%20%22*&amp;input=1%20%2B%202x%20%2B%20-3x%5E2%20%2B%2017x%5E17%20%2B%20-1x%5E107" rel="nofollow">CJam interpreter</a>.</p>

<h3>How it works</h3>

<pre><code>Q           e# Leave an empty array on the bottom of the stack.
l           e# Read a line from STDIN.
eu'^/';*    e# Convert to uppercase and replace carets with semicolons.
'+/         e# Split at plus signs.

{           e# For each resulting chunk:
  ~         e#   Evaluate it. "X" pushes 1 and ";" discards.
            e#   For example, "3X" pushes (3 1) and "3X;2" (3 2).
   :E       e#   Save the rightmost integer (usually the exponent) in E.
   [        e#
     *      e#   Multiply both integers.
            e#   For a constant term c, this repeats the empty string (Q) c times.
     'x     e#   Push the character 'x'.
     ['^E(] e#   Push ['^' E-1].
   ]        e#
   E&lt;       e#  Keep at most E elements of this array.
            e#  If E == 1, 'x' and ['^' E-1] are discarded.
            e#  If E == 2, ['^' E-1] is discarded.
            e#  If E &gt;= 3, nothing is discarded.
}/          e#

]           e# Wrap the entire stack in an array.
1&gt;          e# Discard its first element.
            e# If the first term was constant, this discards [""]. ["" 'x']
            e# or ["" 'x' ['^' E-1]], depending on the constant.
            e# In all other cases, it discards the untouched empty array (Q).
" + "*      e# Join all kept array elements, separating by " + ".
</code></pre>
</div>
<div id="pu5" class="pu"><h1>Python 3, 176 bytes</h1>
<pre class="lang-python prettyprint-override"><code>s=input().split(' + ')
y='x'in s[0]
L=map(lambda x:map(int,x.split('x^')),s[2-y:])
print(' + '.join([s[1-y][:-1]]+['x^'.join(map(str,[a*b,b-1])).rstrip('^1')for a,b in L]))
</code></pre>
<p>Indeed, the main annoyance is having to convert between strings and ints. Also, if a constant term was required, the code would only be <strong>153</strong> bytes.</p>
</div>
<div id="pu6" class="pu"><h1>CJam, <s>62</s> <s>57</s> <s>55</s> 49 bytes</h1>

<p>Well, Dennis put this to shame before I even noticed that the site was back up. But here is my creation anyway:</p>

<pre><code>lS/{'x/:T,({T~1&gt;:T{~T~*'xT~(:T({'^T}&amp;}&amp;" + "}&amp;}/;
</code></pre>

<p>Latest version saves a few bytes with shortcuts suggested by @Dennis (use variables, and split at space instead of <code>+</code>).</p>

<p><a href="http://cjam.aditsu.net/#code=lS%2F%7B&#39;x%2F%3AT%2C(%7BT~1%3E%3AT%7B~T~*&#39;xT~(%3AT(%7B&#39;%5ET%7D%26%7D%26%22%20%2B%20%22%7D%26%7D%2F%3B&amp;input=1%20%2B%202x%20%2B%20-3x%5E2%20%2B%2017x%5E17%20%2B%20-1x%5E107" rel="nofollow">Try it online</a></p>
</div>
<div id="pu7" class="pu"><h1>Python 2, 166 bytes</h1>

<p>Boy, this seems longer than it should be.</p>

<pre><code>S=str.split
def d(t):e="^"in t and int(S(t,"^")[1])-1;return`int(S(t,"x")[0])*(e+1)`+"x"[:e]+"^%d"%e*(e&gt;1)
print" + ".join(d(t)for t in S(raw_input()," + ")if"x"in t)
</code></pre>

<p>The function <code>d</code> takes a non-constant term <code>t</code> and returns its derivative. The reason I <code>def</code> the function instead of using a lambda is so I can assign the exponent minus 1 to <code>e</code>, which then gets used another four times. The main annoying thing is having to cast back and forth between strings and ints, although Python 2's backtick operator helps with that.</p>

<p>We then split the input into terms and call <code>d</code> on each one that has <code>"x"</code> in it, thereby eliminating the constant term. The results are joined back together and printed.</p>
</div>
<div id="pu8" class="pu"><h1>C, <s>204</s> 162 bytes</h1>

<pre><code>#define g getchar()^10
h,e;main(c){for(;!h&amp;&amp;scanf("%dx%n^%d",&amp;c,&amp;h,&amp;e);h=g?g?e?printf(" + "):0,0:1:1)e=e?e:h?1:0,e?printf(e&gt;2?"%dx^%d":e&gt;1?"%dx":"%d",c*e,e-1):0;}
</code></pre>

<p>Basically parse each term and print out the differentiated term in sequence. Fairly straightforward.</p>
</div>
<div id="pu9" class="pu"><h1><a href="https://github.com/mbuettner/retina">Retina</a>, <s>53</s> <s>43</s> <s>42</s> <s>41</s> <s>40</s> 35 bytes</h1>

<pre><code>^[^x]+ |(\^1)?\w(?=1*x.(1+)| |$)
$2
</code></pre>

<p>For counting purposes each line goes in a separate file, but you can run the above as a single file by invoking Retina with the <code>-s</code> flag.</p>

<p>This expects the numbers in the input string <a href="http://meta.codegolf.stackexchange.com/q/5343/8478">to be given in unary</a> and will yield output in the same format. E.g.</p>

<pre><code>1 + 11x + -111x^11 + 11x^111 + -1x^11111
--&gt;
11 + -111111x + 111111x^11 + -11111x^1111
</code></pre>

<p>instead of</p>

<pre><code>1 + 2x + -3x^2 + 2x^3 + -1x^5
--&gt;
2 + -6x + 6x^2 + -5x^4
</code></pre>

<h2>Explanation</h2>

<p>The code describes a single regex substitution, which is basically 4 substitutions compressed into one. Note that only one of the branches will fill group <code>$2</code> so if any of the other three match, the match will simply be deleted from the string. So we can look at the four different cases separately:</p>

<pre><code>^[^x]+&lt;space&gt;
&lt;empty&gt;
</code></pre>

<p>If it's possible to reach a space from the beginning of the string without encountering an <code>x</code> that means the first term is the constant term and we delete it. Due to the greediness of <code>+</code>, this will also match the plus and the second space after the constant term. If there is no constant term, this part will simply never match.</p>

<pre><code>x(?= )
&lt;empty&gt;
</code></pre>

<p>This matches an <code>x</code> which is followed by a space, i.e. the <code>x</code> of the linear term (if it exists), and removes it. We can be sure that there's a space after it, because the degree of the polynomial is always at least 2.</p>

<pre><code>1(?=1*x.(1+))
$1
</code></pre>

<p>This performs the multiplication of the coefficient by the exponent. This matches a single <code>1</code> in the coefficient and replaces it by the entire corresponding exponent via the lookahead.</p>

<pre><code>(\^1)?1(?= |$)
&lt;empty&gt;
</code></pre>

<p>This reduces all remaining exponents by matching the trailing <code>1</code> (ensured by the lookahead). If it's possible to match <code>^11</code> (and a word boundary) we remove that instead, which takes care of displaying the linear term correctly.</p>

<p>For the compression, we notice that most of the conditions don't affect each other. <code>(\^1)?</code> won't match if the lookahead in the third case is true, so we can put those two together as</p>

<pre><code>(\^1)?1(?=1*x.(1+)| |$)
$2
</code></pre>

<p>Now we already have the lookahead needed for the second case and the others can never be true when matching <code>x</code>, so we can simply generalise the <code>1</code> to a <code>\w</code>:</p>

<pre><code>(\^1)?\w(?=1*x.(1+)| |$)
$2
</code></pre>

<p>The first case doesn't really have anything in common with the others, so we keep it separate.</p>
</div>
<div id="pu10" class="pu"><h1>Julia, 220 bytes</h1>

<p>No regular expressions!</p>



<pre class="lang-julia prettyprint-override"><code>y-&gt;(A=Any[];for i=parse(y).args[2:end] T=typeof(i);T&lt;:Int&amp;&amp;continue;T==Symbol?push!(A,1):(a=i.args;c=a[2];typeof(a[3])!=Expr?push!(A,c):(x=a[3].args[3];push!(A,string(c*x,"x",x&gt;2?string("^",ex-1):""))))end;join(A," + "))
</code></pre>

<p>This creates a lambda function that accepts a string and returns a string. The innards mimic what happens when Julia code is evaluated: a string is parsed into  symbols, expressions, and calls. I might actually try writing a full Julia symbolic differentiation function and submit it to be part of Julia.</p>

<p>Ungolfed + explanation:</p>

<pre class="lang-julia prettyprint-override"><code>function polyderiv{T&lt;:AbstractString}(y::T)

    # Start by parsing the string into an expression
    p = parse(y)

    # Define an output vector to hold each differentiated term
    A = Any[]

    # Loop through the elements of p, skipping the operand
    for i in p.args[2:end]

        T = typeof(i)

        # Each element will be an integer, symbol, or expression.
        # Integers are constants and thus integrate to 0. Symbols
        # represent x alone, i.e. "x" with no coefficient or
        # exponent, so they integrate to 1. The difficulty here
        # stems from parsing out the expressions.

        # Omit zero derivatives
        T &lt;: Int &amp;&amp; continue

        if T == Symbol
            # This term will integrate to 1
            push!(A, 1)
        else
            # Get the vector of parsed out expression components.
            # The first will be a symbol indicating the operand,
            # e.g. :+, :*, or :^. The second element is the
            # coefficient.
            a = i.args

            # Coefficient
            c = a[2]

            # If the third element is an expression, we have an
            # exponent, otherwise we simply have cx, where c is
            # the coefficient.
            if typeof(a[3]) != Expr
                push!(A, c)
            else
                # Exponent
                x = a[3].args[3]

                # String representation of the differentiated term
                s = string(c*x, "x", x &gt; 2 ? string("^", x-1) : "")

                push!(A, s)
            end
        end
    end

    # Return the elements of A joined into a string
    join(A, " + ")
end
</code></pre>
</div>
<div id="pu11" class="pu"><h1>JavaScript ES6, 108 bytes</h1>

<pre><code>f=s=&gt;s.replace(/([-\d]+)(x)?\^?(\d+)?( \+ )?/g,(m,c,x,e,p)=&gt;x?(c*e||c)+(--e?x+(e&gt;1?'^'+e:''):'')+(p||''):'')
</code></pre>

<h2>ES5 Snippet:</h2>

<p><div class="snippet" data-lang="js" data-hide="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>// ES5 version, the only difference is no use of arrow functions.
function f(s) {
  return s.replace(/([-\d]+)(x)?\^?(\d+)?( \+ )?/g, function(m,c,x,e,p) {
    return x ? (c*e||c) + (--e?x+(e&gt;1?'^'+e:''):'') + (p||'') : '';
  });
}

[
  '3 + 1x + 2x^2',
  '1 + 2x + -3x^2 + 17x^17 + -1x^107',
  '17x + 1x^2'
].forEach(function(preset) {
  var presetOption = new Option(preset, preset);
  presetSelect.appendChild(presetOption);
});

function loadPreset() {
  var value = presetSelect.value;
  polynomialInput.value = value;
  polynomialInput.disabled = !!value;
  showDifferential();
}

function showDifferential() {
  var value = polynomialInput.value;
  output.innerHTML = value ? f(value) : '';
}</code></pre>
<pre class="snippet-code-css lang-css prettyprint-override"><code>code {
  display: block;
  margin: 1em 0;
}</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;label for="presetSelect"&gt;Preset:&lt;/label&gt;
&lt;select id="presetSelect" onChange="loadPreset()"&gt;
  &lt;option value=""&gt;None&lt;/option&gt;
&lt;/select&gt;
&lt;input type="text" id="polynomialInput"/&gt;
&lt;button id="go" onclick="showDifferential()"&gt;Differentiate!&lt;/button&gt;
&lt;hr /&gt;
&lt;code id="output"&gt;
&lt;/code&gt;</code></pre>
</div>
</div>
</p>
</div>
<div id="pu12" class="pu"><h1>Pyth, 62 bytes</h1>
<pre><code>jJ&quot; + &quot;m::j&quot;x^&quot;,*Fdted&quot;x.1$&quot;\x&quot;x.0&quot;kftTmvMcd&quot;x^&quot;c:z&quot;x &quot;&quot;x^1 &quot;J
</code></pre>
<p>Pretty ugly solution, using some regex substitutions.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/54162/">54162</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




