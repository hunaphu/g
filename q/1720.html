<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::1720</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>379</td><td>Python3</td><td>241017T144526Z</td><td><a href="https://codegolf.stackexchange.com/questions/1720/finding-maximum-paths/276178#276178">Ajax1234</a></td></tr>
<tr d-ix="1"><td>154</td><td>Haskell</td><td>110323T062342Z</td><td><a href="https://codegolf.stackexchange.com/questions/1720/finding-maximum-paths/1760#1760">MtnViewM</a></td></tr>
<tr d-ix="2"><td>155</td><td>Ruby 1.9</td><td>110322T163815Z</td><td><a href="https://codegolf.stackexchange.com/questions/1720/finding-maximum-paths/1750#1750">Ventero</a></td></tr>
<tr d-ix="3"><td>204</td><td>Python</td><td>110321T212832Z</td><td><a href="https://codegolf.stackexchange.com/questions/1720/finding-maximum-paths/1735#1735">Keith Ra</a></td></tr>
<tr d-ix="4"><td>314</td><td>Haskell 314 necessary characters</td><td>110321T004734Z</td><td><a href="https://codegolf.stackexchange.com/questions/1720/finding-maximum-paths/1721#1721">Joey Ada</a></td></tr>
<tr d-ix="5"><td>149</td><td>Python</td><td>110329T211832Z</td><td><a href="https://codegolf.stackexchange.com/questions/1720/finding-maximum-paths/1883#1883">hallvabo</a></td></tr>
<tr d-ix="6"><td>049</td><td>GolfScript  49 Nabb enhanced characters</td><td>110321T145923Z</td><td><a href="https://codegolf.stackexchange.com/questions/1720/finding-maximum-paths/1726#1726">aaaaaaaa</a></td></tr>
<tr d-ix="7"><td>091</td><td>J</td><td>110322T011838Z</td><td><a href="https://codegolf.stackexchange.com/questions/1720/finding-maximum-paths/1740#1740">Jesse Mi</a></td></tr>
<tr d-ix="8"><td>nan</td><td>J</td><td>110321T025458Z</td><td><a href="https://codegolf.stackexchange.com/questions/1720/finding-maximum-paths/1723#1723">Eelvex</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Python3, 379 bytes</h1>
<pre class="lang-py prettyprint-override"><code>lambda b:(P(b),P([*zip(*b)]))
def P(b):
 q,p=[],[]
 for i in range(len(b)):q+=[(i,0,t:=[(i,0)],c:=b[i][0])];p+=[(t,c)]
 for x,y,t,c in q:
  for X in[-1,0,1]:
   if 0&lt;=(j:=x+X)&lt;len(b)and 0&lt;=(k:=y+1)&lt;len(b[0])and[]==[1 for T,C in p if len(T)==len(t)+1 and(j,k)==T[-1]and C&gt;=c+b[j][k]]:q+=[(j,k,T:=t+[(j,k)],C:=c+b[j][k])];p+=[(T,C)]
 return max(c for t,c in p if len(t)==len(b[0]))
</code></pre>
<p><a href="https://tio.run/##7ZTNjpswFIXX5SmuZjN2cCtsJ46h426yr2aRxUgeq4IEWvJDCHGlpC@fXhNmsmgX7FshsDl8nOMr2be9@B@HRuq2u1bm9brL98U6hyIjz6Sg7JnYya@6JZOCOkqjdVlB0LMIjqw11jHrIqgOHdRQN9DlzfeS7MoGEZodY2NJzRLms9uEOrbKTGFrZxNH3ec2AJ6t6OBxZheGr8HpiAm99oJv9iNHF@6CBnUFyZMhm8yc4xf6dAvLm3WvbjNzifmghhD8YJ0xlvdmS7YI5m0wCciSGhNGT2MOiJIN26K0xEAXLBdfzCou7MbZrXO3epBgy8z4uJ9iRYvszrzVhDmhpq70P7sG9vmZrPr8obj3fD/k90ul1xMHAw8PDxEH0d9hfhLv4qgLOTmKE/icjvLjAylHcDdSjOA4zEb5jVvff@5f5/rDIofDorQENcfNKBKQnINOEkilijSfgeYKuMDNPMVtmoKWPJqjPNMalBAwTTmkuDUV0hpHoUAoASk6yFSCTnU0TzgorhFToBUyaQozOY8EshzdJUcOrZTCo8Cn/dJC6/SHb8Uh79bkhB30w9AerJ3s85bUjWdQfzq1u9oTSt29q1b1zpcd@XpoSgangXh8bR6RiqK2wz9JRe7enGKn/lMWf5clytff" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1>Haskell, 154 characters</h1>
 
<pre class="lang-hsk prettyprint-override"><code>import List
z=zipWith
f=show.maximum.foldl1(\a-&gt;z(+)$z max(tail a++[0])$z max(0:a)a)
q a=f(transpose a)++' ':f a
main=interact$q.map(map read.words).lines
</code></pre>
<hr />
<ul>
<li>Edit: (155 -&gt; 154) inlined the function folded over</li>
</ul>
</div>
<div id="pu2" class="pu"><h1>Ruby 1.9, 155 characters</h1>

 

<pre class="lang-rb prettyprint-override"><code>f=-&gt;t{(1...l=t.size).map{|a|l.times{|b|t[a][b]+=t[a-1][(b&gt;0?b-1:0)..b+1].max}};t[-1].max};q=[*$&lt;].map{|a|a.split.map &amp;:to_i};puts [f[q.transpose],f[q]]*" ""
</code></pre>

<p>Straightforward solution that passes all testcases.</p>
</div>
<div id="pu3" class="pu"><h1>Python, 204 characters</h1>
 
<pre class="lang-py prettyprint-override"><code>import sys
I=sys.stdin.read()
n=I.count('\n')
A=map(int,I.split())
R=range(n)
X=lambda h,a:[a[i]+max(([0]+h)[i:i+3])for i in R]
h=v=[0]*n
for i in R:h=X(h,A[i*n:i*n+n]);v=X(v,A[i::n])
print max(v),max(h)
</code></pre>
</div>
<div id="pu4" class="pu"><h1>Haskell: 314 necessary characters</h1>
 
<pre class="lang-hsk prettyprint-override"><code>import Data.Vector(fromList,generate,(!))
import List
l=fromList
x=maximum
g=generate
p a=show$x[m!i!0|i&lt;-[0..h-1]]where{
w=length$head a;h=length$a;n=l$map l a;
m=g h$ \i-&gt;g w$ \j-&gt;n!i!j+x[k#(j+1)|k&lt;-[i-1..i+1]];
i#j|i&lt;0||i&gt;=h||j&gt;=w=0|1&gt;0=m!i!j;}
q a=p a++' ':(p.transpose)a
main=interact$q.map(map read.words).lines
</code></pre>
<p>Note: this requires the module <a href="http://hackage.haskell.org/package/vector" rel="nofollow noreferrer">Data.Vector</a>.  I'm not sure if it's included in the Haskell platform or not.</p>
<p>Ungolfed version:</p>
<pre class="lang-hsk prettyprint-override"><code>import Data.Vector(fromList,generate,(!))
import Data.List

-- horizontal; we use transpose for the vertical case
max_path :: [[Integer]] -&gt; Integer
max_path numbers = maximum [m ! i ! 0 | i &lt;- [0..h-1]] where
    w = length (head numbers)
    h = length numbers
    n = fromList $ map fromList numbers
    m = generate h $ \i -&gt; generate w $ \j -&gt;
        n ! i ! j + maximum [f i' (j+1) | i' &lt;- [i-1..i+1]]
    f i j | i &lt; 0 || i &gt;= h || j &gt;= w = 0
    f i j = m ! i ! j

max_paths :: [[Integer]] -&gt; String
max_paths numbers = (show . max_path) numbers ++ &quot; &quot; ++
                    (show . max_path . transpose) numbers

main = interact $ max_paths . map (map read . words) . lines
</code></pre>
<p>This solution uses laziness, in tandem with <a href="http://hackage.haskell.org/package/vector" rel="nofollow noreferrer">Data.Vector</a>, for memoization.  For every point, the solution for the maximum path from it to the end is computed, then stored in the cell of Vector <code>m</code> and reused when needed.</p>
</div>
<div id="pu5" class="pu"><h1>Python, 149</h1>
 
<pre class="lang-py prettyprint-override"><code>import sys
def f(g,t=[]):
 for r in g:t=[int(e)+max(t[i-1:i+2]+[0])for i,e in enumerate(r)]
 print max(t),
g=map(str.split,sys.stdin)
f(zip(*g)),f(g)
</code></pre>
<p>If I were to calculate only a vertical or horizontal shortest path,<br />
it could be done in-place instead, saving about a third of the bytes.</p>
</div>
<div id="pu6" class="pu"><h2>GolfScript - 49 Nabb enhanced characters</h2>
<p><strike>51 characters</strike><br />
<strike>50 strictly and utterly necessary characters + 3 slackers that only did the job of 1</strike><br />
<strike>56 mostly redundant characters</strike></p>
<pre><code>n%{~]}%.zip{{0@+\{\.1&gt;\3&lt;$-1=@+}%\;}*$-1=\}2*' '@
</code></pre>
<p>51 solution:</p>
<pre><code>n%{~]}%.zip{(\{0@+\{\.1&gt;\3&lt;$-1=@+}%\}%;$-1=\}2*' '@
</code></pre>
<p>53 solution:</p>
<pre><code>n/{~]}%);.zip{(\{0@+\{\.1&gt;\3&lt;$-1=@+}%\}%;$-1=\}2*' '@
             a8_b9___c10___11______12 13      14_
</code></pre>
<p>The method works on two lines at a time, one containing the maximum sums reached at each point, and one containing the next line.</p>
<p>a/14: Repeat twice, once for each result.<br />
8: Take the first line from the input and switch it behind the input array, this in now the first set of maximum sums.<br />
b/13: Iterate over each remaining line in the array.<br />
9: Put 0 at the beginning of the maximum sums.<br />
c/12: Iterate over each element of the line.<br />
10: Make a copy of the maximum sums with the first element removed.<br />
11: Take the first 3 elements of the maximum sums, sort them and add the largest to the current element of the line.</p>
<p>56 solution:</p>
<pre><code>n/{~]}%);.zip{1,99*\{{\.1&gt;\3&lt;$-1=@+}%0\+\}%;$-1=\}2*' '@
1________2___ 3____ 4______________________5_____ 6_7___
</code></pre>
<p>1: From input to array of arrays in 9 characters, actually it could have been done with just 1, but I broke that key so this will have to do.<br />
2: 4 characters just to make a transposed copy.<br />
3: Array of 99 0s in 5 characters, it could probably be done in a way smarter fashion, but I smoke too much weed to figure how.<br />
4: Overly complicated double loop that iterate over every single element of the input and does some fuzzy logic or something like that to produce the result. Nabb will probably make something equivalent in around 3Â½ characters.<br />
5: By now the result is there, inside an array that is, this silly piece of code is just there to get it out (and junk a piece of leftovers (and switch the result into place)).<br />
6: This is a command so simple that its character count would probably be negative in an optimal solution.
7: At this point the program is really done, but due to sloppiness in the preceding code the output is in the wrong order and lacks a space, so here goes a few more bits down the drain.</p>
</div>
<div id="pu7" class="pu"><h1>J, 91 <strike>95</strike></h1>

<pre><code>a=:".;._2(1!:1)3
c=:4 :'&gt;./x+"1|:y,.(1|.!.0 y),._1|.!.0 y'
p=:[:&gt;./c/
(":(p|:a),p a)1!:2(4)
</code></pre>

<p><strike>I decline to do IO, lowering my score dramatically.</strike> Passes all tests in the test harness (though it <em>only</em> works if the input ends with a line ending, as in the test harness). </p>

<p>I removed the handling for Windows line endings, since Chris suggested that it wasn't necessary. The multi-platform version would have <code>a=:".;._2 toJ(1!:1)3</code> as the first line.</p>

<p>Explanation:</p>

<ul>
<li><code>f</code> gives the solution pair by calling p normally and with input transposed (<code>|:</code>).</li>
<li><code>p</code> takes the maximum (<code>&gt;./</code>) of the row-totals from applying <code>c</code> between each row (<code>c/</code>)</li>
<li><code>c</code> takes two rows (x and y). It adds x to each of y, y shifted up 1 cell (<code>1|.!.0 y</code>), and y shifted down 1 cell (<code>_1|.!.0 y</code>). Then it takes the maximums of the three alternatives for each row. (<code>&gt;./</code>). The rest is rank [sic] - I'm not sure if I'm doing it right.</li>
</ul>
</div>
<div id="pu8" class="pu"><h2>J, <sup>109+10=</sup> 119 chars</h2>

<pre><code>y=:0".(1!:1)3
N=:%:#y
y=:y$~N,N
r=:(((1&amp;{)(+(3&gt;./\0,0,~]))(0&amp;{)),2&amp;}.)^:(&lt;:N)
(":([:&gt;./"1([:r|:),r)y)(1!:2)4
</code></pre>

<p>Run with <code>tr</code>:</p>

<pre><code>cat &lt;&lt; EOF | tr \\n ' ' | ./maxpath.ijs
</code></pre>

<p>As usual in J, most of the code is for input/output. The "actual" code is 65 characters:</p>

<pre><code>r=:(((1&amp;{)(+(3&gt;./\0,0,~]))(0&amp;{)),2&amp;}.)^:(&lt;:#y)
([:&gt;./"1([:r|:),r)y
</code></pre>

<p><em>Passes all test cases</em></p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/1720/">1720</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




