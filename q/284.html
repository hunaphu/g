<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::284</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>186</td><td>Binary Lambda Calculus</td><td>120910T013734Z</td><td><a href="https://codegolf.stackexchange.com/questions/284/write-an-interpreter-for-the-untyped-lambda-calculus/7257#7257">John Tro</a></td></tr>
<tr d-ix="1"><td>nan</td><td>C++ gcc</td><td>190522T180646Z</td><td><a href="https://codegolf.stackexchange.com/questions/284/write-an-interpreter-for-the-untyped-lambda-calculus/185976#185976">Daniel S</a></td></tr>
<tr d-ix="2"><td>1266</td><td>Python</td><td>190422T001557Z</td><td><a href="https://codegolf.stackexchange.com/questions/284/write-an-interpreter-for-the-untyped-lambda-calculus/183558#183558">Gaslight</a></td></tr>
<tr d-ix="3"><td>1039</td><td>C</td><td>160914T213715Z</td><td><a href="https://codegolf.stackexchange.com/questions/284/write-an-interpreter-for-the-untyped-lambda-calculus/93234#93234">user5898</a></td></tr>
<tr d-ix="4"><td>305</td><td>Haskell</td><td>150927T205217Z</td><td><a href="https://codegolf.stackexchange.com/questions/284/write-an-interpreter-for-the-untyped-lambda-calculus/58830#58830">Anders K</a></td></tr>
<tr d-ix="5"><td>nan</td><td></td><td>110803T035756Z</td><td><a href="https://codegolf.stackexchange.com/questions/284/write-an-interpreter-for-the-untyped-lambda-calculus/3290#3290">luser dr</a></td></tr>
<tr d-ix="6"><td>140</td><td>Waterhouse Arc</td><td>140722T043011Z</td><td><a href="https://codegolf.stackexchange.com/questions/284/write-an-interpreter-for-the-untyped-lambda-calculus/34916#34916">heated</a></td></tr>
<tr d-ix="7"><td>nan</td><td></td><td>140109T035630Z</td><td><a href="https://codegolf.stackexchange.com/questions/284/write-an-interpreter-for-the-untyped-lambda-calculus/18047#18047">MaiaVict</a></td></tr>
<tr d-ix="8"><td>nan</td><td></td><td>130814T075809Z</td><td><a href="https://codegolf.stackexchange.com/questions/284/write-an-interpreter-for-the-untyped-lambda-calculus/12304#12304">MaiaVict</a></td></tr>
<tr d-ix="9"><td>nan</td><td></td><td>131011T145443Z</td><td><a href="https://codegolf.stackexchange.com/questions/284/write-an-interpreter-for-the-untyped-lambda-calculus/12815#12815">Ray</a></td></tr>
<tr d-ix="10"><td>254</td><td>Ruby</td><td>110807T120628Z</td><td><a href="https://codegolf.stackexchange.com/questions/284/write-an-interpreter-for-the-untyped-lambda-calculus/3364#3364">Howard</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Binary Lambda Calculus 186</h1>
<p>The program shown in the hex dump below</p>
<pre><code>00000000  18 18 18 18 18 18 44 45  1a 10 18 18 45 7f fb cf  |......DE....E...|
00000010  f0 b9 fe 00 78 7f 0b 6f  cf f8 7f c0 0b 9f de 7e  |....x..o.......~|
00000020  f2 cf e1 b0 bf e1 ff 0e  6f 79 ff d3 40 f3 a4 46  |........oy..@..F|
00000030  87 34 0a a8 d0 80 2b 0b  ff 78 16 ff fe 16 fc 2d  |.4....+..x.....-|
00000040  ff ff fc ab ff 06 55 1a  00 58 57 ef 81 15 bf bf  |......U..XW.....|
00000050  0b 6f 02 fd 60 7e 16 f7  3d 11 7f 3f 00 df fb c0  |.o..`~..=..?....|
00000060  bf f9 7e f8 85 5f e0 60  df 70 b7 ff ff e5 5f f0  |..~.._.`.p...._.|
00000070  30 30 6f dd 80 5b b3 41  be 85 bf ff ca a3 42 0a  |00o..[.A......B.|
00000080  c2 bc c0 37 83 00 c0 3c  2b ff 9f f5 10 22 bc 03  |...7...&lt;+....&quot;..|
00000090  3d f0 71 95 f6 57 d0 60  18 05 df ef c0 30 0b bf  |=.q..W.`.....0..|
000000a0  7f 01 9a c1 70 2e 80 5b  ff e7 c2 df fe e1 15 55  |....p..[.......U|
000000b0  75 55 41 82 0a 20 28 29  5c 61                    |uUA.. ()\a|
000000ba
</code></pre>
<p>doesn't accept quite the format you propose.
Rather, it expects a lambda term in binary lambda calculus (blc) format.
However, it does show every single step in the normal form reduction,
using minimal parentheses.</p>
<p>Example: computing 2^3 in Church numerals</p>
<p>Save the above hex dump with xxd -r &gt; symbolic.Blc</p>
<p>Grab a blc interpreter from <a href="http://tromp.github.io/cl/uni.c" rel="nofollow noreferrer">http://tromp.github.io/cl/uni.c</a></p>
<pre><code>cc -O2 -DM=0x100000 -m32 -std=c99 uni.c -o uni
echo -n &quot;010000011100111001110100000011100111010&quot; &gt; threetwo.blc
cat symbolic.Blc threetwo.blc | ./uni
(\a \b a (a (a b))) (\a \b a (a b))
\a (\b \c b (b c)) ((\b \c b (b c)) ((\b \c b (b c)) a))
\a \b (\c \d c (c d)) ((\c \d c (c d)) a) ((\c \d c (c d)) ((\c \d c (c d)) a) b)
\a \b (\c (\d \e d (d e)) a ((\d \e d (d e)) a c)) ((\c \d c (c d)) ((\c \d c (c d)) a) b)
\a \b (\c \d c (c d)) a ((\c \d c (c d)) a ((\c \d c (c d)) ((\c \d c (c d)) a) b))
\a \b (\c a (a c)) ((\c \d c (c d)) a ((\c \d c (c d)) ((\c \d c (c d)) a) b))
\a \b a (a ((\c \d c (c d)) a ((\c \d c (c d)) ((\c \d c (c d)) a) b)))
\a \b a (a ((\c a (a c)) ((\c \d c (c d)) ((\c \d c (c d)) a) b)))
\a \b a (a (a (a ((\c \d c (c d)) ((\c \d c (c d)) a) b))))
\a \b a (a (a (a ((\c (\d \e d (d e)) a ((\d \e d (d e)) a c)) b))))
\a \b a (a (a (a ((\c \d c (c d)) a ((\c \d c (c d)) a b)))))
\a \b a (a (a (a ((\c a (a c)) ((\c \d c (c d)) a b)))))
\a \b a (a (a (a (a (a ((\c \d c (c d)) a b))))))
\a \b a (a (a (a (a (a ((\c a (a c)) b))))))
\a \b a (a (a (a (a (a (a (a b)))))))
</code></pre>
<p>Since the hexdump is rather unreadable, here is a &quot;disassembled&quot; version</p>
<pre><code>@10\\@10\\@10\\@10\\@10\\@10\@\@\@\@@\@1010\@\\\@10\\@10\@\@@@1111111111101
1110@11111110\@@110@11111110\\\\@1110\@1111110\@@101101111110@111111110\@111
111110\\\\@@110@111111011110@11111011110@@10@1111110\@10110\@@111111110\@111
111110\@110@101111011110@1111111111010@1010\\@1110@11010@\@\@1010\@110@1010\
\@@@@@\@1010\@\\\\@@@10\@@111111111011110\\@@101111111111111110\@@101111110\
@@10111111111111111111111110@@@@1111111110\\110@@@@\@1010\\\\@@10\@@@1111101
11110\\@\@@@10111111101111110\@@1011011110\\@@11111010110\\@111110\@@1011110
1110@111010\10\1011111110@111110\\\@101111111111011110\\@@11111111110@@11111
0111110\10\@@@@11111110\\@10\\1101111101110\@@1011111111111111111111110@@@@1
11111110\\@10\\@10\\11011111101110110\\\@@101110110@1010\\11011111010\@@1011
111111111111110@@@@\@1010\@\\@@@10\@@@1110@10\\\@1011110\\110\\\@10\\\@1110\
@@@11111111110@1111111101010\10\\@\@@@1110\\\@10@1110111110\\1110\110@@@1111
0110@@@1111010\\110\\\@10\\\@@1101111111101111110\\\@10\\\@@1101111110111111
10\\\110@1010110\\101110\\@@11010\\\@@1011111111111110@11110\@@1011111111111
101110\@\@@@@@@@@11010101010101010\\110\\10\\1010\10\\\1010\\1010@@@110\110\
@
</code></pre>
<p>replacing 00 (lambda) with \ and 01 (application) with @
Now it's almost as readable as brainfuck:-)</p>
<p>Also see <a href="http://www.ioccc.org/2012/tromp/hint.html" rel="nofollow noreferrer">http://www.ioccc.org/2012/tromp/hint.html</a></p>
<p>A pure blc normal form reducer, that accepts an input term in blc format, and outputs its normal form in blc format, is only 670 bits, or under 84 bytes; see <a href="https://github.com/tromp/AIT/blob/master/ait/nf.lam" rel="nofollow noreferrer">https://github.com/tromp/AIT/blob/master/ait/nf.lam</a></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C++ (gcc)</a>, <del>782</del> <del>766</del> <del>758</del> 731 bytes</h1>



<pre class="lang-cpp prettyprint-override"><code>#include &lt;string&gt;
#include &lt;map&gt;
#define A return
#define N new E
using S=std::string;using C=char;using I=int;S V(I i){A(i&gt;8?V(i/9):"")+C(97+i%9);}S W(C*&amp;s){C*b=s;while(*++s&gt;96);A{b,s};}struct E{I t,i;E*l,*r;E(E&amp;o,I d,I e){t=o.t;i=o.i+(o.i&gt;=d)*e;t?l=N{*o.l,d,e},t-1?r=N{*o.r,d,e}:0:0;}E(I d,std::map&lt;S,I&gt;m,C*&amp;s){t=*s-40?i=m[W(s)],0:*++s-92?l=N{d,m,s},r=N{d,m,++s},++s,2:(m[W(s+=2)]=d,l=N{d+1,m,s+=2},++s,1);}I R(I d){A t?t-1?l-&gt;t==1?l-&gt;l-&gt;s(d,0,*r),*this=*l-&gt;l,1:l-&gt;R(d)||r-&gt;R(d):l-&gt;R(d+1):0;}I s(I d,I e,E&amp;v){t?t-1?l-&gt;s(d,e,v),r-&gt;s(d,e,v):l-&gt;s(d,e+1,v):i==d?*this={v,d,e},0:i-=i&gt;d;}S u(I d){A t?t-1?S{"("}+l-&gt;u(d)+' '+r-&gt;u(d)+')':S{"(\\ "}+V(d)+". "+l-&gt;u(d+1)+')':V(i);}};S f(C*s){E a{0,{},s};for(I c=999;a.R(0)&amp;&amp;c--;);A a.u(0);}
</code></pre>

<p><a href="https://tio.run/##hVNRb5swEH7PrzhlWmKDYaSatoFjoqriIS99aKT2YekDAZJYAlKB0yal/PbubEjaTesWOebuu/N3n48jeXhwNkny@vpJlkm@TzOY1qqS5SYcvCFF/IBumq1lmcElVJnaV@UZuIYye4JosK/xGCxErdIg6Eh4h12JZBtXvTMXslR8AbdkDpI2l0SGP2a3RH7xaTAcUvuK@N9t@dmnvF3AHbmyRjVtrqyVqPnTVuYZsWy7Dv1vlF82K1a3vMVa@0RB1MxBMckjK2dWxSMSjXZsDin@M9oosXMVl7hLm@AWipRaGVezXFw31s7NWcqylilnMqs6pDJI4AUebyOiiczNsBnTBZuHBeukKWHVzldvJkXx847U9J55gZbo@BeGO2UFqmRVb2Kk1Ru7CIg5YIsLei9SZnLtic5GqMuZYBPmcKOLY6dAzbS83AmVEOaJqyYp8/C@lFlqK2thaZhNAnzckJS@vFSd0QP2hOr7zKEmfWtYNHrEW5yoNV/GHimr3uzghKM89KQQ6ayr1jx2bfMC6QgZpvqd7X@Xu2iGZNjaSLFHGfYYxnZ1suk40OHlEjDjVkNDF4Z9Lko1GTgb2IYWR2aN04AdjyBuPNa0@uWvdxWWS4Tv@zx2b4hHR6PEcThOB8TuHn3evpttucNhyeIiHOAQQhHLklBoBoC/d2MLOTeQmTcgJrLJVI7T3jmJLBnklJqs8@Fkt1cwnaLMkZW7q2yj2alGxsty3FF23w54fNC@ErKEgwsHCmgcXb0/u/BMkbeLkA4/UsxBrAcNhoC2YhdiE/owpq2VC6s/CY7/IDj@h@BwKnF2/iPh43Mdaez2VUjcr5WOmdzExFLcE71Sej61dk9ca8P11saDuYMRhZ6SRVYbXD3tuue2yjLdXxPSMO2wU9HCpJVm12VKIAWs6VnU@9J99b8GTrFf" rel="nofollow noreferrer" title="C++ (gcc) – Try It Online">Try it online!</a></p>

<p>The basic idea here is that the code uses an internal representation based on the idea of <a href="https://en.wikipedia.org/wiki/De_Bruijn_index" rel="nofollow noreferrer">de Bruijn indices</a> -- except that I reverse the indices to indicate the lambda-depth of the binding of the referred variable.  In the code:</p>

<ul>
<li><code>E::t</code> represents the type of a node - 0 for a variable leaf node, 1 for a lambda node, and 2 for a function application node.  (Chosen so that it coincides with the arity of the node, which just happens to be possible.)  Then <code>E::l</code> and <code>E::r</code> are the children as appropriate (just <code>E::l</code> for a lambda node), and <code>E::i</code> is the lambda-depth index for a variable leaf node.</li>
<li>The constructor <code>E::E(E&amp;o,int d,int e)</code> clones a subexpression which was initially at lambda-depth <code>d</code> for pasting into a new location at lambda-depth <code>d+e</code>.  This involves preserving variables at lambda-depth less than <code>d</code> while incrementing variables at lambda-depth at least <code>d</code> by <code>e</code>.</li>
<li><code>E::s</code> does a substitution of the subexpression <code>v</code> into variable number <code>d</code> in <code>*this</code> while decrementing variable numbers greater than <code>d</code> (and <code>e</code> is an internal detail tracking the lambda-depth increment for when it needs to call <code>E::c</code>).</li>
<li><code>E::R</code> searches for a single beta-reduction to perform, preferring top-most or left-most instances according to a pre-order search through the AST.  It returns nonzero if it found a reduction to perform or zero if it found none.</li>
<li><code>E::u</code> is a <code>to_string</code> type operation which reconstitutes a "human readable" string using synthetic names for the variables.  (Note that because of a little golfing of the <code>V</code> helper function it will only generate names containing <code>a</code> through <code>i</code>.)</li>
<li>The constructor <code>E::E(int d, std::map&lt;std::string, int&gt; m, char*&amp;s)</code> does parsing of an input string <code>s</code> into an expression AST based on a mapping <code>m</code> of currently bound variable names into lambda-depth indices.</li>
<li><code>f</code> is the main function answering the question.</li>
</ul>

<p>(As you can see at the TIO link, the code does handle variable names with multiple characters, and it also gets a correct answer of <code>(\ a. (\ b. a))</code> for <code>((\ f. (\ x. (f x))) (\ y. (\ x. y)))</code>.  It also just so happens that the parsing code can handle variable shadowing at no extra cost.)</p>

<hr>

<p>-16 bytes partially due to idea by ceilingcat (which I had also come up with independently), and partially due to changing <code>E*a=new E;</code> to <code>E&amp;a=*new E;</code> and then changing <code>a-&gt;</code> to <code>a.</code></p>

<p>-8 more bytes due to another comment by ceilingcat (factor out assignment of <code>a.t</code> from ternary)</p>

<p>-27 bytes from converting parser and clone into constructors of <code>E</code></p>
</div>
<div id="pu2" class="pu"><p><strong>Python: 1266 characters</strong> (measured using wc)</p>

<pre><code>from collections import *;import re
A,B,y,c=namedtuple('A',['l','r']),namedtuple('B',['i','b']),type,list.pop
def ab(t):c(t,0);p=c(t,0);c(t,0);return B(p,tm(t))
def tm(t):return ab(t)if t[0]=='\\'else ap(t)
def at(t):
    if t[0]=='(':c(t,0);r=tm(t);c(t,0);return r
    if 96&lt;ord(t[0][0])&lt;123:return c(t,0)
    if t[0]=='\\':return ab(t)
def ap(t):
    l = at(t)
    while 1:
        r = at(t)
        if not r:return l
        l = A(l,r)
def P(s):return tm(re.findall(r'(\(|\)|\\|[a-z]\w*|\.)',s)+['='])
def V(e):o=y(e);return V(e.b)-{e.i} if o==B else V(e.l)|V(e.r)if o==A else{e}
def R(e,f,t):return B(e.i,R(e.b,f,t)) if y(e)==B else A(R(e.l,f,t),R(e.r,f,t))if y(e)==A else t if e==f else e
def N(i,e):return N(chr(97+(ord(i[0])-96)%26),e) if i in V(e)else i
def S(i,e,a): return A(S(i,e.l,a),S(i,e.r,a)) if y(e)==A else(e if e.i==i else B(N(e.i,a),S(i,R(e.b,e.i,N(e.i,a)),a)))if y(e)==B else a if e==i else e
def T(e):
    if y(e)==A:l,r=e;return S(l.i,l.b,r)if y(l)==B else A(T(l),r)if y(l)==A else A(l,T(r))
    if y(e)==B:return B(e.i,T(e.b))
    q
def F(e):o=y(e);return r'(\%s. %s)'%(e.i,F(e.b))if o==B else'(%s %s)'%(F(e.l),F(e.r)) if o==A else e
def E(a):
    try: return E(T(a))
    except NameError:print(F(a))
E(P(input()))
</code></pre>

<p>Not the shortest by a long shot, but it correctly handles alpha-renaming and all the examples listed in OPs post.</p>
</div>
<div id="pu3" class="pu"><p><strong>C 1039 bytes</strong></p>

<pre><code>#define F for
#define R return
#define E if(i&gt;=M||j&gt;=M)R-1;
enum{O='(',C,M=3999};signed char Q[M],D[M],t[M],Z,v,*o=Q,*d=D,*T;int m,n,s,c,w,x,y;K(i,j,k){!Z&amp;&amp;(Z=t[O]=1)+(t[C]=-1);E;if(!o[i]){d[j]=0;R 0;}if((c=t[o[i]]+t[o[i+1]])!=2||o[i+2]!='\\'){d[j++]=o[i++];R K(i,j,i);}F(i+=2,y=w=0;i&lt;M&amp;&amp;o[i]&amp;&amp;c;++i)c+=t[o[i]],!w&amp;&amp;c==1?w=i:0,!y&amp;&amp;o[i]=='.'?y=i+2:0;E;if(c){F(;d[j++]=o[i++];)E;R 0;}F(c=y;c&lt;w;++c)if(o[c]=='\\')F(n=0,m=w+2;m&lt;i;++m){if(o[m]==o[c+2]){F(x=0;o[m+x]&amp;&amp;isalpha(o[m+x])&amp;&amp;o[m+x]==o[c+2+x];++x);if(o[c+2+x]!='.'||isalpha(o[m+x]))continue;if(v&gt;'Z')R-1;F(n=c+2;n&lt;w;++n)if(o[n]==o[m]){F(x=0; o[m+x]&amp;&amp;isalpha(o[m+x])&amp;&amp;o[m+x]==o[n+x];++x);if(o[m+x]=='.'&amp;&amp;!isalpha(o[n+x]))F(;--x&gt;=0;) o[n+x]=v;}++v;}}F(c=y;c&lt;w&amp;&amp;j&lt;M;++c){F(x=0;o[c+x]&amp;&amp;o[c+x]==o[k+4+x]&amp;&amp;isalpha(o[c+x]); ++x);if(o[k+4+x]=='.'&amp;&amp;!isalpha(o[c+x])){F(m=w+2;m&lt;i-1&amp;&amp;j&lt;M;++m)d[j++]=o[m];c+=x-1;}else d[j++]=o[c];}E;Z=2;R K(i,j,i);}char*L(char*a){F(s=n=0;n&lt;M&amp;&amp;(o[n]=a[n]);++n);if(n==M)R 0;v='A';F(;++s&lt;M;){Z=0;n=K(0,0,0);if(Z==2&amp;&amp;n!=-1)T=d,d=o,o=T;else break;}R n==-1||s&gt;=M?0:d;}
</code></pre>

<p>Variables allow as input using lowercase letters [from a..z] the sys can generate variables using uppercase letters [from A..Z] if need in the output...
Assume ascii character configuration.</p>

<pre><code>#define P printf
main()
{char  *r[]={ "((\\ abc. (\\ b. (abc (abc (abc b))))) (\\ cc. (\\ dd. (cc (cc dd)))))",
              "((\\ fa. (\\ abc. (fa abc))) (\\ yy. (\\ abc. yy)))",
              "((\\ x. x) z)", 
              "((\\ x. x) (\\ y. (\\ z. z)))", 
              "(\\ x. ((\\ y. y) x))", 
              "((\\ x. (\\ y. x)) (\\ a. a))", 
              "(((\\ x. (\\ y. x)) (\\ a. a)) (\\ b. b))",
              "((\\ x. (\\ y. y)) (\\ a. a))",
              "(((\\ x. (\\ y. y)) (\\ a. a)) (\\ b. b))",             
              "((\\ x. (x x)) (\\ x. (x x)))",
              "(((\\ x. (\\ y. x)) (\\ a. a)) ((\\ x. (x x)) (\\ x. (x x))))",
             0}, *p;
 int    w;

 for(w=0; r[w] ;++w)
   {p=L(r[w]);
    P("o=%s d=%s\n", r[w], p==0?"Error ":p);
   }
 R  0;
}

/*1.039*/
</code></pre>
</div>
<div id="pu4" class="pu"><h2>Haskell, <s>342</s> <s>323</s> <s>317</s> 305 characters</h2>

<p>As of this writing, this is the only solution that evaluates ((λ f. (λ x. (f x))) (λ y. (λ x. y))) to the correct result (λ x. (λ z. x)) rather than (λ x. (λ x. x)).  Correct implementation of the lambda calculus requires <a href="https://en.wikipedia.org/wiki/Lambda_calculus#Capture-avoiding_substitutions" rel="noreferrer">capture-avoiding substitution</a>, even under this problem’s simplifying guarantee that no variable shadows another variable in its scope.  (My program happens to work even without this guarantee.)</p>

<pre class="lang-hs prettyprint-override"><code>data T=T{a::T-&gt;T,(%)::ShowS}
i d=T(i. \x v-&gt;'(':d v++' ':x%v++")")d
l f=f`T`\v-&gt;"(λ "++v++". "++f(i(\_-&gt;v))%('x':v)++")"
(?)=q.lex
q[(v,s)]k|v/="("=k(maybe T{}id.lookup v)s|'λ':u&lt;-s,[(w,_:t)]&lt;-lex u=t? \b-&gt;k(\e-&gt;l$b.(:e).(,)w).tail|0&lt;1=s? \f-&gt;(?(.tail).k. \x z-&gt;f z`a`x z)
main=interact(? \f-&gt;(f[]%"x"++))
</code></pre>

<p>Notes:</p>

<ul>
<li>This runs in GHC 7.0, as required because this challenge was set in January 2011.  It would be <a href="https://github.com/andersk/tiny-lambda/blob/master/TinyLambda-minimized.hs" rel="noreferrer">13 characters shorter</a> if I were allowed to assume GHC 7.10.</li>
</ul>

<p><a href="https://github.com/andersk/tiny-lambda/blob/master/TinyLambda.hs" rel="noreferrer">Ungolfed version</a> with documentation.</p>
</div>
<div id="pu5" class="pu"><p><strong>Newest:</strong></p>

<p>I've squeezed it down to <strong>644 chars</strong>, I factored parts of cEll into cOpy and Par; cached calls to cell and cdr into temporary local variables, and moved those local variables to globals in "terminal" (ie. non-recursive) functions. Also, decimal constants are shorter than character literals and this nasty business ...</p>

<pre><code>atom(x){
    return m[x]&gt;&gt;5==3;
}
</code></pre>

<p>... correctly identifies lowercase letters (assuming ASCII), but also accepts any of `{|}~. (This same observation about ASCII is made in this <a href="https://www.youtube.com/watch?v=MijmeoH9LT4">excellent video about UTF-8</a>.)</p>

<p>Et viola:|</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#define X m[x]
#define R return
char*n,*m;int u,w,d;C(x,y){w=n-m;n+=sprintf(n,y?"(%s %s)":"(%s)",&amp;X,m+y)+1;R w;}T(x){R X&gt;&gt;5==3;}
L(x){R X==92;}O(x,j){w=n-m;memcpy(n,&amp;X,j);n+=j;*n++=0;R w;}E(x){X==' '?++x:0;R
X==41?0:L(x)?O(x,4):P(x);}P(x){d=0,w=x;do{X==40?d++:X==41?d--:0;++x;}while(d&gt;0);R
O(w,x-w);}D(x){u=E(x+1);R u?E(x+1+strlen(m+u)):0;}V(x){int a=E(x+1),b=D(x);R
T(x)|T(a)?x:L(a)?C(a,V(b)):L(E(a+1))?V(S(V(b),E(a+3),D(a))):V(C(V(a),b?V(b):0));}S(w,y,x){R
T(x)?(X==m[y]?w:x):C(L(w+1)?E(x+1):S(w,y,E(x+1)),D(x)?S(w,y,D(x)):0);}
Y(char*s){n+=strlen(s=strcpy(n,s))+1;printf("%s\n%s\n\n",s,m+V(s-m));n=m+1;}

char*s[]={
"((\\ a. a) (b))",
"((\\ x. x) (\\ y. (\\ z. z)))",
"(\\ x. ((\\ y. y) x))",
"(((\\ x. (\\ y. x)) (\\ a. a)) (\\ b. b))",
"((\\ x. (\\ y. y)) (\\ a. a))",
"(((\\ x. (\\ y. y)) (\\ a. a)) (\\ b. b))",
"((\\x. (x x)) (\\x. (x x)))",0};
#include&lt;unistd.h&gt;
main(){char**k;n=m=sbrk(4096);*n++=0;for(k=s;*k;k++)Y(*k);R 0;}
</code></pre>

<p><strong>Earlier:</strong></p>

<p>Can I get a few votes for effort? I've been working on this day and night for a week. I dug out the original McCarthy paper and was plagued by a bug in the paper itself until I read the appendix to Paul Graham's <em>The Roots of Lisp</em>. I was so distracted that I locked myself out of my house, then completely forgot until arriving home again that night at 12:30 (a little late to be calling the building manager who lives way out in the county), and had to spend the night at my grandmother's (hacking away until my laptop battery was dry).</p>

<p>And after all that, it's not even close to the winning entry!</p>

<p>I'm not sure how to make this any shorter; and I've used all the dirty tricks I can think of! Maybe it can't be done in C.</p>

<p>With some generosity in the counting (the first chunk takes a string and prints out the result), it's <strike><em>778</em></strike> <strike><strong>770</strong></strike> <strike><strong>709</strong></strike> <strong>694</strong> chars. But to make it stand-alone, it has to have that <code>sbrk</code> call. And to handle more complicated expressions, it needs the <code>signal</code> handler, too. And of course it cannot be made into a module with any code that tries to use <code>malloc</code>.</p>

<p>So, alas, here it is:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#define K(j) strncpy(n,m+x,j);n+=j;goto N;
#define R return
#define X m[x]
#define L =='\\'
char*m,*n;T(x){R islower(X);}V(x){int a=E(x+1);R
T(x)?x:T(a)?x:m[a]L?C(a,V(D(x))):m[E(a+1)]L?V(S(V(D(x)),E(a+3),D(a))):V(C(V(a),D(x)?V(D(x)):0));}
C(x,y){char*t=n;sprintf(n,y?"(%s %s)":"(%s)",m+x,m+y);n+=strlen(n)+1;R
t-m;}Y(char*s){char*t=strcpy(n,s);n+=strlen(n)+1;printf("%s=&gt;%s\n",s,m+V(t-m));n=m+1;}S(x,y,z){R
T(z)?(m[z]==m[y]?x:z):C(m[z+1]L?E(z+1):S(x,y,E(z+1)),D(z)?S(x,y,D(z)):0);}D(x){R
E(x+1)?E(x+strlen(m+E(x+1))+1):0;}E(x){char*t=n,d=0;if(X==' ')++x;if(T(x)){K(1)}if(X
L){K(4)}do{d=X?(X=='('?d+1:(X==')'?d-1:d)):0;*n++=m[x++];}while(d);N:*n++=0;R t-m;}

char*samp[]={
    "a","a","b","b",
    "((\\ a. a) (b))", "(b)",
    "((\\ x. x) (\\ y. (\\ z. z)))", "(\\ y. (\\ z. z))",
    "(\\ x. ((\\ y. y) x))", "(\\ x. x)",
    "(((\\ x. (\\ y. x)) (\\ a. a)) (\\ b. b))", "(\\ a. a)",
    "((\\ x. (\\ y. y)) (\\ a. a))", "(\\ y. y)",
    "(((\\ x. (\\ y. y)) (\\ a. a)) (\\ b. b))", "(\\ b. b)",
    "((\\x. (x x)) (\\x. (x x)))", "undef",
    NULL};
#include&lt;unistd.h&gt;

unsigned sz;
#include&lt;signal.h&gt;
void fix(x){signal(SIGSEGV,fix);brk(m+(sz*=2));}
main(){
    char**t;
    signal(SIGSEGV,fix);
    m=n=sbrk(sz=10*getpagesize());
    *n++=0;
    for(t=samp;*t;t+=2){
        Y(*t);
        printf("s.b. =&gt; %s\n\n", t[1]);
    }
    return 0;
}
</code></pre>

<p>Here's the block just before the final reductions. The tricks here are integer cursors instead of pointers (taking advantage of the 'implicit int' behavior), and the use of 'scratch memory': the <code>char*n</code> is the 'new' or 'next' pointer into the free space. But sometimes I write a string into the memory, then call strlen and increment n; effectively using memory and <em>then</em> allocating it, after the size is easier to calculate.
You can see it's pretty much straight from the McCarthy paper, with the exception of <code>cell()</code> which interfaces between the functions and the string representation of data.</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
char*m,*n;  //memory_base, memory_next
atom(x){  // x is an atom if it is a cursor to a lowercase alpha char.
    return x?(islower(m[x])?m[x]:0):0;
}
eq(x,y){  // x and y are equal if they are both atoms, the same atom.
    return x&amp;&amp;y&amp;&amp;atom(x)==atom(y);
}
cell(x){  // return a copy of the list-string by cursor, by parsing
    char*t=n,d=0;
    if(!x||!m[x])
        return 0;
    if(m[x]==' ')
        ++x;
    if(atom(x)){
        *n++=m[x];
        *n++=0;
        return(n-m)-2;
    }
    if(m[x]=='\\'){  // our lambda symbol
        memcpy(n,m+x,4);
        n+=4;
        *n++=0;
        return(n-m)-5;
    }
    do{  // um ...
        d=m[x]?(m[x]=='('?d+1:(m[x]==')'?d-1:d)):0;
        *n++=m[x++];
    }while(d);
    *n++=0;
    return t-m;
}
car(x){  // return (copy of) first element
    return x?cell(x+1):0;
}
cdr(x){  // return (copy of) rest of list
    return car(x)?cell(x+strlen(m+car(x))+1):0;
}
cons(x,y){  // return new list containing first x and rest y
    char*t=n;
    return x?(sprintf(n,y?"(%s %s)":"(%s)",m+x,m+y),n+=strlen(n)+1,t-m):0;
}
subst(x,y,z){  // substitute x for z in y
    if(!x||!y||!z)
        return 0;
    return atom(z)? (eq(z,y)?x:z):
        cons(m[z+1]=='\\'?car(z):
        subst(x,y,car(z)),cdr(z)?subst(x,y,cdr(z)):0);
}
eval(x){  // evaluate a lambda expression
    int a;
    return atom(x)?x:
        atom(a=car(x))?x:
        m[a]=='\\'?cons(a,eval(cdr(x))):
        m[car(a)]=='\\'?eval(subst(eval(cdr(x)),cell(a+3),cdr(a))):
        eval( cons(eval(a),cdr(x)?eval(cdr(x)):0));
}
try(char*s){  // handler
    char*t=strcpy(n,s);
    n+=strlen(n)+1;
    printf("input: %s\n", s);
    printf("eval =&gt; %s\n", m+eval(t-m));
    n=m+1;
}
</code></pre>
</div>
<div id="pu6" class="pu"><h1>Waterhouse Arc - 140 characters</h1>
<pre><code>(=
f[is cons?&amp;car._'λ]n[if
atom._ _
f._ `(λ,_.1,n:_.2)(=
c n:_.0
e _)(if
f.c(n:deep-map[if(is
c.1 _)e.1
_]c.2)(map n
_))]λ[n:read:rem #\._])
</code></pre>
</div>
<div id="pu7" class="pu"><p>Got 231 with JavaScript / no Regex</p>

<pre><code>(function f(a){return a[0]?(a=a.map(f),1===a[0][0]?f(function d(b,a,e,c){return b[0]?1===b[0]?[1,d(b[1],a,e,c+1)]:2===b[0]?b[1]===c-1?d(a,0,c-1,0)||b:c-1&lt;b[1]?[2,b[1]+e]:b:[d(b[0],a,e,c),d(b[1],a,e,c)]:b}(a[0],a[1],-1,0)[1]):a):a})
</code></pre>

<p>Receives 2-elements arrays. <code>1</code> stands for <code>λ</code> and 2 stands for a bruijn index variable.</p>

<p>Test: </p>

<pre><code>zero = [1,[1,[2,0]]]; // λλ0
succ = [1,[1,[1,[[2,1],[[[2,2],[2,1]],[2,0]]]]]]; // λλλ(1 ((2 1) 0))
console.log(JSON.stringify(reduce([succ,[succ,[succ,zero]]]))); // 0+1+1+1
// Output: [1,[1,[[2,1],[[2,1],[[2,1],[2,0]]]]]] = λλ(1(1(1 0))) = number 3
</code></pre>
</div>
<div id="pu8" class="pu"><p>Edit: check my answer below for 250 under pure JavaScript.</p>

<p><strong><s>2852</s> 243 characters using LiveScript (No Regex! Not fully golfed - could be improved)</strong></p>

<pre><code>L=(.0==\\)
A=-&gt;it.forEach?&amp;&amp;it.0!=\\
V=(.toFixed?)
S=(a,b,t=-1,l=0)-&gt;|L a=&gt;[\\,S(a.1,b,t,l+1)];|A a=&gt;(map (-&gt;S(a[it],b,t,l)),[0 1]);|a==l+-1=&gt;S(b,0,l+-1,0)||a|l-1&lt;a=&gt;a+t;|_=&gt;a
R=(a)-&gt;|L a=&gt;[\\,R a.1]|(A a)&amp;&amp;(L a.0)=&gt;R(S(R(a.0),R(a.1)).1)|_=&gt;a
</code></pre>

<p>Test:</p>

<pre><code>a = [\\,[\\,[1 [1 0]]]]
b = [\\,[\\,[1 [1 [1 0]]]]]
console.log R [a, b]
# outputs ["\\",["\\",[1,[1,[1,[1,[1,[1,[1,[1,[1,0]]]]]]]]]]]
</code></pre>

<p>Which is <code>3^2=9</code>, as stated on OP.</p>

<p>If anyone is curious, here is an extended version with some comments:</p>

<pre><code># Just type checking
λ = 100
isλ = (.0==λ)
isA = -&gt; it.forEach? &amp;&amp; it.0!=λ
isV = (.toFixed?)

# Performs substitutions in trees
# a: trees to perform substitution in
# b: substitute bound variables by this, if != void
# f: add this value to all unbound variables
# l: internal (depth)
S = (a,b,t=-1,l=0) -&gt;
    switch
    | isλ a             =&gt; [λ, (S a.1, b, t, l+1)]
    | isA a             =&gt; [(S a.0, b, t, l), (S a.1, b, t, l)]
    | a == l - 1        =&gt; (S b, 0, (l - 1), 0) || a
    | l - 1 &lt; a &lt; 100   =&gt; a + t
    | _                 =&gt; a

# Performs the beta-reduction
R = (a) -&gt;
    switch
    | (isλ a)               =&gt; [λ,R a.1]
    | (isA a) &amp;&amp; (isλ a.0)  =&gt; R(S(R(a.0),R(a.1)).1)
    | _                     =&gt; a

# Test
a = [λ,[λ,[1 [1 0]]]]
b = [λ,[λ,[1 [1 [1 0]]]]]
console.log show R [a, b]
</code></pre>
</div>
<div id="pu9" class="pu"><h1>Haskell 456 C</h1>

<p>It can be much shorter if the lazy evaluation feature of Haskell is fully utilized. Sadly, I don't know how to do it.</p>

<p>Also, many characters are wasted in the parsing step.</p>

<pre><code>data T=A[Char]|B[Char]T|C T T
(!)=(++)
s(A a)=a
s(B a b)="(λ "!a!". "!s b!")"
s(C a b)='(':s a!" "!s b!")"
e d(A a)=maybe(A a)id(lookup a d)
e d(B a b)=B a.e d$b
e d(C a b)=f d(e d a)(e d b)
f d(B x s)q=e((x,q):d)s
f d p q=C p q
d=tail
p('(':'λ':s)=let(A c,t)=p(d s);(b,u)=p(d.d$t);in(B c b,d u)
p('(':s)=let(a,t)=p s;(b,u)=p(d t)in(C a b,d u)
p(c:s)|elem c" .)"=(A "",c:s)|1&lt;2=let((A w),t)=p s in(A(c:w),t)
r=s.e[].fst.p
main=do l&lt;-getLine;putStrLn$r l
</code></pre>

<h2>Ungolfed version</h2>

<pre><code>data Expression = Literal String 
                | Lambda String Expression
                | Apply Expression Expression
                deriving Show

type Context = [(String, Expression)]

show' :: Expression -&gt; String
show' (Literal a) = a
show' (Lambda x e) = "(λ " ++ x ++ ". " ++ show' e ++ ")"
show' (Apply e1 e2) = "(" ++ show' e1 ++ " " ++ show' e2 ++ ")"

eval :: Context -&gt; Expression -&gt; Expression
eval context e@(Literal a) = maybe e id (lookup a context)
eval context (Lambda x e) = Lambda x (eval context e)
eval context (Apply e1 e2) = apply context (eval context e1) (eval context e2)

apply :: Context -&gt; Expression -&gt; Expression -&gt; Expression
apply context (Lambda x e) e2 = eval ((x, e2):context) e
apply context e1 e2 = Apply e1 e2

parse :: String -&gt; (Expression, String)
parse ('(':'λ':s) = let
    (Literal a, s') = parse (tail s)
    (e, s'') = parse (drop 2 s')
    in (Lambda a e, tail s'')

parse ('(':s) = let
    (e1, s') = parse s
    (e2, s'') = parse (tail s')
    in (Apply e1 e2, tail s'')

parse (c:s) | elem c " .)" = (Literal "", c:s)
            | otherwise    = let ((Literal a), s') = parse s 
                             in (Literal (c:a), s')

run :: String -&gt; String
run = show' . eval [] . fst . parse
main = do
  line &lt;- getLine
  putStrLn$ run line
</code></pre>
</div>
<div id="pu10" class="pu"><h3>Ruby 254 characters</h3>
<pre><code>f=-&gt;u,r{r.chars.take_while{|c|u+=c==?(?1:c==?)?-1:0;u&gt;0}*''}
l=-&gt;x{x=~/^(\(*)\(\\ (\w+)\. (.*)/&amp;&amp;(b,v,r=$1,$2,$3;e=f[1,r];(e==s=l[e])?b==''?x:(s=f[2,r];(x==y=b.chop+e.gsub(v,s[2+e.size..-1])+r[1+s.size..-1])?x:l[y]):(b+'(\\ '+v+'. '+s+r[e.size..-1]))||x}
</code></pre>
<p>It can be used like</p>
<pre><code>puts l[&quot;((\\ x. (\\ y. x)) (\\ a. a))&quot;]    # &lt;= (\ y. (\ a. a))
</code></pre>
<p>The solution is not yet fully golfed but already almost unreadable.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/284/">284</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




