<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::38548</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>069</td><td>Dyalog APL</td><td>250905T225123Z</td><td><a href="https://codegolf.stackexchange.com/questions/38548/is-the-brick-structure-stable/283542#283542">Aaron</a></td></tr>
<tr d-ix="1"><td>407</td><td>Python3</td><td>250511T173111Z</td><td><a href="https://codegolf.stackexchange.com/questions/38548/is-the-brick-structure-stable/279656#279656">Ajax1234</a></td></tr>
<tr d-ix="2"><td>209</td><td>Python</td><td>141101T103642Z</td><td><a href="https://codegolf.stackexchange.com/questions/38548/is-the-brick-structure-stable/40805#40805">legionix</a></td></tr>
<tr d-ix="3"><td>nan</td><td>JavaScript 2 ES6  148</td><td>141005T152138Z</td><td><a href="https://codegolf.stackexchange.com/questions/38548/is-the-brick-structure-stable/38563#38563">me and m</a></td></tr>
<tr d-ix="4"><td>098</td><td>80386 machine code</td><td>141006T214802Z</td><td><a href="https://codegolf.stackexchange.com/questions/38548/is-the-brick-structure-stable/38594#38594">anatolyg</a></td></tr>
<tr d-ix="5"><td>nan</td><td></td><td>141005T144611Z</td><td><a href="https://codegolf.stackexchange.com/questions/38548/is-the-brick-structure-stable/38562#38562">edc65</a></td></tr>
<tr d-ix="6"><td>279</td><td>Python</td><td>141005T124647Z</td><td><a href="https://codegolf.stackexchange.com/questions/38548/is-the-brick-structure-stable/38559#38559">Wikunia</a></td></tr>
<tr d-ix="7"><td>119</td><td>MATLAB</td><td>141005T103613Z</td><td><a href="https://codegolf.stackexchange.com/questions/38548/is-the-brick-structure-stable/38555#38555">COTO</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Dyalog APL, 69 bytes</h1>
<pre><code>{âˆ§/,{(1âˆŠ2â‰¤+/Â¨(3 x)(x 1)((xâ†1 3)3)âŒ·Â¨âŠ‚âµ)âˆ¨2â‰ 2 2âŒ·âµ}âŒº3 3âŠ¢1âªâ¨('_'=âµ)+'.'â‰ âµ}Â­â¡â€‹â€â€âªâ¡âªâ âªâ¤â¤â¤âªâ€â â€âªâ¡âªâ âªâ¢â¡â¡â¡âªâ€â â€âªâ¡âªâ âªâ¢â¡â¡â¢âªâ€â â€âªâ¡âªâ âªâ¢â¡â¡â£âªâ€â â€âªâ¡âªâ âªâ¢â¡â¡â¤âªâ€â€â€‹â¡â â¡â€Œâ¢â€‹â€â€âªâ¡âªâ âªâ¤â¢â¤âªâ€â â€âªâ¡âªâ âªâ¤â£â¡âªâ€â â€âªâ¡âªâ âªâ¤â£â¢âªâ€â â€âªâ¡âªâ âªâ¤â£â£âªâ€â â€âªâ¡âªâ âªâ¤â£â¤âªâ€â â€âªâ¡âªâ âªâ¤â¤â¡âªâ€â â€âªâ¡âªâ âªâ¤â¤â¢âªâ€â€â€‹â¡â â¡â€Œâ£â€‹â€â€âªâ¡âªâ âªâ¤â¤â£âªâ€â€â€‹â¡â â¡â€Œâ¤â€‹â€â€âªâ¡âªâ âªâ¤â¢â¡âªâ€â â€âªâ¡âªâ âªâ¤â¢â¢âªâ€â â€âªâ¡âªâ âªâ¤â¢â£âªâ€â€â€‹â¡â â¡â€Œâ¢â¡â€‹â€â€âªâ¡âªâ âªâ¢â¡âªâ€â â€âªâ¡âªâ âªâ£â¤â£âªâ€â â€âªâ¡âªâ âªâ£â¤â¤âªâ€â â€âªâ¡âªâ âªâ¤â¡â¡âªâ€â â€âªâ¡âªâ âªâ¤â¡â¢âªâ€â â€âªâ¡âªâ âªâ¤â¡â£âªâ€â â€âªâ¡âªâ âªâ¤â¡â¤âªâ€â€â€‹â¡â â¡â€Œâ¢â¢â€‹â€â€âªâ¡âªâ âªâ£â¢â¤âªâ€â â€âªâ¡âªâ âªâ£â£â¡âªâ€â â€âªâ¡âªâ âªâ£â£â¢âªâ€â â€âªâ¡âªâ âªâ£â£â£âªâ€â â€âªâ¡âªâ âªâ£â£â¤âªâ€â â€âªâ¡âªâ âªâ£â¤â¡âªâ€â â€âªâ¡âªâ âªâ£â¤â¢âªâ€â€â€‹â¡â â¡â€Œâ¢â£â€‹â€âªâªâ â€âªâ¡âªâ âªâ¢â¢âªâ€â â€âªâ¡âªâ âªâ£â¢â¢âªâ€â â€âªâ¡âªâ âªâ£â¢â£âªâ€â€â€‹â¡â â¡â€Œâ¢â¤â€‹â€â€âªâ¡âªâ âªâ£â¡â¢âªâ€â â€âªâ¡âªâ âªâ£â¡â£âªâ€â â€âªâ¡âªâ âªâ£â¡â¤âªâ€â â€âªâ¡âªâ âªâ£â¢â¡âªâ€â€â€‹â¡â â¡â€Œâ£â¡â€‹â€â€âªâ¡âªâ âªâ¢â¢â¤âªâ€â â€âªâ¡âªâ âªâ¢â£â¡âªâ€â â€âªâ¡âªâ âªâ¢â£â¢âªâ€â â€âªâ¡âªâ âªâ¢â£â£âªâ€â â€âªâ¡âªâ âªâ¢â£â¤âªâ€â â€âªâ¡âªâ âªâ¢â¤â¡âªâ€â â€âªâ¡âªâ âªâ¢â¤â¢âªâ€â â€âªâ¡âªâ âªâ¢â¤â£âªâ€â â€âªâ¡âªâ âªâ¢â¤â¤âªâ€â â€âªâ¡âªâ âªâ£â¡â¡âªâ€â€â€‹â¡â â¡â€Œâ£â¢â€‹â€â€âªâ¡âªâ âªâ¢â¡â£âªâ€â â€âªâ¡âªâ âªâ¢â¡â¤âªâ€â â€âªâ¡âªâ âªâ¢â¢â¡âªâ€â â€âªâ¡âªâ âªâ¢â¢â¢âªâ€â â€âªâ¡âªâ âªâ¢â¢â£âªâ€â€â€‹â¡â â¡â€Œâ£â£â€‹â€â€âªâ¡âªâ âªâ¤â¢âªâ€â â€âªâ¡âªâ âªâ¤â£âªâ€â â€âªâ¡âªâ âªâ¤â¤âªâ€â â€âªâ¡âªâ âªâ¢â¡â¡âªâ€â â€âªâ¡âªâ âªâ¢â¡â¢âªâ€â€â€‹â¡â â¡â€Œâ£â¤â€‹â€â€âªâ¡âªâ âªâ£â£âªâ€â â€âªâ¡âªâ âªâ£â¤âªâ€â â€âªâ¡âªâ âªâ¤â¡âªâ€â€â€‹â¡â â¡â€Œâ¤â¡â€‹â€â€âªâ¡âªâ âªâ£â¡âªâ€â â€âªâ¡âªâ âªâ£â¢âªâ€â€â€‹â¡â â¡â€Œâ¤â¢â€‹â€â€âªâ¡âªâ âªâ¢â£âªâ€â â€âªâ¡âªâ âªâ¢â¤âªâ€â€â€‹â¡â â¡â€Œâ¤â£â€‹â€â€âªâ¡âªâ âªâ¢âªâ€â â€âªâ¡âªâ âªâ£âªâ€â â€âªâ¡âªâ âªâ¤âªâ€â€â€‹â¡â â¡â€ŒÂ­
                                                               '.'â‰ âµ   # â€â¡Find where the input is not a dot,
                                                       ('_'=âµ)         # â€â¢find where the input is the inner part of a brick,
                                                              +        # â€â£and add these.  This makes the inner parts a 2 and the rest of a brick a 1
                                                    1âªâ¨                # â€â¤Put a row of 1s on the bottom so &quot;ground&quot; can be supportive
    {                                         }âŒº3 3âŠ¢                   # â€â¢â¡Run with a 3x3 stencil
                                       2â‰ 2 2âŒ·âµ                         # â€â¢â¢If the center of the stencil not a 2, we call it supported (that is, we only care about the rest of this expression if it is the inside of a brick)
     (                               )âˆ¨                                # â€â¢â£or
                                 âŒ·Â¨âŠ‚âµ                                  # â€â¢â¤Select from the stencil matrix
                       ((xâ†1 3)3)                                      # â€â£â¡  the right corners
                  (x 1)                                                # â€â£â¢  the left corners
             (3 x)                                                     # â€â£â£  the bottom corners
          +/Â¨                                                          # â€â£â¤Add over each of those
        2â‰¤                                                             # â€â¤â¡See if their sum is 2 or more
      1âˆŠ                                                               # â€â¤â¢Make sure one of those is true
 âˆ§/,                                                                   # â€â¤â£Finally, ravel and and-over to ensure everything in the matrix was reported as supported
ğŸ’
</code></pre>
<p>Created with the help of <a href="https://vyxal.github.io/Luminespire" rel="nofollow noreferrer">Luminespire</a>.</p>
</div>
<div id="pu1" class="pu"><h1>Python3, 407 bytes</h1>
<pre class="lang-py prettyprint-override"><code>E=enumerate
W=lambda X,D,U:{V for _,K in U if(V:=D.get((X,K),-1))&gt;-1}
def f(s):
 c,d=0,{}
 for x,r in E(s):
  q=[]
  for y,a in E(r):
   if a in'[__]':q+=[(x,y)]
   if']'==a:d[c]=q;q=[];c+=1
 D={j:a for a,b in d.items()for j in b}
 return all((L:=d[b][0][0])==len(s)-1 or len(W(L+1,D,d[b]))==2 or len({*W(L+1,D,d[b][:2]),*W(L-1,D,d[b][:2])})==2 or len({*W(L+1,D,d[b][2:]),*W(L-1,D,d[b][2:])})==2 for b in d)
</code></pre>
<p><a href="https://tio.run/##vZTbbqMwEIav109h5Qa7cVBMekhduVfpVau960FiUUSCaakISYwrNYry7FkbtyFg9qDVqigS6PvnnxlmiFcb9bIsRuOV3O9vuCjeFkLGSoBHnseLWRLDJzIh92z7ANOlhFNyC7MC3sMsRQ@MT/xnoRB6IreYDCjG1wO6A4lIYYpKzACck4QPyXYHKvM7kcZ8YzW45mGkb0bZkNgqslJ0dmiAF06nkcfWfR6id7LBkdW8yOM8Zkk4j/j6yqS5mvc5BXDCt68srjLGZGYyJn6mxKJE2LBXQ2a6GSnUmyxgnOcI3TGehLMoHJof5jwXhe5vQKE2mOdHdNenegQmCGs9@BS2J8dSyIIIE4MGDbT7jSVgjsUgazEN21fA@5JCDnu9HjDzAOYBlMEH8n0Dfb/SDno5Osj2skH2AjWqcXdkleu0UapVrirpKJ@JbIKzVjN1mSPnIVkb/HVUVeu8NZdGtbap1XyjYhP/y9wu2itqyuOuDdbyZZe7nikd/morh7g/bIVSJ8N/2gENjr7XL5u3OXfUclpWx8u3j/94eJJmuRISfV8WgsDSL1d5ppD3o/CwPk/ASmaFQimyRn2E4RYKXDRy0amLzlx07qILF41ddOkiOuxgHf1T8wL7nw" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu2" class="pu"><h1>Python, 209</h1>
<pre><code>def s(b):
 c=b.split(&quot;\n&quot;);s=&quot;&quot;.join(c);l=len(c[0]);t=&quot; &quot;*l+s+&quot;]]&quot;*l;a=lambda x,y,z:t[x+l*y+z]==&quot;]&quot;
 return all([(a(i,1,1)&amp;a(i,1,5))or(a(i,-1,1)&amp;a(i,1,1))or(a(i,-1,5)&amp;a(i,1,5))for i,x in enumerate(t)if x==&quot;[&quot;])
</code></pre>
<p>Tests:</p>
<pre><code>towers=(
&quot;[__]&quot;,

&quot;..[__]..\n&quot;
&quot;[__][__]&quot;,

&quot;........[__]........\n&quot;
&quot;......[__][__]......\n&quot;
&quot;........[__]........&quot;,

&quot;..[__][__]..\n&quot;
&quot;[__][__][__]\n&quot;
&quot;..[__][__]..\n&quot;
&quot;[__]....[__]&quot;,

&quot;............[__]..\n&quot;
&quot;..[__][__][__][__]\n&quot;
&quot;[__][__][__][__]..\n&quot;
&quot;..[__][__][__][__]\n&quot;
&quot;[__][__][__][__]..&quot;,

&quot;..[__]........[__]..\n&quot;
&quot;[__][__][__][__][__]\n&quot;
&quot;..[__][__][__][__]..\n&quot;
&quot;....[__][__][__]....\n&quot;
&quot;......[__][__]......\n&quot;
&quot;........[__]........&quot;,

&quot;..[__]..\n&quot;
&quot;........&quot;,

&quot;..[__]..\n&quot;
&quot;[__]....&quot;,

&quot;..[__]..\n&quot;
&quot;....[__]&quot;,

&quot;..[__][__]..\n&quot;
&quot;[__]....[__]\n&quot;
&quot;..[__][__]..\n&quot;
&quot;[__]....[__]&quot;,

&quot;..[__][__][__][__]\n&quot;
&quot;[__][__][__][__]..\n&quot;
&quot;..[__][__][__][__]\n&quot;
&quot;[__][__][__][__]..&quot;,

&quot;[__][__][__][__][__]\n&quot;
&quot;..[__][__][__][__]..\n&quot;
&quot;....[__][__][__]....\n&quot;
&quot;......[__][__]......\n&quot;
&quot;........[__]........&quot;,
)
[s(x) for x in towers]
</code></pre>
<p>Output:</p>
<pre><code>[True, True, True, True, True, True, False, False, False, False, False, False]
</code></pre>
</div>
<div id="pu3" class="pu"><h1>JavaScript 2 (ES6) - 148 <strike>151</strike> bytes</h1>

<pre><code>F=s=&gt;s.split(/\n/).every((b,i,a)=&gt;(r=1,b.replace(/]/g,(m,o)=&gt;(T=z=&gt;(a[i-1+(z&amp;2)]||[])[o-z%2*3]=='_',r&amp;=i&gt;a.length-2?1:T(2)?T(3)|T(0):T(3)&amp;T(1))),r))
</code></pre>

<p>Exepects a string of newline separated brick rows (note: if we could use a different separator character like "|" to separate rows this could be made 1 byte shorter).</p>

<p>Test in Firefox console with:</p>

<pre><code>F('..[__]......\n[__][__][__]\n..[__][__]..\n[__]....[__]'); // false
F('..[__][__]..\n[__][__][__]\n..[__][__]..\n[__]....[__]'); // true
</code></pre>
</div>
<div id="pu4" class="pu"><h2>80386 machine code, 98</h2>

<p>The code:</p>

<pre><code>60 8b f1 8b f9 b0 0a f2 ae 8b ef 2b ee b0 00 f2
ae 2b fe 83 ef 02 2b fd 72 41 03 f7 2b f5 33 c9
8a 7c 6e fc 8a 1c 6e b1 02 33 d2 8b c7 f7 f5 83
fa 02 75 03 b7 00 41 8a 66 fc 8a 06 3b fd 7d 02
33 c0 23 c3 0a c4 22 df 0b c3 f6 44 2e fe 01 74
04 d1 e8 73 06 2b f1 2b f9 73 c5 61 d1 d0 83 e0
01 c3
</code></pre>

<p>The code scans the ASCII art from the end to the beginning, jumping 2 characters at a time. This does twice the needed checks (it would be enough to jump 4 characters), but simplifies the logic.</p>

<p>Checking starts at the next-to-last row of characters (no need to check the last line). At each line, it starts 3 characters from the right (no need to check too far to the right). For each character, it checks 4 surrounding characters:</p>

<pre><code>A...B
..X..
C...D
</code></pre>

<p>There is a bunch of logical conditions to check:</p>

<ul>
<li>If A and C are brick characters, X is supported</li>
<li>If B and D are brick characters, X is supported</li>
<li>If C and D are brick characters, X is supported</li>
<li>If X is a brick character, it has to be supported; otherwise the structure is unstable</li>
</ul>

<p>It's a lucky coincidence that all brick characters <code>[_]</code> have their LSB set; all other characters <code>.\n</code> have it clear. In addition, the 80386 instruction set has these handy "high" and "low" registers (<code>ah</code>, <code>al</code>, etc), which help parallelize the checks a bit. So all the checking amounts to some obscure bit fiddling.</p>

<p>I started from the following C code:</p>

<pre><code>int check(const char* ptr)
{
    int width, result = 0, pos;

    width = strchr(ptr, '\n') - ptr + 1;
    pos = strlen(ptr) - 1 - width; // pos points to the B character
    ptr += pos - width;

    while (pos &gt;= 0)
    {
        int a = ptr[-4];
        int c = ptr[-4 + 2 * width];
        int b = ptr[0];
        int d = ptr[0 + 2 * width];
        int ab = a &lt;&lt; 8 | b;
        int cd = c &lt;&lt; 8 | d;
        if (pos &lt; width)
            ab = 0; // A and B don't exist; set them to 0
        int jump = 2; // distance to next brick
        if (pos % width == 2) // leftmost brick?
        {
            cd &amp;= 0xff; // C doesn't exist; set it to 0
            ++jump;
        }
        int support_v = ab &amp; cd;
        support_v = support_v | support_v &gt;&gt; 8; // data in LSB
        int support_h = cd &amp; cd &gt;&gt; 8; // data in LSB
        int support = (support_v | support_h) &amp; 1;
        if (!support &amp; ptr[-2 + width])
            goto UNSTABLE;
        ptr -= jump;
        pos -= jump;
    }
    return 1;
UNSTABLE:
    return 0;
}
</code></pre>

<p>I translated the code to assembly language (it's mostly one-to-one), including a golfed implementation of <code>strchr</code> and <code>strlen</code>. The following source code is translated by MS Visual Studio to the machine code at the top of my post.</p>

<pre><code>__declspec(naked) int __fastcall check(const char* ptr) // MS Visual Studio syntax
{
    _asm
    {
        pushad;

        // ecx = ptr
        mov esi, ecx; // esi = ptr
        mov edi, ecx
        mov al, 10;
        repne scasb;
        mov ebp, edi;
        sub ebp, esi; // ebp = width

        mov al, 0;
        repne scasb;
        sub edi, esi;
        sub edi, 2;
        sub edi, ebp; // edi = pos
        jc DONE;

        add esi, edi;
        sub esi, ebp;

        xor ecx, ecx; // ecx = jump

    LOOP1:
        mov bh, [esi - 4 + 2 * ebp]; // bh = C
        mov bl, [esi + 2 * ebp]; // bl = D
        // bx = CD
        mov cl, 2;
        xor edx, edx
        mov eax, edi
        div ebp;
        cmp edx, 2;
        jne LABEL2;
        mov bh, 0
        inc ecx;
    LABEL2:

        mov ah, [esi - 4]; // ah = A
        mov al, [esi]; // al = B
        // ax = AB
        cmp edi, ebp;
        jge LABEL3;
        xor eax, eax;
    LABEL3:

        and eax, ebx; // ax = support_v
        or al, ah; // al = support_v
        and bl, bh; // bl = support_h
        or eax, ebx; // eax = support
        test byte ptr[esi - 2 + ebp], 1;
        jz LABEL4; // not a brick character - nothing to check
        shr eax, 1; // shift the LSB into the carry flag
        jnc DONE;
    LABEL4:
        sub esi, ecx;
        sub edi, ecx;
        jnc LOOP1;

    DONE:
        // here, the result is in the carry flag; copy it to eax
        popad;
        rcl eax, 1;
        and eax, 1;
        ret;
    }
}
</code></pre>
</div>
<div id="pu5" class="pu"><h1>JavaScript (E6) 131 <s>261</s></h1>

<pre class="lang-javascript prettyprint-override"><code>F=a=&gt;
  [...a].every((e,p)=&gt;
    !(d={']':-3,'[':3}[e])
     |a[p-r]=='_'&amp;(x=a[p+r]!=' ')
     |a[p-r+d]=='_'&amp;(y=a[p+r+d]!=' ')
     |x&amp;y
  ,r=a.search(/\n/)+1)
</code></pre>
<p><strong>Test</strong> in FireFox/FireBug console</p>
<pre class="lang-javascript prettyprint-override"><code>;['[__]', '  [__]  \n[__][__]', '        [__]        \n      [__][__]      \n        [__]        ',
 '  [__][__]  \n[__][__][__]\n  [__][__]  \n[__]    [__]',
 '            [__]  \n  [__][__][__][__]\n[__][__][__][__]  \n  [__][__][__][__]\n[__][__][__][__]  ',
 '  [__]        [__]  \n[__][__][__][__][__]\n  [__][__][__][__]  \n    [__][__][__]    \n      [__][__]      \n        [__]        ']
.forEach(x =&gt; console.log(x+'\n'+F(x)))

;['  [__]  \n        ', '  [__]  \n[__]    ' ,'  [__]  \n    [__]',
 '  [__][__]  \n[__]    [__]\n  [__][__]  \n[__]    [__]',
 '  [__][__][__][__]\n[__][__][__][__]  \n  [__][__][__][__]\n[__][__][__][__]  ',
 '[__][__][__][__][__]\n  [__][__][__][__]  \n    [__][__][__]    \n      [__][__]      \n        [__]        ']
.forEach(x =&gt; console.log(x+'\n'+F(x)))
</code></pre>
<p><em>Output</em></p>
<pre class="lang-javascript prettyprint-override"><code>    [__]
true

  [__]  
[__][__]
true

        [__]        
      [__][__]      
        [__]        
true

  [__][__]  
[__][__][__]
  [__][__]  
[__]    [__]
true

            [__]  
  [__][__][__][__]
[__][__][__][__]  
  [__][__][__][__]
[__][__][__][__]  
true

  [__]        [__]  
[__][__][__][__][__]
  [__][__][__][__]  
    [__][__][__]    
      [__][__]      
        [__]        
true

  [__]  
false

  [__]  
[__]    
false

  [__]  
    [__]
false

  [__][__]  
[__]    [__]
  [__][__]  
[__]    [__]
false

  [__][__][__][__]
[__][__][__][__]  
  [__][__][__][__]
[__][__][__][__]  
false

[__][__][__][__][__]
  [__][__][__][__]  
    [__][__][__]    
      [__][__]      
        [__]        
false
</code></pre>
<p><strong>Ungolfed</strong></p>
<pre class="lang-javascript prettyprint-override"><code>F=a=&gt;(
  a=a.replace(/__/g,'').replace(/  /g,'.'),
  r=a.search(/\n/)+1,
  [...a].every((e,p)=&gt;
    e &lt; '0' ||
    (e ==']'
    ? // stable right side
     a[p-r]=='[' &amp; a[p+r]!='.' 
     |
     a[p-r-1]==']' &amp; a[p+r-1]!='.' 
     |
     a[p+r]!='.' &amp; a[p+r-1] != '.'
    : // stable left side
     a[p-r]==']' &amp; a[p+r]!='.' 
     |
     a[p-r+1]=='[' &amp; a[p+r+1]!='.' 
     |
     a[p+r]!='.' &amp; a[p+r+1] != '.'
    )  
  )
)
</code></pre>
</div>
<div id="pu6" class="pu"><p><strong>Python 279</strong></p>

<p>I think I am pretty bad in code golf challenges and maybe I use the wrong languages for that :D
But I love code that can be easily read :) Btw I would like to see a python code that uses less bytes!</p>

<pre><code>def t(b):
    r=b.split()
    l=len(r[0])
    r=['.'*l]+r
    for i in range(len(r)-2,0,-1):
        r[i]+='...'
        for j in range(l):
            if(r[i][j]=='['):
                if(r[i+1][j]&lt;&gt;'_'or(r[i+1][j+3]&lt;&gt;'_'and r[i-1][j]&lt;&gt;'_'))and(r[i+1][j+3]&lt;&gt;'_'or r[i-1][j+3]&lt;&gt;'_'):
                    return False
    return True
</code></pre>

<p>Possible examples:</p>

<pre><code>A = "..[__][__][__][__]\n\
[__][__][__][__]..\n\
..[__][__][__][__]\n\
[__][__][__][__].."
print t(A) #False

B = "..[__]........[__]..\n\
[__][__][__][__][__]\n\
..[__][__][__][__]..\n\
....[__][__][__]....\n\
......[__][__]......\n\
........[__]........"
print t(B) #True
</code></pre>
</div>
<div id="pu7" class="pu"><h1>MATLAB - 119 bytes</h1>

<p>Minified:</p>

<pre><code>function c=S(B),f=@(m)conv2([(0&amp;B(1,:))+46;B]+3,m,'valid');M=[2 0;-1 -1;0 2];c=isempty(B)||all(all(f(M)&amp;f(fliplr(M))));
</code></pre>

<p>Expanded:</p>

<pre><code>function c = isstable( B )

f = @(m) conv2( [(0&amp;B(1,:))+46; B] + 3, m, 'valid' );
M = [2 0;-1 -1;0 2];
c = isempty( B ) || all(all( f( M ) &amp; f(fliplr( M )) ));
</code></pre>

<p>Sample Usage:</p>

<pre><code>S4 = [  '..[__][__]..'; ...
        '[__][__][__]'; ...
        '..[__][__]..'; ...
        '[__]....[__]'];

fprintf( 'S4: %d\n', isstable( S4 ) );

S4: 1

U4 = [  '..[__][__]..'; ...
        '[__]....[__]'; ...
        '..[__][__]..'; ...
        '[__]....[__]'];

fprintf( 'U4: %d\n', isstable( U4 ) );

U4: 0
</code></pre>

<h3>Details</h3>

<p>The routine appends a row of <code>.</code> to the top of the input matrix, then converts to a numeric matrix by adding 3 to the ASCII character codes. Given this conversion, a 2D convolution with the kernel</p>

<pre><code> 2  0
-1 -1
 0  2
</code></pre>

<p>yields a matrix with <code>0</code> at locations where the character pattern</p>

<pre><code> . *
 _ _
 * .
</code></pre>

<p>is present, with <code>*</code> representing "any character". Because of the construction of the kernel, this is the only valid character pattern that will yield a <code>0</code>.</p>

<p>An identical convolution is performed with the left-right flipped version of the kernel to detect</p>

<pre><code> * .
 _ _
 . *
</code></pre>

<p>An input is stable if either <em>i</em>) it is empty, or <em>ii</em>) no zeros appear in either convolution.</p>

<p>Two frustrations are</p>

<ol>
<li><p>MATLAB's default convolution runs past the edges of the operand matrix, producing erroneous <code>0</code>s in opposing corners for both convolutions, requiring <code>,'valid'</code> (8 bytes) to be added to <code>conv2</code> call to limit the output to the area where the convolution is valid.</p></li>
<li><p>Handling the empty string case adds 12 bytes.</p></li>
</ol>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/38548/">38548</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




