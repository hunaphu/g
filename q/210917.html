<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::210917</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
  <!-- TXXX -->
<tr d-ix="0"><td>425</td><td>Python3</td><td>241015T184026Z</td><td><a href="https://codegolf.stackexchange.com/questions/210917/connect-the-three-kingdoms/276140#276140">Ajax1234</a></td></tr>
<tr d-ix="1"><td>245</td><td>R</td><td>200912T121931Z</td><td><a href="https://codegolf.stackexchange.com/questions/210917/connect-the-three-kingdoms/210974#210974">Dominic </a></td></tr>
<tr d-ix="2"><td>109</td><td>Perl 5 00ap</td><td>200913T191756Z</td><td><a href="https://codegolf.stackexchange.com/questions/210917/connect-the-three-kingdoms/211026#211026">Nahuel F</a></td></tr>
<tr d-ix="3"><td>067</td><td>Charcoal</td><td>200913T004749Z</td><td><a href="https://codegolf.stackexchange.com/questions/210917/connect-the-three-kingdoms/211000#211000">Neil</a></td></tr>
<tr d-ix="4"><td>nan</td><td>J</td><td>200912T212324Z</td><td><a href="https://codegolf.stackexchange.com/questions/210917/connect-the-three-kingdoms/210995#210995">xash</a></td></tr>
<tr d-ix="5"><td>196</td><td>Charcoal</td><td>200912T001139Z</td><td><a href="https://codegolf.stackexchange.com/questions/210917/connect-the-three-kingdoms/210960#210960">Neil</a></td></tr>
<tr d-ix="6"><td>137</td><td>JavaScript ES7</td><td>200911T162056Z</td><td><a href="https://codegolf.stackexchange.com/questions/210917/connect-the-three-kingdoms/210947#210947">Arnauld</a></td></tr>
<tr d-ix="7"><td>9793</td><td>Brachylog</td><td>200911T173959Z</td><td><a href="https://codegolf.stackexchange.com/questions/210917/connect-the-three-kingdoms/210954#210954">xash</a></td></tr>
<tr d-ix="8"><td>258</td><td>Perl 5</td><td>200911T144755Z</td><td><a href="https://codegolf.stackexchange.com/questions/210917/connect-the-three-kingdoms/210943#210943">Kjetil S</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Python3, 425 bytes</h1>
<pre class="lang-py prettyprint-override"><code>E=enumerate
M=[(1,0),(0,1),(-1,0),(0,-1)]
def P(x,y,t,d):
 q=[(x,y,[])]
 for x,y,s in q:
  if(x,y)in t:return s[:-1]
  for X,Y in M:
   if(d.get(U:=(x+X,y+Y))==0 or U in t)and U not in s and 0==any(all((x+X,y+Y)in s+[U]+t for X,Y in[(0,0),(1,1)]+M[:2])for x,y in s+[U]+t):q+=[(*U,s+[U])]
def f(b):
 d={(x,y):v for x,r in E(b)for y,v in E(r)}
 a,b,*r=[i for i in d if d[i]]
 p=P(*a,[b],d)
 while r:p+=P(*r.pop(),p,d)
 return p
</code></pre>
<p><a href="https://tio.run/##rVNNb@IwED2TX2Gxh9jERISPahXJxx5Z9YLUyo2qoIStSeoY23SJVvvbWU8aWqDplkrLIcx43ps3b@Ko2j5WcvJd6f3@muVy@5Tr1ObenHEc0RGheEQj9xwekmFEEi/LV@gG72hNLc1I7KGNg0PKE1dFq0ojyAwSEm1cGYkVlIlLbaxzu9USGR4PIwdu0Lf0DrBzwAI4C3/mFi9ihnfBLa2DO0IYGyGHXADOklRmLpSVhdQgSEeMpbLGaVniVxYUA75IAnskw50NMBM5Z0kw5/E4Ie3I6I1A4k3gXA0WtDloXa/wEvxm7HdjKH5uzWpgXrsipDV9fkk1@eOhlC7pQDMuGqiASuY8ooyLxPlX7AYPUsqXiVulh349ijJHOlYBnOtQVQoTqppauzm1h0ls9bCsUp1h4wbqtSXOhbR4zZhf@M0oa5ATyavySpQ21/hHJXOKTGhUKSz276VPnMHGYSbcYVo/mKrcWlFJbKgCBcP44ClVuBTG0n@0cX16LztBzTpVbPgu4XXCkP/N93pKw4iADdeVkNhv/wV5248hxPNMhBjq9/teePg1UfEahedR0XF2oHQyoLsZtzLFgX8EKMIPWn4pamQmBzdFR/Piv8lMEXu/s4/NXHp2pjI7ezXFZ6/m06jokrnqvAFfi7q3XBzJvL/xEXUf@tsHFrlb7bX3dugPpiPSwRmfcsaXcCannMklnOkpZ3oJZ3bKmV3CuTrlXDnO/i8" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.r-project.org/" rel="nofollow noreferrer">R</a>, <s>248</s> <s>257</s> <s>251</s> <s>264</s> <s>250</s> 245 bytes</h1>
<p><em>Edit: +9 bytes to fix corner-case (literally; see #1 below), then some golfing, then +13 bytes to fix another corner-case (#2, below), then some more golfing...</em></p>

<pre class="lang-r prettyprint-override"><code>function(g,s=setdiff,S=0:8%/%3-1,`^`=`%in%`){k=which(g&gt;0,T);v=k[,1];w=k[,2]
g[r&lt;-max(s(v+S,v)%%9),]=g[,c&lt;-max(s(w+S,w)%%9)]=1
for(i in 1:3){x=v[i];y=w[i]
if(!(x^(r+S)|y^(c+S)))`if`(F|x^v[-i],g[x:r,y--y^w[-i]**(y&lt;2)]&lt;-1,g[x,y:c]&lt;-F&lt;-1)}
g[k]=2;g}
</code></pre>
<p><a href="https://tio.run/##bZDPbsIwDMbvfQp2qGSDq9EittGSHXkBdotSylIaoopUSrv@EfDsXYrETjv9bH@29Pmzo6yMOcnm0JxPh1IblVeXmo3Fj5GNrgwoqll9anJdFLRny/jDf/VXQUhZmrHM18bP8Fqy7qzlGdTnkr4waVnJKRRJNzESnuJ2G1yOPdTQLvbUou9vkARTnORT6JzQPQTBQq@oLOiZNrMwXuG1Zy3XIhlY5@DpAl6gT8Eu9ngbUpCOiJkuMtjd@rTlgRakeB9bGoJgSLtpMJ/DsI1QbJ1zp9EQS1fvXIt3568ULErUfVRW5@xybKzuYUkb2qD3F4n91iYHT0JEayTHNUUPvtMbojed8ufy9MN/ucK0heMv" rel="nofollow noreferrer" title="R – Try It Online">Try it online!</a></p>
<p>This is a 'constructive' rather than 'brute-force' solution: we build a single set of roads in such a way that the conditions will be satisfied, rather than trying-out various possibilities and checking whether-or-not we've violated one or more of the conditions.</p>
<p>Input is a matrix with non-zero elements representing the three kingdoms.  Output is a matrix with roads represented by 1, and the kingdoms by 2.</p>
<p><strong>How?</strong></p>
<p>First we construct 'main' roads in the form of a '+' from north-to-south and from east-to-west across empty elements of the grid, and touching at least one of the 3 kingdoms (<em>take care: corner-case 2 was when all kingdoms are in edge rows/columns, so we need to make sure that our 'adjacent' roads are still in the grid</em>).<br />
Now there at most 2 kingdoms left that still need to be connected.<br />
For each kingdom that isn't already connected to the 'main' roads, we construct an 'access road' from the kingdom to one of the 'main' roads.<br />
We need to be careful that the 'access road' won't be split by one of the kingdoms: therefore, we check whether the unconnected kingdom is on the same row as another kingdom, and, if it isn't, we construct an east-west access road.
If the unconnected kingdom shares its row with another kingdom, we check if it also shares its column: if not, we build a north-south access road.  If it does (and it also shared a row), then we can be sure that the adjacent columns are empty, so we build a north-south access road in a column adjacent to the kingdom (<em>corner case 1: for this, we need to check if the kingdom is in column 1: if it is, we build the access road in column 2, otherwise in column y-1</em>).</p>
<p>Here are the roads (orange) built for each of the 6 test cases (kingdoms indicated in whiteish):</p>
<p><a href="https://i.sstatic.net/Xy0Qo.png" rel="nofollow noreferrer"><img src="https://i.sstatic.net/Xy0Qo.png" alt="enter image description here" /></a></p>
<p><strong>Commented code:</strong></p>
<pre class="lang-r prettyprint-override"><code>function(g,                     # g=input grid with kingdoms
 s=setdiff,                     # s=alias to 'setdiff()' function
 S=0:8%/%3-1,                   # S=defines adjacent indices 
 `^`=`%in%`){                   # ^=alias to '%in%' function
 k=which(g&gt;0,T)                 # k=get indices of the kingdoms
 v=k[,1];w=k[,2]                # v=x-coordinates, w=y-coordinates of kingdoms
 r&lt;-max(s(v+S,v)%%9)            # r=empty row next-to a kingdom
                                # (elements of v±1 that are different to v, avoiding zero and &gt;8)
 c&lt;-max(s(w+S,w)%%9)            # c=first empty column next-to a kingdom
 g[r,]=g[,c]=1                  # build the 'main' roads
 for(i in 1:3){                 # loop through each of the 3 kingdoms:
  x=v[i];y=w[i]                 #  (x,y=x- and y-coordinates of current kingdom)
  if(!(xin%(r+S)|y%in%(c+S)))   #  if x or y are not adjacent to r or s 
                                #  (so this kingdom isn't connected to the 'main' roads)
   `if`(F|x%in%v[-i],           #  if x is shared with the row of another kingdom, or
                                #  'F' indicates that we've already built an east-west 'access road':
    g[x:r,y                     #   build an north-south 'access road' from x to r
    -                           #   (either on the same row, y, or on an adjacent row
    (-(y%in%w[-i]))**(y&lt;2)&lt;-1,  #   if y is shared with the col of another kingdom);
    g[x,y:c]&lt;-F&lt;-1)             #  otherwise build an east-west 'access road' from y to c
  }
 g[k]=2;                        # mark the kingdoms on the grid
 g                              # and return the grid
}
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.perl.org/" rel="nofollow noreferrer">Perl 5</a> <code>-00ap</code>, <s>114</s>, 109 bytes</h1>

<pre class="lang-perl prettyprint-override"><code>$_|=substr'iiiiiiiii
iaiaiaiai
'x5,10*!(grep/k/,@F[1,7]),90;1while s/(?&lt;!i.{9})(?&lt;!ii)i(?!iii|.{9}i.{9}i)/a/s
</code></pre>
<p>6 bytes saved thanks to @DomHastings, but 1 lost to fix <a href="https://tio.run/##pY3RCoIwFIbvfYokURdrmxcSssSueomIWDTqoOXYjJTs1VvT8gn6fjj/x39zlNRVajtKqKBhqOWp5tcuaHnQ54zb4NDn5n40jY5gwgPxixe1KU7Ywo/PWipaUrzZ7hK82iOcMZ48LlDJmaFxsfaBPLMXGg0QxIWrfpjGHZB7bizvuABO5pY4yuF45bedkYm/7F2rBuqbsUvGRKU@" rel="nofollow noreferrer" title="Perl 5 – Try It Online">a case</a>.</p>
<p><a href="https://tio.run/##pZHRCoIwFIbvfYoiMQ3b5oWErKirXiIijKQOx1JcUZK9ekujRcRCpTPYPv5x/v2cpVEW@zKnhIbUsrJok/B9bl64WUwYl@aqmIjTWhyzPqgyIHwto3/xXY8NuvY2i1KK1J3NF547WjpuwLh33kEcdQS1p@MukGtwc54EDtjT8oCi0p4X4JSvC8lzHgInPUlUGdWGbyLfhBpNtWg7DFQ9HyKSHzat6CMN1idsaa0R8Q9NY411s64lbJK6KelHqP7unqRHSA5CDhkL4/QB" rel="nofollow noreferrer" title="Perl 5 – Try It Online">Try it online!</a></p>
<p>Another perl answer, with a different approach, I've also upvoted the other perl answer.</p>
<p>I had to fix several times because of some cases (in addition to those of the question) for which it didn't work.</p>
<h1>Solution</h1>
<p>The idea is to start from the grid of roads which almost works and fix for the different cases.
If there's a kingdom in the square region of <code>o</code>s rows: 1 or 7 (after golfing), the grid is aligned on (0,0), otherwise on (0,1)</p>
<pre class="lang-perl prettyprint-override"><code>.........      #########      # # # # #
ooooooooo      # # # # #      #########
.........      #########      # # # # #
.........      # # # # #      #########
.........  ?   #########  :   # # # # #
.........      # # # # #      #########
.........      #########      # # # # #
ooooooooo      # # # # #      #########
.........      #########      # # # # #
</code></pre>
<p>Then the remaining roads can be fixed by removing squares when all the squares in the four directions, empirically (haven't a proof yet), at a distance of 3 (right), 2 (left, bottom) or 1 (up), are not a road (or are out of the map).</p>
<pre class="lang-perl prettyprint-override"><code>  ?
??#???
  ?
  ?
</code></pre>
<h1>Justification</h1>
<p>Looking for a counter-example. Starting from a grid of roads and putting kingdoms so that road a kingdom could be disconnected.</p>
<p>Because of the symmetries only the first corner is shown.
For grid 1, the only case which causes a problem:</p>
<pre class="lang-perl prettyprint-override"><code>k.k###
. # # 
k#####
# # # 
</code></pre>
<p>and as there is no kingdom in the region described in solution it can't occur.</p>
<p>For grid 2, one example but other configurations exist:</p>
<pre class="lang-perl prettyprint-override"><code>k # #
..k###
k # #
######
</code></pre>
<p>One of the 2 kingdoms that cut the roads must be in the region described in solution, so this can't occur.</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 67 bytes</h1>
<pre><code>Ｆ⁹Ｆ⌕ＡＳk⊞υ⟦ικ⟧Ｂ⁹ψＦ⁹Ｆ⁹«Ｊκι¿¬№﹪⟦ικ⟧²﹪ΠＥυΠ⊕λ² »Ｆυ«Ｊ⊟ι⊟ιk»Ｆ³Ｆ³«Ｊ⁺³κ⁺³ι¤#
</code></pre>
<p><a href="https://tio.run/##bVDBSgMxFDx3v@IRLy8Qe3BPxZMKhQrKgt7Ew7K7bUPSvCVNRBG/Pb50U2mp75CZhJk3Q7pt6ztqbUpr8oALCQdcatffWYsrN8bwErx2G5QKhBFSQhP3W4wK3rQC8y5vq3v6xIWCL6ZnWxi/q9lj3I2vhEaBZsFMrwGfKeADRRfwifpoCadVCm44pDw1nrFjRTvmsON15To/7AYXhh6t5MkmmVtxyYACBIf8TD3iaX5DI2pWT5ibFIc5cdSleX3mtHGPNRfM7sKnDUvNfySuDgtSmh@nyof5Y/MLZi7fzH@6Mun6w/4C" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Outputs using spaces for empty tiles, but anything except <code>k</code> serves as empty on input. This is an entirely different approach to my previous answer, so I thought it deserved a separate answer. It relies on the observation that the grid with 16 holes solves all problems except those with three kingdoms near the corners. The one thing those problems have in common is that all three kingdoms lie on even rows and columns. In such cases the grid is offset diagonally resulting in a grid with 25 holes. Explanation:</p>
<pre><code>Ｆ⁹Ｆ⌕ＡＳk⊞υ⟦ικ⟧
</code></pre>
<p>Read in the grid and save the coordinates of the kingdoms.</p>
<pre><code>Ｂ⁹ψ
</code></pre>
<p>Prepare an empty area for the grid.</p>
<pre><code>Ｆ⁹Ｆ⁹
</code></pre>
<p>Loop through each square on the grid.</p>
<pre><code>«Ｊκι
</code></pre>
<p>Jump to that position.</p>
<pre><code>¿¬№﹪⟦ικ⟧²﹪ΠＥυΠ⊕λ² »
</code></pre>
<p>If both the row and column have the same parity as the bitwise OR of all of the coordinates, then place an explicit space at that position, preventing it from being flood filled. Since I don't have a good way of taking the bitwise OR of a list, I use De Morgan's laws to check whether neither row nor column contain have the parity of the bitwise AND of the complement of the list, noting that for the purposes of parity, product is equivalent to bitwise AND and increment is equivalent to complement.</p>
<pre><code>Ｆυ«Ｊ⊟ι⊟ιk»
</code></pre>
<p>Place the kingdoms on the grid.</p>
<pre><code>Ｆ³Ｆ³«Ｊ⁺³κ⁺³ι¤#
</code></pre>
<p>Try to flood fill starting at each of the nine centre squares. This guarantees that the result is a single connected road. It's not possible for only three kingdoms to disconnect the centre of the grid, so this is always safe.</p>
</div>
<div id="pu4" class="pu"><h1><a href="http://jsoftware.com/" rel="nofollow noreferrer">J</a>, <sup>139</sup> 127 bytes</h1>
<p>Starting from <code>[0,1]</code> or <code>[0,2]</code> forming two grids</p>
<pre><code>#XX#… and .X.#…
#.#.…     ####…
####…     .#.#…
#.#.…     ####…
</code></pre>
<p>at least one of the 3 attempts will succeed (based on a hacked together J script.) For some byte saving, this tries some more grids:</p>
<pre><code>+u({.@\:#@~.@,&quot;3)0|:(d|.!.0]*1+i.@$)*&quot;2/u=:(}:&quot;2}:&quot;{d|.10$#:1023 682)(2=_(d=:(,-)#:i.3)&amp;(*@]*[:&gt;./|.!.0)(9 9$!.1]1 2 2)*1=+)&quot;2]
</code></pre>
<p><a href="https://tio.run/##rZFNa8MwDIbv@RVqEmLLSVXbgbF6eBgGO@3U62Z66NcyH3bqqd3@ehYC6cZwSfdhEDzI0vtK6KVNiW3BGmBQgQTTxZTgbvFw35Z7fiD3ZDL3Tq5Ka5RHw9dHmpD0QpUNuRxFqmd7a/ibSXUXh@5byTwzSuoarq41cm2XfN1VVFPMTEM1Flw4Lx7NLc16LeRzmOcTUl6BBo1C2RJT7VtMdtYwYBVsC@KMssCKhjBJNqvnV9iBv6GlBt4PjQkNr6dwIvpOIZIbWqIdGDcMg9KX0kBnxH9EZww/Jw/j2/yLYaQ0/CF3sWEYu@Eohd9veCnFjxBOhu0H" rel="nofollow noreferrer" title="J – Try It Online">Try it online!</a></p>
<h3>How it roughly works</h3>
<p>There should still be some bytes golfable. But for now:</p>
<pre><code>(}:&quot;2}:&quot;{d|.10$#:1023 682)
</code></pre>
<p>The grid – first as a 10x10 matrix so we can easily shift via the 4 <code>d</code>irections, we'll define later. Drawback: we have to cut it down to 9x9. Now, for every grid:</p>
<pre><code>(9 9$!.1]1 2 2)*1=+
</code></pre>
<p>Whenever a castle is on a road, set the tile to empty. Also, give the roads at <code>[0,1]</code> and <code>[0,2]</code> value 2 (if they exist). From there we'll find the biggest connected road network now:</p>
<pre><code> 2=_(d=:(,-)#:i.3)&amp;(*@]*[:&gt;./|.!.0)
</code></pre>
<p>Until the map does not change: shift it around and give each road a new road number: the maximum of the current number and the ones of the connected roads (but keep 0 as 0). Finally, keep the roads marked with 2 – those are connected to the starting nodes</p>
<pre><code>(d|.!.0]*1+i.@$)*&quot;2/
</code></pre>
<p>Now to check that all castles are connected: Take the original input, and shift it into the 4 directions. Give each castle a unique number.</p>
<pre><code> +u({.@\:#@~.@,&quot;3)0|:
</code></pre>
<p>Sort the grids by the number of connected castle (the unique numbers after the shifted castle numbers are multiplied with the 1's of the road network.) Take the best one, add the castles back in – et voilà, a kingdom for you!</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 196 bytes</h1>
<pre><code>≔Ｅ⁹ＳθＦ⁹Ｆ⌕Ａ§θιk⊞υ⟦ικ⟧ＦυＦ⁴Ｆ⁴«θＪ§ι¹§ι⁰Ｍ✳⊗λ≔⁰ζＷ⁼ＫＫ.«✳⊗κ#≦⊕ζ»≔ωηＦ⁻υ⟦ι⟧Ｆ⁴Ｆ⁴«Ｊ§μ¹§μ⁰Ｍ✳⊗ξ≔ＫＤ⁹✳⊗νδＭ⌕δ#✳⊗ν¿∧№δ#¬№…δ⌕δ#¦k¿⁼⌕υμ¬⌕υι≔⟦μⅈⅉν⌕δ#ξ⟧η¿∧η⊖ΣＥ⟦ⅈⅉ⟧↔⁻π§η⊕ρ≔⟦⟦ικζλ⟧η⟦μν⌕δ#ξ⟧⟧ε»⎚»θＦε«Ｊ⊟§ι⁰⊟§ι⁰Ｍ✳⊗⊟ι✳⊗⊟ι×#⊟ι
</code></pre>
<p><a href="https://tio.run/##fVLLbtswEDzLX0E4lyXAGinaS5KT4LSAA7gw0PRQGD4oEhMRokhZIpM@4G9XdylKTuKkPEh8zO7s7GxeZm1uM933adepBwPrrIELwVam8e67a5V5AM4F2/Or2b1tGVxwFv5flSlSrSF1K1PIX7AXTCFuXs05ZxvfleAF2yrBqh2GxuQb24BHlBuzfeLs7yzZII0DokhufN3c2imrE@wj4p8dzznB1vZRwrVqZe6UNXBt/Z2WBSgeXiPbuWB/6PhUKi0ZfNn7THewkbICqnRBlSJ7pL/80eDl2ZwiEuxCTLIyeStraZwsYrrDRPAkWEk3QYqPjfl8/FPyV4Kql4KqUdB7iupB0chIxR9B6NNphObkVxGi1D2D1BSwtB4VFoM@wb5ZF6@Wv3MtlyXago9k6QgareQc04Q84RU9rWLXjtlLLENOXYL0rrPaOwlrZXwHP@GZ3pLk02JR0HZLFmNncXx22E6cGeyJflmMYPUOH2XQRP1PEqk7OeXAiMDyRlh0CGOWWmYt4OEwO85bcEoGQdEoGtGxWhXcEez07j8zSGCaQ4IMRO9jBLtVtewAqx1YhgE@9P1iXDP6VNNucbKrTu@qt3Bx9R8e9T8" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Works by drawing a line from a square adjacent to one kingdom to the edge of the grid, then drawing lines from squares adjacent to each of the other kingdoms to intersect the first line, except not allowing the two lines to be exactly one row apart. Explanation:</p>
<pre><code>≔Ｅ⁹Ｓθ
</code></pre>
<p>Input the grid.</p>
<pre><code>Ｆ⁹Ｆ⌕Ａ§θιk⊞υ⟦ικ⟧
</code></pre>
<p>Locate all of the kingdoms.</p>
<pre><code>ＦυＦ⁴Ｆ⁴«
</code></pre>
<p>Loop through each direction from each square adjacent to each kingdom.</p>
<pre><code>θ
</code></pre>
<p>Print the grid.</p>
<pre><code>Ｊ§ι¹§ι⁰Ｍ✳⊗λ
</code></pre>
<p>Jump to the selected kingdom and move to the selected adjacent square.</p>
<pre><code>≔⁰ζ
</code></pre>
<p>Count the number of empty squares.</p>
<pre><code>Ｗ⁼ＫＫ.«
</code></pre>
<p>Repeat while the current square is empty...</p>
<pre><code>✳⊗κ#
</code></pre>
<p>... mark it with a <code>#</code>...</p>
<pre><code>≦⊕ζ
</code></pre>
<p>... and increment the count.</p>
<pre><code>»≔ωη
</code></pre>
<p>Start with no line for the second kingdom.</p>
<pre><code>Ｆ⁻υ⟦ι⟧
</code></pre>
<p>Loop through the remaining kingdoms.</p>
<pre><code>Ｆ⁴Ｆ⁴«
</code></pre>
<p>Loop through each direction from each square adjacent to this kingdom.</p>
<pre><code>Ｊ§μ¹§μ⁰Ｍ✳⊗ξ
</code></pre>
<p>Jump to this kingdom and move to the selected adjacent square.</p>
<pre><code>≔ＫＤ⁹✳⊗νδ
</code></pre>
<p>Grab the line in the selected direction.</p>
<pre><code>Ｍ⌕δ#✳⊗ν
</code></pre>
<p>Move to where the line would intersect if it was valid.</p>
<pre><code>¿∧№δ#¬№…δ⌕δ#¦k
</code></pre>
<p>Does this line cross the first kingdom's line? If so:</p>
<pre><code>¿⁼⌕υμ¬⌕υι
</code></pre>
<p>If this is the second kingdom's line...</p>
<pre><code>≔⟦μⅈⅉν⌕δ#ξ⟧η
</code></pre>
<p>... then save this as its line.</p>
<pre><code>¿∧η⊖ΣＥ⟦ⅈⅉ⟧↔⁻π§η⊕ρ
</code></pre>
<p>Otherwise if the second kingdom's line does not intersect exactly one square away...</p>
<pre><code>≔⟦⟦ικζλ⟧η⟦μν⌕δ#ξ⟧⟧ε
</code></pre>
<p>... then save this as a solution.</p>
<pre><code>»⎚
</code></pre>
<p>Clear the canvas ready for the first kingdom's next adjacent square or the final output.</p>
<pre><code>»θ
</code></pre>
<p>Print the grid.</p>
<pre><code>Ｆε«
</code></pre>
<p>Loop over the kingdoms in the last solution found.</p>
<pre><code>Ｊ⊟§ι⁰⊟§ι⁰Ｍ✳⊗⊟ι
</code></pre>
<p>Jump to the position of the kingdom and move to the found adjacent square.</p>
<pre><code>✳⊗⊟ι×#⊟ι
</code></pre>
<p>Print the found line.</p>
<p>Note that this code tries all combinations of kingdoms and directions. It's probably unnecessary to try them all, for instance I think it's likely that you can always draw a line up from one of three sides of the bottommost kingdom and connecting the other two kingdoms to that line. If this is true then the code can be simplified, currently saving <s>10</s> 24 bytes: <a href="https://tio.run/##fVLLbtswEDzLX0E4lyXAGinaS5KT4LSAA7gw0PRQGD4oEhMRokhZIpM@4G9XdylKTuKkPEh8zO7s7GxeZm1uM933adepBwPrrIELwVam8e67a5V5AM4F2/Or2b1tGVxwFv5flSlSrSF1K1PIX7AXTCFuXs05ZxvfleAF2yrBqh2GxuQb24BHlBuzfeLs7yzZII0DokhufN3c2imrE@wj4p8dzznB1vZRwrVqZe6UNXBt/Z2WBSgeXiPbuWB/6PhUKi0ZfNn7THewkbICqnRBlSJ7pL/80eDl2ZwiEuxCTLIyeStraZwsYrrDRPAkWEk3QYqPjfl8/FPyV4Kql4KqUdB7iupB0chIxR9B6NNphObkVxGi1D2D1BSwtB4VFoM@wb5ZF6@Wv3MtlyXago9k6QgareQc04Q84RU9rWLXjtlLLENOXYL0rrPaOwlrZXwHP@GZ3pLk02JR0HZLFmNncXx22E6cGeyJflmMYPUOH2XQRP1PEqk7OeXAiMDyRlh0CGOWWmYt4OEwO85bcEoGQdEoGtGxWhXcEez07j8zSGCaQ4IMRO9jBLtVtewAqx1YhgE@9P1iXDP6VNNucbKrTu@qt3Bx9R8e9T8" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Explanation:</p>
<pre><code>≔Ｅ⁹ＳθＦ⁹Ｆ⌕Ａ§θιk⊞υ⟦ικ⟧
</code></pre>
<p>Input the grid and locate all of the kingdoms.</p>
<pre><code>≔⊟υτ
</code></pre>
<p>Get the bottommost kingdom.</p>
<pre><code>Ｆ³«
</code></pre>
<p>Check the squares to its right, above and left.</p>
<pre><code>θＪ§τ¹§τ⁰Ｍ✳⊗ι
</code></pre>
<p>Print the grid and jump to the selected adjacent square.</p>
<pre><code>≔⁰ζＷ⁼ＫＫ.«↑#≦⊕ζ»
</code></pre>
<p>Draw a line up as far as possible.</p>
<pre><code>≔ωη
</code></pre>
<p>Start with no line for the second kingdom.</p>
<pre><code>ＦυＦ⁴Ｆ⁴«
</code></pre>
<p>Loop over the other two kingdoms, considering all lines for all four adjacent squares. (I could just do left and right lines but it turns out that all lines is golfier.)</p>
<pre><code>Ｊ§κ¹§κ⁰Ｍ✳⊗μ
</code></pre>
<p>Jump to this kingdom's adjacent square.</p>
<pre><code>≔ＫＤ⁹✳⊗λδ
</code></pre>
<p>Grab the line in the selected direction.</p>
<pre><code>¿∧№δ#¬№…δ⌕δ#¦k
</code></pre>
<p>Does this line cross the first kingdom's line? If so:</p>
<pre><code>¿⌕υκ«
</code></pre>
<p>If this is the third kingdom's line, then...</p>
<pre><code>¿∧η⊖↔⁻ⅉ§η¹
</code></pre>
<p>... if the second kingdom's line isn't exactly one row away, then...</p>
<pre><code>≔⟦⟦τ¹ζι⟧η⟦κλ⌕δ#μ⟧⟧ε
</code></pre>
<p>... save this as a solution.</p>
<pre><code>»≔⟦κⅉλ⌕δ#μ⟧η
</code></pre>
<p>Otherwise for the second kingdom save this as its line.</p>
<pre><code>»⎚
</code></pre>
<p>Clear the canvas ready for the first kingdom's next adjacent square or the final output.</p>
<pre><code>»θＦε«Ｊ⊟§ι⁰⊟§ι⁰Ｍ✳⊗⊟ι✳⊗⊟ι×#⊟ι
</code></pre>
<p>Print the solution.</p>
</div>
<div id="pu6" class="pu"><h1>JavaScript (ES7), <s> 166 153 149 </s> 137 bytes</h1>
<p>Slower and even less subtle than my first answer, but also shorter. This simply looks for a path touching all kingdoms without generating any <span class="math-container">\$2\times 2\$</span> road blocks.</p>
<p>Takes input as a flat list of 81 entries, with <span class="math-container">\$0\$</span> for an empty cell and <span class="math-container">\$2\$</span> for a kingdom. Returns another list with <span class="math-container">\$0\$</span> for an empty cell, <span class="math-container">\$1\$</span> for a road and <span class="math-container">\$3\$</span> for a kingdom.</p>
<pre class="lang-javascript prettyprint-override"><code>f=(a,X)=&gt;+(z=/.*1,1.{15}1,1|2/.exec(a))?a.some((v,x)=&gt;(a[x]++,(d=(x-X)**2)-1|x/9^X/9&amp;&amp;d-81?0:v?1/X&amp;&amp;v==2?f(a,X):0:f(a,x))||!a[x]--)&amp;&amp;a:!z
</code></pre>
<p><a href="https://tio.run/##pVDdboIwGL33KeoNbfn5EJMlE1O52l7AGxJ1SQPFYbE4YIYpPrsDI9MsLGrWi34np@ec76QrvuV5kMWbwlJpKI7HiBFu@pRNDLJjNuiO6cDeeTrUsxraIEoREE6pxyFP14KQrVnWYsJn5cIwTBIyUlo@1fUhtZyqtEdvvj3StNB6dryBu/Uc29e0LWNDLzrtcQduA0pKq6rfhFgW1TTu9nfHTHx8xpkgOMoxhUzw8DVOxPRLBWRAoUinRRarJaGQb5K4IHiu5qoWRmn2woN3kiM2QfseQhwxNAOA/CKsZas0VgRjuoA135CgEQ@RjhrEEJaY0vHZW/c74SBVeZoISNIl4SeXalwYDJB4phaXzPqxqBvYsB8d7GXLN2uRgU5z3DvQI7Sn11zyB8FvJDu41tLp6MnWc0VK@CPmIXTVRt5u@GB0Byn/wXVEy1t/fRPJe1rfi7q/8Ay/AQ" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<h3>How?</h3>
<p>We use the regular expression <code>/.*1,1.{15}1,1|2/</code> to detect either a <span class="math-container">\$2\times 2\$</span> block of roads or a remaining kingdom. We get <code>null</code> if nothing is matched, a string that is coerced to <em>NaN</em> by the unary <code>+</code> if a block is matched, or a string that is coerced to <span class="math-container">\$2\$</span> if a kingdom is matched.</p>
<p>Because the left and right boundaries are ignored, the condition on the road block is a little more restrictive than it really should, as it will also match something like that:</p>
<pre><code>.........
........X
X.......X
X........
.........
</code></pre>
<p>However, we have plenty of room to find a path that will work even without including that kind of pattern.</p>
<hr />
<h1>JavaScript (ES7), <s> 243 236 </s> 226 bytes</h1>
<p><em>I'm not very happy with this method, as it heavily relies on a brute-force search. There must exist more elegant and more straightforwards ways of solving this. But it does work!</em></p>
<p>Expects a matrix with <span class="math-container">\$0\$</span> for an empty cell and <span class="math-container">\$3\$</span> for a kingdom. Returns another matrix with <span class="math-container">\$0\$</span> for an empty cell, <span class="math-container">\$2\$</span> for a kingdom and <span class="math-container">\$4\$</span> for a road.</p>
<pre class="lang-javascript prettyprint-override"><code>f=(m,k)=&gt;(M=m.map((r,y)=&gt;r.map((v,x)=&gt;x^k%8&amp;&amp;x^k%8+2+k/8%8&amp;&amp;y^(q=k/64&amp;7)&amp;&amp;y^q+2+k/512?v:v?3:(X=x,Y=y,1))),g=(X,Y)=&gt;M.map((r,y)=&gt;r.map((v,x)=&gt;(x-X)**2+(y-Y)**2-1?0:v-1?v-3?0:r[x]=2:g(x,y,r[x]=4))))(X,Y)|/1|3/.test(M)?f(m,-~k):M
</code></pre>
<p><a href="https://tio.run/##pZDBT8IwFMbv/BW9SF9ZV2CgkpHCSW@cvEAQk2UOHGUddHPZAvqvYztBiJlB4w7t73t97@u3Lr3MS3wVrlNbxs/Bfj/nEFFB@ABGPGKRtwZQtNBafYqM5lrkT@KqV6@Xm@VYotkzsniCDRfNm279lhi1KY@u284wc7Nhx4Uxz@mEF7RNCKELDmM60WajH6@B3B6TRsOxoLAnBuz2sOVmes3sjiY1zWfccReQ04KWoqudSem7a7Z3nSZLgySFERnO9W/Z74K4o70KNq@hCgDPE0yYCrzn@3AVPBTShxZhafyQqlAugLBkvQpTwI/yUerGeazuPP8FEsQHaFtDKEIcJacm3WKiK3M8ZYypWal9ozuogQxxhAXWCfuHcZ2qZD@WSbwK2CpeQHSy@XwMaRC2LRdhhilyXGNCUVfvFn4jUzkjbBmHErC2PpCJgyxU7v3aG9mz41czi/gi9p1ERe04UjlRE8eZs6JgP9j8ic7SiMsJ/2hdURT/qFVYi0tvfZHEb1L/lqqf8IAf" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<h3>How?</h3>
<p>All puzzles can be solved<sup>1</sup> by putting at most 2 horizontal roads and at most 2 vertical roads across the entire grid, either next to or 'over' the kingdoms.</p>
<p><sup>1: this was empirically verified</sup></p>
<p><em>Example:</em></p>
<p><a href="https://i.sstatic.net/ktDf8.png" rel="nofollow noreferrer"><img src="https://i.sstatic.net/ktDf8.png" alt="example" /></a></p>
<p>Given <span class="math-container">\$k\ge 0\$</span>, we compute:</p>
<p><span class="math-container">$$x_0=k\bmod 8$$</span>
<span class="math-container">$$x_1=x_0+2+(\lfloor k/8\rfloor \bmod 8)$$</span>
<span class="math-container">$$y_0=\lfloor k/64\rfloor \bmod 8$$</span>
<span class="math-container">$$y_1=y_0+2+\lfloor k/512\rfloor$$</span></p>
<p>We put vertical roads at <span class="math-container">\$x_0\$</span> and <span class="math-container">\$x_1\$</span> and horizontal roads at <span class="math-container">\$y_0\$</span> and <span class="math-container">\$y_1\$</span>. If any value is greater than <span class="math-container">\$8\$</span>, it's simply ignored.</p>
<p>Because <span class="math-container">\$x_1\ge x_0+2\$</span> and <span class="math-container">\$y_1\ge y_0+2\$</span>, we will never end up we a <span class="math-container">\$2\times 2\$</span> block of roads.</p>
<p>Starting from a road cell, we flood-fill the grid to make sure that the two other criteria are fulfilled.</p>
</div>
<div id="pu7" class="pu"><h1><a href="https://github.com/JCumin/Brachylog" rel="noreferrer">Brachylog</a>, <sup>97</sup> 93 bytes</h1>
<p>This actually is fast – brute force in Brachylog! You can't believe how surprised I was when I kept upping the board size. However, this assumes that a road doesn't need to fork. If anyone finds a counterexample – be warned, the other version will not run in time on TIO! :-)</p>
<p>Takes castles as 2, and returns roads as 1.</p>
<pre><code>∧ċ{Ċℕᵐ≤ᵛ⁹}ᵐ{s₂{;.\-ᵐȧᵐ+1∧}ᵈ}ᵇP{,1↻₁}ᵐX&amp;{iiʰgᵗc}ᶠT{ṗʰb}ˢ{,.≠&amp;↰₃ᵐ∈ᵛ}P∧T,X≜bᵍtᵐhᵐḍ₉.¬{s₂\s₂c=₁}∧
</code></pre>
<p><a href="https://tio.run/##SypKTM6ozMlPN/r//1HH8iPd1Ue6HrVMfbh1wqPOJQ@3zn7UuLMWyKkuftTUVG2tF6ML5JxYDiS0DYHKgVIdQNweUK1j@Kht96OmRpDiCLXqzMxTG9Ifbp2eXPtw24KQ6oc7p5/akFR7elG1jt6jzgVqj9o2PGpqBlnS0QG0pDYAaFaITsSjzjlJD7f2lgAlMoD44Y7eR02deofWgG2PARHJtiA7gKr//4@ONtBBg7E6aGJGWMQQ6ozw6iXdPMJisf@jAA" rel="noreferrer" title="Brachylog – Try It Online">Try it online!</a> or <a href="https://tio.run/##SypKTM6ozMlPN/pf/XBX58OtEx51LFdS0LVTUAJy7R@1bXjU1ISQ0NXVBYnXArn/gfwj3dU5QPlHLVNB8p1LHm6d/ahxJ0i2GKRta3t1jC6Qc2I5kNAGCs8@tDMDyAyo1jF81Lb7UVMjSGmEWjXYmo6HO6ef2pBU@3DbAmedgEedC4AWOFdb64ElWwyBvFqwKzqA5gCl56hVZ2ae2pD@cOv0ZJAenYikh1t7S4BKQFY83NH7qKlT79CaapBLYkBEsi3IQqAx//9HR0cb6ChgR7E6CiiSRvgkDUiVNCJbJ3Y3UeAgkGy0EaYfiTTYiJJgGESS4GDAGzNGdInTQRIMZBpsNKR0khkMRrQtG2gtaUS31DAQkpTmUmxlYGwsAA" rel="noreferrer">Try all testcases!</a></p>
<h3>How the original version works</h3>
<p>Many bytes got lost for getting the output into a matrix form, as I didn't find a neat way to go from list of coordinates to its matrix representation. The rough story is:</p>
<pre><code>ċ{l₂ℕᵐ≤ᵛ⁹}ᵐ
</code></pre>
<p>We are looking for a path: a list of coordinates, each 0 ≤ X ≤ 9.</p>
<pre><code>s₂ᵇ{\-ᵐȧᵐ+}ᵛ¹hᵐ
</code></pre>
<p>And every pair of consecutive coordinates has a distance of 1.</p>
<pre><code>P{,1↻₁}ᵐX
</code></pre>
<p>We'll store the path as <code>P</code>, and a version with a 1 before every coordinate as <code>X</code>.</p>
<pre><code>&amp;{iiʰgᵗc}ᶠT
</code></pre>
<p>Transform the matrix to a list of <code>[Type, Y, X]</code> and store it as <code>T</code>.</p>
<pre><code>{ṗʰb}ˢ
</code></pre>
<p>However, we are only interested in cities for now, so the <code>Type</code> must be prime (that's why they are marked with 2).</p>
<pre><code>C,P≠
</code></pre>
<p>The city and path coordinates must all be different to each other.</p>
<pre><code>∧C{;.↰₂1∧}ᵐ∈ᵛP≜
</code></pre>
<p>Every city coordinate, shifted by a distance of 1, must be in the path.</p>
<pre><code>∧T,Xbᵍtᵐhᵐḍ₉
</code></pre>
<p>To the tiles <code>T</code> append <code>X</code> (the path with <code>Type = 1</code> prepended), group the tiles by their coordinates and take the last one – so roads will overwrite empty tiles. Reduce the list to the <code>Type</code> and split it into a 9x9 matrix.</p>
<pre><code>.¬{s₂\\s₂c=₁}∧
</code></pre>
<p>This is already the output, but make sure there is no 2x2 submatrix of roads.</p>
</div>
<div id="pu8" class="pu"><h1><a href="https://www.perl.org/" rel="nofollow noreferrer">Perl 5</a>, <s>251</s> <s>317</s> <s>298</s> 258 bytes</h1>

<pre class="lang-perl prettyprint-override"><code>sub f{eval'forP(0..80){forT(0,1){my@r;forK(@_){X=intP/9;Y=P%9;I=intK/9;J=K%9;push@r,X*9+Y andT&amp;&amp;Y-J?Y-=Y&lt;=&gt;J:X-I?X-=X&lt;=&gt;I:Y-J?Y-=Y&lt;=&gt;J:0 whileX.Y neI.J}D=&quot;.&quot;x81;substrD,$_,1,1for@_;substrD,$_,1,0for@r;3==D=~y/1/1/&amp;&amp;D!~/00.{7}00/&amp;&amp;returnD}}'=~s/[A-Z]/\$$&amp;/gr}
</code></pre>
<p><a href="https://tio.run/##bVJNk5pAFLz7K14M4SMZmMF1AZdMllRxUS8e9gBhKcqU6JJVpAZM1qLgr5uBManCBA49/fr1o5l6Rcr295dLefoO2zr9ud4r2yNbqcQwHKLV/PykEmRq9eHsMZfTpeolWh3QLK9WeOaGdPVh5s47uuR0QZecFqfyxWMo@Dj7FMI63zzJcqgvHkOdhp/pl8VDoM8fA50GnMwfBgqBXy/ZPg2MEPJ0biwan46N8ZtjujxgWTEfSQkykcmDeMmwRroac@8o9Wl7xiZ/Zdl/12JCjNpuCOGUpdWJ5X7TKLQtcfRV/xbjZ0mS8Y41F69Ky4qqEEUmmsYIoikyO7DQfRyjEVyfKCKIdHWCJh1MOLuRe5spuiacDeSJqE8FWP@6HeHuI9gcBrIlbLb4hsMjDGQHWaJuC3Buh1siuS3A@e@P/U1ObpP30e4ETK9uzR3xm1f729Pqvv1wBu81y3eb4wEoHNYFSFISkZjvQ3foontS4va9m6ws9uuzClv1j0frZjajbiWvKtRQML5i8OOY5aqioH6oIKAg3pNVGGvG@DkfIyiOBW2xUc8avNOAtsC3geDX95ghUHTlzbQRdJ3QXH4D" rel="nofollow noreferrer" title="Perl 5 – Try It Online">Try it online!</a></p>
<p>Somewhat ungolfed:</p>
<pre class="lang-perl prettyprint-override"><code>sub f {
  for$p(0..80){              #loop through all possible starting points p,
                             #... the crossroads in the 9x9 board
                             #... from which each road to each kingdom starts
   for$t(0,1){               #for each starting point, try two strategies
                             #...of movement: vertical first or horizontal first
    my @r;                   #init list of road tiles to empty
    for(@_){                 #loop through all the three kingdoms from input
      $x=int$p/9; $y=$p%9;   #x,y = start roads at current starting point p
      $X=int$_/9; $Y=$_%9;   #X,Y = current kingdom

      push @r, $x*9+$y       #register road tile while x,y not yet reached X,Y
      and                          # move x,y towards X,Y
      $t &amp;&amp; $y-$Y ? $y-=$y&lt;=&gt;$Y :
            $x-$X ? $x-=$x&lt;=&gt;$X :
            $y-$Y ? $y-=$y&lt;=&gt;$Y :0 # move horizontally or vertically first
                                   # ...depending on current strategy t=0 or 1
        while $x.$y ne $X.$Y   # continue towards current kingdom unless there
    }
    $d='.'x81;                 # init current board string of 81 dots
    substr $d,$_,1,1 for @_;   # put 1's at kingdoms
    substr $d,$_,1,0 for @r;   # put 0's at road tiles
    3==$d=~s/1/1/g             # if board has 3 kingdoms (none overrun by road)
      &amp;&amp; $d!~/00.{7}00/        # and current board has no 2x2 road tiles
      &amp;&amp; return $d             # then the board is valid and is returned
                               # otherwise try the next of the 81 starting points
  }
 }
}
</code></pre>
<p>Can run like this:</p>
<pre class="lang-perl prettyprint-override"><code>@test=( [[1,4], [4,1], [6,5]],
        [[0,0], [0,2], [2,0]],
        [[0,1], [1,0], [2,1]],
        [[2,0], [4,0], [6,0]],
        [[0,8], [1,4], [7,4]],
        [[6,0], [7,1], [8,2]] );
for(@test){
    my @kingdom = map <span class="math-container">$$_[0]*9+$$</span>_[1], @$_;
    print display( f(@kingdom) );
}
sub display{join('',map join(' ',split//).&quot;\n&quot;,pop=~y/10/k#/r=~/.{9}/g).('-'x17).&quot;\n&quot;}
</code></pre>
<p>First lines of output: (see '<em>Try it online</em>' link above for more)</p>
<pre class="lang-perl prettyprint-override"><code># . . . . . . . .
# # # # k . . . .
# . . . . . . . .
# . . . . . . . .
# k . . . . . . .
# . . . . . . . .
# # # # # k . . .
. . . . . . . . .
. . . . . . . . .
</code></pre>
</div>
<!-- TYYY -->

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/210917/">210917</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




