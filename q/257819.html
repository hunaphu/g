<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::257819</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>136</td><td>JavaScript Node.js</td><td>241229T180141Z</td><td><a href="https://codegolf.stackexchange.com/questions/257819/find-sub-matrix-with-matched-cell-1/277439#277439">l4m2</a></td></tr>
<tr d-ix="1"><td>196</td><td>C</td><td>230215T093354Z</td><td><a href="https://codegolf.stackexchange.com/questions/257819/find-sub-matrix-with-matched-cell-1/257867#257867">HatsuPoi</a></td></tr>
<tr d-ix="2"><td>046</td><td>Charcoal</td><td>230214T224307Z</td><td><a href="https://codegolf.stackexchange.com/questions/257819/find-sub-matrix-with-matched-cell-1/257852#257852">Neil</a></td></tr>
<tr d-ix="3"><td>109</td><td>Wolfram Language Mathematica</td><td>230215T070349Z</td><td><a href="https://codegolf.stackexchange.com/questions/257819/find-sub-matrix-with-matched-cell-1/257864#257864">lesobrod</a></td></tr>
<tr d-ix="4"><td>020</td><td>Vyxal</td><td>230215T165839Z</td><td><a href="https://codegolf.stackexchange.com/questions/257819/find-sub-matrix-with-matched-cell-1/257873#257873">AndrovT</a></td></tr>
<tr d-ix="5"><td>186</td><td>JavaScript</td><td>230214T190308Z</td><td><a href="https://codegolf.stackexchange.com/questions/257819/find-sub-matrix-with-matched-cell-1/257845#257845">EzioMerc</a></td></tr>
<tr d-ix="6"><td>075</td><td>J</td><td>230215T053950Z</td><td><a href="https://codegolf.stackexchange.com/questions/257819/find-sub-matrix-with-matched-cell-1/257862#257862">Jonah</a></td></tr>
<tr d-ix="7"><td>142</td><td>Excel</td><td>230215T081833Z</td><td><a href="https://codegolf.stackexchange.com/questions/257819/find-sub-matrix-with-matched-cell-1/257866#257866">Jos Wool</a></td></tr>
<tr d-ix="8"><td>148</td><td>Python NumPy</td><td>230214T205603Z</td><td><a href="https://codegolf.stackexchange.com/questions/257819/find-sub-matrix-with-matched-cell-1/257850#257850">loopy wa</a></td></tr>
<tr d-ix="9"><td>019</td><td>MATL</td><td>230214T153728Z</td><td><a href="https://codegolf.stackexchange.com/questions/257819/find-sub-matrix-with-matched-cell-1/257829#257829">Suever</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 136 bytes</h1>

<pre class="lang-none prettyprint-override"><code>U=&gt;U.map(L=(r,y)=&gt;r.map((c,x)=&gt;k=k&lt;(t=L[[,y,x]]=Math.min(-~L[[,y-1,x-1]],U[[y,x]]=c*-~U[[y-1,x]],L[[y,x]]=c*-~L[[y,x-1]]))?t:k),k=0)|k*k
</code></pre>
<p><a href="https://tio.run/##bY2xDoIwFEV3v4KxJa@EruLDH8CRqenQICgWKIHGQGL49Vro4mDylnPuSd5LvdVcTe1o2WDutWvQlZiXSa9GUiCZYKWYTweSChYPGvWFWCyEgBUWKfGm7DPp24Gw7ZCMw8K4lFAKEYoqZtsO@@J98esD7D2lV3vWFDSm9KNj7bLKDLPp6qQzD9IQcRIcohQiHk7Cf8H/FCFKvfBvMvcF" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<p>Assumes &quot;2D array&quot; <code>L[[y,x]]</code> is O(1)</p>
</div>
<div id="pu1" class="pu"><h1>C, C++ : <s>231</s> <s>227</s> 196 bytes</h1>
<p>-4 bytes thanks to EzioMercer</p>
<p>-31 bytes thanks to ceilingcat</p>
<pre class="lang-cpp prettyprint-override"><code>int f(int t[],int x,int y){int z=1,j=y,i,v,w,m,k,b;for(;j--;)for(i=x;i--;)if(t[i*y+j]){v=k=1;w=0;for(m=x-i&lt;y-j?x-i:y-j;k++&lt;m;w=v?k:w)for(b=k*k;b--;)v=t[y*(i+b%k)+j+b/k]?v:0;z=w&gt;z?w:z;}return z*z;}
</code></pre>
<p><a href="https://tio.run/##jZHdaoQwEIXvfQrZspCYsVXYvTFmfRDrRdW1jamu2PiPz24TrdBuoTSBnDk5kw/CJFVlvybJsvBSmhnSpwwj0Nqv54AnLSNzIWcDcGihgwIExDS71Yjmtk2xrjjrKdeGZ0iG3BpIHuGpZYK5tGPO2l2w3ub@YOeBUk8pFYT4hcrbQHjdyomZsASNNallMhwsxEl8FJjkJH4SUdB6Dh1ZdxmDzhvpXF9lU5fmaKl6eeBl8t6kV/9Dpvz2@HYxtg@do/AUmcycDFOtyYV1z7BZBxxlnd1u6Z1171Njpiu8@Q3/QVvN9@f/SXd48cJLhL/IVa2uMnSo2TF9Lg@gxqXnZWEJZzhhTP/uavauefkE" rel="nofollow noreferrer">TIO Link</a> thanks The Thonnu for pointing it out</p>
<p>Test code :</p>
<pre class="lang-cpp prettyprint-override"><code>int t[5][4] = {
    {1,1,1,1},
    {0,0,1,0},
    {1,1,1,0},
    {1,1,1,1},
    {1,1,1,0}
};

int main() {
    printf(&quot;r=%d\n&quot;, f((int*)t,5,4));
    return 0;
}
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, <s>88</s> <s>80</s> 46 bytes</h1>
<pre><code>≔Ｅθ⁰θＷＳ«≔⮌θη≔⟦⁰⟧θＦι⊞θ×Ｉκ⊕⌊⟦↨υ⁰⊟η↨η⁰⟧⊞υ⌈θ»ＩＸ⌈υ²
</code></pre>
<p><a href="https://tio.run/##NY4/D8IgEMVn@RSMR6IJuDqpk0OTRt2MA6mnEFva8kdNjJ8dr60ywOXx3u9eZbSvWl3nvA7B3hwUuoN@zqWY816s2NPYGjnsXJfiIXrrbiAEf7PZz77HB/qA0JPfkP@vn@R5AsyuredgBS9TMAP5aBsMsNUhwp1CO1d5bNBFvEBhnW1SA6eNJmSaWpRtB4beUTODdhZ0iDwSyVXo1xjrB/XDSmoZpwVl@0QP//9ElOUQzVlJpRT73WqapZIsLx71Fw" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link to verbose version of code. Takes input as a list of newline-terminated bit strings. Explanation: Now a port of @Jonah's J solution.</p>
<pre><code>≔Ｅθ⁰θ
</code></pre>
<p>Start with a row of zeros.</p>
<pre><code>ＷＳ«
</code></pre>
<p>Loop over each input row.</p>
<pre><code>≔⮌θη
</code></pre>
<p>Reverse the previous row totals to make them easier to process.</p>
<pre><code>≔⟦⁰⟧θ
</code></pre>
<p>Start collecting a new row with a zero column.</p>
<pre><code>Ｆι
</code></pre>
<p>For each cell...</p>
<pre><code>⊞θ×Ｉκ⊕⌊⟦↨υ⁰⊟η↨η⁰⟧
</code></pre>
<p>... multiply its value with the incremented minimum of the cells above and to the left. The cell above is obtained by popping the reversed previous row, the cell to the above left is obtained as the base <code>0</code> of the popped reversed previous row and the cell to the left is obtained as the base <code>0</code> of the new row.</p>
<pre><code>⊞υ⌈θ
</code></pre>
<p>Collect the maximum square found in this row.</p>
<pre><code>»ＩＸ⌈υ²
</code></pre>
<p>Output the largest found square from all rows.</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.wolfram.com/wolframscript/" rel="nofollow noreferrer">Wolfram Language (Mathematica)</a>, 109 bytes</h1>
<pre><code>Catch[Do[If[AnyTrue[Erosion[ArrayPad[#,1],BoxMatrix[All,n]],#==1&amp;,2],Throw[n]],{n,Min@Dimensions@#,1,-1}]]^2&amp;
</code></pre>
<p><a href="https://tio.run/##FcyxCoMwEIDhhyk4XcEIjkJs7eAgSHE7Uggaa8Bc4EypIj57Wtcfvt/pMBmng@11HIt416GfsPJYj1jS1vHH4IP9Yj1hyay3Vg94AaHg5tdGB7YrlvMMpBRcikIkkCnoJvZfPNNO0FiSlXWGzsci/xau4lDqlSWxZUtBjvKpafCupmDehlHAnqeQp4eKPw" rel="nofollow noreferrer" title="Wolfram Language (Mathematica) – Try It Online">Try it online!</a></p>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a>, 20 bytes</h1>
<pre><code>ɖλZɖλ÷nfṪg›*&quot;;vt;fG²
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/#WyIiLCIiLCLJls67WsmWzrvDt25m4bmqZ+KAuipcIjt2dDtmR8KyIiwiIiwiW1sxLDAsMSwxLDFdLFsxLDAsMSwxLDFdLFsxLDEsMSwxLDFdLFsxLDAsMCwxLDBdXSJd" rel="nofollow noreferrer">Try it Online!</a></p>
<p>Based on <a href="https://codegolf.stackexchange.com/a/257862/116074"><em>@Jonah's</em> J answer</a>.</p>
<p>For each 2x2 square</p>
<pre><code>a b
c d
</code></pre>
<p>it replaces <code>d</code> with <code>d*(min(a,b,c)+1)</code> in sequence going from left to right, top to bottom. Then it takes maximum and squares it.</p>
<pre><code>ɖλ                   # scan by:
  Z                  #   zip
   ɖλ                #   scan by:  receives [a,c], [b,d]
     ÷               #     push each to stack
      n              #     push the function argument [[a,c],[b,d]]
       f             #     flatten
        Ṫ            #     remove tail  [a,c,b]
         g           #     minimum
          ›          #     increment
           *         #     multiply
            &quot;        #     pair [b, new d]
             ;       #   end scan
              vt     #   get the tail of each
                ;    # end scan
                 f   # flatten
                  G  # maximum
                   ² # square
</code></pre>
</div>
<div id="pu5" class="pu"><h1>JavaScript, 186 bytes</h1>
<p>I know that the complexity should be <code>O(mn)</code> but here the complexity is <code>O((mn)^2)</code> :)</p>
<pre><code>m=&gt;eval('for(x=b=0;x&lt;(r=m.length);++x)for(y=0;y&lt;(c=m[0].length);++y)if(m[x][y]){for(o=s=1;o&amp;&amp;s&lt;(c&gt;r?r:c);++s)for(t=s+1;t--;)if(!m[x+s]?.[y+t]||!m[x+t][y+s]){o=0;--s;break}b=s&gt;b?s:b}b*b')
</code></pre>
<p>Try it:</p>
<p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>f=m=&gt;eval('for(x=b=0;x&lt;(r=m.length);++x)for(y=0;y&lt;(c=m[0].length);++y)if(m[x][y]){for(o=s=1;o&amp;&amp;s&lt;(c&gt;r?r:c);++s)for(t=s+1;t--;)if(!m[x+s]?.[y+t]||!m[x+t][y+s]){o=0;--s;break}b=s&gt;b?s:b}b*b')

;[
    [
        [1, 0, 1, 1, 1],
        [1, 0, 1, 1, 1],
        [1, 1, 1, 1, 1],
        [1, 0, 0, 1, 0],
    ],
    [
        [1, 0, 1, 0, 1],
        [1, 0, 1, 1, 1],
        [1, 1, 1, 1, 1],
        [1, 0, 0, 1, 0],
    ],
    [
        [1, 0, 1, 1, 1],
        [1, 0, 1, 0, 1],
        [1, 1, 1, 1, 1],
        [1, 0, 0, 1, 0],
    ],
    [
        [1]
    ],
    [
        [0]
    ]
].map(m =&gt; console.log(f(m)))</code></pre>
</div>
</div>
</p>
<h1>JavaScript, 200 bytes</h1>
<p>Here the complexity is much less than <code>O((mn)^2)</code> because if the algorithm find the biggest possible square it will stop</p>
<pre><code>m=&gt;eval('a=(c=m[0].length)&gt;(r=m.length)?r:c;for(x=b=0;b!=a&amp;&amp;x&lt;r;++x)for(y=0;b!=a&amp;&amp;y&lt;c;++y)if(m[x][y]){for(o=s=1;o&amp;&amp;s&lt;a;++s)for(t=s+1;t--;)if(!m[x+s]?.[y+t]||!m[x+t][y+s]){o=0;--s;break}b=s&gt;b?s:b}b*b')
</code></pre>
<p>Try it:</p>
<p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>f=m=&gt;eval('a=(c=m[0].length)&gt;(r=m.length)?r:c;for(x=b=0;b!=a&amp;&amp;x&lt;r;++x)for(y=0;b!=a&amp;&amp;y&lt;c;++y)if(m[x][y]){for(o=s=1;o&amp;&amp;s&lt;a;++s)for(t=s+1;t--;)if(!m[x+s]?.[y+t]||!m[x+t][y+s]){o=0;--s;break}b=s&gt;b?s:b}b*b')

;[
    [
        [1, 0, 1, 1, 1],
        [1, 0, 1, 1, 1],
        [1, 1, 1, 1, 1],
        [1, 0, 0, 1, 0],
    ],
    [
        [1, 0, 1, 0, 1],
        [1, 0, 1, 1, 1],
        [1, 1, 1, 1, 1],
        [1, 0, 0, 1, 0],
    ],
    [
        [1, 0, 1, 1, 1],
        [1, 0, 1, 0, 1],
        [1, 1, 1, 1, 1],
        [1, 0, 0, 1, 0],
    ],
    [
        [1]
    ],
    [
        [0]
    ]
].map(m =&gt; console.log(f(m)))</code></pre>
</div>
</div>
</p>
<h2>Explanation</h2>
<p>I will not explain each line of code because it is a lot and boring</p>
<p>Here is illustration of algorithm:</p>
<p><a href="https://i.sstatic.net/dxOFQ.png" rel="nofollow noreferrer"><img src="https://i.sstatic.net/dxOFQ.png" alt="enter image description here" /></a></p>
<p>When I meet the 1 in matrix (blue) I start checking the right and bottom edges of this cell (red cells) if all red cells are 1 then I start check the right and bottom edges of red cells (green cells) and so on until where I won't meet 0 or meet the matrix edge</p>
</div>
<div id="pu6" class="pu"><h1><a href="http://jsoftware.com/" rel="nofollow noreferrer">J</a>, <sup><strike>78 76</strike></sup> 75 bytes</h1>
<pre><code>[:&gt;./@,@;($&lt;@,:&amp;2@#:i.@#@,)({:*1+&lt;./@}:)@,;.0`(0&lt;@{1+[)`]}&amp;.&gt;/@,&amp;|.0&lt;@,0&amp;,.
</code></pre>
<p><a href="https://tio.run/##dY3BCoJAEIbv@xSjxq6b27TrIXA0GQg6deoqkhBJdekBzGff1k5FyTDMz/fzMXdfROTaTUSFUiJG1cOWQIEBCxR2hbA7Hva@oRrXbLhMFxUbkjkndENO2Oh0oKXLqlCPpNmUaLvUVjy4rNFdO0qsgyifGJix0qDX4nK@PqCHGEs85dBOv6xw4bhpvpL7YBO1YlZ3f6TfNK8L@66FfwE" rel="nofollow noreferrer" title="J – Try It Online">Try it online!</a></p>
<p><span class="math-container">\$\mathcal{O}(mn)\$</span> using a standard dynamic programming table.</p>
<p>The only challenge was how to translate this essentially procedural algorithm into an array paradigm:</p>
<ul>
<li><p>First add a top-left border of zeros:</p>
<pre><code> 0 0 0 0 0 0
 0 1 0 1 1 1
 0 1 0 1 1 1
 0 1 1 1 1 1
 0 1 0 0 1 0
</code></pre>
</li>
<li><p>Next generate the coordinates for what would be the nested loop in a procedural language -- that is, we traverse from left to right, top to bottom.   We also add <code>2 2</code> to each, since we'll be cutting out 2x2 squares later.  For example, the first element represents the 2x2 square whose top-left coordinate is <code>0 0</code>:</p>
<pre><code>┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
│0 0│0 1│0 2│0 3│0 4│1 0│1 1│1 2│1 3│1 4│2 0│2 1│2 2│2 3│2 4│3 0│3 1│3 2│3 3│3 4│
│2 2│2 2│2 2│2 2│2 2│2 2│2 2│2 2│2 2│2 2│2 2│2 2│2 2│2 2│2 2│2 2│2 2│2 2│2 2│2 2│
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘
</code></pre>
</li>
<li><p>Now we reverse the above list and use it in a single reduction of the input from the previous step.  In each step of the reduction, we slice out a two by two square.  For example in the first step of the reduction we take the top-left square:</p>
<pre><code>0 0
0 1
</code></pre>
</li>
<li><p>The reduction logic is simple.  Call the value of the lower-right cell <code>lr</code>.  We update <code>lr</code> as follows: <code>lr * (1 + min(all values except lr))</code>.</p>
</li>
<li><p>Return the max value of the completed dynamic programming table.</p>
</li>
</ul>
</div>
<div id="pu7" class="pu"><h1>Excel, 142 bytes</h1>
<pre><code>=LET(b,SEQUENCE(ROWS(a)),c,TRANSPOSE(b),MAX(MMULT(N(COUNTIF(OFFSET(INDIRECT(TOCOL(CELL(&quot;address&quot;,OFFSET(a,b-1,c-1)))),,,c,c),&quot;&lt;&gt;1&quot;)=0),b^0))^2)
</code></pre>
<p>Input <em><strong>a</strong></em> is a <em>worksheet range</em> comprising the matrix. The above should preferably be placed in a worksheet different to that containing the matrix so as to avoid potential circular references.</p>
<p>Complexity is unfortunately <span class="math-container">\$\mathcal{O}(m^3)\$</span>.</p>
</div>
<div id="pu8" class="pu"><h1><a href="https://www.python.org" rel="noreferrer">Python</a> NumPy, 148 bytes</h1>
<pre class="lang-python prettyprint-override"><code>lambda X,o=1:[B:=c(c(pad(X,1),0),1),[o:=o+(B[i,j]+B[i-o,j-o]-B[i,j-o]-B[i-o,j]==o*o)for i,j in argwhere(X)+1]]and~-o*~-o
from numpy import*
c=cumsum
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=LU9BboMwELzzCh_XsKBQtVWE5AN5AickalUuYEIUey0HlOTSV_TWC1LV_qm_qWly2N3RjEYz-_njrtOe7PKlxcv3POl0-_txVOatU6xGEnnR7ArRQgtOdVBjznHD191QISiBXTPiQSbhpISHlGT6z9zBykkhKCauybMgsNEy5Yfzvvc91DzJpVS2e08pDhNpT4bZ2bgrG40jP8VRK9rZnGZz76a9HZhgPpjIZF2v1XycXgMJPKpWwQ7ZaKd-6P0JNviA8ISP-Mx5tBYo1_i4wioz6gLhkQBGG0ARMeeDD0rUUHJ-S1uW2_0D" rel="noreferrer">Attempt This Online!</a></p>
<p>Should be linear in the size N (total number of elements) of the input.</p>
<h3>How?</h3>
<p>Computes first the 2d partial sums B of the input. After this one off O(N) (space and time) investment we can count the number of ones in any grid rectangle in constant time using the four corners of the rectangle: B(top left)+B(bottom right)-B(top right)-B(bottom left).</p>
<p>We can now find the maximum in linear time by traversing the input a single time top left to bottom right. We only check for squares that have their bottom right corner at the current position. If the current point is bottom right of a new maximum square we know that the current maximum must be one less because we have already visited the top left neighbour of the current point. Therefore we need at each point only check a single square, the loop body is constant time and the loop is linear.</p>
</div>
<div id="pu9" class="pu"><h1>MATL, <s>21</s> 19 bytes</h1>
<pre><code>lYa`9I&amp;ZItz}x@UGaa*
</code></pre>
<p><em>2 bytes saved thanks to @lmendo</em></p>
<p>The complexity of the erosion operation is O(mn), but unfortunately with this approach, we perform erosion as many as max(m, n) times.</p>
<p>Try it at <a href="https://matl.io/?code=lYa%609I%26ZItz%7Dx%40UGaa%2a&amp;inputs=%5B1+0+1+1+1%3B1+0+1+1+1%3B1+1+1+1+1%3B1+0+0+1+0%5D&amp;version=22.7.4" rel="nofollow noreferrer">MATL Online</a></p>
<p><strong>Explanation</strong></p>
<pre><code>        % Implicitly grab input as a multi-dimensional array
lYa     % Pad with a row of zeros on the top and bottom to ensure erosion works
`       % do...while loop
  9I&amp;ZI % Perform image erosion with a 3 x 3 neighborhood
  t     % Duplicate the output
  z     % Check if there are any 1's left in the eroded result, if so, repeat
}       % End loop
x       % Delete the last element on the stack (the eroded matrix of all 0's)
@       % Get the index of the last loop iteration and
U       % Square it to get the size of the largest contiguous square of 1's
Gaa     % Check if there are any 1's in the input
*       % Multiply with the result (to account for a matrix of all 0's)
        % Implicitly display the result
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/257819/">257819</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




