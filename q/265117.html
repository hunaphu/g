<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::265117</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>096</td><td>JavaScript Node.js</td><td>230926T010503Z</td><td><a href="https://codegolf.stackexchange.com/questions/265117/how-many-ways-to-cut-a-number-into-an-equation/265491#265491">l4m2</a></td></tr>
<tr d-ix="1"><td>169</td><td>GNU sed E</td><td>230911T172203Z</td><td><a href="https://codegolf.stackexchange.com/questions/265117/how-many-ways-to-cut-a-number-into-an-equation/265128#265128">Philippo</a></td></tr>
<tr d-ix="2"><td>028</td><td>Vyxal</td><td>230912T041804Z</td><td><a href="https://codegolf.stackexchange.com/questions/265117/how-many-ways-to-cut-a-number-into-an-equation/265143#265143">emanresu</a></td></tr>
<tr d-ix="3"><td>031</td><td>Jelly</td><td>230911T184123Z</td><td><a href="https://codegolf.stackexchange.com/questions/265117/how-many-ways-to-cut-a-number-into-an-equation/265130#265130">Jonathan</a></td></tr>
<tr d-ix="4"><td>113</td><td>Ruby</td><td>230911T194208Z</td><td><a href="https://codegolf.stackexchange.com/questions/265117/how-many-ways-to-cut-a-number-into-an-equation/265131#265131">Value In</a></td></tr>
<tr d-ix="5"><td>255</td><td>Python</td><td>230911T170855Z</td><td><a href="https://codegolf.stackexchange.com/questions/265117/how-many-ways-to-cut-a-number-into-an-equation/265127#265127">corvus_1</a></td></tr>
<tr d-ix="6"><td>033</td><td>05AB1E</td><td>230912T093519Z</td><td><a href="https://codegolf.stackexchange.com/questions/265117/how-many-ways-to-cut-a-number-into-an-equation/265154#265154">Kevin Cr</a></td></tr>
<tr d-ix="7"><td>107</td><td>JavaScript ES6</td><td>230911T173117Z</td><td><a href="https://codegolf.stackexchange.com/questions/265117/how-many-ways-to-cut-a-number-into-an-equation/265129#265129">Arnauld</a></td></tr>
<tr d-ix="8"><td>178</td><td>Python</td><td>230911T152440Z</td><td><a href="https://codegolf.stackexchange.com/questions/265117/how-many-ways-to-cut-a-number-into-an-equation/265122#265122">bsoelch</a></td></tr>
<tr d-ix="9"><td>061</td><td>Charcoal</td><td>230911T203820Z</td><td><a href="https://codegolf.stackexchange.com/questions/265117/how-many-ways-to-cut-a-number-into-an-equation/265133#265133">Neil</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 96 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>f=([c,...a],s='',g=t=&gt;f(a,s+t))=&gt;/\b0\d/.test(s+=c)?0:a+a?g`+`+g`-`+g`*`+g``+g`===`:eval(s)===!0
</code></pre>
<p><a href="https://tio.run/##fc5tC4IwEAfw930K25u2ZnObiSWcfpAMXD5RSEYbfn3TEBOtDu44@HHc/6YapdPn9WF29zrL27YAfEptxpg62xo2G7sEA2GBla2pIQRCJ77wOHOYybXBmkJKIh4oqqIyoQktk10/tv3oGwCSIG9UhTXp9jVv0/qu6ypnVV3iAiMfWX0RYjmOxVcz3Uv0R31/omKuggs0qrtQOdEvt@/jQeWCu/rwMpcn5Mje8rO799AvPXIpDhwNqf32BQ" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<p>Unlike Arnauld who tests if exactly one <code>==</code> exist, I use <code>===</code>:</p>
<pre class="lang-javascript prettyprint-override"><code>1             =&gt; 1
1===1         =&gt; true
1===1===1     =&gt; false
1===1===1===1 =&gt; false
</code></pre>
<p>so if it results in <code>true</code> it's an equation</p>
</div>
<div id="pu1" class="pu"><h1>GNU <code>sed -E</code>, <s> 214 200 181 171 </s> 169 bytes</h1>
<p>For some not-so-obvious reason, I decided to solve this by myself in <code>sed</code>, misusing the shell for expression evaluation with the <code>e</code> flag of the GNU version of the tool:</p>
<pre><code>G:1;s/(\S*[0-9])([0-9]\S*\n)/\1_\2\1==\2\1+\2\1-\2\1*\2/;t1;s/_//g;:2;s/(\n|^)[^=]+\n/\n/;s/\S*=\S+=\S*//;t2;s/\S*/+$((&amp;))/g;s/\S*[ =*+-]0[0-9]\S*//g;s/.*/echo $((&amp;))/e
</code></pre>
<p><strong><a href="https://tio.run/##NU27DsIwDPyVDgjloeAmWxtlRHxAx7jtAFVhSSqlbHw7wQkg2Wfd2XdOy02t4ZnzxfbaJmA4CN@qbuSsDqIYOKCe0aB2rqAsoAoINGD34psBVtubmhBeE/eTGyUGoCKNUhwOkloAGcxXAnlg7Mg5OSv3jRNSje3/MdTFScByvcfmd7vk3L3jtj9iSFmdPw" rel="nofollow noreferrer" title="sed – Try It Online">Try it online!</a></strong></p>
<ul>
<li><code>G</code> appends the (empty) hold space, so it adds a newline to the end, which is used as a separator</li>
<li><code>:1;s/(\S*[0-9])([0-9]\S*\n)/\1_\2\1==\2\1+\2\1-\2\1*\2/;t1</code> loops to add operators or <code>==</code> between each pair of digits, marking already considered pairs by <code>_</code></li>
<li><code>s/_//g</code> removes the <code>_</code> markers</li>
<li><code>:2;s/(\n|^)[^=]+\n/\n/;s/\S*=\S+=\S*//;t2</code> removes items without <code>==</code> or with more than one <code>==</code></li>
<li><code>s/\S*/+$((&amp;))/g</code> turns each equation in to an arithmetic expansion <code>$(())</code></li>
<li><code>s/\S*[ =*+-]0[0-9]\S*//g</code> is needed to remove all equations including a leading zero</li>
<li><code>s/.*/echo $((&amp;))/e</code> finally evaluates the whole rubbish</li>
</ul>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a>, 28 bytes</h1>
<pre><code>øṖ'⌊=A;ƛṄfð`+*-,`VΠEƛk-İ⁼]f∑
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m720rLIiMWdptJKjUuyCpaUlaboWN3UO73i4c5r6o54uW0frY7Mf7mxJO7whQVtLVych7NwC12Ozs3WPbHjUuCc27VHHxCXFScnFMJ360UrqCeamhkYJ6ko6QKahgaEhjGkIZ1oaGBlaGAA5MBsB" rel="nofollow noreferrer">Attempt This Online!</a> Semi-port of <a href="https://codegolf.stackexchange.com/a/265130/100664">Jonathan Allan's Jelly answer</a>, but much clunkier. The <code>A</code> flag runs testcases.</p>
<pre><code>øṖ                           # Partitions
  '   ;                      # Where 
     A                       # All substrings
    =                        # Are equivalent under
   ⌊                         # Cast to integer
       ƛ                 ]   # For each partition
                  Π          # Cartesian product of
        Ṅf                   # Join with spaces and flattening
          ð`+*-,`V           # Then replacing spaces with &quot;+*-,&quot;
                  Π          # Resulting in all combinations of the operators and strings
                   E         # Evaluate as Python
                    ƛ    ]   # Map each to
                        ⁼    # Whether it remains the same under
                     k-İ     # [x[-1], x[1]] - ensures it is a 2-item list with both items the same
                          f∑ # Flatten and count truthy values
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, <s> 35 34 32 </s> 31 bytes</h1>
<p>-3 thanks to <a href="https://codegolf.stackexchange.com/users/85334/unrelated-string">Unrelated String</a>! (Filtering leading zero decimals with <code>ḌVÐṀ</code> rather than the somewhat clunky <code>ḌD$ƑƇḌ</code>. Also <code>Ṛṁ2ƊƑ</code> -&gt; <code>.ị$Ƒ</code>)</p>
<pre><code>DŒṖḌVÐṀżFŒV.ị$ƑʋⱮL’“*+,-”ṗƲ$€FS
</code></pre>
<p>A monadic Link that accepts a positive integer and yields the count.</p>
<p><strong><a href="https://tio.run/##y0rNyan8/9/l6KSHO6c93NETdnjCw50NR/e4HZ0Upvdwd7fKsYmnuh9tXOfzqGHmo4Y5Wto6uo8a5j7cOf3YJpVHTWvcgv/rHG7XdP//P9pcR8HESEfBHEgbGhgCCSMQYQBmAgFQxtTQCCRsbGKqo2BpYGRoYRALAA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></strong></p>
<h3>How?</h3>
<pre><code>DŒṖḌVÐṀżFŒV.ị$ƑʋⱮL’“*+,-”ṗƲ$€FS - Link: positive integer, N
D                               - get a list of N's digits
 ŒṖ                             - all partitions of that list
   Ḍ                            - convert each part of each from base ten
                                  : e.g. [0,7,2] -&gt; 72
     ÐṀ                         - keep those maximal under:
    V                           -   evaluate as Jelly code (e.g. [4,72,1]-&gt; 4721)
                                  : i.e. those that had no leading zero digit
                            €   - for each DecimalisedPartition:
                           $    -   last two links as a monad:
                          Ʋ     -     last four links as a monad:
                 L              -       length
                  ’             -       decrement
                   “*+,-”       -       &quot;*+,-&quot;
                         ṗ      -       Cartesian power
                Ɱ               -     map across these operator lists with:
               ʋ                -       last four links as a dyad:
       ż                        -         {DecimalisedPartition} zip {Operators}
        F                       -         flatten
         ŒV                     -         evaluate as Python code
              Ƒ                 -         is {X=that} invariant under?:
             $                  -           last two links as a monad:
           .                    -             0.5
            ị                   -             index into {X} -&gt; [last(X), first(X)]
                                          : i.e. is exactly two equal values?
                             F  - flatten
                              S - sum
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, <s>117</s> 113 bytes</h1>
<p>Takes a string as input. Creates every possible combination of operators and counts which ones have no leading zeroes and <code>eval</code> to <code>true</code>.</p>
<p>This is probably the only time in Ruby golfing when <code>do</code>/<code>end</code> will ever be cheaper than the curly brace syntax, since that allows <code>rescue SyntaxError</code> without adding a <code>begin</code> block like it normally would require. (Inline <code>rescue</code> doesn't catch SyntaxError so the longer syntax is needed.)</p>
<p>-4 from Dingus.</p>
<pre class="lang-ruby prettyprint-override"><code>-&gt;s{[p].product(*[%W&quot;#{} == + - *&quot;]*s.size).count do
!p==eval(e=_1.zip(s.chars)*'')&amp;&amp;/0\d/!~e
rescue$!.class;end}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=LY1daoNAFIXf7yquP03U4GTGJJhSptvogxEx45gINk4dp6URu5G-BNouKrvplPTAgY8DH-fzuzf798tXzXc_Zqjj7fUlftRjpnKi-q4yYgii7O7J9cYJOccFxhi5eaSJbs4yJKIzpwGrDhzFuXwt20DygpFzowJNxLHsdRjN5-FstqS7aul8SOilFkb6DhFtqfWDPFXT__Hq7di0Eg9y0IB-YfXuWTmAygwa3Trz_CJHjt5YZ5YmF6x7Uy_XRQrrBNIUGGXAElv6BzaQblhip9V6A_c0YVt6c34B" rel="nofollow noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu5" class="pu"><h1><a href="https://www.python.org" rel="nofollow noreferrer">Python</a>, 255 bytes</h1>
<pre class="lang-python prettyprint-override"><code>lambda s:len({q for r in range(len(s)+1)for o in combinations(&quot;+-*&quot;*len(s),r)for p in permutations([*s,&quot;==&quot;,*o])if match(f&quot;{n}=={n}$&quot;,q:=&quot;&quot;.join(p))and s==sub(&quot;\D&quot;,&quot;&quot;,q)and eval(q)})
m=&quot;(0|[1-9]\d*)&quot;
n=f&quot;{m}(\D{m})*&quot;
from itertools import*
from re import*
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=TdBBTgMhFIDh_Zzi5dUFUGo6aqM2YddbdLpgLFjMAFNgNKb2JG6aGL2Tp9GZUmM3EL788BLev9rXtPHu8KFF9dklPbn7_mmkrdcS4rxRjuy2oH2AAMZBkO5RkUEjHZd0cD_4g7e1cTIZ7yLB8YQhyxEPx6gdolYF26VTtGSRoxDImV9Ro8HK9LAhGnduL0S_XCDfzgXi5ZM3jrSUSreGKETsaoLVAjn2wRHVs2zIlu5pYQWS6duynNyvqjWjWDjRP2j3pFr0K2VY6OAtmKRC8r6JYGzrQ2KZg_o7n77hpQ3GJTLloAneIqXFOdxc_UuZk7Pm-ijltBxolG2Wq1k53IQRJGNVBN8lDnWX-vmpCy7CLI8_HPL-Cw" rel="nofollow noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 33 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>.œʒïJQ}ε©…-+*„==ªsg&lt;ãε®s.ιJ]˜.EáO
</code></pre>
<p><a href="https://tio.run/##AT8AwP9vc2FiaWX//y7Fk8qSw69KUX3OtcKp4oCmLSsq4oCePT3CqnNnPMOjzrXCrnMuzrlKXcucLkXDoU///zEwMDE" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/V9Waa@k8KhtkoKSfaVLqNJ/vaOTT006vN4rIrD23NZDKx81LNPV1nrUMM/W9tCq4nSbw4uBouuK9c7t9Io9PUfP9fBC//9KemE6/6PNdUyMdMzNdQwNDHUMjYDYAMQAAh1zU0MjoJCxiamOpYGRoYVBLAA" rel="nofollow noreferrer">verify all test cases</a>.</p>
<p><strong>Explanation:</strong></p>

<p>Step 1: Get all partitions of the input-integer, and remove all partitions that contain parts with leading 0s:</p>
<pre class="lang-python prettyprint-override"><code>.œ         # Get all partitions of the (implicit) input-integer
  ʒ        # Filter the list of lists of parts by:
   ï       #  Cast each part to an integer, removing leading 0s
    J      #  Join all parts back together
     Q     #  Check whether it's equal to the (implicit) input-integer
  }        # Close the filter
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f9f7@jkU5MOr/cKrP3/39DAwBAA" rel="nofollow noreferrer">Try just step 1 online.</a></p>
<p>Step 2: Create all possible equations of each partition using <code>-</code>,<code>+</code>,<code>*</code>,<code>==</code> delimiters:</p>
<pre class="lang-python prettyprint-override"><code>ε          # Map over each remaining partition:
 ©         #  Store the current partition in variable `®` (without popping)
  …-+*     #  Push string &quot;-+*&quot;
      „==ª #  Convert it to a list of characters, and append &quot;==&quot;: [&quot;-&quot;,&quot;+&quot;,&quot;*&quot;,&quot;==&quot;]
  s        #  Swap so the partition is at the top again
   g       #  Pop and push its length
    &lt;      #  Decrease it by 1
     ã     #  Get the cartesian power of the [&quot;-&quot;,&quot;+&quot;,&quot;*&quot;,&quot;==&quot;] and this length-1
  ε        #  Inner map each list of operators by:
   ®       #   Push partition `®`
    s      #   Swap so the current list of operators is at the top
     .ι    #   Interleave the two lists
       J   #   And then join them together to a single string
]          # Close the nested maps
 ˜         # Flatten the list of list of equation-strings
</code></pre>
<p><a href="https://tio.run/##AToAxf9vc2FiaWX//y7Fk8qSw69KUX3OtcKp4oCmLSsq4oCePT3CqnNnPMOjzrXCrnMuzrlKXcuc//8xMDAx" rel="nofollow noreferrer">Try the first two steps online.</a></p>
<p>Step 3: Evaluate each equation-string as Elixir code: <code>.E</code>.<br />
<a href="https://tio.run/##ATwAw/9vc2FiaWX//y7Fk8qSw69KUX3OtcKp4oCmLSsq4oCePT3CqnNnPMOjzrXCrnMuzrlKXcucLkX//zEwMDE" rel="nofollow noreferrer">Try the first three steps online.</a></p>
<p>Step 4: Count the amount of <code>&quot;true&quot;</code> values, which under the hood are all <code>1</code> (05AB1E's truthy value), making it difficult to find a correct and short way of distinguishing <code>&quot;true&quot;</code> from actual <code>1</code>s. To give some examples of why this works so weird:</p>
<ol>
<li>Counting the amount of <code>&quot;true&quot;</code> in the list results in 0: <a href="https://tio.run/##AUQAu/9vc2FiaWX//y7Fk8qSw69KUX3OtcKp4oCmLSsq4oCePT3CqnNnPMOjzrXCrnMuzrlKXcucLkUidHJ1ZSLCov//MTAwMQ" rel="nofollow noreferrer">try it online</a>;</li>
<li>Trying to convert it to a flattened list of characters results in an error, since it cannot convert the <code>&quot;false&quot;</code> / <code>&quot;true&quot;</code> items: <a href="https://tio.run/##AT0Awv9vc2FiaWX//y7Fk8qSw69KUX3OtcKp4oCmLSsq4oCePT3CqnNnPMOjzrXCrnMuzrlKXcucLkVT//8xMDAx" rel="nofollow noreferrer">try it online</a>;</li>
<li>Filtering on 05AB1E-truthy values will keep both the <code>1</code> and <code>&quot;true&quot;</code>: <a href="https://tio.run/##AT8AwP9vc2FiaWX//y7Fk8qSw69KUX3OtcKp4oCmLSsq4oCePT3CqnNnPMOjzrXCrnMuzrlKXcucLkXKkn3//zEwMDE" rel="nofollow noreferrer">try it online</a> or <a href="https://tio.run/##AT8AwP9vc2FiaWX//y7Fk8qSw69KUX3OtcKp4oCmLSsq4oCePT3CqnNnPMOjzrXCrnMuzrlKXcucLkVEw4///zEwMDE" rel="nofollow noreferrer">try it online</a>;</li>
<li>Sorting (after the truthy filter) does work correct, although an additional group-by not: <a href="https://tio.run/##AUUAuv9vc2FiaWX//y7Fk8qSw69KUX3OtcKp4oCmLSsq4oCePT3CqnNnPMOjzrXCrnMuzrlKXcucLkXKkn17PQrOsyz//zEwMDE" rel="nofollow noreferrer">try it online</a>;</li>
<li>etc.</li>
</ol>
<p>Eventually I noticed the <code>þ</code> (keep all digits/numbers) and <code>á</code> (keep all letters/words) would correctly distinguish between the two, so I've used that to finish my program that utilizes Elixir-equations and evals:</p>
<pre class="lang-python prettyprint-override"><code>á          # Keep all letters/words (which will only keep all &quot;false&quot; and &quot;true&quot;)
 O         # Sum this list together, since they're 0 and 1 under the hood
           # (after which this count of &quot;true&quot; items is output implicitly as result)
</code></pre>
</div>
<div id="pu7" class="pu"><h1>JavaScript (ES6), 107 bytes</h1>
<p><em>-26 bytes (!) thanks to <a href="https://codegolf.stackexchange.com/users/44718/tsh">@tsh</a></em></p>

<pre class="lang-javascript prettyprint-override"><code>f=([c,...a],s,g=o=&gt;f(a,[s]+c+o))=&gt;c?g``+g`==`+g`+`+g`-`+g`*`:/^(?!.*\D0\d)[^=]*==[^=]*\d$/.test(s)&amp;&amp;eval(s)
</code></pre>
<p><a href="https://tio.run/##fc5tC4IwEAfw930KGxGb2txWYgWXb/oWPuCYDxTSoklf3zLCRKt78b@DH8fdWd6lUbfTtVlddF60bQk4Ui6lVCaucSvQcCixdCOTOMrRhMBBhVWWOVUG0KXTxaoLO9t7KQ7n1I6PLM5JlEJiA7xanC882hSmwYYsl8Vd1s@hVfpidF3QWle4xChAVleEWJ5nsdlINwL90SAYKB8rZxz1up6oGOiX3dfyW8WEn/Xh6V8@Fz3708vrjY9@6Y4JvmXo/XXQPgA" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<h3>How?</h3>
<p>We recursively build all possible expressions obtained by adding <code>&quot;&quot;</code>, <code>&quot;==&quot;</code>, <code>&quot;+&quot;</code>, <code>&quot;-&quot;</code> or <code>&quot;*&quot;</code> after each character.</p>
<p>For each expression, we test whether it matches:</p>
<pre class="lang-javascript prettyprint-override"><code>//         .--------------------&gt; no number may start with '0'
//         |      .-------------&gt; left part
//         |      |   .---------&gt; comparison operator
//         |      |   |  .------&gt; right part (except the last character)
//         |      |   |  |   .--&gt; we must end with a digit
//    _____|___  _|_  | _|_  |
//   /         \/   \/\/   \/\
   /^(?!.*\D0\d)[^=]*==[^=]*\d$/
</code></pre>
<p>If it does, we can safely <code>eval()</code>'uate it and increment the final result if it's truthy.</p>
</div>
<div id="pu8" class="pu"><h1><a href="https://www.python.org" rel="nofollow noreferrer">Python</a>, 178 bytes</h1>
<p><em>-2 bytes, thanks to corvus_192</em></p>
<pre class="lang-python prettyprint-override"><code>lambda s:len({*filter(eval,q(s,&quot;==&quot;))})
q=lambda s,c:[l+c+r for i in range(1,len(s))for l in e(s[:i])for r in e(s[i:])]
e=lambda s:[s]*(s==str(int(s)))+q(s,&quot;+&quot;)+q(s,&quot;-&quot;)+q(s,&quot;*&quot;)
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=XY5BDsIgFET3PQVhBW1NStVUSThJ7aIqKAmiApoY40ncNDF6AG_jbSxqTejf8Of9yTDXx-7k1lvd3ASb3Q9ODCavp6o382UNLFVco3MspHLcIH6sVbpHNoWMQYwvONqzzpkuaKmSRWKA2BoggdTA1HrFEUl9hsXYc-U5R7aksvoA0wFJK1xF_J9HS1vFyDJmnUFSO5-Ak8_nCfwtg26JIf41v-2MNwsEi7Zh9FejPJBFeCUZCXXe01nf0E4YOCZ5L2I4GgdkmuVkkrXoW7Vpvu8b" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p><em>Takes the string representation of the number as input</em></p>
<p>Generates all possible equations, uses <code>eval</code> to compare the results</p>
<p>The <code>*(s==str(int(s)))</code> part prevents leading zeros</p>
</div>
<div id="pu9" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 61 bytes</h1>
<pre><code>⊞υωＦ⮌θ≔ΣＥυ⁺ι⁺⎇∧κ∨⁼κ0∨⌕κ0⁻§κ¹ＩΣ§κ¹⟦+¦-¦*ω==⟧⟦ω⟧κυＩＬΦυ∧⁼²№ι=ＵＶι
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=VVCxTsMwEBUrH4EsTxdIpIQJqeoQoSIhUREBW5XBpG5j1TjU9iX0W1g6FME38TWc4yx4uJPfu3fv2Z8_TSts0wl9PH6h32Q3v2cXFboWMGVDMjvfdJbBk-yldRL2ScJK59TWwDO-wVK8h7FKowM19RdpjbAHKM0adil7tLDYo9AuXHjOkxG6U5GNwFIZEpb-3qzlR4ALAm-F86PJPzyelK34FSd5FsollYH6fM5rYoaa-F0cQ3pAZZXxMK57kGbrW3LXXtqQPISc4l2TZYc0qcIqHtTVwbedWfRCo_ASVDSfndxr46bP-l7xrNe8PhV5XkToDw" rel="nofollow noreferrer">Attempt This Online!</a> Link is to verbose version of code. Explanation:</p>
<pre><code>⊞υω
</code></pre>
<p>Start with an empty expression.</p>
<pre><code>Ｆ⮌θ
</code></pre>
<p>Loop over the digits in reverse order.</p>
<pre><code>≔ΣＥυ⁺ι⁺⎇∧κ∨⁼κ0∨⌕κ0⁻§κ¹ＩΣ§κ¹⟦+¦-¦*ω==⟧⟦ω⟧κυ
</code></pre>
<p>For each expression so far, prefix this digit, but if the expression is not empty, and it either does not being with <code>0</code> or the <code>0</code> is not part of a larger number, then also optionally insert an operator.</p>
<pre><code>ＩΣＥΦυ⁼²№ι=ＵＶι
</code></pre>
<p>For each expression that contains exactly one equality operator, evaluate that as python, and output the the number of expressions for which everything is true.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/265117/">265117</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




