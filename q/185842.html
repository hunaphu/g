<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::185842</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>159</td><td>APLNARS</td><td>240307T221416Z</td><td><a href="https://codegolf.stackexchange.com/questions/185842/output-first-n-digits-of-pi1-pi/271621#271621">Rosario</a></td></tr>
<tr d-ix="1"><td>114</td><td>APLNARS</td><td>240108T055302Z</td><td><a href="https://codegolf.stackexchange.com/questions/185842/output-first-n-digits-of-pi1-pi/269065#269065">Rosario</a></td></tr>
<tr d-ix="2"><td>022</td><td>Wolfram Language Mathematica</td><td>190605T221524Z</td><td><a href="https://codegolf.stackexchange.com/questions/185842/output-first-n-digits-of-pi1-pi/186440#186440">Roman</a></td></tr>
<tr d-ix="3"><td>149</td><td>Python</td><td>190530T173621Z</td><td><a href="https://codegolf.stackexchange.com/questions/185842/output-first-n-digits-of-pi1-pi/186241#186241">primo</a></td></tr>
<tr d-ix="4"><td>221</td><td>AXIOM</td><td>190607T151822Z</td><td><a href="https://codegolf.stackexchange.com/questions/185842/output-first-n-digits-of-pi1-pi/186510#186510">user5898</a></td></tr>
<tr d-ix="5"><td>062</td><td>Wolfram Language Mathematica</td><td>190520T100021Z</td><td><a href="https://codegolf.stackexchange.com/questions/185842/output-first-n-digits-of-pi1-pi/185848#185848">ZaMoC</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>APL(NARS), 159 chars</h1>
<pre><code>r←Q w;m;i;d;e;k;⎕FPC
⎕FPC←4×w⋄m←i←0v⋄e←÷10v*w
k←1+8×i⋄m+←d←(+/4 2 1 1÷k,-k+3..5)÷16*i⋄i+←1⋄→2×⍳e&lt;∣d⋄r←m*÷m

D←{k←{m←⍵⍕Q⍵⋄'123'∊⍨m[≢m]:⍵⋄∇⍵+1}⍵⋄⍵-←1⋄(⍵-k)↓k⍕Q k}
</code></pre>
<p>This would be the bullet proof solution...</p>
<p><code>Q w</code> function would calculate the number <code>π^(1/π)</code> enough for have <code>w</code> digits after point.</p>
<p><code>{m←⍵⍕Q⍵⋄'123'∊⍨m[≢m]:⍵⋄∇⍵+1}</code> <code>w</code> function would calculate the number <code>z≥w</code> in the way the last
printed digits in <code>z⍕Q z</code> is in the set '123'. If it is in that set than the string result in <code>z⍕Q z</code> has to be right the digits in position ..w..(z-1)</p>
<p><code>D w</code> function would cut in the right point <code>w-1</code> from the string <code>z⍕Q z</code></p>
<pre><code>  D 90
1.439619495847590688336490804973755678698296474456640982233160641890
  24343948917584781977504
  D 91
1.439619495847590688336490804973755678698296474456640982233160641890
  243439489175847819775046
  990↓D 1000
975282183643
</code></pre>
<p>In my opinion if <code>r</code> is the input and <code>P</code> it is as <code>⍕</code> but not use any round, <code>(r-1)P Q r</code>
return <strong>always</strong> the right result. If i make it wrong this is the <code>P</code> function, you show I'm wrong</p>
<pre><code>r←a P w;⎕ct;s;y;k;b
   ⎕ct←0⋄s←''⋄→B×⍳∼w&lt;0⋄s←'¯'⋄w←-w
B: y←⌊w×10x*a⋄b←''
C: b,←10∣y⋄→C×⍳0&lt;y←⌊y÷10⋄k←≢r←⎕D[1+⌽b]⋄→D×⍳∼a=0⋄r←s,r⋄→0
D: →F×⍳∼0≥y←k-a⋄r←s,'0.',('0'⍴⍨-y),r⋄→0
F: r←s,(y↑r),'.',y↓r
</code></pre>
<p>Now after some time of above post, I think there is no need of &quot;bullet proof solution&quot; only the function
print the number with no round mode. It is now more clear.</p>
</div>
<div id="pu1" class="pu"><h1>APL(NARS), 114 chars</h1>
<pre><code>r←Q w;m;i;d;e;k;⎕FPC
⎕FPC←4×w+←8⋄m←i←0v⋄e←÷10v*w
k←1+8×i⋄m+←d←(+/4 2 1 1÷k,-k+3..5)÷16*i⋄i+←1⋄→2×⍳e&lt;∣d⋄r←¯9↓w⍕m*÷m
</code></pre>
<p>If it is allowed to use one function that can return π my solution is</p>
<h1>APL(NARS), 27 chars</h1>
<pre><code>{⎕FPC←5×⍵+←8⋄¯9↓⍵⍕r*÷r←○1x}
</code></pre>
<p>Because function for show the number make the rounding, it is possible one error in the last
digits. But for happen that there would be the number 99999999 in the digits before where to cut</p>
<p>test</p>
<pre><code>  990↓Q 1000
975282183643
  Q 90
1.43961949584759068833649080497375567869829647445664098223316064189024343948917584781977504
  Q 91
1.439619495847590688336490804973755678698296474456640982233160641890243439489175847819775046
  ⎕FPC
128
</code></pre>
<p>note that ⎕FPC is not changed outside the function f.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.wolfram.com/wolframscript/" rel="nofollow noreferrer">Wolfram Language (Mathematica)</a>, <s>23</s> 22 bytes</h1>

<pre><code>(p=Log@-1/I)^p^-1~N~#&amp;
</code></pre>

<p><a href="https://tio.run/##y00syUjNTSzJTE78n6ZgqxDzX6PA1ic/3UHXUN9TM64gTtewzq9OWe1/QFFmXkl0SH5wCZCRHp0WbWhgEBsb@x8A" rel="nofollow noreferrer" title="Wolfram Language (Mathematica) – Try It Online">Try it online!</a></p>

<p><sup>-1 byte by @someone — the use and reuse of <code>p</code> beats the pure function</sup></p>

<p>Taking a lot of inspiration from @J42161217 and displaying n digits instead of an infinite stream.</p>

<p>Note that I'm using <code>ToString</code> in Tio to suppress the trailing precision specifier in the output, which does not appear when this code is executed in Mathematica.</p>

<p>Maybe using <code>180°</code> for pi would work; but maybe that's too close to being trigonometric and is disallowed.</p>
</div>
<div id="pu3" class="pu"><h1>Python, 149 bytes</h1>
<p><em>Saved one byte due to <a href="https://codegolf.stackexchange.com/questions/185842/output-first-n-digits-of-pi1-pi/186241?noredirect=1#comment446287_186241">@H.PWiz</a>.</em></p>

<pre class="lang-python prettyprint-override"><code>k=n=int(input())+1
i=j=8*n
e=l=p=z=10**n
while i:p=2*z-i//2*p//~i;i-=2
q=z-z*z//p
while j:l=q//j+q*l//z;j-=1
while k:e=z+e*l//k//p;k-=1
print(e//100)
</code></pre>
<p><a href="https://tio.run/##LY6xCsMwEEP3fEXHxMGcnS4lQZ9jyNnGPZeU0hv6624MWQTSk0DyPfZnubeWUMDlGLnI@xinafYDI@JhyhCQIVB4Z0732TmHG6@CxahlosUI0Y83tliGCrVqlEiuYlwzKlGcq8lEukULf6G0Bugcep7OwZY6kld/EYi8c1Nrp7o/" rel="noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
<p>Input <em>n = 1000</em> finishes in less than 0.5s.</p>
<p><span class="math-container">\$\sqrt[\pi]{\pi}\$</span> is calculated as the <span class="math-container">\$e^\frac{\ln(\pi)}{\pi}\$</span>.<span class="math-container">\$\pi\$</span> is calculated with the usual Euler-Leibniz: <span class="math-container">\$\pi=\sum_{n=0}\limits^{\infty}{\frac{n!}{(2n+1)!!}}\$</span>.</p>
<p><span class="math-container">\$e^x\$</span> and <span class="math-container">\$\ln(x)\$</span> are both computed using a Taylor series: <span class="math-container">\$e^x=\sum\limits_{n=0}^{\infty}{\frac{x^n}{n!}}\$</span> and <span class="math-container">\$\ln(1-x)=-\sum\limits_{n=1}^{\infty}{\frac{x^n}{n}}\$</span>. Because the iteration for <span class="math-container">\$\ln(x)\$</span> converges only when <span class="math-container">\$|x|&lt;1\$</span>, this is instead calculated as <span class="math-container">\$\ln(\pi)=-\ln(\frac{1}{\pi})\$</span>.</p>
<p>Given that Python uses <a href="https://en.wikipedia.org/wiki/Karatsuba_algorithm#Algorithm" rel="noreferrer">Karasuba Multiplication</a>, the overall runtime complexity is <span class="math-container">\$\mathcal{O}(n^{1+\log_2(3)})\$</span> - in other words, twice as many digits will take approximately 6 times as long.</p>
<hr />
<h3>Subquadratic Complexity</h3>
<pre class="lang-python prettyprint-override"><code>import sys
from gmpy2 import isqrt, mpz

def piks(a, b):
  if a == b:
    if a == 0:
      return (1, 1, 1123)
    p = a*(a*(32*a-48)+22)-3
    q = a*a*a*24893568
    t = 21460*a+1123
    return (p, -q, p*t)
  m = (a+b) &gt;&gt; 1
  p1, q1, t1 = piks(a, m)
  p2, q2, t2 = piks(m+1, b)
  return (p1*p2, q1*q2, q2*t1 + p1*t2)

n = int(sys.argv[1])-1
m = n*20//3
z = mpz(10)**n

# n / log(777924, 10)
pi_terms = mpz(n*0.16975227728583067)

pp, pq, pt = piks(0, pi_terms)
pq *= 3528

pi2m = (pq &lt;&lt; m) // pt

a, b = 2 &lt;&lt; m, 8
while a != b:
  a, b = (a + b) &gt;&gt; 1, isqrt(a*b)

mlog2_pi = (z &lt;&lt; m) // a

a, b = 2*pi2m, 8
while a != b:
  a, b = (a + b) &gt;&gt; 1, isqrt(a*b)
logpi_pi = z * pi2m // a - mlog2_pi

mlog2 = mlog2_pi * pq // pt

d = e = (15044673 &lt;&lt; m) // 10450451
pt //= z
while d:
  a, b = 2*e, 8
  while a != b:
    a, b = (a + b) &gt;&gt; 1, isqrt(a*b)
  lnx = (pq * e) // (pt * a) - mlog2
  d = e * (lnx - logpi_pi) // z
  e -= d

print(e * z &gt;&gt; m)
</code></pre>
<p><a href="https://tio.run/##nVLbjpswFHz3V0zVF@zAYhsIpNrsj1TViigkixqIIe4l/Hx6jgNK1JdK5SLhc8Yzc8a4q/8499nt1nbuPHpcrhdxGM8djp27WszV9jKMPkbnJiH2zQGu/X6J6hg7@UUA7QE1tlvsePFY6vsSGBv/Y@wRmRj8GJvJ0HHYolYRPZlVdZJXcmWtTLLQHEKTb5tXm6xYV6HsqWxNvtaqXjGTeBZwMZIhhlOeBTqCRvVqJ/H2BkMFR@oDvd5QZxmhY6iz1KHX26XTrQyPJ57IjQowo4aAVkSzIk7lrRSip41t7yPK76Uejz@/mm8yMYI99MrqNM3ERN@UYGS0VKoX4jN6pDidj1FZlhubUzRaCte@@2bsLjO4V/rFrDdlYW1Z2qqoMr0uSc/RrI5n9YtjTYt5L7EMUFtkha0I2toQBdVeX2lepCltE4LPj9MM1RiV@PXRnho6u0/zUc6AqKY55xTj@69AZ0bZiI7M23fXMmh6kNcPbsXi/8NNzDRNoJ6gEGZgaiRYVGd9DmrxQcBhGW9PjYYlTKHzfF1mD4NG51QrjKD00pQUZnv7J2dWNewb@Nv5v70Dp/73nLhCEyQjklKo5eKfQHeDChGjEywTB/hE/QbJFns6v5F/LEZOrNXJ2@1mNV1/AA" rel="noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
<p>Input <em>n = 20000</em> finishes in less than one second.</p>
<p><span class="math-container">\$\pi\$</span> can be computed in subquadratic time by use of Karatsuba splitting a.k.a. <a href="https://en.wikipedia.org/wiki/FEE_method" rel="noreferrer">Fast E-function Evaluation</a>, which reduces a summation to <em>n</em> terms to a single rational value <em>p/q</em>, splitting in binary descent. I've chosen to use <a href="https://books.google.com/books?id=oSioAM4wORMC&amp;pg=PA38&amp;hl=en&amp;redir_esc=y#v=onepage&amp;q&amp;f=false" rel="noreferrer">Ramanujan #39</a>, which is the fastest converging series of its kind that doesn't require an arbitrary precision square root, to my knowledge. Explicitly, this is computed as:</p>
<p><span class="math-container">\$\large{\left.{3528}\middle/{\sum\limits_{n=0}^{\infty}\frac{(-1)^n (4n)! (1123+21460n)}{(n!)^4 14112^{2n}}}\right.}\$</span></p>
<p>For <span class="math-container">\$\ln(x)\$</span> and <span class="math-container">\$e^x\$</span>, using the same technique wouldn't provide any benefit, because both are computed as a power series of an arbitrary precision variable. Fortunately, Gauss has gifted us with an elegant quadratically converging formula for <span class="math-container">\$\ln(x)\$</span>, based on the <a href="https://en.wikipedia.org/wiki/Arithmetic%E2%80%93geometric_mean" rel="noreferrer">Arithmetic-Geometric Mean</a>:</p>
<p><span class="math-container">\$\DeclareMathOperator{\AGM}{AGM}\large\ln(x)=\lim\limits_{n\rightarrow\infty}\frac{\pi x^n}{2n\AGM(x^n,4)}\$</span></p>
<p>or, in cases when large powers of <em>x</em> are inconvenient, this can also be computed as:</p>
<p><span class="math-container">\$\large\ln(x)\approx\frac{\pi x 2^m}{2\AGM(x 2^m,4)}-m\log(2)\$</span></p>
<p>Conveniently, division by <span class="math-container">\$\pi\$</span> can be acheived simply by not multiplying through by <span class="math-container">\$\pi\$</span>.</p>
<p>With the natural logarithm thusly defined, <span class="math-container">\$e^\frac{\ln(\pi)}{\pi}\$</span> can be computed via Newton's method on <span class="math-container">\$x_{n+1}=x_n-x_n(\ln(x_n)-\frac{\ln(\pi)}{\pi})\$</span>. The overall complexity is then <span class="math-container">\$\mathcal{O}(n^*\log^3(n))\$</span>, where <span class="math-container">\$n^*\$</span> will vary with the complexity of the multiplication algorithm GMP is using for any given bit length.</p>
</div>
<div id="pu4" class="pu"><h1>AXIOM, 221 bytes</h1>
<pre><code>m(k)==(v:=8.*k;(4/(v+1)-2/(v+4)-1/(v+5)-1/(v+6))*16^-k)
p(n:PI):String==(d:=digits(n+9);e:=10.^-digits();i:=s:=0;repeat(k:=m(i);k&lt;e=&gt;break;s:=s+k;i:=i+1);r:=concat split((s^(1/s))::String,char &quot; &quot;);digits(d);r.(1..(n+1)))
</code></pre>
<p>test and ungolf:</p>
<pre><code>(3) -&gt; p 1000
   (3)
  &quot;1.43961949584759068833649080497375567869829647445664098223316064189024343948
  91758478197750465984130420344294359334315186918367329519847221194330793016711
  10102682697604070399426193641233251599869541114696602206159806187886346672286
  57856367519525119750661263299495113759810214853630906903937015021965897319237
  10165099328745976281768843995002409093956556773589445623638530076425378312931
  87261467105359527145042168086291313192180728142873804095866545892671050160887
  16124784115980120121434100886405695749644308230493847450694342636218668197581
  84867550375317450302818249455173467218279517584627294354040035671684811472191
  01725582782513814164998627344159575816112484930170874421446660340640765307896
  24071974858079626467839175875265777541603392496832537982189139796664242012704
  72417497759453219873255463704766434211076771925114046204043479455332360344963
  38423479342775816430095564073314320146986193356277171415551195734877053835347
  93046480854891219035971014474191677302358635371602655346261468634197528218364
  3&quot;
                                                             Type: String
           Time: 0.03 (IN) + 0.53 (EV) + 0.25 (OT) + 0.15 (GC) = 0.97 sec


-- Bailey-Borwein-Plouffe formula for pi
-- https://en.m.wikipedia.org/wiki/Bailey%E2%80%93Borwein%E2%80%93Plouffe_formula   
--       +oo
--      -----          --                                      --
--      \          1   |     4         2         1         1    |
--   pi= |      -------|  ------- - ------- - ------- - ------- |
--      /            k |   8*k+1     8*k+4     8*k+5     8*k+6  |
--      ----- k   16   --                                      --
--        0
m(k)==(v:=8.*k;(4/(v+1)-2/(v+4)-1/(v+5)-1/(v+6))*16^-k)
p(n:PI):String==
      d:=digits(n+9); e:=10.^-digits(); i:=s:=0
      repeat
          k:=m(i)
          k&lt;e=&gt;break
          s:=s+k;i:=i+1
      r:=concat split((s^(1/s))::String,char &quot; &quot;)
      digits(d)
      r.(1..(n+1))
</code></pre>
<p>the function m calculate the term of the sum; the p() function loop, sum them in the variable s until the term is &lt; than min float value (one can see as epsilon);
p() function return one string of that number pi^(1/pi); it seems the required digits are returned in less than 1 second for input to p() function 1000.</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://www.wolfram.com/wolframscript/" rel="nofollow noreferrer">Wolfram Language (Mathematica)</a>, 62 bytes</h1>

<p>In my first try I used Zeta function but this one uses the imaginary part of ln(-1) for pi. (@someone)<br>
Prints more than 4000 digits in the first 10 seconds,    </p>

<pre><code>q=Im@Log@-1;Do[Print@RealDigits[N[q^(1/q),2k]][[1,k]],{k,∞}]
</code></pre>

<p><a href="https://tio.run/##y00syUjNTSzJTE78/7/Q1jPXwSc/3UHX0NolPzqgKDOvxCEoNTHHJTM9s6Q42i@6ME7DUL9QU8coOzY2OtpQB0jpVGfrPOqYVxv7//9/AA" rel="nofollow noreferrer" title="Wolfram Language (Mathematica) – Try It Online">Try it online!</a>     </p>

<p><em>9 bytes saved from @someone</em> </p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/185842/">185842</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




