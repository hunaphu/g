<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::3383</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>069</td><td>Vyxal j</td><td>250627T195452Z</td><td><a href="https://codegolf.stackexchange.com/questions/3383/wordsearch-solver/282436#282436">pacman25</a></td></tr>
<tr d-ix="1"><td>114</td><td>BQN</td><td>220128T164747Z</td><td><a href="https://codegolf.stackexchange.com/questions/3383/wordsearch-solver/241934#241934">ovs</a></td></tr>
<tr d-ix="2"><td>8783</td><td>05AB1E</td><td>220128T155403Z</td><td><a href="https://codegolf.stackexchange.com/questions/3383/wordsearch-solver/241931#241931">Kevin Cr</a></td></tr>
<tr d-ix="3"><td>166</td><td>Ruby 1.9</td><td>110810T203837Z</td><td><a href="https://codegolf.stackexchange.com/questions/3383/wordsearch-solver/3393#3393">Lowjacke</a></td></tr>
<tr d-ix="4"><td>649</td><td>Scala</td><td>110811T070344Z</td><td><a href="https://codegolf.stackexchange.com/questions/3383/wordsearch-solver/3396#3396">user unk</a></td></tr>
<tr d-ix="5"><td>342</td><td>JavaScript</td><td>110809T181701Z</td><td><a href="https://codegolf.stackexchange.com/questions/3383/wordsearch-solver/3384#3384">Briguy37</a></td></tr>
<tr d-ix="6"><td>230</td><td>Perl</td><td>110810T154400Z</td><td><a href="https://codegolf.stackexchange.com/questions/3383/wordsearch-solver/3390#3390">DCharnes</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal/tree/version-2" rel="nofollow noreferrer">Vyxal</a> <code>j</code>, <s>73</s>  69 bytes</h1>
<pre><code>¤€÷$:RJ£D₍Þ√Þ`ṅ∇∩&quot;Jvƛ¥ve:a[¨vƒrꜝfUsn$⁽ɽ¢|n]ƛaßð;ṅ;ɾ÷∩^Þ„‟Þ‟W∩4/ƛ∩vG;ṅ
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/?v=2&amp;c=1#WyJhaiIsIiIsIsKk4oKsw7ckOlJKwqNE4oKNw57iiJrDnmDhuYXiiIfiiKlcIkp2xpvCpXZlOmFbwqh2xpJy6pydZlVzbiTigb3JvcKifG5dxpthw5/DsDvhuYU7yb7Dt+KIqV7DnuKAnuKAn8Oe4oCfV+KIqTQvxpviiKl2RzvhuYUiLCIiLCJCQUNLU1BBQ0VcbkJPTERcbkNMT1NFXG5DT01QQUNURElTQ1xuQ09QWVxuQ1BVXG5DVVJTT1JcbkRFTEVURVxuREVTS1RPUFxuRFZEXG5FRElUXG5FTlRFUlxuRVhJVFxuRkxPUFBZXG5GT05UXG5IQVJEV0FSRVxuSU5URVJORVRcbktFWUJPQVJEXG5NT05JVE9SXG5NT1VTRVxuUEFTU1dPUkRcblBBU1RFXG5SRVRVUk5cblNBVkVcblNPRlRXQVJFXG5TVEFSVFxuVEVYVFxuVE9XRVJcbldPUkRQUk9DRVNTSU5HXG5cbklBVUVSQVdURk9TSUNQTlxuREdaUEZMT1BQWUFSRkxVXG5SU05PQ1VSU09SVlpEQk1cbkFNTklVT01STkhFR1VJTlxuT1RCTlNSTU9OSVRPUk5UXG5CRVlUVFNHUEpCT0xEUlRcbllSUUVBSEVIQVJEV0FSRVxuRU9HUlJORUNFQ0xPU0VQXG5LSU9OVFlLVE9EVE9XRVJcbkVMQ0VOU1VQRVJQREtOTlxuQVRSVFBSWUtFTFBWSUVKXG5HSUVBTlBPVEtTRURVU0xcbk5YQ01QQVNTV09SRFJVQ1xuVEVESVRBR1ZTV0pDVE9WXG5DV09ZUEdZUUtOTFZYTVciXQ==" rel="nofollow noreferrer">Try it Online!</a></p>
<p>this took me several hours and a lot of annoyances with regex but I did it
will explain later today</p>
<p>-4 from basic optimization</p>
<pre><code>¤€÷$:RJ£D₍Þ√Þ`ṅ∇∩&quot;Jvƛ¥ve:a[¨vƒrꜝfUsn$⁽ɽ¢|n]ƛaßð;ṅ;ɾ÷∩^Þ„‟Þ‟W∩4/ƛ∩vG;ṅ­⁡​‎‎⁪⁡⁪⁠⁪⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁪‏‏​⁡⁠⁡‌⁢​‎‎⁪⁡⁪⁠⁪⁢⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁪‏‏​⁡⁠⁡‌⁣​‎‎⁪⁡⁪⁠⁪⁣⁡⁪‏‏​⁡⁠⁡‌⁤​‎‎⁪⁡⁪⁠⁪⁣⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁣⁪‏‏​⁡⁠⁡‌⁢⁡​‎‎⁪⁡⁪⁠⁪⁢⁡⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁡⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁡⁢⁪‏‏​⁡⁠⁡‌⁢⁢​‎‎⁪⁡⁪⁠⁪⁢⁢⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁤⁪‏‏​⁡⁠⁡‌⁢⁣​‎‎⁪⁡⁪⁠⁪⁢⁣⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁣⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁣⁣⁪‏‏​⁡⁠⁡‌⁢⁤​‎‎⁪⁡⁪⁠⁪⁢⁣⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁣⁪‏⁠⁪⁪‏​⁡⁠⁡‌⁣⁡​‎‎⁪⁡⁪⁠⁪⁢⁤⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁡⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁡⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁡⁣⁪‏⁠⁪⁪‏​⁡⁠⁡‌⁣⁢​‎‎⁪⁡⁪⁠⁪⁣⁡⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁢⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁢⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁢⁤⁪‏⁠⁪⁪⁠⁪⁪‏​⁡⁠⁡‌⁣⁣​‎‏​⁢⁠⁡‌⁣⁤​‎‎⁪⁡⁪⁠⁪⁣⁣⁢⁪‏⁠⁪⁪‏​⁡⁠⁡‌⁤⁡​‎‎⁪⁡⁪⁠⁪⁣⁣⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁤⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁤⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁤⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁤⁤⁪‏‏​⁡⁠⁡‌⁤⁢​‎‎⁪⁡⁪⁠⁪⁤⁡⁣⁪‏⁠⁪⁪⁠⁪⁪‏​⁡⁠⁡‌⁤⁣​‎‎⁪⁡⁪⁠⁪⁤⁡⁤⁪‏‏​⁡⁠⁡‌⁤⁤​‎‎⁪⁡⁪⁠⁪⁤⁢⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁢⁢⁪‏‏​⁡⁠⁡‌⁢⁡⁡​‎‎⁪⁡⁪⁠⁪⁤⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁢⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁣⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁣⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁣⁣⁪‏‏​⁡⁠⁡‌⁢⁡⁢​‎‎⁪⁡⁪⁠⁪⁤⁣⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁤⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁤⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁤⁣⁪‏‏​⁡⁠⁡‌⁢⁡⁣​‎‏​⁢⁠⁡‌⁢⁡⁤​‎‎⁪⁡⁪⁠⁪⁤⁤⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁡⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁡⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁡⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁡⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁢⁡⁪‏‏​⁡⁠⁡‌­
¤€÷$                                                                   # ‎⁡parse input
    :RJ£                                                               # ‎⁢set register to the wordlist plus all words reversed
        D                                                              # ‎⁣push the grid 3x
         ₍Þ√Þ`ṅ∇∩&quot;J                                                    # ‎⁤list of diagonals, antidiagonals, rows and columns
                   vƛ                           ṅ;                     # ‎⁢⁡map over each slice and concat
                     ¥ve                                               # ‎⁢⁢first and last index for all regex matches for words
                        :a[             | ]                            # ‎⁢⁣if any has a match
                           ¨vƒr                                        # ‎⁢⁤convert those indices to a range
                               ꜝfUs                                    # ‎⁣⁡sort all unique values across all ranges
                                   n$⁽ɽ¢                               # ‎⁣⁢apply lowercase to items at those indices
# ‎⁣⁣This now has the words all lowercased in each slice of uppercase
                                         n                             # ‎⁣⁤otherwise just push the slice
                                           ƛaßð;                       # ‎⁤⁡convert any uppercase letters to spaces
                                                  ɾ                    # ‎⁤⁢uppercase everything
                                                   ÷                   # ‎⁤⁣push all the slice lists
                                                    ∩^                 # ‎⁤⁤transpose the first one to get columns, then reverse the stack
                                                      Þ„‟Þ‟            # ‎⁢⁡⁡list from diagonals and antidiagonals with a stack rotate in between
                                                           W∩4/        # ‎⁢⁡⁢wrap the stack, transpose it and split into four equal parts
# ‎⁢⁡⁣this gives each row in a solved grid for rows columns diags and antidiags
                                                               ƛ∩vG;ṅ  # ‎⁢⁡⁤get any uppercase letters in any row, spaces for the rest
💎
</code></pre>
<p>Created with the help of <a href="https://vyxal.github.io/Luminespire" rel="nofollow noreferrer">Luminespire</a>.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://mlochbaum.github.io/BQN/" rel="nofollow noreferrer">BQN</a>, <s>126</s> 114 bytes<sup><a href="https://github.com/mlochbaum/BQN/blob/master/commentary/sbcs.bqn" rel="nofollow noreferrer">SBCS</a></sup></h1>
<pre class="lang-none prettyprint-override"><code>{S←-++`×¬⋄{w𝕊g:g⊑∘↑˜¨¯2+∨´⥊w{H←⊒˜∊·⥊(↕≠𝕨)+⌜·/𝕨⊸⍷⋄(H˘∨1↓˘⊒˜⌽⁼˘·H˘⌾⍉⊒˜⌽˘' '⊸∾˘)⌾(⌽∘⍉⍟𝕩)g}⌜↕4}⟜&gt;´(S⟨⟩⊸≡¨)⊸⊔𝕩⊔˜S𝕩='
'}
</code></pre>
<p><a href="https://mlochbaum.github.io/BQN/try.html#code=RiDihpAge1PihpAtKytgw5fCrOKLhHt38J2Vimc6Z+KKkeKImOKGkcucwqjCrzIr4oiowrTipYp3e0jihpDiipLLnOKIisK34qWKKOKGleKJoPCdlagpK+KMnMK3L/Cdlajiirjijbfii4QoSMuY4oioMeKGk8uY4oqSy5zijL3igbzLmMK3SMuY4oy+4o2J4oqSy5zijL3LmCcgJ+KKuOKIvsuYKeKMvijijL3iiJjijYnijZ/wnZWpKWd94oyc4oaVNH3in5w+wrQoU+KfqOKfqeKKuOKJocKoKeKKuOKKlPCdlaniipTLnFPwnZWpPScKJ30KCkYgIkJBQ0tTUEFDRQpCT0xECkNMT1NFCkNPTVBBQ1RESVNDCkNPUFkKQ1BVCkNVUlNPUgpERUxFVEUKREVTS1RPUApEVkQKRURJVApFTlRFUgpFWElUCkZMT1BQWQpGT05UCkhBUkRXQVJFCklOVEVSTkVUCktFWUJPQVJECk1PTklUT1IKTU9VU0UKUEFTU1dPUkQKUEFTVEUKUkVUVVJOClNBVkUKU09GVFdBUkUKU1RBUlQKVEVYVApUT1dFUgpXT1JEUFJPQ0VTU0lORwoKSUFVRVJBV1RGT1NJQ1BOCkRHWlBGTE9QUFlBUkZMVQpSU05PQ1VSU09SVlpEQk0KQU1OSVVPTVJOSEVHVUlOCk9UQk5TUk1PTklUT1JOVApCRVlUVFNHUEpCT0xEUlQKWVJRRUFIRUhBUkRXQVJFCkVPR1JSTkVDRUNMT1NFUApLSU9OVFlLVE9EVE9XRVIKRUxDRU5TVVBFUlBES05OCkFUUlRQUllLRUxQVklFSgpHSUVBTlBPVEtTRURVU0wKTlhDTVBBU1NXT1JEUlVDClRFRElUQUdWU1dKQ1RPVgpDV09ZUEdZUUtOTFZYTVci" rel="nofollow noreferrer">Run online!</a></p>
<p>One third of the code is parsing the input, the more interesting parts are outlined below:</p>
<pre class="lang-none prettyprint-override"><code>{w𝕊g:g⊑∘↑˜¨¯2+∨´⥊w{H←⊒˜∊·⥊(↕≠𝕨)+⌜·/𝕨⊸⍷⋄(H˘∨1↓˘⊒˜⌽⁼˘·H˘⌾⍉⊒˜⌽˘' '⊸∾˘)⌾(⌽∘⍉⍟𝕩)g}⌜↕4}
</code></pre>
<p><a href="https://mlochbaum.github.io/BQN/try.html#code=RiDihpAge3fwnZWKZzpn4oqR4oiY4oaRy5zCqMKvMiviiKjCtOKlind7SOKGkOKKksuc4oiKwrfipYoo4oaV4omg8J2VqCkr4oycwrcv8J2VqOKKuOKNt+KLhChIy5jiiKgx4oaTy5jiipLLnOKMveKBvMuYwrdIy5jijL7ijYniipLLnOKMvcuYJyAn4oq44oi+y5gp4oy+KOKMveKImOKNieKNn/CdlakpZ33ijJzihpU0fQoKdzEg4oaQICJBREEi4oC/IkFMR09MIuKAvyJBU1NFTUJMWSLigL8iQkFTSUMi4oC/IkNPQk9MIuKAvyJERUxQSEki4oC/IkZPUlRSQU4i4oC/IkpBVkEi4oC/IkxBQlZJRVci4oC/IkxPR08i4oC/IlBBU0NBTCLigL8iUEVSTCLigL8iUEhQIuKAvyJQWVRIT04i4oC/IlNNQUxMVEFMSyLigL8iVklTVUFMQyIKZzEg4oaQIDEx4oC/MTHipYoiTExKS0NBQkxGQ0lPUk9MT0JPQ09JTUdFTEFDU0FQUlNYTFBTVEFIV1ZUQVZBTlJMWExYUVJCSUlIUExFRE9YQUhTS0pZQVBIUFlOT1VGQUJNQURBTlpKQUVWSVNOT0hUWVBMQUFZTEJNRVNTQUNXRUlWQkFMT0dPTSIKCncyIOKGkCAiQkFDS1NQQUNFIuKAvyJCT0xEIuKAvyJDTE9TRSLigL8iQ09NUEFDVERJU0Mi4oC/IkNPUFki4oC/IkNQVSLigL8iQ1VSU09SIuKAvyJERUxFVEUi4oC/IkRFU0tUT1Ai4oC/IkRWRCLigL8iRURJVCLigL8iRU5URVIi4oC/IkVYSVQi4oC/IkZMT1BQWSLigL8iRk9OVCLigL8iSEFSRFdBUkUi4oC/IklOVEVSTkVUIuKAvyJLRVlCT0FSRCLigL8iTU9OSVRPUiLigL8iTU9VU0Ui4oC/IlBBU1NXT1JEIuKAvyJQQVNURSLigL8iUkVUVVJOIuKAvyJTQVZFIuKAvyJTT0ZUV0FSRSLigL8iU1RBUlQi4oC/IlRFWFQi4oC/IlRPV0VSIuKAvyJXT1JEUFJPQ0VTU0lORyIKZzIg4oaQIDE14oC/MTXipYoiSUFVRVJBV1RGT1NJQ1BOREdaUEZMT1BQWUFSRkxVUlNOT0NVUlNPUlZaREJNQU1OSVVPTVJOSEVHVUlOT1RCTlNSTU9OSVRPUk5UQkVZVFRTR1BKQk9MRFJUWVJRRUFIRUhBUkRXQVJFRU9HUlJORUNFQ0xPU0VQS0lPTlRZS1RPRFRPV0VSRUxDRU5TVVBFUlBES05OQVRSVFBSWUtFTFBWSUVKR0lFQU5QT1RLU0VEVVNMTlhDTVBBU1NXT1JEUlVDVEVESVRBR1ZTV0pDVE9WQ1dPWVBHWVFLTkxWWE1XIgoKKHcxIEYgZzEp4ouIKHcyIEYgZzIpCgo=" rel="nofollow noreferrer">Run online!</a></p>
<pre><code>{w𝕊g:g⊑∘↑˜¨¯2+∨´⥊w{ ... }⌜↕4}
 w𝕊g:                          # A dyadic function taking:
                               #  - left argument w: word list
                               #  - right argument g: grid
                          ↕4   # 0 1 2 3
                  { ... }⌜     # For each of those numbers on the right (specifying rotation) and ...
                 w             # each word on the left, call the inner function.
                               # The inner function returns boolean matrices of the same shape of the input
              ∨´⥊              # Boolean OR of all the matrices
     g⊑∘↑˜¨¯2+                 # For 1's in the matrix take a character from the grid, for 0's take a space.
</code></pre>
<p>The inner function rotates the grid (as many times as its right argument specifies: <code>⌽∘⍉⍟𝕩</code>), checks for words from left to right and on diagonals and then rotates the result back.</p>
<p><strong>How to get get diagonals</strong>:</p>
<p>This method is mostly taken <a href="https://mlochbaum.github.io/bqncrate/?q=diagonals%20into%20columns#" rel="nofollow noreferrer">from BQNcrate</a>. First a space is prepended to each row. Then each row is rotated by its index. Now words previously in the diagonals are in the columns, by transposing we get them in the rows. After marking the words, all the steps can be reversed: <a href="https://mlochbaum.github.io/BQN/try.html#code=c3RlcHMg4oaQICIx4oaTy5gi4oC/IuKKksuc4oy94oG8y5gi4oC/IsK34o2JIuKAvyLCt0jLmCLigL8iwrfijYki4oC/IuKKksuc4oy9y5gi4oC/IicgJ+KIvsuYIuKAvyLiiqIiCgp0ZXN0IOKGkCA+4p+oCiJ8fHx8IgoiQXx8fCIKInxEfHwiCiJ8fEF8Igrin6kKCj57ZuKGkOKAokJRTiAiSOKGkOKKksuc4oiKwrfipYoo4oaV4omgIiJBREEiIikr4oycwrcvIiJBREEiIuKKuOKNt+KLhCLiiL7wnZWp4ouE8J2VqeKLiEYgdGVzdH3CqCAx4oaT4oy94oi+wqjihpNzdGVwcwo=" rel="nofollow noreferrer">Try with step-by-step results!</a></p>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 87 (or 83?) <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>||UεVX8FD»YåiY1:AuSð:1Y:}D€g©ËiεSÐ0:«NFÁ}}øíJ0δKõKë®à©FD®£€нJRsεN®‹i¦}}¦}\)]€Søε{θ}J®ä»
</code></pre>
<p>With the actual I/O as mentioned in the challenge description.</p>
<p><a href="https://tio.run/##PVBNixQxEL3XP/EwsHuTuaWT6p70R5JNJd2TRQ8riAyIe1g8qNugXr34EwQ/YFkdPDgwsnjpvjf@hv0jY82OekilqOK9eu@dX5w9Wj3e7S4v47Rpl/dzNdyk8fMqHc/Fcxq/z4/TvFe3b78@Ga7Gd6tpM76no/lwbfLxTU/9uB2/lUfTj2rcVOP1sB4/DFdMsR4@MuT3r9JfTBszrG9f/1wNX/qe34N7D3lF43bavJq2fcmYT8PNbpcJWZETEiGztQJZW0KQtuFRUJok9y6BdBFk9GQ9KKwxIH9UBetAtQpQ6QBoAnrAJbd5bR2DcmsCLIRXnfAIer83GKDClFmeQmONDszY2Mg3nSDqLI@5YX6PIXoDJFoEsnm446AgfICASy6243N7gPNWIpE2BYAWEb3oQm5JS2dAFafuoEb4vI7gydiDj/ZUZQ2IxuhoG28WWERtwIbMkP8rjNVnmEKgwpX7cPh08icoFvjfFNrCsymJd7k5qDR7ThyMOujDWqKh6NA7VRkDIvjgfKqwdq3GEgqNwjgbKkIVqQazlM2/IHyUbJWjFUVLXSmDbUF2NrkinVSmbpdNt5vNnp3Pnp69fPEH" rel="nofollow noreferrer">Try it online.</a> (For some reason, the <code>Á</code> is very slow on an inner list of characters instead of a string in this program, so <code>εSÐ0:«NFÁ}}</code> has been replaced with <code>εÐS0:«NFÁ}S}</code> (rotate first; then convert it to a list of characters) to speed things up substantially - it'll now output on TIO in roughly a second, instead of timing out without any output after 60 seconds.)</p>
<p>With less strict I/O (first words-input as a list, second grid-input as a list of lines; output-grid as a list of lines as well), this would be <strong>83 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></strong> instead:</p>
<pre><code>εVI8FD»YåiY1:AuSð:1Y:}D€g©ËiεSÐ0:«NFÁ}}øíJ0δKõKë®à©FD®£€нJRsεN®‹i¦}}¦}\)]€Søε{θ}J®ä
</code></pre>
<p><a href="https://tio.run/##TVFNb9QwEL3zM3JDYqX2Vu3NsSdZ58Pjepxk07KHIiG0EqKHigOgSMCVCz8BiQ@pKqw4sNJWiEt8j/gN/SOL7bYSh2TezHie3zyfX5w9WT/d76dtK48yMf7u3dd1fzhnL8n9nB/280HcvP/@bLx0H9bT1n2kg/l4pTL3bqDB7dyP4mD6Vbpt6a7Gjfs0XnqKzfjZj/z9U5iLaavGzc3b6/X4bRj89/jhyrfI7abtm2k3FH7my35/mqSMl6QZh@RRkmIlfOAVUkg51r5hhSQeM92HoJvwbwyh8UBABRYioNKiDqgNJCCkDUFZCOdgGdOsQh1pMlQhXzAjOmYCgQwnFYRqCX2KvuNhjUraeFONTVSlGVGHselhvNuAbYzygFgbcsLM3rGSZSZQWljGgF2UEwi0QQ5EUuXJ6sFpIlkDhnU2Q5JcBzaRn@hbwcxkVVjbkMLb1dsTkda@wmolG6yNWkDeyDCFNlVk7nTHJVPoraVcF8HfqKY3x8AW8N/2gLnx23OI5gcbS@kt6r2n4l40VBwUNRqMFqUKdzFrrDZ9CZVuJRS@kktgSqMtCURDla@oJa/vPTMNj174t2F5S13BLbbhOTvsdd4fl6pql3WXrPaz2Yvz2fOz16/@AQ" rel="nofollow noreferrer">Try it online</a> (with the same modification as above so it won't time out).</p>
<p><strong>Explanation:</strong></p>
<p>In pseudo-code, I do the following steps:</p>
<pre><code>Map over the list of words:
 Push the input-grid
 Loop 8 times:
  If the word is present horizontally left-to-right:
   Replace everything else with a space
  Rotate the grid 45 degrees counterclockwise
Reduce/combine all grids of spaces and words
</code></pre>
<p>As for the actual code, of which most (50 bytes) is used to rotate the grid 45 degrees:</p>

<pre class="lang-python prettyprint-override"><code>|                      # Get all inputs until an empty line is encountered,
                       # resulting in the list of words
 |                     # Do it again, resulting in the grid
  U                    # Pop and store the grid in variable `X`
 ε                     # Map over each of the words:
  V                    #  Pop and store the word in variable `Y`
  X                    #  Push grid `X`
   8F                  #  Loop 8 times:
     D»Yå              #   Check if the word is in the grid:
     D                 #    Duplicate the grid
      »                #    Join the lines with newline delimiter
       Yå              #    Check that this contains the word `Y`
         i             #   If this is truthy:
          Y1:          #    Replace the word temporarily with a 1
          AuSð:        #    Replace all uppercase letters with a space
          1Y:          #    Replace the 1 back to the word
         }             #   Close the if-statement
     D€g©ËiεSÐ0:«NFÁ}}øíJ0δKõKë®à©FD®£€нJRsεN®‹i¦}}¦}\)
                       #   Rotate the grid 45 degrees counterclockwise:
     D€g©Ë             #    Check if the grid is a rectangle:
     D                 #     Duplicate the grid
      €g               #     Get the length of each row
        ©              #     Save this list of lengths in variable `®` (without popping)
         Ë             #     Check whether these lengths are all equal
          i            #    If this is truthy:
           ε           #     Map over each row:
            S          #      Convert it to a list of characters
             Ð0:«      #      Append the row-length amount of 0s to the row
             Ð         #       Triplicate the row
              0:       #       Pop two, and replace all characters to 0s
                «      #       Merge this list of 0s to the row
             NF        #      Loop the 0-based map-index amount of times:
               Á       #       Rotate the row once towards the right
             }         #      Close the loop
           }           #     Close the map
            øí         #     Now rotate 90 degrees clockwise:
            ø          #      Zip/transpose; swapping rows/columns
             í         #      Reverse each row
              J        #     Join the inner list of characters back to a string
                δ      #     Map over each row:
               0 K     #      Remove all 0s from the row
                  õK   #     Remove any empty rows
          ë            #    Else (it's a diamond-shape instead):
           ®           #     Push the list of lengths
            à          #     Pop and push its maximum
             ©         #     Store this maximum as new variable `®` (without popping)
              F        #     Loop this maximum amount of times:
               D       #      Duplicate the list
                ®£     #      Only leave the first max amount of values
                  €н   #      Only leave the first character of each row
                    J  #      Join these characters together to a string
                     R #      Reverse it
               s       #      Swap so the list is at the top again
                ε      #      Map over each row:
                 N®‹i  #       If the map-index is smaller than max `®`:
                     ¦ #        Remove the first character
                    }  #       Close the if-statement
                }      #      Close the map
                 ¦     #      Remove the first (now empty) row
              }        #     Close the loop
               \       #     Discard the now empty list
                )      #     Wrap all rows on the stack into a list
 ]                     # Close the open if-statement; loop; and map
                       # (we now have a list space-grids, except for the found words)
  €S                   # Convert each inner grid to a flattened list of characters
    ø                  # Zip/transpose; swapping rows/columns
     ε                 # Map over each inner list:
      {                #  Sort; spaces at the front, potential letter(s) at the end
       θ               #  Pop and leave the last character
     }                 # Close the map
      J                # Join everything together to one huge string
       ®               # Push the last maximum `®`
        ä              # Split the string into that many equal-sized parts
         »             # Join the list of rows with newline delimiter
                       # (after which it is output implicitly as result)
</code></pre>
</div>
<div id="pu3" class="pu"><h2>Ruby 1.9, <strike>214</strike> <strike>210</strike> <strike>206</strike> <strike>182</strike> <strike>177</strike> <strike>173</strike> <strike>172</strike> 166</h2>

<pre><code>s,G=$&lt;.read.split$/*2
O=G.tr'^
',' '
(s+$/+s.reverse).split.map{|w|[0,l=G=~/$/,l+1,l-1].map{|d|(k=G=~/#{[*w.chars].*?.*d}/m)&amp;&amp;w.size.times{|i|O[k+d*i+i]=w[i]}}}
$&gt;&lt;&lt;O
</code></pre>
</div>
<div id="pu4" class="pu"><h2>Scala <strike> 697, 666 </strike> 649</h2>

<pre><code>val(z,n)=io.Source.fromFile("F").getLines.toList.span(_.length&gt;0)
val m=n.tail
val(w,h)=(m.head.length,m.size)
def g(d:Int,e:Int,k:Int,g:Int,h:Int,i:Int,s:String)={
def f(x:Int,y:Int):Seq[(Int,Int)]={
val q=for(c&lt;-(0 to s.size-1))
yield (y+c*i,x+c*k)
if((q.map(p=&gt;m(p._1)(p._2))).mkString==s)q else Nil}
val t=for(x&lt;-(d to e);
y&lt;-(g to h))yield f(x,y)
t.flatten}
def i(s:String)={val l=s.size
g(0,w-l,1,0,h-1,0,s)++ g(0,w-1,0,0,h-l,1,s)++ g(0,w-l,1,l-1,h-1,-1,s)++ g(0,w-l,1,0,h-l,1,s)}
def j(s: String)=i(s)++ i(s.reverse)
val k=z.map(j).flatten
(0 to h-1).map(r=&gt;{(0 to w-1).map(c=&gt;if(k.contains(r,c))print(""+m(r)(c))else print(" "));println()})
</code></pre>

<h3>degolfed:</h3>

<pre><code>object Golf {

def main (args: Array[String]) = {
  val (words, matrix) = io.Source.fromFile ("./wordsearch.data").getLines.toList.span (_.length &gt; 0)
  val m = matrix.tail
  val (w,h) = (m.head.length, m.size)

  // xi: x-increment, yi: y-increment
  def find (x: Int, y: Int, xi: Int, yi: Int, s: String): Seq [(Int, Int)] = {
    val points = for (c &lt;- (0 to s.length-1))
       yield (y + c*yi, x + c * xi)
    if ((points.map (p =&gt; m (p._1)(p._2))).mkString == s) points else Nil
  }

  def findInScope (xS: Int, xD: Int, xi: Int, yS: Int, yD: Int, yi: Int, s: String): Seq [(Int, Int)] = {
    val ppoints = for (x &lt;- (xS to xD);
          y &lt;- (yS to yD)) yield find (x, y, xi, yi, s)
    ppoints.flatten 
  }

  def findRowColFallingClimbing (s: String) = {
    val l=s.length

    // horizontal:
      findInScope (0,   w-l,  1,   0, h-1,  0, s) ++
    // vertical: 
      findInScope (0,   w-1,  0,   0, h-l,  1, s) ++
    // climbing /:
      findInScope (0,   w-l,  1, l-1, h-1, -1, s) ++
    // falling \:
      findInScope (0,   w-l,  1,   0, h-l,  1, s)
  }

  def findBoth (s: String) = findRowColFallingClimbing (s) ++ findRowColFallingClimbing (s.reverse)
  val coords = words.map (findBoth).flatten

  (0 to h-1).map ( r =&gt; {
    (0 to w-1).map (c =&gt;
      if (coords.contains (r, c))
       print ("" + m(r)(c)) 
      else print (" ")
     )
     println ()
   })
  }
}
</code></pre>
</div>
<div id="pu5" class="pu"><p><strong>JavaScript:</strong> 342 characters  </p>

<p><a href="http://jsfiddle.net/briguy37/utaf6/" rel="nofollow">Code-Golfed version:</a></p>

<pre><code>function a(b){c='\n';d=b.split(c+c);e=d[1].split(c);for(f=-1,g=[];h=e[++f];)for(i=-1,g[f]=[];h[++i];)for(j=-2,g[f][i]=' ';2&gt;++j;)for(l=-2;2&gt;++l;)for(k=0;m=d[0].split(c)[k++];)for(n=-1;o=m[++n];)for(p=f-n*j-j,q=i-n*l-l,r=0;(s=m[r++])&amp;&amp;(t=e[p+=j])&amp;&amp;(u=t[q+=l])&amp;&amp;s==u;)if(r==m.length)g[f][i]=o;for(i=0;v=g[i];)g[i++]=v.join('');return g.join(c)}
</code></pre>

<p><a href="http://jsfiddle.net/briguy37/78HGh/" rel="nofollow">Formatted version:</a></p>

<pre><code>function solveWordsearch(input){
    var lineBreak = '\n';
    var solver = input.split(lineBreak+lineBreak);
    var board = solver[1].split(lineBreak);

    for(row=-1,output=[]; line=board[++row];){
        for(col=-1,output[row]=[]; line[++col];){
            for(rowIncrement=-2,output[row][col]=' ';2&gt;++rowIncrement;){
                for(colIncrement=-2;2&gt;++colIncrement;){
                    for(k=0; word=solver[0].split(lineBreak)[k++];){
                        for(charPosition=-1; wordChar=word[++charPosition];){
                            var startRowIndex=row-charPosition*rowIncrement-rowIncrement;
                            var startColIndex=col-charPosition*colIncrement-colIncrement;
                            for(wordIndex=0;(compareWordChar=word[wordIndex++])&amp;&amp;(compareBoardRow=board[startRowIndex+=rowIncrement])&amp;&amp;(compareBoardChar=compareBoardRow[startColIndex+=colIncrement])&amp;&amp;compareWordChar==compareBoardChar;){
                                if(wordIndex == word.length){
                                    output[row][col]=wordChar;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    for(i=0;outLine=output[i];){
        output[i++]=outLine.join('');
    }

    return output.join('\n');
}
</code></pre>

<p>The concept behind this solution is to iterate over all positions on the board, initialize a 2D-array's values to ' ' for each position, and then consider all potential word directions and word offsets.  If a matching word is found, the array's value for that position is updated to the correct letter.  Finally, the array is converted to a string and returned.</p>
</div>
<div id="pu6" class="pu"><h2>Perl - 230 chars</h2>

<p>Count includes 4 for "-ln " command-line options.</p>

<pre><code>if(1../^$/){push@w,$_,''.reverse if$_}else{$a.="$_\n"}END{$_=$a;/.+/;$W=$+[0];y/A-Z/ /;chomp;for$w(@w){for$n(0,$W-1..$W+1){$r=join".{$n}",map"($_)",(@l=split//,$w);if($i=$a=~/$r/s){substr($_,$-[$i++],1,shift@l)while@l}}}print}
</code></pre>

<p>Ungolfed:</p>

<pre><code># -n: implicitly loop over input lines
# -l: strip the newlines
if ( 1 .. /^$/ ) {              # from first line to empty line
  push @w,                      # record in @w
    $_,                         #   the word
      ''.reverse                #   and its reverse
        if $_                   #   if it's not the empty line
}
else {
  $a .= "$_\n"                  # otherwise, add to the search array
}

END {
  $_ = $a;                      # make a copy for the output
  /.+/; $W = $+[0];             # compute array width
  y/A-Z/ /;                     # blank the output board
  chomp;                        # and remove the trailing newline,
                                #  because -l will add it back for us
  for $w (@w) {                 # for each word
    for $n (0, $W-1 .. $W+1) {  # for each direction in E, SW, S, SE
      $r = join ".{$n}",        # form a regexp with an appropriate
                                #  number of characters skipped between letters
                                #  (0 -&gt; adjacent, so E; $W -&gt; next line, so S;
                                #   off by one from $W for the diagonals),
        map "($_)",             #  capturing the letters of the word (for their offsets),
          (@l=split//,$w);      #  which we split up here
      if ( $i = $a =~ /$r/s ) { # if the word matches in this orientation
        substr( $_,             # set the substring of the output
                $-[$i++],       #  at the offset this letter matched
                1,              #  length 1
                shift @l )      #  to the corresponding letter
          while @l              #  (for each letter)
      }
    }
  }
  print                         # and print the output
}
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/3383/">3383</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




