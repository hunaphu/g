<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::117432</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>021</td><td>Japt</td><td>250211T214656Z</td><td><a href="https://codegolf.stackexchange.com/questions/117432/perfect-palindromes/278206#278206">Glory2Uk</a></td></tr>
<tr d-ix="1"><td>097</td><td>JavaScript Firefox 3057</td><td>170424T231439Z</td><td><a href="https://codegolf.stackexchange.com/questions/117432/perfect-palindromes/117542#117542">Neil</a></td></tr>
<tr d-ix="2"><td>319</td><td>PHP</td><td>170424T151658Z</td><td><a href="https://codegolf.stackexchange.com/questions/117432/perfect-palindromes/117467#117467">J&#246;r</a></td></tr>
<tr d-ix="3"><td>109</td><td>Haskell</td><td>170424T183217Z</td><td><a href="https://codegolf.stackexchange.com/questions/117432/perfect-palindromes/117494#117494">maple_sh</a></td></tr>
<tr d-ix="4"><td>069</td><td>Haskell</td><td>170425T073422Z</td><td><a href="https://codegolf.stackexchange.com/questions/117432/perfect-palindromes/117568#117568">Zgarb</a></td></tr>
<tr d-ix="5"><td>010</td><td>Jelly</td><td>170424T223543Z</td><td><a href="https://codegolf.stackexchange.com/questions/117432/perfect-palindromes/117535#117535">Jonathan</a></td></tr>
<tr d-ix="6"><td>124</td><td>JavaScript ES6</td><td>170424T143241Z</td><td><a href="https://codegolf.stackexchange.com/questions/117432/perfect-palindromes/117457#117457">Arnauld</a></td></tr>
<tr d-ix="7"><td>083</td><td>Haskell</td><td>170424T204135Z</td><td><a href="https://codegolf.stackexchange.com/questions/117432/perfect-palindromes/117514#117514">Laikoni</a></td></tr>
<tr d-ix="8"><td>009</td><td>Pyth</td><td>170424T193359Z</td><td><a href="https://codegolf.stackexchange.com/questions/117432/perfect-palindromes/117502#117502">isaacg</a></td></tr>
<tr d-ix="9"><td>111</td><td>Clojure</td><td>170424T152551Z</td><td><a href="https://codegolf.stackexchange.com/questions/117432/perfect-palindromes/117469#117469">NikoNyrh</a></td></tr>
<tr d-ix="10"><td>011</td><td>Jelly</td><td>170424T125435Z</td><td><a href="https://codegolf.stackexchange.com/questions/117432/perfect-palindromes/117435#117435">Leaky Nu</a></td></tr>
<tr d-ix="11"><td>007</td><td>Brachylog</td><td>170424T125952Z</td><td><a href="https://codegolf.stackexchange.com/questions/117432/perfect-palindromes/117437#117437">Fatalize</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/ETHproductions/japt" rel="nofollow noreferrer">Japt</a>, 21 bytes</h1>
<pre><code>à à
mf_¥wÃf_¬¥NÃ®lÃrm
</code></pre>
<p><a href="https://tio.run/##y0osKPn///AChcMLuHLT4g8tLT/cDKTWHFrqd7j50Lqcw81Fuf//K6Xn56coAQA" rel="nofollow noreferrer" title="Japt – Try It Online">Try it online!</a></p>
<p>This solution relies pretty much on the same logic as in other answers, it's just larger. And unfortunately does not work for the strings longer than 4 characters. The filtering condition <code>f_¬¥NÃ</code> was peeked from <a href="https://codegolf.stackexchange.com/a/210336/101276">a related challenge.</a></p>
<p><strong>Commented:</strong></p>
<pre class="lang-javascript prettyprint-override"><code>à à    // make a list of lists of word chunks
m      // map
 f_¥wÃ //  the filter of palindromic fragments 
f_¬¥NÃ // filter only those lists that concatenate to the input
®lÃ    // calculate the lengths
rm     // reduce to the minimum

</code></pre>
</div>
<div id="pu1" class="pu"><h2>JavaScript (Firefox 30-57), 97 bytes</h2>

<pre><code>f=(s,t=``,i=0)=&gt;s?Math.min(...(for(c of s)if([...t+=c].reverse(++i).join``==t)1+f(s.slice(i)))):0
</code></pre>

<p>ES6 port:</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>f=(s,t=``)=&gt;s?Math.min(...[...s].map((c,i)=&gt;[...t+=c].reverse().join``==t?1+f(s.slice(i+1)):1/0)):0</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;input oninput=o.textContent=f(this.value)&gt;&lt;pre id=o&gt;</code></pre>
</div>
</div>
</p>

<p>It seems such a simple solution that I keep thinking I've forgotten something but it does at least pass all the test cases.</p>
</div>
<div id="pu2" class="pu"><h1>PHP, 319 Bytes</h1>

<pre><code>for(;$i&lt;$l=strlen($s=$argn);$i++)for($j=$l-$i;$j;$j--)strrev($r=substr($s,$i,$j))!=$r?:$e[+$i][]=$r;uasort($e,function($a,$b){return strlen($b[0])&lt;=&gt;strlen($a[0])?:count($a)&lt;=&gt;count($b);});foreach($e as$p=&gt;$v)foreach($v as$w){$s=preg_replace("#^(.{{$p}})$w#","$1".str_pad("",strlen($w),"ö"),$s,1,$c);!$c?:++$d;}echo$d;
</code></pre>

<p><a href="http://sandbox.onlinephpfunctions.com/code/94f45855398aa600106e2799dfa7fdc602638619" rel="nofollow noreferrer">Online Version</a></p>

<p>Expanded</p>

<pre><code>for(;$i&lt;$l=strlen($s=$argn);$i++)
for($j=$l-$i;$j;$j--)strrev($r=substr($s,$i,$j))!=$r?:$e[+$i][]=$r; #Make all substrings that are palindromes for each position
uasort($e,function($a,$b){return strlen($b[0])&lt;=&gt;strlen($a[0])?:count($a)&lt;=&gt;count($b);}); # sort palindrome list high strlen lowest count for each position
foreach($e as$p=&gt;$v)
foreach($v as$w){
    $s=preg_replace("#^(.{{$p}})$w#","$1".str_pad("",strlen($w),"ö"),$s,1,$c);
    !$c?:++$d; # raise count
}
echo$d; # Output
</code></pre>

<p><a href="http://sandbox.onlinephpfunctions.com/code/b7cc8da273bf5a80e6c29a69f5b0e5828aef0436" rel="nofollow noreferrer">Longer Version without E_NOTICE and Output the resulting array</a></p>
</div>
<div id="pu3" class="pu"><h1>Haskell, <s>139</s> <s>116</s> 109 bytes</h1>

<pre><code>h[]=[[]]
h x=words.concat&lt;$&gt;mapM(\c-&gt;[[c],c:" "])x
r x=reverse x==x
g x=minimum[length y|y&lt;-h x,and$r&lt;$&gt;y]
</code></pre>

<p>Still green at Haskell golfing but here is my best attempt I can come up with quickly.</p>

<ul>
<li>h is a function that creates a List of all possible contiguous subsequences of a List (like a string).  It takes the input String and breaks it out for g.</li>
<li>r is a simple function that returns a Boolean for if a List is a palindrome</li>
<li>g is the main function that takes an input List, calls h to get the list of contiguous subsequence possibilities, filters on <code>(and.map r)</code> to remove sub lists that do not contain a palindrome, at which point length is applied to the list, and then the result is sorted so we can grab the head which is the answer.</li>
</ul>

<p>I was thinking a better answer might be able to leverage the non-deterministic nature of Lists in Haskell through the use of Applicatives.  It might be possible to shave many bytes off of function h by using applicatives, even if we have to import Control.Applicative.  Comments for improvement are welcome.</p>

<p><strong>UPDATE1</strong></p>

<p>Huge savings based on Laikoni's reminder about the minimum function.  Removing sort actually allowed me to drop the Data.List import because minimum is defined in Prelude!</p>

<p><strong>UPDATE2</strong></p>

<p>Thanks to nimi's suggestion about using list comprehensions as a useful replacement for filter.map.  That saved me a few bytes.  Also I borrowed the neat String partition trick from Laikonis answer and saved a couple bytes there as well.</p>
</div>
<div id="pu4" class="pu"><h2><a href="https://www.haskell.org/" rel="noreferrer">Haskell</a>, 69 bytes</h2>



<pre class="lang-hs prettyprint-override"><code>x!(a:b)|p&lt;-a:x=p!b++[1+f b|p==reverse p]
x!y=[0|x==y]
f=minimum.(""!)
</code></pre>

<p>Defines a function <code>f</code>. <a href="https://tio.run/nexus/haskell#NYtBCoMwFET3nuIndJGgFu0iC@nvDXoCK@VHI2QRCaYtEby7tVpnFvOGYZbIBFVazv6aUxXRM52mdZn2oGePOJqPGYMB3ySRTVgXc0ScmqRHZwfr3u4sOGdycWQHQHDk708QjwD5DfxohxeIkEEPQUo4Qc3LVTwDTrrVR3Z/6MwPlKJj2CDubXVL22UD2seLUkXBm@UL" rel="noreferrer" title="Haskell – TIO Nexus">Try it online!</a></p>

<h2>Explanation</h2>

<p>The infix helper function <code>x ! y</code> computes a list of integers, which are the lengths of some splittings of <code>reverse x ++ y</code> into palindromes where <code>reverse x</code> is left intact.
It is guaranteed to contain the length of the minimal splitting if <code>y</code> is nonempty.
How it works is this.</p>

<ul>
<li>If <code>y</code> is nonempty, a char is popped off it and pushed into <code>x</code>.
If <code>x</code> becomes a palindrome, we call the main function <code>f</code> on the tail of <code>y</code> and add 1 to account for <code>x</code>.
Also, we call <code>!</code> on the new <code>x</code> and <code>y</code> to not miss any potential splitting.</li>
<li>If <code>y</code> is empty, we return <code>[0]</code> (one splitting of length 0) if <code>x</code> is also empty, and <code>[]</code> (no splittings) otherwise.</li>
</ul>

<p>The main function <code>f</code> just calls <code>"" ! x</code> and takes the minimum of the results.</p>

<pre class="lang-hs prettyprint-override"><code>x!(a:b)|          -- Function ! on inputs x and list with head a and tail b,
  p&lt;-a:x=         -- where p is the list a:x, is
  p!b++           -- the numbers in p!b, and
  [1+f b|         -- 1 + f b,
   p==reverse p]  -- but only if p is a palindrome.
x!y=              -- Function ! on inputs x and (empty) list y is
  [0|             -- 0,
   x==y]          -- but only if x is also empty.
f=                -- Function f is:
  minimum.(""!)   -- evaluate ! on empty string and input, then take minimum.
</code></pre>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 10 <a href="https://github.com/DennisMitchell/jelly/wiki/Code-page" rel="nofollow noreferrer">bytes</a></h1>

<pre><code>ŒṖŒḂ€¬$ÞḢL
</code></pre>

<p><strong><a href="https://tio.run/nexus/jelly#@3900sOd04DEjqZHTWsOrVE5PO/hjkU@/4/uOdwOFPAG4sj//6PVDYFAXUc9MSk5CUqlQOiUVCBtZpYIFQXRFWA2ECYnghSD6USwjJGZmYGBeiwA" rel="nofollow noreferrer" title="Jelly – TIO Nexus">Try it online!</a></strong></p>

<h3>How?</h3>

<p>Uses the fact that<br>
<code>[0]&lt;[0,0]&lt;[0,0,0],...,&lt;[0,...,0,1]&lt;...</code><br>
- thus if we sort the partitions by a key "is not palindromic for each part" the first entry will be all palindromic and of minimal length.</p>

<p><em>Note: any non-empty string of length <strong>n</strong> will always result in such a key with <strong>n</strong> zeros, since all length <strong>1</strong> strings are palindromic.</em></p>

<pre><code>ŒṖŒḂ€¬$ÞḢL - Main link: s             e.g. 'abab'
ŒṖ         - partitions of s               [['a','b','a','b'],['a','b','ab'],['a','ba','b'],['a','bab'],['ab','a','b'],['ab','ab'],['aba','b'],['abab']]
       Þ   - sort by (create the following key and sort the partitions by it):
      $    -   last two links as a monad:  (key evaluations aligned with above:)
  ŒḂ€      -     is palindromic? for €ach   [ 1 , 1 , 1 , 1 ] [ 1 , 1 , 0  ] [ 1 , 0  , 1 ] [ 1 , 1   ] [ 0  , 1 , 1 ] [ 0  , 0  ] [ 1   , 1 ] [ 0    ] 
     ¬     -     not                        [ 0 , 0 , 0 , 0 ] [ 0 , 0 , 1  ] [ 0 , 1  , 0 ] [ 0 , 0   ] [ 1  , 0 , 0 ] [ 1  , 1  ] [ 0   , 0 ] [ 1    ]
           - ...i.e.:         
           -       making the sorted keys: [[ 0 , 0   ],[ 0   , 0 ],[ 0 , 0 , 0 , 0 ],[ 0 , 0 , 1  ],[ 0 , 1  , 0 ],[ 1    ],[ 1  , 0 , 0 ],[ 1  , 1  ]]
           -  hence the sorted partitions: [['a','bab'],['aba','b'],['a','b','a','b'],['a','b','ab'],['a','ba','b'],['abab'],['ab','a','b'],['ab','ab']]
        Ḣ  - head of the result             ['a','bab']
         L - length                         2
</code></pre>
</div>
<div id="pu6" class="pu"><h2>JavaScript (ES6), <s>143</s> <s>126</s> 124 bytes</h2>

<p><em>Saved 2 bytes thanks to Neil</em></p>

<p>Inspired by <a href="https://codegolf.stackexchange.com/a/117469/58563">NikoNyrh</a> method.</p>

<pre class="lang-js prettyprint-override"><code>s=&gt;(r=1/0,F=(s,i=1,p=0)=&gt;s[p++]?([...o=s.slice(0,p)].reverse().join``==o&amp;&amp;(s[p]?F(s.slice(p),i+1):r=r&lt;i?r:i),F(s,i,p)):r)(s)
</code></pre>

<h3>Formatted and commented</h3>

<pre class="lang-js prettyprint-override"><code>s =&gt; (                          // given a string 's':
  r = 1 / 0,                    // 'r' = best score, initialized to +Infinity
  F = (                         // 'F' is a recursive function that takes:
    s,                          //   - the current string 's'
    i = 1,                      //   - a substring counter 'i'
    p = 0                       //   - a character pointer 'p'
  ) =&gt;                          //
    s[p++] ? (                  // if we haven't reached the end of the string:
      [...o = s.slice(0, p)]    //   compute 'o' = substring of length 'p'
      .reverse().join`` == o    //   if 'o' is a palindrome,
      &amp;&amp; (                      //   then:
        s[p] ?                  //     if there are still characters to process:
          F(s.slice(p), i + 1)  //       do a recursive call on the remaining part
        :                       //     else:
          r = r &lt; i ? r : i     //       update the score with r = min(r, i)
      ),                        //   in all cases:
      F(s, i, p)                //     do a recursive call with a longer substring
    ) :                         // else:
      r                         //   return the final score
  )(s)                          // initial call to F()
</code></pre>

<h3>Test cases</h3>

<p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let f =

s=&gt;(r=1/0,F=(s,i=1,p=0)=&gt;s[p++]?([...o=s.slice(0,p)].reverse().join``==o&amp;&amp;(s[p]?F(s.slice(p),i+1):r=r&lt;i?r:i),F(s,i,p)):r)(s)

console.log(f('1111'))      // -&gt; 1 [1111]
console.log(f('abcb'))      // -&gt; 2 [a, bcb]
console.log(f('abcbd'))     // -&gt; 3 [a, bcb, d]
console.log(f('abcde'))     // -&gt; 5 [a, b, c, d, e]
console.log(f('66a'))       // -&gt; 2 [66, a]
console.log(f('abcba'))     // -&gt; 1 [abcba]
console.log(f('x'))         // -&gt; 1 [x]
console.log(f('ababacab'))  // -&gt; 2 [aba, bacab]
console.log(f('bacababa'))  // -&gt; 2 [bacab, aba]</code></pre>
</div>
</div>
</p>

<hr>

<h2>Initial approach, <s>173</s> 168 bytes</h2>

<p>A pretty long recursive function that computes all possible partitions of the input string.</p>

<pre class="lang-js prettyprint-override"><code>f=(s,b=1/(k=0))=&gt;++k&gt;&gt;(L=s.length)?b:f(s,(k|1&lt;&lt;30).toString(2).slice(-L).match(/(.)\1*/g).some(m=&gt;[...o=s.slice(i,i+=m.length)].reverse(n++).join``!=o,n=i=0)?b:b&lt;n?b:n)
</code></pre>

<h3>Formatted and commented</h3>

<pre class="lang-js prettyprint-override"><code>f = (                           // given:
  s,                            //   - a string 's'
  b = 1 / (k = 0)               //   - a best score 'b' (initialized to +Infinity)
) =&gt;                            //   - a counter 'k' (initialized to 0)
  ++k &gt;&gt; (L = s.length) ?       // if 'k' is greater or equal to 2^(s.length):
    b                           //   stop recursion and return 'b'
  :                             // else:
    f(                          //   do a recursive call:
      s,                        //     using the same string 's'
      (k | 1 &lt;&lt; 30)             //     compute an array containing the groups of identical
      .toString(2).slice(-L)    //     digits in the binary representation of 'k', padded
      .match(/(.)\1*/g)         //     with leading zeros and cut to the length of 's'
      .some(g =&gt;                //     for each group 'g' in this array:
        [... o = s.slice(       //       compute 'o' = corresponding substring of 's',
          i, i += g.length      //       starting at position 'i' with the same length
        )]                      //       (e.g. s = 'abcd' / k = 0b1101 =&gt; 'ab','c','d')
        .reverse(n++)           //       increment the number of groups 'n'
        .join`` != o,           //       return true if this substring is NOT a palindrome
        n = i = 0               //       initialize 'n' and 'i'
      ) ?                       //     if some() returns true:
        b                       //       invalid partition -&gt; keep the previous score 'b'
      :                         //     else:
        b &lt; n ? b : n           //       valid partition -&gt; use min(b, n)
    )                           //   end of recursive call
</code></pre>

<h3>Test cases</h3>

<p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>f=(s,b=1/(k=0))=&gt;++k&gt;&gt;(L=s.length)?b:f(s,(k|1&lt;&lt;30).toString(2).slice(-L).match(/(.)\1*/g).some(m=&gt;[...o=s.slice(i,i+=m.length)].reverse(n++).join``!=o,n=i=0)?b:b&lt;n?b:n)

console.log(f('1111'))      // -&gt; 1 [1111]
console.log(f('abcb'))      // -&gt; 2 [a, bcb]
console.log(f('abcbd'))     // -&gt; 3 [a, bcb, d]
console.log(f('abcde'))     // -&gt; 5 [a, b, c, d, e]
console.log(f('66a'))       // -&gt; 2 [66, a]
console.log(f('abcba'))     // -&gt; 1 [abcba]
console.log(f('x'))         // -&gt; 1 [x]
console.log(f('ababacab'))  // -&gt; 2 [aba, bacab]
console.log(f('bacababa'))  // -&gt; 2 [bacab, aba]</code></pre>
</div>
</div>
</p>
</div>
<div id="pu7" class="pu"><h1><a href="https://www.haskell.org/" rel="noreferrer">Haskell</a>, 83 bytes</h1>



<pre class="lang-hs prettyprint-override"><code>f s=minimum[length x|x&lt;-words.concat&lt;$&gt;mapM(\c-&gt;[[c],c:" "])s,all((==)=&lt;&lt;reverse)x]
</code></pre>

<p><a href="https://tio.run/nexus/haskell#HY49DoMwDIX3nMJCDIn4Ee3AUBFu0BMAgwlpiZSEioSSoXenAT/p87PkZ/l4geNGWWU202lp336G8AtNsS/r5EqxWIG@SVuDnyftRdF2nRhy8UggGZjLUWtKOWe8aVb5lauTLAyHQWWBg7Jerig8pLBZrax0UEI8BLR3ULTgIMsgOV1yOjcvO9D4DwMWF6/AcYtFcBTjhenkJEld4zUjCbFHCRzJxShyr@uq@gM" rel="noreferrer" title="Haskell – TIO Nexus">Try it online!</a></p>

<p>This uses Zgarb's great <a href="https://codegolf.stackexchange.com/a/98446/56433">tip for generating string partitions</a>.</p>

<pre class="lang-hs prettyprint-override"><code>f s = minimum[                               -- take the minimum of the list
    length x |                               -- of the number of partitions in x
    x&lt;-words.concat&lt;$&gt;mapM(\c-&gt;[[c],c:" "])s -- where x are all partitions of the input string s
    , all((==)=&lt;&lt;reverse)x                   -- where each partition is a palindrome.
]
</code></pre>
</div>
<div id="pu8" class="pu"><h1>Pyth, 9 bytes</h1>

<pre><code>lh_I#I#./
</code></pre>

<p><a href="https://pyth.herokuapp.com/?code=lh_I%23I%23.%2F&amp;test_suite=1&amp;test_suite_input=%221111%22%0A%22abcb%22%0A%22abcbd%22%0A%22abcde%22%0A%2266a%22%0A%22abcba%22%0A%22x%22%0A%22ababacab%22%0A%22bacababa%22%0A%2226600%22&amp;debug=0" rel="noreferrer">Test suite</a></p>

<p>This forms all partitions of the input, from shortest to longest. Then, it filters those partitions on invariance under filtering the elements on invariance under reversal. Finally, we take the first element of the filtered list of partitions, and return its length.</p>

<p>To explain that complicated step, let's start with invariance under reversal: <code>_I</code>. That checks whether its input is a palindrome, because it checks whether reversing changes the value.</p>

<p>Next, filtering for palindromicity: <code>_I#</code>. This will keep only the palindromic elements of the list.</p>

<p>Next, we check for invariance under filtering for palindromicity: <code>_I#I</code>. This is truthy if and only if all of the elements of the list are palindromes.</p>

<p>Finally, we filter for lists where all of the elements of the list are palindromes: <code>_I#I#</code>.</p>
</div>
<div id="pu9" class="pu"><h2>Clojure, 111 bytes</h2>

<pre><code>(defn f[s](if(=()s)0(+(apply min(for[i(range(count s))[a b][(split-at(inc i)s)]:when(=(reverse a)a)](f b)))1)))
</code></pre>

<p>Splits at all possible positions, and when the first part is a palindrome proceeds to find a partitioning for the remaining of the string.</p>

<p><a href="https://tio.run/nexus/clojure#Zc6xCgIxDAbg3acInRJE0FXwSUqHpNdq4S5X2nqHT392cqgJ//JBfnLgFKJCtNVhivhAqnTFM3LO8weWpBjXYhMW1mdAv761QSWyDOIs1jynduGGST2kfuru@ytorylhC6UGYGJyGEGI6NZzYC5J26wnAFw4bxDBGpa@nsV0/Y1hFvH/NIj4aQqjifBIIxjXv/kC" rel="nofollow noreferrer">Try it online</a>.</p>

<p>Ungolfed, uses <a href="https://clojuredocs.org/clojure.core/-%3E%3E" rel="nofollow noreferrer">thread-last macro</a> <code>-&gt;&gt;</code>.</p>

<pre><code>(defn f [s]
  (if (empty? s)
    0
    (let [results (for[i (range(count s))]
                      (let [[a b] (split-at (inc i) s)]
                         (when (= a (reverse a))
                           (f b))))]
      (-&gt;&gt; results        ; Take results (a list of integers and nils),
           (filter some?) ; remove null values (they occur when "a" is not a palindrome)
           (apply min)    ; find the minium value,
           inc))))        ; and increment by one.
</code></pre>

<p>An obscure version, please do not write code like this :D</p>

<pre><code>(defn f [s]
   (-&gt;&gt; (f b)
        (when (= a (reverse a)))
        (let [[a b] (split-at (inc i) s)])
        (for[i (range(count s))])
        (filter some?)
        (apply min)
        inc
        (if (empty? s) 0)))
</code></pre>
</div>
<div id="pu10" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="noreferrer">Jelly</a>, <s>13</s> <s>12</s> 11 bytes</h1>

<pre>
<s>ŒṖLÞŒḂ€P$ÐfḢL</s>
<s>ŒṖLÞṚ€⁼$ÐfḢL</s>
ŒṖṚ€⁼$ÐfL€Ṃ
ŒṖ            obtain partitions
      Ðf      filter for partitions which
  Ṛ€              after reversing each subpartition
    ⁼             is equal to the partition
        L€    length of each successful partition
          Ṃ   minimum
</pre>

<p><a href="https://tio.run/nexus/jelly#@3900sOd0x7unPWoac2jxj0qhyek@QCZD3c2/f//XykxCQiTE5OUAA" rel="noreferrer" title="Jelly – TIO Nexus">Try it online!</a></p>

<h3>Specs</h3>

<ul>
<li>Input: <code>"ababacab"</code> (as argument)</li>
<li>Output: <code>2</code></li>
</ul>
</div>
<div id="pu11" class="pu"><h1><a href="https://github.com/JCumin/Brachylog" rel="noreferrer">Brachylog</a>, 7 bytes</h1>
<pre><code>~cL↔ᵐLl
</code></pre>
<p><a href="https://tio.run/nexus/brachylog2#@1@X7POobcrDrRN8cv7/V0pMSk5KUfofBQA" rel="noreferrer" title="Brachylog – TIO Nexus">Try it online!</a></p>
<h3>Explanation</h3>
<pre><code>~cL          Deconcatenate the input into L
  L↔ᵐL       Reversing all elements of L results in L
     Ll      Output = length(L)
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/117432/">117432</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




