<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::25913</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>106</td><td>Java 16 > Java 17</td><td>250711T013328Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/282605#282605">Seggan</a></td></tr>
<tr d-ix="1"><td>nan</td><td>ARMv4T/ARMv5TE+ with libc</td><td>210101T053258Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/217110#217110">EasyasPi</a></td></tr>
<tr d-ix="2"><td>nan</td><td></td><td>140416T151245Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/25936#25936">Habib</a></td></tr>
<tr d-ix="3"><td>000</td><td>Go 1.9>1.10. Score = 1  1 =</td><td>181213T075552Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/177527#177527">captncra</a></td></tr>
<tr d-ix="4"><td>514</td><td>TIBasic 83 Plus vs. 84 Plus</td><td>181212T061320Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/177408#177408">Misha La</a></td></tr>
<tr d-ix="5"><td>005</td><td>SmileBASIC 3 / SmileBASIC 2</td><td>180328T143317Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/160556#160556">12Me21</a></td></tr>
<tr d-ix="6"><td>nan</td><td></td><td>140422T211807Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/26208#26208">celtschk</a></td></tr>
<tr d-ix="7"><td>000</td><td>Python</td><td>140420T201725Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/26077#26077">cjfaure</a></td></tr>
<tr d-ix="8"><td>nan</td><td></td><td>140417T155347Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/25990#25990">Toni Ton</a></td></tr>
<tr d-ix="9"><td>nan</td><td></td><td>140416T115421Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/25925#25925">Gaurang </a></td></tr>
<tr d-ix="10"><td>000</td><td>C89/C99 comment exploit</td><td>140416T180353Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/25949#25949">Johnny C</a></td></tr>
<tr d-ix="11"><td>nan</td><td></td><td>140417T025238Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/25966#25966">nderscor</a></td></tr>
<tr d-ix="12"><td>nan</td><td></td><td>140416T123015Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/25929#25929">MarcDefi</a></td></tr>
<tr d-ix="13"><td>nan</td><td></td><td>140416T211428Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/25958#25958">Eric Lip</a></td></tr>
<tr d-ix="14"><td>nan</td><td></td><td>140416T210758Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/25957#25957">Eric Lip</a></td></tr>
<tr d-ix="15"><td>nan</td><td></td><td>140417T091012Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/25975#25975">Cephalop</a></td></tr>
<tr d-ix="16"><td>000</td><td> PHP</td><td>140417T110625Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/25980#25980">Vereos</a></td></tr>
<tr d-ix="17"><td>115</td><td>C++98/11  "Better" Scoring</td><td>140416T122425Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/25928#25928">foobar</a></td></tr>
<tr d-ix="18"><td>nan</td><td>PHP −134217684 43</td><td>140417T001223Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/25963#25963">Sylweste</a></td></tr>
<tr d-ix="19"><td>4031</td><td>Ruby</td><td>140416T115322Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/25924#25924">Doorknob</a></td></tr>
<tr d-ix="20"><td>nan</td><td>Python</td><td>140416T173636Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/25944#25944">Rynant</a></td></tr>
<tr d-ix="21"><td>nan</td><td>Powershell</td><td>140416T181458Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/25951#25951">Rynant</a></td></tr>
<tr d-ix="22"><td>nan</td><td>Befunge</td><td>140416T174453Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/25947#25947">Justin</a></td></tr>
<tr d-ix="23"><td>nan</td><td>Perl</td><td>140416T120930Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/25926#25926">Vince</a></td></tr>
<tr d-ix="24"><td>014</td><td>Bash 7</td><td>140416T174250Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/25946#25946">Digital </a></td></tr>
<tr d-ix="25"><td>nan</td><td></td><td>140416T102224Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/25914#25914">Tal</a></td></tr>
<tr d-ix="26"><td>nan</td><td></td><td>140416T133345Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/25933#25933">marinus</a></td></tr>
<tr d-ix="27"><td>nan</td><td></td><td>140416T124003Z</td><td><a href="https://codegolf.stackexchange.com/questions/25913/valid-through-the-ages/25930#25930">Gilles &</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Java 16 -&gt; Java 17, 106 bytes, score 106 + 1 - 2 = 105</h1>
<pre class="lang-java prettyprint-override"><code>class M{public static void main(String[]args){System.out.println(System.getProperty(&quot;native.encoding&quot;));}}
</code></pre>
<p><a href="https://tio.run/##JYxBCsMgEEWvIlnFRb1Az1AoZFm6mOogpmYUZyKEkLPbga4@PP57K3S4lYq0hu8YPgOzeZx1/@TkDQuITi8pmA0SzYu0RPH1hhbZnsvBgpsru7iqXLIe/iiiPJtWmxzzRBrp6JB8CWpP1t6va4wf" rel="nofollow noreferrer">Try it in Java 8</a></p>
<p><a href="https://ato.pxeger.com/run?1=m70kK7EsccGCpaUlaboWN7OScxKLixV8qwtKk3IykxWKSxJLgFRZfmaKQm5iZp5GcElRZl56dGxiUXqxZnVwZXFJaq5efmmJXgFQvCQHqAAilJ5aElCUX5BaVFKpoZQHNKQsVS81Lzk_BahbSVPTurYWYiPUYpgDAA" rel="nofollow noreferrer">Try it in Java 18</a></p>
<p>Prints <code>null</code> pre-Java 17, prints the platform encoding (<code>UTF-8</code> on both my machine and ATO) post-Java 17.</p>
<p>Java is notoriously stubborn about maintaining backwards compatibility, so finding a difference that would compile in two versions without resorting to checking class existence like the previous Java answer was hard. Fortunately, I found <a href="https://openjdk.org/jeps/400" rel="nofollow noreferrer">JEP 400</a>, which was introduced in Java 18 and standardized UTF-8 as the default Java character stream encoding. It crucially mentioned the system property <code>native.encoding</code>, introduced in Java 17, which is the solution I use here.</p>
</div>
<div id="pu1" class="pu"><h1>ARMv4T/ARMv5TE+ with libc, <code>pop {pc}</code> bug, for old scoring system, <s>42</s> 40 bytes, old score <s>-4294967252</s> -4294967255</h1>
<pre class="lang-none prettyprint-override"><code>1009 e28f 4002 e92d e001 e04f f004 e49d
e002 e201 ff11 e12f 4674 2021 f7ff fffe
3401 d1fa bc01 4700
</code></pre>
<p>ARMv4T, the ISA used in the ARM7TDMI, famous for powering the Game Boy Advance, introduced the Thumb instruction set.</p>
<p>It is a 16-bit (later mixed with 32-bit) instruction set encoding that is more compact, but more limited, than the standard 32-bit ARM instruction set. I write a lot of my golfs in it, because it is <s>torture</s> fun.</p>
<p>Basically, the idea is, since ARM instructions are always 4 byte aligned, if you jump to an odd address, the CPU will switch to Thumb execution mode at the address rounded down, and vice versa for an even address.</p>
<p>One cool thing that ARM lets you do is <code>pop</code> the return address directly into the program counter from the stack, resulting in incredibly easy stack cleanup (similar to <code>leave; ret</code> in x86, but you can pop ALL registers at once)</p>
<pre class="lang-armasm prettyprint-override"><code>        push    {..., lr} @ put the return address in the link register on the stack
        pop     {..., pc} @ pop the return address into the program counter to return
</code></pre>
<p>On ARMv5TE and later, this will magically switch between ARM and Thumb state.</p>
<p>However, ARMv4T had an infamous bug here.</p>
<p>They forgot to implement Thumb switching: <code>pop {pc}</code> will ignore the lowest two bits and not switch to Thumb mode. <a href="https://developer.arm.com/documentation/dui0283/latest/Babefbce" rel="nofollow noreferrer">Source: ARM docs</a></p>
<p>So all we have to do is write a polyglot that will do something different if it is in ARM or Thumb state, which is easy because the encodings are entirely different.</p>
<pre class="lang-armasm prettyprint-override"><code>        .text
        .arm
        .globl main
main:
        add     r1, pc, #9
        push    {r1, lr}
        sub     lr, pc, r1
@ define to simulate ARMv4T behavior
#ifdef SIMULATE_ARMV4T
        b       simulate_armv4t_bug
#else
        pop     {pc}
#endif
.Larmv4t_polyglot:
        and     lr, r1, #2      @ b     .Lthumb_entry; (skipped)
        bx      r1

        .thumb
.Lthumb_entry:
        mov     r4, lr
.Lloop:
        movs    r0, #'!'
        bl      putchar
        adds    r4, #1
        bne     .Lloop
        pop     {r0}
        bx      r0

#ifdef SIMULATE_ARMV4T
        .arm
        .align 2
simulate_armv4t_bug:
        pop     {r12}
        @ clear thumb bit
        bic     r12, r12, #3
        bx      r12
#endif
</code></pre>
<p>This program starts in ARM state.</p>
<p>We need <code>r1</code> to contain the address of <code>.Larmv4t_polyglot</code>, with the Thumb bit set. (So <code>.Larmv4t_polyglot | 1</code>, or <code>.Larmv4t_polyglot + 1</code>)</p>
<p>Therefore, we add 9 to the program counter (which points 8 bytes after the currently executing instruction because of questionable design decisions) to get 16 bytes, or 4 instructions, ahead, with the Thumb bit set.</p>
<pre class="lang-armasm prettyprint-override"><code>        add     r1, pc, #9
</code></pre>
<p>Push <code>r1</code> and <code>lr</code> to the stack. The former is so we can perform the <code>pop {pc}</code> bug, and the latter is to save the return address so we can use <code>lr</code> as a temp register and make function calls.</p>
<pre class="lang-armasm prettyprint-override"><code>        push    {r1, lr}
</code></pre>
<p>Subtract <code>r1</code> from <code>pc</code>. This results in <code>lr</code> being <code>-1</code>.</p>
<pre class="lang-armasm prettyprint-override"><code>        sub     lr, pc, r1
</code></pre>
<p>Then, we pop the value from <code>r1</code> into the program counter.</p>
<p>An ARMv5+ processor will execute the polyglot in Thumb mode, but an ARMv4T processor will ignore the low 2 bits (rounding down) and execute <code>.Larmv4t_polyglot</code> as ARM code.</p>
<p>To simulate the buggy behavior, define <code>SIMULATE_ARMV4T</code> which will replace <code>pop {pc}</code> with a veneer that jumps to that address in ARM mode.</p>
<pre class="lang-armasm prettyprint-override"><code>        pop     {pc}
</code></pre>
<p>Now, it is time for our polyglot.</p>
<p><strong>ARM mode:</strong> Set <code>lr</code> to <code>0</code> by setting it to <code>r1 &amp; 2</code>. Since that contains the address of <code>.Larmv4t_polyglot</code> plus one, we know the second bit is clear.</p>
<p>Then, jump to the polyglot again on ARMv4T (the address is still in <code>r1</code>), this time using <code>bx</code>, which DOES switch to Thumb mode.</p>
<pre class="lang-armasm prettyprint-override"><code>.Larmv4t_polyglot:
        and     lr, r1, #2
        bx      r1
</code></pre>
<p><strong>Thumb mode:</strong> Jump to <code>.Lthumb_entry</code>.</p>
<pre class="lang-armasm prettyprint-override"><code>.Larmv4t_polyglot.thumb:
        b       .Lthumb_entry
        @ skipped
</code></pre>
<p>Now, we are in Thumb mode on both machines, we can do our output loop.</p>
<p>We first need to make a copy, because <code>lr</code> will be overwritten.</p>
<pre class="lang-armasm prettyprint-override"><code>      mov     r4, lr
</code></pre>
<p>Then, we loop calling <code>putchar('!')</code>, until <code>r4 += 1</code> == 0.</p>
<pre class="lang-armasm prettyprint-override"><code>.Lloop:
        movs    r0, #'!'
        bl      putchar
        adds    r4, #1
        bne     .Lloop
</code></pre>
<p>On ARMv5TE+, <code>r4</code> will be <code>-1</code>, so the loop will only run for one iteration, but on ARMv4T, <code>r4</code> will be <code>0</code>, so it will run <code>4294967296</code> times (<code>0x100000000</code>) until it wraps back around to zero.</p>
<p>I could technically make this infinite, but the rules say that it must eventually finish.</p>
<p>Equivalent C:</p>
<pre class="lang-c prettyprint-override"><code>uint32_t r4 = lr;
do {
    putchar('!');
} while (++r4);
</code></pre>
<p>Finally, do an ARMv4T compatible return using the &quot;Thumb interworking&quot; hack: We pop into a low register and <code>bx</code> to it to return from <code>main</code>.</p>
<pre class="lang-armasm prettyprint-override"><code>        pop     {r0}
        bx      r0
</code></pre>
<p>Program size: 40 bytes</p>
<p>Output length in ARMv5TE+: 1 byte</p>
<p>Output length in ARMv4T: 4294967296 bytes</p>
<p><strong>Score: -4294967255</strong></p>
<h1>ARMv4/ARMv5TE+ with libc, same bug, for new scoring system, 42 bytes, score 0</h1>
<p>Mostly the same, but instead of dumping near-infinite <code>'!'</code>s, both will dump 42 bytes to <code>stdout</code>. However, for a maximum negative score, all you have to do is change <code>movs r5, #42</code> to <code>movs r5, #128</code> for a score of -86.</p>
<p>Machine code:</p>
<pre class="lang-none prettyprint-override"><code>1009 e28f 4002 e92d e080 e3b0 f004 e49d
e002 e201 ff11 e12f 252a 4676 19a8 f7ff
fffe 3d01 d1fa bc01 4700
</code></pre>
<p>(ARMv4T simulator left out, it is the same)</p>
<p>Assembly:</p>
<pre class="lang-armasm prettyprint-override"><code>        .text
        .arm
        .globl main
main:
        add     r1, pc, #9
        push    {r1, lr}
        movs    lr, #128
        pop     {pc}

.Larmv4t_polyglot:
        and     lr, r1, #2      @ b     .Lthumb_entry; (skipped)
        bx      r1

        .thumb
.Lthumb_entry:
        movs    r5, #42
        mov     r6, lr
.Lloop:
        adds    r0, r5, r6
        bl      putchar
        subs    r5, #1
        bne     .Lloop
        pop     {r0}
        bx      r0
</code></pre>
<p>The main differences are that instead of initially setting <code>lr</code> to <code>-1</code>, we set <code>lr</code> to <code>128</code>, and that our print loop will always run 42 times, subtracting 1 from the char it prints each time.</p>
<p>The equivalent C loop looks like this:</p>
<pre class="lang-c prettyprint-override"><code>uint32_t r5 = 42, r6 = ARMv4T ? 0 : 128;
do {
    putchar(r5 + r6);
} while (--r5);
</code></pre>
<p>ARMv5TE+ output</p>
<pre><code>termux ~/golf $ clang -m32 valid-through-the-ages.S
termux ~/golf $ ./a.out | hexdump -C | cut -d' ' -f 3-19
aa a9 a8 a7 a6 a5 a4 a3  a2 a1 a0 9f 9e 9d 9c 9b
9a 99 98 97 96 95 94 93  92 91 90 8f 8e 8d 8c 8b
8a 89 88 87 86 85 84 83  82 81
</code></pre>
<p>ARMv4T (simulated) output:</p>
<p>As stated before, the compiler option is just to emulate the bug on my device. It is not needed on actual hardware.</p>
<pre class="lang-none prettyprint-override"><code>termux ~/golf $ clang -m32 valid-through-the-ages.S -DSIMULATE_ARMV4T
termux ~/golf $ ./a.out | hexdump -C | cut -d' ' -f 3-19
2a 29 28 27 26 25 24 23  22 21 20 1f 1e 1d 1c 1b
1a 19 18 17 16 15 14 13  12 11 10 0f 0e 0d 0c 0b
0a 09 08 07 06 05 04 03  02 01
</code></pre>
<p>Program size: 42 bytes</p>
<p>Difference in output length: None</p>
<p>Differing bytes: 42.</p>
<p><strong>Score: 0</strong></p>
</div>
<div id="pu2" class="pu"><h2>C#</h2>
<p>Following code would produce the different output for C# 5.0 and previous versions of C#</p>
<pre class="lang-cs prettyprint-override"><code>using System;
using System.Collections.Generic;

namespace TestConsoleAppClosure
{
    class Program
    {
        static void Main(string[] args)
        {
            var actions = new List&lt;Action&gt;();
            List&lt;int&gt; list = new List&lt;int&gt; { 10, 20, 30, 40 };
            foreach (var item in list)
            {
                  actions.Add(() =&gt; Console.WriteLine(item));
            }
            foreach (var act in actions) act();
        }
    }
}
</code></pre>
<p><strong>Output: C# 5.0</strong></p>
<pre><code>10
20
30
40
</code></pre>
<p><strong>Output: C# 4.0</strong></p>
<pre><code>40
40
40
40
</code></pre>
<p>The reason is explained in this blog post by Eric Lippert: <a href="https://docs.microsoft.com/en-us/archive/blogs/ericlippert/closing-over-the-loop-variable-considered-harmful" rel="nofollow noreferrer">Closing over the loop variable considered harmful</a>.</p>
</div>
<div id="pu3" class="pu"><h1>Go 1.9->1.10. Score = 1 - 1 = 0</h1>

<p>From <a href="https://golang.org/doc/go1.10#runtime" rel="nofollow noreferrer">1.10 notes</a>:</p>

<blockquote>
  <p>There is no longer a limit on the GOMAXPROCS setting. (In Go 1.9 the limit was 1024.)</p>
</blockquote>

<pre><code>package main 
import (r"runtime")
var g=r.GOMAXPROCS
func main() {g(10340)
print(g(0))}
</code></pre>

<p>1.8: <code>256</code></p>

<p>1.9: <code>1024</code></p>

<p>1.10: <code>10340</code></p>
</div>
<div id="pu4" class="pu"><h1>TI-Basic 83 Plus vs. 84 Plus, score 5-1 = 4</h1>

<pre><code>length("setTime(
</code></pre>

<p>Outputs <code>2</code> on the TI-83 Plus, where the same program is parsed as something that looks like <code>length("?►DMS</code> because the <code>setTime(</code> command had not yet been introduced. So the string contains two 1-byte tokens, its length is 2.</p>

<p>Outputs <code>1</code> on the TI-84 Plus, because a string containing a single 2-byte token has length 1.</p>
</div>
<div id="pu5" class="pu"><h1>SmileBASIC 3 / SmileBASIC 2, Score: -5 (original scoring)</h1>
<pre><code>?1E9
</code></pre>
<p>In modern versions of SB, this prints <code>1000000000</code> as expected, but in version 2 and earlier it printed <code>10</code> due to a bug.</p>
</div>
<div id="pu6" class="pu"><h1>C++98/C++11</h1>

<pre><code>#include &lt;iostream&gt;

int main()
{
  for (long i = 0; i &lt; __cplusplus; ++i)
     std::cout &lt;&lt; "x";
}
</code></pre>

<p>For a standard conforming C++98 compiler, this outputs 199711 times the letter 'x', while for a standard conforming C++11 compiler, this outputs 201103 times the letter 'x'. The length difference of the output is therefore 1392 characters. This means that actually golfing the source code is not worthwhile, since a much larger effect can be achieved by just replacing <code>"x"</code> with a longer string, or by multiplying <code>__cplusplus</code> with some number.</p>
</div>
<div id="pu7" class="pu"><h1>Python - 0</h1>

<pre><code>a='a=%r\ntry:print a%%a\nexcept:pass'
try:print a%a
except:pass
</code></pre>

<p>Python 2 prints a quine, while Python 3 prints nothing.</p>

<p>EDIT: Updated, fixed.</p>
</div>
<div id="pu8" class="pu"><p><strong>CSS2 vs CSS3 48 points</strong></p>

<pre><code>&lt;i style='font-feature-settings:"smcp" on;'&gt;abcdefghijklmnopqrstuvwxyz&lt;/i&gt;
</code></pre>

<p>Rendered as <code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code> (small caps) on CSS3 browsers</p>

<p>Rendered as <code>abcdefghijklmnopqrstuvwxyz</code> on non-CSS3 browsers</p>

<p>74 chars - 26 unique chars difference = 48</p>
</div>
<div id="pu9" class="pu"><h1>Python - 0 points</h1>

<p>No idea how this one works :P Just stumbled upon it while trying out random code.</p>

<pre><code>int
</code></pre>

<p>On Python 3, it's <code>&lt;class 'int'&gt;</code> and on Python 2, it's <code>&lt;type 'int'&gt;</code> (using interative console)<br>
"Better" Score: 3 (length) + 1 (char diff.) - 4 (unique chars)</p>

<h2>Older Python 1 - 7 points</h2>

<pre><code>print()
</code></pre>

<p>Big thanks to <a href="https://codegolf.stackexchange.com/users/4020/grc">@grc</a> for this version and helping me subtract four points !</p>

<p>In Python 2, this statement is interpreted as <code>print ()</code> which prints the empty tuple <code>()</code>.<br>
In Python 3, the <code>print</code> is a function and results in nothing being printed.<br>
"Better" Score: 7 (length) + 2 (char diff.) - 2 (unique chars)</p>

<h3>Older Python 2 - 13 points:</h3>

<pre><code>print(1,2)
</code></pre>

<p>"Better" Score: 12 (length) + 2 (char diff. o/p) - 1 (unique chars o/p) </p>

<p>I know this isn't going to win but still gave an answer, as this is my first Python try :)</p>
</div>
<div id="pu10" class="pu"><h3>C89/C99 comment exploit, 45 character, 0 score</h3>
<pre><code>main(a){while(++a&lt;47)putchar(79-a//**/~0
);}
</code></pre>
<h3>c89 output</h3>
<p><code>QRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}</code> - 45 char.</p>
<h3>c99 output</h3>
<p><code>MLKJIHGFEDCBA@?&gt;=&lt;;:9876543210/.-,+*)('&amp;%$#&quot;!</code> - 45 char.</p>
</div>
<div id="pu11" class="pu"><h1>JavaScript (ES3 vs ES5) - 9 points</h1>

<p>length <code>10</code> <strong>+</strong> length difference <code>0</code> <strong>-</strong> output difference <code>1</code></p>

<pre><code>[].map?1:0
</code></pre>

<p>Outputs <code>1</code> for modern browsers that support Array.prototype.map. Outputs <code>0</code> on older browsers. I tested this with IE8.</p>

<h1>With old rules: 0 points</h1>

<p>length <code>26</code> <strong>-</strong> length difference <code>26</code></p>

<pre><code>Array([].map?27:0).join(0)
</code></pre>

<p>Outputs <code>00000000000000000000000000</code> on modern browsers. And empty string on old.</p>
</div>
<div id="pu12" class="pu"><p><strong>Revised answer for &quot;better&quot; scoring system</strong></p>
<h1>C89 / C99, Score: 0</h1>
<p>My program is 52 characters long and uses the same mechanism as in my original answer to achieve the different output. This works because C89 doesnt treat <code>//</code> as a comment:</p>
<pre class="lang-c prettyprint-override"><code>i=32;main(){putchar(i+++0//**/
+52)&amp;&amp;i&lt;84&amp;&amp;main();}
</code></pre>
<p>The results:</p>
<pre><code>$ ./diff2c89
 !&quot;#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRS
$ ./diff2c99
TUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂Çüéâäàåç
$ ./diff2c99 | wc
      0       1      52
$ ./diff2c89 | wc
      0       1      52
$ wc diff2.c
      1       2      52 diff2.c
</code></pre>
<p><strong>Old answer:</strong></p>
<h1>C89 / C99, Score: -Infinity?</h1>
<p>I'm not entirely sure if this program doesn't break the rules, but never mind.
This program exploits the fact that in C89 <code>//</code> is not a valid comment but <code>/* ... */</code> is.</p>
<p>Using the comment trick an other function is executed. In C89 the function just prints <code>&quot;trolololol...&quot;</code> until the stack overflows (so it might finish within 2 seconds).</p>
<pre class="lang-c prettyprint-override"><code>f1(){printf(&quot;ol&quot;);f1();}
f2(){printf(&quot;oll&quot;);}
main(){
    printf(&quot;tr&quot;);
    void (*f[])() = {f1,f2};
    f[0 //* trollololol */
      +1]();
}
</code></pre>
<h2>C99</h2>
<pre><code>$ ./diffc99
troll
</code></pre>
<h2>C89</h2>
<pre><code>$ ./diffc89
trolololololololololololololololololololololololololololololololololololololololololo
lolololololololololololololololololololololololololololololololololololololololololol
ololololololololololololololololololololololololol ....
</code></pre>
</div>
<div id="pu13" class="pu"><h2>C#</h2>

<p>I also changed the generic method type inference algorithms between C# 2, 3 and 4. For example:</p>

<pre class="lang-cs prettyprint-override"><code>using System;
class C
{
  static int M&lt;T&gt;(T x, T y) { return 1; }
  static int M(object x, object y) { return 2; }
  static void Main() 
  {
    Console.WriteLine(M(1, new int?()));
  }
}
</code></pre>

<p>In C# 2 method type inference says that T cannot be both <code>int</code> and <code>int?</code>, and so produces <code>2</code>. In C# 3 method type inference says "the best compromise between <code>int</code> and <code>int?</code> is <code>int?</code>" and so chooses <code>M&lt;int?&gt;</code> and produces 1.</p>
</div>
<div id="pu14" class="pu"><h2>C#</h2>

<p>I added covariance and contravariance to C# 4, so programs of the form:</p>

<pre class="lang-cs prettyprint-override"><code>using System;
using System.Collections.Generic;
class C
{
  static void Main() 
  {
    Console.WriteLine((new List&lt;string&gt;()) is IEnumerable&lt;object&gt;);
  }
}
</code></pre>

<p>Would produce <code>false</code> in C# 2 and 3 and <code>true</code> in C# 4.</p>

<p>However, one might argue that this does not count because the <em>library</em> containing the definition of <code>IEnumerable&lt;T&gt;</code> also had to change. </p>
</div>
<div id="pu15" class="pu"><h1>Java (around -2.000.000.000)</h1>



<p>The Java versions are sometimes called 1.x, but I think it still is within the rules.</p>

<p>The easy way is to check whether a class exists that was introduced in  a specific version.</p>

<pre class="lang-java prettyprint-override"><code>try {
    Class.forName("java.lang.AutoCloseable");
    // Java 7 or later
    char[] text = new char[Integer.MAX_VALUE];
    Arrays.fill(text, 'a');
    System.out.println(new String(text));
} catch (Exception e) {
    // Java 6 or earlier
    System.out.println("-");
}
</code></pre>

<p>(Depends a bit on your terminal whether it is possible to output 2 billion characters in two seconds / For the new scoring, replace <code>Integer.MAX_VALUE</code> with the byte count of the program to achieve perfect zero score.)</p>

<p>This code depends on the version of the VM/JDK that is used (does that count?)</p>

<pre class="lang-java prettyprint-override"><code>import java.lang.reflect.Field;
import java.util.Arrays;

{
    Field fValue = null;
    for (Field f: String.class.getDeclaredFields()) {
            if (f.getName().equals("value")) {
                    fValue = f;
            }
    }
    char[] text = new char[10];
    Arrays.fill(text, 'a');
    String s1 = new String(text);
    String s2 = s1.substring(1);
    fValue.setAccessible(true);
    text = (char[]) fValue.get(s2);
    Arrays.fill(text, 'z');
    System.out.println(s1);
}
</code></pre>

<p>It prints <code>z</code>s  for Java 6 and earlier JDKs and <code>a</code>s for recent versions.</p>
</div>
<div id="pu16" class="pu"><h1> PHP, Score: 0 (best case) </h1>

<pre><code>srand(2);echo rand();
</code></pre>

<p>Wow, this is going to be fun to explain.</p>

<p>According to <a href="http://sandbox.onlinephpfunctions.com/" rel="nofollow">this website</a>, the <code>srand()</code> function appears to be broken from <strong>PHP 5.1.5</strong> to <strong>PHP 5.3.14</strong>. Therefore, we are going to keep under consideration PHP 4.4.9 and one random version of PHP 5 that falls in the version interval specified above.</p>

<p><strong>PHP 4.4.9 output:</strong> <code>1505335290</code></p>

<p>I don't think this is rule-breaking; Since this appears to be a bug, the output <strong>should</strong> be the same, but it's not. Our other PHP version will simply skip the <code>srand()</code> function and output a random number.</p>
</div>
<div id="pu17" class="pu"><h2><strong>C++98/11 - &quot;Better&quot; Scoring (115 characters - 115 unique character differences in output = score of 0)</strong></h2>

<p><strong>A slightly edited version to comply to the new scoring rules</strong></p>
<p>Golfed:</p>
<pre class="lang-cpp prettyprint-override"><code>#include&lt;cstdio&gt;
#define u8 &quot;\x0B&quot;
int main(){int i=116;char c[i];c[--i]=0;while(i--&gt;0)c[i]=u8&quot;\x7E&quot;[0]+i;puts(c);}
</code></pre>
<p>Ungolfed version:</p>
<pre class="lang-cpp prettyprint-override"><code>#include &lt;cstdio&gt;
#define u8 &quot;\x0B&quot;
int main() {
    int i = 116;
    char c[i];
    c[--i] = 0;

    while(i-- &gt; 0)
        c[i] = u8&quot;\x7E&quot;[0] + i;

    puts(c);
}
</code></pre>
<p>The new solution doesn't differ much to the old one. In the new solution the output in both C++11 and C++98 is with 116 characters equally long, but the only character they have in common is the new line character appended by the puts function.</p>
<p>For C++98 the <code>u8</code> in <code>u8&quot;\x7E&quot;[0]</code> will still be replaced, but now with <code>&quot;\x0B&quot;</code>. So the resulting value after preprocessing will be <code>&quot;\x0B&quot;&quot;\x7E&quot;[0]</code>. The two strings will be concatenated to <code>&quot;\x0B\x7E&quot;</code> and the subscript operator will access the first element, in this case the character with the value 11 in the character encoding. Additionally the value of <code>i</code> will be added, which intially is 114. So the character with the value 125 will be written to the resulting array. As <code>i</code> goes to zero all values from 125 to 11 will be written to the array and <code>puts</code> will print all characters with the values from 11 to 125, plus the trailing new line.</p>
<p>In C++11 <code>u8&quot;\x7E&quot;[0]</code> will be interpreted as an UTF-8 string consisting of the single character with the hexadecimal value 7E. The subscript operator will now access this character and the value of <code>i</code> is added to it, resulting in the decimal value 241 during the first iteration. While <code>i</code> goes to zero, all the values down to 126 will be written to the array and <code>puts</code> will print the characters with the values from 126 to 241, plus the trailing new line.</p>
<p>Depending on the used character set, this will produce different results, as most character sets only have the first 128 characters in common.</p>
<p>For ISO-8859-2 the output would be the following:</p>
<p>C++98:
<img src="https://i.sstatic.net/q5vU3.png" alt="Output for C++98" /></p>
<p>C++11:
<img src="https://i.sstatic.net/BGGYy.png" alt="Output for C++11" /></p>
<p><strong>C++ (106 characters - 107 difference in output = score of -1) (OLD RULES)</strong></p>
<p>Golfed:</p>
<pre class="lang-cpp prettyprint-override"><code>#include&lt;cstdio&gt;
#define u8 &quot;f&quot;
int main(){int i=108;char c[i];c[--i]=0;while(i--&gt;0)c[i]=u8&quot;&quot;[0];puts(c);}
</code></pre>
<p>Ungolfed version:</p>
<pre class="lang-cpp prettyprint-override"><code>#include &lt;cstdio&gt;
#define u8 &quot;f&quot;

int main() {
    int i = 108;
    char c[i];
    c[--i] = 0;

    while(i-- &gt; 0)
            c[i] = u8&quot;&quot;[0];

    puts(c);
}
</code></pre>
<p>Compiled with <code>g++ -std=c++98 main.cpp</code> and <code>g++ -std=c++11 main.cpp</code>.</p>
<p>Actually you can replace <code>108</code> with any positive number in integer range to achieve negative scores. As long as it's bigger than 108 ;)</p>
<p>In C++98 <code>#define u8 &quot;f&quot;</code> will cause the preprocessor to replace <code>u8&quot;&quot;[0]</code> with <code>&quot;f&quot;&quot;&quot;[0]</code>. This will result in <code>&quot;f&quot;[0]</code>, which finally becomes the single character <code>'f'</code>, which is written to an array.</p>
<p><code>puts(c)</code> will print the resulting array, consisting of i-1 <code>'f'</code>.</p>
<p>In C++11 <code>u8&quot;&quot;[0]</code> will cause the empty string to be interpreted as an UTF-8 string, so no string concatenation is done.
As this is a C-string, the subscript operator will access the terminating null-byte and write it to an array.</p>
<p>In the end <code>puts(c)</code> will print the resulting array, which consists only of null-bytes. But as <code>puts</code> stops reading the input as soon as it encounters a null-byte, it will only print a newline and nothing more.</p>
</div>
<div id="pu18" class="pu"><h1>PHP: −134217684 (43 - 134217727)</h1>
<pre><code>echo str_pad(&quot;&quot;,ip2long(&quot;&quot;)&amp;0x7ffffff,&quot;a&quot;);
</code></pre>
<p>Usage:</p>
<pre><code>time php -r 'echo str_pad(&quot;&quot;,ip2long(&quot;&quot;)&amp;0x7ffffff,&quot;a&quot;);' &gt; /tmp/test
1.61user 0.17system 0:01.79elapsed 99%CPU (0avgtext+0avgdata 142272maxresident)k
0inputs+0outputs (0major+35922minor)pagefaults 0swaps
</code></pre>
<p>In PHP5+ this will print nothing since ip2long with invalid argument turns into false which casts to zero. In PHP4 it <code>ip2long(&quot;&quot;)</code> returns -1 and we pad the empty string with 128MB og <code>a</code>.</p>
<p>The mask is fitted so that it returns long before the 2 seconds on my machine. If you can't make it in 2s buy better hardware!</p>
<h1>With new rules: 0 (40 - 40. You can't get any closer to zero.)</h1>
<pre><code>echo str_pad(&quot;&quot;,40,chr(97+ip2long(&quot;&quot;)));
</code></pre>
<p>Outputs:</p>
<pre><code>In PHP4: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 
In PHP5: bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
</code></pre>
</div>
<div id="pu19" class="pu"><h1>Ruby, 4 characters + 0 char length difference - 3 unique char difference = score of 1</h1>

<pre><code>p ?d
</code></pre>

<p>On Ruby 1.9, it will print <code>"d"</code>. On 1.8, it prints <code>100</code>.</p>

<p>Explanation: <code>?d</code> is <code>"d"</code> in 1.9 and <code>100</code> (the ASCII code for d) in 1.8. <code>p x</code> is equivalent to <code>puts x.inspect</code>. <code>*</code> is both string repetition and multiplication.</p>

<hr>

<p>"Optimized" version for old scoring:</p>

<h1>Ruby, 8 characters - 999999989 chars difference = score of -999999981</h1>

<pre><code>p ?!*1e9
</code></pre>

<p>Prints <code>33000000000.0</code> for 1.8 and <code>"!!!!!!</code>...<code>!!!"</code> for 1.9. (<code>?!</code> is <code>33</code> in 1.8 and <code>"!"</code> in 1.9, and <code>*</code> is both string repetition and multiplication.)</p>

<p>Really, you could go as far as you wanted with the multiplication, it just depends on how fast your computer is.</p>
</div>
<div id="pu20" class="pu"><h2>Python, -14 Points ( 3 - 17 char length difference = -14)</h2>
<pre><code>2/3
</code></pre>
<p>Python 2 outputs: <code>0</code></p>
<p>Python 3 outputs: <code>0.6666666666666666</code></p>
<h2>Better Scoring version, 5 points (3 + 2 char length difference = 5)</h2>
<pre><code>3/2
</code></pre>
<p>Python 2 outputs: <code>1</code></p>
<p>Python 3 outputs: <code>1.5</code></p>
</div>
<div id="pu21" class="pu"><h2>Powershell, &quot;Better&quot; scoring, -163 (15 - 178 char diff = -163 )</h2>
<pre><code>$PSVersionTable
</code></pre>
<p><strong>Powershell V2</strong></p>
<pre><code>Name                           Value                                                                   
----                           -----                                                                   
CLRVersion                     2.0.50727.5477                                                          
BuildVersion                   6.1.7601.17514                                                          
PSVersion                      2.0                                                                     
WSManStackVersion              2.0                                                                     
PSCompatibleVersions           {1.0, 2.0}                                                              
SerializationVersion           1.1.0.1                                                                 
PSRemotingProtocolVersion      2.1                                                                     
</code></pre>
<p><strong>Powershell V3</strong></p>
<pre><code>Name                           Value                                                                   
----                           -----                                                                   
WSManStackVersion              3.0                                                                     
PSCompatibleVersions           {1.0, 2.0, 3.0}                                                         
SerializationVersion           1.1.0.1                                                                 
BuildVersion                   6.2.9200.16398                                                          
PSVersion                      3.0                                                                     
CLRVersion                     4.0.30319.1022                                                          
PSRemotingProtocolVersion      2.2 
</code></pre>
</div>
<div id="pu22" class="pu"><h1>Befunge, 36 - 378 = -342;  164 - 2576 = -2412</h1>
<pre><code>&quot;v
&quot;&lt;v
&quot; &lt;v
&quot;  &lt;v
&quot;   &lt;v
 &lt;v:,&lt;
 ^_@
</code></pre>
<p>In Befunge 93, this would output 3 spaces, followed by <code>&lt;v</code>, followed by 76 spaces, followed by <code>&lt;v</code>, then 76 space, then <code>&lt;v</code>, then 76 spaces, then <code>&lt;v</code> followed by 77 spaces, then <code>v</code> followed by 78 spaces. Length: <code>3 + 2 + 76 + 2 + 76 + 2 + 76 + 2 + 77 + 1 + 78 = 395</code>This is trivially extendable by adding extra lines similar to the first 5 lines.</p>
<p>In Befunge 98, this would output <code> &lt;v  &lt;v  &lt;v &lt;v  v</code>.</p>
<p>The difference in length: <code>395 - 17 = 378</code>. So the score would have been (by the old rules): <code>-342</code></p>
<p><sub>Note: I could have gotten an even bigger difference if I used <code>.</code> instead of <code>,</code>; the difference would have been <code>-684</code></sub></p>
<hr />
<p>Rule change:</p>
<p>This is a bit more tricky.</p>
<pre><code>&quot;  &quot;-v&gt;&quot;Befunge 93 very long strings&quot;v&gt;&quot;F&quot;0g&quot; &quot;1-`!#v_   &quot;F&quot;0g1-&quot;F&quot;0pvz
     _^p0&quot;F&quot;-1g0&quot;F&quot;_v#    `-1&quot; &quot;g0&quot;F&quot;&lt;^&quot;j++a81zzzzzz]zzzzzzzzzzzzzzz&quot;&lt;
             _@#`0:,&lt;
</code></pre>
<p>Befunge 93 output:</p>
<pre><code>sgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeBsgnirts gnol yrev 39 egnufeB
</code></pre>
<p>Befunge 98 output:</p>
<pre><code>j++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzzj++a81zzzzzz]zzzzzzzzzzzzzzz
</code></pre>
<p>Lengths: <code>2576</code>. None of the characters between the strings are the same, so if I understood the challenge correctly, my score is <code>164 - 2576 = -2412</code> (yes I was supposed to aim for <code>0</code>, but this was more fun). If I need to make it so that each character in each string are unique and different from each other, I can do so, please tell me.</p>
</div>
<div id="pu23" class="pu"><p><strong>Perl, 24 characters - (9*(10^9))-1 char difference = score of -((9*(10^9))-1)+24</strong></p>

<pre class="lang-pl prettyprint-override"><code>print$]&gt;=5?"a":"a"x9e9;
</code></pre>

<p>Prints 9e9-times <code>a</code> for all versions below 5, prints <code>a</code> for all versions above 5. You could make the score infinitely low by just adding more <code>a</code>s to the second output.</p>
</div>
<div id="pu24" class="pu"><h1>Bash 7 (14 bytes program length + 0 difference in output length - 7 difference in unique chars in output)</h1>
<p>Related to @Gilles answer, but a different expansion feature and different versions.  Scoring according to the edited question:</p>
<pre><code>echo {1..9..2}
</code></pre>
<p>Output for bash 3.x:</p>
<pre><code>{1..9..2}
</code></pre>
<p>Output for bash 4.x:</p>
<pre><code>1 3 5 7 9
</code></pre>
</div>
<div id="pu25" class="pu"><h1>Python - 10 points less than the next best answer</h1>
<pre><code>print(range(100))
</code></pre>
<p>In Python 2, this will print the entire list of integers from 0 to 99.</p>
<p>In Python 3, <code>range</code> is a generator and so it will print only &quot;range(0,100)&quot;.</p>
<p>Seeing as I've never run into a size limit on numbers in Python, I can replace that 100 with a much bigger number (2**1000, for example) and end up with a virtually infinite difference in the output.</p>
<p><em>Edited to reflect the fact that, while I can get a score that is infinitely low for any practical purpose, I cannot reach actual infinity with a program that terminates under 2 seconds</em></p>
<p>For the updated tie-breaker scoring system, I'd submit:</p>
<pre><code>print(range(4))
</code></pre>
<p>Output:</p>
<p>Python 2: <code>[0, 1, 2, 3]</code></p>
<p>Python 3: <code>range(0, 4)</code></p>
<p>The first print has 5 unique characters (<code>[123]</code>), the second print has 8 unique characters (<code>range(4)</code>), the difference in length of output is 1, the code has 15 characters, the shortest output is 11 characters... these rules are pretty confusing but I think this brings me to a final score of 15+1-min(11,5+8) = 5.</p>
</div>
<div id="pu26" class="pu"><h2>APL (5 - (1988894 - 1) = -1988888)  </h2>

<p>In old-style APLs (like Dyalog if <code>⎕ML=0</code>*), <code>↑</code> means <em>mix</em>, which, on a 1-dimensional vector does nothing. In APL2-style APLs, like GNU APL, (or Dyalog if <code>⎕ML=3</code>), <code>↑</code> means <em>first</em>, which takes the first item of a vector.</p>

<p>Thus, the following <code>5</code> bytes (the APL charset <em>does</em> fit in a byte), </p>

<pre><code>↑⍳3e5
</code></pre>

<p>will output <code>1988894</code> bytes (the space separated list of numbers from 1 to 3e5) in old-style APL dialects,</p>

<p>and <code>1</code> byte (just the first number in said list, which is <code>1</code> and therefore of length <code>1</code>), in APL2-style APL dialects.</p>

<p>Notes:</p>

<ul>
<li><code>⎕ML</code> means <em>migration level</em>. In Dyalog APL, the higher you set <code>⎕ML</code>, the more APL2-style features are enabled. It defaults to <code>0</code>. (And it's a global variable! Fun!)</li>
<li><code>3e5</code> was the highest 3-character value Dyalog APL would accept with <code>⍳</code>. <code>4e5</code> gave me a <code>LIMIT ERROR</code>. This restriction is probably interpreter-dependent. (GNU APL had no trouble with higher values.)</li>
</ul>
</div>
<div id="pu27" class="pu"><h2>Bash — -∞ (up to practical limits)</h2>

<p>Effectively, however much memory you have. E.g. with about 10GB:</p>

<pre><code>echo {0..999999999}
</code></pre>

<p>Bash 2: doesn't support ranges in brace expansion, so prints <code>{0..999999999}</code>.</p>

<p>Bash 3: </p>

<hr>

<h2>Any language — -∞ (up to practical limits)</h2>

<p>You'll have this in pretty much any language, even if it ends up being a little more complex. As soon as you can make two different values, you can write code that produces arbitrarily different output. A better scoring method would ignore the differences in the output.</p>

<pre><code>version = … # some arbitrarily weird stuff
if version = 2:
    while not timed_out():
        print "version2"
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/25913/">25913</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




