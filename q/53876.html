<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::53876</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>188</td><td>Tcl</td><td>180610T163827Z</td><td><a href="https://codegolf.stackexchange.com/questions/53876/swap-capitalization-of-two-strings/166600#166600">sergiol</a></td></tr>
<tr d-ix="1"><td>152</td><td>R</td><td>240409T115805Z</td><td><a href="https://codegolf.stackexchange.com/questions/53876/swap-capitalization-of-two-strings/272422#272422">Patric</a></td></tr>
<tr d-ix="2"><td>091</td><td>Haskell</td><td>180610T175449Z</td><td><a href="https://codegolf.stackexchange.com/questions/53876/swap-capitalization-of-two-strings/166603#166603">Angs</a></td></tr>
<tr d-ix="3"><td>097</td><td>Python 2</td><td>180602T224317Z</td><td><a href="https://codegolf.stackexchange.com/questions/53876/swap-capitalization-of-two-strings/166036#166036">Chas Bro</a></td></tr>
<tr d-ix="4"><td>013</td><td>Jelly</td><td>180602T215610Z</td><td><a href="https://codegolf.stackexchange.com/questions/53876/swap-capitalization-of-two-strings/166033#166033">Jonathan</a></td></tr>
<tr d-ix="5"><td>138</td><td>First attempt in scala</td><td>161116T133930Z</td><td><a href="https://codegolf.stackexchange.com/questions/53876/swap-capitalization-of-two-strings/100047#100047">user4710</a></td></tr>
<tr d-ix="6"><td>153</td><td>C   153 Bytes  GCC</td><td>150727T175043Z</td><td><a href="https://codegolf.stackexchange.com/questions/53876/swap-capitalization-of-two-strings/53924#53924">Ray C</a></td></tr>
<tr d-ix="7"><td>099</td><td>Perl 5.10+</td><td>150730T192908Z</td><td><a href="https://codegolf.stackexchange.com/questions/53876/swap-capitalization-of-two-strings/54081#54081">ThisSuit</a></td></tr>
<tr d-ix="8"><td>126</td><td>C</td><td>150727T165713Z</td><td><a href="https://codegolf.stackexchange.com/questions/53876/swap-capitalization-of-two-strings/53914#53914">Vartan</a></td></tr>
<tr d-ix="9"><td>102</td><td>Ruby</td><td>150728T053547Z</td><td><a href="https://codegolf.stackexchange.com/questions/53876/swap-capitalization-of-two-strings/53949#53949">Not that</a></td></tr>
<tr d-ix="10"><td>101</td><td>Python 2</td><td>150728T052844Z</td><td><a href="https://codegolf.stackexchange.com/questions/53876/swap-capitalization-of-two-strings/53948#53948">Sp3000</a></td></tr>
<tr d-ix="11"><td>155</td><td>Mathematica</td><td>150727T220426Z</td><td><a href="https://codegolf.stackexchange.com/questions/53876/swap-capitalization-of-two-strings/53937#53937">Eric Tow</a></td></tr>
<tr d-ix="12"><td>427</td><td>SQL PostGreSQL</td><td>150728T002359Z</td><td><a href="https://codegolf.stackexchange.com/questions/53876/swap-capitalization-of-two-strings/53944#53944">MickyT</a></td></tr>
<tr d-ix="13"><td>131</td><td>Python 3</td><td>150727T103110Z</td><td><a href="https://codegolf.stackexchange.com/questions/53876/swap-capitalization-of-two-strings/53892#53892">Beta Dec</a></td></tr>
<tr d-ix="14"><td>018</td><td>Pyth</td><td>150727T134004Z</td><td><a href="https://codegolf.stackexchange.com/questions/53876/swap-capitalization-of-two-strings/53898#53898">Dennis</a></td></tr>
<tr d-ix="15"><td>164</td><td>C</td><td>150727T162723Z</td><td><a href="https://codegolf.stackexchange.com/questions/53876/swap-capitalization-of-two-strings/53911#53911">Cole Cam</a></td></tr>
<tr d-ix="16"><td>108</td><td>JavaScript ES6</td><td>150727T062513Z</td><td><a href="https://codegolf.stackexchange.com/questions/53876/swap-capitalization-of-two-strings/53881#53881">Downgoat</a></td></tr>
<tr d-ix="17"><td>181</td><td>C</td><td>150727T151625Z</td><td><a href="https://codegolf.stackexchange.com/questions/53876/swap-capitalization-of-two-strings/53907#53907">LambdaBe</a></td></tr>
<tr d-ix="18"><td>126</td><td>Python</td><td>150727T144007Z</td><td><a href="https://codegolf.stackexchange.com/questions/53876/swap-capitalization-of-two-strings/53905#53905">Blue</a></td></tr>
<tr d-ix="19"><td>140</td><td>Matlab</td><td>150727T142016Z</td><td><a href="https://codegolf.stackexchange.com/questions/53876/swap-capitalization-of-two-strings/53904#53904">Luis Men</a></td></tr>
<tr d-ix="20"><td>211</td><td>F#</td><td>150727T140617Z</td><td><a href="https://codegolf.stackexchange.com/questions/53876/swap-capitalization-of-two-strings/53903#53903">mike m</a></td></tr>
<tr d-ix="21"><td>157</td><td>Erlang</td><td>150727T120906Z</td><td><a href="https://codegolf.stackexchange.com/questions/53876/swap-capitalization-of-two-strings/53894#53894">c.P.u1</a></td></tr>
<tr d-ix="22"><td>140</td><td>Julia</td><td>150727T051916Z</td><td><a href="https://codegolf.stackexchange.com/questions/53876/swap-capitalization-of-two-strings/53879#53879">Alex A.</a></td></tr>
<tr d-ix="23"><td>025</td><td>CJam</td><td>150727T041947Z</td><td><a href="https://codegolf.stackexchange.com/questions/53876/swap-capitalization-of-two-strings/53877#53877">Dennis</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="http://tcl.tk/" rel="nofollow noreferrer">Tcl</a>, 188 bytes</h1>
<pre><code>proc C a\ b {proc L x\ y {expr {[[set S string] is u $y]?[$S tou $x]:[$S is lo $y]?[$S tol $x]:$x}}
lmap x [split $a &quot;&quot;] y [split $b &quot;&quot;] {append s [L $x $y]
append t [L $y $x]}
list $s $t}
</code></pre>
<p><a href="https://tio.run/##XVDLToRAELzPV1QI8eYBNTHxYhA2HhZd494EDsMOsEgDIzMoLOHbccBHjH2q6kpXd7U@0DzLtjnAA4@QYFxJgD7CgDHtZYsxDFWqsYfSbVHnMQqFDvYQ34b2HroxuI9vFmwEav4otCp2P02MKi7RI1SSCg2bw7Jis@GHJysfuZRpLaAQBmZ0cWLfLb22hsXQmBXKzCjYeppX46/TmXvn@ZssPxavW3qod/KtVbp7/@iHE@P/6vy3GLOenpu85VVVPN5DdqeXIFU4g7fzU@QNZRbbCyqPZcaJC9oqQZxKJfJrEiX5uSLGXNdNksRxHOYdLnxxuUmv2GSe2WmTxVvy2kkc1dP8CQ" rel="nofollow noreferrer" title="Tcl – Try It Online">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.r-project.org" rel="nofollow noreferrer">R</a>, 152 bytes</h1>
<pre class="lang-r prettyprint-override"><code>\(x){'?'=\(j)strsplit(x,&quot;&quot;)[[j]];s=casefold;'-'=\(a)!a==s(a)&amp;a==s(a,T);do.call(paste0,Map(\(j)c(a=s(a&lt;-(?1)[j],-(b&lt;-(?2)[j])),b=s(b,-a)),1:length(?1)))}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=bVHbTsJAEI2vfEXdB9glW2PBRAM0pFJiFLkE4UXwYdtty2Voa7fVivE_THxBEz9Kv8ZtSpSo8zJzcuacmcy8vEabN1d_T2JXPfl4nuKUPJaaJX2KF0TEkQhhHuOUIkQmk8XNTV3oNhOOGwCvl9SsjZF9putC5mKe6YjUeXBgMwAcMhE7h7TLQpwZ2phlHQ0VNzUi7aiKrQxUMkAItSRrUZXJUquB43vxLOsk5Cnf73NvyCKvocJcxLhgY2Sctsy2683miw50_X54G4k4ubtPH9aIIvYr1O9AhGbqwTDwIrZazXtnSpisry8doRSVVt90FC8AV1pccVjOli4DxqEjODBYCu4dA1-C6QnY-hiGYVmWpmlS0bIrJq-2naMfTqtU5XTJGZbNHbntBSKk4CcAen6YlNgsxqi8E1O_XFbOe4PxqKbkaJeb-ojKn2RF-Y-qPx79K9vqXDkul8oN5TVJftrNJs9f" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Still larger than the most answers here. Takes in a vector of strings, outputs a vector of two strings.</p>
<p>Function definitions:</p>
<pre><code>s=casefold                     # alias: generic function for upper-/lowercase transformation
'?'=\(j)strsplit(x,&quot;&quot;)[[j]]    # splitting the strings into characters
\(a)a==s(a)                    # boolean: TRUE if a is lowercase, FALSE if not
\(a)a==s(a,T)                  # boolean: TRUE if a is uppercase, FALSE if not
                               # (both return TRUE if a is not a letter)
                               #### Inside of the Map-call: ####
c(a=s((a&lt;-(?1)[j]),(!-(b&lt;-(?2)[j]))&amp;+b),b=s(b,(!-a)&amp;+a)
                               # redefine the characters based on the boolean outputs
</code></pre>
<p>Finally, the combination of <code>do.call</code> + <code>paste0</code> combines a list of vectors of characters into strings along the y-axis (vertically)</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, <s>109</s> 91 bytes</h1>



<pre class="lang-hs prettyprint-override"><code>import Data.Char
(!)=zipWith f
f c|isUpper c=toUpper|isAlpha c=toLower|1&lt;3=id
a#b=[b!a,a!b]
</code></pre>

<p>Thanks to @Laikoni for 16 bytes!</p>

<p><a href="https://tio.run/##XYxBS8NAEIXv@RWTFKSFKsQKXppDTIqHplYsIrQUmc0m2TWTZN3dWg3973FpwYPvMo9veJ9AUxdEwyAb1WkLKVq8SQRqb@xPol6qN2kFlF4J@UmaV6UKDXlku3NzJCYl8Eyy7uhIOJ9Fkns4YtGO@ThFn@2HBmULETSoVu8wvhx1sBurs3biwQ6C@CFJF2Ul5MeSVu1afWpjD1/H758@GAX4L9d/CTyYQvD80lUam0Y@PTptv80KA1eQrNMCqo5KZ9hwqkVdIiGnpeGEVBte3ROvKa0MXTRxHDPGwjB0gyS/TflsUdy51374BQ" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
</div>
<div id="pu3" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>, 97 bytes</h1>



<pre class="lang-python prettyprint-override"><code>lambda a,b:''.join([x,chr(ord(x)&amp;95|ord(y)&amp;32)][(x+y).isalpha()]for x,y in zip(a+'\n'+b,b+' '+a))
</code></pre>

<p><a href="https://tio.run/##XZDBT8IwFMbP@lf0RNtskjA0RhIPY1t2QGTBmBiBQ0vXraysswPpFv/3SZ148J2@933v/Q5f1RxyVXodf1x3kuwpI4C4dALhcKdEiVbG3eYaKc2QwYOHuy@rGjwYe3izQsZp8FDURFY5QXjDlQbGbYAoQSsqRBy4LqFDXepAAB2CcWcvznh7sULQnwZhxLNc7GZyXi6qD10fjp8n07TQBZD8m5u/gdgFCCZLlWmy34vnGFTH9v0prcEABIswBZmS3CJemCzyghNJmJzVTBJZ1Cy7l6yQYVbLnuP7PqV0NBrZj2DrhWwcpbd9FiiWxmfYT2ZMkgSxZ0yfSXVKtfVfkyRa9t5cvKWh9fqw59vd/9XTLbNrxOMc4s3k@qrSojwAchH0Ijg694Rd22D3DQ" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 13 <a href="https://github.com/DennisMitchell/jelly/wiki/Code-page" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>=Œu=/ị&quot;Ɱż&quot;Œs$
</code></pre>
<p>A monadic Link accepting and returning lists of two &quot;strings&quot; (lists of characters in Jelly).</p>
<p><strong><a href="https://tio.run/##ATUAyv9qZWxsef//PcWSdT0v4buLIuKxrsW8IsWScyT/4bu0w4dZ//9Db2RlR29sZgp4eFBQQ0d4eA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></strong></p>
</div>
<div id="pu5" class="pu"><h1>First attempt in scala, 138 chars</h1>

<pre><code>def f(s:String,t:String)={val g=(a:Char,o:Char)=&gt;if(o.isUpper)a.toUpper else a.toLower;s.zip(t).map(c=&gt;(g.tupled(c),g(c._2, c._1))).unzip}
</code></pre>

<p>f is a function that take the two input strings and do the job, with a local function, used two times, for changing case of strings.</p>

<p>The same code, with indentation and just a litte more readable names :</p>

<pre><code>def f_ungolfed(first : String, second : String) = {
  val aux = (c1: Char, c2: Char) =&gt; if (c2.isUpper) c1.toUpper else c1.toLower
    first.zip(second).map(
         c =&gt; (aux.tupled(c), aux.tupled(c.swap))
    ).unzip
} 
</code></pre>
</div>
<div id="pu6" class="pu"><h1>C - <s>164</s> 153 Bytes - GCC</h1>

<pre><code>#define r z[_][w]
main(_,z,w)char**z;{while(--_)for(w=0;r;r+=r&lt;25?97:r&lt;91&amp;&amp;r&gt;64?z[!(_-1)+1][w]-=32,_-1?z[_-1][w]-=97:0,32:0,w++);puts(z[1]),puts(z[2]);}
</code></pre>

<p>gcc prog.c</p>

<p>./a.out AfdgF a2dfsd</p>

<p>Will update if I can get wc -c down. Works very well actually</p>
</div>
<div id="pu7" class="pu"><h1>Perl 5.10+, <strike>101</strike> 99 bytes</h1>

<pre><code>perl -p00e '/\n/;s/([a-z])(?=.{$-[0]}([a-z]))/$x=($1^$2)&amp;" ";$s{$-[2]}=$2^$x;$1^$x/egis;s|.|$s{$-[0]}//$&amp;|eg'
</code></pre>

<p>96 bytes + 3 bytes for the command line flags <code>p00</code>. Takes a single newline-delimited string as input:</p>

<pre><code>$ echo -e "AAAbbb111\nCc2Dd3Ee4" | perl -p00e '...'
</code></pre>

<p>Or you can enter input on STDIN:</p>

<pre><code>$ perl -p00e '...'
AAAbbb111 &lt;Enter&gt;
Cc2Dd3Ee4 &lt;Ctrl+D&gt;
</code></pre>

<h2>Broken down:</h2>

<pre><code>perl -p00e'  # Slurp everything into $_, print $_ automatically at the end
    /\n/;    # Match first newline, setting $-[0] to length(s1)

    s/
        ([a-z])  # Match a single letter in s1
        (?=
            .{$-[0]}  # Match n chars where n is length(s1) (until corresponding char in s2)
            ([a-z])   # Corresponding letter in s2
        )
    /
        $x=($1^$2)&amp;" ";   # Check whether bit 6 is the same for both chars.
                          # (Only difference between a lowercase and uppercase ASCII letter
                          # is bit 6; ASCII space is 100000 in binary)

        $s{$-[2]}=$2^$x;  # Swap case of corresponding char in s2 and store in %s,
                          # with position as the key

        $1^$x             # Swap case of current char
    /egis;

    s|.|$s{$-[0]}//$&amp;|eg  # Do a second pass through $_. If there's a value stored in %s
                          # corresponding to this position, use it
'
</code></pre>
</div>
<div id="pu8" class="pu"><h1>C, 126 bytes</h1>

<p>This is my first attempt at a code golf, ever. Let me know if I did anything wrong.</p>

<p>I'm using bitwise operations to perform the switching</p>

<p>Golfed:
</p>

<pre class="lang-c prettyprint-override"><code>main(u,a,s,t)char**a,*s,*t;{for(s=a[1],t=a[2];*t;s++,t++)isalpha(*s)*isalpha(*t)?u=(*t^*s)&amp;32,*t^=u,*s^=u:0;*s=10;puts(a[1]);}
</code></pre>

<p>Ungolfed:</p>

<pre class="lang-c prettyprint-override"><code>main(u,a,s,t) char**a,*s,*t; {       // K&amp;R style arguments
    for(s=a[1],t=a[2];*t;s++,t++)    // initialize loop.
        isalpha(*s) * isalpha(*t) ? // ensure both characters are letters (if)
            u = (*t^*s) &amp; 0x20,      // check if characters have swapped case
            *t^=u,                   // if so, xor the bit which represents case
            *s^=u                    // for both characters in the string.
        :0;                          // end ternary statement (endif)
    *s=10;                           // replace null terminator in first string 
    puts(a[1]);                      // with newline. This allows both output to 
}                                    // be printed out all at once
</code></pre>

<p>edit: replaced &amp;&amp; with *</p>
</div>
<div id="pu9" class="pu"><h2>Ruby, 102</h2>
<pre><code>$&gt;&lt;&lt;gets.chars.zip(gets.chars).map{|i|/[a-z][A-Z]|[A-Z][a-z]/=~i*''?(i.map &amp;:swapcase):i}.transpose*''
</code></pre>
<p>Takes the original strings, pairs off letters in arrays. If they are either lower/cap or cap/lower, then swapcase on both. Then transpose the arrays back into our ordered array.</p>
<p>This requires a trailing newline in input.</p>
</div>
<div id="pu10" class="pu"><h1>Python 2, 101 bytes</h1>
<pre class="lang-py prettyprint-override"><code>lambda*I:[&quot;&quot;.join([a.upper(),a.lower(),a][~-b.isalpha()or&quot;Z&quot;&lt;b]for a,b in zip(*X))for X in I,I[::-1]]
</code></pre>
<p>An anonymous function which takes two strings and returns the output strings in a list. I've marked this as Python 2 because Python 3 doesn't allow <code>I,I[::-1]</code> to sit alone at the end like that.</p>
</div>
<div id="pu11" class="pu"><h2>Mathematica, <s>173</s> <s>169</s> 155 bytes</h2>

<pre><code>f=0&gt;1;t=!f;c=Characters;u=ToUpperCase;StringJoin/@MapThread[#@#2&amp;,{Reverse[{LetterQ@#,#==(u@#)}&amp;/@c@#/.{{f,_}-&gt;(#&amp;),{t,t}-&gt;u,{t,f}-&gt;ToLowerCase}&amp;/@#],c/@#},2]&amp;
</code></pre>

<p>This is a function taking an array of two strings, e.g. <code>{"Foo","bAR"}</code> and outputting an array of two strings.  Un-spatially-compressing it, rewriting the scheme <code>f@x</code> as <code>f[x]</code> wherever it appears, expanding the notation abbreviations (<code>f=0&gt;1</code> a.k.a. <code>False</code>,<code>t=!f</code> a.k.a. <code>True</code>, <code>c=Characters</code>, and <code>u=ToUpperCaseQ</code>), and un-replacing UpperCaseQ[#] with <code>#==u@#</code> (this character equals its uppercased version), it is:</p>

<pre><code>StringJoin /@ MapThread[#[#2] &amp;, {
    Reverse[
        { LetterQ[#], UpperCaseQ[#] } &amp; /@ Characters[#] /. 
        { {False, _} -&gt; (# &amp;), {True, True} -&gt; ToUpperCase, 
          {True, False} -&gt; ToLowerCase } &amp; /@ #
    ],
    Characters /@ #
}, 2] &amp;
</code></pre>

<p>Interfacing:  the trailing <code>&amp;</code> makes this a function.  Its argument is inserted as the "#" at both instances of <code>/@ #</code>.  For instance <code>f=0&gt;1; ... &amp; [{"AAAbbb111", "Cc2Dd3Ee4"}]</code> produces the output <code>{AaABbb111,CC2dd3Ee4}</code>.</p>

<p>Processing:  Told in usual outside in order:</p>

<ul>
<li>The output of the <code>MapThread[...]</code> is a list of two lists of characters.  StringJoin is applied to each of these two lists of characters to produce a list of two strings, the output.</li>
<li><code>MapThread[#[#2]&amp;, ... , 2]</code> acts on an array of two 2-by-n element lists.  The first list is a 2-by-n array of functions.  The second list is a 2-by-n array of characters, <code>Characters /@ #</code>, the lists of characters in the two input strings.  It works at depth 2, i.e., on the functions and individual characters.</li>
<li><code>Reverse[...]</code> swaps the two sublists of functions so that MapThread will apply the second string's functions to the first string and vice versa.</li>
<li><code>{ ... } &amp;</code> is an anonymous function that is applied to each of the two input strings.</li>
<li><code>{LetterQ[#], UpperCaseQ[#]} &amp; /@ Characters[#]</code> splits a string into a list of characters, then replaces each character with two element lists.  In these two element lists, the first element is <code>True</code> if the character is a letter and <code>False</code> otherwise, similarly, the second element indicates whether the character is upper case.  <code>UpperCaseQ[]</code> cannot return true if it does not receive a letter.</li>
<li><code>/. {{False, _} -&gt; (# &amp;), {True, True} -&gt; ToUpperCase, {True, False} -&gt; ToLowerCase}</code> replaces these two element lists with functions.  (Expansion of the abbreviations <code>t</code> and <code>f</code> occurs before any matching is attempted.)  If a two element list has <code>False</code> as its first element, it is replaced with the function <code>(# &amp;)</code>, the identity function.  (The parentheses are necessary, otherwise the arrow binds more tightly than the ampersand.)  Otherwise the two element list starts with <code>True</code>, the character was a letter, and we output the functions <code>ToUpperCase</code> and <code>ToLowerCase</code> corresponding to its case.  (Checking for this last <code>False</code> is unnecessary, in fact <code>{_,_}-&gt;ToLowerCase</code> would work, catching anything that hadn't been replaced yet, but this would be no shorter and more obscure.)</li>
</ul>

<p>The only challenge was figuring out a succinct way to zip a two dimensional array of functions to an array of arguments.</p>

<p>Edit:  Thanks to @Martin Büttner for catching "helpful" cut/paste linebreak backslashes, the <code>1&gt;0</code> and <code>1&lt;0</code> abbreviations, and also for the guidance to count length in bytes not characters (whatever those are :-) )</p>

<p>Edit2:  Further thanks to @Martin Büttner for pointing out that polluting the global namespace is acceptable golf, reminding me of one character function application, and suggesting replacing the two uppercase functions with an abbreviation for one and using the one to emulate the other (saving four characters).  (I think he's done this before.  :-)  )</p>
</div>
<div id="pu12" class="pu"><h1>SQL (PostGreSQL), 427 Bytes</h1>

<p>Despite it's huge size, this ended up being quite a bit smaller than I expected.  I wasn't quite sure I was going to be able to do it to be honest.  I suspect there is a lot that still can be done:)</p>
<pre class="lang-sql prettyprint-override"><code>CREATE FUNCTION F(TEXT,TEXT)RETURNS TABLE(S TEXT) AS'SELECT unnest(array[string_agg(CASE WHEN T~''[A-Z]''THEN upper(S)WHEN T~''[a-z]''THEN lower(S)ELSE S END,''''),string_agg(CASE WHEN S~''[A-Z]''THEN upper(T)WHEN S~''[a-z]''THEN lower(T)ELSE T END,'''')])FROM(SELECT ROW_NUMBER()OVER()N,S FROM regexp_split_to_table($1,'''')X(S))A JOIN(SELECT ROW_NUMBER()OVER()M,T FROM regexp_split_to_table($2,'''')Y(T))B ON N=M'LANGUAGE SQL
</code></pre>
<p>Formatted and commented</p>
<pre class="lang-sql prettyprint-override"><code>-- Declare the function spec
CREATE FUNCTION F(TEXT,TEXT)RETURNS TABLE(S TEXT) AS  
'SELECT unnest(   -- turns array into a table
    array[        -- build array of the column results
    string_agg( -- Aggregate the result into a string
        CASE 
        WHEN T~''[A-Z]''THEN upper(S) -- uppercase it if corresponding char is uppercase
        WHEN T~''[a-z]''THEN lower(S) -- lowercase it if corresponding char is lowercase
        ELSE S END
        ,''''),
    string_agg( -- Same as the previous but swap strings
        CASE 
        WHEN S~''[A-Z]''THEN upper(T)
        WHEN S~''[a-z]''THEN lower(T)
        ELSE T END
        ,'''')
    ])
FROM
    -- split the first string
   (SELECT ROW_NUMBER()OVER()N,S FROM regexp_split_to_table($1,'''')X(S))A
    JOIN
    -- split the second string
   (SELECT ROW_NUMBER()OVER()M,T FROM regexp_split_to_table($2,'''')Y(T))B 
   ON N=M
'
LANGUAGE SQL
</code></pre>
<p>Test run</p>
<pre class="lang-sql prettyprint-override"><code>SELECT F(A,B) AS Result
FROM (VALUES 
    ('AAAbbb111', 'Cc2Dd3Ee4'), 
    ('ABCDEfghijKlMnOpqrstuvwxyz', 'aaaaaaaaaaaaaaaa----------'), 
    ('PRogrammiNG puzZLes &amp; CODe golf', 'SdlkhkfaladlKsdlalksdg7ldklDgsl')
    )A(A,B)

Result
-----------------------------
AaABbb111
CC2dd3Ee4
abcdefghijklmnopqrstuvwxyz
AAAAAaaaaaAaAaAa----------
Programming Puzzles &amp; Code Golf
SDlkhkfalADlksdLAlksdg7LDkldgsl
</code></pre>
</div>
<div id="pu13" class="pu"><h1>Python 3, 131 bytes</h1>



<pre class="lang-python prettyprint-override"><code>def j(s,g):p=lambda s,g:''.join(i.upper()if j.istitle()else i.lower()if j.islower()else i for i,j in zip(s,g));return p(s,g),p(g,s)
</code></pre>

<p>Function returns strings in a tuple</p>
</div>
<div id="pu14" class="pu"><h1>Pyth, <s>19</s> 18 bytes</h1>

<pre><code>LCmrW&amp;@dG@drG1d2Cb
</code></pre>

<p>This defines a function <strong>y</strong> that accepts and return a list of strings.</p>

<p>Verify all test cases at once in the <a href="https://pyth.herokuapp.com/?code=LCmrW%26%40dG%40drG1d2Cb%0A%0Ajb%2BFmydc.z2&amp;input=ABCDEfghijKlMnOpqrstuvwxyz%0Aaaaaaaaaaaaaaaaa----------%0APRogrammiNG+puzZLes+%26+CODe+golf%0ASdlkhkfaladlKsdlalksdg7ldklDgsl%0AAAAbbb111%0ACc2Dd3Ee4&amp;debug=0" rel="noreferrer">Pyth Compiler/Executor</a>.</p>

<p><em>Thanks to @Jakube for golfing off 1 byte.</em></p>

<h3>How it works</h3>

<pre><code>                   " (implicit) Initialize G to 'abcdefghijklmnopqrstuvwxyz'.

L                  " Define y(b):
                Cb "   Zip to turn the two strings into an array of char pairs.
  m                "   Map (implicit variable d):
      @dG          "     Intersect d with G.
         @drG1     "     Intersect d with G.upper().
    W&amp;             "     If both are non-empty:
   r          d2   "       Apply swapcase() to d.
 C                 "   Zip to turn the character pairs back into two strings.
</code></pre>
</div>
<div id="pu15" class="pu"><h1>C, 164 bytes</h1>

<p>Pretty much implementing the algorithm as described in the problem. Takes 2 strings as input parameters.</p>

<pre><code>char*a,*b;main(c,v)char**v;{for(a=v[1],b=v[2];*a&amp;&amp;*b;++a,++b)isupper(*a)&amp;&amp;islower(*b)?*a+=32,*b-=32:isupper(*b)&amp;&amp;islower(*a)?*b+=32,*a-=32:0;puts(v[1]);puts(v[2]);}
</code></pre>

<p>Ungolfed:</p>

<pre><code>char *a, *b; /* Helpers */

main(c, v)
char **v;
{
    /* While strings not terminated... */
    for (a = v[1], b = v[2]; *a &amp;&amp; *b; ++a, ++b)
        isupper(*a) &amp;&amp; islower(*b)
            ? *a += 32, *b -= 32 /* Make first string lowercase, second uppercase */
            : isupper(*b) &amp;&amp; islower(*a)
                ? *b += 32, *a -= 32; /* Make second string lowercase, first uppercase */

    puts(v[1]); /* print out first string */
    puts(v[2]); /* print out second string */
}
</code></pre>
</div>
<div id="pu16" class="pu"><h1>JavaScript ES6, <s>128</s> 108 bytes</h1>

<pre><code>s=(a,b,t)=&gt;[...a].map((l,i)=&gt;/[^a-z]/.exec(b[i])?l.toUpperCase():l.toLowerCase()).join``+(t?'':`
`+s(b,a,1))
</code></pre>

<p>JavaScript's <code>toUpperCase()</code> and <code>toLowerCase()</code> take up a lot of bytes but <code>String.fromCharCode()</code> is even longer</p>
</div>
<div id="pu17" class="pu"><h1>C, 181 bytes</h1>
<pre><code>char*x,*y;main(int a,char**_){a?x=_[2],y=_[1],main(0,0),putchar(10),x=_[1],y=_[2],main(0,0):(*x?putchar(!isupper(*x)?!islower(*x)?*y:tolower(*y):toupper(*y)),x++,y++,main(0,0):0);}
</code></pre>
<p>Had trouble shortening standard library names in a worthwhile way, (#define'ing them takes 11 characters of overhead). Uses main recursion and global variables x and y as arguments.</p>
<p>main(&lt;non-zero&gt;,argv) = call main(0,{argv[1],argv[2]}) then print newline then call main(0,{argv[2],argv[1]})</p>
<p>main(0,{x,y}) = if x is end of string return 0, else print correct case of first character of x and call main(0,{x+1,y+1}).</p>
<p>Run with the two strings as arguments.</p>
</div>
<div id="pu18" class="pu"><h1>Python, 126 bytes</h1>



<pre class="lang-python prettyprint-override"><code>t="".join;s="low","upp";y=lambda a,b:eval("a"+".%ser()"%s[b.isupper()]*b.isalpha());f=lambda a,b:(t(map(y,a,b)),t(map(y,b,a)))
</code></pre>

<p>Function <code>f</code> returns strings in a tuple</p>
</div>
<div id="pu19" class="pu"><h2>Matlab, 140</h2>

<pre><code>function [s,t]=f(s,t)
c=s&gt;96&amp;s&lt;123;C=s&gt;64&amp;s&lt;91;d=t&gt;96&amp;t&lt;123;D=t&gt;64&amp;t&lt;91;s(c&amp;D)=s(c&amp;D)-32;s(C&amp;d)=s(C&amp;d)+32;t(d&amp;C)=t(d&amp;C)-32;t(D&amp;c)=t(D&amp;c)+32;
</code></pre>

<p>Ungolfed:</p>

<pre><code>function [s,t] = f(s,t)
c = s&gt;96 &amp; s&lt;123;         % letters that are lowercase in 1st string
C = s&gt;64 &amp; s&lt;91;          % letters that are uppercase in 1st string
d = t&gt;96 &amp; t&lt;123;         % letters that are lowercase in 2nd string
D = t&gt;64 &amp; t&lt;91;          % letters that are uppercase in 2nd string
s(c&amp;D) = s(c&amp;D) - 32;     % make uppercase in 1st string
s(C&amp;d) = s(C&amp;d) + 32;     % make lowercase in 1st string
t(d&amp;C) = t(d&amp;C) - 32;     % make uppercase in 2nd string
t(D&amp;c) = t(D&amp;c) + 32;     % make lowercase in 2nd string
</code></pre>

<p>Example:</p>

<pre><code>&gt;&gt; [s,t]=f('PRogrammiNG puzZLes &amp; CODe golf','SdlkhkfaladlKsdlalksdg7ldklDgsl')
s =
Programming Puzzles &amp; Code Golf
t =
SDlkhkfalADlksdLAlksdg7LDkldgsl
</code></pre>
</div>
<div id="pu20" class="pu"><h1>F#, 211 chars</h1>

<pre><code>let n x y=List.fold2(fun a i j-&gt;a@match j with|c when c&gt;='A'&amp;&amp;c&lt;='Z'-&gt;[Char.ToUpper i]|c when c&gt;='a'&amp;&amp;c&lt;='z'-&gt;[Char.ToLower i]|_-&gt;[i])[](x|&gt;Seq.toList)(y|&gt;Seq.toList)|&gt;String.Concat
let m a b =n a b+"\n"+n b a
</code></pre>

<p>could be better ...</p>
</div>
<div id="pu21" class="pu"><h1>Erlang, 157 bytes</h1>

<pre><code>f(A,B)-&gt;S=string,G=fun(A,B)-&gt;[if Q&gt;64andalso Q&lt;91-&gt;S:to_upper(P);Q&gt;96andalso Q&lt;123-&gt;S:to_lower(P);true-&gt;P end||{P,Q}&lt;-lists:zip(A,B)]end,G(A,B)++"\n"++G(B,A).
</code></pre>

<p>Zips the two strings (actually, lists) into a two-character-tuple list and maps each character to the appropriate case using a list comprehension.</p>
</div>
<div id="pu22" class="pu"><h1>Julia, 140 bytes</h1>



<pre class="lang-julia prettyprint-override"><code>f(s,t)=(C(x,y)=(i=0;z="";for c=x i+=1;z*=string(isalpha(c)?isupper(y[i])?uppercase(c):islower(t[i])?lowercase(c):c:c)end;z);(C(s,t),C(t,s)))
</code></pre>

<p>This creates a function that accepts two strings and returns a tuple of strings. Nothing particularly clever is going on here; we simply define an inner function that directly implements the algorithm in the spec and call it twice.</p>

<p>Ungolfed:</p>

<pre class="lang-julia prettyprint-override"><code>function f(s, t)
    C(x, y) = begin
        i = 0
        z = ""
        for c in x
            i += 1
            if isalpha(c)
                if isupper(y[i])
                    z *= string(uppercase(c))
                elseif islower(y[i])
                    z *= string(lowercase(c))
                else
                    z *= string(c)
                end
            else
                z *= string(c)
            end
        end
        return z
    end

    return (C(s, t), C(t, s))
end
</code></pre>
</div>
<div id="pu23" class="pu"><h1>CJam, 25 bytes</h1>

<pre><code>{z{_el_eu&amp;\__:^32&amp;f^?}%z}
</code></pre>

<p>This is an anonymous function that pops an array of strings from the stack and leaves one in return.</p>

<p>In supported browsers, you can verify all test cases at once in the <a href="http://cjam.aditsu.net/#code=qN%2F2%2F%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20e%23%20Read%20input%20and%20split%20into%20arrays%20of%20two%20strings.%0A%0A%7Bz%7B_el_eu%26%5C__%3A%5E32%26f%5E%3F%7D%25z%7D%0A%0A%25%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20e%23%20Map%20the%20block%20over%20all%20string%20arrays.%0A%3A%2BN*%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20e%23%20Separate%20the%20strings%20by%20linefeeds.&amp;input=ABCDEfghijKlMnOpqrstuvwxyz%0Aaaaaaaaaaaaaaaaa----------%0APRogrammiNG%20puzZLes%20%26%20CODe%20golf%0ASdlkhkfaladlKsdlalksdg7ldklDgsl%0AAAAbbb111%0ACc2Dd3Ee4">CJam interpreter</a>.</p>

<h3>Test cases</h3>

<p><strong>Code</strong></p>

<pre><code>qN/2/                     e# Read input and split into arrays of two strings.

{z{_el_eu&amp;\__:^32&amp;f^?}%z}

%                         e# Map the block over all string arrays.
:+N*                      e# Separate the strings by linefeeds.
</code></pre>

<p><strong>Input</strong></p>

<pre><code>ABCDEfghijKlMnOpqrstuvwxyz
aaaaaaaaaaaaaaaa----------
PRogrammiNG puzZLes &amp; CODe golf
SdlkhkfaladlKsdlalksdg7ldklDgsl
AAAbbb111
Cc2Dd3Ee4
</code></pre>

<p><strong>Output</strong></p>

<pre><code>abcdefghijklmnopqrstuvwxyz
AAAAAaaaaaAaAaAa----------
Programming Puzzles &amp; Code Golf
SDlkhkfalADlksdLAlksdg7LDkldgsl
AaABbb111
CC2dd3Ee4
</code></pre>

<h3>How it works</h3>

<pre><code>z                       e# Zip to transform the array of strings into an array
                        e# of character pairs.
 {                  }%  e# For each character pair:
  _el                   e#   Push a copy and convert to lowercase.
     _eu                e#   Push a copy and convert to uppercase.
        &amp;               e#   Intersect. The result will be an empty string if
                        e#   and only if both characters are letters.
         \              e#   Swap the character pair on top of the stack.
          __            e#   Push two copies.
            :^          e#   XOR both characters.
              32&amp;       e#   Logical AND with 32. This pushes 32 for letters of
                        e#   different cases and 0 for letters of the same case.
                 f^     e#   XOR each character with the result.
                   ?    e#   Select the original copy for non-empty intersection
                        e#   and the modified one otherwise.
                      z e# Zip to turn the characters pairs back into two strings.
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/53876/">53876</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




