<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::125397</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>042</td><td>><> value x</td><td>240615T072952Z</td><td><a href="https://codegolf.stackexchange.com/questions/125397/create-the-slowest-growing-function-you-can-in-under-100-bytes/273672#273672">None1</a></td></tr>
<tr d-ix="1"><td>100</td><td>Javascript</td><td>240615T044156Z</td><td><a href="https://codegolf.stackexchange.com/questions/125397/create-the-slowest-growing-function-you-can-in-under-100-bytes/273669#273669">Patcail</a></td></tr>
<tr d-ix="2"><td>100</td><td>Haskell</td><td>170609T052137Z</td><td><a href="https://codegolf.stackexchange.com/questions/125397/create-the-slowest-growing-function-you-can-in-under-100-bytes/125519#125519">Anders K</a></td></tr>
<tr d-ix="3"><td>nan</td><td>Python</td><td>211231T152642Z</td><td><a href="https://codegolf.stackexchange.com/questions/125397/create-the-slowest-growing-function-you-can-in-under-100-bytes/240392#240392">Binary19</a></td></tr>
<tr d-ix="4"><td>nan</td><td>Binary Lambda Calculus</td><td>200429T204039Z</td><td><a href="https://codegolf.stackexchange.com/questions/125397/create-the-slowest-growing-function-you-can-in-under-100-bytes/204168#204168">John Tro</a></td></tr>
<tr d-ix="5"><td>100</td><td>Ruby</td><td>170731T122103Z</td><td><a href="https://codegolf.stackexchange.com/questions/125397/create-the-slowest-growing-function-you-can-in-under-100-bytes/136807#136807">Simply B</a></td></tr>
<tr d-ix="6"><td>100</td><td>Haskell</td><td>170622T141200Z</td><td><a href="https://codegolf.stackexchange.com/questions/125397/create-the-slowest-growing-function-you-can-in-under-100-bytes/127878#127878">Wheat Wi</a></td></tr>
<tr d-ix="7"><td>042</td><td>MATL</td><td>170609T145739Z</td><td><a href="https://codegolf.stackexchange.com/questions/125397/create-the-slowest-growing-function-you-can-in-under-100-bytes/125622#125622">J Doe</a></td></tr>
<tr d-ix="8"><td>094</td><td>Javascript ES6</td><td>170611T155141Z</td><td><a href="https://codegolf.stackexchange.com/questions/125397/create-the-slowest-growing-function-you-can-in-under-100-bytes/125850#125850">es1024</a></td></tr>
<tr d-ix="9"><td>100</td><td>Brachylog</td><td>170611T210515Z</td><td><a href="https://codegolf.stackexchange.com/questions/125397/create-the-slowest-growing-function-you-can-in-under-100-bytes/125875#125875">Leo</a></td></tr>
<tr d-ix="10"><td>091</td><td>Clojure</td><td>170611T172132Z</td><td><a href="https://codegolf.stackexchange.com/questions/125397/create-the-slowest-growing-function-you-can-in-under-100-bytes/125857#125857">NikoNyrh</a></td></tr>
<tr d-ix="11"><td>nan</td><td></td><td>170608T192326Z</td><td><a href="https://codegolf.stackexchange.com/questions/125397/create-the-slowest-growing-function-you-can-in-under-100-bytes/125414#125414">Draco18s</a></td></tr>
<tr d-ix="12"><td>nan</td><td></td><td>170608T183949Z</td><td><a href="https://codegolf.stackexchange.com/questions/125397/create-the-slowest-growing-function-you-can-in-under-100-bytes/125398#125398">Christop</a></td></tr>
<tr d-ix="13"><td>097</td><td>JavaScript ES6</td><td>170608T233527Z</td><td><a href="https://codegolf.stackexchange.com/questions/125397/create-the-slowest-growing-function-you-can-in-under-100-bytes/125487#125487">Stephen</a></td></tr>
<tr d-ix="14"><td>099</td><td>Mathematica</td><td>170609T034444Z</td><td><a href="https://codegolf.stackexchange.com/questions/125397/create-the-slowest-growing-function-you-can-in-under-100-bytes/125511#125511">DELETE_M</a></td></tr>
<tr d-ix="15"><td>nan</td><td>APL</td><td>170608T195937Z</td><td><a href="https://codegolf.stackexchange.com/questions/125397/create-the-slowest-growing-function-you-can-in-under-100-bytes/125421#125421">Uriel</a></td></tr>
<tr d-ix="16"><td>100</td><td>Python 3</td><td>170608T184906Z</td><td><a href="https://codegolf.stackexchange.com/questions/125397/create-the-slowest-growing-function-you-can-in-under-100-bytes/125403#125403">Leaky Nu</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://esolangs.org/wiki/Fish" rel="nofollow noreferrer">&gt;&lt;&gt;</a> (<code>--value</code> x), 42 bytes</h1>
<pre><code>f0@:@@:@&gt;(?v~~n;
        ^  &gt;$:*$r1+@:@@:@
</code></pre>
<p><a href="https://tio.run/##S8sszvj/P83AwcoBiOw07Mvq6vKsuRSgIE5BwU7FSkulyFAbouL///@6Zf8NDWAAAA" rel="nofollow noreferrer" title="&gt;&lt;&gt; – Try It Online">Try it online!</a></p>
<p>Computes log<sub>2</sub>log<sub>15</sub>x, the input number x is given through the <code>--value</code> argument.</p>
<p>This creates the number 15 and squares it until it is larger than x. Then the number of times to square is printed.</p>
</div>
<div id="pu1" class="pu"><h1>Javascript, 100 bytes, BB<sup>-1</sup>(x) ≤ f(x) ≤ 100<sup>x</sup></h1>
<p>This program simultaneously is the slowest program and the fastest program for this question. It is the slowest as in for any strictly increasing computable function F, then there exists arbitrarily large values of n such that F(P(n))&lt;n, where P is the program function. This program P is also the fastest where for some values of n, P(n)&gt;n, so in a sense P fails to be slower than the identity function! P is not monotonic, but P(n) approaches infinity as n approaches infinity.</p>
<p>Also, for some small values of n, P(n) might not give a result. This is okay since we only care about the end behavior of the program.</p>
<h2>Strategy</h2>
<p>It works by by:</p>
<ol>
<li>enumerating all of the <a href="https://esolangs.org/wiki/Bitwise_Cyclic_Tag" rel="nofollow noreferrer">Bitwise Cyclic Tag</a> programs by ID number.</li>
<li>Go through the programs, running each one for X steps. If the BCT program halts, then if the halting time is between X/4 and X/3, then we return the associated ID number</li>
<li>Otherwise, we continue going through the programs</li>
</ol>
<p>Thus, we are essentially calculating a <a href="https://en.wikipedia.org/wiki/Kolmogorov_complexity" rel="nofollow noreferrer">Kolmogorov complexity</a> for a number in terms of halting times. This means that &quot;random&quot; numbers, such as 6.661337...*1069420, could have a larger output than <a href="https://en.wikipedia.org/wiki/Graham%27s_number" rel="nofollow noreferrer">much</a> <a href="https://googology.fandom.com/wiki/TREE_sequence" rel="nofollow noreferrer">larger</a> <a href="https://googology.fandom.com/wiki/Loader%27s_number" rel="nofollow noreferrer">numbers</a>.</p>
<h2>The program</h2>
<pre><code>x=&gt;eval(&quot;for(q=i=A=0;q&lt;x&amp;&amp;A^0?1:q/x^3&amp;&amp;(i++,q=A='1');A=+L?A&amp;1?L+A:A:A/10)i+='',L=i[q++%i.length];i&quot;)
</code></pre>
<p>Here is the ungolfed analysis version, using a while loop:</p>
<pre><code>x=&gt;                                         //function signature
    eval(&quot;                                  //golfing eval trick
        q=0                                 //index for program string
        i=0                                 //what BCT we're on
        A=0                                 //data string for BCT
        while(                              //initialize while loop
            q&lt;x                             //q&lt;x - if we haven't exceeded our limit yet
                &amp;&amp;
            A^0                             //and we are still running
            ?1:                             //we continue the while loop
                q/x^3                       //otherwise we check 3&lt;=q/x&lt;4
                  &amp;&amp;                        //normally q==x, so only way for this to be zero is if we halted the BCT on the empty data
                                            //If that expression is 0, we halt everything
                (i++,                       //otherwise we increment our BCT ID. This also un-stringify the i.
                q=A='1')                    //we also reset data string and program pointer
        ) {
            i+=''                           //we stringify i again
            L=i[q++%i.length]               //we set L to be the digit q in the program pointer is looking at in i. We also increment the pointer q.

            A=                              //we manipulate our data string
                +L?                         //check if L==0
                    A&amp;1?                    //if not, we check last digit of A if it is odd
                        L+A                 //append if A is odd
                        :A                  //do nothing if A is even
                    :A/10)                  //remove last digit of A
        };
        i                                   //implicit return our BCT id
    &quot;)
</code></pre>
<p>To implement BCT, we used this table of data:
0 - delete the least significant digit
Odd #'s - prepend an odd number if the least significant digit is odd
Even #'s - prepend an even number if the least significant digit is odd</p>
<p>Thus, 0 corresponds to 0, odd numbers correspond to 11, and even numbers correspond to 10 in BCT.</p>
<p>When dividing by 10, we do have some residue decimal digits. Those are insignificant; we always check A&amp;1 for even/oddness, and we check A^0 to see if A is zero/no active bits or nonzero.</p>
</div>
<div id="pu2" class="pu"><h1>Haskell, 100 bytes, score=<a href="https://en.wikipedia.org/wiki/Fast-growing_hierarchy" rel="nofollow noreferrer"><em>f</em><sub>ε<sub>0</sub></sub></a><sup>−1</sup>(<em>n</em>)</h1>
<pre><code>_#[]=0
k#(0:a)=k#a+1
k#(a:b)=(k+1)#(([1..k]&gt;&gt;fst(span(&gt;=a)b)++[a-1])++b)
f n=[k|k&lt;-[0..],1#[k]&gt;n]!!0
</code></pre>
<h3>How it works</h3>
<p>This computes the inverse of a very fast growing function related to <a href="http://www.mi.ras.ru/%7Ebekl/Problems/gpa5.html" rel="nofollow noreferrer">Beklemishev’s worm game</a>.  Its growth rate is comparable to <em>f</em><sub>ε<sub>0</sub></sub>, where <em>f</em><sub>α</sub> is the <a href="https://en.wikipedia.org/wiki/Fast-growing_hierarchy" rel="nofollow noreferrer">fast-growing hierarchy</a> and ε<sub>0</sub> is the first <a href="https://en.wikipedia.org/wiki/Epsilon_numbers_(mathematics)" rel="nofollow noreferrer">epsilon number</a>.</p>
<p>For comparison with other answers, note that</p>
<ul>
<li>exponentiation is comparable to <em>f</em><sub>2</sub>;</li>
<li>iterated exponentiation (<a href="https://en.wikipedia.org/wiki/Tetration" rel="nofollow noreferrer">tetration</a> or <a href="https://en.wikipedia.org/wiki/Knuth%27s_up-arrow_notation" rel="nofollow noreferrer">↑↑</a>) is comparable to <em>f</em><sub>3</sub>;</li>
<li><a href="https://en.wikipedia.org/wiki/Knuth%27s_up-arrow_notation" rel="nofollow noreferrer">↑↑⋯↑↑</a> with <em>m</em> arrows is comparable to <em>f</em><sub><em>m</em> + 1</sub>;</li>
<li>The <a href="https://en.wikipedia.org/wiki/Ackermann_function" rel="nofollow noreferrer">Ackermann function</a> is comparable to <em>f</em><sub>ω</sub>;</li>
<li>repeated iterations of the Ackermann function (constructions like <a href="https://en.wikipedia.org/wiki/Graham%27s_number" rel="nofollow noreferrer">Graham’s number</a>) are still dominated by <em>f</em><sub>ω + 1</sub>;</li>
<li>and ε<sub>0</sub> is the limit of all towers ω<sup>ω<sup>ω<sup>⋰<sup>ω</sup></sup></sup></sup>.</li>
</ul>
</div>
<div id="pu3" class="pu"><h2>Python, 100 bytes, <span class="math-container">\$999 \uparrow^{99999} \text{Score} = \text{Input}\$</span>, using up-arrow notation</h2>
<pre><code>f=lambda b,i,n:n/b if i==0 else(0if n&lt;=1else 1+f(b,i,f(b,i-1,n)));print(f(999,99999,int(input(&quot;&quot;))))
</code></pre>
<p>This is based on <em>extremely</em> iterated logarithms, since most people know that logarithms alone grow pretty slowly.</p>
<p>This program describes a ternary lambda function known simply as <code>f</code> which takes a base <code>b</code>, iterations <code>i</code> and input <code>n</code>. If <code>i == 0</code>, it just returns the input divided by the base. With <code>i == 1</code>, you may recognise the output as <span class="math-container">\$\text{max}(0, \lfloor \text{log}_b(n)\rfloor)\$</span>. Then, with <code>i == 2</code>, this is equal to <span class="math-container">\$\text{log*}(n) = \text{max}(0, \lfloor \text{slog}_b(n)\rfloor)\$</span>, where <span class="math-container">\$\text{slog}\$</span> is the super logarithm (iteration instead of exponentiation). Then, this program gets user input and returns <span class="math-container">\$\text{max}(0, \lfloor ^{99999}\text{log}_{999}(n)\rfloor)\$</span>. Here, <span class="math-container">\$^m\text{log}\$</span> is logarithm using <span class="math-container">\$\uparrow^m\$</span>, so <span class="math-container">\$^2\text{log}\$</span> is <span class="math-container">\$\text{slog}\$</span>.</p>
</div>
<div id="pu4" class="pu"><h1>Binary Lambda Calculus, 237 bits (under 30 bytes)</h1>

<pre><code>-- compute periods of final row of Laver tables as in as in
-- section 3.4 of https://arxiv.org/pdf/1810.00548.pdf
let
  -- Let mx = 2^n - 1. We consider a dual version of the shelf, determined
  -- by a |&gt; mx = a-1 (mod 2^n), which satisfies
  --   0 |&gt; b  = b
  --   a |&gt; 0  = 0
  --   a |&gt; mx = a-1
  --   a |&gt; b  = (a |&gt; b+1) |&gt; a-1
  -- Note that the latter two equations iterate f_a = \x. x |&gt; (a-1).
  -- In fact, for a &gt; 0, we implement a |&gt; b = f_a^{mx-b} (a-1) as f_a^{mx*b} 0,
  -- exploiting the fact that a |&gt; mx = a-1 = 0 |&gt; a-1 = f_a 0
  -- and (modulo 2^n) 1+mx-b = -b = -1 * b = mx*b

  0 = \f\x. x;
  1 = \x. x;
  2 = \f\x. f (f x);
  succ = \n\f\x. f (n f x);
  pred = \n\f\x. n (\g\h. h (g f)) (\h. x) (\x. x);
  laver = \mx.
    -- swap argument order to simplify iterated laver
    let laver = \b\a. a (\_. mx (b (laver (pred a))) 0) b
    in laver;
  dblp1 = \n\f\x. n f (n f (f x)); -- map n to 2*n+1
  find0 = \mx\i.laver mx i mx (\_.find0 mx (succ i)) i;
  period = \n.let mx = pred (n 2) in find0 mx 1
in
  period
</code></pre>

<p>compiles down to the 237 bits</p>

<pre><code>010000010101000110100000000101010101000110100000000101100001011111110011110010111110111100111111111101100000101101011000010101111101111011100000011100101111101101010011100110000001110011101000100000000101011110000001100111011110001100010
</code></pre>

<p>This function grows to infinity assuming large cardinal axiom I3, which I believe is what Peter Taylor was hinting at. It grows way slower than any sort of inverse Ackerman.</p>
</div>
<div id="pu5" class="pu"><h1>Ruby, 100 bytes, score<sup>-1</sup> = f<sub>ω<sup>ω+1</sup></sub>(n<sup>2</sup>)</h1>

<p>Basically borrowed from my <a href="https://codegolf.stackexchange.com/a/120228">Largest Number Printable</a>, here's my program:</p>

<pre><code>-&gt;k{n=0;n+=1 until(H=-&gt;z,a=[0]*z{b,*c=a;z.times{z+=b ?H[z,b==1?c:[b&gt;1?b-1:z]*z+c]:z};z};H[n*n]&gt;k);n}
</code></pre>

<p><a href="https://tio.run/##DcpLCsMgEADQq7hs/ZTYpTK69Q7iIiNZhLRDaRNIR3J2E3jL993w33foJiyNYPCkwIqN1vl1S2AC6xHyUCQ31LLC6Pmxzu/p11gBipgyawSwsbqMwUY01vG1VS2OD39JmSSVsNw9Hf0j9vws/QQ" rel="nofollow noreferrer">Try it online</a></p>

<p>Basically computes the inverse of f<sub>ω<sup>ω+1</sup></sub>(n<sup>2</sup>) in the fast growing hierarchy.  The first few values are</p>

<pre><code>x[0] = 1
x[1] = 1
x[2] = 1
x[3] = 1
x[4] = 2
</code></pre>

<p>And then it continues to output <code>2</code> for a very long time.  Even <code>x[G] = 2</code>, where <code>G</code> is Graham's number.</p>
</div>
<div id="pu6" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, 100 bytes</h1>



<pre class="lang-hs prettyprint-override"><code>f 0 a b=a^b
f c a b=foldr(f$c-1)a$[0..b]&gt;&gt;[a]
i=length.show
0#x=i x
y#x=i$(y-1)#x
g=(f(f 9 9 9)9 9#)
</code></pre>

<p><a href="https://tio.run/##XYq9CsMgFIV3n@KCDjpUzNiA2TvlAUIK1zT@UGtKEqh5ehs79hwO3zccj9tzjrEUCwoQjMa7IRamn9slPlZu2XRpBLJBSWnGrhtwJEHHObndy80vH6Jo1gEyOSoZP847zcRpbrmFa604R0V5YUhte@u5IFX1ew1pZw4a9Z/yBQ" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>

<p>This solution does not take the inverse of a quickly growing function instead it takes a rather slowly growing function, in this case <code>length.show</code>, and applies it a bunch of times.</p>

<p>First we define a function <code>f</code>.  <code>f</code> is a bastard version of Knuth's uparrow notation that grows slightly faster (slightly is a bit of an understatement, but the numbers we are dealing with are so large that in the grand scheme of things...).  We define the base case of <code>f 0 a b</code> to be <code>a^b</code> or <code>a</code> to the power of <code>b</code>.  We then define the general case to be <code>(f$c-1)</code> applied to <code>b+2</code> instances of <code>a</code>.  If we were defining a Knuth uparrow notation like construct we would apply it to <code>b</code> instances of <code>a</code>, but <code>b+2</code> is actually <em>golfier</em> and has the advantage of being faster growing.</p>

<p>We then define the operator <code>#</code>.  <code>a#b</code> is defined to be <code>length.show</code> applied to <code>b</code> <code>a</code> times.  Every application of <code>length.show</code> is an approximately equal to log<sub>10</sub>, which is not a very swiftly growing function.</p>

<p>We then go about defining our function <code>g</code> that takes and integer in and applies <code>length.show</code> to the integer a bunch of times.  To be specific it applies <code>length.show</code> to the input <code>f(f 9 9 9)9 9</code>.  Before we get into how large this is lets look at <code>f 9 9 9</code>.  <code>f 9 9 9</code> is <em>greater than</em> <code>9↑↑↑↑↑↑↑↑↑9</code> (nine arrows), by a massive margin.  I believe it is somewhere between <code>9↑↑↑↑↑↑↑↑↑9</code> (nine arrows) and <code>9↑↑↑↑↑↑↑↑↑↑9</code> (ten arrows).  Now this is an unimaginably large number, far to big to be stored on any computer in existence (in binary notation).  We then take that and put that as the first argument of our <code>f</code> that means our value is larger than <code>9↑↑↑↑↑↑...↑↑↑↑↑↑9</code> with <code>f 9 9 9</code> arrows in between.  I'm not going describe this number because it is so large I don't think I would be able to do it justice.</p>

<p>Each <code>length.show</code> is approximately equal to taking the log base 10 of the integer.  This means that most numbers will return 1 when <code>f</code> is applied to them.  The smallest number to return something other than 1 is <code>10↑↑(f(f 9 9 9)9 9)</code>, which returns 2.  Lets think about that for a moment.  As abominably large as that number we defined earlier is, the <em>smallest</em> number that returns 2 is 10 to its own power that many times.  Thats 1 followed by <code>10↑(f(f 9 9 9)9 9)</code> zeros.</p>

<p>For the general case of <code>n</code> the smallest input outputting any given n must be <code>(10↑(n-1))↑↑(f(f 9 9 9)9 9)</code>.</p>

<p><strong>Note that this program requires massive amounts of time and memory for even small n (more than there is in the universe many times over), if you want to test this I suggest replacing <code>f(f 9 9 9)9 9</code> with a much smaller number, try 1 or 2 if you want ever get any output other than 1.</strong></p>
</div>
<div id="pu7" class="pu"><h1><a href="https://github.com/lmendo/MATL" rel="nofollow noreferrer">MATL</a>, 42 bytes</h1>
<pre><code>iXI:`2*.]X{oXH1H/16L+XKxI:`Yl.]K+XKXdXzXGx
</code></pre>
<p><a href="https://tio.run/##y00syfn/PzPC0yrBSEsvNqI6P8LD0EPf0MxHO8K7AigamaMX6w1kR6REVEW4V/z/b2gAAA" rel="nofollow noreferrer" title="MATL – Try It Online">Try it online!</a></p>
<p>This program is based on the harmonic series with the use of Euler–Mascheroni constant. As I was reading @LuisMendo documentation on his MATL language (with capital letters, so it looks important) I noticed this constant. The slow growth function expression is as following:
<a href="https://i.sstatic.net/hUCD4.png" rel="nofollow noreferrer"><img src="https://i.sstatic.net/hUCD4.png" alt="enter image description here" /></a></p>
<p>where  <em>εk ~ 1/2k</em></p>
<p>I tested up to 10000 iterations (in Matlab, since it is too large for TIO) and it scores below 10, so it is very slow.</p>
<p><a href="https://i.sstatic.net/59jvA.png" rel="nofollow noreferrer"><img src="https://i.sstatic.net/59jvA.png" alt="enter image description here" /></a></p>
<p>Explanations:</p>
<pre><code> iXI      % ask user input (number of iterations)

:`2*.]    % do...while loop, multiply by 2

X{        % convert numeric array into cell array

o         % convert to double precision array 

XH1H/     % copy to clipboard H and divide by 1: now we have an array of 1/2k

16L       % Euler–Mascheroni constant 

+         % addition (element-wise, singleton expansion)

XKxI:`    % save, clear the stack, do...while loop again

  Yl      % logarithm 

  .]      % break, ends the loop

K+XK      % paste from clipboard K, sum all

Xd        % trim: keep the diagonal of the matrix 

Xz        % remove all zeros

XG        % plot (yes it plots on-line too!)

x         % clear the stack
          % (implicit) display
</code></pre>
<p>Empirical proof:
(ln <em>k</em>) + 1 in red always above ln<em>k</em> + γ + <em>εk</em> in blue.</p>
<p><a href="https://i.sstatic.net/XeNJp.png" rel="nofollow noreferrer"><img src="https://i.sstatic.net/XeNJp.png" alt="enter image description here" /></a></p>
<p>The program for (ln <em>k</em>) + 1 was made in</p>
<h2>Matlab, <s>47</s> <s>18</s> 14 bytes</h2>
<pre><code>n=input('')
A=(1:n)
for k=1:n
A(k)=log(k)+1
end
</code></pre>
<p>Interesting to note that the elapsed time for n=100 is 0.208693s on my laptop, but only 0.121945s with <code>d=rand(1,n);A=d*0;</code> and even less, 0.112147s with <code>A=zeros(1,n)</code>. If zeros is a waste of space, it saves speed!
But I am diverging from the topic (probably very slowly).</p>
<p>Edit:
thanks to Stewie for <s>helping</s> reducing this Matlab expression to, simply:</p>
<pre><code> @(n)log(1:n)+1
</code></pre>
</div>
<div id="pu8" class="pu"><h1>Javascript (ES6), 94 bytes</h1>

<pre><code>(p=j=&gt;i=&gt;h=&gt;g=&gt;f=&gt;x=&gt;x&lt;2?0:1+p(p(j))(j(i))(i(h))(h(g))(g(f))(f(x)))(_=x=&gt;x)(_)(_)(_)(Math.log)
</code></pre>

<p><strong>Explanation</strong>: </p>

<p><code>Id</code> refers to <code>x =&gt; x</code> in the following.</p>

<p>Let's first take a look at:</p>

<pre><code>p = f =&gt; x =&gt; x &lt; 2 ? 0 : 1 + p(p(f))(f(x))
</code></pre>

<p><code>p(Math.log)</code> is approximately equal to <code>log*(x)</code>.</p>

<p><code>p(p(Math.log))</code> is approximately equal to <code>log**(x)</code> (number of times you can take <code>log*</code> until the value is at most 1).</p>

<p><code>p(p(p(Math.log)))</code> is approximately equal to <code>log***(x)</code>.</p>

<p>The inverse Ackermann function <code>alpha(x)</code> is approximately equal to the minimum number of times you need to compose <code>p</code> until the value is at most 1.</p>

<p>If we then use:</p>

<pre><code>p = g =&gt; f =&gt; x =&gt; x &lt; 2 ? 0 : 1 + p(p(g))(g(f))(f(x))
</code></pre>

<p>then we can write <code>alpha = p(Id)(Math.log)</code>.</p>

<p>That's pretty boring, however, so let's increase the number of levels:</p>

<pre><code>p = h =&gt; g =&gt; f =&gt; x =&gt; x &lt; 2 ? 0 : 1 + p(p(h))(h(g))(g(f))(f(x))
</code></pre>

<p>This is like how we constructed <code>alpha(x)</code>, except instead of doing <code>log**...**(x)</code>, we now do <code>alpha**...**(x)</code>.</p>

<p>Why stop here though?</p>

<pre><code>p = i =&gt; h =&gt; g =&gt; f =&gt; x =&gt; x &lt; 2 ? 0 : 1 + p(p(i))(i(h))(h(g))(g(f))(f(x))
</code></pre>

<p>If the previous function is <code>f(x)~alpha**...**(x)</code>, this one is now <code>~ f**...**(x)</code>. We do one more level of this to get our final solution.</p>
</div>
<div id="pu9" class="pu"><h1><a href="https://github.com/JCumin/Brachylog" rel="noreferrer">Brachylog</a>, 100 bytes</h1>

<pre><code>llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll
</code></pre>

<p><a href="https://tio.run/##SypKTM6ozMlPN/r/P4cO4P9/Q4PBAf5HAQA" rel="noreferrer" title="Brachylog – Try It Online">Try it online!</a></p>

<p>This is probably nowhere near the slowness of some other fancy answers, but I couldn't believe noone had tried this simple and beautiful approach.</p>

<p>Simply, we compute the length of the input number, then the length of this result, then the length of this <em>other</em> result... 100 times in total.</p>

<p>This grows as fast as log(log(log...log(x), with 100 base-10 logs.</p>

<p><a href="https://tio.run/##7daxDYAwEATBXlwBUA4ZEEBgCYmM6o8ujAXjCsb3ya7Xsh13PfcpqQ1eUsbh9dcBgYPjNw57cnBwcHT49BgHhx6zJwcHB4ceMwUHhx7j4ODg0GN25eDQY/bk4ODg0GMcHBx6jIODg0OPuS8Hhx6zJwcHB4ce4@Dg0GMcHBwcesx9OTj0mD05ODg49BgHB4ce4@Dg4NBj7svBocfsycHBwSHHODg45BgHBwfH93NMj3Fw6DF7cnBwcPiU@3Jw6DEODg4OPWZXDg49Zk8ODg4OPcbBwaHHODg4OPSY@3Jw6DF7cnBwcOgxDg4OPcbBwcGhx9yXg0OP2ZODg4NDj3FwcOgxDg4ODj3mvhwcesyeHBwcHK1eyfwA" rel="noreferrer">If you input your number as a string</a>, this will run extremely fast on any input you could try, but don't expect to ever see a result higher than 1 :D </p>
</div>
<div id="pu10" class="pu"><h2>Clojure, 91 bytes</h2>

<pre><code>(defn f (apply +(for[n(range %)](/(loop[r 1 v n](if(&lt; v 1)r(recur(* r v)(Math/log v))))))))
</code></pre>

<p>Kind of calculates the <code>sum 1/(n * log(n) * log(log(n)) * ...)</code>, which I found from <a href="https://math.stackexchange.com/a/452441">here</a>. But the function ended up 101 bytes long so I had to drop the explicit number of iterations, and instead iterate as long as the number is greater than one. Example outputs for inputs of <code>10^i</code>:</p>

<pre><code>0 1
1 3.3851305685279143
2 3.9960532565317575
3 4.232195089969394
4 4.370995106860574
5 4.466762285601703
6 4.53872567524327
7 4.595525574477128
8 4.640390570825608
</code></pre>

<p>I assume this modified series still diverges but do now know how to prove it.</p>

<blockquote>
  <p>The third series actually requires a googolplex numbers of terms before the partial terms exceed 10.</p>
</blockquote>
</div>
<div id="pu11" class="pu"><h1>Pure Evil: Eval</h1>

<pre><code>a=lambda x,y:(y&lt;0)*x or eval("a("*9**9**9+"x**.1"+",y-1)"*9**9**9)
print a(input(),9**9**9**9**9)//1
</code></pre>

<p>The statement inside the eval creates a string of length 7*<a href="http://www.wolframalpha.com/input/?i=(9%5E9%5E9%5E9%5E9)%5E(9%5E9%5E9%5E9%5E9)%5E(9%5E9%5E9%5E9%5E9)" rel="nofollow noreferrer">10<sup>10<sup>10<sup>10<sup>10<sup>10<sup>8.57</sup></sup></sup></sup></sup></sup></a> which consists of nothing but <em>more calls to the lambda function</em> each of which will construct a string of <em>similar</em> length, on and on until eventually <code>y</code> becomes 0. Ostensibly this has the same complexity as the Eschew method below, but rather than relying on if-and-or control logic, it just smashes giant strings together (and the net result is getting more stacks...probably?).</p>

<p>The largest <code>y</code> value I can supply and compute without Python throwing an error is 2 which is already sufficient to reduce an input of max-float into returning 1.</p>

<p>A string of length 7,625,597,484,987 is just too big: <code>OverflowError: cannot fit 'long' into an index-sized integer</code>.</p>

<p>I should stop.</p>

<h1>Eschew <code>Math.log</code>: Going to the (10th-)root (of the problem), Score: function effectively indistinguishable from y=1.</h1>

<p>Importing the math library is restricting the byte count. Lets do away with that and replace the <code>log(x)</code> function with something roughly equivalent: <code>x**.1</code> and which costs approximately the same number of characters, but doesn't require the import.  Both functions have a sublinear output with respect to input, but x<sup>0.1</sup> grows <a href="http://www.wolframalpha.com/input/?i=log(10,x),x%5E0.1where+x+from+0+to+1000" rel="nofollow noreferrer">even more slowly</a>.  However we don't care a whole lot, we only care that it has the same base growth pattern with respect to large numbers while consuming a comparable number of characters (eg. <code>x**.9</code> is the same number of characters, but grows more quickly, so there is some value that would exhibit the exact same growth).</p>

<p>Now, what to do with 16 characters. How about...extending our lambda function to have Ackermann Sequence properties? <a href="https://codegolf.stackexchange.com/questions/18028/largest-number-printable/18359#18359">This answer</a> for large numbers inspired this solution.</p>

<pre><code>a=lambda x,y,z:(z&lt;0)*x or y and a(x**.1,z**z,z-1)or a(x**.1,y-1,z)
print a(input(),9,9**9**9**99)//1
</code></pre>

<p>The <code>z**z</code> portion here prevents me from running this function with anywhere <em>close</em> to sane inputs for <code>y</code> and <code>z</code>, the largest values I can use are 9 and <strong><em>3</em></strong> for which I get back the value of 1.0, even for the largest float Python supports (note: while 1.0 is numerically greater than 6.77538853089e-05, increased recursion levels move the output of this function closer to 1, while remaining greater than 1, whereas the previous function moved values closer to 0 while remaining greater than 0, thus even moderate recursion on this function results in so many operations that the floating point number loses <em>all</em> significant bits).</p>

<p>Re-configuring the original lambda call to have recursion values of 0 and 2...</p>

<pre><code>&gt;&gt;&gt;1.7976931348623157e+308
1.0000000071
</code></pre>

<p>If the comparison is made to "offset from 0" instead of "offset from 1" this function returns <code>7.1e-9</code>, which is definitely smaller than <code>6.7e-05</code>.</p>

<p>Actual program's <em>base</em> recursion (z value) is 10<sup>10<sup>10<sup>10<sup>1.97</sup></sup></sup></sup> levels deep, as soon as y exhausts itself, it gets reset with 10<sup>10<sup>10<sup>10<sup>10<sup>1.97</sup></sup></sup></sup></sup> (which is why an initial value of 9 is sufficient), so I don't even know how to correctly compute the total number of recursions that occur: I've reached the end of my mathematical knowledge. Similarly I don't know if moving one of the <code>**n</code> exponentiations from the initial input to the secondary <code>z**z</code> would improve the number of recursions or not (ditto reverse).</p>

<h1>Lets go even slower with even more recursion</h1>

<pre><code>import math
a=lambda x,y:(y&lt;0)*x or a(a(a(math.log(x+1),y-1),y-1),y-1)
print a(input(),9**9**9e9)//1
</code></pre>

<ul>
<li><code>n//1</code> - saves 2 bytes over <code>int(n)</code></li>
<li><code>import math</code>,<code>math.</code> saves 1 byte over <code>from math import*</code></li>
<li><code>a(...)</code> saves 8 bytes total over <code>m(m,...)</code></li>
<li><code>(y&gt;0)*x</code> <a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python/103309#103309">saves a byte</a> over <code>y&gt;0and x</code></li>
<li><s><code>9**9**99</code> increases byte count by 4 and increases recursion depth by approximately <a href="http://www.wolframalpha.com/input/?i=9%5E9%5E99" rel="nofollow noreferrer"><code>2.8 * 10^x</code></a> where <code>x</code> is the old depth (or a depth nearing a googolplex in size: 10<sup>10<sup>94</sup></sup>).</s></li>
<li><code>9**9**9e9</code> increases the byte count by 5 and increases recursion depth by...an insane amount. Recursion depth is now 10<sup>10<sup>10<sup>9.93</sup></sup></sup>, for reference, a googolplex is 10<sup>10<sup>10<sup>2</sup></sup></sup>.</li>
<li>lambda declaration increases recursion by an extra step: <code>m(m(...))</code> to <code>a(a(a(...)))</code> costs 7 bytes</li>
</ul>

<p>New output value (at 9 recursion depth):</p>

<pre><code>&gt;&gt;&gt;1.7976931348623157e+308
6.77538853089e-05
</code></pre>

<p>Recursion depth has exploded to the point at which this result is <em>literally</em> meaningless except in comparison to the earlier results using the same input values:</p>

<ul>
<li>The original called <code>log</code> 25 times</li>
<li>The first improvement calls it 81 times

<ul>
<li>The <em>actual</em> program would call it 1e99<sup>2</sup> or about 10<sup>10<sup>2.3</sup></sup> times</li>
</ul></li>
<li>This version calls it 729 times

<ul>
<li>The <em>actual</em> program would call it (9<sup>9<sup>99</sup></sup>)<sup>3</sup> or slightly less than 10<sup>10<sup>95</sup></sup> times).</li>
</ul></li>
</ul>

<h1>Lambda Inception, score: ???</h1>

<p>I heard you like lambdas, so...</p>

<pre><code>from math import*
a=lambda m,x,y:y&lt;0and x or m(m,m(m,log(x+1),y-1),y-1)
print int(a(a,input(),1e99))
</code></pre>

<p>I can't even run this, I stack overflow even with a mere <em>99</em> layers of recursion.</p>

<p>The old method (below) returns (skipping the conversion to an integer):</p>

<pre><code>&gt;&gt;&gt;1.7976931348623157e+308
0.0909072713593
</code></pre>

<p>The new method returns, using only 9 layers of incursion (rather than the full <em>googol</em> of them):</p>

<pre><code>&gt;&gt;&gt;1.7976931348623157e+308
0.00196323936205
</code></pre>

<p>I think this works out to be of similar complexity to the Ackerman sequence, only small instead of big.</p>

<p>Also thanks to ETHproductions for a 3-byte savings in spaces I didn't realize could be removed.</p>

<p>Old answer:</p>

<h1>The integer truncation of the function log(i+1) iterated <s>20</s> 25 times (Python) using lambda'd lambdas.</h1>

<p>PyRulez's answer can be compressed by introducing a second lambda and stacking it:</p>

<pre><code>from math import *
x=lambda i:log(i+1)
y=lambda i:x(x(x(x(x(i)))))
print int(y(y(y(y(y(input()))))))
</code></pre>

<p><s>99</s> 100 characters used.</p>

<p>This produces an iteration of <s>20</s> 25, over the original 12.  Additionally it saves 2 characters by using <code>int()</code> instead of <code>floor()</code> which allowed for an additional <code>x()</code> stack. <s>If the spaces after the lambda can be removed (I cannot check at the moment) then a 5th <code>y()</code> can be added.</s> Possible!</p>

<p>If there's a way to skip the <code>from math</code> import by using a fully qualified name (eg. <code>x=lambda i: math.log(i+1))</code>), that would save even more characters and allow for another stack of <code>x()</code> but I don't know if Python supports such things (I suspect not). Done!</p>

<p>This is essentially the same trick used in <a href="https://blog.xkcd.com/2007/03/14/large-numbers/" rel="nofollow noreferrer">XCKD's blog post on large numbers</a>, however the overhead in declaring lambdas precludes a third stack:</p>

<pre><code>from math import *
x=lambda i:log(i+1)
y=lambda i:x(x(x(i)))
z=lambda i:y(y(y(i)))
print int(z(z(z(input()))))
</code></pre>

<p>This is the smallest recursion possible with 3 lambdas that exceeds the computed stack height of 2 lambdas (reducing any lambda to two calls drops the stack height to 18, below that of the 2-lambda version), but unfortunately requires 110 characters.</p>
</div>
<div id="pu12" class="pu"><h2>The floor of the function log(i+1) iterated 14 times (Python)</h2>

<pre><code>import math
x=lambda i: math.log(i+1)
print int(x(x(x(x(x(x(x(x(x(x(x(x(x(x(input())))))))))))))))
</code></pre>

<p>I don't expect this to do very well, but I figured its a good start.</p>

<p>Examples:</p>

<ul>
<li>e^n^n^n^n^n^n^n^n^n^n^n^n^n^n -> ~n (approximately n)</li>
</ul>
</div>
<div id="pu13" class="pu"><h1>JavaScript (ES6), Inverse Ackermann Function*, 97 bytes</h1>

<p>*if I did it right</p>

<pre><code>A=(m,n)=&gt;m?A(m-1,n?A(m,n-1):1):n+1
a=(m,n=m,i=1)=&gt;{while(A(i,m/n|0)&lt;=Math.log2(n))i++;return i-1}
</code></pre>

<p>Function <code>A</code> is the <a href="https://en.wikipedia.org/wiki/Ackermann_function" rel="noreferrer">Ackermann function</a>. Function <code>a</code> is supposed to be the <a href="https://en.wikipedia.org/wiki/Ackermann_function#Inverse" rel="noreferrer">Inverse Ackermann function</a>. If I implemented it correctly, Wikipedia says that it will not hit <code>5</code> until <code>m</code> equals <code>2^2^2^2^16</code>. I get a <code>StackOverflow</code> around <code>1000</code>.</p>

<p>Usage:</p>

<pre><code>console.log(a(1000))
</code></pre>

<h1>Explanations:</h1>

<h2>Ackermann Function</h2>

<pre><code>A=(m,n)=&gt;                           Function A with parameters m and n
         m?                   :n+1  If m == 0, return n + 1; else,
           A(m-1,n?        :1)       If n == 0, return A(m-1,1); else,
                   A(m,n-1)          return A(m-1,A(m,n-1))
</code></pre>

<h2>Inverse Ackermann Function</h2>

<pre><code>a=(m,n=m,i=1)=&gt;{                                                Function a with parameter m, with n preinitialized to m and i preinitialized to 1
                while(A(i,m/n|0)&lt;=Math.log2(n))                 While the result of A(i, floor(m/n)) is less than log₂ n,
                                               i++;             Increment i
                                                   return i-1}  Return i-1
</code></pre>
</div>
<div id="pu14" class="pu"><h2>Mathematica, 99 bytes</h2>
<p>(assuming ± takes 1 byte)</p>
<pre><code>﻿0±x_=1±(x-1);y_±0=y+1;x_±y_:=(y-1)±x±(x-1);(i=0;NestWhile[(++i;#±#±#±#±#±#±#±#)&amp;,1,#&lt;k&amp;/.k-&gt;#];i)&amp;
</code></pre>
<p>The first 3 commands define <code>x±y</code> to evaluate <code>Ackermann(y, x)</code>.</p>
<p>The result of the function is the number of times <code>f(#)=#±#±#±#±#±#±#±#</code> need to be applied to 1 before the value get to the value of parameter. As <code>f(#)=#±#±#±#±#±#±#±#</code> (that is, <code>f(#)=Ackermann[Ackermann[Ackermann[Ackermann[Ackermann[Ackermann[Ackermann[#, #], #], #], #], #], #], #]</code>) grow very fast, the function grow very slow.</p>
</div>
<div id="pu15" class="pu"><h1>APL, Apply <code>log(n + 1)</code>, <code>e^9^9...^9</code> times, where the length of the chain is <code>e^9^9...^9</code> of length of chain minus 1 times, and so on.</h1>

<pre><code>⌊((⍟1+⊢)⍣((*⍣(*⍣(*⍣(*⍣(*⍣(*⍣(*⍣(*⍣(*⍣(*⍣(*⍣(*⍣(*⍣(*⍣(*⍣(*⍣(*⍣(*⍣(*⍣(*⍣(*⍣⊢)))))))))))))))))))))9))⊢
</code></pre>
</div>
<div id="pu16" class="pu"><h1><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python 3</a>, 100 bytes</h1>

<p>The floor of the function log(i+1) iterated 99999999999999999999999999999999999 times.</p>

<p>One can use exponents to make the above number even larger...</p>



<pre class="lang-python prettyprint-override"><code>from math import *
s=input()
exec("s=log(s+1);"*99999999999999999999999999999999999)
print(floor(s))
</code></pre>

<p><a href="https://tio.run/##hcFBCoAgEADAu6@QTrt2ik4RPiZCU1BX1g3q9dsTmumvJGqramSqth6SbK6dWKwzw@fWbwE04QknTMMXumDMC@6T2/6h6ZybQCxEDANR9QM" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/125397/">125397</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




