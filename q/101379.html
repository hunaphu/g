<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::101379</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>522</td><td>Python3</td><td>250825T010631Z</td><td><a href="https://codegolf.stackexchange.com/questions/101379/overlapping-line-ordering/283312#283312">Ajax1234</a></td></tr>
<tr d-ix="1"><td>nan</td><td>Perl</td><td>161129T190437Z</td><td><a href="https://codegolf.stackexchange.com/questions/101379/overlapping-line-ordering/101521#101521">user6213</a></td></tr>
<tr d-ix="2"><td>199</td><td>Python 2</td><td>161129T154102Z</td><td><a href="https://codegolf.stackexchange.com/questions/101379/overlapping-line-ordering/101497#101497">PurkkaKo</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Python3, 522 bytes</h1>
<pre class="lang-py prettyprint-override"><code>E=enumerate
def f(s):
 d={(x,y):v for x,r in E(s)for y,v in E(r)}
 q={(x,y):T[d[(x,y)]]for x,y in d if d[(x,y)]!=' 'and 0 in(T:={d.get(V:=(x+X,y+Y),0):V for X,Y in[(1,0),(0,1),(-1,0),(0,-1)]})and d[(x,y)]in T}
 r={}
 while q:
  J,K=q.pop(V:=[*q][0]);x,y=V;X,Y=J-x,K-y;l=[]
  while d.get(W:=(x+X,y+Y),' ').isalpha():l+=[d[W]];x,y=W;q.pop(W,0)
  r[d[V]]={*l}-{d[V]}
 q=[(T:=''.join(i for i in r if not r[i]),T)]
 for a,b in q:
  if[]==(Q:=[k for k in r if any(u in r[k]for u in a)]):return b[::-1]
  q+=[(Q[0],b+''.join(Q))]
</code></pre>
<p><a href="https://tio.run/##dVNRa@JAEH4@f8WcL9nVjZjawhHZhwpFaOFag2jD3nJEkpw5c0ncpD2D@Nu92TXRFrwFh5lvvpn5ZiRFXa3zbPStUMfjA4@ytz@RCqqoE0YxxKSkbgdCvic7VlP3HeJcwY4pSDJ4wKQOa/Z@ChU9dGDbcuciFMaT8lRUa1YISQxt4iu3wAqyEIaYInOX78PBr6giC5eTXf@V1X2fsiF1F2bsK/ORJoiDECND5qC128B2qDxQ3attjsPmqEfxPdq/6ySNYIu7wCN74ttBkRd6jOhtpRhKOsYSvhjjCP5o79iTXY9TLiTST5UnXcuPulA6HSRlkBbrgFA37XNceCmlabUcn0YsUR42UZhaSMn3vfRg77VvLiX0zpY1@J3j@olZMtFHUvpIWV5hXSIpm1MUopMBW@m0WSOJheSczHCHjUluzpVBVpM3E4mNub0JAiqpq6LqTWWwEq5rO3q9LcomMzwBW/VbJTNK5bF0gEO320WOB9DYycSbTBpf58qbMwlg6oMhtp6Hb@qjuZqdNO8MXRzTefShs6fNC3zy7/F52rzc/5czxefh7xPeDrhtBzyDb8T6XuNPn7Gm8Q31rqH6vm/0NkZD@iup8p@rPFCh@Vi@NCcWopfIy18aJ2kVKfI9zyIG5aAs0qQi1o/Mwlt3OoVKsorE5NLJoZRegW@uw6Pr8O11@A7h4z8" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1>Perl, 103+2 = 105 bytes</h1>

<pre class="lang-perl prettyprint-override"><code>s/$/$&quot;x y===c/gem;$a=$_;$_.=$&quot;while$a=~s/^./!($_.=$&amp;)/gem;s/$1/-/g,$b=&quot;$&amp;$b&quot;while/\s(\w)(\1|-)+ /;say$b
</code></pre>
<p>Run with <code>-n0</code> (2 byte penalty).</p>
<p>Explanation:</p>
<pre class="lang-perl prettyprint-override"><code># -n0: read entire input into `$_` at start of program
# (technically speaking it reads to the first NUL byte, but there aren't any)

# We want to be able to extract columns from the input, so we need to add spaces
# to the ends of each line such that each column is complete. Adding too many
# space is OK, so to ensure we have enough, we add a number of spaces equal to the
# length of the input.
s/$/             # At the end of {something},
$&quot; x             # append a number of spaces ($&quot; is a space by default)
y===c            # obtained by counting the characters in $_
/gem;            # where {something} is each (g) line (m)

$a = $_;         # store a copy of the transformed input in $a

# The next step is to create a transposition of the input. To do that, we
# repeatedly extract the first column of $a and append it to $_. This will lead to
# a bunch of junk whitespace at the end of $_ (of varying lengths, because once a
# line is empty it's omitted from the extracted column), but we're OK with that.
# To transpose properly, we'd want to place newlines between the extracted
# columns; however, it happens that the rest of the program treats space the same
# way it would newline, and separating via spaces is shorter, so we do that.

while (          # keep looping as long as there are matches
  $a =~ s/^./    # replace the first character of {something related to $a}
  !(             # with the null string (NOT of something truthy)
    $_.=$&amp;)      # but append that character ($&amp;) to $_
  /gem) {        # {something} is each (g) line (m) of $a
  $_.=$&quot;         # append a space ($&quot;, equivalent to newline here) to $_
}

# Finally, we repeatedly replace every character in the topmost line with the -
# character (treating a line as continuous through the - character but not through
# other characters), thus finding the lines from top to bottom. Because we
# appended the transpose of $_ to $_ above, each line appears twice: once
# horizontally, once vertically. We find only the horizontal copy, but replace
# both with hyphens.
# (Note: I rewrote the regex into a bit more readable of a form in this ungolfed
# version, because the original version wouldn't allow me room to write comments
# inside it. The two should be equivalent; I tested the golfed version.)
while (          # keep looping as long as there are matches
  /\s(\w)        # match a space or newline, $1 (a letter/digit/underscore),
    (\1|-)+      # any positive number of $1s and hyphens,
    \ /x) {      # and a space
  s/$1/-/g,      # changes all $1s to spaces; set $&amp; to $1, $1 becomes invalid
  $b = &quot;$&amp;$b&quot;    # prepend $&amp; to $b
}

# We need to output the lines from first (i.e. bottom) to last (i.e. top).
# We found them in the opposite order, but reversed them via prepending
# (not appending) the partial results to $b.
say $b           # output $b
</code></pre>
<p>One slight subtlety here comes with input like this:</p>
<pre>
   ABC
DDDDDDDDD
   ABC
   ABC
   ABC
</pre>
<p>Look at the fourth line here. If the order of writing were BACBD, there could genuinely be a <em>horizontal</em> line of <code>B</code>s along there without violating any of the assumptions of the problem (other than that there's only one line of each colour, something that we don't check). In order to get around this, we ensure in the last regex that each line <em>starts</em> with a letter (or digit or underscore, but those are impossible), and rely on the fact that parallel lines will be found left-to-right and top-to-bottom (because the regex will find the first match within the string). As such, the first character of each ambiguous line here gets overwritten before the line itself is seen as a match, and that prevents the regex matching.</p>
</div>
<div id="pu2" class="pu"><h1>Python 2, 199 bytes</h1>
<pre class="lang-python prettyprint-override"><code>l=input()
w=len(l[0])
j=&quot;&quot;.join(l)
c=set(j)-{&quot; &quot;}
def f(s):
 for h in s:
  i=j.index(h);I=j.rindex(h);o=f(s-{h})
  if{0}&gt;c-s&amp;set(j[i:I:w**(i+w&lt;=I)])and`o`&gt;&quot;Z&quot;:return[h]+o
 if{0}&gt;s:return[]
print f(c)
</code></pre>
<p>This ended up a lot longer than I initially thought it would. Apart from the <code>rindex</code> I could see this as a very good program to translate into Pyth.</p>
<p>Takes in a list of lines and outputs a list of characters. The code generates permutations recursively, making sure that none of the drawn lines are supposed to be drawn on top of the current line.</p>
<p>The code abuses a lot of Python's features, for example taking <code>w</code> to the power of a boolean, testing for empty sets by checking subsets of <code>{0}</code> (since my sets never contain non-strings), and my favorite, distinguishing any list from <code>None</code> by checking if its representation is greater than <code>Z</code>.</p>
<h3>Explained code</h3>
<pre class="lang-python prettyprint-override"><code>lines = input()
width = len(lines[0])
joined = &quot;&quot;.join(lines)
characters = set(joined) - {&quot; &quot;} # find unique characters except space in input

def solve(chars_left): # returns a solution for the given set of lines
    for try_char in chars_left: # try all lines left

        start_index = joined.index(try_char) # find start position of this line
        end_index = joined.rindex(try_char) # and end position

        step = width ** (start_index + width &lt;= end_index) # take every width'th character if start
                                                           # and end indices differ by at least width

        used_chars = characters - chars_left # find all drawn lines
   
        line_chars = set(joined[start_index:end_index:step]) # find the characters inside the current line
        missed_chars = used_chars &amp; line_chars # find all lines that are already drawn but should be on
                                               # top of this line
   
        solution = solve(chars_left - {try_char}) # find solutions if this line was drawn now

        if {0} &gt; missed_chars and `solution` &gt; &quot;Z&quot;: # there should be no missed lines and a solution
                                                    # should exist
            return [try_char] + solution # solution found, prepend current character and return

    if {0} &gt; chars_left: # if no lines are left
        return [] # solution found

print solve(characters) # solve for all lines
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/101379/">101379</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




