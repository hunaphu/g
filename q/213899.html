<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::213899</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>020</td><td>APLNARS</td><td>250323T104445Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/278861#278861">Rosario</a></td></tr>
<tr d-ix="1"><td>202</td><td>Python 3</td><td>250321T203644Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/278831#278831">CrSb0001</a></td></tr>
<tr d-ix="2"><td>002</td><td>Vyxal 3</td><td>250321T215932Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/278833#278833">Themooni</a></td></tr>
<tr d-ix="3"><td>020</td><td>05AB1E</td><td>201021T085405Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213920#213920">Kevin Cr</a></td></tr>
<tr d-ix="4"><td>350</td><td>Fortran GFortran</td><td>221228T102951Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/256103#256103">roblogic</a></td></tr>
<tr d-ix="5"><td>008</td><td>PARI/GP</td><td>221124T183720Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/254872#254872">Hugo Pfo</a></td></tr>
<tr d-ix="6"><td>003</td><td>q</td><td>221125T015852Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/254883#254883">cillianr</a></td></tr>
<tr d-ix="7"><td>023</td><td>APL Dyalog Unicode</td><td>201022T133837Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213953#213953">ovs</a></td></tr>
<tr d-ix="8"><td>048</td><td>Charcoal</td><td>201021T135201Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213927#213927">Neil</a></td></tr>
<tr d-ix="9"><td>232</td><td>Scala</td><td>201020T225057Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213909#213909">user</a></td></tr>
<tr d-ix="10"><td>003</td><td>Matlab</td><td>201026T052953Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/214163#214163">Dmitry K</a></td></tr>
<tr d-ix="11"><td>029</td><td>Excel</td><td>201023T211807Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/214053#214053">Engineer</a></td></tr>
<tr d-ix="12"><td>061</td><td>R</td><td>201020T213940Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213906#213906">Giuseppe</a></td></tr>
<tr d-ix="13"><td>188</td><td>Python 2</td><td>201022T130358Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213952#213952">lynn</a></td></tr>
<tr d-ix="14"><td>228</td><td>Python 2</td><td>201021T142511Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213929#213929">lynn</a></td></tr>
<tr d-ix="15"><td>057</td><td>Octave</td><td>201021T015709Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213913#213913">Sisyphus</a></td></tr>
<tr d-ix="16"><td>019</td><td>Ruby rmatrix</td><td>201021T094644Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213922#213922">Razetime</a></td></tr>
<tr d-ix="17"><td>011</td><td>SageMath</td><td>201020T233130Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213912#213912">Noodle9</a></td></tr>
<tr d-ix="18"><td>002</td><td>J</td><td>201021T070327Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213917#213917">Bubbler</a></td></tr>
<tr d-ix="19"><td>003</td><td>Jelly</td><td>201021T064123Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213916#213916">Kevin Cr</a></td></tr>
<tr d-ix="20"><td>004</td><td>MATL</td><td>201021T022336Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213914#213914">Mukundan</a></td></tr>
<tr d-ix="21"><td>169</td><td>JavaScript ES6</td><td>201020T230908Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213911#213911">Arnauld</a></td></tr>
<tr d-ix="22"><td>003</td><td>Julia 1.0</td><td>201020T215146Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213908#213908">Kirill L</a></td></tr>
<tr d-ix="23"><td>005</td><td>R</td><td>201020T210613Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213904#213904">Kirill L</a></td></tr>
<tr d-ix="24"><td>001</td><td>APL Dyalog Unicode</td><td>201020T204712Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213902#213902">RGS</a></td></tr>
<tr d-ix="25"><td>007</td><td>Wolfram Language Mathematica</td><td>201020T204409Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213901#213901">ZaMoC</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>APL(NARS), 20 chars</h1>
<pre><code>{⍉⊃{⍵⌹k}¨,/=/¨⍳⍴k←⍵}
</code></pre>
<p>This idea came from to see <a href="https://codegolf.stackexchange.com/a/213904/120560">https://codegolf.stackexchange.com/a/213904/120560</a> answer...
Here <code>⌹</code> is builtin that compute inverse matrix but Cramer rule too.
It seems one can easily build inverse of one input matrix nxn using Cramer rule for vectors each
row of identity matrix on n, build the matrix with rows result and traspose. So I use <code>⌹</code> only
for apply Cramer rule not as bultin inverse matrix...(and Cramer rule  would be in APL as 25 chars solution if it is need one answer without builtin)</p>
<p>this <code>=/¨⍳⍴k</code> is the identity matrix of matrix have dimensions of <code>k</code>.</p>
<pre><code>  f←{⍉⊃{⍵⌹k}¨,/=/¨⍳⍴k←⍵}
  aaa←3 3⍴ 1 3 5 7 5 1 7 6 3 2 1
  aaa
┌3─────┐
3 1 3 5│
│ 7 5 1│
│ 7 6 3│
└~─────┘
  f aaa
┌3──────────────┐
3  4.5  10.5 ¯11│
│ ¯7   ¯16    17│
│  3.5   7.5  ¯8│
└~──────────────┘
  ⌹ aaa
┌3──────────────┐
3  4.5  10.5 ¯11│
│ ¯7   ¯16    17│
│  3.5   7.5  ¯8│
└~──────────────┘
</code></pre>
<p>this is the test of the question, the first with input a list of float,
the second should be a list of rational numbers if mark with &quot;x&quot; the last
element.</p>
<pre><code>  f 3 3⍴ 4 ¯3 0  ¯4 ¯7 6  5 7 6
┌3──────────────────────────────────────────┐
3  0.1686746988 ¯0.03614457831 0.03614457831│
│ ¯0.1084337349 ¯0.04819277108 0.04819277108│
│ ¯0.0140562249  0.08634538153 0.08032128514│
└~──────────────────────────────────────────┘
  f 3 3⍴ 4 ¯3 0  ¯4 ¯7 6  5 7 6x
┌3────────────────────┐
3  14r83  ¯3r83   3r83│
│  ¯9r83  ¯4r83   4r83│
│ ¯7r498 43r498 20r249│
└~────────────────────┘
  
</code></pre>
</div>
<div id="pu1" class="pu"><h1>Python 3, <strike>211</strike> 202 bytes</h1>
<p><i><pre>
2025-03-22: -9 bytes</p>
<p>Currently loses to the most golfed Python solution by 14 bytes.
</pre></i></p>
<p>I know I'm losing to the sub-200 byte Python 2 answer, but I thought it was weird that there were no Python 3 answers, so I decided to try it out for myself. However I did beat the 228 byte Python 2 solution. :))</p>
<p>Actually I decided to do this because I wanted to use an inverted matrix method for an answer to <a href="https://codegolf.stackexchange.com/questions/8728/balance-chemical-equations?rq=1">this</a> problem (even though it's most definitely inefficient because of other methods that could be used) and ended up finding this question.</p>
<h2>Solution</h2>
<pre class="lang-python prettyprint-override"><code>e=enumerate
m=lambda l,i,j:[r[:j]+r[j+1:]for r in l[:i]+l[i+1:]]
d=lambda l:l==[]or sum([l[0][c]*(-1)**c*d(m(l,0,c))for c,_ in e(l)])
lambda l:[[(-1)**(x+y)*d(m(l,x,y))/d(l)for x,_ in e(l)]for y,_ in e(l)]
</code></pre>
<hr />
<h2>Old solution (258 bytes)</h2>
<pre class="lang-python prettyprint-override"><code>r=range
z=len
m=lambda l,i,j:[r[:j]+r[j+1:]for r in l[:i]+l[i+1:]]
d=lambda l:sum([l[0][c]*(-1)**c*d(m(l,0,c))for c in r(z(l))])if 2&lt;z(l)else l[0][0]*l[1][1]-l[0][1]*l[1][0]
i=lambda l:[[(-1)**(x+y)*d(m(l,x,y))/d(l)for x in r(z(l))]for y in r(z(l))]if d(l)else 0
</code></pre>
<ul>
<li><code>m</code> is the lambda function for getting cofactor matrices</li>
<li><code>d</code> is the lambda function for getting the determinant</li>
<li><code>i</code> is the lambda function that finally gets the inverse of the matrix.</li>
</ul>
<p>I had originally used <code>e=enumerate</code> in the first line (without the <code>r=</code> or <code>z=</code>), but somehow this had ended up losing me ~20-25 bytes over my 258 byte solution, so I had used <code>r=range</code>, <code>z=len</code> to circumvent that 'issue'.</p>
<p>Then I looked at @lynn's answer and saw that <code>e=enumerate</code> is indeed more efficient - I just need to write <code>for [var],_ in e(l)</code>. After that, I</p>
<ul>
<li>Realized that the OP only wants it to handle matrices with non-zero determinants, so 13 bytes saved in the main lambda.</li>
<li>Changed the check in the determinant function from <code>2&lt;len(l)</code> to <code>1&lt;len(l)</code> (and actually to <code>~-len(l)</code> since I can then write <code>if~-len(l)else l[0][0]</code>)
<ul>
<li>I then for really no reason decided to try out <code>if len(l)else 1</code> which for some reason works. I have tested the current version with invertible 2x2, 3x3, 4x4, and 5x5 matrices to actually make sure this change works, and it seems that it does, but still.</li>
</ul>
</li>
</ul>
<p>As of <code>2025-03-22</code>, I</p>
<ul>
<li>Have the determinant lambda do <code>l==[]or </code> at the beginning, as <code>True==1</code> in Python. (-7 bytes)</li>
<li>wrote the main function to compute the inverse - as I don't need to call it anywhere in the code - anonymously. (-2 bytes)</li>
</ul>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal/tree/version-3/" rel="nofollow noreferrer">Vyxal 3</a>, 2 bytes</h1>
<pre><code>Þ⅟
</code></pre>
<p><a href="https://vyxal.github.io/latest.html#H4sIAAAAAAAAA6tWSssvyk0sUbIy1lHKSE1MSS1SslJS0lFKzk9JBbIOz3vUOh_ITcvPL4FJpeUkphcrWUXH6ihl5hWUloDY0UruRfmlBQqGSjrRStHRJjq6xjoGsTrRukCWuY4ZkGWqA6JjlWJjgfrKUouKM_PzgOYZ65nrGSjVAgCdytwMiAAAAA" rel="nofollow noreferrer">Vyxal It Online!</a></p>
<p>boring builtin but I was testing the snippet builder so I might as well post it</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false" data-babel-preset-react="false" data-babel-preset-ts="false">
<div class="snippet-code">
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;script type="vyxal3"&gt;
Þ⅟
&lt;/script&gt;
&lt;script&gt;
    args=[["[[4,-3,0],[-4,-7,6],[5,7,6]]"]]
&lt;/script&gt;
&lt;script src="https://themoonisacheese.github.io/snippeterpreter/snippet.js" type="module"/&gt;</code></pre>
</div>
</div>
</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, <s>38</s> <s>22</s> <s>21</s> 20 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>˜nO/øтF©I2Føδ*O®}·s-
</code></pre>
<p>Port of <a href="https://codegolf.stackexchange.com/a/213913/52210"><em>@Sisyphus</em>' Octave answer</a>, so make sure to upvote him!!<br />
-16 bytes thanks to <em>@ovs</em>.</p>
<p><a href="https://tio.run/##yy9OTMpM/f//9Jw8f/3DOy42uR1a6WnkdnjHuS1a/ofW1R7aXqz7/390tImOrrGOQaxOtC6QZa5jBmSZ6oDo2P@6unn5ujmJVZUA" rel="nofollow noreferrer"><strong>Try this online.</strong></a></p>
<p><strong>Code explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>˜            # Flatten the (implicit) input-matrix to a single list
 n           # Square each value in this list
  O          # Take the sum (this is the trace of M*M')
   /         # Divide each value in the (implicit) input-matrix by this trace
    ø        # Zip/transpose this matrix; swapping rows/columns
тF           # Loop 100 times:
  ©          #  Store the current matrix in variable `®` (without popping)
   I         #  Push the input-matrix
    2F       #  Loop 2 times:
      ø      #   Zip/transpose the top matrix; swapping rows/columns
       δ     #   Apply double-vectorized with the top two matrices:
        *    #    Multiply
         O   #   Sum each inner row
          ®  #   Push the matrix from variable `®` again
     }·      #  After the inner loop: double all values in matrix `®`
       s     #  Swap so the calculated matrix VMV is at the top again
        -    #  Subtract this VMV from the 2V
             # (after the outer loop, the resulting matrix is output implicitly) 
</code></pre>
<hr />
<h2>Original answer (38 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a>) and detailed explanation:</h2>
<pre class="lang-python prettyprint-override"><code>εUεX*O]Å\OIøs/тFxs©εUIøεX*O}U®øεX*O}}-
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//3NbQc1sjtPxjD7fG@Hse3lGsf7HJraL40EqgBJALlqsNPbQOxqzV/f8/OtpER9dYxyBWJ1oXyDLXMQOyTHVAdOx/Xd28fN2cxKpKAA" rel="nofollow noreferrer"><strong>Try it online.</strong></a></p>
<p>05AB1E has barely any useful builtins for matrices, not even matrix multiplication. So almost everything has to be done manually..</p>
<p>Since I'm an absolute noob in math, I'm gonna explain everything in full detail to help others like me who want to do this challenge without any builtins, and also to keep this answer self-contained.</p>
<p><strong>Step 1)</strong> <a href="https://en.wikipedia.org/wiki/Matrix_multiplication#Definition" rel="nofollow noreferrer">Matrix multiplication</a> of the input-matrix <span class="math-container">\$M\$</span> with it's transpose: <span class="math-container">\$M\times M'\$</span>:</p>
<p>If we have a matrix <span class="math-container">\$A\$</span> and <span class="math-container">\$B\$</span> and want to do matrix-multiplication <span class="math-container">\$AB\$</span>, we take the <a href="https://en.wikipedia.org/wiki/Dot_product#Algebraic_definition" rel="nofollow noreferrer">dot-product</a> of every <span class="math-container">\$i^{th}\$</span> row of <span class="math-container">\$A\$</span> and <span class="math-container">\$j^{th}\$</span> column of B for every coordinate <span class="math-container">\$i,j\$</span> in the two matrices.</p>
<p>For example, if we use the matrix in the challenge description:</p>
<p><span class="math-container">\$M = \left[\begin{matrix}
 4 &amp; -3 &amp;  0 \\
-4 &amp; -7 &amp;  6 \\
 5 &amp;  7 &amp;  6
\end{matrix}\right]\$</span></p>
<p>We can for example calculate the values in the top row of the resulting <span class="math-container">\$M\times M'\$</span> matrix with:</p>
<p>Top-left: <span class="math-container">\$4\times4+-3\times-3+0\times0 = 25\$</span><br />
Top-center: <span class="math-container">\$4\times-4+-3\times-7+0\times6=5\$</span><br />
Top-right: <span class="math-container">\$4\times5+-3\times7+0\times6 = -1\$</span></p>
<p>I've done matrix multiplication in 05AB1E before in <a href="https://codegolf.stackexchange.com/a/197011/52210">this answer of mine</a>, so I've used that code snippet here as well. Since we want to multiply the input-matrix by it's transpose, we actually won't need the transpose builtin here.</p>
<pre class="lang-python prettyprint-override"><code>ε                  # Map over each row of the (implicit) input-matrix
 U                 #  Pop and store the current row in variable `X`
  ε                #  Map over each row of the (implicit) input-matrix again
   X*              #   Multiply the values of the current row by the values at the same
                   #   positions in row `X`
     O             #   And take the sum of this row
]                  # Close both maps
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//3NbQc1sjtPxj//@PjjbR0TXWMYjVidYFssx1zIAsUx0QHftfVzcvXzcnsaoSAA" rel="nofollow noreferrer">Try just this step online.</a></p>
<p><strong>Step 2)</strong> Take the <a href="https://en.wikipedia.org/wiki/Trace_(linear_algebra)#Definition" rel="nofollow noreferrer">trace</a> of this new matrix: <span class="math-container">\$(M\times M')^T\$</span></p>
<p>The trace of a square matrix is basically the sum of its main diagonal (the values of the top-left to the bottom-right).</p>
<pre class="lang-python prettyprint-override"><code>Å\                 # Take the main diagonal of the matrix of step 1
  O                # And sum the values in this list together
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//3NbQc1sjtPxjD7fG@P//Hx1toqNrrGMQqxOtC2SZ65gBWaY6IDr2v65uXr5uTmJVJQA" rel="nofollow noreferrer">Try the first two steps online.</a></p>
<p><strong>Step 3)</strong> Divide all values in the transposed matrix by this trace we calculated:</p>
<pre class="lang-python prettyprint-override"><code>I                  # Push the input-matrix
 ø                 # Zip/transpose it; swapping rows/columns
  s                # Swap so the trace we calculated it at the top of the stack
   /               # And divide each value in the transposed matrix by this trace
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//3NbQc1sjtPxjD7fG@Hse3lGs//9/dLSJjq6xjkGsTrQukGWuYwZkmeqA6Nj/urp5@bo5iVWVAA" rel="nofollow noreferrer">Try the first three steps online.</a></p>
<p><strong>Step 4)</strong> Repeat the following steps (5 through 8) enough times for the answer to not change anymore:</p>
<p>Since this program isn't very fast in 05AB1E, I've decided to loop just 100 times, but this can be increased to improve the accuracy of the decimal results (I've verified with <a href="https://codegolf.stackexchange.com/a/213913/52210"><em>@Sisyphus</em>' Octave answer</a> that changing the <code>1e4</code> to <code>1e2</code> still holds the same result for most matrices).</p>
<pre class="lang-python prettyprint-override"><code>тF                 # Loop 100 times:
</code></pre>
<p>I'm not sure if the values will eventually not change anymore if we loop enough times. If this is the case we could (in theory) save a byte by changing this <code>тF</code> to <code>Δ</code> (loop until the result no longer changes).</p>
<p>(Let's call the intermediate matrix inside this loop <span class="math-container">\$V\$</span> for the explanations of the following steps.)</p>
<p><strong>Step 5)</strong> Double each value in the current matrix: <span class="math-container">\$2V\$</span>:</p>
<pre class="lang-python prettyprint-override"><code>  x                #  Double each value in the current matrix V (without popping)
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//3NbQc1sjtPxjD7fG@Hse3lGsX/H/f3S0iY6usY5BrE60LpBlrmMGZJnqgOjY/7q6efm6OYlVlQA" rel="nofollow noreferrer">Try the first five steps online, excluding the loop of step 4.</a></p>
<p><strong>Step 6)</strong> Do matrix multiplication again for <span class="math-container">\$VM\$</span> (where <span class="math-container">\$M\$</span> is the input-matrix):</p>
<pre class="lang-python prettyprint-override"><code>   s               #  Swap to take the non-doubled matrix V at the top again
    ©              #  Store this matrix V in variable `®` (without popping)
     ε             #  Map over each row of matrix V:
      U            #   Pop the current row, and store it in variable `X`
       I           #   Push the input-matrix M
        ø          #   Zip/transpose; swapping rows/columns
         ε         #   Map over each row of this transposed matrix M':
          X*       #    Multiply the values in the current row by row `X`
            O      #    And take the sum
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//3NbQc1sjtPxjD7fG@Hse3lGsX1F8aCVQFMgGS/z/Hx1toqNrrGMQqxOtC2SZ65gBWaY6IDr2v65uXr5uTmJVJQA" rel="nofollow noreferrer">Try the first six steps online, excluding the loop of step 4.</a></p>
<p><strong>Step 7)</strong> And do matrix multiplication yet again right after: <span class="math-container">\$VMV\$</span>:</p>
<pre class="lang-python prettyprint-override"><code>         }         #   Close the inner map
          U        #   Pop and store this as new `X`
           ®       #   Push the matrix V from variable `®`
            ø      #   Zip/transpose; swapping rows/columns
             ε     #   Map over each row of this transposed matrix V':
              X*   #    Multiply the values in the current row by row `X`
                O  #    And take the sum
     }}            #  Close both the inner and outer maps
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//3NbQc1sjtPxjD7fG@Hse3lGsX1F8aCVQFMgGS9SGHloHY9b@/x8dbaKja6xjEKsTrQtkmeuYAVmmOiA69r@ubl6@bk5iVSUA" rel="nofollow noreferrer">Try the first seven steps online, excluding the loop of step 4.</a></p>
<p><strong>Step 8)</strong> Subtract the values at the same positions of these two matrices from one another: <span class="math-container">\$2V-VMV\$</span>:</p>
<pre class="lang-python prettyprint-override"><code>       -           #  Subtract matrix VMV from 2V
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//3NbQc1sjtPxjD7fG@Hse3lGsX1F8aCVQFMgGS9SGHloHY9bq/v8fHW2io2usYxCrE60LZJnrmAFZpjogOva/rm5evm5OYlUlAA" rel="nofollow noreferrer">Try the first eight steps online, excluding the loop of step 4.</a></p>
<p>And after the loop is done, the resulting matrix is output implicitly.</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://gcc.gnu.org/fortran/" rel="nofollow noreferrer">Fortran (GFortran)</a>, 350 <s>376</s> bytes</h1>
<pre class="lang-fortran prettyprint-override"><code>real,allocatable,dimension(:,:)::A,B,U;read*,n;allocate(A(n,n));B=A;U=A;read*,((A(i,j),j=1,n),i=1,n)
do i=1,n;do j=1,n;U(i,j)=merge(1,0,i==j);B(i,j)=merge(1.,1/A(i,j),A(i,j)==0);enddo;enddo
do 4 l=1,99;do 4 i=1,n;do 4 j=1,n;s=U(i,j);do k=1,n;m=i;if(k/=m)s=s-A(i,k)*B(k,j);enddo;B(m,j)=s/A(i,m)
4 continue;print'(3(x,f9.6))',((B(i,j),j=1,n),i=1,n)
end
</code></pre>
<p><a href="https://tio.run/##bU/RboQgEHznK3g7uKx3Gu01SnjQf/AD6IkXVKARm/Tv7QqmSZM@wExmJzO7o1@3VbnsNSay76tWC6hl8U@1qY9Fw2CsdsF4xxpoeNO00EEv0DZcwYnTqVnLHDjORSdb0eNLBoa6gYnDJAscg4lABk8jE0jiRPTRJq1eX5oVkKNTTpj2R75BcT/zEkiZc6HdMPj0H8EVXTCxrkXkvzXVWRRkqjq0OSpWGmFGNt@l5UGG7Iie@bVj82FL6R2zR12I9ZaTij6924z70uJzNW67sJJ9w1jfHpxf8Oruv6sxat9LgqtkJc1JhvhOH4S@UYr4Aw" rel="nofollow noreferrer">Try it Online!</a>
  <sub><s><a href="https://tio.run/##bVBBboQwELvnFbltsgqFFXQriOZA/sAD0iVUgZBUQKX@nk4C6vbQy4xlW/ZohrBsi/bZx3CAfV@MdkI7Fx560@/OiN7Oxq82eNaIhjdNK5ToJNr6q/DkdBrWMi8851JBKztoyWFgyFsxcjHCDWVh0yJ9oAlJBEkhdmAWYORdssMtEfmTKCJxZOVQcHXacp3AU4Q/IjG@74NMM1ZW1GFXXcuEfw@ojhPkCkdXtE6JmcFKTJ5ymPkKaxYrJn5VbELbmavYHMvWPIozJxV9BL9Z/2XI52L9dmEl@xZD/XLn/IL/UP/9A6P2vSR4SlbSgmS43@id0FdKcf8A" rel="nofollow noreferrer" title="Fortran (GFortran) – Try It Online">376 bytes</a></s></sub></p>
<p>Adapted from <a href="http://www.uprh.edu/rbaretti/MatrixInv17mar2014.htm" rel="nofollow noreferrer">here</a>. Saved 26 bytes using <code>merge</code> instead of <code>if</code>.</p>
</div>
<div id="pu5" class="pu"><h1>PARI/GP 8 bytes</h1>
<pre><code>f(A)=1/A
</code></pre>
<p>Built-in function; particularly efficient for matrices with integer matrix elements.</p>
<p>Most likely, the method used is similar to the one described in this refererence: H. Haramotu, M. Matsumotu, <a href="https://doi.org/10.1016/j.cam.2008.07.044" rel="nofollow noreferrer">A p-adic algorithm for computing the inverse of integer matrices</a>, Journal of Computational and Applied Mathematics, Volume 225, Issue 1, 1 March 2009, Pages 320-322.</p>
</div>
<div id="pu6" class="pu"><h1><a href="https://code.kx.com/" rel="nofollow noreferrer">q</a>, 3 bytes</h1>
<pre><code>inv
</code></pre>
<h1>k, 1 byte</h1>
<pre><code>!
</code></pre>
<p>Does exactly as requested. Input must be a float matrix</p>
</div>
<div id="pu7" class="pu"><h1><a href="https://www.dyalog.com/" rel="noreferrer">APL (Dyalog Unicode)</a>, <s>27</s> 23 <a href="https://github.com/abrudz/SBCS" rel="noreferrer">bytes</a></h1>
<p>-4 bytes thanks to <a href="https://codegolf.stackexchange.com/users/43319/ad%C3%A1m">Adám</a>!</p>
<p>This implements the method <a href="https://codegolf.stackexchange.com/a/213913/64121">advertised by Sisyphus</a>.</p>

<pre class="lang-apl prettyprint-override"><code>⊢(⊢+⊢-⊢+.×+.×)⍣≡⍉÷,+.×,
</code></pre>
<p><a href="https://tio.run/##SyzI0U2pTMzJT////1HXIg0g1gZiXRCtd3g6CGs@6l38qHPho97Ow9t1QAI6/9MetU141Nv3qKv5Ue@aR71bDq03ftQ28VHf1OAgZyAZ4uEZ/D9NwRgIgZIKhgoGYIigQeBR71wFz5TUvJLMkkoF38SSoswKLoQeEwWgmUC1h9aDWOYKZgqmCiASrC0gv7ikWCG1IjG3ICcVAA" rel="noreferrer" title="APL (Dyalog Unicode) – Try It Online">Try it online!</a></p>
<p>A function that takes the matrix as the right argument.</p>
<p><code>+.×</code> computes the dot product (sum of element-wise product) of the flattened matrix <code>,</code> and the flattened matrix <code>,</code>. This is sum of the squared matrix entries, which is equal to <span class="math-container">\$tr(AA^T)\$</span>.<br />
<code>⍉÷</code> divides the transposed matrix by the trace.</p>
<p><code>(⊢+⊢-⊢+.×+.×)⍣≡</code> is a function which is applied to the original matrix <span class="math-container">\$A\$</span> as a left argument (<code>⊢</code>) and <span class="math-container">\$A^T\div tr(AA^T)\$</span> as the right argument (<code>⍉÷,+.×,</code>):</p>
<p><code>⊢+⊢-⊢+.×+.×</code> takes the current matrix <span class="math-container">\$V\$</span> on its right and the input matrix <span class="math-container">\$A\$</span> on its left and executes one iteration step:<br />
<code>+.×</code> is the inner product of <code>+</code> and <code>×</code>. Given two matrices, this calculates their product. In this case <span class="math-container">\$ A \times V \$</span>.<br />
<code>⊢</code> is the right argument <span class="math-container">\$V\$</span>, <code>⊢+.×</code> the product <span class="math-container">\$V \times (A \times V)\$</span>.<br />
<code>⊢-</code> subtracts this from the right argument: <span class="math-container">\$V-V \times A \times V\$</span>.<br />
<code>⊢+</code> adds this to the right argument: <span class="math-container">\$V+V-V \times A \times V\$</span>.</p>
<p><code>⍣≡</code> applies the function on its left until the result doesn't change. Because of the way <a href="https://help.dyalog.com/18.0/Content/Language/System%20Functions/ct.htm" rel="noreferrer">equality testing works</a> in Dyalog APL, this actually terminates.</p>
</div>
<div id="pu8" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 48 bytes</h1>
<pre><code>≔Ｅθ∕Ｅθ§λκΣＥＸθ²ΣληＦφＵＭηＥκ⁻⊗μΣＥθ×ΣＥθ×§κς§ρπ§§ηπνＩη
</code></pre>
<p><a href="https://tio.run/##ZY67bsMwDEV3fwVHCqABJ30NngxnyRAgQLsZHtRYjQTrkUi2279XpaRGC5QLeS5f9yS5PzmuY2xCUGeLB37BK8FOLWoQKzXT3g7iCzXByBjB62xuraP7FD4PbH9EzXIQSFYXH84DbqqqYpBmW2cMtwNKyoRjSsrOAXduftdiQPPnbDr4powI@E9YjaT1hf368gSX@@NVWbPMHQLL7lEXR6/shC0PE8rEMXZd90hQPhBUPUFXZngheM7wRHAr@z6Wi/4G" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Explanation: Another port of @Sisyphus's answer.</p>
<pre><code>≔Ｅθ∕Ｅθ§λκΣＥＸθ²Σλη
</code></pre>
<p>Transpose the input and divide it by the sum of squares of all the elements. Sadly neither sum nor divide fully vectorise, so I have to divide a row at a time and calculate the sum via a nested loop.</p>
<pre><code>Ｆφ
</code></pre>
<p>Repeat 1000 times, which should be enough for floating-point precision.</p>
<pre><code>ＵＭηＥκ⁻⊗μΣＥθ×ΣＥθ×§κς§ρπ§§ηπν
</code></pre>
<p>Calculate the matrix multiplication and subtraction in-place. Charcoal doesn't have any vector or matrix operations, so we have to loop over the rows and columns manually, but there are a couple of places where we can share variables which saves us a couple of bytes each.</p>
<pre><code>Ｉη
</code></pre>
<p>Output the array. (Note that each element is output on its own line and each row is double-spaced from the previous.)</p>
</div>
<div id="pu9" class="pu"><h1><a href="http://www.scala-lang.org/" rel="nofollow noreferrer">Scala</a>, <s>237</s> 232 bytes</h1>
<p>Uses the method from <a href="https://codegolf.stackexchange.com/a/213913/95792">Sisyphus's answer</a>. Go upvote that!</p>

<pre class="lang-scala prettyprint-override"><code>m=&gt;{val h=m.indices
Seq.iterate(m.transpose.map(_.map(_/m.flatten.map(x=&gt;x*x).sum)),9999){v=&gt;h.map(i=&gt;h.map{j=&gt;2*v(i)(j)-(h.map(k=&gt;v(i).zip(m.transpose.apply(k))map(t=&gt;t._1*t._2)sum),v.transpose.apply(j)).zipped.map(_*_).sum})}last}
</code></pre>
<p><a href="https://tio.run/##nZFbS8MwGIbv8yvCrvKVNpvzhGICgpd6tUsdI9syl65pY5OVaulvr2mqDNkQMZDT8x3zxq5EJrpimcqVw09C5VjWTuZri@@NwQ2qRIbVLZ7Jt@d@PhT7ZSbnc8z4CdZpxps@Yss0VflaraRF3oUqJ0vhJNHUlSK3prCSamHIYljHmm4y4XzdcK8Zr6MaqN1rgPjGD2gqxrfBqL4OTcr4NKqIApJCQgbjjvGe0A9lftQSxmTvZAfQOznGHV2cRX6ZQl8jro5cUwhJjFwPHUaL0E4LbSasa7v@kVo4zPCjso4gPOwXdBLj5DzGE4i/WTLA6xhfHeBlzwJCgJApVe6ynCjicwLVu5nz5JWMXvIReHuLxtEgbUmqeAvsHzom/PAlm6Ik9V0ywa7AQV5Usd/U/aO49EjdUDoEnJb4ZEDr22mjcfcJ" rel="nofollow noreferrer" title="Scala – Try It Online">Try it online!</a></p>
<p><code>h</code> is just a range from 0 until n to reuse later (mostly because Scala doesn't have matrix multiplication builtins). The function makes a sequence of 9999 elements and takes the last element. The first element is the transpose of <code>m</code> divided by the trace of <code>m</code> times its transpose. Subsequent elements are calculated with <code>2*v-v*m*v</code>, where <code>v</code> was the previous element.</p>
<p>To calculate <span class="math-container">\$V_0\$</span> (It turns out the trace of <code>m</code> times its transpose is just the sum of squares of all of <code>m</code>'s cells):</p>
<pre class="lang-scala prettyprint-override"><code>m.transpose.map(            //For every row in m's transpose
  _.map(                    //For every cell in that row
    _ /                     //Divide it by (trace(M * M's transpose))
      m.flatten             //Turn m into a 1D list
        .map(x=&gt;x*x)        //Square each cell
        .sum))              //Add them up
</code></pre>
<p>To calculate subsequent elements, we use <span class="math-container">\$2V - (VA)V\$</span>, but you have to map over <code>h</code> instead of over <code>v</code> itself:</p>
<pre class="lang-scala prettyprint-override"><code>h.map(i =&gt;                 //For every i in [0, n)
  h.map{j =&gt;               //For every j in [0, n)
    2*v(i)(j) -            //2V at these coordinates minus
    &lt;(v * m * v)[i][j]&gt; }) //v*m*v at these coordinates (see explanation below)
</code></pre>
<p>To calculate <code>(v*m)[i]</code>:</p>
<pre class="lang-scala prettyprint-override"><code>h.map(k =&gt;                //k is the index of a row in [0, n)
  v(i).zip(               //Zip column i of v with
    m.transpose.apply(k)  //Row k of m (apply is used for indexing here)
  ) map(t=&gt;t._1*t._2)     //Multiply v(i)(j) with m(k)(i)
  sum                     //Add then up
)
</code></pre>
<p>And getting the cross product of that with row <code>j</code> of <code>v</code> uses pretty much the same approach.</p>
<hr />
<h1>Scala, <s>346</s> 342 bytes</h1>
<p>Saved 4 bytes thanks to <strong>@corvus_192</strong>!</p>
<pre class="lang-scala prettyprint-override"><code>type M=Seq[Seq[Double]]
def c(m:M)={val I=m.indices;I.map(i=&gt;I.map(j=&gt;m(i)(j)*math.pow(-1,i+j)))}
def d(m:M):(M,Double)=if(m.size&lt;2)m-&gt;m(0)(0)else{val I=m.indices
val M=I.map(i=&gt;I.map{j=&gt;d(I.filter(i!=_)map(k=&gt;I.filter(j!=_)map(m(k))))._2})
c(M)-&gt;c(m).head.zip(M.head).map(t=&gt;t._1*t._2).sum}
def i(m:M)=d(m)._1.transpose.map(_.map(_/d(m)._2))
</code></pre>
<p><a href="https://scastie.scala-lang.org/RihOhcl4QLuy8JaqEEzpGg" rel="nofollow noreferrer">Try it in Scastie!</a></p>
<p>As you can see, I'm not very good at math.</p>
</div>
<div id="pu10" class="pu"><h1><a href="https://au.mathworks.com/products/matlab.html" rel="nofollow noreferrer">Matlab</a> <sup><s>6</s></sup> 3 bytes</h1>

<pre class="lang-matlab prettyprint-override"><code>inv
</code></pre>
<p>Computes and prints the inverse of a square matrix. Pretty boring in-built solution. Thanks to @Bubbler for the clarification and -3 bytes.</p>
</div>
<div id="pu11" class="pu"><h1>Excel, 29 bytes</h1>
<pre><code>=MINVERSE(OFFSET(A2,,,A1,A1))
</code></pre>
<p>Straightforward application of the <a href="https://support.microsoft.com/en-us/office/minverse-function-11f55086-adde-4c9f-8eb9-59da2d72efc6" rel="noreferrer">MINVERSE()</a> function. It's boring but I got excited about Excel having a built-in for something. Input <span class="math-container">\$n\$</span> in <code>A1</code>, the matrix starting in <code>A2</code>, and the formula anywhere the spill won't interfere.</p>
<p><a href="https://i.sstatic.net/qFsgT.png" rel="noreferrer"><img src="https://i.sstatic.net/qFsgT.png" alt="Screenshot" /></a></p>
</div>
<div id="pu12" class="pu"><h1><a href="https://www.r-project.org/" rel="nofollow noreferrer">R</a>, <s>72</s> 61 bytes</h1>

<pre class="lang-r prettyprint-override"><code>function(A,V=t(A/sum(diag(A%*%t(A))))){for(i in 1:1e4)V=2*V-V%*%A%*%V;V}
</code></pre>
<p><a href="https://tio.run/##vY3dCoMwDIXv9xS5EVJJ2eoPmxu98B1G78XZUVALWsdg7Nm7Vn2GhSQn@XIgk9fS62VsnbEj1qSkw/o4LwM@TPPEOkmTAFiMj7YTGjAjiKvoCqZkliqugiO61E19vcahcZN5Y4sFQU7AS4IwcXEiuBBUa48wX5dqP4mg5yD7WG2eWIHyYkNZFEZQrnln7DDb/tX99aX/AQ" rel="nofollow noreferrer" title="R – Try It Online">Try it online!</a></p>
<p>Porting <a href="https://codegolf.stackexchange.com/a/213913/67312">Sisyphus' answer</a> is not futile at all...and thanks to Sisyphus for -11 bytes.</p>
<p>Observes that <span class="math-container">\$Tr(AA^T)=\sum\limits_{i,j}a_{ij}^2\$</span>.</p>
<h1><a href="https://www.r-project.org/" rel="nofollow noreferrer">R</a>, 94 bytes</h1>

<pre class="lang-r prettyprint-override"><code>function(M)outer(k&lt;-1:dim(M),k,Vectorize(function(j,i)det(M[-i,-j,drop=F])*(-1)^(i+j)))/det(M)
</code></pre>
<p><a href="https://tio.run/##vY3BCsIwDIbvPkWPiaZo3YZO3NXbbuJFFGTroJtbpXYivnztuuEjCEn@P19@iHFV5qq@K6zSHeSoeysNNHsudqVqPaCGTrKw2qiPhF@wJoWltJCfuSJeU2n0IztccA5c4BXUokbEZUigq6C9WaPeUEBMLCLGE2LecbEitiWWhjnAKCzpdBJeN14mm46ZoT3l8YjWgyCxJNQRcfbU95f860v3BQ" rel="nofollow noreferrer" title="R – Try It Online">Try it online!</a></p>
<p>Thanks to <a href="https://codegolf.stackexchange.com/users/86301/robin-ryder">Robin Ryder</a> for fixing a bug and making this actually work.</p>
<p>Calculates <span class="math-container">\$A^{-1}\$</span> using the adjugate/determinant method.</p>
</div>
<div id="pu13" class="pu"><h1><a href="https://docs.python.org/2/" rel="noreferrer">Python 2</a>, 188 bytes</h1>

<pre class="lang-python prettyprint-override"><code>lambda a:[[c(a,j,i)/d(a)for j,_ in e(a)]for i,_ in e(a)]
c=lambda a,i,j:(-1)**(i+j)*d([b[:j]+b[j+1:]for I,b in e(a)if i-I])
d=lambda a:a==[]or sum(b[0]*c(a,i,0)for i,b in e(a))
e=enumerate
</code></pre>
<p><a href="https://tio.run/##TY5NDoIwEEb3nKLLFgYs/iZNegDPMDamhRKnETSIC0@PBQNx82Ve8r2ZeX6G26Pbjo2@jHfbutoyqxArbiEAiU3NrWgePQtwZdQxH9FMTH@cVHpRgSAonpciTTllQaQ1R4cqmMxhyEo1u2dwi0sNo/xsRFKvK5TVGk2svd4tdyhNOj1DIMXv7uqKxGvfvVvf28GPz566gTUccV9IyHcxZCENYD7zKcZx5kOcFjJi/AI" rel="noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>
<p>The top lambda computes <span class="math-container">\$A^{-1} = \frac{1}{\det(A)}\text{adj}(A)\$</span>.</p>
<p><code>d(a)</code> computes the determinant and <code>c(a,i,j)</code> computes cofactors.</p>
</div>
<div id="pu14" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>, 228 bytes</h1>

<pre class="lang-python prettyprint-override"><code>from random import*
a=input()
exec"""$:j,J=i,I;J+=[j==i $]
while~-all(I[i]$):shuffle(a)
$:
 j,J=i,I
 $:
&#9;if j-i:I[:]=[y-I[j]*x/J[j]for x,y in zip(J,I)]
$:print[x/I[i]for x in I][len(a):]""".replace("$","for i,I in enumerate(a)")
</code></pre>
<p><a href="https://tio.run/##NU5BbsMgEDyXVyDkg53gJGraVKLiAfgLiANKQV4LY0Rt1e6hX3eXqL3szEgzO5O2uZ/i8777PI002/iBAGOa8nwgVkJMy1w3xK3uzhirxMA7CVy9d0epBymBVoZ89RDcT2tDqJUGUzXis1@8D662DakEoX8hQlE8gadDC0JpYaTeWqUHc1jPHYKfMl35RiHSb0h1x1VjMJ8yxFmv5/L7YSkGZXRwEQuEwV2n7FKwd1ezinFWTFhXbC4uo8t2LlNYs@9aX04X3l7xIDFcty9Fv@G5PfQrsn9lfgE" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>
<p>Augment the matrix with the identity matrix, then apply Gauss–Jordan elimination. I don't know if this is the shortest approach, but it's the one I wanted to try golfing down.</p>
<p>I use <code>while not all(a[i][i]for i in r):shuffle(a)</code> to move zeros off the diagonal. This loop will definitely terminate, because if there is <em>no</em> permutation of the rows of <span class="math-container">\$A\$</span> that makes the diagonal free of zeros, then <span class="math-container">\$\det(A)=0\$</span>, which we are guaranteed is not the case. This can be seen from the Leibniz formula for <span class="math-container">\$\det(A)\$</span>:</p>
<p><span class="math-container">$$\det(A) = \sum_{\sigma \in S_n} \text{sgn}(\sigma) \prod_{i=1}^n a_{\sigma(i),i}$$</span></p>
<p>“There is no permutation <span class="math-container">\$\sigma\$</span> of the rows that makes the diagonal free of zeros” can be equivalently rephrased as “<span class="math-container">\$\prod_{i=1}^n a_{\sigma(i),i}\$</span> is always 0, for all <span class="math-container">\$\sigma\$</span>” which causes this whole formula to be 0.</p>
</div>
<div id="pu15" class="pu"><h1><a href="https://www.gnu.org/software/octave/" rel="noreferrer">Octave</a>, 57 bytes</h1>

<pre class="lang-matlab prettyprint-override"><code>A=input('');V=A'/trace(A*A');for i=1:1e4V=2*V-V*A*V;end
V
</code></pre>
<p><a href="https://tio.run/##y08uSSxL/f/f0TYzr6C0RENdXdM6zNZRXb@kKDE5VcNRyxEokJZfpJBpa2hlmGoSZmukFaYbpuWoFWadmpfCFfY/M69Mw1Hzf1FiXoqGsY6xJgA" rel="noreferrer" title="Octave – Try It Online">Try it online!</a></p>
<p>This is not particularly well golfed, but I wanted to advertise an approach that could be useful for other non-builtin answers.</p>
<p>This uses the Hotelling-Bodewig scheme:</p>
<p><span class="math-container">$$ V_{i+1} = V_i\left(2I - AV_i\right)$$</span></p>
<p>Which iteratively computes the inverse of a non singular matrix. This is guaranteed to converge for <span class="math-container">\$\left\lVert I - AV_0\right\rVert &lt; 1\$</span> (under a suitable matrix norm). Choosing the <span class="math-container">\$V_0\$</span> is difficult, but Soleymani, F. shows in <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.882.7271&amp;rep=rep1&amp;type=pdf" rel="noreferrer">&quot;A New Method For Solving Ill-Conditioned Linear Systems&quot;</a> that the inital guess <span class="math-container">\$V_0 = \frac{A^T}{\text{tr}(AA^T)}\$</span> will always satisfy this condition, so the system is numerically stable.</p>
<p>What makes this a particularly attractive approach to other potential answers is that we don't require any builtin determinant or inverse functions. The most complex part is just matrix multiplication, since the transpose and trace are trivial to compute.</p>
<p>I have chosen <code>1e4</code> iterations here to make the runtime somewhat reasonable, although you could of course push it to <code>1e9</code> with no loss of byte count.</p>
<hr />
<p>-10 thanks to <a href="https://codegolf.stackexchange.com/users/20260/xnor">xnor</a> for noting we don't need to construct an identity matrix.</p>
</div>
<div id="pu16" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a> <code>-rmatrix</code>, <sup><s>23</s></sup> 19 bytes</h1>

<pre class="lang-ruby prettyprint-override"><code>-&gt;a{Matrix[*a].inv}
</code></pre>
<p><a href="https://tio.run/##KypNqvyfZvtf1y6x2jexpCizIlorMVYvM6@s9n@BQlp0dLSCiY6usY6CQaxOtC6Qaa6jYAZkKpjqKICZsbH//@UXlGTm5xX/1y3KBRsBAA" rel="nofollow noreferrer" title="Ruby – Try It Online">Try it online!</a></p>
<p>Returns the result as a Ruby matrix object.</p>
<p>-4 bytes from Dingus.</p>
</div>
<div id="pu17" class="pu"><h1><a href="https://www.sagemath.org/" rel="nofollow noreferrer">SageMath</a>, <sup><s>14</s> <s>13</s></sup> 11 bytes</h1>
<p>Saved a byte thanks to <a href="https://codegolf.stackexchange.com/users/31625/fryamtheeggman">FryAmTheEggman</a>!!!<br />
Saved 2 bytes thanks to <a href="https://codegolf.stackexchange.com/users/48931/sisyphus">Sisyphus</a>!!!</p>

<pre class="lang-sagemath prettyprint-override"><code>lambda M:~M
</code></pre>
<p><a href="https://sagecell.sagemath.org/?z=eJxLs43hyknMTUpJVPC1qvPl4ipJLS5RsFXITSwpyqzQiI420dE10TGN1YnWNdbRNdcxB7IMdMx0zGJjNbkKijLzSjRAOoBs2zQYCyxaoAkAz70bIw==&amp;lang=sage&amp;interacts=eJyLjgUAARUAuQ==" rel="nofollow noreferrer">Try it online!</a></p>
<p>Inputs any square <code>matrix</code> and returns its inverse.</p>
</div>
<div id="pu18" class="pu"><h1><a href="http://jsoftware.com/" rel="noreferrer">J</a>, 2 bytes</h1>
<pre><code>%.
</code></pre>
<p><a href="https://tio.run/##y/qfmpyRb6Rga6UQbaUAYqvZKairq1n/V9X7/z83sQQkY6IQb6xgoKCjEA9kmSuYKehYKZgqABlcEM2qekCFcLZChZUCkA8A" rel="noreferrer" title="J – Try It Online">Try it online!</a></p>
<p>Same as APL, but more powerful, as J can produce exact rational matrix when given a matrix of extended integers as input.</p>
</div>
<div id="pu19" class="pu"><h1><a href="https://github.com/DennisMitchell/jellylanguage/wiki" rel="noreferrer">Jelly</a>, 3 <a href="https://github.com/DennisMitchell/jellylanguage/wiki/Code-page" rel="noreferrer">bytes</a></h1>
<pre><code>æ*-
</code></pre>
<p><a href="https://tio.run/##y0rNyan8///wMi3d////R0eb6Oga6xjE6kTrAlnmOmZAlqkOiI4FAA" rel="noreferrer">Try it online.</a></p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>     # Full program taking a single integer-matrix as argument
æ*   #  Matrix exponentiation
  -  #  with -1
     #  (after which the result is output implicitly)
</code></pre>
</div>
<div id="pu20" class="pu"><h1><a href="https://github.com/lmendo/MATL" rel="nofollow noreferrer">MATL</a>, 4 bytes</h1>
<pre><code>-1Y^
</code></pre>
<p><a href="https://tio.run/##y00syfn/X9cwMu7//2gTBV1jBQNrBV0gw1zBzFrBVAFIxQIA" rel="nofollow noreferrer" title="MATL – Try It Online">Try it online!</a></p>
<h2>Explanation</h2>
<pre><code>-1Y^
-1   : Push -1 onto the stack
  Y^ : Raise implicit input to -1 power
</code></pre>
</div>
<div id="pu21" class="pu"><h1>JavaScript (ES6), 169 bytes</h1>
<p>This computes <span class="math-container">\$M^{-1} = \dfrac{\operatorname{adj}(M)}{\det(M)}\$</span></p>

<pre class="lang-javascript prettyprint-override"><code>M=&gt;M.map((r,y)=&gt;r.map((_,x)=&gt;D(h(M,x).map(r=&gt;h(r,y)))*(x+y&amp;1?-1:1)/D(M)),h=(a,n)=&gt;a.filter(_=&gt;n--),D=M=&gt;+M||M.reduce((s,[v],i)=&gt;s+(i&amp;1?-v:v)*D(h(M,i).map(r=&gt;h(r,0))),0))
</code></pre>
<p><a href="https://tio.run/##VY7NasQgFEb3eQpXnetE7aTttDBgugndueoyHQbJT@OQaDBWMjDvnpoIhW7kO5fveu5VejlVVo2OalM3S8sXwXPBBjkCWHLDPLcRLmQOUEAHIqRtZnnebSWM9zCnt4fsnWanDD8WIDAmHQdJdFiSrFW9ayxceK4pxaTgQZKK@10w29Q/VQMwkdKfiQrtKQW1/uRPHu@jT/3zHYJvfZbW2EE6xNGAeI4qoyfTN6w33zDE/jqO5/s1eubMh5qbGrInzEZZfzppHWRHjNnVKA07tPuLXzrkJIkOaKFMECrRC6HPBB3OZCUa6I2g10joSNBGyTnc9gs" rel="noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
</div>
<div id="pu22" class="pu"><h1><a href="http://julialang.org/" rel="noreferrer">Julia 1.0</a>, 3 bytes</h1>

<pre class="lang-julia prettyprint-override"><code>inv
</code></pre>
<p><a href="https://tio.run/##yyrNyUw0rPifZvs/M6/sf0FRZl6JRppGtImCsYKuqYKJgq6hgbWChYIlEAP5xtZAliVIUMFQQdfcWgHCsATJ6ZpaK5gr6JqAuEZAIlZT8z8A" rel="noreferrer" title="Julia 1.0 – Try It Online">Try it online!</a></p>
<p>Yet another short built-in solution.</p>
</div>
<div id="pu23" class="pu"><h1><a href="https://www.r-project.org/" rel="noreferrer">R</a>, 5 bytes</h1>

<pre class="lang-r prettyprint-override"><code>solve
</code></pre>
<p><a href="https://tio.run/##K/qfZvu/OD@nLPV/mkZuYklRZoVGsoaJjoKxjoKuqY4CkKVraKCjYKGjYAkmQYLGYI4lVMoQSJsDKSjTEqIGhIGiuiYQISMQpamjYApGIZqa/wE" rel="noreferrer" title="R – Try It Online">Try it online!</a></p>
<p>Nothing new here...
Basically, the code <code>solve(A, B)</code> solves <span class="math-container">\$AX = B\$</span>, but when <span class="math-container">\$B\$</span> is not given, it is treated as identity matrix, thus giving us the inverse as the result.</p>
</div>
<div id="pu24" class="pu"><h1><a href="https://www.dyalog.com/" rel="noreferrer">APL (Dyalog Unicode)</a>, 1 byte<sup><a href="https://en.wikipedia.org/wiki/SBCS" rel="noreferrer">SBCS</a></sup></h1>

<pre class="lang-apl prettyprint-override"><code>⌹
</code></pre>
<p><a href="https://tio.run/##SyzI0U2pTMzJT////1HPzv@P@qY@apugAGQqGCkYPerdYmigYKFwaD0Y/wcA" rel="noreferrer" title="APL (Dyalog Unicode) – Try It Online">Try it online!</a></p>
<p>The domino primitive is a very interesting APL &quot;built-in&quot;. It already <a href="https://codegolf.stackexchange.com/a/205897/75323">featured in another 1-byte answer of my own</a> where it was used to solve a least-squares problem. When applied to a square matrix, <code>⌹</code> tries to find the matrix inverse of its argument.</p>
<p>Many golfing languages will also have a built-in for this... But mind you, APL is <strong>not</strong> a golfing language, although it is terse enough to be very competitive and, in cases like this, win.</p>
</div>
<div id="pu25" class="pu"><h1><a href="https://www.wolfram.com/wolframscript/" rel="noreferrer">Wolfram Language (Mathematica)</a>, 7 bytes</h1>
<pre><code>Inverse
</code></pre>
<p><a href="https://tio.run/##y00syUjNTSzJTE78n2773zOvLLWoOPV/QFFmXomCg59DenR1ta65joKuERADaSBlDGRZ1uooVEPYlmBBXRMgNjQACeuagZhAbApSqKNgAFQDFjcFKwaSJmAtpiBBA4gakHpDiA26RmDFJhAJkADIPAsQrq3liv3/HwA" rel="noreferrer" title="Wolfram Language (Mathematica) – Try It Online">Try it online!</a></p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/213899/">213899</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




