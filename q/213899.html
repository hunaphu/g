<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::213899</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>020</td><td>05AB1E</td><td>201021T085405Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213920#213920">Kevin Cr</a></td></tr>
<tr d-ix="1"><td>350</td><td>Fortran GFortran</td><td>221228T102951Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/256103#256103">roblogic</a></td></tr>
<tr d-ix="2"><td>008</td><td>PARI/GP</td><td>221124T183720Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/254872#254872">Hugo Pfo</a></td></tr>
<tr d-ix="3"><td>003</td><td>q</td><td>221125T015852Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/254883#254883">cillianr</a></td></tr>
<tr d-ix="4"><td>023</td><td>APL Dyalog Unicode</td><td>201022T133837Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213953#213953">ovs</a></td></tr>
<tr d-ix="5"><td>048</td><td>Charcoal</td><td>201021T135201Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213927#213927">Neil</a></td></tr>
<tr d-ix="6"><td>232</td><td>Scala</td><td>201020T225057Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213909#213909">user</a></td></tr>
<tr d-ix="7"><td>003</td><td>Matlab</td><td>201026T052953Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/214163#214163">Dmitry K</a></td></tr>
<tr d-ix="8"><td>029</td><td>Excel</td><td>201023T211807Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/214053#214053">Engineer</a></td></tr>
<tr d-ix="9"><td>061</td><td>R</td><td>201020T213940Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213906#213906">Giuseppe</a></td></tr>
<tr d-ix="10"><td>188</td><td>Python 2</td><td>201022T130358Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213952#213952">lynn</a></td></tr>
<tr d-ix="11"><td>228</td><td>Python 2</td><td>201021T142511Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213929#213929">lynn</a></td></tr>
<tr d-ix="12"><td>057</td><td>Octave</td><td>201021T015709Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213913#213913">Sisyphus</a></td></tr>
<tr d-ix="13"><td>019</td><td>Ruby rmatrix</td><td>201021T094644Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213922#213922">Razetime</a></td></tr>
<tr d-ix="14"><td>011</td><td>SageMath</td><td>201020T233130Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213912#213912">Noodle9</a></td></tr>
<tr d-ix="15"><td>002</td><td>J</td><td>201021T070327Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213917#213917">Bubbler</a></td></tr>
<tr d-ix="16"><td>003</td><td>Jelly</td><td>201021T064123Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213916#213916">Kevin Cr</a></td></tr>
<tr d-ix="17"><td>004</td><td>MATL</td><td>201021T022336Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213914#213914">Mukundan</a></td></tr>
<tr d-ix="18"><td>169</td><td>JavaScript ES6</td><td>201020T230908Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213911#213911">Arnauld</a></td></tr>
<tr d-ix="19"><td>003</td><td>Julia 1.0</td><td>201020T215146Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213908#213908">Kirill L</a></td></tr>
<tr d-ix="20"><td>005</td><td>R</td><td>201020T210613Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213904#213904">Kirill L</a></td></tr>
<tr d-ix="21"><td>001</td><td>APL Dyalog Unicode</td><td>201020T204712Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213902#213902">RGS</a></td></tr>
<tr d-ix="22"><td>007</td><td>Wolfram Language Mathematica</td><td>201020T204409Z</td><td><a href="https://codegolf.stackexchange.com/questions/213899/calculate-the-inverse-of-a-matrix/213901#213901">ZaMoC</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, <s>38</s> <s>22</s> <s>21</s> 20 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>˜nO/øтF©I2Føδ*O®}·s-
</code></pre>
<p>Port of <a href="https://codegolf.stackexchange.com/a/213913/52210"><em>@Sisyphus</em>' Octave answer</a>, so make sure to upvote him!!<br />
-16 bytes thanks to <em>@ovs</em>.</p>
<p><a href="https://tio.run/##yy9OTMpM/f//9Jw8f/3DOy42uR1a6WnkdnjHuS1a/ofW1R7aXqz7/390tImOrrGOQaxOtC6QZa5jBmSZ6oDo2P@6unn5ujmJVZUA" rel="nofollow noreferrer"><strong>Try this online.</strong></a></p>
<p><strong>Code explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>˜            # Flatten the (implicit) input-matrix to a single list
 n           # Square each value in this list
  O          # Take the sum (this is the trace of M*M')
   /         # Divide each value in the (implicit) input-matrix by this trace
    ø        # Zip/transpose this matrix; swapping rows/columns
тF           # Loop 100 times:
  ©          #  Store the current matrix in variable `®` (without popping)
   I         #  Push the input-matrix
    2F       #  Loop 2 times:
      ø      #   Zip/transpose the top matrix; swapping rows/columns
       δ     #   Apply double-vectorized with the top two matrices:
        *    #    Multiply
         O   #   Sum each inner row
          ®  #   Push the matrix from variable `®` again
     }·      #  After the inner loop: double all values in matrix `®`
       s     #  Swap so the calculated matrix VMV is at the top again
        -    #  Subtract this VMV from the 2V
             # (after the outer loop, the resulting matrix is output implicitly) 
</code></pre>
<hr />
<h2>Original answer (38 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a>) and detailed explanation:</h2>
<pre class="lang-python prettyprint-override"><code>εUεX*O]Å\OIøs/тFxs©εUIøεX*O}U®øεX*O}}-
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//3NbQc1sjtPxjD7fG@Hse3lGsf7HJraL40EqgBJALlqsNPbQOxqzV/f8/OtpER9dYxyBWJ1oXyDLXMQOyTHVAdOx/Xd28fN2cxKpKAA" rel="nofollow noreferrer"><strong>Try it online.</strong></a></p>
<p>05AB1E has barely any useful builtins for matrices, not even matrix multiplication. So almost everything has to be done manually..</p>
<p>Since I'm an absolute noob in math, I'm gonna explain everything in full detail to help others like me who want to do this challenge without any builtins, and also to keep this answer self-contained.</p>
<p><strong>Step 1)</strong> <a href="https://en.wikipedia.org/wiki/Matrix_multiplication#Definition" rel="nofollow noreferrer">Matrix multiplication</a> of the input-matrix <span class="math-container">\$M\$</span> with it's transpose: <span class="math-container">\$M\times M'\$</span>:</p>
<p>If we have a matrix <span class="math-container">\$A\$</span> and <span class="math-container">\$B\$</span> and want to do matrix-multiplication <span class="math-container">\$AB\$</span>, we take the <a href="https://en.wikipedia.org/wiki/Dot_product#Algebraic_definition" rel="nofollow noreferrer">dot-product</a> of every <span class="math-container">\$i^{th}\$</span> row of <span class="math-container">\$A\$</span> and <span class="math-container">\$j^{th}\$</span> column of B for every coordinate <span class="math-container">\$i,j\$</span> in the two matrices.</p>
<p>For example, if we use the matrix in the challenge description:</p>
<p><span class="math-container">\$M = \left[\begin{matrix}
 4 &amp; -3 &amp;  0 \\
-4 &amp; -7 &amp;  6 \\
 5 &amp;  7 &amp;  6
\end{matrix}\right]\$</span></p>
<p>We can for example calculate the values in the top row of the resulting <span class="math-container">\$M\times M'\$</span> matrix with:</p>
<p>Top-left: <span class="math-container">\$4\times4+-3\times-3+0\times0 = 25\$</span><br />
Top-center: <span class="math-container">\$4\times-4+-3\times-7+0\times6=5\$</span><br />
Top-right: <span class="math-container">\$4\times5+-3\times7+0\times6 = -1\$</span></p>
<p>I've done matrix multiplication in 05AB1E before in <a href="https://codegolf.stackexchange.com/a/197011/52210">this answer of mine</a>, so I've used that code snippet here as well. Since we want to multiply the input-matrix by it's transpose, we actually won't need the transpose builtin here.</p>
<pre class="lang-python prettyprint-override"><code>ε                  # Map over each row of the (implicit) input-matrix
 U                 #  Pop and store the current row in variable `X`
  ε                #  Map over each row of the (implicit) input-matrix again
   X*              #   Multiply the values of the current row by the values at the same
                   #   positions in row `X`
     O             #   And take the sum of this row
]                  # Close both maps
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//3NbQc1sjtPxj//@PjjbR0TXWMYjVidYFssx1zIAsUx0QHftfVzcvXzcnsaoSAA" rel="nofollow noreferrer">Try just this step online.</a></p>
<p><strong>Step 2)</strong> Take the <a href="https://en.wikipedia.org/wiki/Trace_(linear_algebra)#Definition" rel="nofollow noreferrer">trace</a> of this new matrix: <span class="math-container">\$(M\times M')^T\$</span></p>
<p>The trace of a square matrix is basically the sum of its main diagonal (the values of the top-left to the bottom-right).</p>
<pre class="lang-python prettyprint-override"><code>Å\                 # Take the main diagonal of the matrix of step 1
  O                # And sum the values in this list together
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//3NbQc1sjtPxjD7fG@P//Hx1toqNrrGMQqxOtC2SZ65gBWaY6IDr2v65uXr5uTmJVJQA" rel="nofollow noreferrer">Try the first two steps online.</a></p>
<p><strong>Step 3)</strong> Divide all values in the transposed matrix by this trace we calculated:</p>
<pre class="lang-python prettyprint-override"><code>I                  # Push the input-matrix
 ø                 # Zip/transpose it; swapping rows/columns
  s                # Swap so the trace we calculated it at the top of the stack
   /               # And divide each value in the transposed matrix by this trace
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//3NbQc1sjtPxjD7fG@Hse3lGs//9/dLSJjq6xjkGsTrQukGWuYwZkmeqA6Nj/urp5@bo5iVWVAA" rel="nofollow noreferrer">Try the first three steps online.</a></p>
<p><strong>Step 4)</strong> Repeat the following steps (5 through 8) enough times for the answer to not change anymore:</p>
<p>Since this program isn't very fast in 05AB1E, I've decided to loop just 100 times, but this can be increased to improve the accuracy of the decimal results (I've verified with <a href="https://codegolf.stackexchange.com/a/213913/52210"><em>@Sisyphus</em>' Octave answer</a> that changing the <code>1e4</code> to <code>1e2</code> still holds the same result for most matrices).</p>
<pre class="lang-python prettyprint-override"><code>тF                 # Loop 100 times:
</code></pre>
<p>I'm not sure if the values will eventually not change anymore if we loop enough times. If this is the case we could (in theory) save a byte by changing this <code>тF</code> to <code>Δ</code> (loop until the result no longer changes).</p>
<p>(Let's call the intermediate matrix inside this loop <span class="math-container">\$V\$</span> for the explanations of the following steps.)</p>
<p><strong>Step 5)</strong> Double each value in the current matrix: <span class="math-container">\$2V\$</span>:</p>
<pre class="lang-python prettyprint-override"><code>  x                #  Double each value in the current matrix V (without popping)
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//3NbQc1sjtPxjD7fG@Hse3lGsX/H/f3S0iY6usY5BrE60LpBlrmMGZJnqgOjY/7q6efm6OYlVlQA" rel="nofollow noreferrer">Try the first five steps online, excluding the loop of step 4.</a></p>
<p><strong>Step 6)</strong> Do matrix multiplication again for <span class="math-container">\$VM\$</span> (where <span class="math-container">\$M\$</span> is the input-matrix):</p>
<pre class="lang-python prettyprint-override"><code>   s               #  Swap to take the non-doubled matrix V at the top again
    ©              #  Store this matrix V in variable `®` (without popping)
     ε             #  Map over each row of matrix V:
      U            #   Pop the current row, and store it in variable `X`
       I           #   Push the input-matrix M
        ø          #   Zip/transpose; swapping rows/columns
         ε         #   Map over each row of this transposed matrix M':
          X*       #    Multiply the values in the current row by row `X`
            O      #    And take the sum
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//3NbQc1sjtPxjD7fG@Hse3lGsX1F8aCVQFMgGS/z/Hx1toqNrrGMQqxOtC2SZ65gBWaY6IDr2v65uXr5uTmJVJQA" rel="nofollow noreferrer">Try the first six steps online, excluding the loop of step 4.</a></p>
<p><strong>Step 7)</strong> And do matrix multiplication yet again right after: <span class="math-container">\$VMV\$</span>:</p>
<pre class="lang-python prettyprint-override"><code>         }         #   Close the inner map
          U        #   Pop and store this as new `X`
           ®       #   Push the matrix V from variable `®`
            ø      #   Zip/transpose; swapping rows/columns
             ε     #   Map over each row of this transposed matrix V':
              X*   #    Multiply the values in the current row by row `X`
                O  #    And take the sum
     }}            #  Close both the inner and outer maps
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//3NbQc1sjtPxjD7fG@Hse3lGsX1F8aCVQFMgGS9SGHloHY9b@/x8dbaKja6xjEKsTrQtkmeuYAVmmOiA69r@ubl6@bk5iVSUA" rel="nofollow noreferrer">Try the first seven steps online, excluding the loop of step 4.</a></p>
<p><strong>Step 8)</strong> Subtract the values at the same positions of these two matrices from one another: <span class="math-container">\$2V-VMV\$</span>:</p>
<pre class="lang-python prettyprint-override"><code>       -           #  Subtract matrix VMV from 2V
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//3NbQc1sjtPxjD7fG@Hse3lGsX1F8aCVQFMgGS9SGHloHY9bq/v8fHW2io2usYxCrE60LZJnrmAFZpjogOva/rm5evm5OYlUlAA" rel="nofollow noreferrer">Try the first eight steps online, excluding the loop of step 4.</a></p>
<p>And after the loop is done, the resulting matrix is output implicitly.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://gcc.gnu.org/fortran/" rel="nofollow noreferrer">Fortran (GFortran)</a>, 350 <s>376</s> bytes</h1>
<pre class="lang-fortran prettyprint-override"><code>real,allocatable,dimension(:,:)::A,B,U;read*,n;allocate(A(n,n));B=A;U=A;read*,((A(i,j),j=1,n),i=1,n)
do i=1,n;do j=1,n;U(i,j)=merge(1,0,i==j);B(i,j)=merge(1.,1/A(i,j),A(i,j)==0);enddo;enddo
do 4 l=1,99;do 4 i=1,n;do 4 j=1,n;s=U(i,j);do k=1,n;m=i;if(k/=m)s=s-A(i,k)*B(k,j);enddo;B(m,j)=s/A(i,m)
4 continue;print'(3(x,f9.6))',((B(i,j),j=1,n),i=1,n)
end
</code></pre>
<p><a href="https://tio.run/##bU/RboQgEHznK3g7uKx3Gu01SnjQf/AD6IkXVKARm/Tv7QqmSZM@wExmJzO7o1@3VbnsNSay76tWC6hl8U@1qY9Fw2CsdsF4xxpoeNO00EEv0DZcwYnTqVnLHDjORSdb0eNLBoa6gYnDJAscg4lABk8jE0jiRPTRJq1eX5oVkKNTTpj2R75BcT/zEkiZc6HdMPj0H8EVXTCxrkXkvzXVWRRkqjq0OSpWGmFGNt@l5UGG7Iie@bVj82FL6R2zR12I9ZaTij6924z70uJzNW67sJJ9w1jfHpxf8Oruv6sxat9LgqtkJc1JhvhOH4S@UYr4Aw" rel="nofollow noreferrer">Try it Online!</a>
  <sub><s><a href="https://tio.run/##bVBBboQwELvnFbltsgqFFXQriOZA/sAD0iVUgZBUQKX@nk4C6vbQy4xlW/ZohrBsi/bZx3CAfV@MdkI7Fx560@/OiN7Oxq82eNaIhjdNK5ToJNr6q/DkdBrWMi8851JBKztoyWFgyFsxcjHCDWVh0yJ9oAlJBEkhdmAWYORdssMtEfmTKCJxZOVQcHXacp3AU4Q/IjG@74NMM1ZW1GFXXcuEfw@ojhPkCkdXtE6JmcFKTJ5ymPkKaxYrJn5VbELbmavYHMvWPIozJxV9BL9Z/2XI52L9dmEl@xZD/XLn/IL/UP/9A6P2vSR4SlbSgmS43@id0FdKcf8A" rel="nofollow noreferrer" title="Fortran (GFortran) – Try It Online">376 bytes</a></s></sub></p>
<p>Adapted from <a href="http://www.uprh.edu/rbaretti/MatrixInv17mar2014.htm" rel="nofollow noreferrer">here</a>. Saved 26 bytes using <code>merge</code> instead of <code>if</code>.</p>
</div>
<div id="pu2" class="pu"><h1>PARI/GP 8 bytes</h1>
<pre><code>f(A)=1/A
</code></pre>
<p>Built-in function; particularly efficient for matrices with integer matrix elements.</p>
<p>Most likely, the method used is similar to the one described in this refererence: H. Haramotu, M. Matsumotu, <a href="https://doi.org/10.1016/j.cam.2008.07.044" rel="nofollow noreferrer">A p-adic algorithm for computing the inverse of integer matrices</a>, Journal of Computational and Applied Mathematics, Volume 225, Issue 1, 1 March 2009, Pages 320-322.</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://code.kx.com/" rel="nofollow noreferrer">q</a>, 3 bytes</h1>
<pre><code>inv
</code></pre>
<h1>k, 1 byte</h1>
<pre><code>!
</code></pre>
<p>Does exactly as requested. Input must be a float matrix</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://www.dyalog.com/" rel="nofollow noreferrer">APL (Dyalog Unicode)</a>, <s>27</s> 23 <a href="https://github.com/abrudz/SBCS" rel="nofollow noreferrer">bytes</a></h1>
<p>-4 bytes thanks to <a href="https://codegolf.stackexchange.com/users/43319/ad%C3%A1m">Adám</a>!</p>
<p>This implements the method <a href="https://codegolf.stackexchange.com/a/213913/64121">advertised by Sisyphus</a>.</p>

<pre class="lang-apl prettyprint-override"><code>⊢(⊢+⊢-⊢+.×+.×)⍣≡⍉÷,+.×,
</code></pre>
<p><a href="https://tio.run/##SyzI0U2pTMzJT////1HXIg0g1gZiXRCtd3g6CGs@6l38qHPho97Ow9t1QAI6/9MetU141Nv3qKv5Ue@aR71bDq03ftQ28VHf1OAgZyAZ4uEZ/D9NwRgIgZIKhgoGYIigQeBR71wFz5TUvJLMkkoF38SSoswKLoQeEwWgmUC1h9aDWOYKZgqmCiASrC0gv7ikWCG1IjG3ICcVAA" rel="nofollow noreferrer" title="APL (Dyalog Unicode) – Try It Online">Try it online!</a></p>
<p>A function that takes the matrix as the right argument.</p>
<p><code>+.×</code> computes the dot product (sum of element-wise product) of the flattened matrix <code>,</code> and the flattened matrix <code>,</code>. This is sum of the squared matrix entries, which is equal to <span class="math-container">\$tr(AA^T)\$</span>.<br />
<code>⍉÷</code> divides the transposed matrix by the trace.</p>
<p><code>(⊢+⊢-⊢+.×+.×)⍣≡</code> is a function which is applied to the original matrix <span class="math-container">\$A\$</span> as a left argument (<code>⊢</code>) and <span class="math-container">\$A^T\div tr(AA^T)\$</span> as the right argument (<code>⍉÷,+.×,</code>):</p>
<p><code>⊢+⊢-⊢+.×+.×</code> takes the current matrix <span class="math-container">\$V\$</span> on its right and the input matrix <span class="math-container">\$A\$</span> on its left and executes one iteration step:<br />
<code>+.×</code> is the inner product of <code>+</code> and <code>×</code>. Given two matrices, this calculates their product. In this case <span class="math-container">\$ A \times V \$</span>.<br />
<code>⊢</code> is the right argument <span class="math-container">\$V\$</span>, <code>⊢+.×</code> the product <span class="math-container">\$V \times (A \times V)\$</span>.<br />
<code>⊢-</code> subtracts this from the right argument: <span class="math-container">\$V-V \times A \times V\$</span>.<br />
<code>⊢+</code> adds this to the right argument: <span class="math-container">\$V+V-V \times A \times V\$</span>.</p>
<p><code>⍣≡</code> applies the function on its left until the result doesn't change. Because of the way <a href="https://help.dyalog.com/18.0/Content/Language/System%20Functions/ct.htm" rel="nofollow noreferrer">equality testing works</a> in Dyalog APL, this actually terminates.</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 48 bytes</h1>
<pre><code>≔Ｅθ∕Ｅθ§λκΣＥＸθ²ΣληＦφＵＭηＥκ⁻⊗μΣＥθ×ΣＥθ×§κς§ρπ§§ηπνＩη
</code></pre>
<p><a href="https://tio.run/##ZY67bsMwDEV3fwVHCqABJ30NngxnyRAgQLsZHtRYjQTrkUi2279XpaRGC5QLeS5f9yS5PzmuY2xCUGeLB37BK8FOLWoQKzXT3g7iCzXByBjB62xuraP7FD4PbH9EzXIQSFYXH84DbqqqYpBmW2cMtwNKyoRjSsrOAXduftdiQPPnbDr4powI@E9YjaT1hf368gSX@@NVWbPMHQLL7lEXR6/shC0PE8rEMXZd90hQPhBUPUFXZngheM7wRHAr@z6Wi/4G" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Explanation: Another port of @Sisyphus's answer.</p>
<pre><code>≔Ｅθ∕Ｅθ§λκΣＥＸθ²Σλη
</code></pre>
<p>Transpose the input and divide it by the sum of squares of all the elements. Sadly neither sum nor divide fully vectorise, so I have to divide a row at a time and calculate the sum via a nested loop.</p>
<pre><code>Ｆφ
</code></pre>
<p>Repeat 1000 times, which should be enough for floating-point precision.</p>
<pre><code>ＵＭηＥκ⁻⊗μΣＥθ×ΣＥθ×§κς§ρπ§§ηπν
</code></pre>
<p>Calculate the matrix multiplication and subtraction in-place. Charcoal doesn't have any vector or matrix operations, so we have to loop over the rows and columns manually, but there are a couple of places where we can share variables which saves us a couple of bytes each.</p>
<pre><code>Ｉη
</code></pre>
<p>Output the array. (Note that each element is output on its own line and each row is double-spaced from the previous.)</p>
</div>
<div id="pu6" class="pu"><h1><a href="http://www.scala-lang.org/" rel="nofollow noreferrer">Scala</a>, <s>237</s> 232 bytes</h1>
<p>Uses the method from <a href="https://codegolf.stackexchange.com/a/213913/95792">Sisyphus's answer</a>. Go upvote that!</p>

<pre class="lang-scala prettyprint-override"><code>m=&gt;{val h=m.indices
Seq.iterate(m.transpose.map(_.map(_/m.flatten.map(x=&gt;x*x).sum)),9999){v=&gt;h.map(i=&gt;h.map{j=&gt;2*v(i)(j)-(h.map(k=&gt;v(i).zip(m.transpose.apply(k))map(t=&gt;t._1*t._2)sum),v.transpose.apply(j)).zipped.map(_*_).sum})}last}
</code></pre>
<p><a href="https://tio.run/##nZFbS8MwGIbv8yvCrvKVNpvzhGICgpd6tUsdI9syl65pY5OVaulvr2mqDNkQMZDT8x3zxq5EJrpimcqVw09C5VjWTuZri@@NwQ2qRIbVLZ7Jt@d@PhT7ZSbnc8z4CdZpxps@Yss0VflaraRF3oUqJ0vhJNHUlSK3prCSamHIYljHmm4y4XzdcK8Zr6MaqN1rgPjGD2gqxrfBqL4OTcr4NKqIApJCQgbjjvGe0A9lftQSxmTvZAfQOznGHV2cRX6ZQl8jro5cUwhJjFwPHUaL0E4LbSasa7v@kVo4zPCjso4gPOwXdBLj5DzGE4i/WTLA6xhfHeBlzwJCgJApVe6ynCjicwLVu5nz5JWMXvIReHuLxtEgbUmqeAvsHzom/PAlm6Ik9V0ywa7AQV5Usd/U/aO49EjdUDoEnJb4ZEDr22mjcfcJ" rel="nofollow noreferrer" title="Scala – Try It Online">Try it online!</a></p>
<p><code>h</code> is just a range from 0 until n to reuse later (mostly because Scala doesn't have matrix multiplication builtins). The function makes a sequence of 9999 elements and takes the last element. The first element is the transpose of <code>m</code> divided by the trace of <code>m</code> times its transpose. Subsequent elements are calculated with <code>2*v-v*m*v</code>, where <code>v</code> was the previous element.</p>
<p>To calculate <span class="math-container">\$V_0\$</span> (It turns out the trace of <code>m</code> times its transpose is just the sum of squares of all of <code>m</code>'s cells):</p>
<pre class="lang-scala prettyprint-override"><code>m.transpose.map(            //For every row in m's transpose
  _.map(                    //For every cell in that row
    _ /                     //Divide it by (trace(M * M's transpose))
      m.flatten             //Turn m into a 1D list
        .map(x=&gt;x*x)        //Square each cell
        .sum))              //Add them up
</code></pre>
<p>To calculate subsequent elements, we use <span class="math-container">\$2V - (VA)V\$</span>, but you have to map over <code>h</code> instead of over <code>v</code> itself:</p>
<pre class="lang-scala prettyprint-override"><code>h.map(i =&gt;                 //For every i in [0, n)
  h.map{j =&gt;               //For every j in [0, n)
    2*v(i)(j) -            //2V at these coordinates minus
    &lt;(v * m * v)[i][j]&gt; }) //v*m*v at these coordinates (see explanation below)
</code></pre>
<p>To calculate <code>(v*m)[i]</code>:</p>
<pre class="lang-scala prettyprint-override"><code>h.map(k =&gt;                //k is the index of a row in [0, n)
  v(i).zip(               //Zip column i of v with
    m.transpose.apply(k)  //Row k of m (apply is used for indexing here)
  ) map(t=&gt;t._1*t._2)     //Multiply v(i)(j) with m(k)(i)
  sum                     //Add then up
)
</code></pre>
<p>And getting the cross product of that with row <code>j</code> of <code>v</code> uses pretty much the same approach.</p>
<hr />
<h1>Scala, <s>346</s> 342 bytes</h1>
<p>Saved 4 bytes thanks to <strong>@corvus_192</strong>!</p>
<pre class="lang-scala prettyprint-override"><code>type M=Seq[Seq[Double]]
def c(m:M)={val I=m.indices;I.map(i=&gt;I.map(j=&gt;m(i)(j)*math.pow(-1,i+j)))}
def d(m:M):(M,Double)=if(m.size&lt;2)m-&gt;m(0)(0)else{val I=m.indices
val M=I.map(i=&gt;I.map{j=&gt;d(I.filter(i!=_)map(k=&gt;I.filter(j!=_)map(m(k))))._2})
c(M)-&gt;c(m).head.zip(M.head).map(t=&gt;t._1*t._2).sum}
def i(m:M)=d(m)._1.transpose.map(_.map(_/d(m)._2))
</code></pre>
<p><a href="https://scastie.scala-lang.org/RihOhcl4QLuy8JaqEEzpGg" rel="nofollow noreferrer">Try it in Scastie!</a></p>
<p>As you can see, I'm not very good at math.</p>
</div>
<div id="pu7" class="pu"><h1><a href="https://au.mathworks.com/products/matlab.html" rel="nofollow noreferrer">Matlab</a> <sup><s>6</s></sup> 3 bytes</h1>

<pre class="lang-matlab prettyprint-override"><code>inv
</code></pre>
<p>Computes and prints the inverse of a square matrix. Pretty boring in-built solution. Thanks to @Bubbler for the clarification and -3 bytes.</p>
</div>
<div id="pu8" class="pu"><h1>Excel, 29 bytes</h1>
<pre><code>=MINVERSE(OFFSET(A2,,,A1,A1))
</code></pre>
<p>Straightforward application of the <a href="https://support.microsoft.com/en-us/office/minverse-function-11f55086-adde-4c9f-8eb9-59da2d72efc6" rel="noreferrer">MINVERSE()</a> function. It's boring but I got excited about Excel having a built-in for something. Input <span class="math-container">\$n\$</span> in <code>A1</code>, the matrix starting in <code>A2</code>, and the formula anywhere the spill won't interfere.</p>
<p><a href="https://i.sstatic.net/qFsgT.png" rel="noreferrer"><img src="https://i.sstatic.net/qFsgT.png" alt="Screenshot" /></a></p>
</div>
<div id="pu9" class="pu"><h1><a href="https://www.r-project.org/" rel="nofollow noreferrer">R</a>, <s>72</s> 61 bytes</h1>

<pre class="lang-r prettyprint-override"><code>function(A,V=t(A/sum(diag(A%*%t(A))))){for(i in 1:1e4)V=2*V-V%*%A%*%V;V}
</code></pre>
<p><a href="https://tio.run/##vY3dCoMwDIXv9xS5EVJJ2eoPmxu98B1G78XZUVALWsdg7Nm7Vn2GhSQn@XIgk9fS62VsnbEj1qSkw/o4LwM@TPPEOkmTAFiMj7YTGjAjiKvoCqZkliqugiO61E19vcahcZN5Y4sFQU7AS4IwcXEiuBBUa48wX5dqP4mg5yD7WG2eWIHyYkNZFEZQrnln7DDb/tX99aX/AQ" rel="nofollow noreferrer" title="R – Try It Online">Try it online!</a></p>
<p>Porting <a href="https://codegolf.stackexchange.com/a/213913/67312">Sisyphus' answer</a> is not futile at all...and thanks to Sisyphus for -11 bytes.</p>
<p>Observes that <span class="math-container">\$Tr(AA^T)=\sum\limits_{i,j}a_{ij}^2\$</span>.</p>
<h1><a href="https://www.r-project.org/" rel="nofollow noreferrer">R</a>, 94 bytes</h1>

<pre class="lang-r prettyprint-override"><code>function(M)outer(k&lt;-1:dim(M),k,Vectorize(function(j,i)det(M[-i,-j,drop=F])*(-1)^(i+j)))/det(M)
</code></pre>
<p><a href="https://tio.run/##vY3BCsIwDIbvPkWPiaZo3YZO3NXbbuJFFGTroJtbpXYivnztuuEjCEn@P19@iHFV5qq@K6zSHeSoeysNNHsudqVqPaCGTrKw2qiPhF@wJoWltJCfuSJeU2n0IztccA5c4BXUokbEZUigq6C9WaPeUEBMLCLGE2LecbEitiWWhjnAKCzpdBJeN14mm46ZoT3l8YjWgyCxJNQRcfbU95f860v3BQ" rel="nofollow noreferrer" title="R – Try It Online">Try it online!</a></p>
<p>Thanks to <a href="https://codegolf.stackexchange.com/users/86301/robin-ryder">Robin Ryder</a> for fixing a bug and making this actually work.</p>
<p>Calculates <span class="math-container">\$A^{-1}\$</span> using the adjugate/determinant method.</p>
</div>
<div id="pu10" class="pu"><h1><a href="https://docs.python.org/2/" rel="noreferrer">Python 2</a>, 188 bytes</h1>

<pre class="lang-python prettyprint-override"><code>lambda a:[[c(a,j,i)/d(a)for j,_ in e(a)]for i,_ in e(a)]
c=lambda a,i,j:(-1)**(i+j)*d([b[:j]+b[j+1:]for I,b in e(a)if i-I])
d=lambda a:a==[]or sum(b[0]*c(a,i,0)for i,b in e(a))
e=enumerate
</code></pre>
<p><a href="https://tio.run/##TY5NDoIwEEb3nKLLFgYs/iZNegDPMDamhRKnETSIC0@PBQNx82Ve8r2ZeX6G26Pbjo2@jHfbutoyqxArbiEAiU3NrWgePQtwZdQxH9FMTH@cVHpRgSAonpciTTllQaQ1R4cqmMxhyEo1u2dwi0sNo/xsRFKvK5TVGk2svd4tdyhNOj1DIMXv7uqKxGvfvVvf28GPz566gTUccV9IyHcxZCENYD7zKcZx5kOcFjJi/AI" rel="noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>
<p>The top lambda computes <span class="math-container">\$A^{-1} = \frac{1}{\det(A)}\text{adj}(A)\$</span>.</p>
<p><code>d(a)</code> computes the determinant and <code>c(a,i,j)</code> computes cofactors.</p>
</div>
<div id="pu11" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>, 228 bytes</h1>

<pre class="lang-python prettyprint-override"><code>from random import*
a=input()
exec"""$:j,J=i,I;J+=[j==i $]
while~-all(I[i]$):shuffle(a)
$:
 j,J=i,I
 $:
&#9;if j-i:I[:]=[y-I[j]*x/J[j]for x,y in zip(J,I)]
$:print[x/I[i]for x in I][len(a):]""".replace("$","for i,I in enumerate(a)")
</code></pre>
<p><a href="https://tio.run/##NU5BbsMgEDyXVyDkg53gJGraVKLiAfgLiANKQV4LY0Rt1e6hX3eXqL3szEgzO5O2uZ/i8777PI002/iBAGOa8nwgVkJMy1w3xK3uzhirxMA7CVy9d0epBymBVoZ89RDcT2tDqJUGUzXis1@8D662DakEoX8hQlE8gadDC0JpYaTeWqUHc1jPHYKfMl35RiHSb0h1x1VjMJ8yxFmv5/L7YSkGZXRwEQuEwV2n7FKwd1ezinFWTFhXbC4uo8t2LlNYs@9aX04X3l7xIDFcty9Fv@G5PfQrsn9lfgE" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>
<p>Augment the matrix with the identity matrix, then apply Gauss–Jordan elimination. I don't know if this is the shortest approach, but it's the one I wanted to try golfing down.</p>
<p>I use <code>while not all(a[i][i]for i in r):shuffle(a)</code> to move zeros off the diagonal. This loop will definitely terminate, because if there is <em>no</em> permutation of the rows of <span class="math-container">\$A\$</span> that makes the diagonal free of zeros, then <span class="math-container">\$\det(A)=0\$</span>, which we are guaranteed is not the case. This can be seen from the Leibniz formula for <span class="math-container">\$\det(A)\$</span>:</p>
<p><span class="math-container">$$\det(A) = \sum_{\sigma \in S_n} \text{sgn}(\sigma) \prod_{i=1}^n a_{\sigma(i),i}$$</span></p>
<p>“There is no permutation <span class="math-container">\$\sigma\$</span> of the rows that makes the diagonal free of zeros” can be equivalently rephrased as “<span class="math-container">\$\prod_{i=1}^n a_{\sigma(i),i}\$</span> is always 0, for all <span class="math-container">\$\sigma\$</span>” which causes this whole formula to be 0.</p>
</div>
<div id="pu12" class="pu"><h1><a href="https://www.gnu.org/software/octave/" rel="noreferrer">Octave</a>, 57 bytes</h1>

<pre class="lang-matlab prettyprint-override"><code>A=input('');V=A'/trace(A*A');for i=1:1e4V=2*V-V*A*V;end
V
</code></pre>
<p><a href="https://tio.run/##y08uSSxL/f/f0TYzr6C0RENdXdM6zNZRXb@kKDE5VcNRyxEokJZfpJBpa2hlmGoSZmukFaYbpuWoFWadmpfCFfY/M69Mw1Hzf1FiXoqGsY6xJgA" rel="noreferrer" title="Octave – Try It Online">Try it online!</a></p>
<p>This is not particularly well golfed, but I wanted to advertise an approach that could be useful for other non-builtin answers.</p>
<p>This uses the Hotelling-Bodewig scheme:</p>
<p><span class="math-container">$$ V_{i+1} = V_i\left(2I - AV_i\right)$$</span></p>
<p>Which iteratively computes the inverse of a non singular matrix. This is guaranteed to converge for <span class="math-container">\$\left\lVert I - AV_0\right\rVert &lt; 1\$</span> (under a suitable matrix norm). Choosing the <span class="math-container">\$V_0\$</span> is difficult, but Soleymani, F. shows in <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.882.7271&amp;rep=rep1&amp;type=pdf" rel="noreferrer">&quot;A New Method For Solving Ill-Conditioned Linear Systems&quot;</a> that the inital guess <span class="math-container">\$V_0 = \frac{A^T}{\text{tr}(AA^T)}\$</span> will always satisfy this condition, so the system is numerically stable.</p>
<p>What makes this a particularly attractive approach to other potential answers is that we don't require any builtin determinant or inverse functions. The most complex part is just matrix multiplication, since the transpose and trace are trivial to compute.</p>
<p>I have chosen <code>1e4</code> iterations here to make the runtime somewhat reasonable, although you could of course push it to <code>1e9</code> with no loss of byte count.</p>
<hr />
<p>-10 thanks to <a href="https://codegolf.stackexchange.com/users/20260/xnor">xnor</a> for noting we don't need to construct an identity matrix.</p>
</div>
<div id="pu13" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a> <code>-rmatrix</code>, <sup><s>23</s></sup> 19 bytes</h1>

<pre class="lang-ruby prettyprint-override"><code>-&gt;a{Matrix[*a].inv}
</code></pre>
<p><a href="https://tio.run/##KypNqvyfZvtf1y6x2jexpCizIlorMVYvM6@s9n@BQlp0dLSCiY6usY6CQaxOtC6Qaa6jYAZkKpjqKICZsbH//@UXlGTm5xX/1y3KBRsBAA" rel="nofollow noreferrer" title="Ruby – Try It Online">Try it online!</a></p>
<p>Returns the result as a Ruby matrix object.</p>
<p>-4 bytes from Dingus.</p>
</div>
<div id="pu14" class="pu"><h1><a href="https://www.sagemath.org/" rel="nofollow noreferrer">SageMath</a>, <sup><s>14</s> <s>13</s></sup> 11 bytes</h1>
<p>Saved a byte thanks to <a href="https://codegolf.stackexchange.com/users/31625/fryamtheeggman">FryAmTheEggman</a>!!!<br />
Saved 2 bytes thanks to <a href="https://codegolf.stackexchange.com/users/48931/sisyphus">Sisyphus</a>!!!</p>

<pre class="lang-sagemath prettyprint-override"><code>lambda M:~M
</code></pre>
<p><a href="https://sagecell.sagemath.org/?z=eJxLs43hyknMTUpJVPC1qvPl4ipJLS5RsFXITSwpyqzQiI420dE10TGN1YnWNdbRNdcxB7IMdMx0zGJjNbkKijLzSjRAOoBs2zQYCyxaoAkAz70bIw==&amp;lang=sage&amp;interacts=eJyLjgUAARUAuQ==" rel="nofollow noreferrer">Try it online!</a></p>
<p>Inputs any square <code>matrix</code> and returns its inverse.</p>
</div>
<div id="pu15" class="pu"><h1><a href="http://jsoftware.com/" rel="noreferrer">J</a>, 2 bytes</h1>
<pre><code>%.
</code></pre>
<p><a href="https://tio.run/##y/qfmpyRb6Rga6UQbaUAYqvZKairq1n/V9X7/z83sQQkY6IQb6xgoKCjEA9kmSuYKehYKZgqABlcEM2qekCFcLZChZUCkA8A" rel="noreferrer" title="J – Try It Online">Try it online!</a></p>
<p>Same as APL, but more powerful, as J can produce exact rational matrix when given a matrix of extended integers as input.</p>
</div>
<div id="pu16" class="pu"><h1><a href="https://github.com/DennisMitchell/jellylanguage/wiki" rel="noreferrer">Jelly</a>, 3 <a href="https://github.com/DennisMitchell/jellylanguage/wiki/Code-page" rel="noreferrer">bytes</a></h1>
<pre><code>æ*-
</code></pre>
<p><a href="https://tio.run/##y0rNyan8///wMi3d////R0eb6Oga6xjE6kTrAlnmOmZAlqkOiI4FAA" rel="noreferrer">Try it online.</a></p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>     # Full program taking a single integer-matrix as argument
æ*   #  Matrix exponentiation
  -  #  with -1
     #  (after which the result is output implicitly)
</code></pre>
</div>
<div id="pu17" class="pu"><h1><a href="https://github.com/lmendo/MATL" rel="nofollow noreferrer">MATL</a>, 4 bytes</h1>
<pre><code>-1Y^
</code></pre>
<p><a href="https://tio.run/##y00syfn/X9cwMu7//2gTBV1jBQNrBV0gw1zBzFrBVAFIxQIA" rel="nofollow noreferrer" title="MATL – Try It Online">Try it online!</a></p>
<h2>Explanation</h2>
<pre><code>-1Y^
-1   : Push -1 onto the stack
  Y^ : Raise implicit input to -1 power
</code></pre>
</div>
<div id="pu18" class="pu"><h1>JavaScript (ES6), 169 bytes</h1>
<p>This computes <span class="math-container">\$M^{-1} = \dfrac{\operatorname{adj}(M)}{\det(M)}\$</span></p>

<pre class="lang-javascript prettyprint-override"><code>M=&gt;M.map((r,y)=&gt;r.map((_,x)=&gt;D(h(M,x).map(r=&gt;h(r,y)))*(x+y&amp;1?-1:1)/D(M)),h=(a,n)=&gt;a.filter(_=&gt;n--),D=M=&gt;+M||M.reduce((s,[v],i)=&gt;s+(i&amp;1?-v:v)*D(h(M,i).map(r=&gt;h(r,0))),0))
</code></pre>
<p><a href="https://tio.run/##VY7NasQgFEb3eQpXnetE7aTttDBgugndueoyHQbJT@OQaDBWMjDvnpoIhW7kO5fveu5VejlVVo2OalM3S8sXwXPBBjkCWHLDPLcRLmQOUEAHIqRtZnnebSWM9zCnt4fsnWanDD8WIDAmHQdJdFiSrFW9ayxceK4pxaTgQZKK@10w29Q/VQMwkdKfiQrtKQW1/uRPHu@jT/3zHYJvfZbW2EE6xNGAeI4qoyfTN6w33zDE/jqO5/s1eubMh5qbGrInzEZZfzppHWRHjNnVKA07tPuLXzrkJIkOaKFMECrRC6HPBB3OZCUa6I2g10joSNBGyTnc9gs" rel="noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
</div>
<div id="pu19" class="pu"><h1><a href="http://julialang.org/" rel="noreferrer">Julia 1.0</a>, 3 bytes</h1>

<pre class="lang-julia prettyprint-override"><code>inv
</code></pre>
<p><a href="https://tio.run/##yyrNyUw0rPifZvs/M6/sf0FRZl6JRppGtImCsYKuqYKJgq6hgbWChYIlEAP5xtZAliVIUMFQQdfcWgHCsATJ6ZpaK5gr6JqAuEZAIlZT8z8A" rel="noreferrer" title="Julia 1.0 – Try It Online">Try it online!</a></p>
<p>Yet another short built-in solution.</p>
</div>
<div id="pu20" class="pu"><h1><a href="https://www.r-project.org/" rel="noreferrer">R</a>, 5 bytes</h1>

<pre class="lang-r prettyprint-override"><code>solve
</code></pre>
<p><a href="https://tio.run/##K/qfZvu/OD@nLPV/mkZuYklRZoVGsoaJjoKxjoKuqY4CkKVraKCjYKGjYAkmQYLGYI4lVMoQSJsDKSjTEqIGhIGiuiYQISMQpamjYApGIZqa/wE" rel="noreferrer" title="R – Try It Online">Try it online!</a></p>
<p>Nothing new here...
Basically, the code <code>solve(A, B)</code> solves <span class="math-container">\$AX = B\$</span>, but when <span class="math-container">\$B\$</span> is not given, it is treated as identity matrix, thus giving us the inverse as the result.</p>
</div>
<div id="pu21" class="pu"><h1><a href="https://www.dyalog.com/" rel="noreferrer">APL (Dyalog Unicode)</a>, 1 byte<sup><a href="https://en.wikipedia.org/wiki/SBCS" rel="noreferrer">SBCS</a></sup></h1>

<pre class="lang-apl prettyprint-override"><code>⌹
</code></pre>
<p><a href="https://tio.run/##SyzI0U2pTMzJT////1HPzv@P@qY@apugAGQqGCkYPerdYmigYKFwaD0Y/wcA" rel="noreferrer" title="APL (Dyalog Unicode) – Try It Online">Try it online!</a></p>
<p>The domino primitive is a very interesting APL &quot;built-in&quot;. It already <a href="https://codegolf.stackexchange.com/a/205897/75323">featured in another 1-byte answer of my own</a> where it was used to solve a least-squares problem. When applied to a square matrix, <code>⌹</code> tries to find the matrix inverse of its argument.</p>
<p>Many golfing languages will also have a built-in for this... But mind you, APL is <strong>not</strong> a golfing language, although it is terse enough to be very competitive and, in cases like this, win.</p>
</div>
<div id="pu22" class="pu"><h1><a href="https://www.wolfram.com/wolframscript/" rel="noreferrer">Wolfram Language (Mathematica)</a>, 7 bytes</h1>
<pre><code>Inverse
</code></pre>
<p><a href="https://tio.run/##y00syUjNTSzJTE78n2773zOvLLWoOPV/QFFmXomCg59DenR1ta65joKuERADaSBlDGRZ1uooVEPYlmBBXRMgNjQACeuagZhAbApSqKNgAFQDFjcFKwaSJmAtpiBBA4gakHpDiA26RmDFJhAJkADIPAsQrq3liv3/HwA" rel="noreferrer" title="Wolfram Language (Mathematica) – Try It Online">Try it online!</a></p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/213899/">213899</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




