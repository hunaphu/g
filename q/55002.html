<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::55002</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>036</td><td>Julia 1.11</td><td>150820T042939Z</td><td><a href="https://codegolf.stackexchange.com/questions/55002/construct-a-polynomial-with-given-roots/55015#55015">Glen O</a></td></tr>
<tr d-ix="1"><td>1342</td><td>‚òæ</td><td>250321T205802Z</td><td><a href="https://codegolf.stackexchange.com/questions/55002/construct-a-polynomial-with-given-roots/278832#278832">Used_Bra</a></td></tr>
<tr d-ix="2"><td>063</td><td>Janet</td><td>250320T092014Z</td><td><a href="https://codegolf.stackexchange.com/questions/55002/construct-a-polynomial-with-given-roots/278798#278798">xigoi</a></td></tr>
<tr d-ix="3"><td>121</td><td>Javascript</td><td>210518T113659Z</td><td><a href="https://codegolf.stackexchange.com/questions/55002/construct-a-polynomial-with-given-roots/225898#225898">Hannesh</a></td></tr>
<tr d-ix="4"><td>050</td><td>Ruby 2.7+</td><td>210518T091037Z</td><td><a href="https://codegolf.stackexchange.com/questions/55002/construct-a-polynomial-with-given-roots/225891#225891">user1007</a></td></tr>
<tr d-ix="5"><td>003</td><td>Jelly</td><td>210517T205950Z</td><td><a href="https://codegolf.stackexchange.com/questions/55002/construct-a-polynomial-with-given-roots/225845#225845">caird co</a></td></tr>
<tr d-ix="6"><td>013</td><td>Husk</td><td>171215T001508Z</td><td><a href="https://codegolf.stackexchange.com/questions/55002/construct-a-polynomial-with-given-roots/150685#150685">·Éë·Éò·Éõ·Éù</a></td></tr>
<tr d-ix="7"><td>056</td><td>Matlab</td><td>150820T215734Z</td><td><a href="https://codegolf.stackexchange.com/questions/55002/construct-a-polynomial-with-given-roots/55053#55053">Luis Men</a></td></tr>
<tr d-ix="8"><td>017</td><td>Pyth</td><td>150820T053828Z</td><td><a href="https://codegolf.stackexchange.com/questions/55002/construct-a-polynomial-with-given-roots/55018#55018">isaacg</a></td></tr>
<tr d-ix="9"><td>021</td><td>CJam</td><td>150820T040604Z</td><td><a href="https://codegolf.stackexchange.com/questions/55002/construct-a-polynomial-with-given-roots/55014#55014">Reto Kor</a></td></tr>
<tr d-ix="10"><td>008</td><td>J</td><td>150820T030336Z</td><td><a href="https://codegolf.stackexchange.com/questions/55002/construct-a-polynomial-with-given-roots/55011#55011">lynn</a></td></tr>
<tr d-ix="11"><td>070</td><td>Haskell</td><td>150820T012502Z</td><td><a href="https://codegolf.stackexchange.com/questions/55002/construct-a-polynomial-with-given-roots/55008#55008">xnor</a></td></tr>
<tr d-ix="12"><td>071</td><td>Python 2</td><td>150819T235818Z</td><td><a href="https://codegolf.stackexchange.com/questions/55002/construct-a-polynomial-with-given-roots/55003#55003">xnor</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Julia 1.11, <s>39</s> 36 bytes</h1>
<p>It's been fun revisiting this after almost 10 years, ended up being able to compress it even with some Julia changes that made it harder.</p>
<pre><code>s-&gt;(i=1;s‚à™s.|&gt;k-&gt;i=[0;i]k-[i;0];i)
</code></pre>
<p>Note that <code>s‚à™s</code>, as suspicious as it may seem, is the most length-efficient way to get unique(s), as ‚à™ is a binary infix operator that performs union, which inherently performs unique as part of its operation.</p>
<p>Saved 3 bytes thanks to MarcMush</p>
<h1>Julia (~0.4), 41 bytes</h1>
<p>Note: this is assuming the list is what matters, not the input/output format.</p>
<pre><code>s-&gt;foldl((i,j)-&gt;[0,i]j-[i,0],1,unique(s))
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/ganercodes/moon" rel="nofollow noreferrer">‚òæ</a>, 13 chars (42 bytes)</h1>
<p><a href="https://i.sstatic.net/IrVN2IWk.png" rel="nofollow noreferrer"><img src="https://i.sstatic.net/IrVN2IWk.png" alt="Solution" /></a></p>
<pre><code>Û∑∫π·ö§·ëÄüÉåÛ∑∏ª·¥ç‚üû‚´ö‚¨§·êµ·¥ç‚®Ä‚®Å
</code></pre>
<p>Note: ‚òæ uses a custom font, but you can run this code in the <a href="https://ganer.xyz/moon?code=%C6%92%20%3D%20%F3%B7%BA%B9%E1%9A%A4%E1%91%80%F0%9F%83%8C%F3%B7%B8%BB%E1%B4%8D%E2%9F%9E%E2%AB%9A%E2%AC%A4%E1%90%B5%E1%B4%8D%E2%A8%80%E2%A8%81%0A%C6%92%28%5B%F3%B7%B0%BE%2C0%2C1%2C%F3%B7%B0%BE%5D%29%E2%98%BE" rel="nofollow noreferrer">Web UI</a></p>
<p>The input is a list of zeros; the output is a list of coefficients starting with the highest term.</p>
<p><a href="https://i.sstatic.net/1ZQvMR3L.png" rel="nofollow noreferrer"><img src="https://i.sstatic.net/1ZQvMR3L.png" alt="Explain" /></a>
For n roots, the x·µè coefficient is the sum of all possible products of n-k of the roots.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://janet-lang.org/" rel="nofollow noreferrer">Janet</a>, 63 bytes</h1>
<pre class="lang-none prettyprint-override"><code>|(reduce(fn[p x](map|(- $(* $1 x))[;p 0][0;p]))[1](distinct $))
</code></pre>
</div>
<div id="pu3" class="pu"><h1>Javascript, 121 bytes</h1>
<pre><code>r=&gt;{o=[...r,0].fill(0);for(i=2**r.length;i--;)e=r.length,a=r.reduce((a,q,j)=&gt;a*(i&amp;1&lt;&lt;j?q:(e--,-1)),1),o[e]+=a;return o;}
</code></pre>
<h2>Explantation</h2>
<p>Similar to other answers, we imagine a polynomial of the form:</p>
<pre><code> (r_1 - x) * (r_2 - x) * ... * (r_n - x)
</code></pre>
<p>And we want to multiply it out to get the polynomial:</p>
<pre><code> a_0 * x^n + ... + a_n * x^0
</code></pre>
<p>This program does that by looping over every permutation of the input brackets. We can do this by counting in binary from 0 to 2^n. The i-th bit of that count tells us whether to multiply by r_i, or by -x.</p>
<h2>Ungolfed:</h2>
<pre><code>function make_poly(roots) {
  o = [...roots, 0].fill(0);
  for (i = 0; i &lt; 2 ** roots.length; i++) {
    a = 1;
    t_index = roots.length;
    for (j = 0; j &lt; roots.length; j++) {
      if (i &amp; (1 &lt;&lt; j)) {
        a *= roots[j];
      } else {
        a *= -1;
        t_index--;
      }
    }
    o[t_index] += a;
  }
  return o;
}
</code></pre>
</div>
<div id="pu4" class="pu"><h1>Ruby 2.7+, <strike>60 58 57</strike> 50 bytes</h1>

<pre class="lang-ruby prettyprint-override"><code>-&gt;i{p=*1;(i&amp;i).map{|x|p&lt;&lt;z=0;p.map!{-x*z+z=_1}};p}
</code></pre>
<p>Requires ruby 2.7+ for numbered arguments to work. Based on <a href="https://codegolf.stackexchange.com/a/55003/100752">xnor's python answer</a></p>
<p>Takes input as an array of roots, and returns an array of coefficients.</p>
<p>Thanks to <a href="https://codegolf.stackexchange.com/users/8478/martin-ender">@Martin Ender</a> for -2 bytes!</p>
<p>Thanks to <a href="https://codegolf.stackexchange.com/users/88546/dingledooper">Lydxn</a> for -1 byte</p>
<p>Thanks to <a href="https://codegolf.stackexchange.com/users/76162/jo-king">JoKing</a> for -7 bytes.</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 3 bytes</h1>
<pre><code>Q√Ü·πõ
</code></pre>
<p><a href="https://tio.run/##y0rNyan8/z/wcNvDnbP/H25/1LTm//9oQx0Fo1gdhWhjHQUgMgMxzYBMEA2U0gVig1gA" rel="nofollow noreferrer" title="Jelly ‚Äì Try It Online">Try it online!</a></p>
<p>Outputs them in order from the zero coefficient first. <a href="https://tio.run/##y0rNyan8/z/wcNvDnbND/x9uf9S05v//aEMdBaNYHYVoYx0FIDIDMc2ATBANlNIFYoNYAA" rel="nofollow noreferrer">+1 byte</a> to go the other way</p>
<p>It would just be a builtin (<code>√Ü·πõ</code>) aside from the fact that duplicates shouldn't matter. Therefore we deduplicate the input first with <code>Q</code>, then use the builtin</p>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/barbuz/Husk" rel="nofollow noreferrer">Husk</a>, 13 bytes</h1>

<pre><code>F»ØmŒ£‚àÇ·π™*moe1_u
</code></pre>

<p><a href="https://tio.run/##yygtzv7/3@3E@txzix91ND3cuUorNz/VML70////0YY6uoY6BrEA" rel="nofollow noreferrer" title="Husk ‚Äì Try It Online">Try it online!</a></p>

<h3>Explanation</h3>

<p>The idea is to generate the polynomials <code>(x-r0),‚Ä¶,(x-rN)</code> for the roots <code>r0,‚Ä¶,rN</code> and simply multiply them out:</p>

<pre><code>F(mŒ£‚àÇ·π™*)m(e1_)u  -- accepts a list of roots, example: [-1,1,-1]
              u  -- remove duplicates: [-1,1]
        m(   )   -- map the following (eg. on 1):
            _    --   negate: -1
          e1     --   create list together with 1: [1,-1]
F(     )         -- fold the following function (which does polynomial multiplication),
                 -- one step with [1,-1] and [1,1]:
     ·π™*          --   compute outer product: [[1,1],[-1,-1]]
    ‚àÇ            --   diagonals: [[1],[1,-1],[-1]]
  mŒ£             --   map sum: [1,0,1]
</code></pre>
</div>
<div id="pu7" class="pu"><h2>Matlab, 56 bytes</h2>

<p>Polynomial multiplication is convolution of their coefficients:</p>

<pre><code>function y=f(R)
y=1;for r=unique(R);y=conv(y,[1 -r]);end
</code></pre>

<p>Floating-point roots are supported.</p>

<p>Example:</p>

<pre><code>&gt;&gt; f([1 2])
ans =
     1    -3     2
&gt;&gt; f([1 2 1])
ans =
     1    -3     2
&gt;&gt; f([1 2.1 -3.2])
ans =
    1.0000    0.1000   -7.8200    6.7200
</code></pre>
</div>
<div id="pu8" class="pu"><h1>Pyth, 17 bytes</h1>

<pre><code>u-V+G0*LH+0GS{Q]1
</code></pre>

<p>17 bytes. A reduce over the input set. <code>+G0</code> is essentially <code>*x</code>, and <code>*LH+0G</code> is essentially <code>*r</code>, and <code>-V</code> performs element by element subtraction to perform <code>*(x-r)</code>.</p>

<p><a href="https://pyth.herokuapp.com/?code=u-V%2BG0*LH%2B0GS%7BQ%5D1&amp;input=1%2C%200%2C%20-1%2C%201&amp;debug=0" rel="nofollow">Demonstration.</a></p>
</div>
<div id="pu9" class="pu"><h1>CJam, <s>24</s> 21 bytes</h1>

<pre><code>1al~_&amp;{W*1$f*0\+.+}/`
</code></pre>

<p>Input format is a list in square brackets (e.g. <code>[1 2]</code>). Output format is the same. This is a full program. It might get slightly shorter if I package it as an anonymous function.</p>

<p>The approach is fairly straightforward: It starts out with <code>1</code> for the polynom, which is described by a coefficient array of <code>[1]</code>. It then multiplies it with <code>x - a</code> for each root <code>a</code>. This results in two arrays of coefficients:</p>

<ul>
<li>One from the multiplication with <code>-a</code>, which simply multiplies each previous coefficient by this value.</li>
<li>One from the multiplication with <code>x</code>, which shifts the array of coefficients by 1, padding the open position with 0.</li>
</ul>

<p>The two are then combined with a vector addition. I actually don't have to do anything for the second array, since CJam uses remaining array elements of the longer array unchanged if the other array is shorter, so padding the second array with a 0 is redundant.</p>

<p><a href="http://cjam.aditsu.net/#code=1al~_%26%7BW*1%24f*0%5C%2B.%2B%7D%2F%60&amp;input=%5B1%202%5D" rel="nofollow">Try it online</a></p>

<p>Explanation:</p>

<pre><code>1a      Put starting coefficient array [1] on stack.
l~      Get and interpret input.
_&amp;      Uniquify input array, using setwise and with itself.
{       Loop over roots given in input.
  W*      Negate value.
  1$      Get a copy of current coefficient array to top.
  f*      Multiply all values with root.
  0\+     Add a leading zero to align it for vector addition.
  .+      Vector add for the two coefficient array.
}/      End loop over roots.
`       Convert array to string for output.
</code></pre>
</div>
<div id="pu10" class="pu"><h1>J, 8 bytes</h1>
<p>A series of verbs:</p>
<pre><code>|.p.1;~.
</code></pre>
<p>Call it like this:</p>
<pre><code>   |.p.1;~. 1 2
1 _3 2
</code></pre>
<p>J has a built-in verb <a href="http://www.jsoftware.com/help/dictionary/dpdot.htm" rel="noreferrer"><code>p. (Roots)</code></a>. It converts between polynomials like <code>2 _3 1</code> (reverse order from the problem) and a multiplier/root pair like <code>(1; 1 2)</code>.</p>
<p>From right-to-left, <code>~.</code> takes the unique elements, <code>1;</code> pairs the list with 1, meaning we want the <em>smallest</em> integer polynomial, <code>p.</code> does the actual work, and <code>|.</code> reverses the resulting list.</p>
</div>
<div id="pu11" class="pu"><h2>Haskell, 70</h2>



<p>Basically a port of the <code>reduce</code> version of my <a href="https://codegolf.stackexchange.com/a/55003/20260">Python solution</a>.</p>

<pre class="lang-haskell prettyprint-override"><code>import Data.List
foldr(\x p-&gt;zipWith(\a b-&gt;a-b*x)(p++[0])(0:p))[1].nub
</code></pre>

<p>I tried to shorten the lambda expression <code>\a b-&gt;a-b*x</code> by making it point-free, but best I have is <code>(+).(*(-x))</code> on switched inputs (thanks to @isaacg), which is the same length.</p>

<p>The lengthy import for <code>nub</code> is for the requirement to ignore duplicate roots. Without it, we'd have 49:</p>

<pre class="lang-haskell prettyprint-override"><code>foldr(\x p-&gt;zipWith(\a b-&gt;a-b*x)(p++[0])(0:p))[1]
</code></pre>
</div>
<div id="pu12" class="pu"><h2>Python 2, 71</h2>



<pre class="lang-python prettyprint-override"><code>P=[1]
for r in set(input()):P=map(lambda a,b:a-r*b,P+[0],[0]+P)
print P
</code></pre>

<p>Iteratively updates the polynomial <code>P</code> to add one root at a time. Adding the root <code>r</code> multiplies the polynomial as <code>P*(x-r)</code>. This requires shifting the polynomial list <code>P</code> by one index to represent multiplication by <code>x</code>, the subtracting <code>r</code> times the original list. This is handled by shifting a copy of the list, padding with zeroes, and mapping the function <code>a,b -&gt; a-r*b</code>.</p>

<p>To remove duplicate roots, the input is made into a <code>set</code>.</p>

<p>Using <code>reduce</code> turned out one char longer (72):</p>

<pre class="lang-python prettyprint-override"><code>lambda R:reduce(lambda P,r:map(lambda a,b:a-r*b,P+[0],[0]+P),set(R),[1])
</code></pre>

<p>Three lambdas though!</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/55002/">55002</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




