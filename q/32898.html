<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::32898</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>174</td><td>AWK</td><td>241127T154009Z</td><td><a href="https://codegolf.stackexchange.com/questions/32898/check-if-point-lies-inside-triangle/276893#276893">xrs</a></td></tr>
<tr d-ix="1"><td>016</td><td>Vyxal ḋr</td><td>241116T172057Z</td><td><a href="https://codegolf.stackexchange.com/questions/32898/check-if-point-lies-inside-triangle/276708#276708">pacman25</a></td></tr>
<tr d-ix="2"><td>nan</td><td>Intel 8087 FPU assembly</td><td>190212T172020Z</td><td><a href="https://codegolf.stackexchange.com/questions/32898/check-if-point-lies-inside-triangle/179810#179810">640KB</a></td></tr>
<tr d-ix="3"><td>038</td><td>Mathematica</td><td>190208T063318Z</td><td><a href="https://codegolf.stackexchange.com/questions/32898/check-if-point-lies-inside-triangle/179679#179679">David G.</a></td></tr>
<tr d-ix="4"><td>108</td><td>C gcc</td><td>190208T083443Z</td><td><a href="https://codegolf.stackexchange.com/questions/32898/check-if-point-lies-inside-triangle/179682#179682">ceilingc</a></td></tr>
<tr d-ix="5"><td>100</td><td>SmileBASIC</td><td>190101T053745Z</td><td><a href="https://codegolf.stackexchange.com/questions/32898/check-if-point-lies-inside-triangle/178211#178211">12Me21</a></td></tr>
<tr d-ix="6"><td>120</td><td>JavaScript ES6</td><td>141118T215420Z</td><td><a href="https://codegolf.stackexchange.com/questions/32898/check-if-point-lies-inside-triangle/41623#41623">edc65</a></td></tr>
<tr d-ix="7"><td>028</td><td>CJam</td><td>140703T205615Z</td><td><a href="https://codegolf.stackexchange.com/questions/32898/check-if-point-lies-inside-triangle/32907#32907">Dennis</a></td></tr>
<tr d-ix="8"><td>065</td><td>Python</td><td>140711T222344Z</td><td><a href="https://codegolf.stackexchange.com/questions/32898/check-if-point-lies-inside-triangle/34428#34428">xnor</a></td></tr>
<tr d-ix="9"><td>023</td><td>R</td><td>140707T223649Z</td><td><a href="https://codegolf.stackexchange.com/questions/32898/check-if-point-lies-inside-triangle/33095#33095">shadowta</a></td></tr>
<tr d-ix="10"><td>090</td><td>Python 2.7</td><td>140704T011614Z</td><td><a href="https://codegolf.stackexchange.com/questions/32898/check-if-point-lies-inside-triangle/32923#32923">Alex L</a></td></tr>
<tr d-ix="11"><td>nan</td><td></td><td>140705T055955Z</td><td><a href="https://codegolf.stackexchange.com/questions/32898/check-if-point-lies-inside-triangle/32997#32997">Derek 朕會</a></td></tr>
<tr d-ix="12"><td>nan</td><td></td><td>140705T162619Z</td><td><a href="https://codegolf.stackexchange.com/questions/32898/check-if-point-lies-inside-triangle/33012#33012">colorado</a></td></tr>
<tr d-ix="13"><td>127</td><td>Haskell —</td><td>140704T163106Z</td><td><a href="https://codegolf.stackexchange.com/questions/32898/check-if-point-lies-inside-triangle/32952#32952">O-I</a></td></tr>
<tr d-ix="14"><td>nan</td><td>HTML5 + JS</td><td>140704T194751Z</td><td><a href="https://codegolf.stackexchange.com/questions/32898/check-if-point-lies-inside-triangle/32965#32965">xem</a></td></tr>
<tr d-ix="15"><td>067</td><td>Mathematica</td><td>140703T192114Z</td><td><a href="https://codegolf.stackexchange.com/questions/32898/check-if-point-lies-inside-triangle/32901#32901">Martin E</a></td></tr>
<tr d-ix="16"><td>nan</td><td>Javascript / ECMAScript 6</td><td>140703T223634Z</td><td><a href="https://codegolf.stackexchange.com/questions/32898/check-if-point-lies-inside-triangle/32915#32915">Abraham</a></td></tr>
<tr d-ix="17"><td>nan</td><td></td><td>140704T004915Z</td><td><a href="https://codegolf.stackexchange.com/questions/32898/check-if-point-lies-inside-triangle/32921#32921">Bob</a></td></tr>
<tr d-ix="18"><td>nan</td><td></td><td>140704T103308Z</td><td><a href="https://codegolf.stackexchange.com/questions/32898/check-if-point-lies-inside-triangle/32941#32941">Dennis J</a></td></tr>
<tr d-ix="19"><td>nan</td><td></td><td>140704T003828Z</td><td><a href="https://codegolf.stackexchange.com/questions/32898/check-if-point-lies-inside-triangle/32920#32920">jpjacobs</a></td></tr>
<tr d-ix="20"><td>051</td><td>Pyth 1.0.5</td><td>140703T224309Z</td><td><a href="https://codegolf.stackexchange.com/questions/32898/check-if-point-lies-inside-triangle/32916#32916">isaacg</a></td></tr>
<tr d-ix="21"><td>174</td><td>Fortran</td><td>140703T192422Z</td><td><a href="https://codegolf.stackexchange.com/questions/32898/check-if-point-lies-inside-triangle/32902#32902">Kyle Kan</a></td></tr>
<tr d-ix="22"><td>465</td><td>C 414 was</td><td>140703T213508Z</td><td><a href="https://codegolf.stackexchange.com/questions/32898/check-if-point-lies-inside-triangle/32910#32910">bacchusb</a></td></tr>
<tr d-ix="23"><td>156</td><td>C –</td><td>140703T194117Z</td><td><a href="https://codegolf.stackexchange.com/questions/32898/check-if-point-lies-inside-triangle/32904#32904">user1525</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.gnu.org/software/gawk/manual/gawk.html" rel="nofollow noreferrer">AWK</a>, 174 bytes</h1>
<pre><code>BEGIN{FPAT=&quot;-*0.[0-9]+&quot;}{d=($6-$8)*($3-$7)+($7-$5)*($4-$8)
x=(($6-$8)*($1-$7)+($7-$5)*($2-$8))/d
y=(($8-$4)*($1-$7)+($3-$7)*($2-$8))/d}1,$0=x&gt;=0&amp;&amp;x&lt;=1&amp;&amp;y&gt;=0&amp;&amp;y&lt;=1&amp;&amp;(1-x-y)&gt;=0
</code></pre>
<p><a href="https://tio.run/##XVTLilxXDNzPVwymGbrtuWO9jh6QDiSQBG@MF9mZWQS88wd4BuNvn@ieI90x3nWLunWkqpL@@/b15eXPv/758PH735/@@Pf6ZnsLD59hi8d3b358/3I9n3Q7@eXt@cTbyS7vzifbTmP/L3v95ul6foXgLxDa65f3X26ed5RvJ/kZNQl/Qv3A@xNcn36/wt3d029XvLt7nr@f5@8zbk/b8yUrLy@fzxs8MIbi/W3@QlLRy/3tOYsu5ve3@cMEY6/tSFDkiRxhQ6rqY8iEqjJfHm8mqZuQTSiAMy5Sc6eYSBBo0oAAWc@zD21SUB87VFzUJys8kEcUKWtWF5SclSaUjpc4mGkhTaw7Fdeop0DCulcwc94JQARHzyo8RjGgFu0IhFUMRhmrSCEw3w9glmqVFcEm52CPAhrCfEfsVT0AlqW@hRgtpNOQmEUKID8aRa2eCIStO1WsqXYstio6cGEFmzaRjnsDA9UPq5AwfCGHx8E6kFbVh0CN6jJU56jBKquGbDonNU/6o9U9QOtzHNxNoVt5nfY4dQKG4cJmgKxYIUzX954RLFXBOiug1PrHmFPtUCHiIrUxfGWVRaBSjWorVW4jU129pmurmlZZ@08DjZdWjC1KPlpmBWh0AMWC5vcmztSsEe12SkG9AC1qzuf9VCqFUrZm1x0Mn6zbFBZ6BXCAL62GEraCbqnRGta8FHSV9b4CW3kFyDGj6pI705S4v76vr0SvX1BasRfJBLx0JuFYA2kcQa3oUKhYEXruU3k34tg9ovIjLKI2YriOlXOm1pgyuTNjngpoUeYylhipCveAiLGCR3aohryOUThEZ2Hsvi0pM9WH78as07fsjGsg5Zx8r2Fm8tgF594QltcNQaQJNUY9gj@sb0zKgN1Brgst4YOjDMoTgnNxJA9Q3xKmCm1enfZ8Pzpr0BFaSVZA9Hrc@2YTrpu9n9nDSejA5GDaFrEol5yv/eQ783PMy1e1AUhU01CFSJjXukDeo8PzTPY8LXkXtE97hmPde0Khspwzgkt044OQ1CrpmMl6/B8" rel="nofollow noreferrer" title="AWK – Try It Online">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal/tree/version-2" rel="nofollow noreferrer">Vyxal</a> <code>ḋr</code>, 16 bytes</h1>
<pre><code>₍‡⁰M‡2ḋvƛ÷∆d;Ṡƒ&lt;
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/?v=2&amp;c=1#WyLhuItyIiwiIiwi4oKN4oCh4oGwTeKAoTLhuIt2xpvDt+KIhmQ74bmgxpI8IiwiIiwiWygwLjM4NDc4LCAwLjM3NDE5KSwgKC0wLjMwNjEzLCAtMC41OTc1NCksICgtMC44NTU0OCwgMC42NjMzKV1cbigtMC4zMTk2MSwgLTAuMTI2NDYpIl0=" rel="nofollow noreferrer">Try it Online!</a></p>
<p>Uses the inequality <span class="math-container">\$AX+BX+CX&lt;AB+BC+CA\$</span></p>
<p>Takes <code>[A,B,C]</code> as a list of points then <code>X</code> as a point</p>
</div>
<div id="pu2" class="pu"><h1>Intel 8087 FPU assembly, <del>222</del> 220 bytes</h1>

<p>Uses only the 8087 FPU hardware to calculate.  Here is the unassembled (ungolfed in this case too) version as a MACRO (will spare you the 220 hex byte codes):</p>

<pre><code>; calculate the area of of a triangle ABC using determinate
; input: coordinates (float), Ax,Ay,Bx,By,Cx,Cy
; output: area in ST
TAREA   MACRO   A1,A2,B1,B2,C1,C2
    FLD  A1
    FLD  B2
    FLD  C2
    FSUB        ; ST = By - Cy
    FMUL        ; ST = Ax * ( By - Cy )
    FLD  B1 
    FLD  C2
    FLD  A2
    FSUB        ; ST = Cy - Ay
    FMUL        ; ST = Bx * ( Cy - Ay )
    FLD  C1
    FLD  A2
    FLD  B2
    FSUB        ; Ay - By
    FMUL        ; Cx * ( Ay - By )
    FADD        ; Cx * ( Ay - By ) + Bx * ( Cy - Ay )
    FADD        ; Cx * ( Ay - By ) + Bx * ( Cy - Ay ) + Ax * ( By - Cy )
    FLD1        ; make a value of 2
    FADD ST,ST  ; ST = 2
    FDIV        ; divide by 2
    FABS        ; take abs value
        ENDM

; determine if point X is in triangle ABC
; input: points X, A, B, C
; output: ZF=1 if X in triangle, ZF=0 if X not in triangle
TXINABC     MACRO X1,X2,A1,A2,B1,B2,C1,C2

    TAREA  A1,A2,B1,B2,C1,C2    ; ST(3) = area of triangle ABC
    TAREA  X1,X2,B1,B2,C1,C2    ; ST(2) = area of triangle XBC
    TAREA  A1,A2,X1,X2,C1,C2    ; ST(1) = area of triangle AXC
    TAREA  A1,A2,B1,B2,X1,X2    ; ST(0) = area of triangle ABX

    FADD        ; add areas of triangles with point
    FADD        ; ST = ST + ST(1) + ST(2)
    FCOMPP      ; compare ST to ST(1) and pop results
    FWAIT       ; sync CPU/FPU
    FSTSW R     ; store result flags to R
    MOV  AX, R  ; move result to AX
    SAHF        ; store result into CPU flags for conditional check
        ENDM
</code></pre>

<h2>Explanation</h2>

<p>Uses the determinate to calculate the area of the ABC triangle, and then the triangle formed with the X point and two other points of the ABC triangle.  If the area of triangle ABC equals the sum of areas of triangles XBC + AXC + ABX, then the point is within the triangle.  The result is returned as ZF.</p>

<h3>What's neat about this</h3>

<p>All of the math and floating point operations are done in hardware with 80-bit extended precision.  The final floating point comparison is also done in hardware so will be very accurate.</p>

<p>This also uses all eight of the 8087's stack registers at once.</p>

<h3>What's not quite as neat about this</h3>

<p>As the points of the triangle must be plugged back into the formulas several times during the calculation, it requires each variable in memory to be loaded into the FPU's stack registers one at a time in the correct order.  While this can be fairly easily modeled like a function as a MACRO, it means that the code is expanded each time at assembly, creating redundant code.  41 bytes were saved by moving some of the same repeated code segments into PROCs.  However it makes the code less readable, so the above listing is without it (which is why it's labeled as "ungolfed").</p>

<h2>Tests</h2>

<p>Here is a test program using IBM DOS showing output:</p>

<pre><code>TTEST   MACRO T
        LOCAL IS_IN_TRI

    TXINABC T,T+4*1,T+4*2,T+4*3,T+4*4,T+4*5,T+4*6,T+4*7
    MOV  DX, OFFSET TEQ     ; load true string by default 
    JZ   IS_IN_TRI          ; if ZF=1, it is in triangle, skip to display
    MOV  DX, OFFSET FEQ     ; otherwise ZF=0 means not in triangle, so load false string
IS_IN_TRI:
    MOV  AH, 9              ; DOS write string function
    INT  21H 
        ENDM

START:
    FINIT                   ; reset 8087

    TTEST   T0              ; true tests
    TTEST   T1
    TTEST   T2
    TTEST   T3
    TTEST   T4
    TTEST   T5
    TTEST   T6
    TTEST   T7
    TTEST   T8
    TTEST   T9

    TTEST   F0              ; false tests
    TTEST   F1
    TTEST   F2
    TTEST   F3
    TTEST   F4
    TTEST   F5
    TTEST   F6  
    TTEST   F7
    TTEST   F8  
    TTEST   F9

    RET         ; return to DOS

T0  DD  -0.31961, -0.12646, 0.38478, 0.37419, -0.30613, -0.59754, -0.85548, 0.6633
T1  DD  -0.87427, -0.00831, 0.78829, 0.60409, -0.90904, -0.13856, -0.80685, 0.48468
T2  DD  0.28997, -0.03668, -0.28362, 0.42831, 0.39332, -0.07474, -0.48694, -0.10497
T3  DD  -0.07783, 0.04415, -0.34355, -0.07161, 0.59105, -0.93145, 0.29402, 0.90334
T4  DD  0.36107, 0.05389, 0.27103, 0.47754, -0.00341, -0.79472, 0.82549, -0.29028
T5  DD  -0.01655, -0.20437, -0.36194, -0.90281, -0.26515, -0.4172, 0.36181, 0.51683
T6  DD  -0.12198, -0.45897, -0.35128, -0.85405, 0.84566, 0.99364, 0.13767, 0.78618
T7  DD  -0.03847, -0.81531, -0.18704, -0.33282, -0.95717, -0.6337, 0.10976, -0.88374
T8  DD  0.07904, -0.06245, 0.95181, -0.84223, -0.75583, -0.34406, 0.16785, 0.87519
T9  DD  -0.33485, 0.53875, -0.25173, 0.51317, -0.62441, -0.90698, -0.47925, 0.74832

F0  DD  -0.99103, 0.43842, 0.78128, -0.10985, -0.84714, -0.20558, -0.08925, -0.78608
F1  DD  0.15087, -0.56212, -0.87374, -0.3787, 0.86403, 0.60374, 0.01392, 0.84362
F2  DD  0.1114, 0.66496, -0.92633, 0.27408, 0.92439, 0.43692, 0.8298, -0.29647
F3  DD  0.87786, -0.8594, -0.42283, -0.97999, 0.58659, -0.327, -0.22656, 0.80896
F4  DD  0.43525, -0.8923, 0.86119, 0.78278, -0.01348, 0.98093, -0.56244, -0.75129
F5  DD  -0.73365, 0.28332, 0.63263, 0.17177, -0.38398, -0.43497, -0.31123, 0.73168
F6  DD  -0.57694, -0.87713, -0.93622, 0.89397, 0.93117, 0.40775, 0.2323, -0.30718
F7  DD  0.91059, 0.75966, 0.60118, 0.73186, 0.32178, 0.88296, -0.90087, -0.26367
F8  DD  0.3463, -0.89397, 0.99108, 0.13557, 0.50122, -0.8724, 0.43385, 0.00167
F9  DD  0.88121, 0.36469, -0.29829, 0.21429, 0.31395, 0.2734, 0.43267, -0.78192

TEQ DB 'In Triangle',0DH,0AH,'$'
FEQ DB 'Not In Triangle',0DH,0AH,'$'
</code></pre>

<h3>Output</h3>

<pre><code>In Triangle
In Triangle
In Triangle
In Triangle
In Triangle
In Triangle
In Triangle
In Triangle
In Triangle
In Triangle
Not In Triangle
Not In Triangle
Not In Triangle
Not In Triangle
Not In Triangle
Not In Triangle
Not In Triangle
Not In Triangle
Not In Triangle
Not In Triangle
</code></pre>
</div>
<div id="pu3" class="pu"><h1>Mathematica, 38 characters</h1>
<pre><code>RegionMember[Polygon[#[[1]]],#[[2]]] &amp;
</code></pre>
<p>Example:</p>
<pre><code>d = {{{0, 0}, {1, 0}, {.5, .7}}, {.5, .6}};

RegionMember[Polygon[#[[1]]], #[[2]]] &amp; @ d
</code></pre>
<p>(* True *)</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C (gcc)</a>, 108 bytes</h1>



<pre class="lang-c prettyprint-override"><code>i;f(a,b,c,d,e,f,g,h)float a,b,c,d,e,f,g,h;{i=(e-=a)*(h-=b)&gt;(f-=b)*(g-=a);i=(c-=a)*f&gt;(d-=b)*e==i&amp;i==g*d&gt;h*c;}
</code></pre>

<p><a href="https://tio.run/##dVXLbiQ3DLznKwYLJOgxehbiQ3xgMP6SXLxjjz3AxgmCvS322x2KVF8C96kFSV0kq4rU9fR6vX583M@35Wn9tl7X5/Vlva2v69vx9v3vpx@H/@2ef94vy8vp8nR8WN5Ol2/Hx@U2Pg/L69g8x@k1T2@Py3MevFwu9z/ul8vrw/Pj28P1/Ovjr6f7@3L8@dvh8M@/9/cft@XL789/vn9Zb8upfSVwgfUQK0BhWQ@xZayWC2XwPKMmQLnqrp1zZb1zXhMhOh7Pn@ObMmreb80Ixn01Q88fG7fC9@atUIGsS@E3sT6usbHY5wHaVzT3iU8ilis0Esw/cYYkJ8K6pawViU18xmzsultBUzUaII0ZetHB1PuEA8kI3aHVlhNw5o3OLdPwRsR7BZBA04TvZEkLKrQMyLpx3RpxqaTOmqCGnYs89Ia2nz7IzBUbU1EVMWfp49cCRumzOoaKELesagOxfYUBwYt37ja1oA5o0yXckg3jLmkvdxIeCyAVLUNEpP0Chh8LCzpNr5pOv4SuVsp6V6h74cfEheY6vWTh5T0Fmm7ma4IlnXeYtBgjlvO1d6MpP7csBUTLoqYdfLeCUL@uhcI6teigVNzSljXy1NibbIyqY/6pbIQjwOcR3DfLBFlYnG4KBAvWZy0KPK0QxVTJlhFOqULbbTPozSrNLgi4ZmfT7CTSOIsN4UpC2jgZ1iMvr3I05C40ANcYYZcB7BgCViNws3VsMHlVJwE4vD/5QRfWPWCLxp3y97D7oBNxSujq7oHUTfoccTGmBmL0QWprwYzsQUf/T9aCPsraAbx4xxie2XdU49GtOa3FHPO0EuC@XZRIaoDYmFrDz8FI@i0cnlmS0eYQitmVWwCYl5RA9rup6zb1gh7IvKIfsWRy8iFkTDDIBuKYfT02kGYPUMy7XY@MCVgcdI9WHz4AsJmSjQ1CqJdlvAClddt8FSXKrpTEQpPumWIEsxoivY@N3gBx1oXDfExUTddiAu57JNqkXoh4/DwN4PN1QmAcFqFwccmhVMAoOjsGPG396@M/" rel="nofollow noreferrer" title="C (gcc) – Try It Online">Try it online!</a></p>

<p>Takes three cross products and returns <code>1</code> if the sign of the <code>k̂</code> component doesn't change.</p>
</div>
<div id="pu5" class="pu"><h1>SmileBASIC, <s>111</s> 100 characters</h1>
<pre><code>DEF T X,Y,A,B,C,D,E,F
Q=9e5GCLS
GTRI(A-X)*Q,Q*(B-Y),Q*(C-X),Q*(D-Y),Q*(E-X),Q*(F-Y)?!!GSPOIT(0,0)END
</code></pre>
<p>Draws a triangle and checks the color of the pixel at the point.
The triangle is scaled up 99999x and shifted so that the point to check will be at (0,0) before being drawn, to minimize loss in precision.</p>
</div>
<div id="pu6" class="pu"><h1>JavaScript (ES6) 120</h1>
<pre><code>C=(p,q,i,j,k,l,m,n,
 z=j*(m-k)+i*(l-n)+k*n-l*m,
 s=(j*m-i*n+(n-j)*p+(i-m)*q)/z,
 t=(i*l-j*k+(j-l)*p+(k-i)*q)/z
)=&gt;s&gt;0&amp;t&gt;0&amp;s+t&lt;1
</code></pre>
<p>Directly copied from my answer to <a href="https://codegolf.stackexchange.com/questions/40343/triangular-battleships-a-computational-geometry-problem">This other question</a></p>
<p><strong>Test</strong> In FireFox/FireBug console</p>
<p><em>Output</em> all 1s</p>
<pre><code>;[
C(-0.31961, -0.12646, 0.38478, 0.37419, -0.30613, -0.59754, -0.85548, 0.6633),
C(-0.87427, -0.00831, 0.78829, 0.60409, -0.90904, -0.13856, -0.80685, 0.48468),
C(0.28997, -0.03668, -0.28362, 0.42831, 0.39332, -0.07474, -0.48694, -0.10497),
C(-0.07783, 0.04415, -0.34355, -0.07161, 0.59105, -0.93145, 0.29402, 0.90334),
C(0.36107, 0.05389, 0.27103, 0.47754, -0.00341, -0.79472, 0.82549, -0.29028),
C(-0.01655, -0.20437, -0.36194, -0.90281, -0.26515, -0.4172, 0.36181, 0.51683),
C(-0.12198, -0.45897, -0.35128, -0.85405, 0.84566, 0.99364, 0.13767, 0.78618),
C(-0.03847, -0.81531, -0.18704, -0.33282, -0.95717, -0.6337, 0.10976, -0.88374),
C(0.07904, -0.06245, 0.95181, -0.84223, -0.75583, -0.34406, 0.16785, 0.87519),
C(-0.33485, 0.53875, -0.25173, 0.51317, -0.62441, -0.90698, -0.47925, 0.74832)
]
</code></pre>
<p><em>Output</em> all 0s</p>
<pre><code>;[
C(-0.99103, 0.43842,0.78128, -0.10985,-0.84714, -0.20558,-0.08925, -0.78608),
C(0.15087, -0.56212,-0.87374, -0.3787,0.86403, 0.60374,0.01392, 0.84362),
C(0.1114, 0.66496,-0.92633, 0.27408,0.92439, 0.43692,0.8298, -0.29647),
C(0.87786, -0.8594,-0.42283, -0.97999,0.58659, -0.327,-0.22656, 0.80896),
C(0.43525, -0.8923,0.86119, 0.78278,-0.01348, 0.98093,-0.56244, -0.75129),
C(-0.73365, 0.28332,0.63263, 0.17177,-0.38398, -0.43497,-0.31123, 0.73168),
C(-0.57694, -0.87713,-0.93622, 0.89397,0.93117, 0.40775,0.2323, -0.30718),
C(0.91059, 0.75966,0.60118, 0.73186,0.32178, 0.88296,-0.90087, -0.26367),
C(0.3463, -0.89397,0.99108, 0.13557,0.50122, -0.8724,0.43385, 0.00167),
C(0.88121, 0.36469,-0.29829, 0.21429,0.31395, 0.2734,0.43267, -0.78192)
]
</code></pre>
</div>
<div id="pu7" class="pu"><h1>CJam, <s>66</s> <s>63</s> <s>59</s> <s>52</s> <s>46</s> <s>34</s> <s>32</s> <s>31</s> <s>30</s> 28 characters</h1>

<pre><code>"Ă䒟损崙㩴ァ椟饃꿾藭鑭蘁"2G#b131b:c~
</code></pre>

<p>After transforming the Unicode string, the following code (<strong>33 bytes</strong>) gets evaluated:</p>

<pre><code>{2*2/\f{f{+~@-@@-}~@@*@@*&gt;})-!}:T
</code></pre>

<p>Expects <code>X [A B C]</code> as input, where each point is of the form <code>[double double]</code>. Output is 1 or 0.</p>

<p><a href="http://cjam.aditsu.net/" rel="nofollow noreferrer" title="CJam interpreter">Try it online.</a></p>

<p>A big thank you goes to <a href="https://codegolf.stackexchange.com/u/25180">user23013</a> for saving 6 characters (13 bytes of uncompressed code)!</p>

<h3>Test cases</h3>

<pre><code>$ cat triangle.cjam
"Ă䒟损崙㩴ァ椟饃꿾藭鑭蘁"2G#b131b:c~

[
  [-0.31961 -0.12646] [ [0.38478 0.37419]   [-0.30613 -0.59754] [-0.85548 0.6633]   ] T
  [-0.87427 -0.00831] [ [0.78829 0.60409]   [-0.90904 -0.13856] [-0.80685 0.48468]  ] T
  [0.28997 -0.03668]  [ [-0.28362 0.42831]  [0.39332 -0.07474]  [-0.48694 -0.10497] ] T
  [-0.07783 0.04415]  [ [-0.34355 -0.07161] [0.59105 -0.93145]  [0.29402 0.90334]   ] T
  [0.36107 0.05389]   [ [0.27103 0.47754]   [-0.00341 -0.79472] [0.82549 -0.29028]  ] T
  [-0.01655 -0.20437] [ [-0.36194 -0.90281] [-0.26515 -0.4172]  [0.36181 0.51683]   ] T
  [-0.12198 -0.45897] [ [-0.35128 -0.85405] [0.84566 0.99364]   [0.13767 0.78618]   ] T
  [-0.03847 -0.81531] [ [-0.18704 -0.33282] [-0.95717 -0.6337]  [0.10976 -0.88374]  ] T
  [0.07904 -0.06245]  [ [0.95181 -0.84223]  [-0.75583 -0.34406] [0.16785 0.87519]   ] T
  [-0.33485 0.53875]  [ [-0.25173 0.51317]  [-0.62441 -0.90698] [-0.47925 0.74832]  ] T
  [-0.99103 0.43842]  [ [0.78128 -0.10985]  [-0.84714 -0.20558] [-0.08925 -0.78608] ] T
  [0.15087 -0.56212]  [ [-0.87374 -0.3787]  [0.86403 0.60374]   [0.01392 0.84362]   ] T
  [0.1114 0.66496]    [ [-0.92633 0.27408]  [0.92439 0.43692]   [0.8298 -0.29647]   ] T
  [0.87786 -0.8594]   [ [-0.42283 -0.97999] [0.58659 -0.327]    [-0.22656 0.80896]  ] T
  [0.43525 -0.8923]   [ [0.86119 0.78278]   [-0.01348 0.98093]  [-0.56244 -0.75129] ] T
  [-0.73365 0.28332]  [ [0.63263 0.17177]   [-0.38398 -0.43497] [-0.31123 0.73168]  ] T
  [-0.57694 -0.87713] [ [-0.93622 0.89397]  [0.93117 0.40775]   [0.2323 -0.30718]   ] T
  [0.91059 0.75966]   [ [0.60118 0.73186]   [0.32178 0.88296]   [-0.90087 -0.26367] ] T
  [0.3463 -0.89397]   [ [0.99108 0.13557]   [0.50122 -0.8724]   [0.43385 0.00167]   ] T
  [0.88121 0.36469]   [ [-0.29829 0.21429]  [0.31395 0.2734]    [0.43267 -0.78192]  ] T
]p;

$ cjam triangle.cjam
[1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0]
</code></pre>
</div>
<div id="pu8" class="pu"><h1>Python (65)</h1>

<p>People seem to be done submitting, so I'll post my own solution to my question.</p>

<pre class="lang-python prettyprint-override"><code>f=lambda X,L:sum(((L[i-1]-X)/(L[i]-X)).imag&gt;0for i in(0,1,2))%3&lt;1
</code></pre>

<p><code>X</code> is the complex number representing the test points, and <code>L</code> is a list of three points, each a complex number.</p>

<p>First, I'll explain a less golfed version of the code;</p>

<pre class="lang-python prettyprint-override"><code>def f(X,A,B,C):A-=X;B-=X;C-=X;return((A/B).imag&gt;0)==((B/C).imag&gt;0)==((C/A).imag&gt;0)
</code></pre>

<p>We shift the points <code>A,B,C,X</code> so that <code>X</code> is at the origin, taking advantage of Python's built-in complex arithmetic. We need to check if the origin is contained in the convex hull of <code>A,B,C</code>. This is equivalent to the origin always lying on the same side (left or right) of the line segments AB, BC, and AC. </p>

<p>A segment <code>AB</code> has the origin on the left if one travel counterclockwise less than 180 degrees to get from A to B, and on the right otherwise. If we consider the angles <code>a</code>, <code>b</code>, and <code>c</code> corresponding to these points, this means <code>b-a &lt; 180 degrees</code> (taken angles in the range 0 to 360 degrees). As complex numbers, <code>angle(B/A)=angle(B)/angle(A)</code>. Also, <code>angle(x) &lt; 180 degrees</code> exactly for point in he upper half-plane, which we check via <code>imag(x)&gt;0</code>. </p>

<p>So whether the origin lies to the left of AB is expressed as <code>(A/B).imag&gt;0</code>. Checking whether these are all equal for each cyclic pair in <code>A,B,C</code> tells us whether triangle <code>ABC</code> contains the origin.</p>

<p>Now, let's return to the fully golfed code</p>

<pre class="lang-python prettyprint-override"><code>f=lambda X,L:sum(((L[i-1]-X)/(L[i]-X)).imag&gt;0for i in(0,1,2))%3&lt;1
</code></pre>

<p>We generate each cyclic pair in <code>(A-X,B-X,C-X)=(L[0]-X,L[1]-X,L[2]-X)</code>, taking advantage of negative Python list indices wrapping around (<code>L[-1]</code> = <code>L[2]</code>). To check that the Bools are all <code>True</code> (<code>1</code>) or all <code>False</code> (<code>0</code>), we add them and check divisibility by 3, as many solutions did.</p>
</div>
<div id="pu9" class="pu"><h2>R, 23</h2>
<p>Inspired by <a href="https://codegolf.stackexchange.com/a/32941/26904">MATLAB</a>,</p>
<pre><code>SDMTools::pnt.in.poly()
</code></pre>
<p>called like <code>SDMTools::pnt.in.poly(point,triangle)</code> where <code>point</code> is a length-2 vector and <code>triangle</code> is a 3x2 matrix of vertices. SDMTools is available on CRAN.</p>
</div>
<div id="pu10" class="pu"><h2>Python 2.7 <s>128</s> <s>127</s> <s>117</s> <s>110</s> <s>109</s> <s>103</s> <s>99</s> <s>95</s> <s>94</s> <s>91</s> 90</h2>

<p>My first code-golf attempt!</p>

<h2>Code</h2>

<pre><code>f=lambda x,y,t:sum(a*y+c*b+d*x&lt;d*a+c*y+b*x for i in(0,1,2)for a,b,c,d in[t[i-1]+t[i]])%3&lt;1
</code></pre>

<p>Takes as input (x,y,t) where (x,y) is the point we're checking and t is a triangle t = ((x1,y1),(x2,y2),(x3,y3)).</p>

<h2>Explanation</h2>

<p>I'm calculating the determinants of the matrices</p>

<pre><code>| 1 x1 y1 |      | 1 x2 y2 |      | 1 x3 y3 |
| 1 x2 y2 | ,    | 1 x3 y3 | ,    | 1 x1 y1 | .
| 1 x  y  |      | 1 x  y  |      | 1 x  y  |
</code></pre>

<p>These determinants represent the signed distances from the sides of the triangle to the point (x,y). If they all have the same sign, then the point is on the same side of every line and is thus contained in the triangle.</p>

<p>In the code above, <code>a*y+c*b+d*x-d*a-c*y-b*x</code> is a determinant of one of these matrices.</p>

<p>I'm using the fact that <code>True+True+True==3</code> and <code>False+False+False==0</code> to determine if these determinants all have the same sign.</p>

<p>I make use of Python's negative list indices by using <code>t[-1]</code> instead of <code>t[(i+1)%3]</code>.</p>

<p>Thanks Peter for the idea to use <code>s%3&lt;1</code> instead of <code>s in(0,3)</code> to check if s is either 0 or 3!</p>

<h2>Sagemath Version</h2>

<p>Not really a different solution so I'm including it in this answer, a sagemath solution using <strong>80</strong> characters:</p>

<pre><code>f=lambda p,t,o=[1]:sum([det(Matrix([o+t[i-1],o+t[i],o+p]))&lt;0for i in 0,1,2])%3&lt;1
</code></pre>

<p>where <code>p=[x,y]</code>, and <code>t=[[x1,y1],[x2,y2],[x3,y3]]</code></p>
</div>
<div id="pu11" class="pu"><h1>JavaScript 125/198</h1>
<p>If points are provided in 8 arguments:</p>
<pre><code>function d(x,y,a,b,c,d,e,f){function z(a,b,c,d){return(y-b)*(c-a)-(x-a)*(d-b)&gt;0}return(z(a,b,c,d)+z(c,d,e,f)+z(e,f,a,b))%3&lt;1}
</code></pre>
<p>If points are provided in a 2-dimensional array:</p>
<pre><code>function c(s){return (z(s[1][0],s[1][1],s[2][0],s[2][1])+z(s[2][0],s[2][1],s[3][0],s[3][1])+z(s[3][0],s[3][1],s[1][0],s[1][1]))%3&lt;1;function z(a,b,c,d){return (s[0][1]-b)*(c-a)-(s[0][0]-a)*(d-b)&gt;0}}
</code></pre>
<p>This code doesn't use any of those fancy vector math. Instead, it only uses a simple algebra trick to determine if the point is inside the triangle or not. The formula:</p>
<pre><code>(y-b)(c-a) - (x-a)(d-b)
</code></pre>
<p><a href="https://www.desmos.com/calculator/pmuc3meieh" rel="nofollow noreferrer">which tells the point is on which side of a line</a>, is derived from rearranging the definition of slope:</p>
<pre><code>            m = (y2-y1)/(x2-x1)
      (y2-y1) = m(x2-x1)
       (y-y1) = m(x-x1)     ,substituting point we are testing (x,y) to be the 2nd point
       (y-y1) = (x-x1)(y2-y1)/(x2-x1)  ,substitute back the original definition of m
(y-y1)(x2-x1) = (x-x1)(y2-y1)    &lt;-- left side will be greater than the right side, if
                                     the point is on the left; otherwise, it's on the right
            0 = (y-b)(c-a)-(x-a)(d-b) ,where (a,b)=(x1,y1), (c,d)=(x2,y2)
</code></pre>
<p>If we test all 3 sides, all 3 should yield some numbers with the same sign only when the point is inside the triangle since we are testing it around the triangle. If the point is on a side then one of the test should return 0.</p>
<p>jsFiddle test code: <a href="http://jsfiddle.net/DerekL/zEzZU/" rel="nofollow noreferrer">http://jsfiddle.net/DerekL/zEzZU/</a></p>
<pre><code>var l = [[-0.31961, -0.12646, 0.38478, 0.37419, -0.30613, -0.59754, -0.85548, 0.6633],[-0.87427, -0.00831, 0.78829, 0.60409, -0.90904, -0.13856, -0.80685, 0.48468],[0.28997, -0.03668, -0.28362, 0.42831, 0.39332, -0.07474, -0.48694, -0.10497],[-0.07783, 0.04415, -0.34355, -0.07161, 0.59105, -0.93145, 0.29402, 0.90334],[0.36107, 0.05389, 0.27103, 0.47754, -0.00341, -0.79472, 0.82549, -0.29028],[-0.01655, -0.20437, -0.36194, -0.90281, -0.26515, -0.4172, 0.36181, 0.51683],[-0.12198, -0.45897, -0.35128, -0.85405, 0.84566, 0.99364, 0.13767, 0.78618],[-0.03847, -0.81531, -0.18704, -0.33282, -0.95717, -0.6337, 0.10976, -0.88374],[0.07904, -0.06245, 0.95181, -0.84223, -0.75583, -0.34406, 0.16785, 0.87519],[-0.33485, 0.53875, -0.25173, 0.51317, -0.62441, -0.90698, -0.47925, 0.74832],
         [-0.99103, 0.43842, 0.78128, -0.10985, -0.84714, -0.20558, -0.08925, -0.78608],[0.15087, -0.56212, -0.87374, -0.3787, 0.86403, 0.60374, 0.01392, 0.84362],[0.1114, 0.66496, -0.92633, 0.27408, 0.92439, 0.43692, 0.8298, -0.29647],[0.87786, -0.8594, -0.42283, -0.97999, 0.58659, -0.327, -0.22656, 0.80896],[0.43525, -0.8923, 0.86119, 0.78278, -0.01348, 0.98093, -0.56244, -0.75129],[-0.73365, 0.28332, 0.63263, 0.17177, -0.38398, -0.43497, -0.31123, 0.73168],[-0.57694, -0.87713, -0.93622, 0.89397, 0.93117, 0.40775, 0.2323, -0.30718],[0.91059, 0.75966, 0.60118, 0.73186, 0.32178, 0.88296, -0.90087, -0.26367],[0.3463, -0.89397, 0.99108, 0.13557, 0.50122, -0.8724, 0.43385, 0.00167],[0.88121, 0.36469, -0.29829, 0.21429, 0.31395, 0.2734, 0.43267, -0.78192]];

function d(x,y,a,b,c,d,e,f){function z(a,b,c,d){return(y-b)*(c-a)-(x-a)*(d-b)&gt;0}return(z(a,b,c,d)+z(c,d,e,f)+z(e,f,a,b))%3&lt;1}

for(var i = 0; i &lt; l.length; i++){
    console.log(d.apply(undefined,l[i]));    //10 true, 10 false
}
</code></pre>
<hr />
<p><strong>97 characters</strong> (not counting spaces or tabs) count if converted into CoffeeScript:</p>
<pre><code>d=(x,y,a,b,c,d,e,f)-&gt;
    z=(a,b,c,d)-&gt;
        (y-b)*(c-a)-(x-a)*(d-b)&gt;0
    (z(a,b,c,d)+z(c,d,e,f)+z(e,f,a,b))%3&lt;1
</code></pre>
<p><strong>115 characters</strong> if converted into ES6:</p>
<pre><code>d=(x,y,a,b,c,d,e,f)=&gt;{z=(a,b,c,d)=&gt;{return (y-b)*(c-a)-(x-a)*(d-b)&gt;0};return(z(a,b,c,d)+z(c,d,e,f)+z(e,f,a,b))%3&lt;1}
</code></pre>
</div>
<div id="pu12" class="pu"><p>
<strong>Java, 149 characters</strong></p>

<pre class="lang-java prettyprint-override"><code>g=Math.atan2(100*(d-y),(a-x));h=Math.atan2(100*(e-y),(b-x));i=Math.atan2(100*(f-y),(c-x));k=Math.round(Math.abs(g-h)+Math.abs(h-i)+Math.abs(i-g))==6;
</code></pre>

<p>Horrible considering I have to write "Math." every time. This is the actual program:</p>

<pre class="lang-java prettyprint-override"><code>package mathPackage;
public class InTriangle {
public static void main(String[] args) {
    boolean k;
    double a=-1,b=0,c=1,d=0,e=1,f=0,x=0,y=0.4;
    double g,h,i;
    g=Math.atan2(100*(d-y),(a-x));
    h=Math.atan2(100*(e-y),(b-x));
    i=Math.atan2(100*(f-y),(c-x));
    k=Math.round(Math.abs(g-h)+Math.abs(h-i)+Math.abs(i-g))==6;
    System.out.println(k);
    System.out.println(g);
    System.out.println(h);
    System.out.println(i);
    System.out.print(Math.abs(g-h)+Math.abs(h-i)+Math.abs(i-g));
}
}
</code></pre>

<p>where a is the x of point a,b is the x of point b, c for x of c, d is y of a, e is y of b, f is the y of c, and x and y are the x and y of the point. The boolean k determines whether it is true or not.</p>
</div>
<div id="pu13" class="pu"><h3>Haskell — <s>233</s> 127</h3>

<p>Using cross products as described <a href="https://math.stackexchange.com/a/51328">here</a>:</p>

<pre><code>h(a,b)(p,q)(r,s)(t,u)=z a b p q r s==z a b r s t u&amp;&amp;z a b r s t u==z a b t u p q where z j k l m n o =(o-m)*(j-l)+(l-n)*(k-m)&gt;0
</code></pre>

<p>Previous solution implemented using <a href="http://en.wikipedia.org/wiki/Barycentric_coordinate_system#Determining_whether_a_point_is_inside_a_triangle" rel="nofollow noreferrer">barycentric coordinates</a> and the formulae described in this Stack Exchange <a href="https://math.stackexchange.com/a/51459">answer</a>:</p>

<pre><code>g(p,q)(r,s)(t,u)(v,w)=
 let (j,k)=(p+(-r),q+(-s))
     (l,m)=(t+(-r),u+(-s))
     (n,o)=(v+(-r),w+(-s))
     d=l*o-n*m
     a=(j*(m-o)+k*(n-l)+l*o-n*m)/d
     b=(j*o-k*n)/d
     c=(k*l-j*m)/d
 in (0&lt;=a&amp;&amp;a&lt;1)&amp;&amp;(0&lt;=b&amp;&amp;b&lt;1)&amp;&amp;(0&lt;=c&amp;&amp;c&lt;1)
</code></pre>

<p>Both functions <code>g</code> and <code>h</code> take four pairs, the first of which is the point to be tested for inclusion and the rest being the coordinates of the vertices of the triangle.</p>

<p>To test with the sample input:</p>

<pre><code>let trueTestCases =
  [((-0.31961, -0.12646), (0.38478, 0.37419), (-0.30613, -0.59754), (-0.85548, 0.6633)),
   ((-0.87427, -0.00831), (0.78829, 0.60409), (-0.90904, -0.13856), (-0.80685, 0.48468)),
   ((0.28997, -0.03668), (-0.28362, 0.42831), (0.39332, -0.07474), (-0.48694, -0.10497)),
   ((-0.07783, 0.04415), (-0.34355, -0.07161), (0.59105, -0.93145), (0.29402, 0.90334)),
   ((0.36107, 0.05389), (0.27103, 0.47754), (-0.00341, -0.79472), (0.82549, -0.29028)),
   ((-0.01655, -0.20437), (-0.36194, -0.90281), (-0.26515, -0.4172), (0.36181, 0.51683)),
   ((-0.12198, -0.45897), (-0.35128, -0.85405), (0.84566, 0.99364), (0.13767, 0.78618)),
   ((-0.03847, -0.81531), (-0.18704, -0.33282), (-0.95717, -0.6337), (0.10976, -0.88374)),
   ((0.07904, -0.06245), (0.95181, -0.84223), (-0.75583, -0.34406), (0.16785, 0.87519)),
   ((-0.33485, 0.53875), (-0.25173, 0.51317), (-0.62441, -0.90698), (-0.47925, 0.74832))]

let falseTestCases =
  [((-0.99103, 0.43842), (0.78128, -0.10985), (-0.84714, -0.20558), (-0.08925, -0.78608)),
   ((0.15087, -0.56212), (-0.87374, -0.3787), (0.86403, 0.60374), (0.01392, 0.84362)),
   ((0.1114, 0.66496), (-0.92633, 0.27408), (0.92439, 0.43692), (0.8298, -0.29647)),
   ((0.87786, -0.8594), (-0.42283, -0.97999), (0.58659, -0.327), (-0.22656, 0.80896)),
   ((0.43525, -0.8923), (0.86119, 0.78278), (-0.01348, 0.98093), (-0.56244, -0.75129)),
   ((-0.73365, 0.28332), (0.63263, 0.17177), (-0.38398, -0.43497), (-0.31123, 0.73168)),
   ((-0.57694, -0.87713), (-0.93622, 0.89397), (0.93117, 0.40775), (0.2323, -0.30718)),
   ((0.91059, 0.75966), (0.60118, 0.73186), (0.32178, 0.88296), (-0.90087, -0.26367)),
   ((0.3463, -0.89397), (0.99108, 0.13557), (0.50122, -0.8724), (0.43385, 0.00167)),
   ((0.88121, 0.36469), (-0.29829, 0.21429), (0.31395, 0.2734), (0.43267, -0.78192))]

type Point = (Double, Double)

test :: [(Point, Point, Point, Point)] -&gt; [Bool]
test testCases =
  map (\((px,py),(ax,ay),(bx,by),(cx,cy)) -&gt; h (px,py) (ax,ay) (bx,by) (cx,cy)) testCases

test trueTestCases --&gt; [True,True,True,True,True,True,True,True,True,True]
test falseTestCases --&gt; [False,False,False,False,False,False,False,False,False,False]
</code></pre>

<p>Ungolfed solutions:</p>

<pre><code>type Point = (Double, Double)

-- using cross products

triangulate' (a, b) (p, q) (r, s) (t, u) =
  (side a b p q r s == side a b r s t u) &amp;&amp; (side a b r s t u == side a b t u p q)
  where side j k l m n o = (o - m) * (j - l) + (-n + l) * (k - m) &gt;= 0

-- using barycentric coordinates

triangulate :: (Point, Point, Point, Point) -&gt; Bool
triangulate ((px, py), (ax, ay), (bx, by), (cx, cy)) = 
  let (p'x, p'y) = (px + (-ax), py + (-ay))
      (b'x, b'y) = (bx + (-ax), by + (-ay))
      (c'x, c'y) = (cx + (-ax), cy + (-ay))
      d = b'x * c'y - c'x * b'y
      a = (p'x * (b'y - c'y) + p'y * (c'x - b'x) + b'x * c'y - c'x * b'y) / d
      b = (p'x * c'y - p'y * c'x) / d
      c = (p'y * b'x - p'x * b'y) / d
  in
      (0 &lt;= a &amp;&amp; a &lt; 1) &amp;&amp; (0 &lt;= b &amp;&amp; b &lt; 1) &amp;&amp; (0 &lt;= c &amp;&amp; c &lt; 1)
</code></pre>
</div>
<div id="pu14" class="pu"><h2>HTML5 + JS, 13b + 146b / 141b / 114 chars</h2>

<p>HTML:</p>

<pre><code>&lt;canvas id=C&gt;
</code></pre>

<p>JS (146b):</p>

<pre><code>// @params: t1x, t1y, t2x, t2y, t3x, t3y, pointx, pointy
function T(a,b,c,d,e,f,g,h){with(C.getContext("2d"))return beginPath(),moveTo(a,b),lineTo(c,d),lineTo(e,f),fill(),!!getImageData(g,h,1,1).data[3]}
</code></pre>

<p>or ES6 (141b):</p>

<pre><code>T=(a,b,c,d,e,f,g,h)=&gt;{with(C.getContext("2d"))return beginPath(),moveTo(a,b),lineTo(c,d),lineTo(e,f),fill(),!!getImageData(g,h,1,1).data[3]}
</code></pre>

<p>or ES6 unicode-obfuscated (114 chars):</p>

<pre><code>eval(unescape(escape('𥀽𚁡𛁢𛁣𛁤𛁥𛁦𛁧𛁨𚐽🡻𭱩𭁨𚁃𛡧𩑴𠱯𫡴𩑸𭀨𘠲𩀢𚐩𬡥𭁵𬡮𘁢𩑧𪑮𤁡𭁨𚀩𛁭𫱶𩑔𫰨𨐬𨠩𛁬𪑮𩑔𫰨𨰬𩀩𛁬𪑮𩑔𫰨𩐬𩠩𛁦𪑬𫀨𚐬𘐡𩱥𭁉𫑡𩱥𡁡𭁡𚁧𛁨𛀱𛀱𚐮𩁡𭁡𦰳𧑽').replace(/uD./g,'')))
</code></pre>

<p>demo:
<a href="http://jsfiddle.net/xH8mV/" rel="nofollow">http://jsfiddle.net/xH8mV/</a></p>

<p>Unicode obfuscation made with:
<a href="http://xem.github.io/obfuscatweet/" rel="nofollow">http://xem.github.io/obfuscatweet/</a></p>
</div>
<div id="pu15" class="pu"><h2>Mathematica, 67 bytes</h2>

<pre><code>f=Equal@@({#2,-#}&amp;@@(#-#2).(x-#)&gt;0&amp;@@@Partition[x=#;#2,2,1,{1,1}])&amp;
</code></pre>

<p>The function takes two arguments, the point <code>X</code> and a list of points <code>{A,B,C}</code>, which are referred to as <code>#</code> and <code>#2</code> respectively. That is if you call</p>

<pre><code>f[X,{A,B,C}]
</code></pre>

<p>then you'll get <code>#</code> as <code>X</code> and <code>#2</code> as <code>{A,B,C}</code>. (Note that there are two other anonymous functions nested inside the code - <code>#</code> and <code>#2</code> have a different meaning within those.) </p>

<p>Here is an explanation of the function itself:</p>

<pre><code>                                              x=#;#2            &amp; (* Save X into a variable x, but evaluate to {A,B,C}. *)
                                    Partition[x=#;#2,2,1,{1,1}] &amp; (* Get a cyclic list of pairs {{A,B},{B,C},{C,B}}. *)
       (                        &amp;@@@Partition[x=#;#2,2,1,{1,1}])&amp; (* Define an anonymous function and apply it to each 
                                                                     of the above pairs. The two elements are referred 
                                                                     to as # and #2. *)
       (          (#-#2)        &amp;@@@Partition[x=#;#2,2,1,{1,1}])&amp; (* Subtract the two points. For a pair of vertices 
                                                                     this yields a vector corresponding to the edge 
                                                                     between them. *)
        {#2,-#}&amp;                                                  (* An anonymous function that takes two values, 
                                                                     reverses them, inverts the sign of one of them 
                                                                     and puts them into a list. *)
       ({#2,-#}&amp;@@(#-#2)        &amp;@@@Partition[x=#;#2,2,1,{1,1}])&amp; (* Applied to the edge, this yields its normal. *)
       ({#2,-#}&amp;@@(#-#2).(x-#)  &amp;@@@Partition[x=#;#2,2,1,{1,1}])&amp; (* Take the scalar product of that normal with a
                                                                     vector from a vertex to x. This is projection of 
                                                                     this vector onto that normal and hence the SIGNED
                                                                     distance of x from the edge. *)
       ({#2,-#}&amp;@@(#-#2).(x-#)&gt;0&amp;@@@Partition[x=#;#2,2,1,{1,1}])&amp; (* Check the sign of that distance, the exact mapping 
                                                                     between (left, right) and (True, False) is 
                                                                     irrelevant, as long as it's consistent. *)
Equal@@({#2,-#}&amp;@@(#-#2).(x-#)&gt;0&amp;@@@Partition[x=#;#2,2,1,{1,1}])&amp; (* Check if all signs are equal - that is, if point X 
                                                                     lies on the same side of all edges. This is 
                                                                     equivalent to check that the point is inside the 
                                                                     triangle. *)
</code></pre>

<p>Note that this function will actually work for <em>any</em> convex n-gon as long as its vertices are given in either clockwise or counter-clockwise order.</p>
</div>
<div id="pu16" class="pu"><h1>Javascript / ECMAScript 6, <strike>161</strike> <strike>159</strike> 158 / 152</h1>

<p>Javascript:</p>

<pre><code>function $(t,r,i,a,n,g,l,e){b=(-g*l+a*(-n+l)+i*(g-e)+n*e)/2;c=b&lt;0?-1:1;d=(a*l-i*e+(e-a)*t+(i-l)*r)*c;f=(i*g-a*n+(a-g)*t+(n-i)*r)*c;return d&gt;0&amp;&amp;f&gt;0&amp;&amp;d+f&lt;2*b*c}
</code></pre>

<p>ECMAScript 6 version (thanks m.buettner, saves 6 characters)</p>

<pre><code>$=(t,r,i,a,n,g,l,e)=&gt;{b=(-g*l+a*(-n+l)+i*(g-e)+n*e)/2;c=b&lt;0?-1:1;d=(a*l-i*e+(e-a)*t+(i-l)*r)*c;f=(i*g-a*n+(a-g)*t+(n-i)*r)*c;return d&gt;0&amp;&amp;f&gt;0&amp;&amp;d+f&lt;2*b*c}
</code></pre>

<p>Call it as such (returns <code>true</code> or <code>false</code>):</p>

<pre><code>$(pointX, pointY, v1X, v1Y, v2X, v2Y, v3X, v3Y);
</code></pre>

<p>Uses some fancy <a href="http://en.wikipedia.org/wiki/Barycentric_coordinates_%28mathematics%29" rel="nofollow noreferrer">barycentric coordinate math</a> based on code from <a href="https://stackoverflow.com/a/2049712/863470">this answer</a>. An ungolfed version for your reading enjoyment follows:</p>

<pre><code>function $ (pointX, pointY, v1X, v1Y, v2X, v2Y, v3X, v3Y) {
  var A =  (-v2Y * v3X + v1Y * (-v2X + v3X) + v1X * (v2Y - v3Y) + v2X * v3Y) / 2;
  var sign = A &lt; 0 ? -1 : 1;
  var s = (v1Y * v3X - v1X * v3Y + (v3Y - v1Y) * pointX + (v1X - v3X) * pointY) * sign;
  var t = (v1X * v2Y - v1Y * v2X + (v1Y - v2Y) * pointX + (v2X - v1X) * pointY) * sign;
  return s &gt; 0 &amp;&amp; t &gt; 0 &amp;&amp; s + t &lt; 2 * A * sign;
}
</code></pre>
</div>
<div id="pu17" class="pu"><h1>C# 218 (149?)</h1>

<pre><code>using P=System.Drawing.PointF;
bool F(P[]p){for(int i=0;i&lt;4;i++){p[i].X*=1e7f;p[i].Y*=1e7f;}P[]a=new P[3];Array.Copy(p,1,a,0,3);var g=new System.Drawing.Drawing2D.GraphicsPath();g.AddLines(a);return g.IsVisible(p[0]);}
</code></pre>

<p>Probably not as character-efficient as a mathematical method, but it's a fun use of libraries. Incidentally, also rather slow.</p>

<p>Also taking advantage of "Also don't worry about numerical stability or floating-point precision." - unfortunately, <code>GraphicsPath</code> uses <code>int</code>s internally, so a value in the range -1 &lt; f &lt; 1 can only have three possible values. Since floats only have 7 digits of precision, I just multiply by 1e7 to turn them into whole numbers. Hm, I guess it's not really <em>losing</em> any precision. It's also exploitable in another way: I probably could have taken advantage of ignoring precision and just given the "wrong" answer.</p>

<p><em>If</em> I'm allowed to ignore the character cost of importing libraries, <strong>149</strong> (at the very least, <code>System.Linq</code> and <code>System.Drawing</code> are pretty standard on most WinForms projects, but <code>System.Drawing.Drawing2D</code> might be a bit of a stretch):</p>

<pre><code>bool G(PointF[]p){for(int i=0;i&lt;4;i++){p[i].X*=1e7f;p[i].Y*=1e7f;}var g=new GraphicsPath();g.AddLines(p.Skip(1).ToArray());return g.IsVisible(p[0]);}
</code></pre>

<p>Test program (yea, it's ugly):</p>

<pre><code>using System;
using System.Drawing;
using System.Drawing.Drawing2D;
using P=System.Drawing.PointF;
using System.Linq;

class Program
{
    static void Main(string[] args)
    {
        Program prog = new Program();
        foreach (string test in
@"[(-0.31961, -0.12646), (0.38478, 0.37419), (-0.30613, -0.59754), (-0.85548, 0.6633)]
[(-0.87427, -0.00831), (0.78829, 0.60409), (-0.90904, -0.13856), (-0.80685, 0.48468)]
[(0.28997, -0.03668), (-0.28362, 0.42831), (0.39332, -0.07474), (-0.48694, -0.10497)]
[(-0.07783, 0.04415), (-0.34355, -0.07161), (0.59105, -0.93145), (0.29402, 0.90334)]
[(0.36107, 0.05389), (0.27103, 0.47754), (-0.00341, -0.79472), (0.82549, -0.29028)]
[(-0.01655, -0.20437), (-0.36194, -0.90281), (-0.26515, -0.4172), (0.36181, 0.51683)]
[(-0.12198, -0.45897), (-0.35128, -0.85405), (0.84566, 0.99364), (0.13767, 0.78618)]
[(-0.03847, -0.81531), (-0.18704, -0.33282), (-0.95717, -0.6337), (0.10976, -0.88374)]
[(0.07904, -0.06245), (0.95181, -0.84223), (-0.75583, -0.34406), (0.16785, 0.87519)]
[(-0.33485, 0.53875), (-0.25173, 0.51317), (-0.62441, -0.90698), (-0.47925, 0.74832)]
[(-0.99103, 0.43842), (0.78128, -0.10985), (-0.84714, -0.20558), (-0.08925, -0.78608)]
[(0.15087, -0.56212), (-0.87374, -0.3787), (0.86403, 0.60374), (0.01392, 0.84362)]
[(0.1114, 0.66496), (-0.92633, 0.27408), (0.92439, 0.43692), (0.8298, -0.29647)]
[(0.87786, -0.8594), (-0.42283, -0.97999), (0.58659, -0.327), (-0.22656, 0.80896)]
[(0.43525, -0.8923), (0.86119, 0.78278), (-0.01348, 0.98093), (-0.56244, -0.75129)]
[(-0.73365, 0.28332), (0.63263, 0.17177), (-0.38398, -0.43497), (-0.31123, 0.73168)]
[(-0.57694, -0.87713), (-0.93622, 0.89397), (0.93117, 0.40775), (0.2323, -0.30718)]
[(0.91059, 0.75966), (0.60118, 0.73186), (0.32178, 0.88296), (-0.90087, -0.26367)]
[(0.3463, -0.89397), (0.99108, 0.13557), (0.50122, -0.8724), (0.43385, 0.00167)]
[(0.88121, 0.36469), (-0.29829, 0.21429), (0.31395, 0.2734), (0.43267, -0.78192)]".Split('\n'))
        {
            string t = test.Replace("[(", "").Replace(")]", "");
            string[] points = t.Split(new string[] { "), (" }, StringSplitOptions.None);

            string[] p = points[0].Split(',');
            P[] xabc = new P[4];

            for (int i = 0; i &lt; 4; i++)
            {
                p = points[i].Split(',');
                xabc[i] = new F(float.Parse(p[0]), float.Parse(p[1]));
            }

            Console.WriteLine(test + "=&gt;" + prog.F(xabc));
        }

        Console.ReadKey();
    }

    bool G(PointF[]p)
    {
        for(int i=0;i&lt;4;i++){p[i].X*=1e7f;p[i].Y*=1e7f;}
        var g=new GraphicsPath();
        g.AddLines(p.Skip(1).ToArray());
        return g.IsVisible(p[0]);
    }

    bool F(P[]p)
    {
        for(int i=0;i&lt;4;i++){p[i].X*=1e7f;p[i].Y*=1e7f;}
        var g=new System.Drawing.Drawing2D.GraphicsPath();
        g.AddLines(p.Skip(1).ToArray());
        return g.IsVisible(p[0]);
    }
}
</code></pre>
</div>
<div id="pu18" class="pu"><h1>MATLAB: 9!</h1>

<p>Not a whole lot of me to write here</p>

<pre><code>inpolygon
</code></pre>

<p>Can be called like so:</p>

<pre><code>inpolygon(2/3, 2/3, [0 1 1], [0 0 1])
</code></pre>

<p>Output is assigned to a variable named <code>ans</code></p>

<hr>

<p>If I actually had to write a function, it may be something like so, could probably be optimized:</p>

<pre><code>function y=f(a,b,c,d)
inpolygon(a,b,c,d)
</code></pre>
</div>
<div id="pu19" class="pu"><h1>J <strike>64</strike> 45 (42 without assignment)</h1>

<pre><code>c=:*./@(&gt;:&amp;0)@({.(,(1-+/))@%.|:@}.)@(}:-"1{:)
</code></pre>

<p>The assignment is not necessary for the thing to be a function, so unsure whether to count it or not.
Taking advantage of the flexible input: I'd like to have an array of (1 + number of vertices) x (dimensionality of the space).</p>

<p>Hoping to score some extra points here ... : This thing works for any dimension of simplex, not just triangles in a plane, but also a 3 sided pyramid in 3d space and so on. It also works when the number of vertices of the simplex is smaller than (n+1), then it computes whether the projection of the point onto the simplex is inside or not.</p>

<p>It converts to <a href="http://en.wikipedia.org/wiki/Barycentric_coordinate_system" rel="nofollow">barycentric coordinates</a>, then checks for negative ones, indicating the point is outside.  Do mind J uses _ for negative </p>

<pre><code>NB. example in triangle
D =: 4 2 $ 1 1 0 0 3 0 0 2 NB. 4 rows , x first, then the vertices of the triangle

NB. subtract last vertex coordinates from the rest and drop reference node
n=: (}:-"1{:)

NB. preprocessed to barycentric coordinates
bar=: {. (, 1 - +/)@%. |:@}.

NB. all positive
ap =: *./@(&gt;:&amp;0)

insided =: ap@bar@n

inside D
1
</code></pre>

<p>A run on the given examples:</p>

<pre><code>   true =: 0 : 0
[(-0.31961, -0.12646), (0.38478, 0.37419), (-0.30613, -0.59754), (-0.85548, 0.6633)]
[(-0.87427, -0.00831), (0.78829, 0.60409), (-0.90904, -0.13856), (-0.80685, 0.48468)]
[(0.28997, -0.03668), (-0.28362, 0.42831), (0.39332, -0.07474), (-0.48694, -0.10497)]
[(-0.07783, 0.04415), (-0.34355, -0.07161), (0.59105, -0.93145), (0.29402, 0.90334)]
[(0.36107, 0.05389), (0.27103, 0.47754), (-0.00341, -0.79472), (0.82549, -0.29028)]
[(-0.01655, -0.20437), (-0.36194, -0.90281), (-0.26515, -0.4172), (0.36181, 0.51683)]
[(-0.12198, -0.45897), (-0.35128, -0.85405), (0.84566, 0.99364), (0.13767, 0.78618)]
[(-0.03847, -0.81531), (-0.18704, -0.33282), (-0.95717, -0.6337), (0.10976, -0.88374)]
[(0.07904, -0.06245), (0.95181, -0.84223), (-0.75583, -0.34406), (0.16785, 0.87519)]
[(-0.33485, 0.53875), (-0.25173, 0.51317), (-0.62441, -0.90698), (-0.47925, 0.74832)]
)

   false =: 0 : 0
[(-0.99103, 0.43842), (0.78128, -0.10985), (-0.84714, -0.20558), (-0.08925, -0.78608)]
[(0.15087, -0.56212), (-0.87374, -0.3787), (0.86403, 0.60374), (0.01392, 0.84362)]
[(0.1114, 0.66496), (-0.92633, 0.27408), (0.92439, 0.43692), (0.8298, -0.29647)]
[(0.87786, -0.8594), (-0.42283, -0.97999), (0.58659, -0.327), (-0.22656, 0.80896)]
[(0.43525, -0.8923), (0.86119, 0.78278), (-0.01348, 0.98093), (-0.56244, -0.75129)]
[(-0.73365, 0.28332), (0.63263, 0.17177), (-0.38398, -0.43497), (-0.31123, 0.73168)]
[(-0.57694, -0.87713), (-0.93622, 0.89397), (0.93117, 0.40775), (0.2323, -0.30718)]
[(0.91059, 0.75966), (0.60118, 0.73186), (0.32178, 0.88296), (-0.90087, -0.26367)]
[(0.3463, -0.89397), (0.99108, 0.13557), (0.50122, -0.8724), (0.43385, 0.00167)]
[(0.88121, 0.36469), (-0.29829, 0.21429), (0.31395, 0.2734), (0.43267, -0.78192)]
)
   NB. replace - by _ to avoid problems
   NB. cut up per row, drop the [ ] and convert to numbers
   $dat_t =: ((4 2 $ ".)@}:@}.;._2) (true='-')} true ,: '_'
10 4 2
   $dat_f =: ((4 2 $ ".)@}:@}.;._2) (false='-')}false,: '_'
10 4 2
   NB. this results in arrays with shape 10 4 2

   NB. for each 4 x 2 array (rank 2), do c for all true instances
   c=:*./@(&gt;:&amp;0)@({.(,(1-+/))@%.|:@}.)@(}:-"1{:)
   c"2 dat_t
1 1 1 1 1 1 1 1 1 1
   NB. the same for the false ones, demonstrating anonymous usage
   NB. still a function though (or verb in J parlance)
   *./@(&gt;:&amp;0)@({.(,(1-+/))@%.|:@}.)@(}:-"1{:)"2 dat_f
0 0 0 0 0 0 0 0 0 0
</code></pre>
</div>
<div id="pu20" class="pu"><h1><a href="https://github.com/isaacg1/pyth/blob/master/pyth.py" rel="nofollow noreferrer">Pyth 1.0.5</a>, <strike>57</strike> <strike>54</strike> 51</h1>

<pre><code>DgYb=Z0J'bWbK;bDiHNR*-'H'K-@N1@K1~Z&gt;iYJiJY=JK)R!%Z3
</code></pre>

<p>Defines the function g, which takes two inputs: the test point, and then the list of the vertices of the triangle. Outputs <code>True</code> and <code>False</code>. Note: Destroys the input, specifically b, the list of the vertices of the triangle.</p>

<p>Try it <a href="http://ideone.com/fork/aPbXH9" rel="nofollow noreferrer">here</a>.
The last few characters, <code>gvwvw</code> call the function with a test case on the next two lines.</p>

<p>Based on <a href="https://stackoverflow.com/questions/2049582/how-to-determine-a-point-in-a-triangle">this</a> algorithm</p>

<p>Explanation:</p>

<pre><code>DgYb                  Define g(Y,b):
=Z0                     Z=0
J'b                     J=b[0]              (No = is needed because j is special).
Wb                      While len(b)&gt;0:     (While b:)
K;b                       K=b.pop()
DiHN                      Define i(H,N):    
R*-'H'K-@N1@K1              Return half of the linked equation.
~ZiYJiJY                  Z+=i(Y,J)&gt;i(J,Y)
=JK                       J=K
)                       Wend
R!%Z3                   return not Z%3==0   (True iff Z == 0 or 3)
</code></pre>

<p>The CJam - Pyth war rages on!</p>
</div>
<div id="pu21" class="pu"><h1>Fortran - <s>232</s> <s>218</s> <s>195</s> 174</h1>
<p>Bloody awful. The function is horrendous because of the requirement that the data is passed to it and we cannot preprocess it.</p>
<pre><code>logical function L(x);real::x(8);p=x(1)-x(3);q=x(2)-x(4);r=x(5)-x(3);s=x(6)-x(4);t=x(7)-x(3);u=x(8)-x(4);L=ALL([p*(s-u)+q*(t-r)+r*u-t*s,p*u-q*t,q*r-p*s]&gt;=r*u-t*s);endfunction
</code></pre>
<p>The decrease of 14 characters is because I forgot to golf the function name from my test runs. The further decrease is due to implicit typing and forgetting to change the function name. The next 20 characters came off due to reading in the points as a single array. The full program is</p>
<pre><code>program inTriagle
   real, dimension(2) :: a,b,c,x
   do 
      print*,&quot;Enter coordinates as x,a,b,c&quot;
      read*,x,a,b,c
      if(all(x==0.0).and.all(a==0.0).and.all(b==0.0).and.all(c==0.0)) exit
      print*,&quot;Is point in triangle: &quot;,T(x,a,b,c)
   enddo
 contains!                       
   logical function L(x)
     real::x(8)
     p=x(1)-x(3);q=x(2)-x(4);r=x(5)-x(3)
     s=x(6)-x(4);t=x(7)-x(3);u=x(8)-x(4)
     L=ALL([p*(s-u)+q*(t-r)+r*u-t*s,p*u-q*t,q*r-p*s]&gt;=r*u-t*s)
   endfunction
end program inTriagle
</code></pre>
</div>
<div id="pu22" class="pu"><h2>C 414 (was 465)</h2>
<p>Golfed</p>
<pre><code>#define D double 
int F(D ax,D ay,D bx,D by,D cx,D cy,D px,D py){int y=0;double J,K;D m=(ax-bx&lt;0.001)?(by-ay)/(ax-bx):1000;D b=m*ax+ay;J=m*cx-cy+b;K=m*px-py+b;if(J*K&gt;=0)y=1;return y;}D T[8],k;int i,n;void G(){while(i&lt;8){scanf(&quot;%lf&quot;,&amp;k);T[i++]=k;}n+=F(T[2],T[3],T[4],T[5],T[6],T[7],T[0],T[1]);n+=F(T[4],T[5],T[6],T[7],T[2],T[3],T[0],T[1]);n+=F(T[2],T[3],T[6],T[7],T[4],T[5],T[0],T[1]);printf(n==3?&quot;True&quot;:&quot;False&quot;);}
</code></pre>
<p>Original function declaration added for explanation</p>
<pre><code>/**
* determine if points C &amp; P are on same side of line AB
* return 1 if true, 0 otherwise
*/
int PointsSameSide(D ax,D ay,D bx,D by,D cx, D cy, D px, D py);
</code></pre>
<p>Rewritten as a named function: input via stdin one each line or all in one line space-separated.</p>
<pre><code>#define D double
int F(D ax,D ay,D bx,D by,D cx, D cy, D px, D py)
{
int y=0;
double J,K;
D m = (ax-bx&lt;0.001)?(by-ay)/(ax-bx):1000;
D b = m*ax+ay;
J=m*cx-cy+b;
K=m*px-py+b;
if(J*K&gt;=0)y=1;
return y;
}
double T[8],k;
int i,n;
void G()
{
while(i&lt;8){scanf(&quot;%lf&quot;,&amp;k);T[i++]=k;}
n+=F(T[2],T[3],T[4],T[5],T[6],T[7],T[0],T[1]);
n+=F(T[4],T[5],T[6],T[7],T[2],T[3],T[0],T[1]);
n+=F(T[2],T[3],T[6],T[7],T[4],T[5],T[0],T[1]);
printf(n==3?&quot;True&quot;:&quot;False&quot;);
}
</code></pre>
</div>
<div id="pu23" class="pu"><h1>C – 156 bytes</h1>
<p>Input are array of 3 floats in X, 3 floats in Y and separate x and y for the test point. Bonus: handles all edge cases!</p>
<pre><code>int f(float*X,float*Y,float x,float y){int i,j,c=0;for(i=0,j=2;i&lt;3;j=i++)if(((Y[i]&gt;y)!=(Y[j]&gt;y))&amp;&amp;(x&lt;(X[j]-X[i])*(y-Y[i])/(Y[j]-Y[i])+X[i]))c=!c;return c;}
</code></pre>
<p>Adapted from PNPOLY.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/32898/">32898</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




