<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::50926</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>823</td><td>tinylisp</td><td>240823T204540Z</td><td><a href="https://codegolf.stackexchange.com/questions/50926/calculating-collatz-cousins/275117#275117">Andrew B</a></td></tr>
<tr d-ix="1"><td>026</td><td>CJam</td><td>150529T000706Z</td><td><a href="https://codegolf.stackexchange.com/questions/50926/calculating-collatz-cousins/50951#50951">Dennis</a></td></tr>
<tr d-ix="2"><td>nan</td><td></td><td>150529T023542Z</td><td><a href="https://codegolf.stackexchange.com/questions/50926/calculating-collatz-cousins/50956#50956">windy</a></td></tr>
<tr d-ix="3"><td>021</td><td>Pyth</td><td>150528T224144Z</td><td><a href="https://codegolf.stackexchange.com/questions/50926/calculating-collatz-cousins/50944#50944">Jakube</a></td></tr>
<tr d-ix="4"><td>071</td><td>Python 2</td><td>150529T014418Z</td><td><a href="https://codegolf.stackexchange.com/questions/50926/calculating-collatz-cousins/50954#50954">Sp3000</a></td></tr>
<tr d-ix="5"><td>178</td><td>PHP 5.4+</td><td>150529T060334Z</td><td><a href="https://codegolf.stackexchange.com/questions/50926/calculating-collatz-cousins/50962#50962">JPMC</a></td></tr>
<tr d-ix="6"><td>118</td><td>Python 2</td><td>150529T051014Z</td><td><a href="https://codegolf.stackexchange.com/questions/50926/calculating-collatz-cousins/50960#50960">Reto Kor</a></td></tr>
<tr d-ix="7"><td>089</td><td>Mathematica</td><td>150528T191438Z</td><td><a href="https://codegolf.stackexchange.com/questions/50926/calculating-collatz-cousins/50931#50931">Martin E</a></td></tr>
<tr d-ix="8"><td>123</td><td>Java 8</td><td>150528T193049Z</td><td><a href="https://codegolf.stackexchange.com/questions/50926/calculating-collatz-cousins/50932#50932">Ypnypn</a></td></tr>
<tr d-ix="9"><td>035</td><td>CJam</td><td>150528T182602Z</td><td><a href="https://codegolf.stackexchange.com/questions/50926/calculating-collatz-cousins/50928#50928">Optimize</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/dloscutoff/Esolangs/tree/master/tinylisp" rel="nofollow noreferrer">tinylisp</a>, <s> 993 </s> 823 bytes</h1>
<p>Shout out to @DLosc for carving off 170 bytes! Woo Hoo!</p>
<pre><code>(d !(q(1 1
(d B(q(S S
(d C(q((S T)(i T(C(c(a(h S)(h S))S)(s T 1))S
(d F(q((S T)(i T(F(c((q((U)(a(a U U)U)))(h(t S)))S)(s T 1))S
(d G(F ! 38
(d H(q((S T)(i(e T !)S(i(l(h T)(a S 1))(H(s S(h T))(t T))(H S(t T
(d K(q((S T)(i(e T !)S(i(l(h T)(a S 1))(a(h(t(t T)))(K(s S(h T))(t T)))(K S(t T
(d M(q((S)(N(i(a(H(s S 1)G)(a(e S 4)(H S(C ! 30))))()(B(K(s S 1)G)))(B(a S S
(d N(q((S T)(i S(N(t S)(c(h S)T))T
(d O(q((T S)(i S(O(N(M(h S))T)(t S))T
(d P(q((T S)(i S(Q(c(h S)T)(t S))T
(d Q(q((T S)(i S(P T(t S))T
(d R(q((S T U)(i S(i T(i(e(h S)(h T))(R(t S)(t T)(c(h S)U))(i(l(h S)(h T))(R(t S)T(c(h S)U))(R S(t T)(c(h T)U))))(R(t S)T(c(h S)U)))(i T(R S(t T)(c(h T)U))U
(d V(q((S T)(i S(V(t S)(c(h S)T))T
(d W(q((S)(i(t S)(V(R(W(Q()S))(W(P()S))())())S
(d Y(q((T S)(i S(Y(i T(O()T)())(s S 1))(B T S
(d A(q((S)(i S(W(h(Y(B 2)(s S 1))))(B 1
</code></pre>
<p><a href="https://tio.run/##jZLNa8JAEMXv/SvG28yt6Qf0qkIMiCZmNwkegxUakNKil/716ZvZaD7qoSDxZfc3bzZv9tJ8/pya81fb8jvN@Jsjih4gF5COnMolJLQXbsjzkg9c8wc5sYfg/0yeIiiF4xEcA9aFQlBTU0GFFCKo5IvWTotXHNOMnt9UJ70RH8HMxEGd0BRLNTkt4gTlzpYEjvpM8A6lDuv/ONR6llArvJ7aYan325if8BYudWgNi5V6HCFfQvOlfsGjaK3wIlgaJvqqbe1Tt4OcHCw1D4SlkaKv9UsV8bquSApoEyL3EuIzKhtRu5vHANmNkAxz6ffy7hyYjO3q1BDXdcCaRB4Op4F07phhl@QE8gMgD8mFGm9zv4OFe/KXLfRw5Sik8l5IVTeUJmyW6FAhBdwsgciCsJ/Fvh9FsbfmKWtcIt2kMCbEYfT8ag62wkXZY@vpxhkZtTyn6LX9BQ" rel="nofollow noreferrer" title="tinylisp – Try It Online">Try it online!</a></p>
<p>Ungolfed:</p>
<pre><code>(d list
(q(args
  args
)))


(d make-pow2
(q((S T)
  (i
    T
    (make-pow2 (c (a (h S) (h S)) S) (s T 1))
    S
  )
)))

(d pow2 (make-pow2 (q(1 1)) 30))

(d times3
(q((U )
   (a (a U U) U)
)))

(d make-pow3
(q((S T)
  (i
    T
    (make-pow3 (c (times3 (h (t S))) S) (s T 1))
    S
  )
)))

(d pow3 (make-pow3 (q (1 1)) 38))

(d trim
(q((S T)
  (i
    (e T (q(1 1)))
    S &#32;
    (i&#32;
      (l (h T) (a S 1))
      (trim (s S (h T)) (t T))
      (trim S (t T))
    )
  )
)))

(d div3?
(q((S)
  (e 0 (trim S pow3))
)))

(d div2?
(q((S)
  (e 0 (trim S pow2))
)))


(d div3*
(q((S T)
  (i
    (e T (q(1 1)))
    S
    (i&#32;
      (l (h T) (a S 1))
      (a (h (t (t T))) (div3* (s S (h T)) (t T)))      &#32;
      (div3* S (t T))&#32;
    )
  ) &#32;
)))

(d div3
(q((S)
  (div3* S pow3)
)))




(d G
(q((S)
  (i&#32;
    (div3? (s S 1))
    (i&#32;
      (e (div3 (s S 1)) 1)
      (list (a S S))
      (i
        (div2? (div3 (s S 1)))
        (list (a S S))
        (list (div3 (s S 1)) (a S S))
      )     &#32;
    )
    (list (a S S))
  )
)))

(d concat
(q((S T)
  (i
    S
    (concat (t S) (c (h S) T))
    T
  )
)))

(d step*
(q((N acc)
  (i
    N
    (step* (t N) (concat (G (h N)) acc ))&#32;
    acc
  )&#32;
)))

(d even
(q((S T)
  (i
    (e S ())
    T
    (odd (t S) (c (h S) T))       &#32;
  )   &#32;
)))

(d odd
(q((S T)
  (i
    (e S ())
    T
    (even (t S) T)       &#32;
  )   &#32;
)))

(d merge
(q((S T U)
  (i
    (e S ())
    (i
      (e T ())
      U
      (merge S (t T) (c (h T) U))&#32;
    )
    (i
      (e T ())
      (merge (t S) T (c (h S) U))&#32;
      (i
        (e (h S) (h T))
        (merge (t S) (t T) (c (h S) U))     &#32;
        (i
          (l (h S) (h T))
          (merge (t S) T (c (h S) U))
          (merge S (t T) (c (h T) U))
        )
      )
    )
  ) &#32;
)))

(d rev
(q((S T)
  (i&#32;
    (e S ())
    T
    (rev (t S) (c (h S) T))
  )
)))

(d sort
(q((S)
  (i
    (e () S)
    S
    (i&#32;
      (e () (t S))
      S
      (rev (merge (sort(odd S ())) (sort (even S ())) ()) ())
    )
  )
)))

(d step
(q((N)
  (i
    N
    (step* N ()) &#32;
    () &#32;
  )
)))

(d stopping
(q((N S)
  (i
    (e S 0)
    (list N S)
    (stopping (step N) (s S 1))
  ) &#32;
)))

(d A
(q((S)
  (i
    (e S 0)
    (q(1))
    (sort (h (stopping (q(2)) (s S 1))) )
  ) &#32;
)))

</code></pre>
<p><a href="https://tio.run/##jVVNj@IwDL33V/gYj7QSUI20NzSnufXS8gMqiJhqByhQMdpfzzp2nI9OmEWCNkqeX96L7XQajn8/h@t4v5sd0GCqzNn0l/21AuAXIlZVRYuH/o/9NZ6@Vg5hWuiQIGagB0DHTxMgYLZgejAf0KI8kUdX6GCJyOiWnij0xC5RCcHZLB0U6oVHTMPBXmvefANM4XboYQMbpF9gUo76/zpr1inETqaZnNInpNYZxxlU62/VehkOhe2NJVJ15qkBZGmQN40@nZQOnbc2SKB5R@p0tbKOTm43W27TScxk74ZbvRZRLMnCIgQ5H5hBVz9AVwpV2pcnvT7rtPfJEC@0zpsUvKMEBELB6SFAPAWCpOeQeNMQPgJvi3HvCchLZvBadKjcxI4VQFinf3BKnSU222hz8AMhXq1n4RiXS@FhOt9zhsLkgLzgOVnM@/Z03PZTIZk@c7IubcKtw/2t5dZlXNfJjlIXDfTbbULWCBkDHFeDkfndcTZkg0JAM0hjzmHgtjd7LJccpT5RQ1On3a6gF2Ld8DgwE/xJYqfBM3eP@Q72srfK6G6pMmcoBemakL2NTjOPFra30rlrD7PUPqDx4V5tPIkQnhejjRd3l5ZbypIK8UxpJ2aE2unfKX@U9h1V8h9QoeKLXX@xtzyx8DCzBC2XeFLcp8uUXg/KZdy3o3zX8aJ8YPxUq0u8oT8Hx8xFy7JQJny16ZT8C1e8aylpuUft1nC09y6DNPw0jsNx77u2nVfrIr1AGnVqNEz24HaOF2Sag7fSkUVa@lZoO4jpj5T7bFYYmTFL8N28wfIV7/8A" rel="nofollow noreferrer" title="tinylisp – Try It Online">Try it online!</a></p>
<h2>Explanation</h2>
<p>My initial approach was a naive one where I started from 2^n and counted down checking each number to see if it's stopping number was n. That was way too slow. After consulting other answers for inspiration, I switched to using the reverse Collatz function, generating the tree, and stopping after n iterations.</p>
<p>I discovered by experimenting, that the tree does not grow exponentially - although n*2 is always a hit, the (n-1)/3 path only hits occasionally. So by the time we get to n=30 we have about twice the number of integers that we want, but no more than that.</p>
<p>As a result, I put the sort and de-dup at the very end, and called it just once - this saves some execution time.</p>
<p>The sort is a merge sort - this makes it convenient to de-dup while merging.</p>
<p>The arithmetic operations required: divides-by-two? divides-by-three? and divide-by-three all had to be optimized - the naive implementations of these were too slow. To optimize, I created a list of powers of 2 and 3, and used these to make the operations faster.</p>
<h2>Testing</h2>
<p>My code has been tested and verified for n = 0,1,5,9,15 and 30. All are correct. n=30 runs in about 15 seconds on TIO.</p>
</div>
<div id="pu1" class="pu"><h1>CJam, <s>29</s> 26 bytes</h1>

<pre><code>Xari{{2*_Cmd8=*2*)}%1-}*$p
</code></pre>

<p><em>Credit goes to @isaacg for his idea to remove 1's after each iteration, which saved me two bytes directly and another one indirectly.</em></p>

<p>Try it online in the <a href="http://cjam.aditsu.net/#code=Xari%7B%7B2*_Cmd8%3D*2*)%7D%251-%7D*%24p&amp;input=30" rel="nofollow">CJam interpreter</a> (should finish in less than a second).</p>

<h3>How it works</h3>

<pre><code>Xa       e# Push A := [1].
ri{      e# Read an integer from STDIN and do the following that many times:
  {      e# For each N in A:
    2*   e#     Push I := (N * 2) twice.
    _Cmd e#     Push (I / 12) and (I % 12).
     8=  e#     Push K := (I % 12 == 8).

         e#     (K == 1) if and only if the division ((N - 1) / 3) is exact and
         e#     yields an odd integer. In this case we can compute the quotient 
         e#     as (I / 12) * 2 + 1.

    *2*) e#     Push J := (I / 12) * K * 2 + 1.

         e#     This yields ((N - 1) / 3) when appropriate and 1 otherwise.
  }%     e# Replace N with I and J.
  1-     e# Remove all 1's from A.

         e# This serves three purposes:

         e# 1. Ones have been added as dummy values for inappropriate quotients.

         e# 2. Not allowing 1's in A avoids integers that have already stopped
         e#    from beginning a new cycle. Since looping around has been prevented,
         e#    A now contains all integers of a fixed stopping time.

         e# 3. If A does not contain duplicates, since the maps N -&gt; I and N -&gt; J
         e#      are inyective (exluding image 1) and yield integers of different
         e#      parities, the updated A won't contain duplicates either.

}*       e#
$p       e# print(sort(C))
</code></pre>
</div>
<div id="pu2" class="pu"><h1>C Language</h1>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;    
const int s = 30;

bool f(long i)
{
    int r = 0;
    for(;;)
        if (i &lt; 0 || r &gt; s) return false;
        else if (i == 1) break;
        else{r ++;i = i % 2 ? 3*i + 1 : i/2;}
    return (r==s);
}

void main(){
    for(long i = 1; i &lt; LONG_MAX; i++) if (f(i)) printf(&quot;%ld &quot;, i);
}
</code></pre>
</div>
<div id="pu3" class="pu"><h1>Pyth, <s>26</s> <s>24</s> 21 bytes</h1>

<pre><code>Su+yMG-/R3fq4%T6G1Q]1
</code></pre>

<p>This code runs instantly for <code>S=30</code>. Try it out yourself: <a href="https://pyth.herokuapp.com/?code=Su-%2ByMG%2FR3fq4%25T6G1Q%5D1&amp;input=30&amp;debug=0" rel="nofollow">Demonstration</a></p>

<p>Thanks to @isaacg for saving 5 bytes. </p>

<h3>Explanation</h3>

<p>My code starts with <code>1</code> and undos the Collatz function. It maps all numbers <code>d</code> of the <code>S-1</code> step to <code>2*d</code> and <code>(d-1)/3</code>. The last one in not always valid though. </p>

<pre><code>                        implicit: Q = input number
                   ]1   start with G = [1]
 u                Q     apply the following function Q-times to G:
                          update G by
   yMG                      each number in G doubled
  +                       +
          fq4%T6G           filter G for numbers T, which satisfy 4==T%6
       /R3                  and divide them by 3
      -          1          and remove 1, if it is in the list
                            (to avoid jumping from 4 to 1)
S                       sort the result and print
</code></pre>
</div>
<div id="pu4" class="pu"><h1>Python 2, <s>86</s> <s>83</s> <s>75</s> <s>73</s> 71 bytes</h1>



<pre class="lang-py prettyprint-override"><code>f=lambda n,k=1:sorted([k][n:]or(k&gt;4==k%6and f(n-1,k/3)or[])+f(n-1,k*2))
</code></pre>

<p>Call like <code>f(30)</code>. <code>n = 30</code> is pretty much instant.</p>

<p><em>(Thanks to @DLosc for the idea of recursing by <code>k</code> being a number rather than a list of cousins, and a few bytes. Thank to @isaacg for dropping <code>~-</code>.)</em></p>

<p>This variant is much shorter, but unfortunately takes too long due to exponential branching:</p>

<pre class="lang-py prettyprint-override"><code>f=lambda n,k=1:sorted([k][n:]or(k&gt;4==k%6)*f(n-1,k/3)+f(n-1,k*2))
</code></pre>
</div>
<div id="pu5" class="pu"><h1>PHP 5.4+, 178 bytes</h1>

<p>The function</p>

<pre><code>function c($s,$v=1,$p=[],&amp;$r=[]){$p[]=$v;if(!$s--){return$r[$v][]=$p;}c($s,$v*2,$p,$r);is_int($b=($v-1)/3)&amp;!in_array($b,$p)&amp;$b%2?c($s,$b,$p,$r):0;ksort($r);return array_keys($r);}
</code></pre>

<p>Test &amp; Output</p>

<pre><code>echo "0 - ".implode(',',c(0)).PHP_EOL;
// 0 - 1
echo "1 - ".implode(',',c(1)).PHP_EOL;
// 1 - 2
echo "5 - ".implode(',',c(5)).PHP_EOL;
// 5 - 5,32
echo "9 - ".implode(',',c(9)).PHP_EOL;
// 9 - 12,13,80,84,85,512
echo "15 - ".implode(',',c(15)).PHP_EOL;
// 15 - 22,23,136,138,140,141,150,151,768,832,848,852,853,904,906,908,909,5120,5376,5440,5456,5460,5461,32768
</code></pre>

<p>S(30) runs in <strong>0.24 seconds*</strong>, returns 732 elements. A couple are </p>

<pre><code>86,87,89,520,522,524,525,528, [ ... ] ,178956928,178956960,178956968,178956970,1073741824
</code></pre>

<p>*To save on bytes, I had to add <code>ksort</code> and <code>array_keys</code> at every step. The only other choice I had was to make a small wrapper function that calls <code>c()</code> and then calls <code>array_keys</code> and <code>ksort</code> on the result once. But due to the time still being decently snappy, I decided to take the performance hit for low byte count. Without the proper sorting &amp; processing, the time is <strong>0.07 seconds</strong> on average for S(30).</p>

<p>If anyone has any clever ways of getting the proper processing only once without too many additional bytes, please let me know!  (I store my numbers as array keys, hence the use of <code>array_keys</code> and <code>ksort</code>)</p>
</div>
<div id="pu6" class="pu"><h1>Python 2, 118 bytes</h1>

<p>Well, I figured that I wouldn't reach the best Python score after seeing @Sp3000's solution. But it looked like a fun little problem, so I wanted to try an independent solution anyway:</p>



<pre class="lang-python prettyprint-override"><code>s={1}
for k in range(input()):
 p,s=s,set()
 for t in p:s.add(2*t);t&gt;4and(t-1)%6==3and s.add((t-1)/3)
print sorted(s)
</code></pre>

<p>Same thing before stripping whitespace:</p>



<pre class="lang-python prettyprint-override"><code>s={1}
for k in range(input()):
    p,s=s,set()
    for t in p:
        s.add(2 * t)
        t &gt; 4 and (t - 1) % 6 == 3 and s.add((t - 1) / 3)
print sorted(s)
</code></pre>

<p>This is a very direct implementation of a breadth first search. In each step, we have the set with stopping time <code>k</code>, and derive the set with stopping time <code>k + 1</code> by adding the possible predecessors of each value <code>t</code> in the set from step <code>k</code>:</p>

<ul>
<li><code>2 * t</code> is always a possible predecessor.</li>
<li>If <code>t</code> can be written as <code>3 * u + 1</code>, where <code>u</code> is an odd number that is not <code>1</code>, then <code>u</code> is a predecessor as well.</li>
</ul>

<p>Takes about 0.02 seconds to run for <code>N = 30</code> on my MacBook Pro.</p>
</div>
<div id="pu7" class="pu"><h1>Mathematica, <s>98</s> <s>92</s> 89 bytes</h1>

<p>This solution solves <code>S = 30</code> immediately:</p>

<pre><code>(p={0};l={1};Do[l=Complement[##&amp;@@{2#,Mod[a=#-1,2]#~Mod~3~Mod~2a/3}&amp;/@l,p=p⋃l],{#}];l)&amp;
</code></pre>

<p>This is an unnamed function taking <code>S</code> as its only parameter and returning a list of the Collatz cousins.</p>

<p>The algorithm is a simple breadth-first search. The Collatz cousins for a given <code>S</code> are all the integers that can be reached from the Collatz cousins for <code>S-1</code> via <code>2*n</code> or odd numbers that can be reached via <code>(n-1)/3</code>. We also need to ensure that we only produce those integers which were reached for the <em>first time</em> after <code>S</code> steps, so we keep track of all previous cousins in <code>p</code> and remove those from the result. Since we're doing that anyway, we can save a few bytes by computing the steps from <em>all</em> previous cousins (not just those from <code>S-1</code>) to save a few bytes (that makes it slightly slower, but not noticeably for the required <code>S</code>).</p>

<p>Here is a slightly more readable version:</p>

<pre><code>(
  p = {0};
  l = {1};
  Do[
    l = Complement[
      ## &amp; @@ {2 #, Mod[a = # - 1, 2] #~Mod~3~Mod~2 a/3} &amp; /@ l,
      p = p ⋃ l
    ]~Cases~_Integer,
    {#}
  ];
  l
) &amp;
</code></pre>
</div>
<div id="pu8" class="pu"><h1>Java 8, 123</h1>

<pre><code>x-&gt;java.util.stream.LongStream.range(1,(1&lt;&lt;x)+1).filter(i-&gt;{int n=0;for(;i&gt;1;n++)i=i%2&lt;1?i/2:3*i+1;return n==x;}).toArray()
</code></pre>

<p>When <code>x</code> is 30, the program takes 15 minutes and 29 seconds.</p>

<h2>Expanded</h2>

<pre><code>class Collatz {
    static IntFunction&lt;long[]&gt; f =
            x -&gt; java.util.stream.LongStream.range(1, (1 &lt;&lt; x) + 1).filter(i -&gt; {
                int n = 0;
                for (; i &gt; 1; n++)
                    i = i % 2 &lt; 1 ? i / 2 : 3 * i + 1;
                return n == x;
            }).toArray();

    public static void main(String[] args) {
        System.out.println(Arrays.toString(f.apply(15)));
    }
}
</code></pre>
</div>
<div id="pu9" class="pu"><h1>CJam, 35 bytes</h1>

<pre><code>1]ri{_"(Z/Y*"3/m*:s:~\L+:L-_&amp;0-}*$p
</code></pre>

<p>Explanation coming soon. This is a much faster version than the "pretty straight forward" approach (see it in edit history).</p>

<p><a href="http://cjam.aditsu.net/#code=1%5Dri%7B_%22(Z%2FY*%223%2Fm*%3As%3A~%5CL%2B%3AL-_%260-%7D*%24p&amp;input=25" rel="nofollow">Try it online here</a> for <code>N = 30</code> which runs in seconds on the online version and instantly in the <a href="http://sourceforge.net/p/cjam/wiki/" rel="nofollow">Java Compiler</a></p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/50926/">50926</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




