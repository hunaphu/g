<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::65895</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>046</td><td>TIBASIC TI84 Plus CE Python</td><td>250819T133301Z</td><td><a href="https://codegolf.stackexchange.com/questions/65895/hilbert-primes-golf/283209#283209">madeforl</a></td></tr>
<tr d-ix="1"><td>060</td><td>APLNARS</td><td>250318T193229Z</td><td><a href="https://codegolf.stackexchange.com/questions/65895/hilbert-primes-golf/278754#278754">Rosario</a></td></tr>
<tr d-ix="2"><td>093</td><td>AWK</td><td>250318T141334Z</td><td><a href="https://codegolf.stackexchange.com/questions/65895/hilbert-primes-golf/278747#278747">xrs</a></td></tr>
<tr d-ix="3"><td>054</td><td>JavaScript</td><td>230306T094133Z</td><td><a href="https://codegolf.stackexchange.com/questions/65895/hilbert-primes-golf/258859#258859">Shaggy</a></td></tr>
<tr d-ix="4"><td>035</td><td>Raku</td><td>230307T160652Z</td><td><a href="https://codegolf.stackexchange.com/questions/65895/hilbert-primes-golf/258911#258911">Sean</a></td></tr>
<tr d-ix="5"><td>080</td><td>Python</td><td>230307T183817Z</td><td><a href="https://codegolf.stackexchange.com/questions/65895/hilbert-primes-golf/258917#258917">97.100.9</a></td></tr>
<tr d-ix="6"><td>056</td><td>Perl 5 p</td><td>201222T015915Z</td><td><a href="https://codegolf.stackexchange.com/questions/65895/hilbert-primes-golf/216733#216733">Xcali</a></td></tr>
<tr d-ix="7"><td>015</td><td>Jelly</td><td>200913T010234Z</td><td><a href="https://codegolf.stackexchange.com/questions/65895/hilbert-primes-golf/211001#211001">caird co</a></td></tr>
<tr d-ix="8"><td>008</td><td>Husk</td><td>200913T071910Z</td><td><a href="https://codegolf.stackexchange.com/questions/65895/hilbert-primes-golf/211006#211006">Zgarb</a></td></tr>
<tr d-ix="9"><td>023</td><td>CJam</td><td>151207T062222Z</td><td><a href="https://codegolf.stackexchange.com/questions/65895/hilbert-primes-golf/65912#65912">Reto Kor</a></td></tr>
<tr d-ix="10"><td>073</td><td>Julia</td><td>151207T210710Z</td><td><a href="https://codegolf.stackexchange.com/questions/65895/hilbert-primes-golf/65972#65972">Andrew</a></td></tr>
<tr d-ix="11"><td>074</td><td>Matlab</td><td>151207T200326Z</td><td><a href="https://codegolf.stackexchange.com/questions/65895/hilbert-primes-golf/65965#65965">Luis Men</a></td></tr>
<tr d-ix="12"><td>073</td><td>JavaScript ES6</td><td>151208T043026Z</td><td><a href="https://codegolf.stackexchange.com/questions/65895/hilbert-primes-golf/66000#66000">n̴̖̋h̷͉̃</a></td></tr>
<tr d-ix="13"><td>060</td><td>Ruby</td><td>151207T172941Z</td><td><a href="https://codegolf.stackexchange.com/questions/65895/hilbert-primes-golf/65954#65954">MegaTom</a></td></tr>
<tr d-ix="14"><td>021</td><td>Pyth</td><td>151207T133049Z</td><td><a href="https://codegolf.stackexchange.com/questions/65895/hilbert-primes-golf/65936#65936">Jakube</a></td></tr>
<tr d-ix="15"><td>065</td><td>Mathematica</td><td>151207T124016Z</td><td><a href="https://codegolf.stackexchange.com/questions/65895/hilbert-primes-golf/65934#65934">LegionMa</a></td></tr>
<tr d-ix="16"><td>032</td><td>Minkolang 0.14</td><td>151207T060220Z</td><td><a href="https://codegolf.stackexchange.com/questions/65895/hilbert-primes-golf/65909#65909">El&#39;e</a></td></tr>
<tr d-ix="17"><td>046</td><td>Haskell</td><td>151207T053257Z</td><td><a href="https://codegolf.stackexchange.com/questions/65895/hilbert-primes-golf/65905#65905">xnor</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>TI-BASIC (TI-84 Plus CE Python), <s>61</s> 46 bytes</h1>
<pre><code>Input G
For(I,1,ᴇ5
If 2=sum(not(remainder(4I+1,seq(4N+1,N,0,I
DS&lt;(G,1
End
1+4I
</code></pre>
<p>gets crazily slower when you up the number</p>
</div>
<div id="pu1" class="pu"><h1>APL(NARS), 60 chars</h1>
<pre><code>r←f w;c;a
c←¯1⋄a←⍬⋄r←5⋄→3
→2×⍳∨/0=a∣r+←4
a,←r⋄→0×⍳w≤c+←1⋄→2
</code></pre>
<p>//10+16+15+19 = 60.<br />
Input a not negative integer.
Test:</p>
<pre><code>  f¨0..10
┌11─────────────────────────────┐
│ 5 9 13 17 21 29 33 37 41 49 53│
└~──────────────────────────────┘
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.gnu.org/software/gawk/" rel="nofollow noreferrer">AWK</a>, 93 bytes</h1>
<pre><code>{for(i=5;i&lt;$1^2;i+=4)b[++x]=i;for(;++j&amp;&amp;y&lt;$1;b[j]==b[k]&amp;&amp;y++)for(k=0;b[j]%b[++k];);}$0=b[j-1]
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m704sTx7wYKlpSVpuhY3Y6vT8os0Mm1NrTNtVAzjjKwztW1NNJOitbUrYm0zrUGS1traWWpqlUBp66TorFhb26To7FiggLa2Jkg629YALK4K0pQda61pXatiAFSTpWsYC7EEateCRYYGEBYA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<pre><code>{for(i=5;i&lt;$1^2;i+=4)    # input squared for sufficiently long list
b[++x]=i;                # create array of hits
for(;++j                 # traverse array
&amp;&amp;y&lt;$1;                  # until we reach our prime
b[j]==b[k]&amp;&amp;y++)         # if prime, increment y
for(k=0;b[j]%b[++k];);}  # primality test
$0=b[j-1]                # set output
</code></pre>
</div>
<div id="pu3" class="pu"><h1>JavaScript, <s>59</s> <s>58</s> 54 bytes</h1>
<p>0-indexed and based on the (possibly erroneous?) observation that, just as all composite numbers are divisible by at least one prime, all <em>Hilbert</em> composites are also divisible by at least one Hilbert prime.</p>
<p>Here's <a href="https://tio.run/##ZY9PT4QwEMXvfIrxsEkr2mU3HryUBLRqE/5soG6yMR4Qa1IXWNKyJHx67AqGg3OZ5M3M7735LvrClFq13W1/P47rNTyzhGWBYPDEs1zA1jvCC49ClglIXmPbc/A3TnOuP6Q29I0QEmhdDGjr2cLkKAeD8DupixYp6t9du65yN9hxftECdhmPWe60WtXS0BlDvlTVSY1Qc6Mw9f9UU6lSIs9qRPZSDyixs1WCF9pDGu/SnAtLLE91ezKq@09tqH81@RHVlNX5UxrUzBB7KYDtWXZYWMBzeOR7nvMwYhAeIBAQscAupgmbHrjkbzq0eM4By8VqElrql6sWYzyOPw" rel="nofollow noreferrer">a limited proof</a> of that using the first 20000 Hilbert numbers.</p>
<p>We handle the edge case of <code>1</code> being neither prime nor composite below by hardcoding <code>5</code> as our stating point.</p>

<pre class="lang-javascript prettyprint-override"><code>a=[x=5];f=n=&gt;a[a.every(y=&gt;x%y,x+=4)?a.push(x):n]||f(n)
</code></pre>
<p><a href="https://tio.run/##DcNRCsIwDADQ0wgJan62gSjZ8BylH0FanGIp6SwN7O7VB@8lVcpD17yd66VH7sKu8eRvkRPP4oRCDWpgPLeDndqRR1yE8rc8oeE1@X2PkLBnXdMGROT@76piMExI72AF0NNHMkTE/gM" rel="nofollow noreferrer">Try it online!</a></p>
<h2>Explanation</h2>
<p>We initialise an array <code>a=[5]</code>, which will hold the Hilbert primes, and an integer <code>x=5</code>, which we'll use as a temporary variable for the Hilbert numbers, outside the main function. Usually this wouldn't be possible because our rules require that everything be reusable by successive function calls, but here on each successive call of the function <code>a[n]</code> will either exist and be immediately returned or we'll resume building the array of primes from where we left off on the last call and continue until it does exist.</p>
<p><code>f</code>, then, is our recursive function taking input via parameter <code>n</code>. On each iteration we increment <code>x</code> by <code>4</code> and then check that, for each existing prime <code>y</code> in <code>a</code>, <code>x%y&gt;0</code>.</p>
<p>If it is then we <code>push</code> the new value of <code>x</code> to <code>a</code>, which returns the updated length of <code>a</code>. We use that to index into <code>a</code> but, as JavaScript uses 0-based indexing, <code>a[a.length]</code> will always return <code>undefined</code>, which is falsey, so we fall through the logical <code>OR</code> to execute a recursive call to <code>f(n)</code> and continue to do so until we encounter a Hilbert composite (i.e., for at least one <code>y</code> in <code>a</code>, <code>x%y===0</code>).</p>
<p>When we do encounter a composite we instead index <code>n</code> into <code>a</code> and, if it exists, return that value, or continue recursing until the next composite if it doesn't.</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://raku.org/" rel="nofollow noreferrer">Raku</a>, 35 bytes</h1>
<pre><code>grep {$_%%none 5,9...^$_},(5,9...*)
</code></pre>
<p><a href="https://tio.run/##K0gtyjH7n1up4JChYPs/vSi1QKFaJV5VNS8/L1XBVMdST08vTiW@VkcDwtbS/G@tUJwIUh4dZ2wa@x8A" rel="nofollow noreferrer" title="Perl 6 – Try It Online">Try it online!</a></p>
<p>This is an expression for the lazy, infinite list of Hilbert primes.</p>
<ul>
<li><code>5, 9 ... *</code> is the infinite list of Hilbert numbers.  (Raku infers that it's an arithmetic sequence from the first two elements.)</li>
<li><code>grep { $_ %% none 5, 9 ...^ $_ }</code> filters that list to those which are divisible (<code>%%</code>) by <code>none</code> of the Hilbert numbers up to, but not including (<code>...^</code>), the number being tested.</li>
</ul>
</div>
<div id="pu5" class="pu"><h1><a href="https://www.python.org" rel="nofollow noreferrer">Python</a>, 80 bytes</h1>
<pre class="lang-python prettyprint-override"><code>f=lambda I,i=0,H=[2]:(i&gt;I)*H[0]or f(I,i+all((p:=4*len(H)+1)%h for h in H),[p]+H)
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m72soLIkIz9vwYKlpSVpuhY3A9JscxJzk1ISFTx1Mm0NdDxso41irTQy7Tw1tTyiDWLzixTSNIBS2ok5ORoaBVa2Jlo5qXkaHprahpqqGQppQPkMhcw8BQ9NneiCWG0PTYi5-0ASmSCJosS89FQNUwNNq4KizLwSjTSNTE2oIpgjAA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>0-indexed (but it would be trivial to change to be 1-indexed). Stores the previous Hilbert numbers in <code>H</code>, and stores how many Hilbert  primes have been found so far in <code>i</code>.</p>
</div>
<div id="pu6" class="pu"><h1><a href="https://www.perl.org/" rel="nofollow noreferrer">Perl 5</a> <code>-p</code>, 56 bytes</h1>

<pre class="lang-perl prettyprint-override"><code>$k=$.+=4;1while($k-=4)&gt;1&amp;&amp;$.%$k;($k&gt;1||--$_)&amp;&amp;redo;$_=$.
</code></pre>
<p><a href="https://tio.run/##K0gtyjH9/18l21ZFT9vWxNqwPCMzJ1VDJVvX1kTTzlBNTUVPVSXbGihgZ1hTo6urEq@pplaUmpJvrRIP1PL/v9m//IKSzPy84v@6BQA" rel="nofollow noreferrer" title="Perl 5 – Try It Online">Try it online!</a></p>
</div>
<div id="pu7" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, <s>17</s> 15 bytes</h1>
<pre><code>ŻḤḤ‘ḍḍiɗċ1=2µ#Ṫ
</code></pre>
<p><a href="https://tio.run/##y0rNyan8H/RwxxIgetQwI/Pw9Ic7eo@1nwRSrYaHtiqbGgTpHG5XedS05uikhztncAHVgFQ2rYGoT3WIB6o/Of1It4EtSPnDnav@H90NNw4oB0SZIHlDWyOo/H9DAwA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p>Uses 1-indexing (e.g. <code>1 -&gt; 5, 2 -&gt; 9, etc.</code>), allowed by default on <a href="/questions/tagged/sequence" class="post-tag" title="show questions tagged &#39;sequence&#39;" rel="tag">sequence</a> challenges.</p>
<h2>How it works</h2>
<pre><code>ŻḤḤ‘ḍḍiɗċ1=2µ#Ṫ - Main link. Takes n via STDIN
            µ#  - Execute the following on integers k = 1, 2, 3, ... until n integers return True:
Ż               -   Yield [0, 1, 2, ..., k]
 Ḥ              -   Unhalve; [0, 2, 4, ..., 2k]
  Ḥ             -   Unhalve; [0, 4, 8, ..., 4k]
   ‘            -   Increment; [1, 5, 9, ..., 4k+1]
       ɗ        -   Group the previous three links into a dyad.
                    Use l = [1, 5, ..., 4k+1] on the left and k on the right:
    ḍ           -     Each element in l is divisible by k?
      i         -     Index of k in l or 0?
     ḍ          -     1 or 0 is divisible by the index?
                    This yields a list with 2 1s for Hilbert primes
        ċ1      -   Count 1s
          =2    -   Equals 2?
              Ṫ - Take the last one i.e. the nth Hilbert prime
</code></pre>
</div>
<div id="pu8" class="pu"><h1><a href="https://github.com/barbuz/Husk" rel="nofollow noreferrer">Husk</a>, 8 bytes</h1>
<pre><code>!ü¦¡+4 5
</code></pre>
<p><a href="https://tio.run/##yygtzv7/X/HwnkPLDi3UNlEw/f//v4kZAA" rel="nofollow noreferrer" title="Husk – Try It Online">Try it online!</a>
Uses 1-based indexing.</p>
<h2>Explanation</h2>
<pre><code>!ü¦¡+4 5   Implicit input n.
   ¡       Iterate
    +4     addition of 4
       5   starting from 5: [5,9,13,17,..]
 ü         Uniquify by
  ¦        divisibility.
!          Get nth element.
</code></pre>
<p>Most of the work is done by <code>ü¦</code>.
The function <code>ü</code>, when given a binary function <code>f</code> and a list, greedily constructs a subsequence where <code>f x y</code> is falsy for every (not necessarily adjacent) pair of elements <code>x, y</code>.
In this case it picks a number if it's not divisible by any earlier pick.
Then we just index into the resulting infinite list.</p>
</div>
<div id="pu9" class="pu"><h1>CJam, <s>36</s> <s>33</s> <s>32</s> 23 bytes</h1>

<pre><code>5ri{_L+:L;{4+_Lf%0&amp;}g}*
</code></pre>

<p><a href="http://cjam.aditsu.net/#code=5ri%7B_L%2B%3AL%3B%7B4%2B_Lf%250%26%7Dg%7D*&amp;input=20" rel="nofollow">Try it online</a></p>

<p>The latest version is actually much more @MartinBüttner's than mine. The key idea in his suggested solution is to use two nested loops to find the n-th value that meets the condition. I thought I was being clever by using only a single loop in my original solution, but it turns out that the added logic cost more than I saved by not using a second loop.</p>

<p>Explanation</p>

<pre><code>5       Push first Hilbert prime.
ri      Get input n and convert to integer.
{       Loop n times.
  _       Push a copy of current Hilbert prime.
  L       Push list of Hilbert primes found so far (L defaults to empty list).
  +       Prepend current Hilbert prime to list.
  :L      Store new list of Hilbert primes in variable L.
  ;       Pop list off stack.
  {       Start while loop for finding next Hilbert prime.
    4+      Add 4 to get next Hilbert number.
    _       Copy candidate Hilbert number.
    L       Push list of Hilbert primes found so far.
    f%      Element wise modulo of Hilbert number with smaller Hilbert primes.
    0&amp;      Check for 0 in list of modulo values.
  }g      End while loop.
}*      End loop n times.
</code></pre>
</div>
<div id="pu10" class="pu"><h1>Julia, 73 bytes</h1>

<pre><code>n-&gt;(a=[x=5];while length(a)&lt;n;x+=4;all(k-&gt;mod(x,k)&gt;0,a)&amp;&amp;push!(a,x)end;x)
</code></pre>

<p>Thanks Alex A. for saving 11 bytes! This uses the same algorithm as the Matlab and Ruby answers. Since Julia arrays are one-indexed, this starts with <code>f(1) == 5</code>.</p>

<p>My first attempt, using the Lazy package, is <strong>106 bytes</strong>. If you plan to run this in the REPL, make sure to add semicolons to the ends of the lines to suppress the infinite output. And call <code>Pkg.Add("Lazy")</code> if you don't already have it installed.</p>

<pre><code>using Lazy
r=range
h=r(1,Inf,4)
p=@&gt;&gt;r() filter(n-&gt;n!=1&amp;&amp;all(map(x-&gt;mod(h[n],h[x])&lt;1,2:n-1)))
f=n-&gt;h[p[n]]
</code></pre>
</div>
<div id="pu11" class="pu"><h1>Matlab, 74 <s>83</s> bytes</h1>

<pre><code>function t=H(n)
x=5;t=x;while nnz(x)&lt;n
t=t+4;x=[x t(1:+all(mod(t,x)))];end
</code></pre>

<p>Thanks to Tom Carpenter for removing 9 bytes!</p>

<p>Example use:</p>

<pre><code>&gt;&gt; H(20)
ans =
   101
</code></pre>
</div>
<div id="pu12" class="pu"><h1>JavaScript (ES6), 73 bytes</h1>

<pre><code>n=&gt;{for(i=0,t=2;i&lt;=n;)i+=!/^(.(....)+)\1+$/.test(Array(t+=4));return t-1}
</code></pre>

<p>Just check Hilbert numbers one by one until we reach the nth Hilbert prime. Divisibility by Hilbert number is handled by regex.</p>
</div>
<div id="pu13" class="pu"><h1>Ruby, 60 bytes</h1>
<pre><code>h=-&gt;i{n=[];x=5;n.any?{|r|x%r&lt;1}?x+=4: n&lt;&lt;x until e=n[i-1];e}
</code></pre>
<p>Only checks Hilbert prime factors.</p>
</div>
<div id="pu14" class="pu"><h1>Pyth, 21 bytes</h1>

<pre><code>Lh*4bye.fqZf!%yZyT1hQ
</code></pre>

<p>Try it online: <a href="http://pyth.herokuapp.com/?test_suite_input=0%0A1%0A2%0A3%0A4%0A5%0A6%0A7&amp;input=6&amp;code=Lh%2A4bye.fqZf%21%25yZyT1hQ&amp;test_suite=0" rel="nofollow">Demonstration</a> or <a href="http://pyth.herokuapp.com/?test_suite_input=0%0A1%0A2%0A3%0A4%0A5%0A6%0A7&amp;input=6&amp;code=Lh%2A4bye.fqZf%21%25yZyT1hQ&amp;test_suite=1" rel="nofollow">Test Suite</a></p>

<h3>Explanation:</h3>

<pre><code>Lh*4bye.fqZf!%yZyT1Q    implicit: Q = input number
L                       define a function y(b), which returns
 h*4b                      4*b + 1
                        this converts a index to its Hilbert number
       .f          hQ   find the first (Q+1) numbers Z &gt;= 1, which satisfy:
           f      1        find the first number T &gt;= 1, which satisfies:
            !%yZyT            y(Z) mod y(T) == 0
         qZ                test if the result is equal to Z 

                        this gives a list of indices of the first Q Hilbert Primes
      e                 take the last index
     y                  apply y and print
</code></pre>
</div>
<div id="pu15" class="pu"><h2>Mathematica, 65 bytes</h2>

<pre><code>Select[4Range[4^9]+1,Divisors[#][[2;;-2]]~Mod~4~FreeQ~1&amp;][[#+1]]&amp;
</code></pre>

<p>Generates the entire list and selects the element from it.</p>
</div>
<div id="pu16" class="pu"><h2><a href="https://github.com/elendiastarman/Minkolang" rel="nofollow noreferrer">Minkolang 0.14</a>, <s>46</s> <s>37</s> 32 bytes</h2>
<p>I didn't realize that the gosub was totally unnecessary... &gt;_&gt;</p>
<pre><code>n$z(xxi4*5+d(4-$d%)1=,z+$ziz-)N.
</code></pre>
<p><a href="http://play.starmaninnovations.com/minkolang/?code=n%24z%28xxi4*5%2Bd%284-%24d%25%291%3D%2Cz%2B%24ziz-%29N%2E&amp;input=9" rel="nofollow noreferrer">Try it here</a> and <a href="http://play.starmaninnovations.com/minkolang/?code=57*%5Bi%24z%28xxi4*5%2Bd(4-%24d%25%291%3D%2Cz%2B%24ziz-)6Z%22Mine%3A%20%22%24Oln6Z%22%2C%20Mego%3A%20%22%24O%5D%2E&amp;input=5%2C%209%2C%2013%2C%2017%2C%2021%2C%2029%2C%2033%2C%2037%2C%2041%2C%2049%2C%2053%2C%2057%2C%2061%2C%2069%2C%2073%2C%2077%2C%2089%2C%2093%2C%2097%2C%20101%2C%20109%2C%20113%2C%20121%2C%20129%2C%20133%2C%20137%2C%20141%2C%20149%2C%20157%2C%20161%2C%20173%2C%20177%2C%20181%2C%20193%2C%20197" rel="nofollow noreferrer">check all test cases here</a>.</p>
<h3>Explanation</h3>
<pre><code>n$z                                 Take number from input and store it in the register
   (                                Open while loop
    xx                              Dump the stack
      i4*5+                         Loop counter times 4 plus 5 (Hilbert number)
           d                        Duplicate
            (                       Open while loop
             4-                     Subtract 4
               $d                   Duplicate stack
                 %                  Modulo
                  )                 Exit while loop when top of stack is 0
                   1=,              0 if 1, 1 otherwise
                      z             Push register value
                       +            Add
                        $z          Pop and store in register
                          iz-       Subtract z from loop counter
                             )      Exit while loop when top of stack is 0
                              N.    Output as number and stop.
</code></pre>
<p>The register is used to store the target index. The outer while loop calculates each Hilbert number and does some bookkeeping. The inner while loop checks each Hilbert number for primality. If a Hilbert number is <em>not</em> a Hilbert prime, then the target is incremented so that the outer while loop has to repeat (at least) one more time, effectively skipping Hilbert composites.</p>
</div>
<div id="pu17" class="pu"><h2>Haskell, 46 bytes</h2>

<pre class="lang-haskell prettyprint-override"><code>(foldr(\a b-&gt;a:[x|x&lt;-b,mod x a&gt;0])[][5,9..]!!)
</code></pre>
<p>An anonymous function.</p>
<p>The core is <code>foldr(\a b-&gt;a:[x|x&lt;-b,mod x a&gt;0])[][5,9..]</code>, which iterates through the arithmetic progression <code>5,9,13,...</code>, removing multiples of each one from the list to its right. This produces the infinite list of Hilbert primes. Then, <code>!!</code> takes the <code>n</code>th element.</p>
<p>I has tried making <code>(\a b-&gt;a:[x|x&lt;-b,mod x a&gt;0])</code> pointfree but didn't find a shorter way.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/65895/">65895</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




