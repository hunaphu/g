<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::26505</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>042</td><td>Vyxal 3</td><td>250616T215810Z</td><td><a href="https://codegolf.stackexchange.com/questions/26505/determine-if-a-move-exists-in-a-bejeweled-match-3-game/282308#282308">pacman25</a></td></tr>
<tr d-ix="1"><td>051</td><td>05AB1E</td><td>200525T162842Z</td><td><a href="https://codegolf.stackexchange.com/questions/26505/determine-if-a-move-exists-in-a-bejeweled-match-3-game/205238#205238">Kevin Cr</a></td></tr>
<tr d-ix="2"><td>071</td><td>APL Dyalog Unicode</td><td>200525T061235Z</td><td><a href="https://codegolf.stackexchange.com/questions/26505/determine-if-a-move-exists-in-a-bejeweled-match-3-game/205227#205227">Bubbler</a></td></tr>
<tr d-ix="3"><td>201</td><td>Ruby</td><td>160818T214306Z</td><td><a href="https://codegolf.stackexchange.com/questions/26505/determine-if-a-move-exists-in-a-bejeweled-match-3-game/90276#90276">Jordan</a></td></tr>
<tr d-ix="4"><td>085</td><td>Perl</td><td>160422T103509Z</td><td><a href="https://codegolf.stackexchange.com/questions/26505/determine-if-a-move-exists-in-a-bejeweled-match-3-game/78250#78250">Ton Hosp</a></td></tr>
<tr d-ix="5"><td>153</td><td>Original Solution JavaScript   153 Characters</td><td>140502T115734Z</td><td><a href="https://codegolf.stackexchange.com/questions/26505/determine-if-a-move-exists-in-a-bejeweled-match-3-game/26512#26512">MT0</a></td></tr>
<tr d-ix="6"><td>nan</td><td></td><td>140503T015030Z</td><td><a href="https://codegolf.stackexchange.com/questions/26505/determine-if-a-move-exists-in-a-bejeweled-match-3-game/26531#26531">alyx-bre</a></td></tr>
<tr d-ix="7"><td>905</td><td>Node.js  Naive solution</td><td>140502T050224Z</td><td><a href="https://codegolf.stackexchange.com/questions/26505/determine-if-a-move-exists-in-a-bejeweled-match-3-game/26508#26508">DankMeme</a></td></tr>
<tr d-ix="8"><td>314</td><td>Python3</td><td>140502T084503Z</td><td><a href="https://codegolf.stackexchange.com/questions/26505/determine-if-a-move-exists-in-a-bejeweled-match-3-game/26509#26509">alyx-bre</a></td></tr>
<tr d-ix="9"><td>383</td><td>Python</td><td>140502T045214Z</td><td><a href="https://codegolf.stackexchange.com/questions/26505/determine-if-a-move-exists-in-a-bejeweled-match-3-game/26507#26507">KSab</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal/tree/version-3/" rel="nofollow noreferrer">Vyxal 3</a>, 42 bytes</h1>
<pre><code>e¨f:T;∦ƛ③foƛ£hƛ¥$¨cA]ƛ14fo⎘¨⊞3≥]fG&quot;∦⦰MD”⌈i
</code></pre>
<p><a href="https://vyxal.github.io/latest.html#H4sIAAAAAAAACjWPsUoDQRCGX0UGyyM4OzM7cFaCkMrOLntFSG5NQHfDJbERwTKKCHZC0EJJSOkzXJEH2Sdxz5Bm5meY__tnHsDH5m64gJIKmNTDcd1ACVDAKI7rrOp258vr87Ta7tfp_dvH_br9meSyOW13o4tqv0b2Mb19tLv08kXpeVP5voO8n7a_V5fp6TO9rqaZ52NcHNn-dngzh3JQFTANs-Wi0wPoN3E5O0EoBoCGkJHQBSRjGFlcEFZrrJILFhWtlX9FjMjsgiEWUu2UWhY21gUVUbFioaqKI950eBJjUbhbsWxQJdtQlMlojrQGSfLchdxQD0GcQfmA7gw2ag4OSxkiGZ8fua-b-TSG_CD1tHcGj38rlKDHWgEAAA" rel="nofollow noreferrer">Vyxal It Online!</a></p>
<p>Same idea as the APL answer but structured differently</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 51 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>„€¸…Ü#|€S2FÐ€ü3ø€ü2s€ü4«sø}\«€`ʒÐg;iøćδåøPàë¢3å]gĀè
</code></pre>
<p>Port of the approach used by <a href="https://codegolf.stackexchange.com/a/205227/52210"><em>@Bubbler</em> in his APL answer</a>, so make sure to upvote him!!</p>
<p><a href="https://tio.run/##HcetCsJQGIDhfm7DK/h@T7CbBauCCjKWDKsKw2IdZhERJsKMhhNM51syeBG7keNcep93W6zW@Salrrx0h2cMXXm382jXe4YTq/ramywMxWIIx6awsJ/Hpt/l52RVNs4ttMfvy2oLU7taE29k9SJrS3ukBEjAQOCAEBlYnLBXVE9OwYOq/EEMwOyQWMj7Hl5ZGNV5ES8q@gM" rel="nofollow noreferrer">Try it online.</a></p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>„€¸…Ü                 # Push dictionary string &quot;no yes&quot;
     #                # Split it on spaces: [&quot;no&quot;,&quot;yes&quot;]
|                     # Push all input-lines as list
 €S                   # Convert each line to a list of digits
   2F                 # Loop 2 times:
     Ð                #  Triplicate the matrix
      €               #  For each row:
       ü3             #   Create overlapping triplets
         ø            #  Zip/transpose; swapping rows/columns
          €           #  For each overlapping 3-sized column:
           ü2         #   Create overlapping pairs
     s                #  Swap to get the initial matrix again
      €               #  For each row:
       ü4             #   Create overlapping quadruplets
         «            #  Merge this list of 4x1 blocks to the list of 2x3 blocks
     s                #  Swap again to get the initial matrix
      ø               #  Zip/transpose; swapping rows/columns
    }\                # After the loop: discard the top item
      «               # Merge the two lists together
       €`             # Flatten it one level down
         ʒ            # Filter this list of 4x1 and 2x3 blocks by:
          Ð           #  Triplicate the block
           g          #  Get its length (either 4 or 2)
            ;i        #  If this length is 2:
              ø       #   Zip/transpose; swapping rows/columns,
                      #   to make the 2x3 block a 3x2 block
               ć      #   Extract head; pop and push the remainder 2x2 columns and
                      #   first 2x1 column separated to the stack
                δ     #   Apply double-vectorized:
                 å    #    Check if the value is in the list
                  ø   #   Zip/transpose; swapping rows/columns,
                      #   so the checks per value are in the same inner list
                   P  #   Check for both lists whether all checks were truthy
                    à #   And check if either of the two checks is truthy
             ë        #  Else (the length is 4 instead):
              ¢       #   Count how many times each value occurs in the 4x1 block
               3å     #   And check if the counts contain a 3
         ]            # Close both the if-else statement and filter
          g           # Get the amount of remaining blocks
           Ā          # Check that at least one block is remaining
                      # (1 if truthy; 0 if falsey)
            è         # And use that to index into the [&quot;no&quot;,&quot;yes&quot;] list
                      # (after which the result is output implicitly)
</code></pre>
<p><a href="https://codegolf.stackexchange.com/a/166851/52210">See this 05AB1E tip of mine (section <em>How to use the dictionary?</em>)</a> to understand why <code>„€¸…Ü</code> is <code>&quot;no yes&quot;</code>.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.dyalog.com/" rel="nofollow noreferrer">APL (Dyalog Unicode)</a>, 71 <a href="https://github.com/abrudz/SBCS" rel="nofollow noreferrer">bytes</a></h1>



<pre class="lang-apl prettyprint-override"><code>'no' 'yes'⊃⍨{∨/∊{((3≤1⊥⊃=⊢)¨4,/⍵)({∨⌿∧⌿∨⌿⍵∘.=⊣/⍵}⌺2 3⊢⍵)}¨⍵(⍉⍵)}↑{⍞}¨⍳8
</code></pre>

<p><a href="https://tio.run/##HY49TsNAEIVr9hTp7EhAmH8aDkDFGSJBaCKCRBVZqZCCY8UICiQqCn6Ee5SGBilHmYuY8Ta7b95@781Ob@dHl8vpfHHd@@PL@YWvn06S1w@zvrhZFKNieXVXeHPvbVd53U28bqqyJN98gjdf8XDmzft43/HhxNvduBwg3/55/Z3PrNud16/HAX4MzMq3vziiiA2B1b6Lq/R2kydfP1fevmX357SPf/QHswRIwECQgBAZWJKwKapRUjBQlUEQAzAnJBYyC2HKwqjJRExUNEUVCSoIh6mMYMIJxJjQICkCSbjBRGvu5IjFpljHaJhhpUjLPw" rel="nofollow noreferrer" title="APL (Dyalog Unicode) – Try It Online">Try it online!</a></p>

<p>Nice challenge to show off some extreme array-processing capabilities of APL.</p>

<p>Without the I/O restriction, it is <strong><s>55</s> 52 bytes</strong> as a function taking a 8-by-8 matrix of chars and returning a boolean (therefore without 7-bytes pre-processing <code>↑{⍞}¨⍳8</code> and 12-bytes post-processing <code>'no' 'yes'⊃⍨</code>):</p>

<pre class="lang-apl prettyprint-override"><code>{∨/∊{((3≤1⊥⊃=⊢)¨4,/⍵)({∨⌿∧⌿∨⌿⍵∘.=⊣/⍵}⌺2 3⊢⍵)}¨⍵(⍉⍵)}
</code></pre>

<p><a href="https://tio.run/##bY27SgNREIZrz1Ok3ICazN3GysZUgvEFAhKbQGxlSSWEzZINWghWFl5wOxvT2Aj7KPMi6@zWNnPmDN//f7PbxdH13WyxvGl99zS58PXDuM29qEdelHmWkW/ewcsPL@9PvXwdNjUfjrzaD7MO8u2vF5/97Pdq78XzcYBvHbPy7Q8OKGJdYNXU8WRebfpfOw@VV7sobr7I14@hn16exbw6n0zbg/kgbrlXL5E78ep7nAAJGAgSECIDSxI2RTVKCgaq0i3EAMwJiYXMYjFlYdRkIiYqmv6pJkEF4YCUEUw4gRgTGiRFIIlrMGHpHRw1YQ49o2EPK0Va/gA" rel="nofollow noreferrer" title="APL (Dyalog Unicode) – Try It Online">Try it online!</a></p>

<p>The basic idea is that we can test for 1x4 and 2x3 sub-boxes if each sub-box has a valid Bejeweled move:</p>

<pre class="lang-apl prettyprint-override"><code>(1x4 box)
OxOO    OOxO

(2x3 box)
OOx     OxO     xOO
xxO     xOx     Oxx

Oxx     xOx     xxO
xOO     OxO     OOx
</code></pre>

<p>For 1x4 boxes, we can check if the first item appears at least 3 times. For 2x3 boxes, we can check if at least one item in the first column appears in every column. For 4x1 and 3x2 boxes, we can check for 1x4 and 2x3 on the board transposed.</p>

<h3>How it works: the code</h3>

<pre class="lang-apl prettyprint-override"><code>'no' 'yes'⊃⍨{∨/∊{((3≤1⊥⊃=⊢)¨4,/⍵)({∨⌿∧⌿∨⌿⍵∘.=⊣/⍵}⌺2 3⊢⍵)}¨⍵(⍉⍵)}↑{⍞}¨⍳8

↑{⍞}¨⍳8  ⍝ Take 8 lines of input and form a 8x8 matrix
     ⍳8  ⍝ A dummy length-8 vector
 {⍞}¨    ⍝ Map "take a line of input" over the dummy vector
↑        ⍝ Promote a vector of vectors to a matrix (M)

{∨/∊{...}¨⍵(⍉⍵)}  ⍝ Pass the matrix onto the inline function
          ⍵(⍉⍵)   ⍝ M and transpose of M
    {...}¨        ⍝ Test over M and transposed M for Bejeweled moves
                  ⍝ (explained below)
 ∨/∊              ⍝ Enlist all booleans and check if any is true

{((3≤1⊥⊃=⊢)¨4,/⍵)({∨⌿∧⌿∨⌿⍵∘.=⊣/⍵}⌺2 3⊢⍵)}  ⍝ Test over all possible sub-boxes
((3≤1⊥⊃=⊢)¨4,/⍵)  ⍝ Test over 1x4 boxes
           4,/⍵   ⍝ Extract 1x4 boxes
 (    ⊃=⊢)¨       ⍝ For each box, test if each item equals first item
  3≤1⊥            ⍝ Is the count at least 3?
({∨⌿∧⌿∨⌿⍵∘.=⊣/⍵}⌺2 3⊢⍵)  ⍝ Test over 2x3 boxes
 {             }⌺2 3⊢⍵   ⍝ Ditto
        ⍵∘.=⊣/⍵          ⍝ Compare each item with the first column
  ∨⌿                     ⍝ Does there exist an item from the first column
    ∧⌿                   ⍝ that appears on every column
      ∨⌿                 ⍝ at least once?

'no' 'yes'⊃⍨  ⍝ Map 0/1 to no/yes respectively
</code></pre>
</div>
<div id="pu3" class="pu"><h1>Ruby, 201 bytes</h1>

<p>I was disappointed not to see any solutions to this great challenge that don't use a regex or brute force (although those are great), so I wrote one. It takes input on STDIN.</p>

<p>The core bitwise arithmetic algorithm is derived from <a href="https://gamedev.stackexchange.com/questions/2607/match-three-puzzle-games-algorithm">this fantastic answer on Game Development Stack Exchange</a> by @leander.</p>

<pre><code>s=$&lt;.read
$&gt;&lt;&lt;(?1..?9).any?{|n|a=[0]*19
s.scan(n){i=$`.size
a[i/9+1]+=2**(i%9)
a[i%9+10]+=2**(i/9)}
a.each_cons(3).any?{|x,y,z|q=y&amp;y&lt;&lt;1
l=q&lt;&lt;1
q&gt;&gt;=2
y&amp;(l&lt;&lt;1|q&gt;&gt;1)|(q|l|(y&amp;y&lt;&lt;2)&gt;&gt;1)&amp;(x|z)&gt;0}}?"yes":"no"
</code></pre>

<h2>Ruby lambda, 181 bytes</h2>

<p>Here it is as a lambda that takes a string and returns <code>true</code> or <code>false</code>:</p>

<pre><code>-&gt;s{(?1..?9).any?{|n|a=[0]*19
s.scan(n){i=$`.size
a[i/9+1]+=2**(i%9)
a[i%9+10]+=2**(i/9)}
a.each_cons(3).any?{|x,y,z|q=y&amp;y&lt;&lt;1
l=q&lt;&lt;1
q&gt;&gt;=2
y&amp;(l&lt;&lt;1|q&gt;&gt;1)|(q|l|(y&amp;y&lt;&lt;2)&gt;&gt;1)&amp;(x|z)&gt;0}}}
</code></pre>

<p>See it on repl.it: <a href="https://repl.it/ColJ/2" rel="nofollow noreferrer">https://repl.it/ColJ/2</a></p>

<h2>Ungolfed &amp; explanation</h2>

<pre><code>-&gt;s{
  (?1..?9).any? {|n|
    a = [0] * 19

    s.scan(n) {
      i = $`.size
      a[i/9+1] += 2**(i%9)
      a[i%9+10] += 2**(i/9)
    }

    a.each_cons(3).any? {|x,y,z|
      q = y &amp; y &lt;&lt; 1
      l = q &lt;&lt; 1
      q &gt;&gt;= 2
      y &amp; (l &lt;&lt; 1 | q &gt;&gt; 1) |
        (q | l | (y &amp; y &lt;&lt; 2) &gt;&gt; 1) &amp;
        (x | z) &gt; 0
    }
  }
}
</code></pre>

<p>The code iterates over the digits "1" to "9." Each iteration has two discrete steps:</p>

<p>The first step is board transformation, which you can see in the <code>s.scan(n)</code> block in the ungolfed code. It transforms the board into an array of 8 integers, one for each row, by treating matching digits as 1s and all others as 0s in a binary string. For example, take the row <code>12231123</code>. In the first iteration, this will become the binary string <code>10001100</code> (all 1s become—er, stay—1s and all other digits become 0s), which is the decimal number 140. In the second iteration the same row becomes <code>01100010</code> (all 2s become 2s and all other digits become 0s), or decimal 98.</p>

<p>It simultaneously performs a second transformation, which is the same as the first but with the board rotated 90 degrees. This lets us use the same logic for making horizontal matches as vertical ones. For simplicity, it concatenates the two boards into a single long one with a zero at the beginning, middle (to separate the two boards), and end for padding.</p>

<p>The second step is searching for possible matches, which you can see in the <code>each_cons(3).any?</code> block. The transformed rows (which are now 8-bit integers) are checked in (overlapping) groups of three rows (<em>x</em>, <em>y</em>, <em>z</em>) using bitwise arithmetic. Each group is checked to see if a match can be made in row <em>y</em>, either by shifting a piece in row <em>y</em> or by shifting a piece into <em>y</em> from <em>x</em> or <em>z</em>. Since there is a zero "row" before and after both the original and rotated boards' rows, we don't have to check if we're on the first or last row of a board.</p>

<p>If no matches were found, it continues to the next iteration.</p>
</div>
<div id="pu4" class="pu"><h1>Perl, <s>114</s> <s>96</s> <s>95</s> <s>93</s> <s>92</s> <s>87</s> <s>86</s> 85 bytes</h1>

<p>Includes + for <code>-a0p</code></p>

<p>Run with the input on STDIN:</p>

<pre><code>bejeweled.pl
12314131
13224145
54762673
61716653
61341144
23453774
27645426
75575656
^D
</code></pre>

<p><code>bejeweled.pl</code>:</p>

<pre><code>#!/usr/bin/perl -a0p
$i/s%.%chop$F[$i++&amp;7]%eg&gt;3|/(.)((.|\H{6}|\H{9})\1|\H{7}\1.)\1/||redo;$_=$1?yes:n.o
</code></pre>

<p>This combines a single direction horizontal regex solution with rotations</p>

<h2>Explanation:</h2>

<p>In this solution I will repeatedly rotate and do the following 4 tests:</p>

<pre><code>/(.).\1\1/,      // 3-in-a-row horizontally after left-most shifts right
/(.)\C{9}\1\1/,  // 3-in-a-row horizontally after left-most shifts down
/(.)\C{7}\1.\1/, // 3-in-a-row horizontally after middle shifts down
/(.)\C{6}\1\1/,  // 3-in-a-row horizontally after right-most shifts down
</code></pre>

<p>Where <code>\C</code> is "any character" (unlike <code>.</code> this includes newline). Except that <code>\C</code> is deprecated and leads to warnings, so I use <code>\H</code> (non-horizontal space) instead which is good enough to capture all digits and newline.</p>

<p>After 4 rotation this will have done all 16 tests that are needed</p>

<pre><code>-p                            Read lines from STDIN, print $_ at the end
-0                            No line ending =&gt; slurp ALL of STDIN
-a                            Split $_ into @F. Since there are no spaces
                              on the rows this means each element of @F is
                              1 row

    s%.%chop$F[$i++&amp;7]%eg     Replace each row by the removed last column
                              This is therefore a left rotation. Very short
                              but at the cost of using @F. To make sure that
                              @F gets refilled from $_ each time I won't be
                              able to use while, until, eval or do$0 for the
                              loops but have to use redo. That costs a few
                              bytes but less than having to do my own split
$i/                      &gt;3   The previous regex replacement always
                              returns 64 and each time through the loop $i is
                              increased by 64. So if this division reaches
                              4 all rotations have been done

/(.)((.|\H{6}|\H{9})\1|\H{7}\1.)\1/ This is the 4 regexes mentioned above
  ||redo                      Stop the loop if the regex matches or we
                              rotated 4 times
$_=$1?yes:n.o                If the regex matched $1 will be one of the
                              color digits (which cannot be 0) and this will
                              assign "yes" to $_. If the regex didn't match
                              in 4 times $1 will get its value from the last
                              succesful regex in scope which will be the one
                              from the rotation, but that one doesn't have
                              any () so $1 will be unset. So in case there
                              is no move $_ will be set to "no" (which needs
                              to be constructed because "no" is a keyword)
</code></pre>
</div>
<div id="pu5" class="pu"><h1>Original Solution: JavaScript - <s>261</s> <s>255</s> <s>228</s> <s>227</s> <s>179</s> 153 Characters</h1>
<pre><code>/(\d)(\1(\d|.{6}|.{9})|(\d|.{6}|.{9})\1|.{7}\1(.|.{9})|(.|.{9})\1.{7}|(.{7,9}|.{17})\1.{8}|.{8}\1(.{7,9}|.{17}))\1/.test(s.replace(/\n/g,'A'))?'yes':'no'
</code></pre>
<p>Assuming that the string to test is in the variable <code>s</code> (to make it a function <code>f</code> then add <code>f=s=&gt;</code> to the beginning of the code or, otherwise, to take input from a prompt then replace <code>s</code> with <code>prompt()</code>).</p>
<p>Outputs is to the console.</p>
<h1>3<sup>rd</sup> Solution: JavaScript (ECMAScript 6) - 178 Characters</h1>
<pre><code>p=x=&gt;parseInt(x,36);for(t=&quot;2313ab1b8a2a78188h9haj9j8iaiir9r&quot;,i=v=0;s[i];i++)for(j=0;t[j];v|=s[i]==s[i+a]&amp;s[i]==s[i+b]&amp;i%9&lt;8&amp;(b&gt;3|(i+b-a)%9&lt;8))a=p(t[j++]),b=p(t[j++]);v?'yes':'no'
</code></pre>
<p>I took the 2<sup>nd</sup> solution, below, (which uses regular expressions to check for characters in certain configurations) and reworked it to just check the string for identical characters in the same configurations without using regular expressions.</p>
<p>The Base-36 string <code>&quot;2313ab1b8a2a78188h9haj9j8iaiir9r&quot;</code> gives pairs of offsets to check - i.e. the pair <code>23</code> results in the check if i<sup>th</sup> character is identical to the (i+2)<sup>th</sup> character and the (i+3)<sup>th</sup> character (the equivalent of the regular expression <code>(.).\1\1</code> - with some additional checks to ensure that the non-identical character is not a newline).</p>
<h1>2<sup>nd</sup> Solution: JavaScript (ECMAScript 6) - 204 Characters</h1>
<pre><code>p=x=&gt;parseInt(x,18);g=a=&gt;a?a&gt;1?&quot;(.|\\n){&quot;+a+&quot;}&quot;:&quot;.&quot;:&quot;&quot;;f=(x,a,b)=&gt;RegExp(&quot;(.)&quot;+g(a)+&quot;\\1&quot;+g(b)+&quot;\\1&quot;).test(x);for(t=&quot;10907160789879h8&quot;,i=v=0;t[i];v|=f(s,x,y)||f(s,y,x))x=p(t[i++]),y=p(t[i++]);v?'yes':'no'
</code></pre>
<p>Builds multiple regular expressions (see below for more details) using pairs of values taken from the  Base-18 string <code>10907160789879h8</code> and takes the <code>OR</code> of all the tests. To reduce it further you can note that the regular expressions come in pairs where one is the &quot;reverse&quot; of the other (ignoring the Regular Expressions for 3-in-a-row horizontally and vertically as the OP states they will never be present - if you want to add those tests back in the append <code>0088</code> to the Base-18 string).</p>
<p><strong>Explanation</strong></p>
<p>Start with 16 regular expressions covering all the possible configurations of valid moves:</p>
<pre><code>REs=[
    /(\d)\1\1/,                 // 3-in-a-row horizontally
    /(\d).\1\1/,                // 3-in-a-row horizontally after left-most shifts right
    /(\d)\1.\1/,                // 3-in-a-row horizontally after right-most shifts left
    /(\d)(?:.|\n){9}\1\1/,  // 3-in-a-row horizontally after left-most shifts down
    /(\d)(?:.|\n){7}\1.\1/, // 3-in-a-row horizontally after middle shifts down
    /(\d)(?:.|\n){6}\1\1/,  // 3-in-a-row horizontally after right-most shifts down
    /(\d)\1(?:.|\n){6}\1/,  // 3-in-a-row horizontally after left-most shifts up
    /(\d).\1(?:.|\n){7}\1/, // 3-in-a-row horizontally after middle shifts up
    /(\d)\1(?:.|\n){9}\1/,  // 3-in-a-row horizontally after right-most shifts up
    /(\d)(?:.|\n){7,9}\1(?:.|\n){8}\1/, // 3-in-a-row vertically (with optional top shifting left or right)
    /(\d)(?:.|\n){7}\1(?:.|\n){9}\1/,   // 3-in-a-row vertically after middle shifts right
    /(\d)(?:.|\n){9}\1(?:.|\n){7}\1/,   // 3-in-a-row vertically after middle shifts left
    /(\d)(?:.|\n){8}\1(?:.|\n){7}\1/,   // 3-in-a-row vertically after bottom shifts right
    /(\d)(?:.|\n){8}\1(?:.|\n){9}\1/,   // 3-in-a-row vertically after bottom shifts left
    /(\d)(?:.|\n){17}\1(?:.|\n){8}\1/,  // 3-in-a-row vertically after top shifts down
    /(\d)(?:.|\n){8}\1(?:.|\n){17}\1/,  // 3-in-a-row vertically after bottom shifts up
];
</code></pre>
<p>(<em>Note: the regexs for 3-in-a-row horizontally (0<sup>th</sup>) and vertically (part of the 9<sup>th</sup>) are irrelevant as the OP states that inputs matching these will never be present.</em>)</p>
<p>Testing each of those against the input will determine if a valid move of that configuration can be found.</p>
<p>However, the regular expressions can be combined to give these 6:</p>
<pre><code>/(\d)(?:.|(?:.|\n){9}|(?:.|\n){6})?\1\1/            // Tests 0,1,3,5
/(\d)\1(?:.|(?:.|\n){9}|(?:.|\n){6})?\1/            // Tests 0,2,6,8
/(\d)(?:.|\n){7}\1(?:.|(?:.|\n){9})\1/              // Tests 4,10
/(\d)(?:.|(?:.|\n){9})\1(?:.|\n){7}\1/              // Tests 7,11
/(\d)(?:(?:.|\n){7,9}|(?:.|\n){17})\1(?:.|\n){8}\1/ // Tests 9,14
/(\d)(?:.|\n){8}\1(?:(?:.|\n){7,9}|(?:.|\n){17})\1/ // Tests 9a,12,13,15
</code></pre>
<p>These can then be combined into a single regular expression:</p>
<pre><code>/(\d)(?:.|(?:.|\n){9}|(?:.|\n){6})?\1\1|(\d)\2(?:.|(?:.|\n){9}|(?:.|\n){6})?\2|(\d)(?:.|\n){7}\3(?:.|(?:.|\n){9})\3|(\d)(?:.|(?:.|\n){9})\4(?:.|\n){7}\4|(\d)(?:(?:.|\n){7,9}|(?:.|\n){17})\5(?:.|\n){8}\5|(\d)(?:.|\n){8}\6(?:(?:.|\n){7,9}|(?:.|\n){17})\6/
</code></pre>
<p>Which just needs to be tested against the input.</p>
<p><strong>Test Cases</strong></p>
<p>Some test cases which other people might find useful (doesn't comply with the input format of using only digits 1-7 but that's easily corrected and is only an 8x4 grid - since that is the minimum required for a test of all the valid inputs).</p>
<p>In the format of a map from input string to which of the 16 regular expressions above it matches.</p>
<pre><code>Tests={
    &quot;12345678\n34567812\n56781234\n78123456&quot;: -1, // No Match
    &quot;12345678\n34969912\n56781234\n78123456&quot;: 1,    // 3-in-a-row horizontally after left-most shifts right 
    &quot;12345678\n34567812\n59989234\n78123456&quot;: 2,    // 3-in-a-row horizontally after right-most shifts left
    &quot;12345978\n34567899\n56781234\n78123456&quot;: 3,    // 3-in-a-row horizontally after left-most shifts down
    &quot;12345978\n34569892\n56781234\n78123456&quot;: 4,    // 3-in-a-row horizontally after middle shifts down
    &quot;12345678\n34967812\n99781234\n78123456&quot;: 5,    // 3-in-a-row horizontally after right-most shifts down
    &quot;12399678\n34967812\n56781234\n78123456&quot;: 6,    // 3-in-a-row horizontally after left-most shifts up
    &quot;12345678\n34597912\n56789234\n78123456&quot;: 7,    // 3-in-a-row horizontally after middle shifts up
    &quot;12345998\n34567819\n56781234\n78123456&quot;: 8,    // 3-in-a-row horizontally after right-most shifts up
    &quot;12945678\n34597812\n56791234\n78123456&quot;: 9,    // 3-in-a-row vertically after top shifts right
    &quot;12349678\n34597812\n56791234\n78123456&quot;: 9,    // 3-in-a-row vertically after top shifts left
    &quot;12345978\n34569812\n56781934\n78123456&quot;: 10,   // 3-in-a-row vertically after middle shifts right
    &quot;92345678\n39567812\n96781234\n78123456&quot;: 11,   // 3-in-a-row vertically after middle shifts left
    &quot;12945678\n34967812\n59781234\n78123456&quot;: 12,   // 3-in-a-row vertically after bottom shifts right
    &quot;12349678\n34569812\n56781934\n78123456&quot;: 13,   // 3-in-a-row vertically after bottom shifts left
    &quot;12395678\n34567812\n56791234\n78193456&quot;: 14,   // 3-in-a-row vertically after top shifts down
    &quot;12345698\n34567892\n56781234\n78123496&quot;: 15,   // 3-in-a-row vertically after bottom shifts up
    &quot;12345678\n34567899\n96781234\n78123456&quot;: -1,   // No match - Matches (.)\1.\1 but not 3 in a row
    &quot;12345679\n99567812\n56781234\n78123456&quot;: -1,   // No match - Matches (.).\1\1 but not 3 in a row
};
</code></pre>
<p><strong>Edit 1</strong></p>
<p>Replace <code>\d</code>s with <code>.</code> - saves 6 characters.</p>
<p><strong>Edit 2</strong></p>
<p>Replace <code>(?:.|\n)</code> with <code>[\s\S]</code> and removed extra non-capturing groups and updated back references (as suggested by <a href="https://codegolf.stackexchange.com/users/8478/m-buettner">m-buettner</a>) and added in yes/no output.</p>
<p><strong>Edit 3</strong></p>
<ul>
<li>Added ECMAScript 6 solution to build the individual Regular Expressions from a Base-18 string.</li>
<li>Removed the tests for 3-in-a-row horizontally (as suggested by <a href="https://codegolf.stackexchange.com/users/8478/m-buettner">m-buettner</a>).</li>
</ul>
<p><strong>Edit 4</strong></p>
<p>Added another (shorter) solution and two more non-matching tests cases.</p>
<p><strong>Edit 5</strong></p>
<ul>
<li>Shortened original solution by replacing newlines with a non-numeric character (as suggested by <a href="https://codegolf.stackexchange.com/users/15846/vadimr">VadimR</a>).</li>
</ul>
<p><strong>Edit 6</strong></p>
<ul>
<li>Shortened original solution by combining bits of the regular expression (as suggested by <a href="https://codegolf.stackexchange.com/users/15846/vadimr">VadimR</a>).</li>
</ul>
</div>
<div id="pu6" class="pu"><h1>GNU sed 255+2 = 257B</h1>
<p>I thought this wasn't going to be as good as python but it is now :-/ I've been without internet access today so I occupied myself with solving this in sed :). Needs to be called with the -r flag, i.e. <code>sed -rf command.sed &lt; input</code> so I added 2 to my score.</p>
<pre><code>:a
$!N
s/\n/ /g
ta
:b
/^((\w)(\w\2\2|\2\w\2|\w\2\w* \w\2|\2\w* \w\w\2|\w* (\2\w* \w* \2|\w* \2\w* \2|\w\2\2|\w\2\w* \2|\2\w* \w\2|\w\2\w* \w\2))|\w((\w)(\w* \6\w\6|\6\w* \6|\w* (\6\w \w\6|\w\6\w* \6|\6\w* \6))|\w(\w)\w* \9\9))/c\yes
s/\w(\w*)/\1/g
tb
c\no
</code></pre>
<p>How it works:</p>
<ol>
<li>Read the grid into a single line of space-separated characters</li>
<li>Use the motherload regex to find out whether there's a match in the first column* - if yes, swap the entire line for 'yes' (ending the program)</li>
<li>Strip the first character from each column and goto 2 if we did</li>
<li>If we didn't (the line is empty) replace the whole line with 'no'</li>
</ol>
</div>
<div id="pu7" class="pu"><h1>Node.js - Naive solution - 905 bytes</h1>

<p>Well, no answers yet so I'll post a really naive solution in Node.js</p>

<p>It goes through every possible move and then tests the resulting board to see if there's 3 in a row.</p>

<p>Golfed (with google closure compiler) (some hacky stuff in there like !0 and !1; I'm not even sure what it did with my XOR swap)</p>

<pre><code>Array.prototype.a=function(){for(var f=[],d=0;d&lt;this.length;d++)f[d]=this[d].a?this[d].a():this[d];return f};for(var a=[],b=0;8&gt;b;b++)a[b]=[];for(b=2;b&lt;process.argv.length;b++)for(var c=process.argv[b].split(""),e=0;e&lt;c.length;e++)a[b-2][e]=parseInt(c[e],10);function h(){for(var d=l,f=0;f&lt;d.length-2;f++)for(var g=0;g&lt;d[f].length-2;g++){var k=d[f][g];if(k==d[f+1][g]&amp;&amp;k==d[f+2][g]||k==d[f][g+1]&amp;&amp;k==d[f][g+2])return!0}return!1}function m(){console.log("yes");process.exit()}for(b=0;b&lt;a.length;b++)for(e=0;e&lt;a[b].length;e++){var l=a.a();0!=b&amp;&amp;(l[b-1][e]^=l[b][e],l[b][e]^=l[b-1][e],l[b-1][e]^=l[b][e],h()&amp;&amp;m(),l=a.a());b!=a.length-1&amp;&amp;(l[b+1][e]^=l[b][e],l[b][e]^=l[b+1][e],l[b+1][e]^=l[b][e],h()&amp;&amp;m(),l=a.a());0!=e&amp;&amp;(l[b][e-1]^=l[b][e],l[b][e]^=l[b][e-1],l[b][e-1]^=l[b][e],h()&amp;&amp;m(),l=a.a());e!=a[b].length-1&amp;&amp;(l[b][e+1]^=l[b][e],l[b][e]^=l[b][e+1],l[b][e+1]^=l[b][e],h()&amp;&amp;m(),l=a.a())}console.log("no");
</code></pre>

<p>Note that I wrote this <em>all</em> on my mobile and don't have time to test it or anything. Comment if you see any bugs, I'll check it myself later.</p>

<p>The pre-golfed human readable version</p>

<pre><code>// set it up
Array.prototype.clone = function() {
    var arr = [];
    for( var i = 0; i &lt; this.length; i++ ) {
        if( this[i].clone ) {
             arr[i] = this[i].clone();
        } else {
             arr[i] = this[i];
        }
    }
};
var board=[];
for(var i=0;i&lt;8;i++)board[i]=[];
for(var i=2;i&lt;process.argv.length;i++){
    var row=process.argv[i].split("");
    for(var j=0;j&lt;row.length;j++)board[i-2][j]=parseInt(row[j], 10);
}
// function to test
function testBoard(arr){
    for(var i=0;i&lt;arr.length-2;i++){
        for(var j=0;j&lt;arr[i].length-2;j++){
            var val=arr[i][j];
            if(val==arr[i+1][j] &amp;&amp; val==arr[i+2][j])return true;
            if(val==arr[i][j+1] &amp;&amp; val==arr[i][j+2])return true;
        }
    }
    return false;
}
// functions to exit
function yay(){console.log("yes");process.exit();}
function nay(){console.log("no");}
// super slow naive solution time
for(var i=0;i&lt;board.length;i++){
    for(var j=0;j&lt;board[i].length;j++){
        var newboard=board.clone();
        if(i!=0){
            newboard[i-1][j]=newboard[i-1][j]^newboard[i][j];// whoa, it's a
            newboard[i][j]=newboard[i-1][j]^newboard[i][j];  // cool algorithm
            newboard[i-1][j]=newboard[i-1][j]^newboard[i][j];// at least this 
                                                             // isn't all naive
            if(testBoard(newboard))yay();
            newboard=board.clone();
        }
        if(i!=board.length-1){
            newboard[i+1][j]=newboard[i+1][j]^newboard[i][j];
            newboard[i][j]=newboard[i+1][j]^newboard[i][j];
            newboard[i+1][j]=newboard[i+1][j]^newboard[i][j];
            if(testBoard(newboard))yay();
            newboard=board.clone();
        }
        if(j!=0){
            newboard[i][j-1]=newboard[i][j-1]^newboard[i][j];
            newboard[i][j]=newboard[i][j-1]^newboard[i][j];
            newboard[i][j-1]=newboard[i][j-1]^newboard[i][j];
            if(testBoard(newboard))yay();
            newboard=board.clone();
        }
        if(j!=board[i].length-1){
            newboard[i][j+1]=newboard[i][j+1]^newboard[i][j];
            newboard[i][j]=newboard[i][j+1]^newboard[i][j];
            newboard[i][j+1]=newboard[i][j+1]^newboard[i][j];
            if(testBoard(newboard))yay();
            newboard=board.clone();
        }
    }
}
nay();
</code></pre>
</div>
<div id="pu8" class="pu"><h1>Python3, 314B</h1>
<pre><code>import itertools as T,copy
r=[]
K=range(8)
J=[list(input())for w in K]
P=T.product
f=lambda A:[&quot;yes&quot;for b in[A[m][n:]for m,n in P(K,K[:6])]if b[0]==b[1]==b[2]]
for i,j,x in P(K,K,[0,1]):
 t=j+1-x
 if i+x&lt;8and t&lt;8:B=copy.deepcopy(J);B[i][j],B[i+x][t]=B[i+x][t],B[i][j];r+=f(B)+f(list(zip(*B)))
r+=[&quot;no&quot;]
print(r[0])
</code></pre>
<p>Change the 8, the 5 on line 6, and the 8s on line 9 to handle arbitrarily large input sizes; also doesn't care what each value is, so you can feed it:</p>
<pre><code>absdefgh
sdkljahs
lsdfjasd
fjdhsdas
dkjhfasd
sdfhaskd
sdkfhkas
weriuwqe
</code></pre>
<p>and it will return <code>yes</code>.</p>
<h3>Annotations</h3>
<pre><code>import itertools as T,copy 
            # itertools.product is going to save us lots of for loops
r=[]        # result
K=range(8)  # we can use range(8) everywhere, so this saves more than the usual R=range
J=[list(input())for w in K] 
            # input handling: keep everything as a length-1 string to avoid map(int,input())
P=T.product
f=lambda A:[&quot;yes&quot;for b in[A[m][n:]for m,n in P(K,K[:6])]if b[0]==b[1]==b[2]] 
            # check the condition horiontally only. K[:6] is the same as range(5)
            # A[m][n:n+3] would be neater, but not actually needed
for i,j,x in P(K,K,[0,1]): 
            # &lt;3 itertools.product! 3 for-loops without it.
            # NB we're only going right and downwards
 t=j+1-x
 if i+x&lt;8and t&lt;8: 
            # don't want out-of-bounds errors at the edges
  B=copy.deepcopy(J) 
            # preserve the reference array
  B[i][j],B[i+x][t]=B[i+x][t],B[i][j] 
            # do the switch
  r+=f(B)+f(list(zip(*B))) 
            # do the test. you could end up with lots of 'yes's in r.
            # zip(*B) takes the transpose, so that f checks the columns too
r+=[&quot;no&quot;]   # happens to ensure that r is nonempty
print(r[0]) # only prints no if r was empty before the last line
</code></pre>
</div>
<div id="pu9" class="pu"><h1>Python 383</h1>
<p>Just a single* line of Python!</p>
<pre class="lang-py prettyprint-override"><code>a=[list(l)for l in raw_input().split('\n')];z=any;e=enumerate;c=lambda b:z(all(p==b[y+v][x+u]for(u,v)in o)for y,r in e(b[:-2])for x,p in e(r[:-2])for o in [[(0,1),(0,2)],[(1,0),(2,0)]]);print z(c([[q if(i,j)==(m,n)else a[m][n]if(i,j)==(y+1,x+1)else p for j,p in e(r)]for i,r in e(a)])for y,t in e(a[1:-1])for x,q in e(t[1:-1])for n,m in((x+u,y+v)for u,v in[(1,0),(1,2),(0,1),(2,1)]))
</code></pre>
<p>*Well, with semicolons, but that's still non-trivial in python (python one-liners are <a href="https://wiki.python.org/moin/Powerful%20Python%20One-Liners" rel="nofollow noreferrer">fun!</a>)</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/26505/">26505</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




