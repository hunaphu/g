<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::22599</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td></td><td>240927T114059Z</td><td><a href="https://codegolf.stackexchange.com/questions/22599/approximate-a-bell-curve/275816#275816">roblogic</a></td></tr>
<tr d-ix="1"><td>nan</td><td>Charcoal</td><td>180406T122947Z</td><td><a href="https://codegolf.stackexchange.com/questions/22599/approximate-a-bell-curve/161464#161464">Neil</a></td></tr>
<tr d-ix="2"><td>nan</td><td></td><td>180402T233100Z</td><td><a href="https://codegolf.stackexchange.com/questions/22599/approximate-a-bell-curve/161094#161094">ceilingc</a></td></tr>
<tr d-ix="3"><td>020</td><td>Stax</td><td>180403T034209Z</td><td><a href="https://codegolf.stackexchange.com/questions/22599/approximate-a-bell-curve/161105#161105">Weijun Z</a></td></tr>
<tr d-ix="4"><td>nan</td><td></td><td>180403T000140Z</td><td><a href="https://codegolf.stackexchange.com/questions/22599/approximate-a-bell-curve/161098#161098">Bolce Bu</a></td></tr>
<tr d-ix="5"><td>nan</td><td></td><td>140317T072915Z</td><td><a href="https://codegolf.stackexchange.com/questions/22599/approximate-a-bell-curve/24362#24362">user1921</a></td></tr>
<tr d-ix="6"><td>nan</td><td></td><td>140306T222424Z</td><td><a href="https://codegolf.stackexchange.com/questions/22599/approximate-a-bell-curve/23249#23249">cpri</a></td></tr>
<tr d-ix="7"><td>nan</td><td></td><td>140306T220609Z</td><td><a href="https://codegolf.stackexchange.com/questions/22599/approximate-a-bell-curve/23247#23247">andrepd</a></td></tr>
<tr d-ix="8"><td>004</td><td>Wolfram Alpha tongueincheek</td><td>140306T200336Z</td><td><a href="https://codegolf.stackexchange.com/questions/22599/approximate-a-bell-curve/23234#23234">Tim Segu</a></td></tr>
<tr d-ix="9"><td>nan</td><td></td><td>140304T214445Z</td><td><a href="https://codegolf.stackexchange.com/questions/22599/approximate-a-bell-curve/22914#22914">Mark Jer</a></td></tr>
<tr d-ix="10"><td>nan</td><td>C#</td><td>140304T163920Z</td><td><a href="https://codegolf.stackexchange.com/questions/22599/approximate-a-bell-curve/22870#22870">Sebastia</a></td></tr>
<tr d-ix="11"><td>nan</td><td></td><td>140303T010006Z</td><td><a href="https://codegolf.stackexchange.com/questions/22599/approximate-a-bell-curve/22679#22679">Jonathan</a></td></tr>
<tr d-ix="12"><td>nan</td><td></td><td>140303T165842Z</td><td><a href="https://codegolf.stackexchange.com/questions/22599/approximate-a-bell-curve/22719#22719">DavidC</a></td></tr>
<tr d-ix="13"><td>nan</td><td></td><td>140302T090034Z</td><td><a href="https://codegolf.stackexchange.com/questions/22599/approximate-a-bell-curve/22629#22629">ProgramF</a></td></tr>
<tr d-ix="14"><td>nan</td><td></td><td>140302T092216Z</td><td><a href="https://codegolf.stackexchange.com/questions/22599/approximate-a-bell-curve/22630#22630">primo</a></td></tr>
<tr d-ix="15"><td>009</td><td>Haskell</td><td>140302T083542Z</td><td><a href="https://codegolf.stackexchange.com/questions/22599/approximate-a-bell-curve/22627#22627">John Dvo</a></td></tr>
<tr d-ix="16"><td>nan</td><td></td><td>140302T074704Z</td><td><a href="https://codegolf.stackexchange.com/questions/22599/approximate-a-bell-curve/22624#22624">Justin</a></td></tr>
<tr d-ix="17"><td>nan</td><td></td><td>140302T064444Z</td><td><a href="https://codegolf.stackexchange.com/questions/22599/approximate-a-bell-curve/22621#22621">qwr</a></td></tr>
<tr d-ix="18"><td>nan</td><td></td><td>140302T051525Z</td><td><a href="https://codegolf.stackexchange.com/questions/22599/approximate-a-bell-curve/22617#22617">Doorknob</a></td></tr>
<tr d-ix="19"><td>008</td><td>Java</td><td>140302T025904Z</td><td><a href="https://codegolf.stackexchange.com/questions/22599/approximate-a-bell-curve/22607#22607">Victor S</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.zsh.org/" rel="nofollow noreferrer">Zsh</a> &amp; <a href="https://zachholman.com/spark/" rel="nofollow noreferrer">spark</a>/<a href="https://www.gnu.org/software/plotutils/" rel="nofollow noreferrer">plotutils</a></h1>
<h2>with <a href="https://zachholman.com/spark/" rel="nofollow noreferrer"><code>spark</code></a> for the shell:</h2>
<pre><code>r=RANDOM%6;(for i ({0..99999})echo $[r+r+r])|sort -n|uniq -c|spark 
▁▁▁▁▂▁▃▁▄▁▆▁▇▁▇▁█▁▇▁▆▁▄▁▃▁▂▁▁▁▁▁
</code></pre>
<p>Unfortunately Zsh <code>$RANDOM</code> is deterministic/pseudo-random so perhaps I should use <code>jot -r</code>.  The following example uses <code>rand48()</code>.</p>
<h2>with <a href="https://www.gnu.org/software/plotutils/" rel="nofollow noreferrer"><code>plotutils/graph</code></a>:</h2>
<pre class="lang-sh prettyprint-override"><code>#!/bin/zsh
zmodload zsh/mathfunc
bm()printf %.1f\\n $[sqrt(-2*log(rand48()))*$1(8*atan(1)*rand48())]
(repeat 99999 bm cos&amp;&amp;bm sin)|sed 's/-0.0/0.0/'|sort -n\
  |uniq -c|graph -t -g0 -Tpng &gt; $$.png
               # -t   transpose axes
               # -g0  no labels
</code></pre>
<p>Uses <a href="https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform" rel="nofollow noreferrer">Box-Muller transform</a> to convert <a href="https://zsh.sourceforge.io/Doc/Release/Zsh-Modules.html#The-zsh_002fmathfunc-Module" rel="nofollow noreferrer"><code>rand48()</code></a> values to a normal distribution.
<img src="https://i.sstatic.net/Lh5MGvSd.png" width="200" alt="bell curve"/></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a></h1>

<pre><code>≔⟦Ｘφ±⁹⟧θＦ⁹⁹≔Ｅ⊞Ｏθ⁰⁺κ§θ⊖λθ↑θ
</code></pre>

<p>Verbose version:</p>

<pre><code>Assign([Power(1000, Negate(9))], q);
for (99) Assign(Map(PushOperator(q, 0), Plus(k, AtIndex(q, Decremented(l)))), q);
Print(:Up, q);
</code></pre>

<p><a href="https://tio.run/##LYy9DsIgFEZ3n@KOlwQTHNGpiYuDyuJkHAi9to0U6IWqb4@/33ZOTj7XW3bR@lqbnIcu4NnEBzGulFISDtTZQqiFuEiYxGZxjQyotYB/vbcJzZz7YyK2JTJOEpSQYPyc8SahKbvQ0vOjt@SYRgqFWvTivd@j4SEUXJ/SF2uty7t/AQ" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Output:</p>

<pre><code>             ||             
             ||             
            ||||            
            ||||            
            ||||            
            ||||            
           ||||||           
           ||||||           
           ||||||           
           ||||||           
           ||||||           
          ||||||||          
          ||||||||          
          ||||||||          
          ||||||||          
          ||||||||          
          ||||||||          
         ||||||||||         
         ||||||||||         
         ||||||||||         
         ||||||||||         
         ||||||||||         
         ||||||||||         
        ||||||||||||        
        ||||||||||||        
        ||||||||||||        
        ||||||||||||        
        ||||||||||||        
        ||||||||||||        
       ||||||||||||||       
       ||||||||||||||       
       ||||||||||||||       
       ||||||||||||||       
       ||||||||||||||       
      ||||||||||||||||      
      ||||||||||||||||      
      ||||||||||||||||      
      ||||||||||||||||      
      ||||||||||||||||      
     ||||||||||||||||||     
     ||||||||||||||||||     
     ||||||||||||||||||     
    ||||||||||||||||||||    
    ||||||||||||||||||||    
    ||||||||||||||||||||    
   ||||||||||||||||||||||   
   ||||||||||||||||||||||   
  ||||||||||||||||||||||||  
 |||||||||||||||||||||||||| 
||||||||||||||||||||||||||||
</code></pre>
</div>
<div id="pu2" class="pu"><h1>Octave</h1>
<pre><code>c=79;
x=ifft(fft([ones(1,10) zeros(1,c-10)]).^8);
y=(1:c)*0+' ';
for l=-24:-1,
  for k=1:c,
    if -real(x(k))&lt;l*2e5,
      y(k)='*';
    end
  end
  printf([char(y) '\n'])
end
</code></pre>
<p><a href="https://tio.run/##NYzRCsIwDEXf@xV5azJXWYeibvZLpsKoLY6NVuqQzZ@vLeJDQs494Xo9928To1aHU8sWNVg7Y57OO/NCWcqK4GOCz7cWia60vR2pZatC2Wgqqg0H3jLrA0xK1LtGyJIBZB5V@sgAMFgQwfQTLjgSnaeiNvufAVhTpHiRSjIZd2f//QyDmy12@tEHXAn4xfErsSRj/AI" rel="nofollow noreferrer" title="Octave – Try It Online">Try it online!</a></p>
<p>Instead of directly simulating coin flips, this just uses the observation that the pdf of a sum of random variables is the convolution of the pdfs of each of the random variables. An efficient way to do circular convolution is to take the inverse fourier transform of the element-wise product of the fourier transforms of the pdfs of each of the random variables. For the purpose of this problem (not true in general) circular convolution can stand in for linear convolution.</p>
<p>As an example, given the following pdf of a uniform random variable.</p>
<pre><code>                           **********
                           **********
                           **********
                           **********
                           **********
                           **********
                           **********
                           **********
                           **********
                           ********** 
                           ********** 
                           **********       
</code></pre>
<p>The above random variable summed with itself</p>
<pre><code>                                * 
                               *** 
                               ***  
                              *****  
                             *******   
                            *********    
                           ***********                           
                           *********** 
                          *************  
                         ***************    
                        *****************  
                       *******************
</code></pre>
<p>The uniform random variable summed with itself 7 times.</p>
<pre><code>                                *                                          
                             *******                                       
                           ***********                                     
                          *************                                    
                         ***************                                   
                        *****************                                  
                       *******************                                 
                     ***********************                               
                    *************************                              
                   ***************************                             
                 *******************************                           
              *************************************                   
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/tomtheisen/stax" rel="nofollow noreferrer">Stax</a>, 20 <a href="https://github.com/tomtheisen/stax/blob/master/docs/packed.md#packed-stax" rel="nofollow noreferrer">bytes</a></h1>

<pre><code>⌐∞¶J♠fr"▐cS╥aÆ~a╚∩┌I
</code></pre>

<p><a href="https://staxlang.xyz/#p=a9ec144a06667222de6353d261927e61c8efda49&amp;i=&amp;a=1" rel="nofollow noreferrer">Run and debug it</a></p>

<p>This isn't code-golf but I still want to give Stax a try. Calculates frequency of sum of dices rolled 6 times. Note there are no support for random numbers in Stax.</p>

<p>ASCII equivalent:</p>

<pre><code>6R6|^{|+m{o:G{AJ/'**mMrm
</code></pre>

<p>Output:</p>

<pre><code>               *               
              ***              
              ***              
              ***              
             *****             
             *****             
             *****             
             *****             
             *****             
            *******            
            *******            
            *******            
            *******            
            *******            
            *******            
           *********           
           *********           
           *********           
           *********           
           *********           
           *********           
          ***********          
          ***********          
          ***********          
          ***********          
          ***********          
          ***********          
         *************         
         *************         
         *************         
         *************         
         *************         
        ***************        
        ***************        
        ***************        
        ***************        
       *****************       
       *****************       
       *****************       
      *******************      
      *******************      
     *********************     
    *********************** 
</code></pre>
</div>
<div id="pu4" class="pu"><h1>J</h1>

<pre><code>load 'plot'
plot (3+i.58)([:+/=)"0 1]3+([:+/?,?,?)"0]1e6#20
</code></pre>

<p>Not very creative, but still fun!</p>

<p>Throws three twenty sided dice 1000000 times, summing the result each time. Then to get it in a <code>plot</code>-ready format, we take the array <code>[3..60]</code> and replace each element by the number of times it occures in the random sums.</p>

<p><code>plot</code> then creates a PDF:</p>

<p><a href="https://i.sstatic.net/PkCl0.png" rel="nofollow noreferrer"><img src="https://i.sstatic.net/PkCl0.png" alt="Look at that curve"></a></p>
</div>
<div id="pu5" class="pu"><h1>awk</h1>
<pre><code>#!/ust/bin/awk -f
BEGIN {
  #
  # do WALKS random walks with OOPS times left or right per walk
  #
  WALKS=100000
  OOPS=39
  #
  # output will be H lines
  # the line width will be 2*OOPS+1
  #
  H=23
  #
  # shake awk's pseudorandom generator
  #
  srand()
  #
  # do the walks
  #
  for(i=0;i&lt;WALKS;i++) {
    x=0
    for(j=0;j&lt;OOPS;j++) rand()&lt;0.5?--x:++x
    X[x]++
  }
  #
  # scan for maximum height
  #
  M=0
  for(x=-OOPS;x&lt;=OOPS;x++) {
    if(X[x]&gt;M) M=X[x]
  }
  #
  # &quot;draw&quot; into S[x]: strings of H*X[x]/M &quot;*&quot;s
  #
  for(x=-OOPS;x&lt;=OOPS;x++) {
    s=sprintf(&quot;%*s&quot;,H*X[x]/M,&quot; &quot;)
    gsub(/./,&quot;*&quot;,s)
    S[x]=s
  }
  #
  # print S[x] transposed
  #
  for(y=H;y&gt;0;y--) {
    for(x=-OOPS;x&lt;=OOPS;x++) {
      if(c=substr(S[x],y,1)) printf c
      else printf &quot; &quot;
    }
    print &quot;&quot;
  }
}
</code></pre>
<p>Output:</p>
<pre><code>                                        *                                      
                                      * *                                      
                                      * *                                      
                                    * * * *                                    
                                    * * * *                                    
                                    * * * *                                    
                                    * * * *                                    
                                  * * * * * *                                  
                                  * * * * * *                                  
                                  * * * * * *                                  
                                  * * * * * *                                  
                                * * * * * * * *                                
                                * * * * * * * *                                
                                * * * * * * * *                                
                                * * * * * * * *                                
                              * * * * * * * * * *                              
                              * * * * * * * * * *                              
                              * * * * * * * * * *                              
                            * * * * * * * * * * *                              
                            * * * * * * * * * * * *                            
                            * * * * * * * * * * * *                            
                          * * * * * * * * * * * * * *                          
*******************************************************************************
</code></pre>
</div>
<div id="pu6" class="pu"><p><H1>C</H1></p>

<p>Based on random walks</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define X_SIZE 40
#define Y_SIZE 15
#define SMOOTH 100

int main(void)
{
int i,j;
int T[X_SIZE*2];
int w;

for (i=0; i&lt;X_SIZE*2; i++) T[i]=0;

// random walks
do  {
    w=X_SIZE;
    for (i=0;i&lt;X_SIZE;i++)
        w+=rand()%2?1:-1;
    T[w]++;
    }
while (T[w]&lt;Y_SIZE*SMOOTH);

// display
for (j=Y_SIZE; j&gt;=0; j--)
    {
    for (i=0; i&lt;X_SIZE*2; i+=2)
        printf("%c", (T[i]&gt;j*SMOOTH)?'#':' ');
    printf("\n");
    }

}
</code></pre>

<p>Output :</p>

<pre><code>               ###
               ###
              #####
              #####
              #####
             #######
             #######
            #########
            #########
            #########
           ###########
           ###########
          #############
         ###############
     #######################
</code></pre>
</div>
<div id="pu7" class="pu"><h2>Python (Box-Muller) - 6 lines</h2>

<p>This short code uses the Box-Muller transform for simulating a normally distributed variable:</p>

<pre><code>from math import cos, log, pi
from random import random

f = open("normDist.txt",'w')
for i in xrange(10**6):
    f.write(str(cos(2*pi*random())*(-2*log(random()))**.5)+'\n')
f.close()
</code></pre>

<p>You can plug the values on GNUPLOT or use this script</p>

<pre><code>f=open("normDist.txt",'r')

v = [0 for i in xrange(51)]
for i in f:
    v[int(float(i)*10) if float(i)&lt;5 and float(i)&gt;-5 else 0]+=1

m=0
for i in v:
    if i&gt;m:
        m=i
for i in v[3:]:
    for j in xrange(int(70.*i/m)):
        print '*',
    print
</code></pre>

<p>to produce something like this:</p>

<pre><code>* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * *
* * * * * * * * * * * * * *
* * * * * * * * * * * *
* * * * * * * * * *
* * * * * * * *
* * * * * * *
* * * * * *
* * * * *
* * * *
* * *
* * *
* *
* *
* *
* *
* *
* *
* * *
* * *
* * * *
* * * * *
* * * * * *
* * * * * * *
* * * * * * * *
* * * * * * * * * *
* * * * * * * * * * * *
* * * * * * * * * * * * * *
* * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
</code></pre>
</div>
<div id="pu8" class="pu"><h2>Wolfram Alpha (tongue-in-cheek) 4 bytes:</h2>

<p>Here is a practical application of the Central Limit Theorem. I even golfed it!</p>

<p>Type this into the input box on Wolfram Alpha:</p>

<pre><code>3d20
</code></pre>

<p><a href="https://www.wolframalpha.com/input/?i=3d20" rel="noreferrer">Here</a> is a link to the results. It interprets this input as 3 icosahedral dice, and decides you want a graph of the distribution function of the pip sums. It prints the following graph:</p>

<p><img src="https://i.sstatic.net/9tfbU.gif" alt="enter image description here"></p>

<p>We can make the graph more and more bell shaped by adding more dice. I don't see this as taking my data from the internet since, if I could run the query engine for it on my home computer I would. Unfortunately, Wolfram Research doesn't provide it for download, though.</p>
</div>
<div id="pu9" class="pu"><h2>Java</h2>

<p>Throwing 6 dice in every possible combination approaches a 'normal distribution', which happens to be a bell curve.</p>

<pre><code>public class Temp {
    public static void main(String[] args) throws Exception {
        int[] hist = new int[31];
        for (int d1 = 0; d1 &lt; 6; d1++)
            for (int d2 = 0; d2 &lt; 6; d2++)
                for (int d3 = 0; d3 &lt; 6; d3++)
                    for (int d4 = 0; d4 &lt; 6; d4++)
                        for (int d5 = 0; d5 &lt; 6; d5++)
                            for (int d6 = 0; d6 &lt; 6; d6++)
                                hist[d1 + d2 + d3 + d4 + d5 + d6]++;
        for (int y = 4104; y &gt;= 0; y -= 228)
            for (int x = 0; x &lt; 32; x++)
                System.out.print(x == 31? '\n' : hist[x] &lt;= y? '\u3000' : (char)('\u2580' + Math.min(Math.ceil((hist[x] - y) / 28.5), 8)));
    }
}
</code></pre>

<p>Some Unicode tricks make the output smoother:</p>

<pre><code>　　　　　　　　　　　　　　▅█▅　　　　　　　　　　　　　　
　　　　　　　　　　　　　▂███▂　　　　　　　　　　　　　
　　　　　　　　　　　　　█████　　　　　　　　　　　　　
　　　　　　　　　　　　▁█████▁　　　　　　　　　　　　
　　　　　　　　　　　　███████　　　　　　　　　　　　
　　　　　　　　　　　　███████　　　　　　　　　　　　
　　　　　　　　　　　▅███████▅　　　　　　　　　　　
　　　　　　　　　　　█████████　　　　　　　　　　　
　　　　　　　　　　　█████████　　　　　　　　　　　
　　　　　　　　　　▇█████████▇　　　　　　　　　　
　　　　　　　　　　███████████　　　　　　　　　　
　　　　　　　　　▃███████████▃　　　　　　　　　
　　　　　　　　　█████████████　　　　　　　　　
　　　　　　　　▁█████████████▁　　　　　　　　
　　　　　　　　███████████████　　　　　　　　
　　　　　　　▃███████████████▃　　　　　　　
　　　　　　　█████████████████　　　　　　　
　　　　　▁███████████████████▁　　　　　
▁▁▁▂▅█████████████████████▅▂▁▁▁
</code></pre>

<p><img src="https://i.sstatic.net/zIoKJ.png" alt="enter image description here"></p>
</div>
<div id="pu10" class="pu"><h2>C#, WPF</h2>

<p>Rough approximation with a hand-crafted Bézier curve. To make it more interesting: No use of <code>Line</code>, <code>Path</code> or similar, only <code>Ellipse</code>.</p>

<p><img src="https://i.sstatic.net/qx3MX.png" alt="Bézier curve"></p>

<pre class="lang-cs prettyprint-override"><code>public MainWindow()
{
    InitializeComponent();
    // Requires a Canvas named Canvas in XAML file
    DrawBellCurve(Canvas, 300, 300);
}

public static void DrawBellCurve(Canvas canvas, int width, int height)
{
    Point p1 = new Point(0, height);
    Point p2 = new Point(0.3 * width, 1 * height);
    Point p3 = new Point(0.4 * width, 0.1 * height);
    Point peak = new Point(width / 2, 0);
    Point p3r = new Point(width - p3.X, p3.Y);
    Point p2r = new Point(width - p2.X, p2.Y);
    Point p1r = new Point(width, height);
    List&lt;Point&gt; controlPoints = new List&lt;Point&gt; { p1, p2, p3, peak, p3r, p2r, p1r };

    DrawBezierCurve(canvas, controlPoints, Color.FromRgb(50, 200, 25));
    DrawPoints(canvas, controlPoints, 5, Color.FromRgb(80, 80, 220));
}

public static void DrawPoints(Canvas canvas, List&lt;Point&gt; points, double radius, Color color)
{
    foreach (var p in points)
    {
        Ellipse ellipse = new Ellipse();
        ellipse.Width = radius;
        ellipse.Height = radius;
        ellipse.SetValue(Canvas.LeftProperty, p.X - radius / 2);
        ellipse.SetValue(Canvas.TopProperty, p.Y - radius / 2);
        ellipse.Fill = new SolidColorBrush(color);
        canvas.Children.Add(ellipse);
    }
}

public static void DrawBezierCurve(Canvas canvas, List&lt;Point&gt; controlPoints, Color color)
{
    var curvePoints = new List&lt;Point&gt;();
    double tStep = 0.01;
    for (double t = 0; t &lt;= 1; t += tStep)
    {
        curvePoints.Add(GetBezierPoint(controlPoints, t));
    }

    DrawPoints(canvas, curvePoints, 3, color);
}

public static Point GetBezierPoint(List&lt;Point&gt; controlPoints, double t)
{
    // De Casteljau's algorithm
    if (controlPoints.Count == 1)
    {
        return controlPoints[0];
    }

    var newControlPoints = new List&lt;Point&gt;();
    for (int i = 0; i &lt; controlPoints.Count - 1; i++)
    {
        Point p1 = controlPoints[i];
        Point p2 = controlPoints[i + 1];
        Point p = new Point(
            t * p1.X + (1 - t) * p2.X,
            t * p1.Y + (1 - t) * p2.Y);
        newControlPoints.Add(p);
    }
    return GetBezierPoint(newControlPoints, t);
}
</code></pre>
</div>
<div id="pu11" class="pu"><h2>Mathematica</h2>
<p>I decided it should not only look like a bell curve, it should look like a bell. So hey, let's spin it around the Z-axis and make it 3D.</p>
<p>And hey, while we're at it, it should <em>sound</em> like a bell as well.</p>
<p>So, each time you evaluate the code, it makes a nice pleasing <a href="http://youtu.be/x54Rbreryic" rel="nofollow noreferrer">church-bell BWONNGGG!</a></p>
<pre class="lang-m prettyprint-override"><code>Manipulate[
 RevolutionPlot3D[PDF[NormalDistribution[mu, sigma], x], {x, -4, 4}, 
  PlotRange -&gt; {Automatic, Automatic, Automatic}, 
  BoxRatios -&gt; {1, 1, 1}, PlotStyle -&gt; {Orange, Yellow}, 
  ImageSize -&gt; {500, 500}], {{mu, 0, &quot;mean&quot;}, -3, 3, 
  Appearance -&gt; &quot;Labeled&quot;}, {{sigma, 1.47, &quot;standard deviation&quot;}, .5, 
  2, Appearance -&gt; &quot;Labeled&quot;}]
EmitSound[Sound[SoundNote[0, 3, &quot;TubularBells&quot;, SoundVolume -&gt; 1]]]
</code></pre>
<p>Here's what it looks like:
<img src="https://i.sstatic.net/uJpsy.jpg" alt="Yo quiero Mathematica Bell!" /></p>
<p>And here's a <a href="http://youtu.be/x54Rbreryic" rel="nofollow noreferrer">brief video of the bell ringing</a>.</p>
</div>
<div id="pu12" class="pu"><h1>Mathematica</h1>
<p>Generating the sums of 5 random integers, each between 0 and 100, 20000 times.</p>
<pre><code>Histogram[Plus @@@ RandomInteger[100, {20000, 5}]]
</code></pre>
<p><img src="https://i.sstatic.net/Q0zhs.png" alt="table" /></p>
<hr />
<p>Here's the result for sums of 1,2, 3 numbers.  As the number of integers to be summed increases, the curve approaches the bell shape.</p>
<p>When single random integers are generated, but not summed, the distribution should be fairly uniform, not favoring any value. The apparent anomaly for 100 may be the result of how Matheamtica bins data. (see <a href="https://mathematica.stackexchange.com/questions/43300/does-randominteger0-n-disfavor-n/43302#43302">https://mathematica.stackexchange.com/questions/43300/does-randominteger0-n-disfavor-n/43302#43302</a> )</p>
<pre><code>Table[Histogram[Plus @@@ RandomInteger[100, {20000, k}]], {k, 1, 3}]
</code></pre>
<p><img src="https://i.sstatic.net/4BMLE.png" alt="enter image description here" /></p>
</div>
<div id="pu13" class="pu"><h2>GeoGebra</h2>

<p>I don't know whether it is valid to use an application that is made to draw graphs, but if you enter this in the input, you get a Bell Curve:</p>

<pre><code>f(x) = 3ℯ^(-(x - 1)²)
</code></pre>

<p>Or, if you want a customizable bell curve:</p>

<pre><code>a = 0
b = 0
c = 0
d = 0
f(x) = a ℯ^((-(x - b)²) / 2 c²) + d
</code></pre>

<p>Then, make sure that you enable the sliders for the variables (if they are disabled, click on the circle next to the variable names). Then, you can set a value for them by sliding.</p>

<p>Image of the curve with the sliders (click to enlarge):</p>

<p><a href="https://i.sstatic.net/pcRql.png" rel="nofollow noreferrer"><img src="https://i.sstatic.net/pcRql.png" alt="GeoGebra Bell Curve"></a></p>
</div>
<div id="pu14" class="pu"><h2>Python</h2>

<pre><code>from pygame import*
t,u=640,400;init();d=display;s=d.set_mode((t,u))
s.fill(0xFFFFFF)
for x in range(t):
  d.flip();event.get()
  draw.line(s,u,(x,int(u-2**(-((x-t*.5)/120)**2)*u)),(x,u))

while time.wait(50):
 for e in event.get():
  if e.type==QUIT:exit()
</code></pre>

<p>This is actually a normal distribution, using <em>2</em> as the base of the exponent instead of <em>e</em>, and not dividing by <em>⎷2π</em>, because without axes, it doesn't really matter if the area under the curve isn't exactly <em>1</em>.</p>

<p><img src="https://i.sstatic.net/eC0w2.png" alt=""></p>

<p>The last 3 lines just keep the window open until the user closes it manually.</p>
</div>
<div id="pu15" class="pu"><h2>Haskell, 9 LoC</h2>

<p>Everyone's code is so ... huge, and their approximations are ... less than deterministic. Just to remind everyone of the simplicity of the actual task, here's a nine-liner in Haskell:</p>

<pre class="lang-haskell prettyprint-override"><code>import Data.List; import Data.Ratio
main = do
  putStrLn "please choose the width and the maximum height:"
  [w, mh] &lt;- (map read.words) `fmap` getLine
  let dist = map length $ group $ sort $ map length $ subsequences [2..w]
      scale = ceiling $ maximum dist % mh
      maxD = scale * ceiling (maximum dist % scale) 
  putStrLn $ unlines $ map (row dist) [maxD, maxD - scale .. 0]
      where row dist y = map (\x -&gt; if x &gt;= y then '*' else ' ') dist
</code></pre>

<p>OK... that wasn't exactly fast. Here's another go. Does it still count as not hard-coded?</p>

<pre><code>import Data.List; import Data.Ratio

main = do
  putStrLn "please choose the width and the maximum height:"
  [w, mh] &lt;- (map read.words) `fmap` getLine
  let dist = map ((w-1) `choose`) [0..(w-1)]
      scale = ceiling $ maximum dist % mh
      maxD = scale * ceiling (maximum dist % scale) 
  putStrLn $ unlines $ map (row dist) [maxD, maxD - scale .. 0]
      where row dist y = map (\x -&gt; if x &gt;= y then '*' else ' ') dist

factorial x = product [1..x]
n `choose` k = factorial n `div` factorial k `div` factorial (n-k)
</code></pre>

<p><img src="https://i.sstatic.net/zdsPF.png" alt="bell curve"></p>
</div>
<div id="pu16" class="pu"><h1>Java</h1>
<p>The method of generation is based off of the game <a href="http://armorgames.com/play/10638/sugar-sugar" rel="noreferrer"><em>Sugar, Sugar</em></a>. In that game, sugar particles fall, traveling randomly left and right. In my program, <code>Dust</code> objects fall until they hit the ground. I collect data based on where they land; this is the bell curve:</p>
<pre class="lang-java prettyprint-override"><code>import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.Random;
import java.util.Stack;
import javax.imageio.ImageIO;

/**
 *
 * @author Quincunx
 */
public class ApproxBellCurve {

    public static final int NUM_DUST = 10_000_000;
    public static final int NUM_THREADS = Runtime.getRuntime().availableProcessors() - 1;
    public static final int LOOP_LIMIT = NUM_DUST / (NUM_THREADS + 1);

    public static void main(String[] args) {
        BufferedImage output = new BufferedImage(2049, 2049, BufferedImage.TYPE_INT_RGB);

        Stack&lt;Thread&gt; threads = new Stack();

        for (int i = 0; i &lt; NUM_THREADS; i++) {
            threads.push(new Thread(new Duster()));
            threads.peek().start();
        }

        Dust d;
        Random r = new Random();
        for (int i = 0; i &lt; LOOP_LIMIT + NUM_DUST - (LOOP_LIMIT * (NUM_THREADS + 1)); i++) {
            d = new Dust(r);
            while (!d.end) {
                d.step();
            }
            if ((i &amp; 1024) == 0) {
                r = new Random();
            }
        }
        while (threads.size() &gt; 0) {
            try {
                threads.pop().join();
            } catch (InterruptedException ex) {

            }
        }
        int maxy = 0;
        for (int x = 0; x &lt; Dust.data.length; x++) {
            maxy = Dust.data[x] &gt; maxy ? Dust.data[x] : maxy;
        }

        for (int x = 0; x &lt; Dust.data.length; x++) {
            for (int y = 0; y &lt; output.getHeight(); y++) {
                output.setRGB(x, y, (y &gt;= output.getHeight() - (Dust.data[x] * output.getHeight() / maxy)) ? 6591981 : 16777215);
            }
        }
        try {
            ImageIO.write(output, &quot;png&quot;, new File(&quot;Filepath&quot;));
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private static class Duster implements Runnable {

        @Override
        public void run() {
            Dust d;
            Random r = new Random();
            for (int i = 0; i &lt; LOOP_LIMIT; i++) {
                d = new Dust(r);
                while (!d.end) {
                    d.step();
                }
                if ((i &amp; 1024) == 0) {
                    r = new Random();
                }
            }
        }

    }

    private static class Dust {

        public static int[] data = new int[2049];

        static {
            for (int i = 0; i &lt; data.length; i++) {
                data[i] = 0;
            }
        }

        private int[] location;
        private Random r;
        public boolean end;

        public Dust(Random rand) {
            location = new int[]{1024, 0};
            r = rand;
            end = false;
        }

        public void step() {
            if (end) {
                return;
            }
            if (location[1] &gt;= 1024) {
                end = true;
                synchronized (data) {
                    data[location[0]] += 1;
                }
                return;
            }
            location[1] += 1;
            location[0] += r.nextInt(21) - 10;
        }
    }
}
</code></pre>
<p>Sample output (took 1 minute to create):</p>
<p><img src="https://i.sstatic.net/idWMb.png" alt="enter image description here" /></p>
<p>Because of the nature of the random number generation, it is possible to get an <code>ArrayIndexOutOfBoundsException</code>.</p>
<p>I used multithreading to speed up the process. The program determines the number of processors available and creates that many threads to run the simulations.</p>
<p>To obtain a finer image, <code>NUM_DUST</code> can be increased, but that would also lead to an increased risk of an <code>ArrayIndexOutOfBoundsException</code>.</p>
<p>Each thread creates a new <code>Random</code> after every 1024 <code>Dust</code> objects are simulated. When that code was removed, the image was more coarse.</p>
<p><code>rand.nextInt(21) - 10</code> is to widen the distribution. A change to <code>rand.nextInt(3) - 1</code> would remove all chance of an <code>ArrayIndexOutOfBoundsException</code>.</p>
</div>
<div id="pu17" class="pu"><h1>Python and tkinter</h1>
<p>I liked Doorknob's generation method and Victor's output (his generation is actually equivalent), so I decided to combine the two with tkinter!</p>
<pre><code>from tkinter import *
import random

bins = [0]*201
for i in range(20000):
    x = 0
    for j in range(100):
        if random.randint(0, 1):
            x += 0.5
        else:
            x -= 0.5
    bins[int(x)+100] += 1

master = Tk()

w = Canvas(master, width = 201, height=200)
w.pack()

for i in range(201):
    w.create_line(i, 200, i, 200-bins[i]/10, fill=&quot;light blue&quot;)
    w.create_line(i-1, 200-bins[i-1]/10, i, 200-bins[i]/10, fill=&quot;blue&quot;)
</code></pre>
<p><img src="https://i.sstatic.net/A38Bg.png" alt="enter image description here" /></p>
</div>
<div id="pu18" class="pu"><h1>Ruby</h1>

<p>Simulates the classic example of bell curves, dropping a ball down a grid full of pole thingies.</p>

<pre><code>a = [0]*30
1000.times do
  x = 15
  49.times do
    x += (rand(3) - 1)
  end
  a[[[x.to_i, 29].min, 0].max] += 1
end
until a.all?{|x| x == 0}
  a.each_with_index{|x,i|
    if x == 0
      print ' '
    else
      print 'x'
      a[i] -= 1
    end
  }
  puts
end
</code></pre>

<p>Sample output:</p>

<pre><code>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
  xxxxxxxxxxxxxxxxxxxxxxxxxx
  xxxxxxxxxxxxxxxxxxxxxxxxxx
  xxxxxxxxxxxxxxxxxxxxxxxxxx
  x xxxxxxxxxxxxxxxxxxxxxxxx
    xxxxxxxxxxxxxxxxxxxxxxxx
    xxxxxxxxxxxxxxxxxxxxxxxx
    xxxxxxxxxxxxxxxxxxxxxxxx
     xxxxxxxxxxxxxxxxxxxxxxx
     xxxxxxxxxxxxxxxxxxxx
     xxxxxxxxxxxxxxxxxxxx
     xxxxxxxxxxxxxxxxxxxx
     xxxxxxxxxxxxxxxxxxxx
     xxxxxxxxxxxxxxxxxxxx
     xxxxxxxxxxxxxxxxxxxx
     xxxxxxxxxxxxxxxxxxxx
     xxxxxxxxxxxxxxxxxxx
      xxxxxxxxxxxxxxxxxx
      xxxxxxxxxxxxxxxxxx
      xxxxxxxxxxxxxxxxxx
      xxxxxxxxxxxxxxxxxx
       xxxxxxxxxxxxxxxxx
        xxxxxxxxxxxxxxxx
        xxxxxxxxxxxxxxxx
        xxxxxxxxxxxxxxx
        xxxxxxxxxxxxxxx
        xxxxxxxxxxxxxxx
        xxxxxxxxxxxxxxx
        xxxxxxxxxxxxxxx
        xxxxxxxxxxxxxxx
        xxxxxxxxxxxxxxx
        xxxxxxxxxxxxxxx
        xxxxxxxxxxxxxx
        xxxxxxxxxxxxxx
         xxxxxxxxxxxxx
         xxxxxxxxxxxxx
         xxxxxxxxxxxxx
         xxxxxxxxxxxxx
         xxxxxxxxxxxxx
         xxxxxxxxxxxxx
         xxxxxxxxxxxx
          xxxxxxxxxxx
          xxxxxxxxxxx
          xxxxxxxxxxx
          xxxxxxxxxxx
           xxxxxxxxxx
           xxxxxxxxxx
           xxxxxxxxxx
           xxxxxxx xx
           xxxxxxx xx
           xxxxxxx xx
            xxxxxx xx
            xxxxxx xx
            xxxxxx x
            xxxxx  x
            xxxxx  x
              xxx  x
              xxx  x
              xxx  x
              xxx  x
              xxx  x
              xxx
              xxx
              xxx
              xxx
              xxx
              xxx
              xxx
              xxx
              xxx
              x x
              x x
              x x
              x x
              x
              x
              x
</code></pre>

<p>Oh, did I forget to mention it's upside down?</p>
</div>
<div id="pu19" class="pu"><h1>Java 8</h1>
<p>It gets the height and the width from the user, chooses <code>width</code> random booleans and count how many are true, registering the counted frequency. Repeat this until some of the generated frequencies is enough to fill the height:</p>
<pre class="lang-java prettyprint-override"><code>import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.util.Random;
import javax.swing.JComponent;
import javax.swing.JFrame;
import javax.swing.JOptionPane;

public class Bell {
    public static int[] bell(int width, int height) {
        // I could have used Random.nextGaussian() method, but this way is more fun.
        Random r = new Random();
        int max = 0;
        int[] freqs = new int[width];
        for (int j = 0; max &lt; height - 1; j++) {
            int count = 0;
            for (int i = 0; i &lt; width; i++) {
                if (r.nextBoolean()) count++;
            }
            freqs[count]++;
            if (freqs[count] &gt; max) max++;
        }
        return freqs;
    }

    public static BufferedImage drawBell(int[] ps, int width, int height) {
        BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
        for (int i = 0; i &lt; width; i++) {
            for (int j = 0; j &lt; ps[i]; j++) {
                bi.setRGB(i, height - j - 1, 0xFF00FFFF); // Cyan
            }
            for (int m = i - 1; m &lt;= i + 1; m++) {
                if (m &lt; 0 || m &gt;= width) continue;
                for (int n = ps[i] - 1; n &lt;= ps[i] + 1; n++) {
                    if (n &lt; 0 || n &gt;= height) continue;
                    bi.setRGB(m, height - n - 1, 0xFF0000FF); // Blue
                }
            }
            for (int j = ps[i] + 1; j &lt; height; j++) {
                bi.setRGB(i, height - j - 1, 0xFFFFFFFF); // White
            }
        }
        return bi;
    }

    public static void main(String[] args) {
        String a = JOptionPane.showInputDialog(&quot;Give the width:&quot;);
        String b = JOptionPane.showInputDialog(&quot;Give the height:&quot;);

        int w, h;
        try {
            w = Integer.parseInt(a);
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(null, &quot;Invalid width.&quot;);
            return;
        }

        try {
            h = Integer.parseInt(b);
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(null, &quot;Invalid height.&quot;);
            return;
        }

        int[] freqs = bell(w, h);
        BufferedImage image = drawBell(freqs, w, h);

        EventQueue.invokeLater(() -&gt; {
            JFrame j = new JFrame(&quot;Bell curve&quot;);
            j.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
            j.add(new SimpleSprite(image));
            j.setResizable(false);
            j.pack();
            j.setVisible(true);
        });
    }

    public static class SimpleSprite extends JComponent {
        private final BufferedImage image;
        private final Dimension dim;

        public SimpleSprite(BufferedImage image) {
            this.image = image;
            this.dim = new Dimension(image.getWidth(), image.getHeight());
        }

        @Override
        public Dimension getMinimumSize() {
            return dim;
        }

        @Override
        public Dimension getMaximumSize() {
            return dim;
        }

        @Override
        public Dimension getPreferredSize() {
            return dim;
        }

        @Override
        public void paintComponent(Graphics g) {
            g.drawImage(image, 0, 0, null);
        }
    }
}
</code></pre>
<p>Screenshot:</p>
<p><img src="https://i.sstatic.net/z2XN9.png" alt="Bell" /></p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/22599/">22599</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




