<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::282217</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td>Further golf</td><td>250619T205045Z</td><td><a href="https://codegolf.stackexchange.com/questions/282217/shortest-brainfck-program-that-loads-prime-numbers-into-memory/282337#282337">Level Ri</a></td></tr>
<tr d-ix="1"><td>203</td><td>203 bytes</td><td>250613T115250Z</td><td><a href="https://codegolf.stackexchange.com/questions/282217/shortest-brainfck-program-that-loads-prime-numbers-into-memory/282265#282265">Level Ri</a></td></tr>
<tr d-ix="2"><td>306</td><td>brainfuck</td><td>250610T025336Z</td><td><a href="https://codegolf.stackexchange.com/questions/282217/shortest-brainfck-program-that-loads-prime-numbers-into-memory/282227#282227">tata</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Further golf, 167 bytes + 8<code>&gt;</code> = 175</h1>
<p>The previous version used trial division by numbers below 13, which meant about 40 bytes were required to hardcode primes <code>5 7 11 13</code> at the beginning of the code and <code>2 3</code> at the end. This version uses adaptive prime division: only the factor 1 is used when checking for the 1st prime, with factors 54 down to 1 being checked for the 54th prime. It is shorter but takes even longer (about 4 times as long) to run. Further explanation soon.</p>
<pre><code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+
&lt;&lt;&lt;++
[a
&gt;&gt;&gt;[-&lt;&lt;&lt;&lt;&lt;+&gt;&gt;&gt;&gt;&gt;]&lt;&lt;&lt;
&lt;&lt;e
[&gt;&gt;f
[&lt;+&lt;-&lt;+&gt;[&lt;]&lt;[&gt;+&lt;-]&gt;&gt;[&gt;]&lt;-]
&lt;[-&gt;+&lt;]
&lt;&lt;[&lt;]&gt;&gt;&gt;[&gt;&gt;+&lt;&lt;&lt;]
&lt;&lt;[-&gt;+&lt;]
&gt;-&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;]g
&gt;&gt;&gt;&gt;-[[-]&lt;]&lt;&lt;
[[-&gt;+&lt;]
 &gt;&gt;&gt;+[&gt;]+[&lt;]&lt;-
 [&gt;&gt;[&gt;]&lt;+[&lt;]&lt;&lt;+&gt;-]
 &lt;+&lt;
]
&gt;+]b
&gt;&gt;&gt;[-]&gt;
</code></pre>
<h1>180 bytes + 7 <code>&gt;</code> = 187, by trial division</h1>
<pre><code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;++++++[-&gt;+&gt;+&gt;++&gt;++&lt;&lt;&lt;&lt;]
&gt;&gt;&gt;&gt;[+&lt;-&lt;]
&lt;&lt;++
[a
&lt;&lt;+++++++++++++e
[&gt;&gt;f
[&lt;+&lt;-&lt;+&gt;[&lt;]&lt;[&gt;+&lt;-]&gt;&gt;[&gt;]&lt;-]
&lt;[-&gt;+&lt;]
&lt;&lt;[&lt;]&gt;&gt;&gt;[&gt;&gt;+&lt;&lt;&lt;]
&lt;&lt;[-&gt;+&lt;]
&gt;-]g
&gt;&gt;&gt;&gt;-[[-]&lt;]&lt;&lt;
[[-&gt;+&lt;]
 &gt;&gt;&gt;[&gt;]+[&lt;]&lt;-
 [&gt;&gt;[&gt;]&lt;+[&lt;]&lt;&lt;+&gt;-]
 &lt;+&lt;
]
&gt;+]b
&gt;++&gt;+++&lt;
</code></pre>
<p>Byte count excludes newlines and comment labels added for readability. Interpreters that do not allow negative cells require seven initial <code>&gt;</code> which are listed separately.</p>
<p>This code has been tested to completion at
<a href="https://esolangpark.vercel.app/ide/brainfuck" rel="nofollow noreferrer">https://esolangpark.vercel.app/ide/brainfuck</a></p>
<p>Delete the hello world program, copy in the code from here, set the delay to zero and hit run. Unfortunately the tape is visualised in signed integers, but these are readily converted to signed integers, for example the last prime found is 256-5 = 251. Runtime several minutes.</p>
<p><strong>Warning: the site appears to use some form of buffering and on my hardware code will not run to completion without hanging due to excessive memory use. Frequent pausing whenever the browser memory use reached 2000MB allowed the memory to recover and I was able to run the code to completion.</strong></p>
<p>Here is a TIO.run link, which runs in less than a second. <a href="https://tio.run/##bZJNbtwwDIX3OgX3gnOAjCCgQDZdFD2AoIVsczxCPJRhyUnay09JOs5MgHJ@ZIHko/Q992vKdN6G19vNaoTOW/nI13FE4zmCdR0/OmetCbo8hAnem@CkxPrgoguenyN3@circaKp3ZwUMe@tKrsj47t9TBdCF1nAmXBkVMWKaidzRFJ3PEqkrTNcZOUnJ7buJhXwq7whLCVTwxXOa7lCj1MmyjRBOcOca4NWAGk8tiYAx@8FCeZSFkiS2tqyNaDt2uNaIROMOORrmmGrojSUEXd1rGVONFUD4P2dzH5Bvhb/@cgUgyCKunMaQklQPTZxz2MHa35vintL8IdjX3ZwwZOQsVLBPqiUi3dnD8dYMvonLXL/VREfnAGNH8zqggpL1h2H4OuZ8SqMR7ikCleGztAIoS5pQFjzdGnPnyIvBag0Rrb8gT4Nr9JfuCIT4xxwnmFh0dqYe1pHGfbp1YFWaR9qP6k2TCP8xbXooUThtJ8GCN/nTHj6noU08at@UmPlpDDjWV8Cwo/D42cV5xl8/bshO4x4@wc" rel="nofollow noreferrer" title="brainfuck – Try It Online">Try it online!</a>
The code itself produces no output. The footer produces decimal output to enable verification, and is adapted from this link <a href="https://esolangs.org/wiki/Brainfuck_algorithms#Print_value_of_cell_x_as_number_(8-bit)" rel="nofollow noreferrer">https://esolangs.org/wiki/Brainfuck_algorithms#Print_value_of_cell_x_as_number_(8-bit)</a></p>
<h1>Motivation: I thought this question deserved a fully algorithmic answer.</h1>
<p>I considered prime sieves but they seemed too cumbersome to implement. Another algorithm that might work is finding greatest common divisors. For example the numbers 2 x 7 x 11 = 154 and 3 x 5 x 13 = 195 cover all six prime factors that need to be checked. By finding the greatest common divisor of these numbers (for example using Euclid's method of successive subtraction) you could check 3 primes at once.</p>
<p>I picked trial division because it is easily scalable to any size. Versions of BF using cells larger than 8-bit should be able to run this code with out issue (though it is designed to stop when it reaches 256.)</p>
<p>Trial division is carried out with factors up to 13. This is enough to prove any number below <code>17**2</code> = 289 is prime, since any non-prime number below 289 must have a prime factor less than 17.</p>
<p><strong>Faster version, 183 bytes + 7 <code>&gt;</code> = 190</strong></p>
<p>This version works 4 times faster as it only generates odd numbers and compares them to odd divisors. This is achieved by counting by 2 on each loop, by modifying both the test number and the divisor both at the beginnning and at the end of the relevant code. The test number is incremented at <code>a</code> and <code>b</code> and the divisor is decremented at <code>f</code> and <code>g</code>. The divisor therefore needs to start at 14 not 13, so there is an additional <code>+</code> at <code>e</code></p>
<p>I can run this at <a href="https://esolangpark.vercel.app/ide/brainfuck" rel="nofollow noreferrer">https://esolangpark.vercel.app/ide/brainfuck</a> in a single step in a little over a minute without needing to pause to allow the memory to recover, though usage does hit close to 4000MB.</p>
<pre><code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;++++++[-&gt;+&gt;+&gt;++&gt;++&lt;&lt;&lt;&lt;]
&gt;&gt;&gt;&gt;[+&lt;-&lt;]
&lt;&lt;++
[+a
&lt;&lt;++++++++++++++e
[-&gt;&gt;f
[&lt;+&lt;-&lt;+&gt;[&lt;]&lt;[&gt;+&lt;-]&gt;&gt;[&gt;]&lt;-]
&lt;[-&gt;+&lt;]
&lt;&lt;[&lt;]&gt;&gt;&gt;[&gt;&gt;+&lt;&lt;&lt;]
&lt;&lt;[-&gt;+&lt;]
&gt;-]g
&gt;&gt;&gt;&gt;-[[-]&lt;]&lt;&lt;
[[-&gt;+&lt;]
 &gt;&gt;&gt;[&gt;]+[&lt;]&lt;-
 [&gt;&gt;[&gt;]&lt;+[&lt;]&lt;&lt;+&gt;-]
 &lt;+&lt;
]
&gt;+]b
&gt;++&gt;+++&lt;
</code></pre>
<p><strong>Explanation</strong></p>
<p>The code starts by forming a foundation for the prime list by adding <code>6 6 12 12</code> to the tape and modifying to <code>5 7 11 13</code>.  It then goes through all numbers starting at <code>N</code>=2 and ending at 255 (after which it wraps round to zero) testing if these numbers are divisible by the natural numbers <code>D</code>=13 or less. The first two primes <code>2 3</code> are added to the beginning of the list at the end of the program.</p>
<p>The tape when searching for a prime looks like this. The three zero cells are necessary for the flow control of the modulo operation.</p>
<pre><code> 0  0
 1  0
 2  d  Copy of D
 3  D  The divisor being checked
 4  n  Copy of N
 5  N  The number being checked
 6  0
 7  F  How many factors found so far
 8  5
 9  7
10 11
11 13
12 ... Continuation of prime list
</code></pre>
<p>The trial division (more accurately called trial modulo) is carried out using the following algorithm. It's copied from <a href="https://esolangs.org/wiki/Brainfuck_algorithms#Modulo" rel="nofollow noreferrer">https://esolangs.org/wiki/Brainfuck_algorithms#Modulo</a> except that the tape is run in reverse.</p>
<pre><code>[&lt;+     Increment n
 &lt;-     Decrement D
 &lt;+     Increment d
 &gt;[&lt;]&lt;  If D=0 move to d; otherwise move two cells further left
 [&gt;+&lt;-] If at d; copy the contents of d back to D 
 &gt;&gt;[&gt;]&lt; Move back to N
-]      Decrement N and exit if it reaches zero
</code></pre>
<p>This moves the number being tested from Cell 5 <code>N</code> to cell 4 <code>n</code>. We move it back to cell 5, then check if cell 3 <code>d</code> is zero. If it is, we increment the factor counter <code>F</code> in cell 7. <code>d+D</code> still adds up to the current divisor, so we move any data in <code>d</code> back to <code>D</code>, then reduce it to carry out the next divisor check.</p>
<p>Divisor checks are carried out all the way down to divisor of 1. Testing divisibility with 1 always gives a positive result, even for primes. So when the divisor reaches zero, we reduce the value of <code>F</code> by 1. If it is still nonzero the number is composite, so we zero F and move to cell 4. We then move onto the next value of <code>N</code>, incrementing cell 5.</p>
<p>If <code>F</code> is zero we have found a new prime. We copy <code>N</code> from cell 5 to cell 6. Then we add a 1 to the end of the prime list to mark where we are going to store the new prime*. We then increment both the cell where the new prime is to be stored and cell 5, and decrement cell 6, until cell 6 is depleted, thereby copying N back to cell 5 and simultaneously to the end of the prime list.</p>
<p>*In order to avoid overshooting the number in the prime list by 1, we temporarily reduce <code>N</code> by 1. We add this 1 back on at the end of the prime-copying code, leaving the pointer in cell 4.</p>
<p><strong>Commented code - based on the fast version</strong></p>
<pre><code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;++++++[-&gt;+&gt;+&gt;++&gt;++&lt;&lt;&lt;&lt;]  Put 6 6 12 12 on the tape
&gt;&gt;&gt;&gt;[+&lt;-&lt;]                      Modify to 5 7 11 13
&lt;&lt;++                            Move to cell 5 and set to N=2
[+a                             Open loop Increment N by 1
&lt;&lt;++++++++++++++e               Set divisor D to 14
[-&gt;&gt;f                           Open loop Decrement D by 1 and start looking for factors
[&lt;+&lt;-&lt;+&gt;[&lt;]&lt;[&gt;+&lt;-]&gt;&gt;[&gt;]&lt;-]      Modulo algorithm as described above
&lt;[-&gt;+&lt;]                         Move n in cell 4 back to N in cell 5
&lt;&lt;[&lt;]&gt;&gt;&gt;                        If cell 2 is nonzero stay in vacant cell 4; if zero move to occupied cell 5
[&gt;&gt;+&lt;&lt;&lt;]                        If in cell 5 add 1 to F in cell 7 then move to occupoied cell 4
&lt;&lt;[-&gt;+&lt;]                        Move d from cell 2 back to cell 3 to regenerate divisor D  
&gt;-]g                            Subtract 1 from divisor D again and loop until D zero
&gt;&gt;&gt;&gt;-[[-]&lt;]&lt;&lt;                   Move to F in cell 7; if nonzero clear the cell and move back to vacant cell 4; if zero mover to occupied cell 5
[[-&gt;+&lt;]                         IF in cell 5 we must record prime: move value N to cell 6
 &gt;&gt;&gt;[&gt;]+[&lt;]&lt;-                   Put a 1 at the end of the prime list and delete 1 from N 
 [&gt;&gt;[&gt;]&lt;+[&lt;]&lt;&lt;+&gt;-]              Deplete cell 6 and add N-1 to both end of prime list and cell 5           
 &lt;+&lt;                            Add 1 back to cell 5 and exit IF by leaving pointer in vacant cell 4
] 
&gt;+]b                            Increment N by 1 again 
&gt;++&gt;+++&lt;                        If N wraps round to 256=0 finish the tape with 2 3 and exit
</code></pre>
</div>
<div id="pu1" class="pu"><h1>203 bytes</h1>
<p>(excluding newlines added for readability)</p>
<p>Major edit to my previous code. The first loop not only fills the tape with the numbers 43 downto 1 and 251 downto 5, but also adds <code>200 150 100 50</code> to the beginning of the tape. There is no 5-iteration loop. Instead the 50-iteration loop is reduced to 25 iterations and serves only to make the transformations <code>25&gt;75</code> and <code>35&gt;60</code>. Other transformations are done with long strings of <code>+</code> or <code>-</code>. The long strings look awkward but it removes the need for a lot of awkward setup and reconstruction code around <code>2 251</code>.</p>
<pre><code>-[-----&gt;+&lt;]&gt;-
[&gt;++++&gt;+++&gt;++&gt;+&gt;[++++++&gt;]+++++[&lt;]&gt;-]
&gt;-&gt;+&gt;+&gt;[&gt;&gt;&gt;&gt;++[&gt;]&lt;&lt;&lt;&lt;&lt;&lt;+[&lt;]&gt;&gt;&gt;&gt;--]+++
&gt;&gt;&gt;&gt;--&gt;&gt;&gt;&gt;+&gt;&gt;++++&gt;&gt;&gt;++&gt;++&gt;++++++++++++&gt;
++&gt;----------&gt;&gt;&gt;----&gt;&gt;&gt;&gt;++&gt;++&gt;&gt;----&gt;&gt;&gt;
++&gt;----------&gt;&gt;&gt;++&gt;++&gt;&gt;&gt;++&gt;&gt;++&gt;&gt;&gt;&gt;&gt;+
[&gt;]&lt;

-[-----&gt;+&lt;]&gt;-                           Put 255/5=51 in cell 1 and reduce to 50
[&gt;++++&gt;+++&gt;++&gt;+&gt;[++++++&gt;]+++++[&lt;]&gt;-]    Setup 200 150 100 50 followed by 43 downto 1 then 251 downto 5 
&gt;-&gt;+&gt;+&gt;                                 Adjust to 199 151 101
[&gt;&gt;&gt;&gt;++[&gt;]&lt;&lt;&lt;&lt;&lt;&lt;+[&lt;]&gt;&gt;&gt;&gt;--]+++          Iterate 25 times boosting 25 &amp; 35 to 75 &amp; 60; put 3 in depleted counter cell
&gt;&gt;&gt;&gt;--&gt;&gt;&gt;&gt;+&gt;&gt;++++&gt;&gt;&gt;++&gt;++&gt;++++++++++++&gt; Tweak the rest of the tape
++&gt;----------&gt;&gt;&gt;----&gt;&gt;&gt;&gt;++&gt;++&gt;&gt;----&gt;&gt;&gt;
++&gt;----------&gt;&gt;&gt;++&gt;++&gt;&gt;&gt;++&gt;&gt;++&gt;&gt;&gt;&gt;&gt;+
[&gt;]&lt;                                    Move pointer to end
</code></pre>
<h1><s>247 220</s> 215 bytes</h1>
<p>(excluding newlines added for readability)</p>
<p>Latest edit saves 5 bytes with a modification of the 5-iteration loop. 4th line from bottom. String of 14 <code>&gt;</code> to access the cell with initial value 35 is replaced by <code>[&gt;]&lt;&lt;&lt;&lt;&lt;&lt;</code> (go to end of data then backtrack 6.)</p>
<pre><code>&gt;-[-----&gt;+&lt;]&gt;
[&gt;[++++++&gt;]+++++[&lt;]&gt;-]&gt;
+[-&lt;++&lt;+++&lt;++++&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;]
&lt;&lt;&lt;-&gt;+&gt;+&gt;+++
&gt;&gt;&gt;&gt;--&gt;&gt;&gt;&gt;
-&gt;[&gt;-&gt;&gt;&gt;&gt;&gt;++&gt;&gt;--&gt;&gt;&gt;-&gt;&gt;&gt;&gt;&gt;&gt;&gt;-&gt;&gt;&gt;&gt;--
[&gt;]&lt;&lt;&lt;&lt;&lt;&lt;+++++[&lt;]&gt;+]
&lt;++&gt;-----&gt;+&gt;&gt;&gt;++&gt;++&gt;++&gt;++&gt;&gt;&gt;&gt;+&gt;&gt;&gt;&gt;++
&gt;++&gt;&gt;+&gt;&gt;&gt;++&gt;&gt;&gt;&gt;++&gt;++&gt;&gt;&gt;++&gt;&gt;++&gt;&gt;&gt;&gt;&gt;+
[&gt;]&lt;
</code></pre>
<p>Copy and paste into <a href="https://minond.xyz/brainfuck/" rel="nofollow noreferrer">https://minond.xyz/brainfuck/</a> to try. Delete the example hello world program and set the iteration evaluation delay to 0. It will take about a minute to run like this.</p>
<p>This answer uses the following observations: all prime numbers except 2&amp;3 are 1 less or more than a multiple of 6; and primes get sparser as numbers get higher.</p>
<p>We start by setting a cell to 51, then use this to iterate 51 times generating every 6th number of the form <code>6n+1</code> from 49 down to 1, wrapping round to 251 then down through all numbers of the form <code>6n-1</code> until we reach 5. We then adjust these to make the primes.</p>
<p>Most of these numbers are either prime already or can be tweaked to a prime by adding 2. for primes under 47 we have two numbers generated (<code>6n-1</code> and <code>6n+1</code>) so there is nothing to do. For numbers above 47 we have only <code>6n-1</code>. Some of these are prime, while others can be made prime by adding 2. In some cases we have a choice of either. In that case we select whichever prime is more difficult to generate in another way. The other prime (the easier one) is generated by adjusting another number which is neither prime nor can be made prime by adding 2. There is a loop that runs for 5 iterations to do this, crudely adjusting the numbers to be close to their targets. Cells are then tweaked at the end of the program.</p>
<p>The first step does not generate sufficient initial values to generate all the primes by adjustment as described above. Therefore, the first number 49 (plus 1) is used as a loop counter to generate three primes which are close to multiples of 50: <code>199,151,101</code>. This code also adjusts 25 to 75, which is then tweaked to <code>73</code>.</p>
<p>Below shows the initial and final states of the tape. Numbers that are left alone or adjusted by 2 are marked with <code>=</code> or <code>++</code>. Other numbers are marked with the size of the adjustment. Numbers that are created in other ways are marked with <code>()</code>. These include <code>199, 151, 101</code> which are generated by the 50-iteration loop, as well as <code>3</code> which is made by adjusting the depleted counter cell for this loop. The numbers <code>1</code> and <code>251</code> are generated by the initial loop but <code>1</code> is reduced back to zero to act as a pointer stop for the 5-iteration loop and <code>251</code> is used as the upcounter, so <code>251</code> and <code>2</code> have to be regenerated once the 5-iteration loop is finished.</p>
<p><strong>Initial state of tape (after 2nd line of code) and final state</strong></p>
<pre><code>   0   0   0 49 43 37 31  25 19 13  7  1 251 245 239 233 227 221 215 209 203 197 191 185 179 173 167 161 155 149 143 137 131 125 119 113 107 101 95 89 83 77 71 65 59 53 47 41  35 29 23 19 11 5
                 =  =  = +48  =  =  =         -4   =   =  ++  ++ +12  ++ -10   =   =  -4   =   =   =  ++  ++   =  -4   =   =  ++ -10   =   =  ++ ++  =  = ++  = ++  =  =  =  = +26  =  =  =  = =
(199 151 101 3) 43 37 31  73 19 13  7 (2 251)241 239 233 229 223 227 211 193 197 191 181 179 173 167 163 157 149 139 137 131 127 109 113 107 103 97 89 83 79 71 67 59 53 47 41  61 29 23 17 11 5
</code></pre>
<p><strong>Commented code (220 byte version)</strong></p>
<pre><code>&gt;-[-----&gt;+&lt;]&gt;                         Put 255 in cell 1 and iterate 255/5 times to put 51 in cell 2
[&gt;[++++++&gt;]+++++[&lt;]&gt;-]&gt;               Iterate 51 times building a sequence from 49 down to 1 then 251 down to 5
+[-&lt;++&lt;+++&lt;++++&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;]          Iterate 50 times to make 200 150 100 and boost 25 to 75  
&lt;&lt;-&lt;+&gt;&gt;+&gt;+++                          Adjust 1st 4 cells to 199 151 101 3 
&gt;&gt;&gt;&gt;--&gt;&gt;&gt;&gt;-&gt;                          Adjust 75 to 73; adjust 1 to zero to act as a pointer stop; leave pointer at 251
[&gt;-&gt;&gt;&gt;&gt;&gt;++&gt;&gt;--&gt;&gt;&gt;-&gt;&gt;&gt;&gt;&gt;&gt;&gt;-&gt;&gt;&gt;&gt;--      Iterate 5 times to adjust certain cells by multiples of 5 increasing 251 to 256
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+++++[&lt;]&gt;+]             Use the zero cell to catch the leftbound pointer at the end of each iteration 
&lt;++&gt;-----&gt;+&gt;&gt;&gt;++&gt;++&gt;++&gt;++&gt;&gt;&gt;&gt;+&gt;&gt;&gt;&gt;++  Adjust zero to 2 and 256=0 back to 251; tweak remaining cells as necessary
&gt;++&gt;&gt;+&gt;&gt;&gt;++&gt;&gt;&gt;&gt;++&gt;++&gt;&gt;&gt;++&gt;&gt;++&gt;&gt;&gt;&gt;&gt;+
[&gt;]&lt;                                  Move pointer to end
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/TryItOnline/brainfuck" rel="nofollow noreferrer">brainfuck</a>, 306 bytes</h1>
<pre><code>&gt;&gt;&gt;+[[&gt;+&gt;+&lt;&lt;-]&gt;&gt;[-&lt;&lt;+&gt;&gt;]&lt;+++++]&lt;&lt;[--------&lt;]&lt;&lt;++&gt;+++&gt;+++++&gt;++++++++++++++&gt;+++++++++++++&gt;++++++++++&gt;+++++++++&gt;++++++&gt;+++++&gt;++++++&gt;+++&gt;++++&gt;+++&gt;&gt;-&gt;&gt;+&gt;--&gt;-&gt;--&gt;-----&gt;----&gt;-----&gt;----&gt;-&gt;--&gt;-----&gt;------&gt;---------&gt;----------&gt;-&gt;--&gt;-&gt;----&gt;+&gt;--&gt;-&gt;&gt;-&gt;&gt;+&gt;--&gt;+++&gt;&gt;-&gt;----&gt;+++&gt;++++++++++&gt;+++++++++&gt;++++++&gt;+++++&gt;++++++&gt;+++&gt;
</code></pre>
<p><a href="https://tio.run/##lU5bCoAwDDtQqScIuUjZhwqCCH4Inr9ubCtM8MNA04Q@l2vez@1eD3eSYkahAJpIU0DIBClIgGkDspHcV6NzgF@Ob8W3YQhqfoeqORcqYFCXYynSoHpbHWkrY3s7VWt/n3WbkPwB" rel="nofollow noreferrer" title="brainfuck – Try It Online">Try it online!</a></p>
<ol>
<li>Initialize with sequence</li>
</ol>
<blockquote>
<p><code>[0, 0, 0, 1, 6, 11, 16, 21, 26, ..., 241, 246, 251, 0]</code></p>
</blockquote>
<ol start="2">
<li>Substitute 8 for cells in the middle</li>
</ol>
<blockquote>
<p><code>[0, 0, 0, 249, 254, 3, 8, 13, 18, ..., 233, 238, 251, 0]</code></p>
</blockquote>
<ol start="3">
<li>Adjust each cell to its target value one by one</li>
</ol>
<blockquote>
<p><code>[2, 3, 5, 7, ... 241, 251]</code></p>
</blockquote>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/282217/">282217</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




