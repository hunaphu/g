<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::282217</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td>192 bytes</td><td>250619T205045Z</td><td><a href="https://codegolf.stackexchange.com/questions/282217/shortest-brainfck-program-that-loads-prime-numbers-into-memory/282337#282337">Level Ri</a></td></tr>
<tr d-ix="1"><td>203</td><td>203 bytes</td><td>250613T115250Z</td><td><a href="https://codegolf.stackexchange.com/questions/282217/shortest-brainfck-program-that-loads-prime-numbers-into-memory/282265#282265">Level Ri</a></td></tr>
<tr d-ix="2"><td>306</td><td>brainfuck</td><td>250610T025336Z</td><td><a href="https://codegolf.stackexchange.com/questions/282217/shortest-brainfck-program-that-loads-prime-numbers-into-memory/282227#282227">tata</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>192 bytes, by trial division</h1>
<p>(byte count excludes newlines and comment labels added for readability)</p>
<p>I thought this question deserved a fully algorithmic answer. I considered sieves but they seemed too cumbersome to implement. Another algorithm that might work is finding greatest common divisors. For example the numbers 2 x 7 x 11 = 154 and 3 x 5 x 13 = 195 cover all six prime factors that need to be checked. By finding the greatest common divisor of these numbers (for example using Euclid's method of successive subtraction) you could check 3 primes at once.</p>
<p>I picked trial division because it is easily scalable to any size Versions of BF using cells larger than 8-bit should be able to run this code with out issue (though it is designed to stop when it reaches 256.)</p>
<p>Trial division is carried out with factors up to 13. This is enough to prove any number below <code>17**2</code> = 289 is prime, since any non-prime number below 289 must have a prime factor less than 17.</p>
<p>This version only generates odd numbers and compares them to odd factors, to enhance speed. This is achieved by counting by 2 on each loop, by modifying both the test number and the factor counter both at the beginnning and at the end of the relevant code. The test number is incremented at <code>a</code> and <code>b</code> and the factor counter is decremented at <code>f</code> and <code>g</code>. Deleting the <code>+</code> at <code>a</code> and <code>-</code> at 4 would save 2 bytes but make the code run 4 times slower.</p>
<p>The code is nonetheless expected to take several hours to run at <a href="https://%20https://minond.xyz/brainfuck/" rel="nofollow noreferrer"> https://minond.xyz/brainfuck/</a> and is currently under its first trial run. <a href="https://esolangpark.vercel.app/ide/brainfuck" rel="nofollow noreferrer">https://esolangpark.vercel.app/ide/brainfuck</a> is much quicker (less than a minute) but uses signed instead of unsigned integers. The contents of the tape are correct though.</p>
<p>The primes <code>5 7 11 13</code> are generated at the beginning, hardcoded style, to provide a foundation for the prime list. <code>2 3</code> are added at the end.</p>
<p>Explanation to follow shortly.</p>
<pre><code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;++++++[-&gt;+&gt;+&gt;++&gt;++&lt;&lt;&lt;&lt;]
&gt;&gt;&gt;&gt;[+&lt;-&lt;]
&lt;&lt;++
[+a
&lt;&lt;++++++++++++++
[-&gt;&gt;f
[&lt;+&lt;-&lt;+&gt;[&lt;]&lt;[&gt;+&lt;-]&gt;&gt;[&gt;]&lt;-]
&lt;[-&gt;+&lt;]
&lt;&lt;[&lt;]&gt;&gt;&gt;[&gt;&gt;+&lt;&lt;&lt;]
&lt;&lt;[-&gt;+&lt;]
&gt;-]g
&gt;&gt;&gt;&gt;-[[-]&lt;]&lt;&lt;
[
 &gt;&gt;&gt;[&gt;]+[&lt;]&lt;&lt;-
 [&gt;&gt;&gt;[&gt;]&lt;+[&lt;]&lt;&lt;&lt;+&gt;-]+
 &lt;[-&gt;+&lt;]
]
&gt;+]b
&gt;++&gt;+++&lt;
</code></pre>
</div>
<div id="pu1" class="pu"><h1>203 bytes</h1>
<p>(excluding newlines added for readability)</p>
<p>Major edit to my previous code. The first loop not only fills the tape with the numbers 43 downto 1 and 251 downto 5, but also adds <code>200 150 100 50</code> to the beginning of the tape. There is no 5-iteration loop. Instead the 50-iteration loop is reduced to 25 iterations and serves only to make the transformations <code>25&gt;75</code> and <code>35&gt;60</code>. Other transformations are done with long strings of <code>+</code> or <code>-</code>. The long strings look awkward but it removes the need for a lot of awkward setup and reconstruction code around <code>2 251</code>.</p>
<pre><code>-[-----&gt;+&lt;]&gt;-
[&gt;++++&gt;+++&gt;++&gt;+&gt;[++++++&gt;]+++++[&lt;]&gt;-]
&gt;-&gt;+&gt;+&gt;[&gt;&gt;&gt;&gt;++[&gt;]&lt;&lt;&lt;&lt;&lt;&lt;+[&lt;]&gt;&gt;&gt;&gt;--]+++
&gt;&gt;&gt;&gt;--&gt;&gt;&gt;&gt;+&gt;&gt;++++&gt;&gt;&gt;++&gt;++&gt;++++++++++++&gt;
++&gt;----------&gt;&gt;&gt;----&gt;&gt;&gt;&gt;++&gt;++&gt;&gt;----&gt;&gt;&gt;
++&gt;----------&gt;&gt;&gt;++&gt;++&gt;&gt;&gt;++&gt;&gt;++&gt;&gt;&gt;&gt;&gt;+
[&gt;]&lt;

-[-----&gt;+&lt;]&gt;-                           Put 255/5=51 in cell 1 and reduce to 50
[&gt;++++&gt;+++&gt;++&gt;+&gt;[++++++&gt;]+++++[&lt;]&gt;-]    Setup 200 150 100 50 followed by 43 downto 1 then 251 downto 5 
&gt;-&gt;+&gt;+&gt;                                 Adjust to 199 151 101
[&gt;&gt;&gt;&gt;++[&gt;]&lt;&lt;&lt;&lt;&lt;&lt;+[&lt;]&gt;&gt;&gt;&gt;--]+++          Iterate 25 times boosting 25 &amp; 35 to 75 &amp; 60; put 3 in depleted counter cell
&gt;&gt;&gt;&gt;--&gt;&gt;&gt;&gt;+&gt;&gt;++++&gt;&gt;&gt;++&gt;++&gt;++++++++++++&gt; Tweak the rest of the tape
++&gt;----------&gt;&gt;&gt;----&gt;&gt;&gt;&gt;++&gt;++&gt;&gt;----&gt;&gt;&gt;
++&gt;----------&gt;&gt;&gt;++&gt;++&gt;&gt;&gt;++&gt;&gt;++&gt;&gt;&gt;&gt;&gt;+
[&gt;]&lt;                                    Move pointer to end
</code></pre>
<h1><s>247 220</s> 215 bytes</h1>
<p>(excluding newlines added for readability)</p>
<p>Latest edit saves 5 bytes with a modification of the 5-iteration loop. 4th line from bottom. String of 14 <code>&gt;</code> to access the cell with initial value 35 is replaced by <code>[&gt;]&lt;&lt;&lt;&lt;&lt;&lt;</code> (go to end of data then backtrack 6.)</p>
<pre><code>&gt;-[-----&gt;+&lt;]&gt;
[&gt;[++++++&gt;]+++++[&lt;]&gt;-]&gt;
+[-&lt;++&lt;+++&lt;++++&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;]
&lt;&lt;&lt;-&gt;+&gt;+&gt;+++
&gt;&gt;&gt;&gt;--&gt;&gt;&gt;&gt;
-&gt;[&gt;-&gt;&gt;&gt;&gt;&gt;++&gt;&gt;--&gt;&gt;&gt;-&gt;&gt;&gt;&gt;&gt;&gt;&gt;-&gt;&gt;&gt;&gt;--
[&gt;]&lt;&lt;&lt;&lt;&lt;&lt;+++++[&lt;]&gt;+]
&lt;++&gt;-----&gt;+&gt;&gt;&gt;++&gt;++&gt;++&gt;++&gt;&gt;&gt;&gt;+&gt;&gt;&gt;&gt;++
&gt;++&gt;&gt;+&gt;&gt;&gt;++&gt;&gt;&gt;&gt;++&gt;++&gt;&gt;&gt;++&gt;&gt;++&gt;&gt;&gt;&gt;&gt;+
[&gt;]&lt;
</code></pre>
<p>Copy and paste into <a href="https://minond.xyz/brainfuck/" rel="nofollow noreferrer">https://minond.xyz/brainfuck/</a> to try. Delete the example hello world program and set the iteration evaluation delay to 0. It will take about a minute to run like this.</p>
<p>This answer uses the following observations: all prime numbers except 2&amp;3 are 1 less or more than a multiple of 6; and primes get sparser as numbers get higher.</p>
<p>We start by setting a cell to 51, then use this to iterate 51 times generating every 6th number of the form <code>6n+1</code> from 49 down to 1, wrapping round to 251 then down through all numbers of the form <code>6n-1</code> until we reach 5. We then adjust these to make the primes.</p>
<p>Most of these numbers are either prime already or can be tweaked to a prime by adding 2. for primes under 47 we have two numbers generated (<code>6n-1</code> and <code>6n+1</code>) so there is nothing to do. For numbers above 47 we have only <code>6n-1</code>. Some of these are prime, while others can be made prime by adding 2. In some cases we have a choice of either. In that case we select whichever prime is more difficult to generate in another way. The other prime (the easier one) is generated by adjusting another number which is neither prime nor can be made prime by adding 2. There is a loop that runs for 5 iterations to do this, crudely adjusting the numbers to be close to their targets. Cells are then tweaked at the end of the program.</p>
<p>The first step does not generate sufficient initial values to generate all the primes by adjustment as described above. Therefore, the first number 49 (plus 1) is used as a loop counter to generate three primes which are close to multiples of 50: <code>199,151,101</code>. This code also adjusts 25 to 75, which is then tweaked to <code>73</code>.</p>
<p>Below shows the initial and final states of the tape. Numbers that are left alone or adjusted by 2 are marked with <code>=</code> or <code>++</code>. Other numbers are marked with the size of the adjustment. Numbers that are created in other ways are marked with <code>()</code>. These include <code>199, 151, 101</code> which are generated by the 50-iteration loop, as well as <code>3</code> which is made by adjusting the depleted counter cell for this loop. The numbers <code>1</code> and <code>251</code> are generated by the initial loop but <code>1</code> is reduced back to zero to act as a pointer stop for the 5-iteration loop and <code>251</code> is used as the upcounter, so <code>251</code> and <code>2</code> have to be regenerated once the 5-iteration loop is finished.</p>
<p><strong>Initial state of tape (after 2nd line of code) and final state</strong></p>
<pre><code>   0   0   0 49 43 37 31  25 19 13  7  1 251 245 239 233 227 221 215 209 203 197 191 185 179 173 167 161 155 149 143 137 131 125 119 113 107 101 95 89 83 77 71 65 59 53 47 41  35 29 23 19 11 5
                 =  =  = +48  =  =  =         -4   =   =  ++  ++ +12  ++ -10   =   =  -4   =   =   =  ++  ++   =  -4   =   =  ++ -10   =   =  ++ ++  =  = ++  = ++  =  =  =  = +26  =  =  =  = =
(199 151 101 3) 43 37 31  73 19 13  7 (2 251)241 239 233 229 223 227 211 193 197 191 181 179 173 167 163 157 149 139 137 131 127 109 113 107 103 97 89 83 79 71 67 59 53 47 41  61 29 23 17 11 5
</code></pre>
<p><strong>Commented code (220 byte version)</strong></p>
<pre><code>&gt;-[-----&gt;+&lt;]&gt;                         Put 255 in cell 1 and iterate 255/5 times to put 51 in cell 2
[&gt;[++++++&gt;]+++++[&lt;]&gt;-]&gt;               Iterate 51 times building a sequence from 49 down to 1 then 251 down to 5
+[-&lt;++&lt;+++&lt;++++&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;]          Iterate 50 times to make 200 150 100 and boost 25 to 75  
&lt;&lt;-&lt;+&gt;&gt;+&gt;+++                          Adjust 1st 4 cells to 199 151 101 3 
&gt;&gt;&gt;&gt;--&gt;&gt;&gt;&gt;-&gt;                          Adjust 75 to 73; adjust 1 to zero to act as a pointer stop; leave pointer at 251
[&gt;-&gt;&gt;&gt;&gt;&gt;++&gt;&gt;--&gt;&gt;&gt;-&gt;&gt;&gt;&gt;&gt;&gt;&gt;-&gt;&gt;&gt;&gt;--      Iterate 5 times to adjust certain cells by multiples of 5 increasing 251 to 256
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+++++[&lt;]&gt;+]             Use the zero cell to catch the leftbound pointer at the end of each iteration 
&lt;++&gt;-----&gt;+&gt;&gt;&gt;++&gt;++&gt;++&gt;++&gt;&gt;&gt;&gt;+&gt;&gt;&gt;&gt;++  Adjust zero to 2 and 256=0 back to 251; tweak remaining cells as necessary
&gt;++&gt;&gt;+&gt;&gt;&gt;++&gt;&gt;&gt;&gt;++&gt;++&gt;&gt;&gt;++&gt;&gt;++&gt;&gt;&gt;&gt;&gt;+
[&gt;]&lt;                                  Move pointer to end
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/TryItOnline/brainfuck" rel="nofollow noreferrer">brainfuck</a>, 306 bytes</h1>
<pre><code>&gt;&gt;&gt;+[[&gt;+&gt;+&lt;&lt;-]&gt;&gt;[-&lt;&lt;+&gt;&gt;]&lt;+++++]&lt;&lt;[--------&lt;]&lt;&lt;++&gt;+++&gt;+++++&gt;++++++++++++++&gt;+++++++++++++&gt;++++++++++&gt;+++++++++&gt;++++++&gt;+++++&gt;++++++&gt;+++&gt;++++&gt;+++&gt;&gt;-&gt;&gt;+&gt;--&gt;-&gt;--&gt;-----&gt;----&gt;-----&gt;----&gt;-&gt;--&gt;-----&gt;------&gt;---------&gt;----------&gt;-&gt;--&gt;-&gt;----&gt;+&gt;--&gt;-&gt;&gt;-&gt;&gt;+&gt;--&gt;+++&gt;&gt;-&gt;----&gt;+++&gt;++++++++++&gt;+++++++++&gt;++++++&gt;+++++&gt;++++++&gt;+++&gt;
</code></pre>
<p><a href="https://tio.run/##lU5bCoAwDDtQqScIuUjZhwqCCH4Inr9ubCtM8MNA04Q@l2vez@1eD3eSYkahAJpIU0DIBClIgGkDspHcV6NzgF@Ob8W3YQhqfoeqORcqYFCXYynSoHpbHWkrY3s7VWt/n3WbkPwB" rel="nofollow noreferrer" title="brainfuck – Try It Online">Try it online!</a></p>
<ol>
<li>Initialize with sequence</li>
</ol>
<blockquote>
<p><code>[0, 0, 0, 1, 6, 11, 16, 21, 26, ..., 241, 246, 251, 0]</code></p>
</blockquote>
<ol start="2">
<li>Substitute 8 for cells in the middle</li>
</ol>
<blockquote>
<p><code>[0, 0, 0, 249, 254, 3, 8, 13, 18, ..., 233, 238, 251, 0]</code></p>
</blockquote>
<ol start="3">
<li>Adjust each cell to its target value one by one</li>
</ol>
<blockquote>
<p><code>[2, 3, 5, 7, ... 241, 251]</code></p>
</blockquote>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/282217/">282217</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




