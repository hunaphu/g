<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::136709</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td></td><td>250209T013926Z</td><td><a href="https://codegolf.stackexchange.com/questions/136709/products-that-equal-a-sum-and-vice-versa/278150#278150">138 Aspe</a></td></tr>
<tr d-ix="1"><td>nan</td><td>C gcc</td><td>180722T081619Z</td><td><a href="https://codegolf.stackexchange.com/questions/136709/products-that-equal-a-sum-and-vice-versa/169015#169015">Anders K</a></td></tr>
<tr d-ix="2"><td>2859</td><td>Python 2</td><td>170801T090446Z</td><td><a href="https://codegolf.stackexchange.com/questions/136709/products-that-equal-a-sum-and-vice-versa/137013#137013">G B</a></td></tr>
<tr d-ix="3"><td>8359</td><td>Axiom</td><td>170801T184227Z</td><td><a href="https://codegolf.stackexchange.com/questions/136709/products-that-equal-a-sum-and-vice-versa/137099#137099">user5898</a></td></tr>
<tr d-ix="4"><td>nan</td><td>Haskell</td><td>170801T164758Z</td><td><a href="https://codegolf.stackexchange.com/questions/136709/products-that-equal-a-sum-and-vice-versa/137073#137073">Christia</a></td></tr>
<tr d-ix="5"><td>102</td><td>Haskell</td><td>170731T191825Z</td><td><a href="https://codegolf.stackexchange.com/questions/136709/products-that-equal-a-sum-and-vice-versa/136878#136878">maple_sh</a></td></tr>
<tr d-ix="6"><td>1911</td><td>Mathematica</td><td>170731T144403Z</td><td><a href="https://codegolf.stackexchange.com/questions/136709/products-that-equal-a-sum-and-vice-versa/136833#136833">ZaMoC</a></td></tr>
<tr d-ix="7"><td>126</td><td>Ruby</td><td>170731T152332Z</td><td><a href="https://codegolf.stackexchange.com/questions/136709/products-that-equal-a-sum-and-vice-versa/136836#136836">G B</a></td></tr>
<tr d-ix="8"><td>nan</td><td>Mathematica</td><td>170731T001805Z</td><td><a href="https://codegolf.stackexchange.com/questions/136709/products-that-equal-a-sum-and-vice-versa/136737#136737">ZaMoC</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Rust</h1>
<p>Rust port of @Anders Kaseorg's C answer.</p>
<p><a href="https://ato.pxeger.com/run?1=nVjNjuM2Er77AXLm9GInUsZWtzRBsLDbDexOECC3ID-7h0ZjwpZom7FEqSmq25OZfo8AueSQHPJKeZp8RVGyZEnTM6uDTZHFYvGrf_36u65K89tvf1Rms_jXX5_88o9n1zxN8wevUlUpktcyK3JtSv9mhldWmmS5FOp-NZudn5-zf2NCV7FhuzxNpNoybGVmJ1jCDWdcJey22myELhnxYrdv7CJPt7mWZpcFM7f9SyJ_O2N41JLJl9HcjnHCf0Vscuw3OY7KtWD3PK1EyeJca1EWubLHYpWH9jweMansKThiKxVP2SsQJyJoOP5PsEKLBV0y5kYQbUYMUqG2ZscUuxUxp7uaHTeflpZXxg8yqzIav2GZ3O4MU0IkNU8eLknMS4h9VcvNo9MZnPs1RI0hubcP52wf-ZCzJzZdB5eV9yJ9UzPeg3FVyp9FzWMf9V4J_iSRRuZ0yXuuJb9Nwd9orsoUN0vYRufZNBZl2IG6CPu4f8UJd8a15m-O4JcZYBOlAYIyE2zDa-WAMJH3ssS_VJu8hfqbDs5JB-PPP1OLcKCno2Q13y6Gj7MZDDHtGkptf4nUAK29NMBg-cby_TGvjOf_yDaVimk-aHd9owF9rdi4ghkp406UPzsOujEz8OLhObRTVrc_2YNyyKlq2EsnLTZU5vVGec9LkW58J1-j9g2AZus1EJ6zeCfiPVA4yDjfal7sZIyL5zoRmswYnOEQnKRrWUjsB9egZmKHRdg5wkpAwBOeF0FgKfZhkEnl1ePIPyHvsuXhtbxhl-4lopchMT1amEqr1WDtkYkUztLnd_U0v1st-H6E3Wz8DQbQB_UBbsxLiiq1EQ0gnJORQrXQTbt1BKgT8eyeZ97Z20d2Nu9cyV91RDklDg8gf9duUGzBGu68JLfq7B6KEH2ACNF7RUiVE2IoQdSXwMH4pO9shXo5dB5Yul14nlXG8p8zGhV16GCl-8-af6wdOuM7O-5aYyoM0wxm3cir2IsTwTERrXobEub8oHba6zuitIHxZtWzku9xk43UCFdnSc7esiAIYK4PO5kK7479kxit2YV_xm4RovZNPKpDZJdPG1EpDS2PsuR5caI6eMGBfQbGl2uWjRg-FtcsWU3YOD137HxAAa61uM8g7gjXEVeachyCpBQUwUYwwfgJMMavfEc4njqSOxCWu49evLiBzg6D9ca2ncYt0TAkNPbwAodMrMIqI69g5-wwt7aEv4M_zWkx4OSi2PAKDfuXXgHWsOM5Mb_zT-EemsH_qzB6Ds4KepNA85XNHzZxNUmo0dRRhY0TOz0n-cKunUpIcHlkrXc-4r8m1Ojl4-2rA8CHxJVoKq5E3bgyiClYyUbjh4qaeDCMekeh7YVHzJTyFs2r0yhMj2XmcvtA4-2oTYDgcUUnPH8O578aHNUNdoriWjhwcw1NROzdO8hKKhlKNJaFH0-50OFjmzMcrp_Y2w2sxTGwTgW0EfdAmVNMg_Wx1hJOWUv4XmsZt5RwaCnhwFKaEgsV28lkafdDcSrsJ5pXKHJLa8LsAX0N48lPaKpQmhRc80wYNEDLPitr7o7pvDly7piTabQJ0V-dVj6ARgs0JqWR6LZ0jhrfwyaKNf4cONp6XRyMUEnX_B3JiRJtQ_Qp-NQFfrcmLvKyjTDUphgMEnFAWzIoPg9EEwXBesxGXNo5RqyzAoHmQCZF9z3Ud16w8KxuWF6NFasTWyaKy6ZuczqeSCwtJaxgPLl09RV6VoZaSRMJpstxmGTomUw09Hx0TVz_wp3gExmKXs9vmyP2reAJQM8y9JeLVCr03XpbZdCspSCHwERZd1nfGaqer4ATmvvlkhY8P4hzdHuxaWIf1EALAbo4z7eR6ngNcSxEfyj5ViwZytdLdYWKlPZcX3TLV_sVodA52uFyuUQ3ZLywX6Bad4U0dm94E8CRSrFc2m4QglXqAd3T61x7F0fZ1LRIQAcOic6eAnR09lGi2NYdhstTBMLjx436y0WlRSsvhSO7tO62qfSoeTukjwX3In52fbGCwG187RBETxDQV4GLzmvUey37q0X_1blir-VmTYdeui7YNf02krmG3bMdux90GYlgGzQ71iy2XIiO3BJOAqHzjQcF-J1tTWPfXND7HC5ld_inV31ctfB_v5OlK0tvK5kmdevuktSNE5eCFHxAKaFxeCZTrikODr4wLBuuDMc2iY4CRFGHGRxlP26MkO0hrCOloJdVqZFFWn8lKLr0PC1zpOoNOV0rJqaOx8n6Du33FIcjgc_iHTzZzQStdaW4k8HZLWKr5sT_ECbjn2bqfAmuhQvQNZejZeLKZLJjGX89TBaTpN1U2XUHOVyytSizu-UXdBnZDBHcW3uI_GZ2GCm7UtiYLP33yWKvORLfBxXcIDEi1x41dtmOUTe30zeUvE3PjkbJggE8G5BO4DnEsthYqwPHQck4pZPL_sqms_R-SPuKnWLygQWeLY2sqZu8WKTiXqRUJwldF3r9ws6eZTMtAsjFnL1sg8Nq9lh_oHbfqf-8Di_sc-Mm_gY" rel="nofollow noreferrer">Attempt This Online!</a></p>
<pre class="lang-rust prettyprint-override"><code>#![allow(unused_imports)]
use std::env;

/// A struct holding all the data and buffers used by the algorithm.
struct Data {
    n: i32,
    // Vectors to store values corresponding to a1 and a2 in the original C code.
    // We pre-allocate them to length n because that's the maximum they might need.
    a1: Vec&lt;i32&gt;,
    a2: Vec&lt;i32&gt;,
    // Indices (k1, k2) into a1 and a2 respectively.
    k1: usize,
    k2: usize,
    // Additional variables translated from the original C code.
    s1: i32,
    p1: i32,
    // Factor array to store smallest prime factors or divisor info.
    // Pre-allocated to length 4*n-1 in the original code.
    factor: Vec&lt;i32&gt;,
}

impl Data {
    /// A direct translation of the `out()` function.
    /// Prints the current factorization or values of a1/a2 subject to conditions.
    fn out_fn(&amp;self) {
        // If s1 == p1, check lexicographical ordering constraints
        if self.s1 == self.p1 {
            for i in 0..self.k1.min(self.k2) {
                if self.a1[i] &lt; self.a2[i] {
                    return;
                } else if self.a1[i] &gt; self.a2[i] {
                    break;
                }
            }
        }

        // If we passed the ordering constraint, print out
        for i in 0..self.k1 {
            print!(&quot;{} &quot;, self.a1[i]);
        }
        print!(&quot;1x{} | &quot;, self.n - self.k1 as i32);
        for i in 0..self.k2 {
            print!(&quot;{} &quot;, self.a2[i]);
        }
        println!(&quot;1x{}&quot;, self.n - self.k2 as i32);
    }

    /// A direct translation of the `gen3()` function.
    fn gen3(&amp;mut self, mut p: i32, s: i32, m: i32, mut x: i32, mut q: i32) {
        let r = s - self.n + self.k2 as i32 + 2;
        let d = self.factor[q as usize];

        // The first &quot;do { ... } while(q % d == 0)&quot; block in the C code
        // translates to:
        loop {
            if x * d &lt;= m {
                x *= d;
            }
            q /= d;
            if q % d != 0 {
                break;
            }
        }

        // The second &quot;do { ... } while(...)&quot; block in the C code
        loop {
            if q == 1 {
                // a2[k2++] = x
                self.a2[self.k2] = x;
                self.k2 += 1;
                self.gen2(p / x, s - x, x);
                self.k2 -= 1;
            } else {
                self.gen3(p, s, m, x, q);
            }

            if x % d != 0 {
                break;
            }
            x /= d;

            // Check the condition in the while(...) of the second do-while
            if p / (x * q) &lt; r - x * q {
                break;
            }
        }
    }

    /// A direct translation of the `gen2()` function.
    fn gen2(&amp;mut self, p: i32, s: i32, mut m: i32) {
        let n2 = self.n - self.k2 as i32;
        if p == 1 {
            if s == n2 {
                self.out_fn();
            }
        } else if n2 &gt;= 1 &amp;&amp; m &gt; 1 {
            let r = s - n2 + 1;
            if r &lt; 2 || p &lt; r {
                return;
            }
            if m &gt; r {
                m = r;
            }
            if self.factor[p as usize] &lt;= m {
                self.gen3(p, s, m, 1, p);
            }
        }
    }

    /// A direct translation of the `gen1()` function.
    fn gen1(&amp;mut self, p: i32, s: i32, m: i32) {
        let n1 = self.n - self.k1 as i32;
        self.p1 = p;
        self.s1 = s + n1;

        // Calls gen2 with adjusted parameters:
        self.gen2(self.s1, self.p1, s + n1 + 1 - self.n);

        // If there's still room (n1 != 0), try to extend
        if n1 != 0 {
            // We'll store the current position in a1 at index k1
            for x in 2..=m {
                // The condition &quot;p * x &lt;= s + x + n1 - 1&quot; from C
                if p * x &lt;= s + x + n1 - 1 {
                    self.a1[self.k1] = x;
                    self.k1 += 1;
                    self.gen1(p * x, s + x, x);
                    self.k1 -= 1;
                } else {
                    break;
                }
            }
        }
    }
}

fn main() {
    // Read command-line argument
    let args: Vec&lt;String&gt; = env::args().collect();
    if args.len() &lt; 2 {
        eprintln!(&quot;Usage: {} &lt;n&gt;&quot;, args[0]);
        std::process::exit(1);
    }

    let n = args[1].parse::&lt;i32&gt;().unwrap_or(0);
    if n &lt; 2 {
        eprintln!(&quot;n must be &gt;= 2&quot;);
        std::process::exit(1);
    }

    // Initialize the data structure
    let mut data = Data {
        n,
        a1: vec![0; n as usize],
        a2: vec![0; n as usize],
        k1: 0,
        k2: 0,
        s1: 0,
        p1: 0,
        // The original code allocates factor array with length (4*n-1).
        // e.g. factor = calloc(4*n - 1, sizeof(int)).
        factor: vec![0; (4 * n - 1) as usize],
    };

    // This block builds the factor[] array in a manner similar to the original code:
    //   - factor[p] = p if p is prime
    //   - factor[k * p] = p for multiples of p
    //   - also refine factor[] so factor[p] is the smallest factor or a chain factor.
    let limit = 4 * n - 1;
    // Build smallest prime factor
    for p in 2..limit {
        if data.factor[p as usize] == 0 {
            data.factor[p as usize] = p;
            let mut i = p;
            while p as i64 * i as i64 &lt;= (4 * n - 2) as i64 {
                data.factor[(p * i) as usize] = p;
                i += 1;
            }
        } else {
            // If factor[p] &lt; factor[p / factor[p]], set factor[p] = factor[p / factor[p]].
            let f = data.factor[p as usize];
            let pf = p / f;
            if data.factor[p as usize] &lt; data.factor[pf as usize] {
                data.factor[p as usize] = data.factor[pf as usize];
            }
        }
    }

    // Call the top-level generation function.
    data.gen1(1, 0, 3 * n - 1);
}
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C (gcc)</a>, n = 50000000 with 6499 results in 59 s</h1>

<p>To avoid producing over a terabyte of output consisting almost entirely of 1s, a sequence of (say) 49999995 1s is abbreviated as <code>1x49999995</code>.</p>



<pre class="lang-c prettyprint-override"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

static int n, *a1, k1 = 0, *a2, k2 = 0, s1, p1, *factor;

static void out() {
  if (s1 == p1) {
    for (int i = 0; i &lt; k1 &amp;&amp; i &lt; k2; i++) {
      if (a1[i] &lt; a2[i])
        return;
      else if (a1[i] &gt; a2[i])
        break;
    }
  }

  for (int i = 0; i &lt; k1; i++)
    printf("%d ", a1[i]);
  printf("1x%d | ", n - k1);
  for (int i = 0; i &lt; k2; i++)
    printf("%d ", a2[i]);
  printf("1x%d\n", n - k2);
}

static void gen2(int p, int s, int m);

static void gen3(int p, int s, int m, int x, int q) {
  int r = s - n + k2 + 2;
  int d = factor[q];
  do {
    if (x * d &lt;= m)
      x *= d;
    q /= d;
  } while (q % d == 0);
  do {
    if (q == 1) {
      a2[k2++] = x;
      gen2(p / x, s - x, x);
      k2--;
    } else {
      gen3(p, s, m, x, q);
    }
    if (x % d != 0)
      break;
    x /= d;
  } while (p / (x * q) &gt;= r - x * q);
}

static void gen2(int p, int s, int m) {
  int n2 = n - k2;
  if (p == 1) {
    if (s == n2)
      out();
  } else if (n2 &gt;= 1 &amp;&amp; m &gt; 1) {
    int r = s - n2 + 1;
    if (r &lt; 2 || p &lt; r)
      return;
    if (m &gt; r)
      m = r;
    if (factor[p] &lt;= m)
      gen3(p, s, m, 1, p);
  }
}

static void gen1(int p, int s, int m) {
  int n1 = n - k1;
  p1 = p;
  s1 = s + n1;
  gen2(s1, p1, s + n1 + 1 - n);
  if (n1 != 0) {
    int *p1 = &amp;a1[k1++];
    for (int x = 2; x &lt;= m &amp;&amp; p * x &lt;= s + x + n1 - 1; x++) {
      *p1 = x;
      gen1(p * x, s + x, x);
    }
    k1--;
  }
}

int main(int argc, char **argv) {
  if (argc &lt; 2)
    return 1;
  n = atoi(argv[1]);
  if (n &lt; 2)
    return 1;
  a1 = malloc(n * sizeof(int));
  a2 = malloc(n * sizeof(int));
  factor = calloc(4 * n - 1, sizeof(int));
  for (int p = 2; p &lt; 4 * n - 1; p++)
    if (factor[p] == 0) {
      factor[p] = p;
      for (int i = p; i &lt;= (4 * n - 2) / p; i++)
        factor[p * i] = p;
    } else if (factor[p] &lt; factor[p / factor[p]]) {
      factor[p] = factor[p / factor[p]];
    }
  gen1(1, 0, 3 * n - 1);
  return 0;
}

</code></pre>

<p><a href="https://tio.run/##jVXbUtswEH3PV2zpwMR2UrDomwm/0A@geRC@BE0c27EN9RT49aZntZbtkPTCDCNr92i1e86uEi83cXw4fDZFnD8nKd01bWLKL0/3syNTbh7ZNmta3ZqYTNFSsSBfhwvahrSiG94obJRsGjgq/PuZjtuyjoaTL6VJqHxu5x69zohMRvMGAVZAi4UoK2ua8w2GY0VY7viSqyv5UrAEgQNLCB0@mDWcWmH1egdRnbbPdRH1@zRv0gn6/iP6sU71VsDvM/6f/SkXycAiqxrebH5xmdDFgmxkj2M4e9jB88a@gpY4ap1no6o/R1Xnon4vXFAF3/sxw5u0UPaGamHFamTZedEJ7vYcTpZOln2vFT5rJNzgzoIC1jogFfWeBB4R@2G/ZmNS9hIx5R35QNytkEHPNywrSoTuPV333@/048nkKc33dMkhQY93EmzP9nDsAPCzVUGwRgadE9sSUNE118AJY@k859yq5bIXWrridTx1OwcVoAEU4MzeGxvCVcKJfeLEZid9050WwjnY8sHi/QoELkl2/6/ZwH7B0yWSR/3wVEdc2HFiS6FcdnbWJKNhABAHqdiR2mEOxuNThVndMBrC1uhRRW9vVOGjdtGnE8YoDjc4dwhVj76@O6r1UR8cU87PhmR7hp3wH@yEjh2bdsXbir/4gUFNARC8tTy7B0rMXCrX7DlaYbIST4jxbcArjPg2RLNFx29VBx8muLO1MbEVRLY7vqGTW5YglLrp4yVBp10bzu1JyWzStdKB21A619Jj69emsAnoehMvKH7SNfk@Ni/jA8suVk8oF8lE2gKX67Y0DHl5CNdj/efxmrPd6TwvY0B8aszPtMz4fs8e1ervfmkBYGLBfAWGFWMhPkIds5Uwy203wLF1T@VxZ60mornrrF064eTnpbKP74qGTJSHea0mT/E0DjBmEmsyUZPeHtHXYwLr80mdhY5623YAN/hBvXWlW3J6TW74DTkcDuGN/fsVZ7neNIflt0w37W8" rel="nofollow noreferrer" title="C (gcc) – Try It Online">Try it online!</a></p>
</div>
<div id="pu2" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>, n=175, 28 results in 59s</h1>

<p>Made it a little slower using a reduction factor 2, but gets more solutions starting with n=83</p>

<p>I get results for n up to 92 on TIO in a single run.</p>



<pre class="lang-python prettyprint-override"><code>def submats(n, r):
    if n == r:
        return [[]]
    elif r &gt; 6:
        base = 1
    else:
        base = 2
    mx = max(base, int(n*2**(1-r)))

    mats = []
    subs = submats(n, r+1)
    for m in subs:
        if m:
            mn = m[-1]
        else:
            mn = 1
        for i in range(mn, mx + 1):
            if i * mn &lt; 3*n:
                mats += [m + [i]]
    return mats

def mats(n):
    subs = []
    for sub in submats(n, 0):
        sum = 0
        prod = 1
        for m in sub:
            sum += m
            prod *= m
        if prod &gt; n and prod &lt; n*3:
            subs += [[sub, sum, prod]]
    return subs

def sols(n):
    mat = mats(n)
    sol = [
        [[1]*(n-1)+[3*n-1],[1]*(n-2)+[2,2*n-1]],
    ]
    if n &gt; 2:
        sol += [[[1]*(n-1)+[2*n+1],[1]*(n-2)+[3,n]]]
    for first in mat:
        for second in mat:
            if first[2] == second[1] and first[1] == second[2] and [second[0], first[0]] not in sol:
                sol += [[first[0], second[0]]];
    return sol
</code></pre>

<p><a href="https://tio.run/##bVTtiuMwDPyfpxBdFuzEgTiF@9Hb9kWMCek1vTXETrFT2H36nvzRJN5eoSWWRtLMWOnte/6cTPu42knDrPQASt8mO4fnx2W4grufdT87YhhYeigAP@oKBo5HsPHoP3aY79aAEFKG2DAiyMIJfq2Yc@8GOAJPADe8pNoQ0F/4qPsv4qMMlJmJKduyJLy2lNIigpATwkQchyT9acu14jSkrpMFjU0CZp2I9PR6Ch2NHytqLpdwTnIB8SXkmyvf3Pbm70A0Dkb2FXCal@E0BaWv/oB9afLkIqdCPRqrhUouJld9sij8ZUR1qXkSnSzwVDCSlD5taDZE3F0jvFnONztdXtQ8rcop@lJkp7NgqC@3UZQZgifcj95c4uEDTLn/2e4c1Qp8Yr47C9hctkdF2W4aV9koLexHcCIaMY3eh2WEEFyWxNScVgLdxhtlKdJipGVtiEkWCuS60idoN25h00Bx0wwLq7zZnhkp1wu4Kutm7yDSO2S@uuHPhI78TKXZoU600r9VEYkzgoUxw7eZNmZEOjaSJVQjJZgpzEf2r0u2SHrCGSw9pPydeT@ND@TVdabXQ9f56buu070yXbc7FP/Z/ZbxZrv2bu6tvyj/R0LoGj6Gy1R0s4b4hsPu/QL1CfCX4NfRHbwDUQzGwRBHWWoDdexLi7e83D2K4h8" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>
</div>
<div id="pu3" class="pu"><h1>Axiom, n=83 in 59 seconds here</h1>
<pre><code>-- copy the below text in the file name &quot;thisfile.input&quot; 
-- and give something as the command below in the Axiom window:
-- )read C:\Users\thisuser\thisdirectory\thisfile

)cl all
)time on

-- controlla che l'array a e' formato da elementi  a.i&lt;=a.(i+1)
tv(a:List PI):Boolean==(for i in 1..#a-1 repeat if a.i&gt; a.(i+1) then return false;true)

-- funzione incremento: incrementa a, con #a=n=b/3,sotto la regola di &quot;reduce(+,a)+#a-1&gt;=reduce(*,a)&quot;
-- e che n&lt;reduce(*,a)&lt;3*n ed reduce(+,a)&lt;3*n 
inc3(a:List PI):INT==
   i:=1; n:=#a; b:=3*n
   repeat
      if i&gt;n  then return 0
      x:=reduce(*,a)
      if x&gt;=b then a.i:=1
      else
          y:=reduce(+,a)
          if y&gt;b then a.i=1
          else if y+n-1&gt;=x then
                      x:=x quo a.i
                      a.i:=a.i+1
                      x:=x*a.i
                      if tv(a) then break
                      else a.i:=1
          else a.i:=1
      i:=i+1
   if x&lt;=n then return inc3(a) -- x&lt;=n non va
   x

-- ritorna una lista di liste di 4 divisori di n
-- tali che il loro prodotto e' n
g4(n:PI):List List PI==
  a:=divisors(n)
  r:List List PI:=[]
  for i in 1..#a repeat
     for j in i..#a repeat
        x:=a.i*a.j
        if x*a.j&gt;n then break
        for k in j..#a repeat
            y:=x*a.k
            if y*a.k&gt;n then break
            for h in k..#a repeat
                z:=y*a.h
                if z=n  then r:=cons([a.h,a.k,a.j,a.i],r)
                if z&gt;=n then break 
  r

-- ritorna una lista di liste di 3 divisori di n
-- tali che il loro prodotto e' n
g(n:PI):List List PI==
  a:=divisors(n)
  r:List List PI:=[]
  for i in 1..#a repeat
     for j in i..#a repeat
        x:=a.i*a.j
        if x*a.j&gt;n then break
        for k in j..#a repeat
            y:=x*a.k
            if y=n  then r:=cons([a.k,a.j,a.i],r)
            if y&gt;=n then break
  r

-- cerca che [a,b] nn si trovi gia' in r
searchr(r:List List List PI,a:List PI,b:List PI):Boolean==
  aa:=sort(a); bb:=sort(b)
  for i in 1..#r repeat
      x:=sort(r.i.1);y:=sort(r.i.2)
      if x=aa and y=bb then return false
      if x=bb and y=aa then return false
  true

-- input n:PI
-- ritorna r, tale che se [a,b] in r
-- allora #a=#b=n
--        ed reduce(+,a)=reduce(*,b) ed reduce(+,b)=reduce(*,a)
f(n:PI):List List List PI==
  n&gt;100000 or n&lt;=1 =&gt;[]
  a:List PI:=[]; b:List PI:=[]; r:List List List PI:=[]
  for i in 1..n repeat(a:=cons(1,a);b:=cons(1,b))
  if n~=72 and n&lt;86 then  m:=min(3,n)
  else                    m:=min(4,n) 
  q:=reduce(*,a) 
  repeat
    w:=reduce(+,a)
    if n~=72 and n&lt;86 then x:= g(w)
    else                   x:=g4(w)
    if q=w then r:=cons([copy a, copy a],r)
    for i in 1..#x repeat
           for j in 1..m repeat
                  b.j:=(x.i).j
           -- per costruzione abbiamo che reduce(+,a)= prodotto dei b.i=reduce(*,b)
           -- manca solo di controllare che reduce(+,b)=reduce(*,a)=q
           if reduce(+,b)=q and searchr(r,a,b) then r:=cons([copy a, copy b],r)
    q:=inc3(a)
    if q=0 then break
  r
</code></pre>
<p>results:</p>
<pre><code> for i in 2..83 repeat output [i, # f(i)]
   [2,2][3,4][4,3][5,5][6,4][7,6][8,5][9,7][10,7][11,8][12,6][13,10][14,7][15,7]
   [16,10][17,10][18,9][19,12][20,7][21,13][22,9][23,14][24,7][25,13][26,11]
   [27,10][28,11][29,15][30,9][31,16][32,11][33,17][34,9][35,9][36,13][37,19]
   [38,11][39,14][40,12][41,17][42,11][43,20][44,12][45,16][46,14][47,14][48,13]
   [49,16][50,14][51,17][52,11][53,20][54,15][55,17]
   [56,14][57,20][58,17][59,16][60,15][61,28][62,15][63,16][64,17][65,18]
   [66,14][67,23][68,20][69,19][70,13][71,18][72,15][73,30][74,15][75,17][76,18]
   [77,25][78,16][79,27][80,9][81,23][82,17][83,26]
 
 
 f 3
    [[[1,2,5],[8,1,1]],[[1,3,3],[7,1,1]],[[1,2,3],[1,2,3]],[[2,2,2],[6,1,1]]]
                                     Type: List List List PositiveInteger
                                   Time: 0.07 (IN) + 0.05 (OT) = 0.12 sec
</code></pre>
<p>The way for run above text in Axiom, would be, copy all that text in a file, save the file with the name: Name.input, in a Axiom window use &quot;)read absolutepath/Name&quot;.<br />
results: (# f(i) finds the length of the array f(i), that is the number of solutions)</p>
</div>
<div id="pu4" class="pu"><h2>Haskell, a lot of solutions fast</h2>

<pre><code>import System.Environment

pr n v = prh n v v

prh 1 v l = [ [v] | v&lt;=l ]
prh n 1 _ = [ take n $ repeat 1 ]
prh _ _ 1 = []
prh n v l = [ d:r | d &lt;-[2..l], v `mod` d == 0, r &lt;- prh (n-1) (v`div`d) d ]

wo n v = [ (c,k) | c &lt;- pr n v, let s = sum c, s&gt;=v,
                   k &lt;- pr n s, sum k == v, s&gt;v || c&gt;=k ]

f n = concatMap (wo n) [n+1..3*n]

main = do [ inp ] &lt;- getArgs
          let results = zip [1..] $ f (read inp)
          mapM_ (\(n,s) -&gt; putStrLn $ (show n) ++ ": " ++ (show s)) results
</code></pre>

<p><code>f</code> computes the solutions, the <code>main</code> function adds getting the input from the command line and some formatting and counting. </p>
</div>
<div id="pu5" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, n=10 with 2 solutions</h1>



<pre class="lang-hs prettyprint-override"><code>
import           Data.List

removeDups = foldl' (\seen x -> if x `elem` seen then seen else x : seen) []
removeDups' = foldl' (\seen x -> if x `elem` seen then seen else x : seen) []

f n= removeDups $ map sort filterSums
  where maxNumber = 4
        func x y = if (((fst x) == (fst.snd$y)) && ((fst y) == (fst.snd$x)))
                     then [(snd.snd$x),(snd.snd$y)]
                     else [[],[]]
        pOf = removeDups' $ (map sort (mapM (const [1..maxNumber]) [1..n]))
        sumOf = map (\x->((sum x),((product x), x))) pOf
        filterSums = filter (\x-> not$(x == [[],[]])) (funcsumOfsumOf)

</code></pre>

<p>This performs like crap, but I at least fixed it so I am actually addressing the challenge now!</p>

<p><a href="https://tio.run/##rVG7boMwFN35ijugxK4S1EqdqsCUsY@hI7EUGmwF1Q9kmxa@nl6blFApYz3Y93nuOdfnyn1yKcexUa2xHq5nX/kqe26cTxLLlfni@651kIMwspZrIAfHuYYetgU0At8jl1wdIUb9Ga9ocek4Jp@iR6FkC7D1P6AlAnQOC4IpqKoFF7SIRnpu3zvlEoDvM7ccc/1rpz64xdGPya9U0ekTwg4YxOGEEOE89BTyHIKZOV2nA6WwWsGUG/7mekppArdOpF4SLLoUbmZ7oOx2TxRZlmxTsmtF@yZgqXONQsmsNFgvQE5GI7nyIctmnYxGX7MFQ9epiBbayaHfFoRgCAI50lpTd6egfgNBVhh83dO80PBz0ZkAQBufkj4s5UIcO0lY6y4t4rjd3fTSZFRVo7G/NgF3In6Q26K1jfapABkY37PxBw" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
</div>
<div id="pu6" class="pu"><h1>Mathematica, n=19 with 11 solutions</h1>
<p>this is my new answer according to OP's new criteria</p>
<pre><code>(SOL = {};
For[a = 1, a &lt; 3, a++, 
For[b = a, b &lt; 3, b++, 
For[c = b, c &lt; 5, c++, 
 For[d = c, d &lt; 6, d++, 
  For[e = d, e &lt; 3#, e++, 
   For[k = 1, k &lt; 3, k++, 
    For[l = k, l &lt; 3, l++, 
     For[m = l, m &lt; 5, m++, 
      For[n = m, n &lt; 6, n++, For[o = n, o &lt; 3#, o++,
        s = Join[Table[1, # - 5], {a, b, c, d, e}];
        t = Join[Table[1, # - 5], {k, l, m, n, o}];            
        If[Tr[s[[-# ;;]]] == Times @@ t[[-# ;;]] &amp;&amp; 
          Tr[t[[-# ;;]]] == Times @@ s[[-# ;;]], 
         AppendTo[SOL,{s[[-#;;]],t[[-#;;]]}]]]]]]]]]]]];
Union[SortBy[#,Last]&amp;/@SOL])&amp;
</code></pre>
<p>if you give an input [n] at the end, the program displays the solutions</p>
<p>here are my results (on my old laptop 64-bit 2.4GHz)</p>
<blockquote>
<p>n-&gt;solutions<br />
2 -&gt; 2<br />
3 -&gt; 4<br />
4 -&gt; 3<br />
5 -&gt; 5<br />
6 -&gt; 4<br />
7 -&gt; 6<br />
8 -&gt; 5<br />
9 -&gt; 7<br />
10 -&gt; 7<br />
11 -&gt; 8<br />
12 -&gt; 6    (in 17 sec)<br />
13 -&gt; 10 (in 20 sec)<br />
14 -&gt; 7 (in 25 sec)<br />
15 -&gt; 7 (in 29 sec)<br />
16 -&gt; 9 (in 34 sec)<br />
17 -&gt; 10 (in 39 sec)<br />
18 -&gt; 9 (in 45 sec)<br />
19 -&gt; 11 (in 51 sec)<br />
20 -&gt; 7 (in 58 sec)</p>
</blockquote>
</div>
<div id="pu7" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, n=12 gets 6 solutions</h1>

<p>At least on TIO, usual results for 1 up to 11
</p>

<pre class="lang-ruby prettyprint-override"><code>-&gt;n{
  arr=[*1..n*3].product(*(0..n-2).map{|x|
    [*1..[n/3**x,2].max]|[1]
  }).select{|a|
    a.count(1) &gt;= n-4
  }.map(&amp;:sort).uniq
  arr.product(arr).map(&amp;:sort).uniq.select{|r|
    r[0].reduce(&amp;:+) == r[1].reduce(&amp;:*) &amp;&amp;
    r[0].reduce(&amp;:*) == r[1].reduce(&amp;:+)
  }
}
</code></pre>

<p><a href="https://tio.run/##bY/NCoMwEITvPsWexETdGu2pEF8k5GBtBKGNNipYf57dRgUp1Nsy@@3sjOnun6XgS5jq0QHIjOGCMkRNE4m1qR5d3nrUi6wSxgRfWT1O/WRJgI0T@pJQ2gextLteToJJu5wJNuqp8nacsh3OMK863XqMQMpBh9eVWu0899ZUpiXY6fK9Jzj@2pn8MYez2Z2NiCQaZQ@U5XwCnFuN/WiUgOuesPSE9ckazJkXwbZKW90aBl6IXgYDNuWg5uUL" rel="nofollow noreferrer" title="Ruby – Try It Online">Try it online!</a></p>

<p>Gets 10 results under a minute for n=13 on my laptop.</p>
</div>
<div id="pu8" class="pu"><h1>Mathematica, n=293 with 12 solutions</h1>

<p>OP changed the challenge and asks for input<br>
Here is the new code that takes any n as input<br>
For n=293 you get the 12 solutions</p>

<pre><code>If[#&lt;5,Union[Sort/@Select[Tuples[{1,2,3,4,5,6,7,8,9},{#}],Tr@#==Times@@#&amp;]],For[a=1,a&lt;3,a++,For[b=a,b&lt;3,b++,For[c=b,c&lt;5,c++,For[d=c,d&lt;10,d++,For[e=d,e&lt;300,e++,If[Tr[s=Join[Table[1,#-5],{a,b,c,d,e}]]==Times@@s,Print[s]]]]]]]]&amp;
</code></pre>

<p><br>
<strong>input</strong></p>

<blockquote>
  <p>[n]</p>
</blockquote>

<p>You can test this algorithm on <a href="https://sandbox.open.wolframcloud.com/app/objects/" rel="nofollow noreferrer">Wolfram Sandbox</a> which is an online <strong>freely available software</strong><br>
Just follow the link, paste the code (ctrl+v),<strong>paste input at the end of the code</strong> and press shift+enter to run.<br>
You will get all my solutions in seconds</p>

<p>Here is also <a href="https://tio.run/##bc9NbsIwEAXgfU7xRBeG2JUIFVJUh/Yi3Ti2QY6KQSSsUM6evpi/VCKbmeSbebHt8fi@s3YY3kK0v2fnUYVD25282X9l2bkNcYdo9r49GuvRdk5nWYgd9ibE@eKSAeObUagVrIJT8Pr2MSg0nAa2h9PcYINCw6DCB4uUC0KSmmI06qvUN0lkSbWGJa1Z7pTM0ayGoxVL1gcm9VSn4cfQJdk/mYfb8jiSf5SMloyQHJRYlSU2PAtyUk7KSTl8uuX9GcMDw5kZGL5iYfR0ArCHc4eqgrgI/Q/G5ea63IzLZcmG64@NWaFm@mWWSYFKjKWe9HbSu0nvX8eIPimv8A3xEwU@ISAW0@E@e3b9MPwB" rel="nofollow noreferrer" title="C++ (gcc) – Try It Online">Try it online!</a> in C++(gcc)<br>
(Many thanks to @ThePirateBay for supporting and translating my code to a free language)</p>

<p>this program generates only solutions of the form {a,b,c}{a,b,c}<br>
which means a+b+c=a*b*c</p>

<p><strong>It takes 1 sec to compute</strong></p>

<p>the twelve solutions are:</p>

<blockquote>
  <p>{1,1...,1,1,1,2,293}  {1,1...,1,1,1,2,293}<br>
  {1,1...,1,1,1,3,147}  {1,1...,1,1,1,3,147}<br>
  {1,1...,1,1,1,5,74}  {1,1...,1,1,1,5,74}<br>
  {1,1...,1,1,2,2,98}  {1,1...,1,1,2,2,98}<br>
  {1,1...,1,1,2,3,59}  {1,1...,1,1,2,3,59}<br>
  {1,1...,1,1,2,5,33}  {1,1...,1,1,2,5,33}<br>
  {1,1...,1,1,2,7,23}  {1,1...,1,1,2,7,23}<br>
  {1,1...,1,1,2,8,20}  {1,1...,1,1,2,8,20}<br>
  {1,1...,1,1,3,3,37}  {1,1...,1,1,3,3,37}<br>
  {1,1...,1,1,3,4,27}  {1,1...,1,1,3,4,27}<br>
  {1,1...,1,1,3,7,15}  {1,1...,1,1,3,7,15}<br>
  {1,1...,1,2,2,6,13}  {1,1...,1,2,2,6,13}  </p>
</blockquote>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/136709/">136709</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




