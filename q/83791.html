<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::83791</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>966</td><td>Python3</td><td>240809T184817Z</td><td><a href="https://codegolf.stackexchange.com/questions/83791/solve-the-chromatic-puzzle/274862#274862">Ajax1234</a></td></tr>
<tr d-ix="1"><td>404</td><td>C</td><td>160709T075604Z</td><td><a href="https://codegolf.stackexchange.com/questions/83791/solve-the-chromatic-puzzle/84992#84992">Norg74</a></td></tr>
<tr d-ix="2"><td>559</td><td>Lua</td><td>160707T143038Z</td><td><a href="https://codegolf.stackexchange.com/questions/83791/solve-the-chromatic-puzzle/84770#84770">Katenkyo</a></td></tr>
<tr d-ix="3"><td>313</td><td>Octave</td><td>160701T102116Z</td><td><a href="https://codegolf.stackexchange.com/questions/83791/solve-the-chromatic-puzzle/84208#84208">Sanchise</a></td></tr>
<tr d-ix="4"><td>754</td><td>Befunge</td><td>160707T145543Z</td><td><a href="https://codegolf.stackexchange.com/questions/83791/solve-the-chromatic-puzzle/84773#84773">Maliafo</a></td></tr>
<tr d-ix="5"><td>495</td><td>Rust</td><td>160707T174310Z</td><td><a href="https://codegolf.stackexchange.com/questions/83791/solve-the-chromatic-puzzle/84796#84796">raggy</a></td></tr>
<tr d-ix="6"><td>266</td><td>Ruby</td><td>160707T185927Z</td><td><a href="https://codegolf.stackexchange.com/questions/83791/solve-the-chromatic-puzzle/84801#84801">Value In</a></td></tr>
</table>
<div id="pu0" class="pu"><h2>Python3, 966 bytes</h2>
<p>Runs input puzzle matrix through a series of transformation convolutions.</p>
<pre class="lang-py prettyprint-override"><code>R=range
v=lambda d:not d%2 and d%3
def C(B,x,X,y,Y):
 d={}
 for j in B[x:X]:
  for t in j[y:Y]:d[t]=d.get(t,0)+1
 return d
def f(b):
 B=[b,b+[[0]*len(b[0])]][len(b)%2]
 for x in R(0,len(B),2):
  for y in R(0,len(B[0]),2):
   d,V=C(B,x,x+2,y,y+2),-1
   if len(d)==3:V=max(d,key=lambda x:d[x])
   elif len(d)==2:V=[*{0,1,2}-{*d}][0]if len({*d.values()})==1 else min(d,key=lambda x:d[x])
   if V&gt;-1:
    for X in R(x,x+2):
     for Y in R(y,y+2):B[X][Y]=V
 e=[]
 for x in R(len(B)):
   for y in R(len(B[0])):
    for X in R(x+1,len(B)+1):
     for Y in R(y+1,len(B[0])+1):
      if v(A:=X-x)and v(U:=Y-y):e+=[(x,X,y,Y,A*U)]
 q,s=[B],[B]
 for B in q:
  if len({i for k in B for i in k})==1:return B
  O=[]
  for I in e:
   if len(d:=C(B,*I[:-1]))==2 and len({*d.values()})==1:O+=[([*{0,1,2}-{*d}][0],*I)]
  for V,x,X,y,Y,_ in sorted(O,key=lambda x:x[-1],reverse=1):
   T=eval(str(B))
   for j in R(x,X):
    for k in R(y,Y):T[j][k]=V
   if T not in s:q+=[T];s+=[T];break
</code></pre>
<p><a href="https://tio.run/##dVNda9swFH2ef4UolEqxUiTlZWhoUO@pLyuUNCRoothI6ZwPO7Xd4FDy27Mr2W5T2hmM5ft57jlXu0Pztywm33fV6XSvqrR4ctFebdJtZlNkZVE2yF4KlBYWvpPIuiX6hRPa0jk90AWREbLq9RihZVmhFcoLlOhWzg3Yg6nxppU@yIWRVjdG2esn1@CGMhLzCFWueakKZEPdJc58vUTpjGax1syMNq7AGRyIMTqcyaUwXbPWV77HjHp7QqggQ8/DB4/P7p3I0pnq0LexAPyHWBA65t6VL5EPt0SpiZypbdpiS9fuMFDRAvzWEB/qNmfBAoL16JVRTsVx/DqyRwMd@wD4vd6nmxdXY3KEYA65tUPbvPhvccic/RzzADdMM@@mCZC7KTr7orN3Q8hEz41eGDWLkFP6I0UdQV3uGT9v7JDPzWLe0xrzr3oObp/9HuGx7/GNVPNxS/zC7PGDVIvxgUgXK437naE3owcCCJ9prXRiKLwd3MRXf/bFBvryYF@HtQrH3B/XgUrZ704C8Xdh5BBx6yOcPJdUBs1Ht1qOOUwLmoV1/lIgeeeRfhYU0snQYjZsP330zeqyapzFdx8FbTU0o5Xbu6p2qudoqhx0w3VTeUEGPVaDwvMzJdaDvHDHpnpl9DqIG6aaIn8tfWv5DHCn5kfdfbLKpetTzZFCFxcXEReMcSZYxDgXQjABBwb/nEUiOMDF/eMtwQ7GiLPOCekC8hiPfC1/QZvyMSvTyuIagH7r@dd6tE13OC8ainJi3lRa5pvGVfh3WTiK6ut6t8kbfPWnuCJAZLSrIAEv8XtJTgg5/QM" rel="nofollow noreferrer">Try it online!</a></p>
<h2>Python3, 1271 bytes</h2>
<p>An even longer solution. Here, the original convolution rules have been extended to any <code>j x k</code> window, where <code>j &lt;= n</code> and <code>k &lt;= m</code>. This greatly increases performance, however, it still requires <code>O(n^4)</code> to produce the windows in the first place.</p>
<pre class="lang-py prettyprint-override"><code>import math
R=range
v=lambda d:not d%2 and d%3
def C(B,x,X,y,Y):
 d={}
 for j in B[x:X]:
  for t in j[y:Y]:d[t]=d.get(t,0)+1
 return d
def f(b):
 B=[b,b+[[0]*len(b[0])]][len(b)%2]
 for x in R(0,len(B),2):
  for y in R(0,len(B[0]),2):
   d,V=C(B,x,x+2,y,y+2),-1
   if len(d)==3:V=max(d,key=lambda x:d[x])
   elif len(d)==2:V=[*{0,1,2}-{*d}][0]if len({*d.values()})==1 else min(d,key=lambda x:d[x])
   if V&gt;-1:
    for X in R(x,x+2):
     for Y in R(y,y+2):B[X][Y]=V
 e=[]
 for x in R(len(B)):
   for y in R(len(B[0])):
    for X in R(x+1,len(B)+1):
     for Y in R(y+1,len(B[0])+1):
      if v(A:=X-x)and v(U:=Y-y):e+=[(x,X,y,Y,A*U)]
 q,s=[B],[B]
 for B in q:
  if len({i for k in B for i in k})==1:return B
  O=[]
  for I in e:
   if len(d:=C(B,*I[:-1]))&gt;1:
    G=math.gcd(*d.values());M={i:d[i]/G for i in d}
    if all(M[i]==int(M[i])for i in M):
     M={i:int(M[i])for i in M}
     if len(M)==2:
      if len(o:={*M.values()})==1:O+=[([*{0,1,2}-{*M}][0],*I)]
      if{1,3}==o:O+=[(min(M,key=lambda x:M[x]),*I)]
     elif len(M)==3:
      if[1,1,2]==sorted(M.values()):O+=[(max(M,key=lambda x:M[x]),*I)]
  for V,x,X,y,Y,_ in sorted(O,key=lambda x:x[-1],reverse=1):
   T=eval(str(B))
   for j in R(x,X):
    for k in R(y,Y):T[j][k]=V
   if T not in s:q+=[T];s+=[T];break
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=fVRLbtswEN10U52CCBCUtGlXVDYFAwaIugiyUAMEjmGDFQK5pBPZsuRIiiHD8Em6yaY9RG_SXqTbDinJHzStAUPUfN7MPD7N1-_LdfmYpS8v357Lae_Drze_48Uyy0u0iMpH51bkUfqgnZVIosVERUjxNCuROvVQlCp4njlKT9FH7NOKjuiajgl3kBKbrYOmWY5mKE6RLys-CsFuTaUxzeSaj0OuZBkK1X_QJS6pS7rMQbkun_MUKYs7xROD5ws5oZOulG7YSXSKJ3AgYSjtmZx6YV2sMsi32KXG7hPqkbbm-shjshsnUnQo6u6rrgf9r7seoT1mXPEUmXBFhDjjQ7GIKqzoXK9bKipovwqJCdXJQbAHwbKzcSmj3ra36ahtCBWbAHjtr6LkWReYbCGYQW6h0SJO_wkOmcOLHrPt2mlG9TS25XqK2j6u7fUQ3JejUI5DMXSQFvKYopqgOveAnx075O9iXdbQ2mWv1WzdJnsfYXpf4UsuRr2KGMGs8B0X496acN0VEjeaoZedOwIdPtFCSD-k8K_b9Q36kwFr6YutfW5lZY-xOc4tlbzRjg_xN3ZkG3FtIjQ_vFJu77xzLXmPwbQXDblXwoi-__BF4YNrIueB2MRwH3H4_mpfU22dZsIoSXAAXiHitLQnsosKWiosxiv-GqXtLLD62ZNnbBkXm05wrBp-Y-g7VFlgVQYzGSKb9A2jZ1shsjraaCw41lhgNHaQs9NxYEW_A5LMlIEBC9gMWuF9N6TBho_jf9hm3mG7Iui9mbyBujnOqiTcCM31SueFFo2QBkJDPVyUuVFtK9pZ-xmMDuQ6b78BWEQDOQvl3H4BlswBMrvLlOZP0PQgPC_qxyTX0bzefz9_FAwJdHJy4jDPdZnruY7LmOd5rgcHF96Z63jWAS5mfsZi7WB0mFs7Id2DPJc5BsssszK7n2RRrnAB_b5ttCplZxEtMQiDopiEO11M46TUOf6UpZqiol8sk7jE7z6n7wjw6Sxzo6Qp3kMyQkg9QbvJ_wA" rel="nofollow noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu1" class="pu"><h1>C, 404 bytes</h1>

<p>My first code golf, I'm pretty happy with how it turned out. Took way too long, though. It's not fully standard C, just whatever will compile under gcc with no special flags (and ignoring warnings). So there's a nested function in there. The function <code>f</code> takes the dimensions <code>m</code> and <code>n</code> as its first arguments, and as it's third argument takes takes an (int pointer) to an array of size <code>m</code>×<code>n</code> (indexed by rows first). The other arguments are dummy arguments, you don't need to pass them in, they're just there to save bytes on declaring variables.  It writes each changed pair to STDOUT in the format <code>row1,col1:row1,col1;</code>, with the semicolon separating the pairs. Uses 0-based indexing.</p>

<pre><code>#define A a[i*o+p
#define B A*c
f(m,n,a,i,j,o,p,b,c,d)int*a;{
int t(x){printf("%d,%d:%d,%d;",b?i:c+x,b?c+x:i,b?i:c+1+x,b?c+1+x:i);}
o=n;p=b=1;for(;~b;b--){
for(i=0;i&lt;m;i++){c=j=0;
for(;j&lt;n;)c+=A*j++];d=c*n%3;
for(j=0;j&lt;n-1;j++) 
while(A*j]^d|A*j+p]^d){
for(c=j;B]==B+p];c++);
if(c&lt;n-2&amp;B]==d&amp;2*(B+p]+A*(c+2)])%3==d)
B+p]=A*(c+2)]=d,t(1);else
B]=B+p]=2*(B]+B+p])%3,
t(0);}}o=m;p=m=n;n=o;o=1;}}
</code></pre>

<p>I used a slightly different algorithm than OP for solving individual rows/columns. It goes something like this(pseudocode):</p>

<pre><code>for j in range [0, rowlength):
    while row[j] != targetCol or row[j+1] != targetCol:
        e=j
        while row[e] == row[e+1]:
            e++             //e will never go out of bounds
        if e&lt;=rowLength-3 and row[e] == targetCol 
                and (row[e+1] != row[e+2] != targetCol):
            row.changeColor(e+1, e+2)
        else:
            row.changeColor(e, e+1)
</code></pre>

<p>The <code>for(;~b;b--)</code> loop executes exactly twice, on the second pass it solves columns instead of rows. This is done by swapping <code>n</code> and <code>m</code>, and changing the values of <code>o</code> and <code>p</code> which are used in pointer arithmetic to address the array.</p>

<p>Here's a version that's ungolfed, with a test main, and prints the whole array after every move (press enter to step 1 turn):</p>

<pre><code>#define s(x,y)b?x:y,b?y:x
#define A a[i*o+p
#define B A*e
f(m,n,a,i,j,o,p,b,c,d,e)int*a;{

    int t(x){
        printf("%d,%d:%d,%d;\n",s(i,e+x),s(i,e+1+x));
        getchar();
        printf("\n");
        for(int i2=0;i2&lt;(b?m:n);i2++){
            for(int j2=0;j2&lt;(b?n:m);j2++){
                printf("%d ",a[i2*(b?n:m)+j2]);
            }
            printf("\n");
        }
        printf("\n");
    }

    printf("\n");
    b=1;
    for(int i2=0;i2&lt;(b?m:n);i2++){
        for(int j2=0;j2&lt;(b?n:m);j2++){
            printf("%d ",a[i2*(b?n:m)+j2]);
        }
        printf("\n");
    }
    printf("\n");

    o=n;p=1;
    for(b=1;~b;b--){
        for(i=0;i&lt;m;i++){
            c=0;
            for(j=0;j&lt;n;j++) c+= a[i*o+p*j];
            d=0;
            d = (c*n)%3;
            for(j=0;j&lt;n-1;j++) {
                while(a[i*o+p*j]!=d||a[i*o+p*j+p]!=d){
                    for(e=j;a[i*o+p*e]==a[i*o+p*e+p];e++);
                    if(e&lt;=n-3 &amp;&amp; a[i*o+p*e]==d 
                            &amp;&amp; 2*(a[i*o+p*e+p]+a[i*o+p*(e+2)])%3==d){
                        a[i*o+p*e+p]=a[i*o+p*(e+2)]=d;
                        t(1);
                    }else{
                        a[i*o+p*e]=a[i*o+p*e+p] = 2*(a[i*o+p*e]+a[i*o+p*e+p])%3;
                        t(0);
                    }
                }
            }
        }
        o=m;p=m=n;n=o;o=1;
    }
}

main(){
    int g[11][11] = 
    {
        {0,2,1,2,2,1,0,1,1,0,2},
        {2,1,1,0,1,1,2,0,2,1,0},
        {1,0,2,1,0,1,0,2,1,2,0},
        {0,0,2,1,2,0,1,2,0,0,1},
        {0,2,1,2,2,1,0,0,0,2,1},
        {2,1,1,0,1,1,2,1,0,0,2},
        {1,0,2,1,0,1,0,2,2,1,2},
        {0,0,2,1,2,0,1,0,1,2,0},
        {1,2,0,1,2,0,0,2,1,2,0},
        {2,1,1,0,1,1,2,1,0,0,2},
        {0,2,1,0,1,0,2,1,0,0,2},
    };
    #define M 4
    #define N 7
    int grid[M][N];
    for(int i=0;i&lt;M;i++) {
        for(int j=0;j&lt;N;j++) {
            grid[i][j] = g[i][j];
        }
    }
    f(M,N,grid[0],0,0,0,0,0,0,0,0);
};
</code></pre>
</div>
<div id="pu2" class="pu"><h2>Lua, <s>594</s> <s>575</s> 559 Bytes</h2>

<p><strong>Warning</strong> There's still lots of work before I'm done with this golfing! I should be able to take that under 500 Bytes, at the very least. For the moment, it's the first solution that worked, and I'm still working on it.</p>
<p>I will provide a full explanation once I'm done.</p>
<pre class="lang-lua prettyprint-override"><code>function f(t)s=#t a=&quot;,&quot;for i=1,s do p=t[i]for i=1,s
do p.Q=p.Q and p.Q+p[i]or p[i]end p.Q=(p.Q*#p)%3 for i=1,s do for j=1,#p-1 do
x=p[j]y=p[j+1]u=x~=y and(p.S and p.R==p.S or x~=p.Q)v=(x+y)*2p[j]=u and v%3or x
p[j+1]=u and v%3or y print(i..a..j,i..a..j+1)end
p.R=p.S p.S=table.concat(p)end end
for i=1,s do Q=Q and Q+t[i][1]or t[i][1]end Q=(Q*s)%3 for i=1,s
do for j=1,s-1 do p=t[j]q=t[j+1]x=p[1]y=q[1]u=x~=y and(S and R==S or x~=Q)v=(x+y)*2
for k=1,#p do p[k]=u and v%3or x q[k]=u and v%3or y
print(j..a..k,j+1..a..k)end Y=Y and Y..x or x end
R=S S=Y end end
</code></pre>
</div>
<div id="pu3" class="pu"><h2>Octave, <s>334</s> 313 bytes</h2>

<p>Since the challenge may seem a bit daunting, I present my own solution. I did not formally prove that this method works (I guess that will come down to proving that the algorithm will never get stuck in a loop), but so far it works perfectly, doing 100x100 testcases within 15 seconds. Note that I chose to use a function with side effects rather than one that returns all the coordinates since that saved me a few bytes. Coordinates are row-major, 1-based, and formatted as <code>row1 col1 row2 col2</code>. Input colours are <code>0,1,2</code> since this works better with <code>mod</code>, at the cost of having to use <code>numel</code> rather than <code>nnz</code>. Golfed version: <em>Edit: saved another few bytes by using a technique from Kevin Lau's answer.</em></p>

<pre class="lang-matlab prettyprint-override"><code>function P(p)
k=0;[m,n]=size(p);t=@(v)mod(sum(v)*numel(v),3);for c=1:n
p(:,c)=V(p(:,c));end
k=1;for r=1:m
p(r,:)=V(p(r,:));end
function a=V(a)
while any(a-(g=t(a)))
isempty(q=find(diff(a)&amp;a(1:end-1)-g,1))&amp;&amp;(q=find(diff(a),1));
a([q q+1])=t(a([q q+1]));if k
disp([r q r q+1])
else
disp([q c q+1 c])
end;end;end;end
</code></pre>

<p>Example GIF of the solving algorithm:</p>

<p><a href="https://i.sstatic.net/njo6G.gif" rel="nofollow noreferrer"><img src="https://i.sstatic.net/njo6G.gif" alt="enter image description here"></a></p>

<p>Ungolfed version:</p>

<pre class="lang-matlab prettyprint-override"><code>function solveChromaticPuzzle(p)
[m,n]=size(p);                           % Get size
t=@(v)mod(sum(v)*numel(v),3);            % Target colour function
for c=1:n                                % Loop over columns
    p(:,c)=solveVec(p(:,c));             % Solve vector
end
for r=1:m                                % Loop over rows
    p(r,:)=solveVec(p(r,:));
end
    function a=solveVec(a)               % Nested function to get globals
        g=t(a);                          % Determine target colour
        while(any(a~=g))                 % While any is diff from target...
            % Do the finding magic. Working left-to-right, we find the
            % first pair that can be flipped (nonzero diff) that does not
            % have the left colour different from our goal colour
            q=min(intersect(find(diff(a)),find(a~=g)));
            if(isempty(q))               % In case we get stuck...
                q=find(diff(a),1);       % ... just flip the first possible
            end;
            a([q q+1])=t(a([q q+1]));    % Do the actual flipping.
            if(exist('r'))               % If we're working per row
                disp([r q r q+1])        % Print the pair, using global row
            else
                disp([q c q+1 c])        % Print the pari, using global col
            end
        end
    end
end
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://fr.wikipedia.org/wiki/Befunge" rel="nofollow noreferrer">Befunge</a>, <s>197</s> <s>368</s> <s>696</s> 754 Bytes</h1>

<hr>

<p>(yes, I'm doing some reverse code golf, the more bytes the better)</p>

<p><br/></p>

<p>I was thinking it could be a challenge to write this algorithm in Befunge and that it could be fun</p>

<p><s>I would like it to be a community program, so if anyone wants to work on it, please, do so.</s></p>

<p>In the end, I made everything alone so far, so I'll finish on my own (it's almost done)</p>

<hr>

<p>What's done yet: a troll-shaped code</p>

<pre><code>&amp;:19p&amp;:09p:v:p94g92g90  &lt;
 v94+1:g94&amp;_$59g1+59p1-:|
 &gt;p59gp1-: ^    vp95g93$&lt;
v94\-1&lt;v:g&lt;     &gt;  v
&gt;g:1+v^_$v^90p94g92&lt;
v5p94&lt;   3&gt;1+59p   ^
&gt;9gg+\:^ %g   v93:g95&lt;           v3_2         v
v1pg95g94&lt;^95&lt;&gt;g-v&gt;$v^           v ^-%3*2\gg9&lt;
&gt;9g39g+59g-1-|v-1_^ #^pg95+g92g90&lt;1_09g:29g+5^
       ;  &gt;  &gt;  09g:29g+59gg\3%-# !^v         &lt;
          ^p95&lt;                  ^  &lt;
     v  p96-1+g90g92&lt;
     v                  p95_@
            &gt;59g1+:39g-19g-^
     v    &gt;p 79g:59gg\1+59gp$$$$$29g49pv
    &gt; p59g^ |&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;!-g96g94&lt;
&gt;:79^&gt;29g49p&gt;69g1+59gg49g:59gg\1+49p- v
^\-\6+gg95+1\g&lt; v         !-g96:&lt;-1g94_^
&gt;"]",52*,::59g^v_::1+59gg\59gg-v^ &lt;
^ .-g93g95,.-g&lt;&gt;:69g- v  v-g96:_1+^
&gt;+" [,]",,,\29^       &gt;#v_$:49g2-v
^1:.-g93g95,.-g92\,"[ ":&lt;        &lt;
</code></pre>

<p>(yes, it's a troll, believe me)</p>

<p><br/></p>

<p>Basically, it reads an array and computes the move to do to solve the rows, given an input as</p>

<pre><code>(number of rows) (number of columns) 1 2 3 1 1 3 2 1 2 ....
</code></pre>

<p>(the whole array is passed as a list [row1, row2, row3,…])</p>

<p>output is</p>

<pre><code>[col row],[col',row']
[col2 row2],[col2',row2']
...
</code></pre>

<p>rows and cols both start at 0.</p>

<p><br/></p>

<p>Now that rows are solved, it's almost done ! Hooray !</p>

<hr>

<p>Explanation: (will be updated later on)</p>

<p><img src="https://i.sstatic.net/CxCxS.png" alt="image"></p>

<p>So there are 5 main parts :</p>

<ul>
<li>The first one, in green, reads the input line and writes one row of the array</li>
<li>The second one, in orange, passes to the next row of the array</li>
<li>The third, in the blue, sums a row</li>
<li>The fourth one, in hot pink, takes the modulus 3 of the sum, saves it at the right of the concerned row, and go to the next row</li>
<li>Finally, in the red, the part that computes the target color from the previously computed number. This part is really dumb and should probably be rewritten, but I didn't figure out how I could do that in a nice way (passed from 197 bytes to 368 with just that part)</li>
</ul>

<p>Grey parts are initialisations</p>

<hr>

<p>Here is a a deeper explanation of the module that finds the to boxes to combine (which is coded here, by the way)</p>

<pre><code>                                       B
            @                          v
            |                  !-g96g94&lt;
ENTRY&gt;29g49p&gt;69g1+59gg49g:59gg\1+49p- v
                v         !-g96:&lt;-1g94_^
               v_::1+59gg\59gg-v^ &lt;
               &gt;:69g- v  v-g96:_1+^
                      &gt;#v_$:49g2-v
                    CALL&lt;        &lt;
</code></pre>

<p>The CALL part is when the instruction pointer is going to another module, to combine to boxes. It comes back to this module through the 'B' entry</p>

<p>Here is some pseudo code:
(currentx is related to the array reading)
    For:</p>

<pre><code>    69g1+59gg  // read target color
    49g:59gg\1+49p // read current color and THEN shift the currentx to the next box
    if ( top != top ){  // if the current color is bad
        49g1-          //  put the current place  (or currentx - 1) in the stack
        While:
            if ( :top != 69g ){   // if you didn't reach the end of the list
                ::1+              // copy twice, add 1
                if ( 59gg == \59gg ){ // if the next color is the same than current
                   1+                // iterate
                   break While;
                }
            }

        : // copies j (the previous raw iterator)
        if ( top == 69g ){  // if you reached the end of the row (which mean you can't swap with the color after that point)
            $:              // discard j's copy and copy target
            49g2-           // put the place just before the color change on the stack
            combine_with_next;
        } else {
            combine_with_next;
        }
        29g49p   // back to the beginning of the row (there was some changes int the row)
    }

    if ( 49g != 69g ) // if you didn't reach the end of the list
        break For:
</code></pre>

<hr>

<p>Note that if you want to test it, you will have to put some trailing space and trailing new lines so that there is enough space to store the array, if you wish to use <a href="http://www.quirkster.com/iano/js/befunge.html" rel="nofollow noreferrer">the interpret</a> I linked.
22 + the number of rows in input as trailing lines, and 34 + the number of columns as trailing spaces on one line should be ok.</p>
</div>
<div id="pu5" class="pu"><h1>Rust, <s>496</s> 495 bytes</h1>

<p>Sadly I can't beat OP, but for a Rust answer I am quite satisfied with the bytecount.</p>

<pre><code>let s=|mut v:Vec&lt;_&gt;,c|{
let p=|v:&amp;mut[_],f,t|{
let x=|v:&amp;mut[_],i|{
let n=v[i]^v[i+1];v[i]=n;v[i+1]=n;
for k in f..t+1{print!("{:?}",if f==t{(k,i,k,i+1)}else{(i,k,i+1,k)});}};
let l=v.len();let t=(1..4).find(|x|l*x)%3==v.iter().fold(0,|a,b|a+b)%3).unwrap();
let mut i=0;while i&lt;l{let c=v[i];if c==t{i+=1;}else if c==v[i+1]{
let j=if let Some(x)=(i+1..l).find(|j|v[j+1]!=c){x}else{i-=1;i};x(v,j);}else{x(v,i);}}t};
p(&amp;mut (0..).zip(v.chunks_mut(c)).map(|(i,x)|{p(x,i,i)}).collect::&lt;Vec&lt;_&gt;&gt;(),0,c-1usize)};
</code></pre>

<p><strong>Input:</strong> a vector of numbers as well as the number of columns. E.g.</p>

<pre><code>s(vec!{1,2,1,3},2);
</code></pre>

<p>outputs</p>

<pre><code> (row1,col1,row2,col2)
</code></pre>

<p>to the command line.</p>

<p>I first solve every row and then solve the resulting column only once ,but print the steps for all columns. So it is actually quite efficient :-P.</p>

<p><strong>With formating:</strong></p>

<pre><code>let s=|mut v:Vec&lt;_&gt;,c|{  
    let p=|v:&amp;mut[_],f,t|{     // solves a single row/column
        let x=|v:&amp;mut[_],i|{   // makes a move and prints it 
            let n=v[i]^v[i+1]; // use xor to calculate the new color
            v[i]=n;
            v[i+1]=n;
            for k in f..t{
                print!("{:?}",if f==t{(k,i,k,i+1)}else{(i,k,i+1,k)});
            }
        };
        let l=v.len();
        // find target color
        // oh man i am so looking forward to sum() being stabilized
        let t=(1..4).find(|x|(l*x)%3==v.iter().fold(0,|a,b|a+b)%3).unwrap();
        let mut i=0;
        while i&lt;l{
            let c=v[i];
            if c==t{             // if the color is target color move on
                i+=1;
            }else if c==v[i+1]{ // if the next color is the same
                                // find the next possible move
                let j=if let Some(x)=(i+1..l).find(|j|v[j+1]!=c){x}else{i-=1;i};
                x(v,j);
            }else{              // colors are different so we can make a move
                x(v,i);         
            }
        }
        t
    };
    // first solve all rows and than sovle the resulting column c times 
    p(&amp;mut (0..).zip(v.chunks_mut(c)).map(|(i,x)|p(x,i,i)).collect::&lt;Vec&lt;_&gt;&gt;(),0,c-1usize)
};
</code></pre>

<p><strong>Edit:</strong>
now returns the color of the solution which saves me a semicolon^^</p>
</div>
<div id="pu6" class="pu"><h1>Ruby, 266 bytes</h1>

<p>More-or-less just a port of the Octave solution, except it solves rows first instead of columns. Input is an array of arrays, with the inner arrays being the rows. Output moves are <code>[row, column, row, column]</code>. <a href="https://repl.it/C9jd" rel="nofollow">Test suite</a></p>

<pre class="lang-ruby prettyprint-override"><code>-&gt;m{t=-&gt;v{v.size*v.inject(:+)%3}
s=-&gt;a,x,r{g=t[a]
(q=(r=0..a.size-2).find{|i|a[i]!=a[i+1]&amp;&amp;g!=a[i]}||r.find{|i|a[i]!=a[i+1]}
a[q,2]=[t[a[q,2]]]*2
p r ?[x,q,x,q+1]:[q,x,q+1,x])while[]!=a-[g]}
m.size.times{|i|s[m[i],i,1]}
m=m.shift.zip *m
m.size.times{|i|s[m[i],i,p]}}
</code></pre>

<h3>Ungolfed with explanation</h3>

<pre><code>-&gt;m{                                  # Start lambda function, argument `m`
  t=-&gt;v{v.size*v.inject(:+)%3}        # Target color function
  s=-&gt;a,x,r{                          # Function to determine proper moves
                                      #   a = row array, x = row index, r = horizontal
    g=t[a]                            # Obtain target color
    (
      q=(r=0..a.size-2).find{|i|      # Find the first index `i` from 0 to a.size-2 where...
        a[i]!=a[i+1]                  # ...that element at `i` is different from the next...
        &amp;&amp;g!=a[i]                     # ...and it is not the same as the target color
      } || r.find{|i|a[i]!=a[i+1]}    # If none found just find for different colors
      a[q,2]=[t[a[q,2]]]*2            # Do the color flipping operation
      p r ?[x,q,x,q+1]:[q,x,q+1,x]    # Print the next move based on if `r` is truthy
    ) while[]!=a-[g]}                 # While row is not all the same target color, repeat
m.size.times{|i|                      # For each index `i` within the matrix's rows...
  s[m[i],i,1]                         # ...run the solving function on that row
                                      #   (`r` is truthy so the moves printed are for rows)
}
m=m.shift.zip *m                      # Dark magic to transpose the matrix
m.size.times{|i|s[m[i],i,p]}}         # Run the solving function on all the columns now
                                      #   (`r` is falsy so the moves printed are for columns)
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/83791/">83791</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




