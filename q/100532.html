<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::100532</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td></td><td>250701T012835Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/282495#282495">macOSist</a></td></tr>
<tr d-ix="1"><td>013</td><td>MMIXAL</td><td>210522T192701Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/226154#226154">NoLonger</a></td></tr>
<tr d-ix="2"><td>053</td><td>Rust</td><td>210129T162032Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/218233#218233">Teodor M</a></td></tr>
<tr d-ix="3"><td>nan</td><td>C x86_64</td><td>161120T110038Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/100540#100540">user6213</a></td></tr>
<tr d-ix="4"><td>001</td><td>x86 .COM</td><td>180331T044912Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/160926#160926">l4m2</a></td></tr>
<tr d-ix="5"><td>001</td><td>MachineCode on x86_64</td><td>180311T185032Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/157842#157842">MD XF</a></td></tr>
<tr d-ix="6"><td>018</td><td>GNU C</td><td>180227T024701Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/156810#156810">MD XF</a></td></tr>
<tr d-ix="7"><td>009</td><td>Linux shell</td><td>180227T031043Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/156811#156811">MD XF</a></td></tr>
<tr d-ix="8"><td>007</td><td>C x86_64</td><td>161120T160539Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/100557#100557">Dennis</a></td></tr>
<tr d-ix="9"><td>024</td><td>Java</td><td>161121T230128Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/100680#100680">user8397</a></td></tr>
<tr d-ix="10"><td>002</td><td>TI83 Hex Assembly</td><td>161201T205652Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/101842#101842">habs</a></td></tr>
<tr d-ix="11"><td>045</td><td>ELF + x86 machine code</td><td>161121T135043Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/100619#100619">Florian </a></td></tr>
<tr d-ix="12"><td>003</td><td>ARM Unified Assembler Language UAL</td><td>161127T000355Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/101216#101216">user4268</a></td></tr>
<tr d-ix="13"><td>001</td><td>PDP11 Assembler UNIX Sixth Edition</td><td>161120T113718Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/100544#100544">user6213</a></td></tr>
<tr d-ix="14"><td>002</td><td>x86 MSDOS COM file</td><td>161120T154756Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/100556#100556">maservan</a></td></tr>
<tr d-ix="15"><td>025</td><td>NASM</td><td>161123T040707Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/100786#100786">apricot </a></td></tr>
<tr d-ix="16"><td>041</td><td>Bash on Raspbian on QEMU</td><td>161121T144418Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/100628#100628">Eric Tow</a></td></tr>
<tr d-ix="17"><td>010</td><td>Any shell sh</td><td>161121T225701Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/100678#100678">fluffy</a></td></tr>
<tr d-ix="18"><td>003</td><td>GNU as x86_64</td><td>161121T171349Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/100646#100646">Torkel B</a></td></tr>
<tr d-ix="19"><td>032</td><td>Python</td><td>161121T122102Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/100609#100609">Torkel B</a></td></tr>
<tr d-ix="20"><td>005</td><td>Swift</td><td>161120T183638Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/100564#100564">NobodyNa</a></td></tr>
<tr d-ix="21"><td>034</td><td>C 32bit Windows</td><td>161120T153302Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/100554#100554">anatolyg</a></td></tr>
<tr d-ix="22"><td>013</td><td>Ruby</td><td>161120T133959Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/100548#100548">daniero</a></td></tr>
<tr d-ix="23"><td>093</td><td>AutoIt</td><td>161120T133542Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/100547#100547">user4264</a></td></tr>
<tr d-ix="24"><td>009</td><td>Perl</td><td>161120T110411Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/100541#100541">user6213</a></td></tr>
<tr d-ix="25"><td>016</td><td>Microsoft C Visual Studio 2005 onwards</td><td>161120T095949Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/100534#100534">user6213</a></td></tr>
<tr d-ix="26"><td>025</td><td>GNU C</td><td>161120T095600Z</td><td><a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/100533#100533">user6213</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Swift 6 (non-competing)</h1>
<p>So, uh...</p>
<pre class="lang-swift prettyprint-override"><code>@MainActor func mainActorOnly() {
  print(&quot;Hi from the main actor!&quot;)
}

func doStuff() async {
  DispatchQueue.main.async { @MainActor in
    MainActor.assertIsolated()
    mainActorOnly()
  }
}

await doStuff()

// MARK: - The WTF-level stuff

struct DispatchQueue {
  static let main = Self()
  func async(_ work: () -&gt; Void) { work() }
}
</code></pre>
<p>This crashes with a <code>SIGILL</code> caused by a call to <code>fatalError(_:file:line:)</code> in <code>MainActor.assertIsolated()</code>.</p>
<h3>Details</h3>
<blockquote>
<p>Credit goes to <a href="https://oleb.net/2024/dispatchqueue-mainactor/" rel="nofollow noreferrer">this blog post</a> for documenting this behavior. The following explanation assumes at least a basic understanding of Swift concurrency — in particular, what the &quot;main actor&quot; is, and what it means for code to be isolated to it.</p>
</blockquote>
<p>This is a kinda big but also extremely silly hole in the implementation of Swift's concurrency model.</p>
<p>In short, there isn't actually any way for the compiler to prove that the closure passed to <code>DispatchQueue.main.async</code> (the real one from Foundation, not the impostor here) is guaranteed to be isolated to the main actor. So the type checker performs a <em>syntax-level</em> check for a closure passed to <em>something</em> called <code>DispatchQueue.main.async</code>, and will annotate the closure's type with <code>@_unsafeMainActor</code> if the check succeeds. (It should go without saying that this attribute does not perform any runtime checks on its own.)</p>
<p>To illustrate this, here's an example. This compiles and runs just fine (assuming that Foundation is imported, and that <code>mainActorOnly()</code> is a function annotated with <code>@MainActor</code>):</p>
<pre class="lang-swift prettyprint-override"><code>Task {
  DispatchQueue.main.async {
    mainActorOnly()
  }
}
</code></pre>
<p>but these don't:</p>
<pre class="lang-swift prettyprint-override"><code>Task {
  let queue = DispatchQueue.main
  queue.async {
    mainActorOnly() // error: call to main actor-isolated global function 'mainActorOnly()' in a synchronous nonisolated context
  }
}

Task {
  typealias DQ = DispatchQueue
  DQ.main.async {
    mainActorOnly() // error: call to main actor-isolated global function 'mainActorOnly()' in a synchronous nonisolated context
  }
}
</code></pre>
<p>This can be a little annoying, but it's not too tricky to work around when you need to. The real problem shows itself when you declare <em>your own type</em> named <code>DispatchQueue</code>, with its own static property called <code>main</code> and an instance method called <code>async</code> that takes a closure:</p>
<pre class="lang-swift prettyprint-override"><code>struct DispatchQueue {
  static let main = Self()
  func async(_ work: () -&gt; Void) { work() }
}
</code></pre>
<p>Our impostor <code>DispatchQueue.main.async</code> is quite evidently <em>not</em> isolated to the main actor, neither at compile-time nor at runtime. But the Swift compiler is none the wiser, and will happily let you call main actor-isolated code via this method.</p>
<p>(The runtime, however, isn't quite so naive, and correctly determines that
the closure passed to the fake <code>async</code> is nonisolated — this is why <code>MainActor.assertIsolated()</code> crashes in this case.)</p>
</div>
<div id="pu1" class="pu"><h1>MMIXAL, 13 bytes</h1>
<p><code>Main RESUME 2</code></p>
<p><code>RESUME</code> is legal in all code; <code>RESUME 1</code> throws a protection violation in user mode; any other argument throws an illegal instruction violation.</p>
</div>
<div id="pu2" class="pu"><h1>Rust, 53 bytes</h1>
<pre class="lang-rs prettyprint-override"><code>fn main(){unsafe{std::hint::unreachable_unchecked()}}
</code></pre>
<p>This piece of code generates no <code>main</code> function because main is marked as unreached, hence SIGILL being triggered when run. <a href="https://tio.run/##BcHBDcAgCADAVfrUFVimoYjBtPIQeBlnp3crzDO7XhOHlrpDDTtv8wYgQx0gdDGS4PPxHUrC9HIr9ZzMHw" rel="nofollow noreferrer" title="Rust – Try It Online">Try it online!</a></p>
</div>
<div id="pu3" class="pu"><h1>C (x86_64), 11, 30, 34, or 34+15 = 49 bytes</h1>
<pre><code>main[]=&quot;/&quot;;
</code></pre>
<pre><code>c=6;main(){((void(*)())&amp;c)();}
</code></pre>
<pre><code>main(){int c=6;((void(*)())&amp;c)();}
</code></pre>
<p>I've submitted a couple of solutions that use library functions to throw <code>SIGILL</code> via various means, but arguably that's cheating, in that the library function solves the problem. Here's a range of solutions that use no library functions, and make varying assumptions about where the operating system is willing to let you execute non-executable code. (The constants here are chosen for x86_64, but you could change them to get working solutions for most other processors that have illegal instructions.)</p>
<p><code>06</code> is the lowest-numbered byte of machine code that does not correspond to a defined instruction on an x86_64 processor. So all we have to do is execute it. (Alternatively, <code>2F</code> is also undefined, and corresponds to a single printable ASCII character.) Neither of these are guaranteed to always be undefined, but they aren't defined as of today.</p>
<p>The first program here executes <code>2F</code> from the read-only data segment. Most linkers aren't capable of producing a working jump from <code>.text</code> to <code>.rodata</code> (or their OS's equivalent) as it's not something that would ever be useful in a correctly segmented program; I haven't found an operating system on which this works yet. You'd also have to allow for the fact that many compilers want the string in question to be a wide string, which would require an additional <code>L</code>; I'm assuming that any operating system that this works on has a fairly outdated view of things, and thus is building for a pre-C94 standard by default. It's possible that there's nowhere this program works, but it's also possible that there's somewhere this program works, and thus I'm listing it in this collection of more-dubious-to-less-dubious potential answers. (After I posted this answer, Dennis also mentioned the possibility <code>main[]={6}</code> in chat, which is the same length, and which doesn't run into problems with character width, and even hinted at the potential for <code>main=6</code>; I can't reasonably claim these answers as mine, as I didn't think of them myself.)</p>
<p>The second program here executes <code>06</code> from the read-write data segment. On most operating systems this will cause a segmentation fault, because writable data segments are considered to be a bad design flaw that makes exploits likely. This hasn't always been the case, though, so it probably works on a sufficiently old version of Linux, but I can't easily test it.</p>
<p>The third program executes <code>06</code> from the stack. Again, this causes a segmentation fault nowadays, because the stack is normally classified as nonwritable for security reasons. The linker documentation I've seen heavily implies that it used to be legal to execute from the stack (unlike the preceding two cases, doing so is occasionally useful), so although I can't test it, I'm pretty sure there's some version of Linux (and probably other operating systems) on which this works.</p>
<p>Finally, if you give <code>-Wl,-z,execstack</code> (15 byte penalty) to <code>gcc</code> (if using GNU <code>ld</code> as part of the backend), it will explicitly turn off executable stack protection, allowing the third program to work and give an illegal operation signal as expected. I <em>have</em> tested and verified this 49-byte version to work. (Dennis mentions in chat that this option apparently works with <code>main=6</code>, which would give a score of 6+15. I'm pretty surprised that this works, given that the 6 blatantly isn't on the stack; the link option apparently does more than its name suggests.)</p>
</div>
<div id="pu4" class="pu"><h1>x86 .COM, 1 byte</h1>

<pre><code>c
</code></pre>

<p><code>ARPL</code> causes <code>#UD</code> in 16-bit mode</p>
</div>
<div id="pu5" class="pu"><h1><a href="//github.com/aaronryank/MachineCode" rel="nofollow noreferrer">MachineCode</a> on x86_64, <s>2</s> 1 bytes</h1>

<pre><code>7
</code></pre>

<p><a href="https://tio.run/##y01MzsjMS03OT0n9/9/I/P9/AA" rel="nofollow noreferrer">Try it online!</a></p>

<p>Simply calls the x86_64 instruction <code>0x07</code> (ceilingcat suggested 0x07 instead of 0x27)</p>
</div>
<div id="pu6" class="pu"><h1>GNU C, <s>24</s> <s>19</s> 18 bytes</h1>

<p><sup>-4 thanks to Dennis<br>
-1 thanks to ceilingcat</sup></p>

<pre><code>main(){goto*&amp;"'";}
</code></pre>

<p><a href="https://tio.run/##S9ZNT07@/z83MTNPQ7M6Pb8kX0tNSV3Juvb/fwA" rel="nofollow noreferrer">Try it online!</a> This assumes ASCII and x86_64. It attempts to run the machine code <code>27</code>, which ... is illegal.</p>

<hr>

<h1><a href="//git.io/shortC" rel="nofollow noreferrer">shortC</a>, <s>10</s> <s>5</s> 4 bytes</h1>

<pre><code>AV"'
</code></pre>

<p>Equivalent to the GNU C code above. <a href="https://tio.run/##K87ILypJ/v/fMUwpxuz/fwA" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu7" class="pu"><h1>Linux shell, 9 bytes</h1>

<pre><code>kill -4 0
</code></pre>

<p>Sends <code>SIGILL</code> to the process with PID 0. I don't know what process has PID 0, but it always exists.</p>

<p><a href="https://tio.run/##S0oszvj/PzszJ0dB10TB4P9/AA" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu8" class="pu"><h1>C (x86_64, <a href="http://savannah.nongnu.org/projects/tinycc" rel="noreferrer">tcc</a>), 7 bytes</h1>
<pre class="lang-c prettyprint-override"><code>main=6;
</code></pre>
<p>Inspired by <a href="https://codegolf.stackexchange.com/a/100540/12012">this answer</a>.</p>
<p><a href="https://tio.run/##S9YtSU7@/z83MTPP1sz6/38A" rel="noreferrer" title="C (tcc) – Try It Online">Try it online!</a></p>
<h3>How it works</h3>
<p>The generated assembly looks like this.</p>
<pre class="lang-asm prettyprint-override"><code>    .globl  main
main:
    .long 6
</code></pre>
<p>Note that TCC doesn't place the defined &quot;function&quot; in a <em>data</em> segment.</p>
<p>After compilation, <em>_start</em> will point to <em>main</em> as usual. When the resulting program is executed, it expects code in <em>main</em> and finds the little-endian(!) 32-bit integer <strong>6</strong>, which is encoded as <strong>0x06 0x00 0x00 0x00</strong>. The first byte – <strong>0x06</strong> – is an invalid opcode, so the program terminates with <em>SIGILL</em>.</p>
<hr />
<h1>C (x86_64, <a href="https://gcc.gnu.org/" rel="noreferrer">gcc</a>), 13 bytes</h1>
<pre class="lang-c prettyprint-override"><code>const main=6;
</code></pre>
<p><a href="https://tio.run/##S9ZNT07@/z85P6@4RCE3MTPP1sz6/38A" rel="noreferrer" title="C (gcc) – Try It Online">Try it online!</a></p>
<h3>How it works</h3>
<p>Without the <em>const</em> modifier, the generated assembly looks like this.</p>
<pre class="lang-asm prettyprint-override"><code>    .globl  main
    .data
main:
    .long   6
    .section    .note.GNU-stack,&quot;&quot;,@progbits
</code></pre>
<p>GCC's linker treats the last line as a hint that the generated object does not require an executable stack. Since <em>main</em> is explicitly placed in a <em>data</em> section, the opcode it contains isn't executable, so the program terminates will <em>SIGSEGV</em> (segmentation fault).</p>
<p>Removing either the second or the last line will make the generated executable work as intended. The last line could be ignored with the compiler flag <code>-zexecstack</code> (<a href="https://tio.run/##S9ZNT07@/z83MTPP1sz6//9/yWk5ienF/3WrUitSk4tLEpOzAQ" rel="noreferrer" title="C (gcc) – Try It Online">Try it online!</a>), but this costs <strong>12 bytes</strong>.</p>
<p>A shorter alternative is to declare <em>main</em> with the <em>const</em> modifier, resulting in the following assembly.</p>
<pre class="lang-asm prettyprint-override"><code>        .globl  main
        .section    .rodata
main:
        .long   6
        .section    .note.GNU-stack,&quot;&quot;,@progbits
</code></pre>
<p>This works without any compiler flags. Note that <code>main=6;</code> would write the defined &quot;function&quot; in <em>data</em>, but the <em>const</em> modifier makes GCC write it in <em>rodata</em> instead, which (at least on my platform) is allowed to contain code.</p>
</div>
<div id="pu9" class="pu"><h1>Java, <s>50</s> <s>43</s> 24 bytes</h1>

<pre><code>a-&gt;a.exec("kill -4 $$");
</code></pre>

<p>This is a <code>java.util.function.Consumer&lt;Runtime&gt;</code><sup>1</sup> whose command is stolen from <a href="https://codegolf.stackexchange.com/a/100678">fluffy's answer</a>. It works because you <em>must</em> call it as <code>whateverNameYouGiveIt.accept(Runtime.getRuntime())</code>!</p>

<p>Note that this will create a new process and make it throw a SIGILL rather than throwing a SIGILL itself.</p>

<p><sup>1 - Technically, it can also be a <code>java.util.function.Function&lt;Runtime, Process&gt;</code> because <code>Runtime#exec(String)</code> returns a <code>java.lang.Process</code> which can be used to control the process you just created by executing a shell command.</sup></p>

<hr>

<p>For the sake of doing something more impressive in such a verbose language, here's a <s>72</s> <s>60</s> 48-byte bonus:</p>

<pre><code>a-&gt;for(int b=0;;b++)a.exec("sudo kill -s 4 "+b);
</code></pre>

<p>This one is another <code>Consumer&lt;Runtime&gt;</code> that goes through ALL processes (including itself), making each of them throw a SIGILL. Better brace for a violent crash.</p>

<hr>

<p>And another bonus (a <code>Consumer&lt;ANYTHING_GOES&gt;</code>), which at least <em>pretends</em> to throw a SIGILL in 20 bytes:</p>

<pre><code>a-&gt;System.exit(132);
</code></pre>
</div>
<div id="pu10" class="pu"><h1>TI-83 Hex Assembly, 2 bytes</h1>
<pre><code>PROGRAM:I
:AsmPrgmED77
</code></pre>
<p>Run as <code>Asm(prgmI)</code>. Executes the illegal 0xed77 opcode. I count each pair of hex digits as one byte.</p>
</div>
<div id="pu11" class="pu"><h1>ELF + x86 machine code, 45 bytes</h1>

<p>This should be the smallest executable program on an Unix machine that throws SIGILL (due to Linux not recognizing the executable if made any smaller).</p>

<p>Compile with <code>nasm -f bin -o a.out tiny_sigill.asm</code>, tested on an x64 virtual machine.</p>

<p>Actual 45 bytes binary:</p>

<pre><code>0000000 457f 464c 0001 0000 0000 0000 0000 0001

0000020 0002 0003 0020 0001 0020 0001 0004 0000

0000040 0b0f c031 cd40 0080 0034 0020 0001
</code></pre>

<p>Assembly listing (see source below):</p>

<pre><code>;tiny_sigill.asm      
BITS 32


            org     0x00010000

            db      0x7F, "ELF"             ; e_ident
            dd      1                                       ; p_type
            dd      0                                       ; p_offset
            dd      $$                                      ; p_vaddr 
            dw      2                       ; e_type        ; p_paddr
            dw      3                       ; e_machine
            dd      _start                  ; e_version     ; p_filesz
            dd      _start                  ; e_entry       ; p_memsz
            dd      4                       ; e_phoff       ; p_flags


_start:
                ud2                             ; e_shoff       ; p_align
                xor     eax, eax
                inc     eax                     ; e_flags
                int     0x80
                db      0
                dw      0x34                    ; e_ehsize
                dw      0x20                    ; e_phentsize
                db      1                       ; e_phnum
                                                ; e_shentsize
                                                ; e_shnum
                                                ; e_shstrndx

  filesize      equ     $ - $$
</code></pre>

<p>Disclaimer: code from the following tutorial on writing the smallest assembly program to return a number, but using opcode ud2 instead of mov:
<a href="http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html" rel="nofollow noreferrer">http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html</a></p>
</div>
<div id="pu12" class="pu"><h1>ARM Unified Assembler Language (UAL), 3 bytes</h1>

<pre><code>nop
</code></pre>

<p>For example:</p>

<pre><code>$ as ill.s -o ill.o
$ ld ill.o -o ill
ld: warning: cannot find entry symbol _start; defaulting to 00010054
$ ./ill 
Illegal instruction
</code></pre>

<p>After executing <code>nop</code>, the processor interprets the <code>.ARM.attributes</code> section as code and encounters an illegal instruction somewhere there:</p>

<pre><code>$ objdump -D ill

ill:     file format elf32-littlearm


Disassembly of section .text:

00010054 &lt;__bss_end__-0x10004&gt;:
   10054:       e1a00000        nop                     ; (mov r0, r0)

Disassembly of section .ARM.attributes:

00000000 &lt;.ARM.attributes&gt;:
   0:   00001341        andeq   r1, r0, r1, asr #6
   4:   61656100        cmnvs   r5, r0, lsl #2
   8:   01006962        tsteq   r0, r2, ror #18
   c:   00000009        andeq   r0, r0, r9
  10:   01080106        tsteq   r8, r6, lsl #2
</code></pre>

<p>Tested on a Raspberry Pi 3.</p>
</div>
<div id="pu13" class="pu"><h1>PDP-11 Assembler (UNIX Sixth Edition), 1 byte</h1>
<pre><code>9
</code></pre>
<p>Instruction 9 is not a valid instruction on the PDP-11 (in octal, it would be <code>000011</code>, which does not appear on <a href="http://www.cdf.toronto.edu/%7Eajr/258/pdp11.pdf" rel="noreferrer">the list of instructions</a> (PDF)). The PDP-11 assembler that ships with UNIX Sixth Edition apparently echoes everything it doesn't understand into the file directly; in this case, 9 is a number, so it generates a literal instruction 9. It also has the odd property (unusual in assembly languages nowadays) that files start running from the start, so we don't need any declarations to make the program work.</p>
<p>You can test out the program using <a href="http://pdp11.aiju.de/" rel="noreferrer">this emulator</a>, although you'll have to fight with it somewhat to input the program.</p>
<p>Here's how things end up once you've figured out how to use the filesystem, the editor, the terminal, and similar things that you thought you already knew how to use:</p>
<pre><code>% a.out
Illegal instruction -- Core dumped
</code></pre>
<p>I've confirmed with the documentation that this is a genuine <code>SIGILL</code> signal (and it even had the same signal number, 4, all the way back then!)</p>
</div>
<div id="pu14" class="pu"><h1>x86 MS-DOS COM file, 2 bytes</h1>

<p><strong>EDIT:</strong> As pointed out in the comments, DOS itself will not trap the CPU exception and will simply hang (not just the app, the entire OS). Running on a 32-bit NT-based OS such as Windows XP will, indeed, trigger an illegal instruction signal.</p>

<pre><code>0F 0B
</code></pre>

<p>From the <a href="http://x86.renejeschke.de/html/file_module_x86_id_318.html" rel="noreferrer">documentation</a>:</p>

<blockquote>
  <p>Generates an invalid opcode. This instruction is provided for software testing to explicitly generate an invalid opcode.</p>
</blockquote>

<p>Which is pretty self-explanatory. Save as a .com file, and <strike>run in any DOS emulator</strike> DOS emulators will just crash. Run on Windows XP, Vista, or 7 32-bit.</p>

<p><a href="https://i.sstatic.net/85VuO.png" rel="noreferrer"><img src="https://i.sstatic.net/85VuO.png" alt="SIGILL on Windows XP"></a></p>
</div>
<div id="pu15" class="pu"><h1>NASM, 25 bytes</h1>

<p>I don't know how this works, just that it does on my computer specifically (Linux x86_64).</p>

<pre><code>global start
start:
jmp 0
</code></pre>

<p>Compile &amp; run like:</p>

<pre><code>$ nasm -f elf64 ill.asm &amp;&amp; ld ill.o &amp;&amp; ./a.out
ld: warning: cannot find entry symbol _start; defaulting to 0000000000400080
Illegal instruction
</code></pre>
</div>
<div id="pu16" class="pu"><h2>Bash on Raspbian on QEMU, 4 (1?) bytes</h2>

<p>Not my work.  I merely report the work of another.  I'm not even in a position to test the claim.  Since a crucial part of this challenge seems to be finding an environment where this signal will be raised and caught, I'm not including the size of QEMU, Raspbian, or bash.</p>

<p>On Feb 27, 2013 8:49 pm, user <a href="https://www.raspberrypi.org/forums/memberlist.php?mode=viewprofile&amp;u=59462&amp;sid=0e95d50056c1d75daa9a3183a3596b4e" rel="noreferrer">emlhalac</a> reported "<a href="https://www.raspberrypi.org/forums/viewtopic.php?p=298537" rel="noreferrer">Getting 'illegal instruction' when trying to chroot</a>" on the Raspberry Pi fora.</p>

<pre><code>ping
</code></pre>

<p>producing </p>

<pre><code>qemu: uncaught target signal 4 (Illegal instruction) - core dumped
Illegal instruction (core dumped)
</code></pre>

<p>I imagine much shorter commands will produce this output, for instance, <code>tr</code>.</p>

<p>EDIT:  Based on <a href="https://codegolf.stackexchange.com/questions/100532/shortest-code-to-throw-sigill/100628#comment244372_100628">@fluffy's comment</a>, reduced the conjectured lower bound on input length to "1?".</p>
</div>
<div id="pu17" class="pu"><h1>Any shell (sh, bash, csh, etc.), any POSIX (10 bytes)</h1>

<p>Trivial answer but I hadn't seen anyone post it.</p>

<pre><code>kill -4 $$
</code></pre>

<p>Just sends SIGILL to the current process. Example output on OSX:</p>

<pre><code>bash-3.2$ kill -4 $$
Illegal instruction: 4
</code></pre>
</div>
<div id="pu18" class="pu"><h1>GNU as (x86_64), 3 bytes</h1>

<pre><code>ud2
</code></pre>

<hr>

<p>$ xxd sigill.S</p>

<pre><code>00000000: 7564 32                                  ud2
</code></pre>

<p>$ as --64 sigill.S -o sigill.o ; ld -S sigill.o -o sigill</p>

<pre><code>sigill.S: Assembler messages:
sigill.S: Warning: end of file not at end of a line; newline inserted
ld: warning: cannot find entry symbol _start; defaulting to 0000000000400078
</code></pre>

<p>$ ./sigill</p>

<pre><code>Illegal instruction
</code></pre>

<p>$ objdump -d sigill</p>

<pre><code>sigill:     file format elf64-x86-64

Disassembly of section .text:

0000000000400078 &lt;__bss_start-0x200002&gt;:&gt;
  400078:       0f 0b                   ud2
</code></pre>
</div>
<div id="pu19" class="pu"><h1>Python, 32 bytes</h1>

<pre><code>from os import*;kill(getpid(),4)
</code></pre>
</div>
<div id="pu20" class="pu"><h1>Swift, 5 bytes</h1>

<pre><code>[][0]
</code></pre>

<p>Access index 0 of an empty array.  This calls <code>fatalError()</code>, which prints an error message and crashes with a SIGILL.  <a href="http://swiftlang.ng.bluemix.net/#/repl/5831ec1d892718588ddb0ddb">You can try it here</a>.</p>
</div>
<div id="pu21" class="pu"><h1>C (32-bit Windows), 34 bytes</h1>

<pre><code>f(i){(&amp;i)[-1]-=9;}main(){f(2831);}
</code></pre>

<p>This only works if compiling without optimizations (else, the illegal code in the <code>f</code> function is "optimized out").</p>

<p>Disassembly of the <code>main</code> function looks like this:</p>

<pre><code>68 0f 0b 00 00    push 0b0f
e8 a1 d3 ff ff    call _f
...
</code></pre>

<p>We can see that it uses a <code>push</code> instruction with a literal value <code>0b0f</code> (little-endian, so its bytes are swapped). The <code>call</code> instruction pushes a return address (of the <code>...</code> instruction), which is situated on the stack near the parameter of the function. By using a <code>[-1]</code> displacement, the function overrides the return address so it points 9 bytes earlier, where the bytes <code>0f 0b</code> are.</p>

<p>These bytes cause an "undefined instruction" exception, as designed.</p>
</div>
<div id="pu22" class="pu"><h1>Ruby, 13 bytes</h1>

<pre><code>`kill -4 #$$`
</code></pre>

<p>I guess it's safe to assume that we are running this from a *nix shell. The backtick literals runs the given shell command. <code>$$</code> is the running Ruby process, and the <code>#</code> is for string interpolation.</p>

<hr>

<p>Without calling the shell directly:</p>

<h1>Ruby, 17 bytes</h1>

<pre class="lang-rb prettyprint-override"><code>Process.kill 4,$$
</code></pre>
</div>
<div id="pu23" class="pu"><h1><a href="http://autoitscript.com" rel="noreferrer">AutoIt</a>, 93 bytes</h1>

<p>Using flatassembler inline assembly:</p>

<pre><code>#include&lt;AssembleIt.au3&gt;
Func W()
_("use32")
_("ud2")
_("ret")
EndFunc
_AssembleIt("int","W")
</code></pre>

<p>When run in SciTE interactive mode, it'll crash immediately. The Windows debugger should popup for a fraction of a second. The console output will be something like this:</p>

<pre><code>--&gt; Press Ctrl+Alt+Break to Restart or Ctrl+Break to Stop
0x0F0BC3
!&gt;14:27:09 AutoIt3.exe ended.rc:-1073741795
</code></pre>

<p>Where <code>-1073741795</code> is the undefined error code thrown by the WinAPI. This can be any negative number.</p>

<p>Similar using my own assembler <a href="https://www.autoitscript.com/forum/topic/173946-light-assembler-lasm-and-a-bunch-of-examples/" rel="noreferrer">LASM</a>:</p>

<pre><code>#include&lt;LASM.au3&gt;
$_=LASM_ASMToMemory("ud2"&amp;@CRLF&amp;"ret 16")
LASM_CallMemory($_,0,0,0,0)
</code></pre>
</div>
<div id="pu24" class="pu"><h1>Perl, 9 bytes</h1>
<pre><code>kill+4,$$
</code></pre>
<p>Simply calls the appropriate library function for signalling a process, and gets the program to signal itself with <code>SIGILL</code>. No actual illegal instructions are involved here, but it produces the appropriate result. (I think this makes the challenge fairly cheap, but if anything's allowed, this is the loophole you'd use…)</p>
</div>
<div id="pu25" class="pu"><h1>Microsoft C (Visual Studio 2005 onwards), 16 bytes</h1>
<pre><code>main(){__ud2();}
</code></pre>
<p>I can't easily test this, but according to <a href="https://msdn.microsoft.com/en-us/library/aa983360(v=vs.80).aspx" rel="noreferrer">the documentation</a> it should produce an illegal instruction by intentionally trying to execute a kernel-only instruction from a user-mode program. (Note that because the illegal instruction crashes the program, we don't have to try to return from <code>main</code>, meaning that this K&amp;R-style <code>main</code> function is valid. Visual Studio never having moved on from C89 is normally a bad thing, but it came in useful here.)</p>
</div>
<div id="pu26" class="pu"><h1>GNU C, 25 bytes</h1>
<pre><code>main(){__builtin_trap();}
</code></pre>
<p>GNU C (a specific dialect of C with extensions) contains an instruction to crash the program intentionally. The exact implementation varies from version to version, but often the developers make an attempt to implement the crash as cheaply as possible, which normally involves the use of an illegal instruction.</p>
<p>The specific version I used to test is <code>gcc (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0</code>; however, this program causes a SIGILL on a fairly wide range of platfoms, and thus is fairly portable. Additionally, it does it via actually executing an illegal instruction. Here's the assembly code that the above compiles into with default optimization settings:</p>
<pre><code>main:
    pushq %rbp
    movq %rsp, %rbp
    ud2
</code></pre>
<p><code>ud2</code> is an instruction that Intel guarantees will always remain undefined.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/100532/">100532</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




