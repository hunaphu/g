<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::51870</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>164</td><td>APLNARS</td><td>250120T214428Z</td><td><a href="https://codegolf.stackexchange.com/questions/51870/naturally-linear-diophantine-equations/277782#277782">Rosario</a></td></tr>
<tr d-ix="1"><td>460</td><td>Axiom</td><td>170827T152956Z</td><td><a href="https://codegolf.stackexchange.com/questions/51870/naturally-linear-diophantine-equations/140649#140649">user5898</a></td></tr>
<tr d-ix="2"><td>nan</td><td></td><td>150620T170150Z</td><td><a href="https://codegolf.stackexchange.com/questions/51870/naturally-linear-diophantine-equations/51940#51940">Abr001am</a></td></tr>
<tr d-ix="3"><td>092</td><td>Pyth</td><td>150619T215713Z</td><td><a href="https://codegolf.stackexchange.com/questions/51870/naturally-linear-diophantine-equations/51904#51904">Jakube</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>APL(NARS), 164 chars</h1>
<pre><code>{(a b n)←⍵⋄(g x y)←{(u v)←⍵⋄v=0:u,1,0⋄(g x y)←∇v,v∣u⋄g,y,x-y×⌊u÷v}a b⋄0≠g∣n:,0⋄h←(⌊¯3+a÷⍨y×m)⌊∣⌊b÷⍨x×m←n÷g⋄0=≢z←z/⍨×/¨0≤¨z←((b×h..h+10)+x×m),¨(-a×h..h+10)+y×m:,0⋄z}
</code></pre>
<p>If a solution exist, it from the ten integer (positive and negative) <code>x,y</code> solution of <code>ax+by=n</code> search some solution where both <code>x&gt;0</code> and <code>y&gt;0</code> and return those in one array of array. If no solution it is find, it return ,0.
The problem is center the interval in the way it gets all both positive solution, and return only them
because find one solution in the integers positive and negative, is more easy:</p>
<pre><code>{(a b n)←⍵⋄(g x y)←{(u v)←⍵⋄v=0:u,1,0⋄(g x y)←∇v,v∣u⋄g,y,x-y×⌊u÷v}a b⋄0≠g∣n:0⋄(x×n÷g),y×n÷g}
</code></pre>
<p>test:</p>
<pre><code>  q←{(a b n)←⍵⋄(g x y)←{(u v)←⍵⋄v=0:u,1,0⋄(g x y)←∇v,v∣u⋄g,y,x-y×⌊u÷v}a b⋄0≠g∣n:,0⋄h←(⌊¯3+a÷⍨y×m)⌊∣⌊b÷⍨x×m←n÷g⋄0=≢z←z/⍨×/¨0≤¨z←((b×h..h+10)+x×m),¨(-a×h..h+10)+y×m:,0⋄z}
  q 99 78  1
0 
  q 99 78 3
0 
  q ¯2 3 11
2 5  5 7  8 9  11 11  14 13 
  q  3 ¯2 11
11 11  9 8  7 5  5 2 
  q 2 3 11
1 3  4 1 
  q 3 2 11
1 4  3 1 
  q 1152921504606846883x ¯576460752303423433x 1x 
1865020080981664048 3730040161963328151  1288559328678240615 2577118657356481268  712098576374817182 1424197152749634385  135637824071393749 271275648142787502 
  q ¯1152921504606846883x 576460752303423433x 1x 
440822928232029684 881645856464059381  1017283680535453117 2034567361070906264  1593744432838876550 3187488865677753147  2170205185142299983 4340410370284600030  2746665937445723416 5493331874891446913  3323126689749146849 6646253379498293796  3899587442052570282 7799174884105140679 
</code></pre>
</div>
<div id="pu1" class="pu"><h1>Axiom, 460 bytes</h1>
<pre><code>w(a,b,x,u)==(a=0=&gt;[b,x];w(b rem a,a,u,x-u*(b quo a)))
d(a,b,k)==(o:List List INT:=[];a=0 and b=0=&gt;(k=0=&gt;[1,1];[]);a=0=&gt;(k=0=&gt;[[1,0]];k rem b=0=&gt;[1,k quo b];[]);b=0=&gt;(k=0=&gt;[[0,1]];k rem a=0=&gt;[k quo a,1];[]);r:=w(a,b,0,1);q:=k quo r.1;(y,x,u,v):=(q*(r.1-r.2*a)quo b,q*r.2,b quo r.1,a quo r.1);m:=min(80,4+abs(k)quo min(abs(a),abs(b)));l:=y quo v;x:=x+l*u;y:=y-l*v;for n in -m..m repeat(t:=x+n*u;z:=y-n*v;t&gt;=0 and z&gt;=0 and t*a+z*b=k=&gt;(o:=cons([t,z],o)));sort(o))
</code></pre>
<p>ungolf and some test</p>
<pre><code>-- input a b and k for equation a*x+b*y=k
-- result one List of List of elments [x,y] of solution of  
-- that equation with x and y NNI (not negative integers) 
-- or Void list [] for no solution
diopanto(a,b,k)==
  o:List List INT:=[]
  a=0 and b=0=&gt;(k=0=&gt;[1,1];[])
  a=0=&gt;(k=0=&gt;[[1,0]];k rem b=0=&gt;[1,k quo b];[])
  b=0=&gt;(k=0=&gt;[[0,1]];k rem a=0=&gt;[k quo a,1];[])
  r:=w(a,b,0,1)
  q:=k quo r.1
  (y,x,u,v):=(q*(r.1-r.2*a)quo b,q*r.2,b quo r.1,a quo r.1)
  m:=min(80,4+abs(k)quo min(abs(a),abs(b)))
  l:=y quo v           -- center the interval
  x:=x+l*u; y:=y-l*v
  for n in -m..m repeat
     t:=x+n*u;z:=y-n*v
     t&gt;=0 and z&gt;=0 and t*a+z*b=k=&gt;(o:=cons([t,z],o))
  sort(o)

 ------------------------------------------------------
(4) -&gt; d(0,-9,0)
   (4)  [[1,0]]
                                                  Type: List List Integer
(5) -&gt; d(2,3,11)
   (5)  [[4,1],[1,3]]
                                                  Type: List List Integer
(6) -&gt; d(2,3,2)
   (6)  [[1,0]]
                                                  Type: List List Integer
(7) -&gt; d(2,3,1)
   (7)  []
                                                  Type: List List Integer
(8) -&gt; d(1152921504606846883,-576460752303423433,1)
   (8)
   [[135637824071393749,271275648142787502],
    [712098576374817182,1424197152749634385],
    [1288559328678240615,2577118657356481268],
    [1865020080981664048,3730040161963328151],
    [2441480833285087481,4882961666570175034]]
                                                  Type: List List Integer
</code></pre>
<p>In the other 'solutions' possible there was a bug because
it tried to save the infinite solutions in one List; now it is
imposed the limit of 80 solutions max</p>
</div>
<div id="pu2" class="pu"><ul>
<li>after Dennis' remarks, that made my previous idea upside-down, i had to change the code from its roots and it took me long term debugging, and cost me twice n° of bytes :'(.</li>
</ul>

<h2>Matlab (660)</h2>

<pre><code>a=input('');b=input('');c=input('');if((min(a*c,b*c)&gt;c*c)&amp;&amp;a*c&gt;0&amp;&amp;b*c&gt;0)||(a*c&lt;0&amp;&amp;b*c&lt;0),-1,return,end,g=abs(gcd(a,b));c=c/g;a=a/g;b=b/g;if(c~=floor(c)),-1,return,end,if(c/a==floor(c/a)&amp;&amp;c/a&gt;0),e=c/a-b;if(e&gt;0),e,a,return,else,c/a,0,return,end,end,if(c/b==floor(c/b)&amp;&amp;c/b&gt;0),e=c/b-a;if(e&gt;0),b,e,return,else,0,c/b,return,end,end,f=max(abs(a),abs(b));if f==abs(a),f=b;b=a;a=f;g=0.5;end,e=(c-b)/a;f=(c-2*b)/a;if(e&lt;0&amp;&amp;f&lt;e),-1,elseif(e&lt;0&amp;&amp;f&gt;e),for(i=abs(c*a):abs((c+1)*a)),e=(c-i*b);if(mod(e,a)==0)if(g==0.5),i,e/a;else,e/a,i,end,return,end,end,else for(i=1:abs(a)),e=(c-i*b);if(e/a&lt;0),-1,elseif(mod(e,a)==0),if(g==0.5),i,e/a,else,e/a,i,end,return,end,end,end,-1
</code></pre>

<blockquote>
  <ul>
  <li>Well , i know its not golfed, since that type of languages isnt adapted for code length reduction, but, i can ensure that time-complexity is at its best.</li>
  </ul>
</blockquote>

<h2>Explanation:</h2>

<ul>
<li><p>the code takes three invariants a,b,c as input, these last ones are subdued to couple of conditions before proceeding to calculate:</p>

<p>1- if (a+b>c) and (a,b,c>0) no solution!</p>

<p>2- if (a+b &lt; c) ,(a,b,c&lt;0) no solution!</p>

<p>3- if (a, b) have common opposite signs of c : no solution!</p>

<p>4- if GCD(a,b) dosnt divide c, then no solution again! , otherwise, divide all variants by GCD.</p></li>
<li><p>after this , we have to check another condition out, it should ease and shorteb the way to desired solution.</p>

<p>5- if c divide a or b , solution s= (x or y)=(c-[ax,yb])/[b,a]=C/[b,a]+[ax,yb]/[b,a]=S+[ax,yb]/[b,a] where S is natural so ax/b or by/a would have henceforth non-negative direct solutions which are respectively x=b or y=a . (notice that solutions can be just nil values in case previous arbitrary solutions are revealed negatives)</p></li>
<li><p>when the program reaches this stage, a narrower range of solutions for x=(c-yb)/a is swept instead, thanks to congruence, of sweeping larger ranges of numbers ,which is come accross repetitively by regular cycles. the largest search field is [x-a,x+a] where a is the divisor.</p></li>
</ul>

<h2><a href="http://rextester.com/NDXGP44424" rel="nofollow">TRY IT</a></h2>
</div>
<div id="pu3" class="pu"><h1>Pyth, 92 bytes</h1>

<pre><code>I!%vzhK%2u?sm,ed-hd*ed/F&lt;G2cG2@G1G+~Q,hQ_eQj9 2)J*L/vzhKtKeoSNm-VJ/RhK_*LdQsm+LdtM3/V*LhK_JQ
</code></pre>

<p>It's quite a monster. </p>

<p>Try it online: <a href="https://pyth.herokuapp.com/?code=I!%25vzhK%252u%3Fsm%2Ced-hd*ed%2FF%3CG2cG2%40G1G%2B~Q%2ChQ_eQj9+2)J*L%2FvzhKtKeoSNm-VJ%2FRhK_*LdQsm%2BLdtM3%2FV*LhK_JQ&amp;input=11%0A%5B2%2C+3%5D&amp;debug=0" rel="nofollow">Demonstration</a>. The input format is <code>c\n[a,b]</code> and the output format is <code>[x,y]</code>. </p>

<p>In the case that no integer solution exists, I'll print nothing, and in the case that no natural integer solution exists, I'll simply print a random integer solution. </p>

<h3>Explanation (Rough Overview)</h3>

<ol>
<li><p>At first I'll find an integer solution to the equation <code>ax + by = gcd(a,b)</code> by using the Extended Euclidean algorithm. </p></li>
<li><p>Then I'll modify the solution (my multiplying <code>a</code> and <code>b</code> with <code>c/gcd(a,b)</code>) to get an integer solution of <code>ax + by = c</code>. This works, if <code>c/gcd(a,b)</code> is an integer. Otherwise there doesn't exist a solution. </p></li>
<li><p>All the other integer solutions have the form <code>a(x+n*b/d) + b(y-n*a/d) = c</code>  with <code>d = gcd(a,b)</code> for integer <code>n</code>. Using the two inequalities <code>x+n*b/d &gt;= 0</code> and <code>y-n*a/d &gt;= 0</code> I can determine 6 possible values for <code>n</code>. I'll try all 6 of them and print the solution with the highest lowest coefficient. </p></li>
</ol>

<h3>Explanation (Detailed)</h3>

<p>The first step is to find an integer solution to the equation <code>ax' + by' = gcd(a,b)</code>. This can be done by using the extended Euclidean algorithm. You can get an idea on how it works at <a href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example" rel="nofollow">Wikipedia</a>. The only difference is, that instead of using 3 columns (<code>r_i s_i t_i</code>) I'll use 6 columns (<code>r_i-1 r_i s_i-1 s_i t_i-1 t_i</code>). This way I don't have to keep the last two rows in memory, only the last one. </p>

<pre><code>K%2u?sm,ed-hd*ed/F&lt;G2cG2@G1G+~Q,hQ_eQj9 2)   implicit: Q = [a,b] (from input)
                                     j9 2    convert 9 to base 2: [1,0,0,1]
                            + Q              add to Q =&gt; [a,b,1,0,0,1]
                                             this is the initial row
   u                                     )   start with G = ^ and update G repeatedly
                                             by the following expression, until
                                             the value of G doesn't change anymore
    ?                   @G1                    if G[1] != 0:
                     cG2                         split G into parts of 2
      m                                          map the parts d to:
       ,                                           the pair 
        ed                                           d[1]
          -hd*ed/F&lt;G2                                d[0]-d[1]*G[0]/G[1]
     s                                           unfold
                                               else:
                           G                     G (don't change it, stop criterion for u)
 %2                                          take every second element
                                             we get the list [gcd(a,b),x',y']
K                                            store this list in K
                             ~Q,hQ_eQ        afterwards change Q to [Q[0],-Q[1]] = [a,-b]
                                             This will be important for the other parts. 
</code></pre>

<p>Now I want to find a solution to <code>ax + by = c</code>. This is possible only, when <code>c mod gcd(a,b) == 0</code>. If this equation is satisfied, I simply multiplying <code>x',y'</code> with <code>c/gcd(a,b)</code>. </p>

<pre><code>I!%vzhK...J*L/vzhKtK   implicit: z = c in string format (from input)
  %vzhK                evaluated(z) mod K[0] (=gcd(a,b))
I!                     if not ^ than: 
             /vzhK        c/K[0]
           *L     tK      multipy ^ to each element in K[1:] (=[x',y'])
          J               and store the result in J, this is now [x,y]
</code></pre>

<p>We have an integer solution for <code>ax + by = c</code>. Notice, that <code>x</code>, <code>y</code> or both may be negative. So our goal is to transform these to non-negative. </p>

<p>The nice thing about Diophantine equations is, that we can describe all solution using only one initial solution. If <code>(x,y)</code> is a solution, that all other solutions are of the form <code>(x-n*b/gcd(a,b),y+n*a/gcd(a,b))</code> for <code>n</code> integer. </p>

<p>Therefore we want to find a <code>n</code>, where <code>x-n*b/gcd(a,b) &gt;= 0</code> and <code>y+n*a/gcd(a,b &gt;= 0</code>. After some transformation we end up with the two inequalities <code>n &gt;= -x*gcd(a,b)/b</code> and <code>n &gt;= y*gcd(a,b)/a</code>. Notice that the inequality symbol might look in the other direction due the division with a potential negative <code>a</code> or <code>b</code>. I don't care that much about it, I simply say that one number of <code>-x*gcd(a,b)/b - 1, -x*gcd(a,b)/b, -x*gcd(a,b)/b + 1</code> definitly satisfies inequality 1, and one number of <code>y*gcd(a,b)/a - 1, y*gcd(a,b)/a, y*gcd(a,b)/a + 1</code> satisfies inequality 2. It there is a <code>n</code>, that satisfies both inequalities, one of the 6 numbers also does. </p>

<p>Then I calculate the new solutions <code>(x-n*b/gcd(a,b),y+n*a/gcd(a,b))</code> for all 6 possible values of <code>n</code>. And I print the solution with the highest lowest value. </p>

<pre><code>eoSNm-VJ/RhK_*LdQsm+LdtM3/V*LhK_JQ
                               _J    reverse J =&gt; [y,x]
                           *LhK      multiply each value with K[0] =&gt; [y*gcd,x*gcd]
                         /V      Q   vectorized division =&gt; [y*gcd/a,-x*gcd/b]
                  m                  map each d of ^ to:
                      tM3              [-1,0,1]
                   +Ld                 add d to each ^
                 s                   unfold
                                     these are the possible values for n
    m                                map each d (actually n) of ^ to:
             *LdQ                      multiply d to Q =&gt; [a*n,-b*n]
            _                          reverse =&gt; [-b*n,a*n]
        /RhK                           divide by K[0] =&gt; [-b*n/gcd,a*n/gcd]
     -VJ                               vectorized subtraction with J
                                       =&gt; [x+b*n/gcd,y-a*n/gcd]
 oSN                                 order the solutions by their sorted order
e                                    print the last one
</code></pre>

<p>The sort by their sorted order thing works the following way. I'm using the example <code>2x + 3y = 11</code></p>

<p>I sort each of the 6 solutions (this are called keys), and sort the original solutions by their keys:</p>

<pre><code>solutions: [1, 3], [4, 1], [7, -1], [-5, 7], [-2, 5], [1, 3]
keys:      [1, 3], [1, 4], [-1, 7], [-5, 7], [-2, 5], [1, 3]
sort by key:
solutions: [-5, 7], [-2, 5], [7, -1], [1, 3], [1, 3], [4, 1]
keys:      [-5, 7], [-2, 5], [-1, 7], [1, 3], [1, 3], [1, 4]
</code></pre>

<p>This sorts a complete non-negative solution to the end (if there is any). </p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/51870/">51870</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




