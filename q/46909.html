<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::46909</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
  <!-- TXXX -->
<tr d-ix="0"><td>011</td><td>05AB1E</td><td>230808T151108Z</td><td><a href="https://codegolf.stackexchange.com/questions/46909/finding-prime-numbers-without-using-prime-characters/263885#263885">Kevin Cr</a></td></tr>
<tr d-ix="1"><td>131</td><td>JavaScript V8</td><td>230807T092743Z</td><td><a href="https://codegolf.stackexchange.com/questions/46909/finding-prime-numbers-without-using-prime-characters/263819#263819">l4m2</a></td></tr>
<tr d-ix="2"><td>183</td><td>Python 3.7+</td><td>230806T044931Z</td><td><a href="https://codegolf.stackexchange.com/questions/46909/finding-prime-numbers-without-using-prime-characters/263771#263771">incendia</a></td></tr>
<tr d-ix="3"><td>1695</td><td>Rust</td><td>220330T060636Z</td><td><a href="https://codegolf.stackexchange.com/questions/46909/finding-prime-numbers-without-using-prime-characters/245739#245739">Aiden4</a></td></tr>
<tr d-ix="4"><td>009</td><td>Jelly</td><td>210211T214330Z</td><td><a href="https://codegolf.stackexchange.com/questions/46909/finding-prime-numbers-without-using-prime-characters/218905#218905">caird co</a></td></tr>
<tr d-ix="5"><td>020</td><td>CJam</td><td>150220T171527Z</td><td><a href="https://codegolf.stackexchange.com/questions/46909/finding-prime-numbers-without-using-prime-characters/46914#46914">Runer112</a></td></tr>
<tr d-ix="6"><td>055</td><td>GNU APL</td><td>161017T152104Z</td><td><a href="https://codegolf.stackexchange.com/questions/46909/finding-prime-numbers-without-using-prime-characters/96535#96535">Adalynn</a></td></tr>
<tr d-ix="7"><td>nan</td><td>Rust</td><td>161104T112725Z</td><td><a href="https://codegolf.stackexchange.com/questions/46909/finding-prime-numbers-without-using-prime-characters/98561#98561">user6126</a></td></tr>
<tr d-ix="8"><td>474</td><td>Java.</td><td>150221T142109Z</td><td><a href="https://codegolf.stackexchange.com/questions/46909/finding-prime-numbers-without-using-prime-characters/46937#46937">TheNumbe</a></td></tr>
<tr d-ix="9"><td>090</td><td>Haskell</td><td>150221T011119Z</td><td><a href="https://codegolf.stackexchange.com/questions/46909/finding-prime-numbers-without-using-prime-characters/46926#46926">nimi</a></td></tr>
<tr d-ix="10"><td>227</td><td>Bash + coreutils</td><td>150220T230848Z</td><td><a href="https://codegolf.stackexchange.com/questions/46909/finding-prime-numbers-without-using-prime-characters/46922#46922">Digital </a></td></tr>
<tr d-ix="11"><td>074</td><td>Ruby</td><td>150220T172618Z</td><td><a href="https://codegolf.stackexchange.com/questions/46909/finding-prime-numbers-without-using-prime-characters/46915#46915">histocra</a></td></tr>
<tr d-ix="12"><td>030</td><td>CJam</td><td>150220T174738Z</td><td><a href="https://codegolf.stackexchange.com/questions/46909/finding-prime-numbers-without-using-prime-characters/46916#46916">Martin E</a></td></tr>
<tr d-ix="13"><td>012</td><td>Pyth</td><td>150220T170410Z</td><td><a href="https://codegolf.stackexchange.com/questions/46909/finding-prime-numbers-without-using-prime-characters/46912#46912">Maltysen</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 11 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>∞¦ʒDÑPQ}sôн
</code></pre>
<p>Input as integers.</p>
<p><a href="https://tio.run/##AR4A4f9vc2FiaWX//@KInsKmypJEw5FQUX1zw7TQvf//MTA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/a/0/1HHvEPLTk1yOTwxILC2@PCWC3v/Kx3a5q0UUJSfXpSYa6WgZG/LpeScn5KqW5CfmVdSrKCRmFepUFCUmZtabK8Jkj@0MvjoviNtxdku9koKj9omAYUKEMzDC3S4lIJSi0tzgHrT8osUog11DA1igRp1Qlz9DA/vgqv0O7ROL0znPwA" rel="nofollow noreferrer">verify it's valid, and some test cases</a>.</p>
<p>Or 14 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a> if we include string inputs, and comply to the other rules:</p>
<ul>
<li>Non-integer strings; leading whitespaces; or leading <code>+</code> are invalid</li>
<li>Leading <code>0</code> are valid</li>
</ul>

<pre><code>∞ʒDÑPQ}s0ì&gt;ôн¦
</code></pre>
<p><a href="https://tio.run/##ASIA3f9vc2FiaWX//@KInsqSRMORUFF9czDDrD7DtNC9wqb//ys3" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/a/0/1HHvFOTXA5PDAisLTY4vMbu8JYLew8t@690aJu3UkBRfnpRYq6VgpK9LZeSc35Kqm5BfmZeSbGCRmJepUJBUWZuarG9Jkj@0Mrgo/uOtBVnu9grKTxqmwQUKkAwDy/Q4VIKSi0uzQHqTcsvUog21DE0iAVq1Alx9TM8vAuu0u/QOr0wnVoupeCC1OTMxByF5MTi1GKQQqWknEQlJQVzJSVtIDYAYqCAOUhQs6zyUcMypcP7lZBNqjw8AWzWfwA" rel="nofollow noreferrer">verify it's valid, and some test cases</a>.</p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>∞        # Push an infinite positive list: [1,2,3,...]
 ¦       # Remove the leading 1: [2,3,4,...]
  ʒ      # Filter it by:
   D     #  Duplicate the current integer
    Ñ    #  Pop and push a list of its divisors
     P   #  Take the product of this list of divisors
      Q  #  Check if it's still the same as the duplicated integer
         #  (only if the divisors are {1,value}, the value will be a prime)
  }s     # After the filter: swap so the (implicit) input-integer is a the top
    ô    # Split the infinite list into parts of that size
     н   # Pop and leave just the first part
</code></pre>
<p><em>For the program with additional string input validation:</em></p>
<ul>
<li>The <code>0ì</code> will prepend a leading <code>&quot;0&quot;</code> to the input (to fix the test cases with leading <code>+</code>, which would otherwise be interpret as integers);</li>
<li>The <code>&gt;</code> will then increase the string-integer by 1 (implicitly converting it to an integer if it's valid first), because we haven't removed the leading <code>1</code> with <code>¦</code> yet;</li>
<li>The <code>¦</code> will then:
<ul>
<li>Remove the leading <code>1</code> from the list for valid inputs;</li>
<li>Or remove the <code>1</code> from itself, leaving an empty string for invalid inputs. Because the <code>s0ì&gt;ô</code> will have been no-ops, after which <code>н</code> will leave not the first part, but the first integer in the list, which is the <code>1</code>.</li>
</ul>
</li>
</ul>
<p><em>Minor notes:</em></p>
<ol>
<li>Uses <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">05AB1E encoding</a>, with <a href="https://tio.run/##yy9OTMpM/f//6L4jbXpHGv//BwA" rel="nofollow noreferrer">the following codepoint-integers</a>.</li>
<li><code>ôн</code> could have been <code>£</code>, but unfortunately <code>£</code> with code-point 163 is a prime.</li>
<li>Even if prime-builtins were allowed, <code>Å</code> in the builtin <code>Åp</code> with code-point 197 is a prime as well. Although <code>&lt;ÝØ</code> would in that case be a short valid alternative: <a href="https://tio.run/##yy9OTMpM/f/f5vDcwzP@/zcHAA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/a/03@bw3MMz/isd2uatFFCUn16UmGuloGRvy6XknJ@SqluQn5lXUqygkZhXqVBQlJmbWmyvCZI/tDL46L4jbcXZLvZKCo/aJgGFChDMwwt0uJSCUotLc4B60/KLFKINdQwNYoEadUJc/QwP74Kr9Du0Ti9M5z8A" rel="nofollow noreferrer">verify it's 'valid', and some test cases</a>. <code>&lt;Ý</code> pushes a list in the range <code>[0,input)</code>, whereas <code>Ø</code> converts each value in this list to their 0-based value'th prime.</li>
</ol>
</div>
<div id="pu1" class="pu"><h1><a href="https://v8.dev/" rel="nofollow noreferrer">JavaScript (V8)</a>, 131 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>[].fill.constructor`M${`for(N\x3D1\x3bM\x3bn-N||--M-print(n\x29\x29for(n\x3Di\x3DN-\x3D-1\x3bi--&gt;2\x3b\x29n\x2fi-~~[n\x2fi]||n--`}`
</code></pre>
<p><a href="https://tio.run/##VY5RT8IwFIXf/R2atczbAgLRLONFg@Fh44EnMxY2m5ZUa4vdXJY4@etzF554uF9Ocr6T3I@yKSvh9bGG5rFXMQmCkOzjJR/1Wc6UNoYJZ6va/4ja@SK5/S2U8yTdtQ8vkwHvCcJC2nUACRy9tjWxu3b6hIeqRVUjUkDCeaYBllMMqKGvNJxO2SXlXWcBir@iH/ExpawyWkiyuIcZjW7wHWckM@5AeHZHQz6P4ufX9Wb7VsrD59d3zplspSCKDvYqlk1phnw9XIVBgC2ZjGnU/wM" rel="nofollow noreferrer" title="JavaScript (V8) – Try It Online">Try it online!</a></p>
</div>
<div id="pu2" class="pu"><h1>Python 3.7+, 183 bytes</h1>
<pre class="lang-python prettyprint-override"><code>for E,E.__clªss_ᵍᵉtitᵉᵐ__ in[__builtins__.__loªdᵉr__,ᵉxᵉc],:E[f'd{101:c}f F(n\x29:\n p,f\x3d1,1\n whil{101:c} n&gt;0:p,f\x3d-~p,f*p*p\73n-\x3df{37:c}p&gt;0!\x3dprint(p\x29']
</code></pre>
<p><a href="https://tio.run/##LYxBCoMwEEWvkq5qJZakWUizcKeXMDJQJRiQGDSlFmn3XRR6DvdewJt4kjSCi5k////HmKetW82ck22HUpyeAcpmmfoe1vm7zh@rrN/r/ANASucAt7tqrNI9gEebdpkq33cA2MvgpywwT3N5rEZKKC9fEmWBFsPlyoVGBksxsIpi6s2jVs0OIZ0QvpfR2x@hCY2ImY62RI4s9pBJyGGzplPaBmb7eSxcFlBycn8" rel="noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
<p>Assumes an infinite upper bound, takes integer input via function argument, and prints the primes on separate lines.</p>
<p>Without substitutions for characters (except <code>\n</code>):</p>
<pre class="lang-python prettyprint-override"><code>for E,E.__class_getitem__ in[__builtins__.__loader__,exec],:E[f'def F(n):\n p,f=1,1\n while n&gt;0:p,f=-~p,f*p*p;n-=f%p&gt;0!=print(p)']
</code></pre>
<p>The string in the above code:</p>
<pre class="lang-python prettyprint-override"><code>def F(n):
 p,f=1,1
 while n&gt;0:p,f=-~p,f*p*p;n-=f%p&gt;0!=print(p)
</code></pre>
<p>Python 3.7 <a href="https://peps.python.org/pep-0560/" rel="noreferrer">added</a> the <code>__class_getitem__</code> magic method: if <code>A</code> is a class, then <code>A[x]</code> calls <code>A.__class_getitem__(x)</code>. Assigning <code>exec</code> to this attribute of a class allows us to call it without <code>)</code>. Unfortunately, we cannot create our own class without either using the <code>class</code> keyword (<code>a</code>) or calling the <code>type</code> function (<code>)</code>), so we must use a built-in class. The only one that allows the assignment to be made without error is <code>__builtins__.__loader__</code>.</p>
<p>Python <a href="https://docs.python.org/3/reference/lexical_analysis.html#identifiers" rel="noreferrer">normalizes</a> all identifiers to NFKC, and this allows us to spell <code>__class_getitem__</code>, <code>__loader__</code>, and  <code>exec</code> without using any of the letters <code>aegm</code>. The exact substitutions are U+00AA for <code>a</code>, U+1D49 for <code>e</code>, U+1D4D for <code>g</code>, and U+1D50 for <code>m</code>. We use a <code>for</code> loop to make assignments without using <code>=</code>, and these let us call <code>exec</code> via <code>E[f'...']</code> in the body.</p>
<p>Inside the string passed to <code>exec</code>, we use octal (<code>\73</code> instead of <code>;</code>), hex (<code>\x3d</code> instead of <code>=</code>), and decimal (<code>{37:c}</code> instead of <code>%</code>) escapes for banned characters. The code simply tests the primality of each positive integer using <a href="https://en.wikipedia.org/wiki/Wilson%27s_theorem" rel="noreferrer">Wilson's theorem</a>. A function was used instead of a lambda as the recursion limit causes the latter to stop working well below 10000.</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.rust-lang.org/" rel="nofollow noreferrer">Rust</a>, <strike>2720</strike> 1695 bytes</h1>

<pre class="lang-rust prettyprint-override"><code>|n|for i in 0..n{if i&lt;3&amp;&amp;i&gt;1||i&amp;1&gt;0&amp;&amp;0&lt;[0x2196820D864A4c32816D129A64B4cB6Eu128,0x4A2882D129861144A48961204A0434c9|1&lt;&lt;28,0x148A48844224064B0834992132424030|1&lt;&lt;80,0x64048928124108A00B40B4086c304204|1&lt;&lt;0|1&lt;&lt;84|1&lt;&lt;120,0xc02104c94112422180124496804c3098,0x220824B0826896810804490000982D32|1&lt;&lt;104,0x69009244304340069004264940A28948|1&lt;&lt;36,0x86122D22400c06012410DA408088210,0x14916022c044A0020110D301821B0484,0x4cA2100800422094092094D204A6400c|1&lt;&lt;84,0x34c108144309A24A48B081041018200|1&lt;&lt;28|1&lt;&lt;64,0x241140A2180032402084490880422402|1&lt;&lt;8|1&lt;&lt;20|1&lt;&lt;68,0x29260008360044120A41A00101840128|1&lt;&lt;72,0xc20c26484822006D10100480c0618283|1&lt;&lt;100,0x10c02402190024884420482024894810|1&lt;&lt;44|1&lt;&lt;7*8|1&lt;&lt;104,0x60901300264B0400802832cA01140868,0x430800112186430c32100100D0248082|1&lt;&lt;16,0x24880906002D20430092900c10480424,0x4000814196800880430082090932c040|1&lt;&lt;60,0x926094022080c3292048489608481048|1&lt;&lt;4*13,0xA04204901904004A0104422812000|1&lt;&lt;7*8,0x800084424002982c02c801348348924|1&lt;&lt;96,0x1864328244908A0004D0048442043698|1&lt;&lt;28|1&lt;&lt;112,0x861104309204A44028024001020A0090,0x4424990912486084c90804422c004208|1&lt;&lt;36,0x4040208804321A011000211403002400|1&lt;&lt;88,0xA2020c90116802186030014084c30906,0x8801904800841028224148929860004,0x120100100c061061020004A442681210,0x140128040A0c94186412422194032010|1&lt;&lt;7*8,0x4882402D20410490014000D040A40A29,0x822902002484490424080130100020c1|1&lt;&lt;76,0xA0cA0006112100104816814802486100|1&lt;&lt;20,0x2414480906810c044200B09104000240|1&lt;&lt;120,0x84420004802c10c860A00A011242092|1&lt;&lt;16|1&lt;&lt;112,0x12824414814804820022130406980032,0x2c00D86424812004D028804340101824,0x180110c04120cA41020000A241081209,0x48044320240A08320941220A41804A4,0x820104128864008A6086400c001800|1&lt;&lt;96][i&gt;&gt;8]&amp;1&lt;&lt;{[i&amp;{1&lt;&lt;8}-1][0]&gt;&gt;1}{print!{&quot;{}
&quot;,i}}}
</code></pre>
<p><a href="https://tio.run/##TVTbahtBDH33V2zzYJKQBkkjJprWNaxxv8L4ISwxLLRuyQVCbX@7e442xQ1mY89qRuemeX57eT3v9t3Px3F/fXOY/Xh67XZfdvvrt5fxz9NN9607H/fH3a/nbuzGfSf39/vDuOvGRZnPx6Uej@NclzKfy2Ij76athsk6qvc@FAuta7XWV1/5sKrf39TiTt69twjjm6iqjtpoVU28Fy8@tKMuFlmoHngX7mYuOESieGumxRwLRVgYgsLqgjPQz1wlepGV8xN1KOI4mIVTdX5FL8IQU0E7V2wz0xD8dzDAYpFGAGYSxr5WATFwtqBC8NdAoFgeJk4EWG3YXkhBhD/dqjcXkG0erCwVhaBstiYhGaRKIl73wCrQRCVZN61iNqAXqJgoKoooXq9Ak9186FGLPWhigiaNzzUlrDx4oopCyAnQSlytNyoNMkCsPE5kUprPympgUQKGFAKN0TpIN0LSgaSb1ZY7a0rUrEKPKHi6Q9neFajZwMEuyx@MmE0GKBIegCwIBmpAhyoAS5RJyxQAa2ynENEm/1Fo/A4lNXt7GvlwG/9ZIE20YAuT4lQHp9rQC0lFgoUMoAa/FREtgogqocqaZ8PlPKymEiDd4I8YVS00F2ggplOM9ICs1Rl5SYlQBJBNWqF1k0JJBwLBImaJHRvJMPEQl1YkA7/VgtI@0woajQTgPt5DeuRaJrNAmBlia@cMCGYI3WxAeItjPDAFqUwji2RpYWkiTBFfU/LUs9QWF/shCRVE0pgU5siBOGgDMMBUCJAzg6YNFBHbIIGh5UgwrIR@iTkGkvGhLKa0AN2NRtAgn8jEx4ghGKCs0JG@sIKG5RBKjkykIJQZwQUf5JREcX2QU0osk5EMEz/Uixwwt/pvqphGoOqFIw9lpqmHM4W7L@rCeqaPvivNIBpGBFs5HC1BN7Ywz/mgEdRfkiRCkmdljGSg7JWJIz4YDkBOXXEPfMyfTJPnnokLpp8OyQoyMwbU63JrpXs5OIY0DpAAHSgw2MC5KcEXSzXtR0t25RAhh0CK67TlkLM3vOOVDUzMGTJi6ZvnEGfWeTcmLiUjn/SFFrxtsdRSNaAuHFKgwdwh8rjoeBsEnSByyozFCN5R0SM/eVlBmJikaHW7GZfL2M7x47AZ5wem5PRZtxvZLpd6Ovx@Hvevnw5Xh9Ps6m48nU7nr7PdNXWXm9np/Bc" rel="nofollow noreferrer" title="Rust – Try It Online">Try it online!</a></p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=d00e709d3560207c376d52d5bce8648f" rel="nofollow noreferrer">Lookup table generator</a></p>
<p>Yikes, I'm fairly confident rust doesn't even count as primitive recursive with the restrictions, because mutability and function calls are disallowed, meaning there is no way to maintain state across loop iterations. Works up to 10111.</p>
<p>My strategy was to form a lookup table by packing the primality of every odd number into array of 128 bit integers, and then just using a good old fashioned mask and shift to recover the value. The <code>5</code>s in the hexadecimal representation are dealt with by removing the 1 bit and orring it in at runtime. To deal with operator precedence issues, I abused the fact that blocks are also expressions, so I can use curly braces instead of parentheses.</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 9 bytes</h1>
<pre><code>2ḍƇ`L&lt;3Ʋ#
</code></pre>
<p><a href="https://tio.run/##y0rNyan8/9/o4Y7eY@0JPjbGxzYp////3xwA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p>The character codes are <code>[50, 7693, 391, 96, 76, 60, 51, 434, 35]</code></p>
<h2>How it works</h2>
<pre><code>2ḍƇ`L&lt;3Ʋ# - Main link. Takes N on the left
       Ʋ  - Define a monad f(k):
  Ƈ       -   Filter the range [1, 2, ..., k] on the following:
 ḍ `      -     Divides k cleanly?
    L     -   Length
     &lt;3   -   Less than 3?
2       # - Count up k = 2, 3, 4, ... until n integers return true. 
            Return those integers
</code></pre>
</div>
<div id="pu5" class="pu"><h1>CJam, <s>19</s> <s>18</s> <s>30</s> <s>34</s> <s>33</s> <s>19</s> <s>17</s> <s>21</s> 20 bytes</h1>

<p><a href="http://cjam.aditsu.net/#code=5%7B_3%5C%23%2C2%3E__ff*%3A~-%3CN*%7D~" rel="nofollow noreferrer">Try it online.</a></p>

<pre><code>{_3\#,2&gt;__ff*:~-&lt;N*}
</code></pre>

<p>This is probably one of the most horribly inefficient algorithms I've ever implemented. But I did it for the size!</p>

<p>My answer consists of a code block, which acts like an anonymous function in CJam. Run it with an integer immediately preceding it on the stack, and the resulting list is dumped onto the stack. I treat the upper bound on the input as infinite so I don't have to check that bound.</p>

<p>My algorithm starts by raising 3 to the <code>input</code>th power, which is guaranteed to give a number larger than the <code>input</code>-th prime if the input is valid. Then a list of the integers from 2 to this number minus one is generated, which is a large enough swath to contain all the prime numbers we want. To get rid of the composite numbers... <em>sigh</em>... we create a list of every pairwise product, which should generate all composite numbers from 4 to some stupidly large value, large enough for our purposes. Then it's just a matter of removing every element from the original list that is in this composite list, trimming it down to the first <code>input</code> elements, and joining the elements with the newline character.</p>

<p>The algorithm <em>should</em> work for any input. However, whether or not the interpreter/computer has enough memory or time is a whole other question, because the time and space requirements are exponential with respect to the input. So if the input is larger than about 5 for the online interpreter or about 8 for the offline one, then the answer to that question is probably no.</p>
</div>
<div id="pu6" class="pu"><h2>GNU APL, <s>75 68 67 65 59 56</s> 55 characters</h2>
<p><code>⎕IO</code> must be <code>1</code>.</p>
<pre><code>∇z←p n
z←2,j←3
j←j--2
→2×⍳∨⌿1&gt;z|j
z←z,j
→2×⍳n&gt;⍴z
z←n↑z∇
</code></pre>
<p>I came back on this months later realizing that I had an extra space!</p>
</div>
<div id="pu7" class="pu"><h1>Rust, 64897 bytes</h1>



<pre class="lang-rs prettyprint-override"><code>|n|println!{"{:?}",&amp;[2,3,6-1,7,11,13,17,19,23,29,31,37,41,43,47,60-7,0x3b,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,0x97,0x9d,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,0xfb,0x101 ...}
</code></pre>

<p>(code snipped due to character limit, <a href="https://gist.github.com/vintermann/863374c3114b4e421336a2b4ae06e9ec" rel="nofollow noreferrer">full solution here</a>)</p>

<p>The following rust features become unavailable due to the prime restriction:</p>

<ul>
<li>function calls, as they require ')'</li>
<li>regular bindings, since they require let (e)</li>
<li>macro definitions, they require macro-rules! (a,e,m)</li>
<li>match statements, they require match (a,m) and => (=)</li>
<li>mutability, since it's always introduced with the mut keyword (m).</li>
<li>return (e), break (a,e), continue (e)</li>
<li>else (e)</li>
</ul>

<p>What you can technically use:</p>

<ul>
<li>if. But without else, they're useless in expression contexts, so only good for side effects.</li>
<li>macros. Standard macros like print! are usually followed by (), but it's actually legal to use {} or [] instead. Without this, the task would be impossible.</li>
<li>closures, in the most narrow sense. You can't call them (requires ()) or bind them(requires let), but you can define a single non-recursive one. Without this, the task would obviously become impossible.</li>
<li>structs.</li>
<li>for loops. These are promising, since they actually allow variable binding, and they take an iterator, which can still be defined with the range syntax. The iterator can even be an expression.</li>
<li>Builtin operators, except +, % and /. The short-circuiting logical operators seem promising.</li>
</ul>

<p>I simply couldn't make anything Turing-complete with these tools. I'm sorry. All that was left was to include the full first 10000 primes, cleaned of 5's. At least you can slice it and have a valid solution, in the most narrow sense possible.</p>

<p>I very much would like experts on Turing tarpit diving (or on Rust!) to tell me if I could have done anything better!</p>
</div>
<div id="pu8" class="pu"><h1>Java. 474 bytes</h1>

<pre class="lang-java prettyprint-override"><code>i\u006dport j\u0061v\u0061.util.*\u003bvoid b(int b\u0029{Lon\u0067 c\u003d2L,d,f[]\u003d{}\u003bfor(f\u003dArr\u0061ys.copy\u004ff(f,b\u0029,Arr\u0061ys.fill(f,0L\u0029\u003bb--&gt;0\u003b\u0029for(d\u003d0L\u003bf[b]&lt;1\u003bf[b]\u003dd&lt;1?c:f[b],d\u003d0L,c\u002b\u002b\u0029for(lon\u0067 h:f\u0029d\u003dh&gt;0&amp;&amp;c\u002fh*h\u003d\u003dc?1:d\u003bj\u0061v\u0061x.x\u006dl.bind.JAXB.un\u006d\u0061rsh\u0061l(&quot;&quot;\u002bArr\u0061ys.\u0061sList(f\u0029,Lon\u0067.cl\u0061ss\u0029\u003b}
</code></pre>
<p>Takes input via function argument, outputs via thrown exception.</p>
<p>Indented:</p>
<pre class="lang-java prettyprint-override"><code>i\u006dport j\u0061v\u0061.util.*\u003b
void b(int b\u0029{
    Lon\u0067 c\u003d2L,d,f[]\u003d{}\u003b
    for(f\u003dArr\u0061ys.copy\u004ff(f,b\u0029,Arr\u0061ys.fill(f,0L\u0029\u003bb--&gt;0\u003b\u0029
        for(d\u003d0L\u003bf[b]&lt;1\u003bf[b]\u003dd&lt;1?c:f[b],d\u003d0L,c\u002b\u002b\u0029
            for(lon\u0067 h:f\u0029
                d\u003dh&gt;0&amp;&amp;c\u002fh*h\u003d\u003dc?1:d\u003b
    j\u0061v\u0061x.x\u006dl.bind.JAXB.un\u006d\u0061rsh\u0061l(&quot;&quot;\u002bArr\u0061ys.\u0061sList(f\u0029,Lon\u0067.cl\u0061ss\u0029\u003b
}
</code></pre>
<p>Escaped characters removed:</p>
<pre class="lang-java prettyprint-override"><code>import java.util.*;
void b(int b){
    Long c=2L,d,f[]={};
    for(f=Arrays.copyOf(f,b),Arrays.fill(f,0L);b--&gt;0;)
        for(d=0L;f[b]&lt;1;f[b]=d&lt;1?c:0,d=0L,c++)
            for(long h:f)
                d=h&gt;0&amp;&amp;c/h*h==c?1:d;
    javax.xml.bind.JAXB.unmarshal(&quot;&quot;+Arrays.asList(f),Long.class);
}
</code></pre>
<p>Explanation:</p>
<pre class="lang-java prettyprint-override"><code>Long c,d,f[]={};                                                //Initialize variables.

for(f=java.util.Arrays.copyOf(f,b),Arrays.fill(f,0L);b--&gt;0;)
    f=java.util.Arrays.copyOf(f,b),Arrays.fill(f,0L)            //Initialize f to an array of 0's.
                                                     b--&gt;0      //Iterate over the first b primes.

for(d=0L;f[b]&lt;1;f[b]=d&lt;1?c:0,d=0L,c++)
    d=0L                        d=0L                            //Initialize d to 0.
         f[b]&lt;1                      c++                        //Increment c while the b'th prime is 0.
                f[b]=d&lt;1?c:0                                    //If d = 0, the b'th prime = c, else continue.

for(long h:f)                                                   //Iterate over all found primes.

d=h&gt;0&amp;&amp;c/h*h==c?1:d;
  h&gt;0                                                           //Ignore non-found primes.
       c/h*h==c                                                 //Equivalent to c%h==0
               ?1:d                                             //If h is prime and c is divisible by h, d = 1. Otherwise d stays unchanged.

javax.xml.bind.JAXB.unmarshal(&quot;&quot;+Arrays.asList(f),Long.class)   //Print solution to stderr
javax.xml.bind.JAXB.unmarshal(                   ,Long.class)   //Prints what's contained to stderr.
                                 Arrays.asList(f)               //Convert f to list.
                              &quot;&quot;+                               //Convert to string.
</code></pre>
<p>My original solution used a <code>return</code> statement. After asking <a href="https://stackoverflow.com/q/28635275/4230423">this question</a> on StackOverflow, <a href="https://stackoverflow.com/users/1707091/rgettman">regettman</a> was kind enough to provide a way to output/return without using prime letters.</p>
<p>As usual, suggestions are welcome :)</p>
</div>
<div id="pu9" class="pu"><h1>Haskell, 90 bytes</h1>

<pre><code>\n-&gt;[fst c|c&lt;-zip[p|p&lt;-[2..],not$or[b&gt;p-1&amp;&amp;b-1&lt;p|b&lt;-[u*v|u&lt;-[2..p-1],v&lt;-[2..p-1]]]][1..n]]
</code></pre>

<p>This is an anonymous function which takes an integer <code>n</code> as input.</p>

<p>How it works: <code>[p|p&lt;-[2..],not$or[b&gt;p-1&amp;&amp;b-1&lt;p|b&lt;-[u*v|u&lt;-[2..p-1],v&lt;-[2..p-1]]]]</code> (first example of prime number one-liners at the <a href="https://wiki.haskell.org/Prime_numbers_miscellaneous#One-liners" rel="nofollow">Haskell wiki</a> but with the <code>elem</code> function replaced) creates an infinite list of primes. <code>zip</code> it with the numbers from <code>1</code>to <code>n</code> to make a list of <code>(prime, seq. number)</code> pairs. Remove seq. number, again. Result is a list of primes of length <code>n</code>.    </p>
</div>
<div id="pu10" class="pu"><h1>Bash + coreutils, 227 bytes</h1>
<pre><code>printf -vb br`dc&lt;&lt;&lt;Di14B8209P`
printf -vc -- $[$1-0]
[ &quot;${1#$c}&quot; -o $c -lt 1 ]||{
for i in {2..104729}
{
for f in `jot $[i-1] $[i-1] 1`
{
[ 0 -lt `dc&lt;&lt;&lt;&quot;$i $f~p&quot;` ]||$b
}
[ $f -lt 2 ]&amp;&amp;printf $i\ &amp;&amp;: $[c--]
[ $c -lt 1 ]&amp;&amp;$b
}
}
</code></pre>
<p>This was quite tricky.  Some things I ran into:</p>
<ul>
<li>Most loops (<code>while</code> and <code>until</code>) are unusable because they most close with <code>done</code> which is a shell keyword and cannot be the result of a variable expansion (unless <code>eval</code> is used, but that is out too).  The only usable loop is <code>for</code>/<code>in</code> which allows <code>{</code>/<code>}</code> instead of <code>do</code>/<code>done</code>.  <code>for (( ; ; ))</code> is also not usable.</li>
<li><code>=</code> is out, so we need another way to assign variables.  <code>printf -v</code> is good for this.</li>
<li>We know that p(10000) is 104729 so for the outer loop for potential primes we can simply loop from 2 to 104729 and break once we have enough primes</li>
<li><code>jot</code> generates the list of potential factors in the inner loop.  If a potential factor divides a potential prime, then it is not prime and we break out early</li>
<li>Fortunately <code>break</code> is a shell builtin and not a keyword, so may be generated as a result of an expansion.  <code>dc</code> converts a base 13 number to the bytestream <code>eak</code>.</li>
<li>To check if a potential factor divides a potential prime, we cannot use the usual <code>/</code> or <code>%</code> shell arithmetic operators.  So this is outsourced to <code>dc</code>s <code>~</code> operator, which pushes quotient and remainder to the stack.</li>
<li><code>-lt</code> - less-than - is the only usable shell comparison operator.</li>
<li><code>echo</code> is no use for output.  <code>printf</code> works though as long as we avoid <code>%</code></li>
</ul>
<p>Getting the input validation right is a bit of a pain.  This returns nothing in the case of invalid input.</p>
<h3>Output:</h3>
<pre><code>$ ./primenoprime.sh 10
2 3 5 7 11 13 17 19 23 29 $ 
</code></pre>
</div>
<div id="pu11" class="pu"><h1>Ruby, 74</h1>

<pre><code>-&gt;n,*o{o&lt;&lt;[2..n*n][0].find{|x|!o.find{|y|1.&gt;x.^y.*x.div y}}until o[n-1]
o}
</code></pre>

<p>Explanation:</p>

<p><code>*o</code> initializes an empty output array. until it has <code>n</code> items, we find the smallest number >=2  that doesn't divide any item currently in <code>o</code>, then add it to <code>o</code>. To test for division, yikes. All the good operators are disallowed, and I can't even use <code>divmod</code>. Best I could see was to use <code>x.div y</code>, which takes x divided by y and rounds down, then multiply that by y again. If it equals x, there was no rounding, so y divides x. <code>1.&gt;x.^</code> is an equality test, checking whether the result of xor is 0. The <code>.</code> before every operator is because you can't mix <code>.</code>-free operator calls and parenthesis-free method calls.</p>

<p>Edit: The range-checking specifications were added after I posted this, I think. To comply requires 79 characters:</p>

<pre><code>-&gt;n,*o{o&lt;&lt;[*2..-~n*n].find{|x|!o.find{|y|1.&gt;x.^y.*x.div y}}until o[n-1]||n&lt;1
o}
</code></pre>
</div>
<div id="pu12" class="pu"><h1>CJam, <s>38</s> <s>37</s> 30 bytes</h1>

<pre><code>{_~2#,2&gt;\{(\{1$37c~},\p}*'&lt;(~}
</code></pre>

<p><a href="http://cjam.aditsu.net/#code=10%0A%7B_~2%23%2C2%3E%5C%7B(%5C%7B1%2437c~%7D%2C%5Cp%7D*&#39;%3C(~%7D%0A~" rel="nofollow">Try it here</a></p>

<p>I think this should comply with all the rules and works for any non-negative <em>N</em> (i.e. <em>T</em> is infinite). It's horribly inefficient though, so don't try it for large numbers.</p>

<p>This is a block - the closest thing to an (unnamed) function - which expects an integer on the stack, prints all the prime numbers and leaves the stack without its input. For all invalid inputs it will either throw an error or print nothing.</p>

<p>Most of the code is input validation, followed by the sieve of Eratosthenes. I only needed to work around the input restriction in 3 places:</p>

<ul>
<li><code>)</code> is increment in CJam. I needed that once, but could replace it with <code>~</code> (bitwise complement) because I was squaring the numbers afterwards anyway.</li>
<li><code>%</code> is modulo. I'm using <code>37c~</code> instead, which first creates the character <code>%</code> and then eval's that. This makes the code a lot slower.</li>
<li><code>;</code> pops and discards an element from the stack. I need to do this at the end. Instead I'm using <code>'&lt;(~</code> which pushes the character <code>&lt;</code>, decrements it and eval's that.</li>
</ul>
</div>
<div id="pu13" class="pu"><h1><a href="http://pyth.herokuapp.com" rel="nofollow noreferrer">Pyth</a> - 12 bytes</h1>
<p>Uses pyth's prime factorization function to see if # is prime. Uses <code>!tPT</code> trick suggested to me at my answer for primes under million problem.</p>
<pre><code>&lt;f!tPTr2^T6Q
</code></pre>
<p>Since the filter only works for primes under n and not first n, I just looked up the inverse of pi(x) for 10,000 and got 104,000 so I use primes under 10⁶ and get first n. This doesn't actually run, so you should test by replacing <code>^T6</code> with <code>^T3</code> and restrict n to under 1000. Input from stdin and output to stdout.</p>
<pre><code>&lt;          Q     Slice first n
f     r2^T6      filter on range 2-&gt;10⁶
 !               Logical not (gives true if tail is empty)
  t              Tail (all but first, so gives empty if prime fact is len 1)
   PT            Prime factorization of filter var (len 1 if num is prime)
</code></pre>
</div>
<!-- TYYY -->

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/46909/">46909</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




