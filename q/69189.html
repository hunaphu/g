<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::69189</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td>Rust</td><td>250507T124323Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/279569#279569">Deadbeef</a></td></tr>
<tr d-ix="1"><td>004</td><td>BrainChild</td><td>250331T044939Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/279001#279001">ATaco</a></td></tr>
<tr d-ix="2"><td>299</td><td>yacc GNU Bison</td><td>250330T175422Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/278992#278992">ais523</a></td></tr>
<tr d-ix="3"><td>007</td><td>Swift for wasm</td><td>230303T202655Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/258760#258760">Bbrk24</a></td></tr>
<tr d-ix="4"><td>042</td><td>Rust</td><td>230302T134656Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/258687#258687">JSorngar</a></td></tr>
<tr d-ix="5"><td>054</td><td>C</td><td>211124T064713Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/237617#237617">Random H</a></td></tr>
<tr d-ix="6"><td>nan</td><td>Myxal 0.7.1</td><td>220528T214331Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/247957#247957">Seggan</a></td></tr>
<tr d-ix="7"><td>022</td><td>Julia</td><td>211124T165443Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/237624#237624">MarcMush</a></td></tr>
<tr d-ix="8"><td>nan</td><td></td><td>211124T154012Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/237620#237620">Tynuk</a></td></tr>
<tr d-ix="9"><td>nan</td><td></td><td>210216T224443Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/219197#219197">mystery</a></td></tr>
<tr d-ix="10"><td>nan</td><td>Boo</td><td>171024T161439Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/146234#146234">user7520</a></td></tr>
<tr d-ix="11"><td>nan</td><td>C</td><td>170225T113929Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/111257#111257">H2CO3</a></td></tr>
<tr d-ix="12"><td>367</td><td>C</td><td>160121T034127Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/69811#69811">Zakipu</a></td></tr>
<tr d-ix="13"><td>nan</td><td>C</td><td>160112T001600Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/69193#69193">Digital </a></td></tr>
<tr d-ix="14"><td>nan</td><td>Scala  70 byte source</td><td>160117T013505Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/69555#69555">Rex Kerr</a></td></tr>
<tr d-ix="15"><td>nan</td><td>Java</td><td>160113T222102Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/69376#69376">Sleafar</a></td></tr>
<tr d-ix="16"><td>028</td><td>C#</td><td>160112T013934Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/69200#69200">Vladimir</a></td></tr>
<tr d-ix="17"><td>nan</td><td>Python 3</td><td>160114T085859Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/69415#69415">Aleksi T</a></td></tr>
<tr d-ix="18"><td>nan</td><td></td><td>160112T202722Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/69279#69279">Joshua</a></td></tr>
<tr d-ix="19"><td>005</td><td>Plain old C preprocessor 214 bytes input</td><td>160114T075229Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/69413#69413">Thomas P</a></td></tr>
<tr d-ix="20"><td>nan</td><td>C++</td><td>160112T175016Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/69265#69265">Toby Spe</a></td></tr>
<tr d-ix="21"><td>320</td><td>ASM</td><td>160112T014044Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/69201#69201">viraptor</a></td></tr>
<tr d-ix="22"><td>236</td><td>Boo</td><td>160112T163438Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/69259#69259">Mason Wh</a></td></tr>
<tr d-ix="23"><td>090</td><td>Kotlin</td><td>160112T183057Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/69270#69270">TheNumbe</a></td></tr>
<tr d-ix="24"><td>214</td><td>C++</td><td>160112T182600Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/69269#69269">Ben Voig</a></td></tr>
<tr d-ix="25"><td>nan</td><td></td><td>160112T165048Z</td><td><a href="https://codegolf.stackexchange.com/questions/69189/build-a-compiler-bomb/69262#69262">Warbo</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Rust, 29+16=45 bytes, 10,125,006,610 bytes (9.43 GiB) executable</h1>
<pre class="lang-rust prettyprint-override"><code>static A:&amp;[u8]=&amp;[0;9e9 as _];
</code></pre>
<p>Compile command:</p>
<pre><code>rustc --crate-type lib test.rs
</code></pre>
<p>Anything above (<code>1e10</code>) would generate the following error:</p>
<pre><code>error: failed to build archive at `libtest.rlib`: Archive member test.test.d32f52fcc5ed38cf-cgu.0.rcgu.o is too big

error: aborting due to 1 previous error; 1 warning emitted
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/tehflamintaco/brainlift" rel="nofollow noreferrer">BrainChild</a>, 4 Gibibytes</h1>
<pre><code>reserve 0x3ffffecb;
</code></pre>
<p><a href="https://tehflamintaco.github.io/brainlift/v1.0.1/?code=eF6rVspNzMzTS0pWslIqSi1OLSpLVTCoMAADNzdrBX194zQgSE1OUqoFADUlDXE%3D" rel="nofollow noreferrer">Try It Online!</a> (Number dialed down for demonstration purposes)</p>
<p>Reserves exactly enough memory to completely fill the 4GB Program Memory that Brainchild offers.</p>
<p>Similarly, the following can be used to unroll to arbitrarily large compiled binaries</p>
<pre><code>macro ('R' (number) (expression)) {if (const $1) {$2; R ($1-1) $2}}
R 0x000000FF int j;
</code></pre>
<p><a href="https://tehflamintaco.github.io/brainlift/v1.0.1/?code=eF4dx7EKgCAURuFX%2BRGh61CkY%2B09gHNLiYFB19CCIHz3pDOd7xXHErhbnRjquRRBjW1AfB%2BrTwrknzP5nENkpfCGDeQi5wtSV0ozwoKkbqukKWVmi%2F7p%2F6YJgS%2FsoygfO6sdmg%3D%3D" rel="nofollow noreferrer">Try it Online!</a></p>
</div>
<div id="pu2" class="pu"><h1>yacc (GNU Bison), 299 bytes</h1>
<pre class="lang-none prettyprint-override"><code>%%
P:a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x
a:S a|N b
b:S b|N c
c:S c|N d
d:S d|N e
e:S e|N f
f:S f|N g
g:S g|N h
h:S h|N i
i:S i|N j
j:S j|N k
k:S k|N l
l:S l|N m
m:S m|N n
n:S n|N o
o:S o|N p
p:S p|N q
q:S q|N r
r:S r|N s
s:S s|N t
t:S t|N u
u:S u|N v
v:S v|N w
w:S w|N x
x:N a|S:'0'N:'1'
</code></pre>
<p><a href="https://tio.run/##Tc5LCoMwGEXh@V1FJuJI205D6RKk4Ary0kRjhEaEwr93e4edfXAmx5oar8uZQz3VzYfzVg@finqpo//CprqXP3XdGT417QW5qi6zHMb27rqaBm9txIoTL0EmmSVKkkVWybJJgdGjMjIoC0tZysFRjvLwlKcCAhWoCRM1UTNmaqYiIhWphEQlasFCLdSKlVqpjExlasNGbVRB0QMPRt3e20G3j/YH" rel="nofollow noreferrer">Try a shorter version online!</a></p>
<p>I haven't managed to run the full version of this compile on my computer because I don't have enough RAM (and the compile would be expected to take hours), but the output size grows exponentially, and going as far as <code>x</code> is definitely enough (going as far as <code>w</code> would be close to the 4GiB target but I don't think it quite reaches it).</p>
<p>I mentioned GNU Bison in the title because it's the yacc implementation I used for testing, but the same program (maybe with a couple more lines) is likely to cause an exponential blowup on other yacc implementations too, as  long as they are able to create the program without running past hardcoded limits on the size of the output or something that correlates to that. (It would be possible for a yacc implementation to optimise in a way that prevents an exponential blowup on this sort of input, but don't expect any such yacc implementations to do that in practice.)</p>
<p>Output sizes for smaller versions of this program, with fewer lines, using GNU Bison 3.8.2:</p>
<pre><code>a-n 5167494
a-o 11058187
a-p 23580540
a-q 50106053
a-r 106010181
</code></pre>
<h2>Explanation</h2>
<p>Yacc is a language for describing parsers; you give it a description of the grammar of a language, and <code>yacc</code> generates a parser for it. Yacc's semantics require the input to be parsed left to right.</p>
<p>The grammar in this program can be summarised as &quot;parse a string of <code>0</code>s and <code>1</code>s, such that for each suffix of the input that starts with <code>0</code>, the number of <code>1</code>s in that suffix is not divisible by 24&quot;. However, because yacc parses from left to right, a bit of subtlety is needed to express the situation that the validity of a <code>0</code> depends on the elements to its right (rather than its left).</p>
<p>The basic trick is: if the number of <code>1</code>s in the input modulo 24 were known in advance, it would be possible to determine whether or not a <code>0</code> is valid by counting the <code>1</code>s to the left of the <code>0</code>, rather than counting the <code>1</code>s to the right. As such, the grammar is defined by (effectively) creating 24 threads, one for each possible <code>1</code>-count-modulo-24, and having each of those threads check the input to see if it would be valid assuming that the thread's assumption about the total <code>1</code> count is correct. At the end of the input, the total number of <code>1</code>s is known, so we can just ask the thread that started with a correct assumption whether the input is correct or not.</p>
<p>Why does this lead to an exponential blowup? Almost all yacc implementations compile a program using a virtual machine that works using a stack together with a finite-state machine (known as a &quot;push-down automaton&quot;) – typically the virtual machine is interpreted, although at least one implementation instead compiles it (using the processor's call stack as the stack of the virtual machine). However, for this particular program, the stack is entirely useless, so the grammar has to be parsed entirely using the finite state machine. It's certainly possible to do that! You just need 2<sup>24</sup> states, because each combination of &quot;this thread thinks the input could be valid given its starting assumption&quot; and &quot;that thread thinks the input must be invalid given its starting assumption&quot; needs to be assigned to a state (finite-state machines don't have variables, or indeed anywhere to store data other than their instruction pointer).</p>
<p>This grammar is within the set of grammars that yacc implementations have to be able to handle (according to the specification), so if they target the usual virtual machine (and most don't have any other back-ends), there will necessarily be an exponential blowup during the compilation process – the program is valid but the virtual machine can't represent it without using exponentially many states.</p>
<p>The program itself is fairly self-explanatory: the first line starting <code>P</code> creates the threads, and then everything else is just a state machine (e.g. the <code>d</code> line says &quot;In state <code>d</code>, either read an <code>S</code> and remain in state <code>d</code>, or read an <code>N</code> and go to state <code>e</code>.&quot;) The only subtlety is that in order to golf off a couple of bytes per line, instead of using the <code>'0'</code> and <code>'1'</code> characters directly, I defined them as <code>S</code> and <code>N</code> respectively (those definitions, <code>S:'0'N:'1'</code>, are at the end of the program, and don't require whitespace before or between them). The definition of <code>x</code> is <code>x:N a|</code> and reads as &quot;In state <code>x</code>, either read an <code>N</code> and go to state <code>a</code>, or accept the input if at end of input&quot; – if the acceptance condition in state <code>x</code> is not met, then the input will be rejected.</p>
</div>
<div id="pu3" class="pu"><h1>Swift for wasm, 7 byte source, 6326162 byte (6.3MB) wasm file</h1>
<p>Not winning, but I'm adding this answer for its sheer absurdity:</p>
<pre class="lang-swift prettyprint-override"><code>print()
</code></pre>
<p>The Swift compiler does almost no dead code stripping (at least when compiling for wasm), so you get the entire standard library. The arguments to the print statement, any loops or recursion I added, etc barely seemed to matter. However, removing the print statement entirely shrunk the code size by a noticeable amount.</p>
<p>For reference, I used the wasm file generated by <a href="https://swiftwasm.org/" rel="noreferrer">https://swiftwasm.org/</a>, which seems to be using Swift 5.6 at the time of writing.</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://www.rust-lang.org" rel="nofollow noreferrer">Rust</a>, 42 bytes, 1.31 GB executable</h1>
<pre class="lang-rust prettyprint-override"><code>fn main(){print!(&quot;{:?}&quot;,[0u8;9999999999])}
</code></pre>
<p>Does not require any specific compilation flags, you can just compile with <code>rustc cbomb.rs</code>.<br />
Arrays of the format <code>[x; s]</code> where <code>x</code> is <code>Copy</code> and <code>s</code> has type <code>usize</code> and both have a value known at compile time are constructed during compilation and embedded in the binary, though the final executable is smaller than I would expect from this and I do not know what mechanism does that.<br />
I couldn't make the size much larger than this on my laptop without LLVM or the linker crashing from non-language limitations.</p>
<h1><a href="https://www.rust-lang.org" rel="nofollow noreferrer">Rust</a>, 42 bytes, 18(?) EB executable (on a 64-bit system)</h1>
<pre class="lang-rust prettyprint-override"><code>fn main(){print!(&quot;{:?}&quot;,[0u8;usize::MAX])}  
</code></pre>
<p>The array would have a size of 18 EB, but the final executable would probably be smaller. I can't afford this much RAM and storage space, so I haven't been able to test this. Maybe you can if you are in the future.</p>
</div>
<div id="pu5" class="pu"><h1>C, 54 bytes, ridiculously large executable</h1>
<pre class="lang-c prettyprint-override"><code>#include &lt;inttypes.h&gt;
uint64_t main[(uint64_t)~0]={~0};
</code></pre>
<p>Not exactly <em>original</em>, but much more devastating.</p>
<h3>Inline but not portable version</h3>
<pre class="lang-c prettyprint-override"><code>unsigned long long main[~0ull]={~0};
</code></pre>
<p>I am NOT going to sacrifice my laptop just for this.</p>
<h3>Explanation</h3>
<p><code>uint64_t</code>, <code>unsigned long long</code>, they're both unsigned 64-bit integers.<br/><br/>
The tilde (<code>~</code>) is the bitwise NOT operator in C (it flips the bits of a value).<br/><br/>
<code>(uint64_t)0</code> is <code>0000000000000000000000000000000000000000000000000000000000000000</code> in binary.<br/><br/>
By applying the bitwise NOT operator, we get a... big number (<span class="math-container">\$2^{64}-1\$</span>).</p>
<h3>Credits</h3>
<p>Big thanks to user Digital Trauma for his original <a href="https://codegolf.stackexchange.com/a/69193/108497">implementation</a>.
This answer is really just an expansion from that.</p>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/Vyxal/Myxal" rel="nofollow noreferrer">Myxal</a> 0.7.1, 46 source bytes + 2 bytes flag = 48 bytes, 2.042 MB compiled</h1>
<pre><code>~~~~~~~y¢aaaa¢bbbb¢cccc¢dddd¢eeee¢ffff¢gggg¢hh
</code></pre>
<p>Simple node alias recursion bomb. Adding more aliases make the JVM complain of a too large main method.</p>
<pre><code>~~~~~~~y # A bunch of filter modifiers on the element 'y'
¢a       # Alias that to 'a'
aaa¢b    # 3 'a's = 'b' and so on...
bbb¢c
ccc¢d
ddd¢e
eee¢f
fff¢g
ggg¢h
h        # Run that final 'h'
</code></pre>
<p>Compiled with the <code>-O</code> flag to disable optimization, which also disables shrinking for some reason.</p>
</div>
<div id="pu7" class="pu"><h1><a href="http://julialang.org/" rel="nofollow noreferrer">Julia</a>, 22 bytes (in memory)</h1>

<pre class="lang-julia prettyprint-override"><code>0:9^9 .|&gt;i-&gt;@eval 2^$i
</code></pre>
<p><a href="https://tio.run/##jcUxDsIwDADAr3RgaAcs0i0MFeIbCCqrdZCRm0S1Cy3i7@EDDCx3j0UY3VrK4ei9r@DT8b470ROlam87LiNrFtxq2zKlUJ9RCYSNZpQ@p1cDESeCyWCkoBBptX8ISxxAMw2Mwm80TlEB57u7uOvPm/IF" rel="nofollow noreferrer" title="Julia 1.0 – Try It Online">Try it online!</a></p>
<p>It's quite easy to make a compilation bomb in Julia, it can easily happen accidentally. Here we use the fact that <code>a^i</code> has some trickery when <code>i</code> is a litteral integer, that allows <code>a^2</code> to be turned into <code>a*a</code>, and <code>a^-1</code> into <code>inv(a)</code>. It means that there is a new compiled method of <code>litteral_pow</code> being compiled for each <code>i</code>. I'm pretty sure this would be at least 4GB but I don't know how to check it. This is only compiled in memory and not saved in a file though</p>
<h1><a href="http://julialang.org/" rel="nofollow noreferrer">Julia</a>, 114 bytes (output in a <code>.ji</code> file)</h1>

<pre class="lang-julia prettyprint-override"><code>using Pkg
pkg&quot;generate A&quot;
write(&quot;A/src/A.jl&quot;,&quot;module A
!(::Val{x}) where x=x
.!Val.(1:9^9)end&quot;)
pkg&quot;dev A&quot;
using A
</code></pre>
<p><a href="https://tio.run/##yyrNyUw0rPj/v7Q4My9dISA7nasgO10pPTUvtSixJFXBUYmrvCizJFVDyVG/uChZ31EvK0dJRyk3P6U0ByjLpahhZRWWmFNdUaupUJ6RWpSqUGFbwaWnCBTT0zC0soyz1EzNS1HSBJuakloGMhBileP//wA" rel="nofollow noreferrer" title="Julia 1.0 – Try It Online">(can't) Try it online!</a>
<a href="https://tio.run/##Hci7DsIgFADQvV9BN1huZITEoT/hYhxuykUxvFIgpRq/HY3TSc6zeYeyjxGSaZ7YMs1c6wv6d/8Itj9oI9bPfYL5d8BPWiklKJphXMkeD16PTMnyBfQsIGIgCBUM2QK2xRVKptWhdy@sLsUCuN3lVd7@ivEF" rel="nofollow noreferrer" title="Julia 1.0 – Try It Online">Try <code>A</code> online!</a></p>
<p>To save compiled code to a file, the function must be in a package, therefore we create a package <code>A</code> that has the culprit (the function <code>!</code>). <code>Val(i)</code> is of type <code>Val{i}</code>, so a new method is compiled for each <code>i</code>. The output file will be in <code>~/.julia/compiled/&lt;version&gt;/A/xxx.ji</code>
In my testing, each additional method adds at least 150 bytes (and growing, 182MB for 1M methods), which means 25M would be enough</p>
<p>in Julia 1.7, +2 bytes because <code>pkg&quot;dev ./A&quot;</code> is needed</p>
<h1><a href="http://julialang.org/" rel="nofollow noreferrer">Julia</a>, 117 bytes (without writing files)</h1>
<p>this is basically the same as the above, but with the files already there. This is slightly longer because of the uuid needed in <code>Project.toml</code> (this is taken care of in <code>pkg&quot;generate A&quot;</code>)</p>
<p><strong>file structure</strong></p>
<pre class="lang-julia prettyprint-override"><code>A
├── src
│   └── A.jl
├── Project.toml
└── a.jl

</code></pre>
<p><strong>Project.toml</strong>, 52 bytes</p>
<pre class="lang-julia prettyprint-override"><code>name=&quot;A&quot;
uuid=&quot;8945f399-ba5e-44d3-9e17-ab2f7e467331&quot;
</code></pre>
<p><strong>src/A.jl</strong>, 47 bytes</p>
<pre class="lang-julia prettyprint-override"><code>module A
!(::Val{x}) where x=x
.!Val.(0:9^9)end
</code></pre>
<p><a href="https://tio.run/##Hci7DsIgFADQvV9BN1huZITEoT/hYhxuykUxvFIgpRq/HY3TSc6zeYeyjxGSaZ7YMs1c6wv6d/8Itj9oI9bPfYL5d8BPWiklKJphXMkeD16PTMnyBfQsIGIgCBUM2QK2xRVKptWhdy@sLsUCuN3lVd7@ivEF" rel="nofollow noreferrer" title="Julia 1.0 – Try It Online">Try it online!</a></p>
<p><strong>a.jl</strong>, 7 bytes</p>
<pre class="lang-julia prettyprint-override"><code>using A
</code></pre>
<p><strong>command line options</strong> (in the <code>A</code> folder), +11 bytes</p>
<pre class="lang-julia prettyprint-override"><code>julia --project=. a.jl
</code></pre>
</div>
<div id="pu8" class="pu"><p><strong>Dlang</strong> (ldc compiler)</p>
<p>command to build <code>ldc -c t.d</code></p>
<p>GBS is count of gigabytes;</p>
<p>code of t.d:</p>
<pre><code>import std;
enum GBS = 1;
void main(){
    static foreach(i; 0..2* GBS){
        mixin(text(q{static immutable a}, i,q{ = uint.max.BigInt &lt;&lt; uint.max;}));
        mixin(text(q{a}, i, q{.writeln;}));
    }
}

</code></pre>
<p><a href="https://i.sstatic.net/umLHN.png" rel="nofollow noreferrer"><img src="https://i.sstatic.net/umLHN.png" alt="Result of compiling" /></a></p>
</div>
<div id="pu9" class="pu"><p>PHP 7.1:</p>
<pre><code>const X=&quot;x&quot;,Y=X.X.X.X.X.X.X.X,Z=Y.Y.Y.Y.Y.Y.Y.Y,A=Z.Z.Z.Z.Z.Z.Z.Z,B=A.A.A.A.A.A.A.A,C=B.B.B.B.B.B.B.B,D=C.C.C.C.C.C.C.C,E=D.D.D.D.D.D.D.D,F=E.E.E.E.E.E.E.E,G=F.F.F.F.F.F.F.F;
</code></pre>
<p><code>.</code> is the concatenation operator, and PHP's compiler will try to do constant folding where possible, so it will construct a huge string and store it in PHP's internal bytecode. (I think you can get this written to a file with newer versions.) This is only as efficient as a classic XML entity bomb unfortunately. You'd need a few more repetitions to get to the gigabyte range.</p>
<p>The interesting part is that by default the worst that'll happen is seeing an error like:</p>
<pre><code>Fatal error: Allowed memory size of 134217728 bytes exhausted (tried to allocate 50331680 bytes) in Command line code on line 1
</code></pre>
<p>PHP's web-orientedness means it has a memory limit by default!</p>
</div>
<div id="pu10" class="pu"><h1>Boo, way more than you can expect from this</h1>
<pre><code>macro R(e as int):for i in range(9**e):yield R.Body
x = 0
R 99:++x
</code></pre>
</div>
<div id="pu11" class="pu"><h2>C, 284 bytes + 2 for the <code>-c</code> in <code>gcc bomb.c -o bomb.o -c</code>; output: 2 147 484 052 bytes</h2>
 
<pre class="lang-c prettyprint-override"><code>#define a 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
#define b a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
#define c b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b
#define d c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c
#define e d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d
#define f e,e,e,e,e,e,e,e,e,e,e,e,e,e,e,e
__int128 x[]={f,f,f,f,f,f,f,f};
</code></pre>
</div>
<div id="pu12" class="pu"><h2>C, 26 byte source, 2,139,103,367 byte output, valid program</h2>

<pre><code>const main[255&lt;&lt;21]={195};
</code></pre>

<p>Compiled using: <code>gcc cbomb.c -o cbomb</code> (gcc version 4.6.3, Ubuntu 12.04, ~77 seconds)</p>

<p>I thought I'd try to see how large I could make a valid program without using any command line options. I got the idea from this answer: <a href="https://codegolf.stackexchange.com/a/69193/44946">https://codegolf.stackexchange.com/a/69193/44946</a> by Digital Trauma. See the comments there as to why this compiles.</p>

<p>How it works: The <code>const</code> removes the write flag from the pages in the segment, so main can be executed. The <code>195</code> is the Intel machine code for a return. And since the Intel architecture is little-endian, this is the first byte. The program will exit with whatever the start up code put in the eax register, likely 0.</p>

<p>It's only about 2 gig because the linker is using 32 bit signed values for offsets. It's 8 meg smaller than 2 gig because the compiler/linker needs some space to work and this is the largest I could get it without linker errors - ymmv.</p>
</div>
<div id="pu13" class="pu"><h1>C, (14 + 15) = 29 byte source, 17,179,875,837 (16 GB) byte executable</h1>
<p>Thanks to @viraptor for 6 bytes off.</p>
<p>Thanks to @hvd for 2 bytes off and executable size x4.</p>
<p>This defines the <code>main</code> function as a large array and initialises its first element.  This causes GCC to store the entire array in the resulting executable.</p>
<p>Because this array is bigger than 2GB, we need to provide the <code>-mcmodel=medium</code> flag to GCC.  The extra 15 bytes are included in the score, as per the rules.</p>

<pre class="lang-c prettyprint-override"><code>main[-1u]={1};
</code></pre>
<p>Don't expect this code to do anything nice when run.</p>
<p>Compile with:</p>
<pre class="lang-c prettyprint-override"><code>gcc -mcmodel=medium cbomb.c -o cbomb
</code></pre>
<hr />
<p>It took me a while to get round to testing @hvd's suggestion - and to find a machine with enough juice to handle it. Eventually I found a old non-production RedHat 5.6 VM with 10GB RAM, 12GB swap, and /tmp set to a large local partition.  GCC version is 4.1.2.  Total compile time about 27 minutes.</p>
<blockquote>
<p><strong>Due to the CPU and RAM load, I recommend against doing this compile on any remotely production-related machine</strong>.</p>
</blockquote>
</div>
<div id="pu14" class="pu"><h1>Scala - 70 byte source, 22980842 byte result (after jar)</h1>

<pre><code>import scala.{specialized =&gt; s}
class X[@s A, @s B, @s C, @s D, @s E]
</code></pre>

<p>This produces 9<sup>5</sup> (about 59,000) specialized class files, which pack into a jar of about 23 MB.  You can in principle keep going if you have a filesystem that can handle that many files and enough memory.</p>

<p>(If the jar command must be included, it's 82 bytes.)</p>
</div>
<div id="pu15" class="pu"><h1>Java, 450 + 22 = 472 bytes source, ~1GB class file</h1>

<h2>B.java (golfed version, warning during compilation)</h2>

<pre class="lang-java prettyprint-override"><code>import javax.annotation.processing.*;@SupportedAnnotationTypes("java.lang.Override")public class B extends AbstractProcessor{@Override public boolean process(java.util.Set a,RoundEnvironment r){if(a.size()&gt;0){try(java.io.Writer w=processingEnv.getFiler().createSourceFile("C").openWriter()){w.write("class C{int ");for(int i=0;i&lt;16380;++i){for(int j=0;j&lt;65500;++j){w.write("i");}w.write(i+";int ");}w.write("i;}");}catch(Exception e){}}return true;}}
</code></pre>

<h2>B.java (ungolfed version)</h2>

<pre class="lang-java prettyprint-override"><code>import java.io.Writer;
import java.util.Set;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.TypeElement;

@SupportedAnnotationTypes("java.lang.Override")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class B extends AbstractProcessor {
    @Override
    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
        if (annotations.size() &gt; 0) {
            try (Writer writer = processingEnv.getFiler().createSourceFile("C").openWriter()) {
                writer.write("class C{int ");
                for (int i = 0; i &lt; 16380; ++i) {
                    for (int j = 0; j &lt; 65500; ++j) {
                        writer.write("i");
                    }
                    writer.write(i + ";int ");
                }
                writer.write("i;}");
            } catch (Exception e) {
            }
        }
        return true;
    }
}
</code></pre>

<h2>Compilation</h2>

<pre><code>javac B.java
javac -J-Xmx16G -processor B B.java
</code></pre>

<h2>Explanation</h2>

<p>This bomb uses Annotation Processors. It needs 2 compile passes. The first pass builds the processor class <code>B</code>. During the second pass the processor creates a new source file <code>C.java</code>, and compiles it to a <code>C.class</code> with a size of <code>1,073,141,162</code> bytes.</p>

<p>There are several limitations when trying to create a big class file:</p>

<ul>
<li>Creating identifiers longer than about 64k results in: <code>error: UTF8 representation for string "iiiiiiiiiiiiiiiiiiii..." is too long for the constant pool</code>.</li>
<li>Creating more than about 64k variables/functions results in: <code>error: too many constants</code></li>
<li>There is also a limit of about 64k for the code size of a function.</li>
<li>There seems to be a general limit (bug?) in the java compiler of about 1GB for the <code>.class</code> file. If I increase <code>16380</code> to <code>16390</code> in the above code the compiler never returns.</li>
<li>There is also a limit of about 1GB for the <code>.java</code> file. Increasing <code>16380</code> to <code>16400</code> in the above code results in: <code>An exception has occurred in the compiler (1.8.0_66). Please file a bug ...</code> followed by a <code>java.lang.IllegalArgumentException</code>.</li>
</ul>
</div>
<div id="pu16" class="pu"><h1>C#, about 1 min to compile, 28MB output binary:</h1>

<pre><code>class X&lt;A,B,C,D,E&gt;{class Y:X&lt;Y,Y,Y,Y,Y&gt;{Y.Y.Y.Y.Y.Y.Y.Y.Y y;}}
</code></pre>

<p>Adding more Y's will increase the size exponentially.</p>

<p>An explanation by Pharap as per @Odomontois' request:</p>

<p>This answer is abusing inheritance and type parameters to create recursion. To understand what's happening, it's easier to first simplify the problem. Consider <code>class X&lt;A&gt; { class Y : X&lt;Y&gt; { Y y; } }</code>, which generates the generic class <code>X&lt;A&gt;</code>, which has an inner class <code>Y</code>. <code>X&lt;A&gt;.Y</code> inherits <code>X&lt;Y&gt;</code>, hence <code>X&lt;A&gt;.Y</code> also has an inner class <code>Y</code>, which is then <code>X&lt;A&gt;.Y.Y</code>. This then also has an inner class <code>Y</code>, and that inner class <code>Y</code> has an inner class <code>Y</code> etc. This means that you can use scope resolution (<code>.</code>) ad infinitum, and every time you use it, the compiler has to deduce another level of inheritance and type parameterisation.</p>

<p>By adding additional type parameters, the work the compiler has to do at each stage is further increased.</p>

<p>Consider the following cases: <br>
In <code>class X&lt;A&gt; { class Y : X&lt;Y&gt; { Y y;} }</code> type param <code>A</code> has a type of <code>X&lt;A&gt;.Y</code>. <br>
In <code>class X&lt;A&gt; { class Y : X&lt;Y&gt; { Y.Y y;} }</code> type param <code>A</code> has a type of <code>X&lt;X&lt;A&gt;.Y&gt;.Y</code>. <br>
In <code>class X&lt;A&gt; { class Y : X&lt;Y&gt; { Y.Y.Y y;} }</code> type param <code>A</code> has a type of <code>X&lt;X&lt;X&lt;A&gt;.Y&gt;.Y&gt;.Y</code>. <br>
In <code>class X&lt;A,B&gt; { class Y : X&lt;Y,Y&gt; { Y y;} }</code> type param <code>A</code> is <code>X&lt;A,B&gt;.Y</code> and <code>B</code> is <code>X&lt;A,B&gt;.Y</code>. <br>
In <code>class X&lt;A&gt; { class Y : X&lt;Y&gt; { Y.Y y;} }</code> type param <code>A</code> is <code>X&lt;X&lt;A,B&gt;.Y, X&lt;A,B&gt;.Y&gt;.Y</code> and <code>B</code> is <code>X&lt;X&lt;A,B&gt;.Y, X&lt;A,B&gt;.Y&gt;.Y</code>. <br>
In <code>class X&lt;A&gt; { class Y : X&lt;Y&gt; { Y.Y.Y y;} }</code> type param <code>A</code> is <code>X&lt;X&lt;X&lt;A,B&gt;.Y, X&lt;A,B&gt;.Y&gt;.Y, X&lt;X&lt;A,B&gt;.Y, X&lt;A,B&gt;.Y&gt;.Y&gt;.Y</code> and <code>B</code> is <code>X&lt;X&lt;X&lt;A,B&gt;.Y, X&lt;A,B&gt;.Y&gt;.Y, X&lt;X&lt;A,B&gt;.Y, X&lt;A,B&gt;.Y&gt;.Y&gt;.Y</code>.</p>

<p>Following this pattern, one can only imagine<sup>1</sup> the work the compiler would have to do to to deduce what <code>A</code> to <code>E</code> are in <code>Y.Y.Y.Y.Y.Y.Y.Y.Y</code> in the definition <code>class X&lt;A,B,C,D,E&gt;{class Y:X&lt;Y,Y,Y,Y,Y&gt;{Y.Y.Y.Y.Y.Y.Y.Y.Y y;}}</code>.</p>

<p><sup>1</sup> You could figure it out, but you'd need a lot of patience, and intellisense won't help you out here.</p>
</div>
<div id="pu17" class="pu"><h1>Python 3, 13 byte source, 9,057,900,463 byte (8.5GiB) .pyc-file</h1>

<pre class="lang-python prettyprint-override"><code>(1&lt;&lt;19**8,)*2
</code></pre>
<p><strong>Edit</strong>: Changed the code to the version above after I realized the rules say output size beyond 4GiB doesn't matter, and the code for this one is ever so slightly shorter; The previous code - and more importantly the explanation - can be found below.</p>
<hr />
<h1>Python 3, 16 byte source, &gt;32TB .pyc-file (if you have enough memory, disk space and patience)</h1>

<pre class="lang-python prettyprint-override"><code>(1&lt;&lt;19**8,)*4**7
</code></pre>
<p>Explanation: Python 3 does constant folding, and you get big numbers fast with exponentation. The format used by .pyc files stores the length of the integer representation using 4 bytes, though, and in reality the limit seems to be more like <code>2**31</code>, so using just exponentation to generate one big number, the limit seems to be generating a 2GB .pyc file from an 8 byte source. (<code>19**8</code> is a bit shy of <code>8*2**31</code>, so <code>1&lt;&lt;19**8</code> has a binary representation just under 2GB; the multiplication by eight is because we want bytes, not bits)</p>
<p>However, tuples are also immutable and multiplying a tuple is also constant folded, so we can duplicate that 2GB blob as many times as we want, up to at least <code>2**31</code> times, probably. The <code>4**7</code> to get to 32TB was chosen just because it was the first exponent I could find that beat the previous 16TB answer.</p>
<p>Unfortunately, with the memory I have on my own computer, I could test this only up to a multiplier of 2, ie. <code>(1&lt;&lt;19**8,)*2</code>, which generated a 8.5GB file, which I hope demonstrates that the answer is realistic (ie. the file size isn't limited to 2**32=4GB).</p>
<p>Also, I have no idea why the file size I got when testing was 8.5GB instead of the 4GB-ish I expected, and the file is big enough that I don't feel like poking around it at the moment.</p>
</div>
<div id="pu18" class="pu"><p>Here's my C answer from 2005. Would produce a 16TB binary if you had 16TB RAM (you don't).</p>

<pre class="lang-c prettyprint-override"><code>struct indblock{
   uint32_t blocks[4096];
};

struct dindblock {
    struct indblock blocks[4096];
};

struct tindblock {
    struct dindblock blocks[4096];
};

struct inode {
    char data[52]; /* not bothering to retype the details */
    struct indblock ind;
    struct dindblock dint;
    struct tindblock tind;
};

struct inode bbtinode;

int main(){}
</code></pre>
</div>
<div id="pu19" class="pu"><h1>Plain old C preprocessor: 214 bytes input, 5MB output</h1>
<p>Inspired by my real-world preprocessor fail <a href="https://stackoverflow.com/questions/652788/what-is-the-worst-real-world-macros-pre-processor-abuse-youve-ever-come-across/1594500#1594500">here</a>.</p>
<pre><code>#define A B+B+B+B+B+B+B+B+B+B
#define B C+C+C+C+C+C+C+C+C+C
#define C D+D+D+D+D+D+D+D+D+D
#define D E+E+E+E+E+E+E+E+E+E
#define E F+F+F+F+F+F+F+F+F+F
#define F x+x+x+x+x+x+x+x+x+x

int main(void) { int x, y = A; }
</code></pre>
<p>Experiments show that each level of <code>#define</code>s will (as expected) make the output approximately ten times larger. But since this example took more than an hour to compile, I never went on to &quot;G&quot;.</p>
</div>
<div id="pu20" class="pu"><h1>C++, 250 + 26 = 276 bytes</h1>



<pre><code>template&lt;int A,int B&gt;struct a{static const int n;};
template&lt;int A,int B&gt;const int a&lt;A,B&gt;::n=a&lt;A-1,a&lt;A,B-1&gt;::n&gt;::n;
template&lt;int A&gt;struct a&lt;A,0&gt;{static const int n=a&lt;A-1,1&gt;::n;};
template&lt;int B&gt;struct a&lt;0,B&gt;{static const int n=B+1;};
int h=a&lt;4,2&gt;::n;
</code></pre>

<p>This is the <a href="https://en.wikipedia.org/wiki/Ackermann_function">Ackermann function</a> implemented in templates.  I'm not able to compile with <code>h=a&lt;4,2&gt;::n;</code> on my little (6GB) machine, but I did manage <code>h=a&lt;3,14&gt;</code> for a 26M output file.  You can tune the constants to hit your platform's limits - see the linked Wikipedia article for guidance.</p>

<p>Requires <code>-g</code> flag to GCC (because it's all the debug symbols that actually consume any space), and a larger-than-default template depth.  My compile line ended up as
</p>

<pre><code>g++ -ftemplate-depth=999999 -g -c -o 69189.o 69189.cpp
</code></pre>

<h3>Platform information</h3>

<pre><code>g++ (Ubuntu 4.8.2-19ubuntu1) 4.8.2
Linux 3.13.0-46-generic #79-Ubuntu SMP x86_64 GNU/Linux
</code></pre>
</div>
<div id="pu21" class="pu"><h1>ASM, 61 bytes (29 bytes source, 32 bytes for flags), 4,294,975,320 bytes executable</h1>

<pre><code>.globl main
main:
.zero 1&lt;&lt;32
</code></pre>

<p>Compile with <code>gcc the_file.s -mcmodel=large -Wl,-fuse-ld=gold</code></p>
</div>
<div id="pu22" class="pu"><h1><a href="https://github.com/boo-lang/boo" rel="noreferrer">Boo</a>, 71 bytes.  Compile time: 9 minutes. 134,222,236 byte executable</h1>
<pre><code>macro R(e as int):
 for i in range(2**e):yield R.Body
x = 0
R 25:++x
</code></pre>
<p>Uses a macro <code>R</code> (for Repeat) to cause the compiler to multiply the increment statement an arbitrary number of times.  No special compiler flags are needed; simply save the file as <code>bomb.boo</code> and invoke the compiler with <code>booc bomb.boo</code> to build it.</p>
</div>
<div id="pu23" class="pu"><h1><a href="https://kotlinlang.org/">Kotlin</a>, 90 bytes source, 177416 bytes (173 KB) compiled JVM binary</h1>

<pre><code>inline fun a(x:(Int)-&gt;Any){x(0);x(1)}
fun b()=a{a{a{a{a{a{a{a{a{a{a{println(it)}}}}}}}}}}}
</code></pre>

<p>Technically, you could make this even longer by nesting the expression further. However, the compiler crashes with a <code>StackOverflow</code> error if you increase the recursion.</p>
</div>
<div id="pu24" class="pu"><h1>C++, 214 bytes (no special compile options needed)</h1>
<pre><code>#define Z struct X
#define T template&lt;int N
T,int M=N&gt;Z;struct Y{static int f(){return 0;}};T&gt;Z&lt;N,0&gt;:Y{};T&gt;Z&lt;0,N&gt;:Y{};T,int M&gt;Z{static int f(){static int x[99999]={X&lt;N-1,M&gt;::f()+X&lt;N,M-1&gt;::f()};}};int x=X&lt;80&gt;::f();
</code></pre>
<p>It's a fairly straightforward two-dimensional template recursion (recursion depth goes as the square-root of total templates emitted, so won't exceed platform limits), with a small amount of static data in each one.</p>
<p>Generated object file with <code>g++ 4.9.3 x86_64-pc-cygwin</code> is 2567355421 bytes (2.4GiB).</p>
<p>Increasing the initial value above 80 breaks the cygwin gcc assembler (too many segments).</p>
<p>Also, <code>99999</code> can be replaced by <code>9&lt;&lt;19</code> or similar for increased size without changing the source code... but I don't think I need to use any more disk space than I already am ;)</p>
</div>
<div id="pu25" class="pu"><blockquote>
  <p>If an output of more than 4GB is achieved (perhaps if somebody finds a turing complete preprocessor), the competition will be for the smallest source which produces a file of at least that size (it's just not practical to test submissions which get too big).</p>
</blockquote>

<p>"Template Haskell" allows Haskell code to be generated at compile-time using Haskell, and is hence a turing complete pre-processor.</p>

<p>Here's my attempt, parameterised by an arbitrary numerical expression <code>FOO</code>:</p>

<pre><code>import Language.Haskell.TH;main=print $(ListE .replicate FOO&lt;$&gt;[|0|])
</code></pre>

<p>The magic is the code inside the "splice" <code>$(...)</code>. This will be executed at compile time, to generate a Haskell AST, which is grafted on to the program's AST in place of the splice.</p>

<p>In this case, we make a simple AST representing the literal <code>0</code>, we replicate this <code>FOO</code> times to make a list, then we use <code>ListE</code> from the <code>Language.Haskell.TH</code> module to turn this list of ASTs into one big AST, representing the literal <code>[0, 0, 0, 0, 0, ...]</code>.</p>

<p>The resulting program is equivalent to <code>main = print [0, 0, 0, ...]</code> with <code>FOO</code> repetitions of <code>0</code>.</p>

<p>To compile to ELF:</p>

<pre><code>$ ghc -XTemplateHaskell big.hs
[1 of 1] Compiling Main             ( big.hs, big.o )
Linking big ...
$ file big
big: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /nix/store/mibabdfiaznqaxqiy4bqhj3m9gaj45km-glibc-2.21/lib/ld-linux.so.2, for GNU/Linux 2.6.32, not stripped
</code></pre>

<p>This weighs in at 83 bytes (66 for the Haskell code and 17 for the <code>-XTemplateHaskell</code> argument), plus the length of <code>FOO</code>.</p>

<p>We can avoid the compiler argument and just compile with <code>ghc</code>, but we have to put <code>{-# LANGUAGE TemplateHaskell#-}</code> at the beginning, which bumps the code up to 97 bytes.</p>

<p>Here are a few example expressions for <code>FOO</code>, and the size of the resulting binary:</p>

<pre><code>FOO         FOO size    Total size    Binary size
-------------------------------------------------
(2^10)      6B          89B           1.1MB
(2^15)      6B          89B           3.6MB
(2^17)      6B          89B           12MB
(2^18)      6B          89B           23MB
(2^19)      6B          89B           44MB
</code></pre>

<p>I ran out of RAM compiling with <code>(2^20)</code>.</p>

<p>We can also make an infinite list, using <code>repeat</code> instead of <code>replicate FOO</code>, but that prevents the compiler from halting ;)</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/69189/">69189</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




