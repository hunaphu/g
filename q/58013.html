<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::58013</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>136</td><td>Ruby pl</td><td>250527T044250Z</td><td><a href="https://codegolf.stackexchange.com/questions/58013/parentheses-into-footnotes/281996#281996">Value In</a></td></tr>
<tr d-ix="1"><td>138</td><td>JavaScript Node.js</td><td>250523T231618Z</td><td><a href="https://codegolf.stackexchange.com/questions/58013/parentheses-into-footnotes/281939#281939">l4m2</a></td></tr>
<tr d-ix="2"><td>335</td><td>Emacs Lisp</td><td>150916T090105Z</td><td><a href="https://codegolf.stackexchange.com/questions/58013/parentheses-into-footnotes/58066#58066">coredump</a></td></tr>
<tr d-ix="3"><td>1510</td><td>Sacred JavaScript</td><td>151006T230355Z</td><td><a href="https://codegolf.stackexchange.com/questions/58013/parentheses-into-footnotes/59907#59907">Conor O&</a></td></tr>
<tr d-ix="4"><td>244</td><td>JavaScript ES6</td><td>151006T223130Z</td><td><a href="https://codegolf.stackexchange.com/questions/58013/parentheses-into-footnotes/59901#59901">Conor O&</a></td></tr>
<tr d-ix="5"><td>533</td><td>Scheme</td><td>150917T151048Z</td><td><a href="https://codegolf.stackexchange.com/questions/58013/parentheses-into-footnotes/58161#58161">xebtl</a></td></tr>
<tr d-ix="6"><td>092</td><td>Scheme</td><td>150917T091351Z</td><td><a href="https://codegolf.stackexchange.com/questions/58013/parentheses-into-footnotes/58146#58146">xebtl</a></td></tr>
<tr d-ix="7"><td>201</td><td>Lua</td><td>150915T213303Z</td><td><a href="https://codegolf.stackexchange.com/questions/58013/parentheses-into-footnotes/58025#58025">Nikolai9</a></td></tr>
<tr d-ix="8"><td>072</td><td>Perl</td><td>150915T214122Z</td><td><a href="https://codegolf.stackexchange.com/questions/58013/parentheses-into-footnotes/58027#58027">Jarmex</a></td></tr>
<tr d-ix="9"><td>210</td><td>Haskell</td><td>150916T165838Z</td><td><a href="https://codegolf.stackexchange.com/questions/58013/parentheses-into-footnotes/58094#58094">nimi</a></td></tr>
<tr d-ix="10"><td>nan</td><td>Retina</td><td>150915T202208Z</td><td><a href="https://codegolf.stackexchange.com/questions/58013/parentheses-into-footnotes/58022#58022">Martin E</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a> <code>-pl</code>, 136 bytes</h1>
<p>Pursuant to new guidelines, all parentheses have been removed from this code. As such, parentheses are matched against <code>40.chr</code><sup>1</sup> and <code>41.chr</code><sup>2</sup> for removal purposes.</p>
<pre class="lang-ruby prettyprint-override"><code>i=0
b=40.chr
r=eval&quot;/\\#{b*3}\\g&lt;0&gt;|[^#{b+e=41.chr}]#{e+?*+e+?\\+e}/&quot;
while~r
sub r,&quot;&lt;sup&gt;#{i+=1}&lt;/sup&gt;&quot;
$_+=&quot;

&lt;sub&gt;#{i} #$1&lt;/sub&gt;&quot;
end
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=fZBLTsMwEIb3PsXgdGE3fYouWNTtlgOwAJqCEjLUkfKSH62iEtbcgU0XoJ6pl0HYbSUkhPjHGvn3Z82M5v1D2aTZL2i_zuly92nNc__q8JaJEUnEZDR4koooges4p8MoCrZJ97KNotV0NHtZPDgbopiM_a92GWwxnHdDl6IoxHZIyUZmOb4qom0Cqken2tazYJuFYtxOh95Q0nkMBSXEocSjFoLO2LPEMSzT0zznsXaHrxuZaZCxBqarAjnUscLSSNTonhJroKwM6AqKuGz4gIi_RX7KlKgNpsBSxDpvgFUKZLaSeTPncGL8V5e4TEHjGlWcw0pVttb_NLouCsaZOz1XBmJ_N8pwtmbAvDbWcC92y9kdZ_cc-MX8GJxXZzGfju60hm8" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p><sub>1 evaluates to open parenthesis symbol</sub></p>
<p><sub>2 evaluates to closed parenthesis symbol</sub></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 138 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>f=([c,...x],z=d=k='')=&gt;c?(d-=(c=='(')-(c==')'))?f(x,z+c):z?`&lt;sup&gt;${++k}&lt;/sup&gt;`+f(x.join``+`

&lt;sub&gt;${k} ${z.slice(1)}&lt;/sub&gt;`,''):c+f(x,z):x
</code></pre>
<p><a href="https://tio.run/##JY7LasMwEEX3@QotAppBtkq3JrJ/ortSkCKNH7GQjOUExyHf7qru7sI993EzD5PsPExLGaKjfW8VfNtCSrn@FJtyalSco6ptA65UYJXiwLE8BHLEpoW12ITFamv0Jd2n@vwSYnxfPv60FtmWtzgErYU@nTJwzcD4ZufXJpMfLMEnHvC11kVeqqw4GrFadxtDip6kjx20wL/6IbHeJAaB0kKOgSOa/JNBnFk/dL1/Nsj@PUQ2mZnC0lOinDDBsUQPmo1n3RzvU0KZ3@@/" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
</div>
<div id="pu2" class="pu"><h1>Emacs Lisp, 335 bytes</h1>

<p><strong>Foreword.</strong> <em>This answer and the Scheme ones are currently the only answers officially sanctioned by both the Mighty Popular Republic of LISP and the Church of Emacs. Other answers, shorter or not, are considered a threat to peace. In particular, and with a profound disdain to any libelious allegation of McCarthyism that is sporadically heard from hostile opponents of the state, we enjoin anyone who has information about the real identity of the anonymous  authors writing Nonlisp answers to contact your Local Bureau. It is reminded that everyone should take time to reflect and upvote in accordance to what he or she deeply believes will not threaten his or her future interactions with official representants of the power in place. Code is data. Data is code.</em></p>

<pre><code>(defun p()(let(b(cpt 0)n)(goto-char 0)(while(search-forward"("()t)(setf b(point)n(number-to-string(incf cpt)))(backward-char)(forward-sexp)(backward-char)(kill-region b(point))(delete-backward-char 1)(delete-forward-char 1)(insert "&lt;sup&gt;"n"&lt;/sup&gt;")(save-excursion(end-of-buffer)(newline 2)(insert "&lt;sub&gt;"n" ")(yank)(insert"&lt;/sub&gt;")))))
</code></pre>

<p>More elegantly:</p>

<pre><code>(defun parens ()
  (let (b(cpt 0)n)
    (goto-char 0)
    (while(search-forward"("()t)
      (setf b(point)n(number-to-string(incf cpt)))
      (backward-char)
      (forward-sexp)
      (backward-char)
      (kill-region b(point))
      (delete-backward-char 1)
      (delete-forward-char 1)
      (insert "&lt;sup&gt;"n"&lt;/sup&gt;")
      (save-excursion
       (end-of-buffer)
       (newline 2)
       (insert "&lt;sub&gt;"n" ")
       (yank)
       (insert "&lt;/sub&gt;")))))
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="http://esolangs.org/wiki/Sacred" rel="nofollow noreferrer">Sacred JavaScript</a>, 1510 bytes</h1>

<p><em>Fellow rebels, do not give in to their tyrannical demolition of the parenthesis! You must persevere! From the start, programming has been a free enterprise. Now, it has become a pervaded show of piety. We must show nothing less then absolute fearsomeness. Therefore, I have fought back!</em></p>

<pre><code>    ( )( (((  ((  )( )  (( ))( )) (( ( ((  ) ( ()( ) (( ) )(( ((( ()((( ) ( ) )((  ) (((((( )( (())((  ) ) )( ()(( ((()((()   ( (  (  ( )) ((  )( ) (( ) )((((  ( () ) )( ( ()(( )( () ((( )(( ) )( ()((( ) ( )  ( )() (((( () ) (((( () ) ((() ) ()  ( (  (  ( )) ( )(  ((((( )) ((  )( ) (( ) )((((  ) )  ()(  ((() ( ()(( ) ( ) )(( ))(((  (( ) ((  ) ( ()(( )( ) ()  ( (  (  ( ()( ) )( ()(  ) ()  ( (  (  ( )( (( ( (( )  ((((( ))  ) )(( )) ((  )( ) (( ) )((((  ) ()( ))  ) ) (( )( () (((   ( ) )((  )( )(((( ))( )() ) ()( ))  (()( (()( ((()((()   ( (  (    (  ( )) ( )(  (((((( )(( ( (( )) ( ((  ) )( ) )( ( )( ((() ( )( ((() ( ()( ()( ()   ) )( ()(( ) ()  ( (  (    (  ( )) ( )(  (((((( )(( ( (( )) ( ((  ) )( ) )( ( )( (((( ( )( ((() ( ()( ()( (()( ) )( ()(( ) ()  ( (  (    (  ( )) ( )(  (((( ( ) ( ()( ((() ( ()( ())(( ) ( ) )( ()(( ))) ) ()  ( (  (  ((())  ( (  (  ((( ( ) )((( )( () ((( )(((   ( )) ( )  ( ) ) ((((( )) ((  )( ) (( ) )((((  (())( ))  (()( ()(( ((()  ( (  (  ( )(  ) )(((( ( () ((( ) ( ) )(( ((((   ( ()(( )  ( ) ) (((( () )( ((( ((((((()( ((() ((   () )( )(( (()) ( )( ( )( ((() ) ()  ( (  (  (( ) ( ) )(( ))(((  (( ) ((  ) ( ()( ) (( ) )(( ((( ()((( ) ( ) )((  ) (((((( )( () ((( ) ( ) )(( ((((   ( ()(( )  ( ) ) ((((((( ( (()) ( )( ) ) (( )((((  ( ()) ) )) ( )( (()(((  ) (()( ( )( ) )  () )(( )((((  ( ()) ) )) ( )( ((() (()( ( )(  ( (  ( ( ) ) (( )((((  ( ()) ) )) ( )( (()(((  ) (()( ( )( ( () ( )( (()(( )(  (()( ( )( ) )  () )(( )((((  ( ()) ) )) ( )( (())((  ) (()( ()(( ((() ) ()  ( (((())
</code></pre>

<p>No rules against using the sacred characters in a non-Lisp language. Nope, not at all. (In a little less compact way:)</p>

<pre><code>( )( (((  ((  )( )  (( ))( )) (( ( ((  ) ( ()( ) (( ) )(( ((( ()((( ) 
( ) )((  ) (((((( )( (())((  ) ) )( ()(( ((()((()   ( (  (  ( )) ((  )
( ) (( ) )((((  ( () ) )( ( ()(( )( () ((( )(( ) )( ()((( ) ( )  ( )()
 (((( () ) (((( () ) ((() ) ()  ( (  (  ( )) ( )(  ((((( )) ((  )( ) (
( ) )((((  ) )  ()(  ((() ( ()(( ) ( ) )(( ))(((  (( ) ((  ) ( ()(( )(
 ) ()  ( (  (  ( ()( ) )( ()(  ) ()  ( (  (  ( )( (( ( (( )  ((((( )) 
 ) )(( )) ((  )( ) (( ) )((((  ) ()( ))  ) ) (( )( () (((   ( ) )((  )
( )(((( ))( )() ) ()( ))  (()( (()( ((()((()   ( (  (    (  ( )) ( )( 
 (((((( )(( ( (( )) ( ((  ) )( ) )( ( )( ((() ( )( ((() ( ()( ()( ()  
 ) )( ()(( ) ()  ( (  (    (  ( )) ( )(  (((((( )(( ( (( )) ( ((  ) )(
 ) )( ( )( (((( ( )( ((() ( ()( ()( (()( ) )( ()(( ) ()  ( (  (    (  
( )) ( )(  (((( ( ) ( ()( ((() ( ()( ())(( ) ( ) )( ()(( ))) ) ()  ( (
  (  ((())  ( (  (  ((( ( ) )((( )( () ((( )(((   ( )) ( )  ( ) ) ((((
( )) ((  )( ) (( ) )((((  (())( ))  (()( ()(( ((()  ( (  (  ( )(  ) )(
((( ( () ((( ) ( ) )(( ((((   ( ()(( )  ( ) ) (((( () )( ((( ((((((()(
 ((() ((   () )( )(( (()) ( )( ( )( ((() ) ()  ( (  (  (( ) ( ) )(( ))
(((  (( ) ((  ) ( ()( ) (( ) )(( ((( ()((( ) ( ) )((  ) (((((( )( () (
(( ) ( ) )(( ((((   ( ()(( )  ( ) ) ((((((( ( (()) ( )( ) ) (( )((((  
( ()) ) )) ( )( (()(((  ) (()( ( )( ) )  () )(( )((((  ( ()) ) )) ( )(
 ((() (()( ( )(  ( (  ( ( ) ) (( )((((  ( ()) ) )) ( )( (()(((  ) (()(
 ( )( ( () ( )( (()(( )(  (()( ( )( ) )  () )(( )((((  ( ()) ) )) ( )(
 (())((  ) (()( ()(( ((() ) ()  ( (((())
</code></pre>

<p>This compiles to the expanded JavaScript in my <a href="https://codegolf.stackexchange.com/questions/58013/parentheses-into-footnotes/59901#59901">other answer</a>. This is a joke submission.</p>
</div>
<div id="pu4" class="pu"><h1>JavaScript ES6, 244 bytes</h1>

<p><em>Serious answer (only works on FireFox, to my knowledge)</em></p>

<pre><code>d=(s,n=1)=&gt;{u=s.search(/\(/);if(index&lt;a=0)return s;for(i=index;i&lt;s.length;i++){if(s[i]==")")a-=1;if(s[i]=="(")a+=1;if(!a)break}return d(s.replace(v=s.slice(index,i+1),"&lt;sub&gt;"+n+"&lt;/sub&gt;")+`

&lt;sub&gt;`+n+" "+v.replace(/^\(|\)$/g,"")+"&lt;/sub&gt;",n+1)}
</code></pre>

<p>Expanded:</p>

<pre><code>function deparen(s,n=1){
    index = s.search(/\(/);
    if(index&lt;0) return s;
    a=0;
    for(i=index;i&lt;s.length;i++){
        if(s[i]==")") a-=1;
        if(s[i]=="(") a+=1;
        if(!a) break;
    }
    v=s.slice(index,i+1)
    f=v.replace(/^\(|\)$/g,"");
    return deparen(s.replace(v,"&lt;sub&gt;"+n+"&lt;/sub&gt;")+"\n\n&lt;sub&gt;"+n+" "+f+"&lt;/sub&gt;",n+1);
}
</code></pre>
</div>
<div id="pu5" class="pu"><h1>Scheme, 533 bytes</h1>

<p>With indentation:</p>

<pre><code>(letrec ((l string-&gt;list)
         (n number-&gt;string)
         (? null?)
         (p (lambda (o) (or (pair? o)(? o))))
         (a car)
         (d cdr)
         (e append)
         (i 0)
         (x
          (lambda (h t)
            (if (? h)
                t
                (case (a h)
                  ((#\() 
                   (let ((s (x (d h) ())))
                     (x (a s) (e t (d s)))))
                  ((#\)) (cons (d h) (list t)))
                  (else 
                   (x (d h) (e t (list (a h)))))))))
         (f 
          (lambda (h t F)
            (cond ((? h)
                   (let ((w (e t F)))
                     (if (find p w) (f w()()) w)))
                  ((p(a h))
                   (set! i(+ 1 i))
                   (f (d h)
                      (e t (e (l "&lt;sup&gt;")
                              (l (n i))
                              (l "&lt;/sup&gt;")))
                      (e F (e (l "\n\n&lt;sub&gt;")
                              (l (n i))
                              '(#\ )
                              (a h)
                              (l "&lt;/sub&gt;")))))
                  (else (f (d h) 
                           (e t (list (a h)))
                           F))))))
  (print (list-&gt;string (f (x (l (read-line)) 
                             ())
                          ()
                          ()))))
</code></pre>

<p>Yes, this is 533 bytes when all the optional whitespace is removed.  Bask in the functional glory.</p>

<p>I implemented more or less the algorithm in the description: <code>x</code> groups the input by parentheses and <code>f</code> replaces the first level of groups by footnotes, repeating until no more groups are left.  I am sure it can be made shorter, but I do not see how it could be made <em>much</em> shorter without switching to a different algorithm.</p>

<p>As written, it is a complete program.  You can try it out <a href="https://repl.it/BIoc/1" rel="nofollow">here</a>, but because repl.it apparently cannot deal with <code>(read-line)</code> you have to put the input string in its place.  A completely ungolfed version is <a href="https://repl.it/BIn4/8" rel="nofollow">here</a>.</p>

<p><em>EDIT:</em> As pointed out in the comments, I changed the parentheses <code>()</code> into  brackets <code>[]</code> in the repl.it versions.  This was purely for convenience during programming and debugging.  The version as posted now works with <code>()</code>.</p>
</div>
<div id="pu6" class="pu"><h1>Scheme, 92 bytes</h1>

<p>Frustrated with implementing the breadth-first search in Real Lisp,<sup>1</sup> the powers-that-be decide to take a more pragmatic approach.  After all, Parentheses are sacred, but brackets are not.<sup>2</sup></p>

<pre><code>(lambda(s)(list-&gt;string(map(lambda(c)(case c((#\()#\[)((#\))#\])(else c)))(string-&gt;list s)))
</code></pre>

<p><sub>1. listen not to those heretics from the so-called “church” of Emacs!</sub><br>
<sub>2. They are not Racket programmers, are they?</sub></p>
</div>
<div id="pu7" class="pu"><h1>Lua, <s>222</s> <s>216</s> <s>204</s> 201 bytes</h1>
<p>Golfed:</p>
<pre><code>s=io.read()g=&quot;%b()&quot;c=1k=string l=k.find t=k.sub o=k.format a,b=l(s,g)while a do s=t(s,0,a-1)..o(&quot;&lt;sup&gt;%d&lt;/sup&gt;&quot;,c)..t(s,b+1,#s)..&quot;\n\n&quot;..o(&quot;&lt;sub&gt;%d %s&lt;/sub&gt;&quot;,c,t(s,a+1,b-1))c=c+1 a,b=l(s,g)end print(s)
</code></pre>
<p>Ungolfed:</p>
<pre><code>input=io.read() 
inputFormat=&quot;&lt;sup&gt;%d&lt;/sup&gt;&quot;
footnoteFormat=&quot;&lt;sub&gt;%d %s&lt;/sub&gt;&quot;
counter=1
a,b=string.find(input,&quot;%b()&quot;)
while a do
    current=string.sub(input,a+1,b-1)
    input=input..&quot;\n\n&quot;..string.format(footnoteFormat, counter, current) 
    input=string.sub(input,0,a-1)..string.format(inputFormat, counter)..string.sub(input,b+1,#input)
    counter=counter+1
    a,b=string.find(input,&quot;%b()&quot;)
end

print(input)
</code></pre>
</div>
<div id="pu8" class="pu"><h1>Perl, <s>81</s> <s>75</s> 72 bytes</h1>

<p>71 bytes code + 1 byte command line argument.</p>

<p>Requires Perl 5.10 or newer (for recursive regex support)</p>

<pre class="lang-pl prettyprint-override"><code>$i++;s#(\((((?1)|.)*?)\))(.*)#&lt;sup&gt;$i&lt;/sup&gt;$4

&lt;sub&gt;$i $2&lt;/sub&gt;#s&amp;&amp;redo
</code></pre>

<h3>Usage:</h3>

<pre><code>perl -p entry.pl input.txt
</code></pre>

<h3>Explanation</h3>

<p><code>-p</code> parameter will print the result of applying the given commands to the input, avoiding the need for an explicit print.</p>

<p>The regex <code>(\(((?1)|.)*?)\))</code> is looking for the outermost set of brackets from the start of the string. When this is found, we perform the substitution, ensuring we only add the  at the very end of the input (by capturing everything until the end of the input using <code>(.*)</code>).</p>

<p>We then repeat the regex substitution on the now-substituted string using <code>redo</code>, which will continually apply the regex substitution until it no longer matches. The <code>s</code> modifier ensures that the <code>.</code> in the regex will match new lines, which is necessary because we re-apply the regex match on the result of the previous regex substitution.</p>
</div>
<div id="pu9" class="pu"><h1>Haskell, 210 bytes</h1>

<pre><code>n#x|b==""=a|1&lt;2=a++"&lt;sup&gt;"++m++"&lt;/sup&gt;"++((n+1)#(c++"\n\n&lt;sub&gt;"++m++' ':init d++"&lt;/sub&gt;"))where m=show n;(a,b)=span(/='(')x;(d,c)=[x|x@(y,_)&lt;-map(`splitAt`(tail b))[0..],'('!y&lt;')'!y]!!0;c!l=[1|m&lt;-l,m==c]
p=(1#)
</code></pre>

<p>Usage example:</p>

<pre><code>*Main&gt; putStrLn $ p "This has (nested (deeply (or highly?) nested)) parentheses (and several groups)."
This has &lt;sup&gt;1&lt;/sup&gt; parentheses &lt;sup&gt;2&lt;/sup&gt;.

&lt;sub&gt;1 nested &lt;sup&gt;3&lt;/sup&gt;&lt;/sub&gt;

&lt;sub&gt;2 and several groups&lt;/sub&gt;

&lt;sub&gt;3 deeply &lt;sup&gt;4&lt;/sup&gt; nested&lt;/sub&gt;

&lt;sub&gt;4 or highly?&lt;/sub&gt;
</code></pre>

<p>How it works:</p>

<pre><code>n # x                      -- # does all the work, n is the current number of the
                           --   footnote and x the input string
  | b=="" = a              -- if b (see below) is empty, there's no ( in the
                           --   string and the result is 'a' (see below)
  | 1&lt;2   = a++"&lt;sup&gt;"++m++"&lt;/sup&gt;"++ ((n+1)#(c++"\n\n&lt;sub&gt;"++m++' ':init d++"&lt;/sub&gt;"))
                           -- otherwise (b not empty) build the output string
                           --   starting with 'a' and a footnote number and a
                           --   recursive call with the current footnote appended
                           --   to the rest of the string  

  where 
  m = show n;              -- turn n into string
  (a,b) = span (/='(') x;  -- split the input string x into two parts:
                           --   a: everything before the first (
                           --   b: beginning with the first ( to the end
                           --   if there's no (, a is x and b is empty
  (d,c) = [x|x@(y,_)&lt;-map(`splitAt`(tail b))[0..],'('!y&lt;')'!y]!!0;
                           -- find matching ) in the tail of b ('tail' to remove leading '(') 
                           --   d: everything before and including the matching )
                           --   c: everything behind the matching )
  c!l=[1|m&lt;-l,m==c]        -- helper function that builds a list of 1s for every character searched for
                           --   we have reached the matching ) if the list for ( is
                           --   shorter (less than, &lt;) the list for )

p=(1#)                     -- start with footnote 1
</code></pre>
</div>
<div id="pu10" class="pu"><h1><a href="https://github.com/mbuettner/retina" rel="nofollow noreferrer">Retina</a>, <s>96</s> <s>86</s> 83 bytes * 120% = 99.6</h1>

<p>The source code of this solution consists of two files:</p>

<pre><code>+s`\((((\()|(?&lt;-3&gt;\))|[^)])*).(.*)(?&lt;=(1+).*?)?
</code></pre>



<pre><code>&lt;sup&gt;1$5&lt;/sup&gt;$4

&lt;sub&gt;1$5 $1&lt;/sub&gt;
</code></pre>

<h2>Explanation</h2>

<p>This is a very direct implementation of the algorithm as described in the challenge. The code consists of a single regex substitution which turns the first set of parentheses into a footnote. This substitution is repeated via the <code>+</code> until the string stops changing, which here means that the regex no longer matches (because it can't find any more parentheses).</p>

<p>The footnotes are enumerated in unary, so that I can simply look for the last footnote's number and append a <code>1</code> to create the next one.</p>

<p>The regex for finding the first set of parentheses is based on <a href="https://stackoverflow.com/a/17004406/1633117">the standard technique for matching parentheses with balancing groups</a> (hrhr, "matching parentheses"). It has been shortened a bit by using an unnamed group and by assuming that the parentheses are correctly balanced (which means we can omit the <code>(</code> from the negated character class and match the final <code>)</code> with a simple <code>.</code> and we also don't need to ensure that the capture stack is empty).</p>

<p>After matching the parentheses and capturing their contents into group <code>1</code>, we capture the remainder of the string with <code>(.*)</code> into group <code>4</code> and then search back through the the string for the first set of <code>1</code>s with a negative lookbehind. If we find such a substring, we store in group <code>5</code>. If we don't, we lookbehind fails, but that's okay because it's optional - it just means that <code>$5</code> will give an empty string which is the unary representation of <code>0</code> and which is also correct.</p>

<p>The substitution string then simply pieces everything together based on the capturing groups. The footnote number is incremented by prepending a <code>1</code> to the last number with <code>1$5</code>.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/58013/">58013</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




