<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::79545</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>029</td><td>MATL</td><td>170208T094551Z</td><td><a href="https://codegolf.stackexchange.com/questions/79545/jordan-decomposition/109481#109481">miles</a></td></tr>
<tr d-ix="1"><td>060</td><td>Octave</td><td>170208T091147Z</td><td><a href="https://codegolf.stackexchange.com/questions/79545/jordan-decomposition/109478#109478">miles</a></td></tr>
<tr d-ix="2"><td>071</td><td>J</td><td>170206T093554Z</td><td><a href="https://codegolf.stackexchange.com/questions/79545/jordan-decomposition/109259#109259">miles</a></td></tr>
<tr d-ix="3"><td>105</td><td>Mathematica</td><td>160621T053614Z</td><td><a href="https://codegolf.stackexchange.com/questions/79545/jordan-decomposition/83429#83429">miles</a></td></tr>
<tr d-ix="4"><td>079</td><td>Sage</td><td>160513T061709Z</td><td><a href="https://codegolf.stackexchange.com/questions/79545/jordan-decomposition/79840#79840">user4594</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/lmendo/MATL" rel="nofollow noreferrer">MATL</a>, 29 bytes, non-competing</h1>

<pre><code>1$Yn1$ZQYotdUZS~0hXdF1hYSwXd+
</code></pre>

<p><a href="https://tio.run/nexus/matl#HYk9C8MwDET/yg3ZikCS5Q/w3j2EQpzSzUOmZAl06193ROEed7wbMrVDpm1u59Vf2/Ljfe1P2dvyXftjjLcprMAYyTzVBJYRBNGlVooR5ILUyeY7VQfk978zg1KpgaEMUQSDlM8N" rel="nofollow noreferrer" title="MATL – TIO Nexus">Try it online!</a></p>

<p>This is my first MATL submission so there are bound to be improvements. I spent a while learning it and only at the end did I remember that this might not have worked using the MATL from May 7, 2016. Sure enough, I checked out the penultimate <a href="https://github.com/lmendo/MATL/tree/673ac40831308a27475c53e4d28bc59ebf0f453f" rel="nofollow noreferrer">commit</a> to that day and it did not run.</p>

<p>I would have liked to use <code>diag</code> but it seems MATL only supports the single argument version. The second argument would be needed to place values along the superdiagonal (or any other diagonal for different problems).</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.gnu.org/software/octave/" rel="nofollow noreferrer">Octave</a>, 60 bytes</h1>



<pre class="lang-matlab prettyprint-override"><code>@(a)diag(1-sign(diff(v=round(roots(poly(a)))).^2),1)+diag(v)
</code></pre>

<p><a href="https://tio.run/nexus/octave#HYtdCoMwEITfPcU8bmhT8rMaIQi9R2lBCBGhGtFW6Ont4jLDfMzuHnfqVRr7gazexmGmNOZMe7eW75xoLeWz0VLeP7mSub2culp1OR92dWR06OctVpPAgx24BRs0LIpswQHeopbSRV3X0FJoJw4s3EQxtKzPDAa6aaM3cAbWwTNs@6wyTer4Aw" rel="nofollow noreferrer">Try it online!</a></p>

<p>A port of my Mathematica <a href="https://codegolf.stackexchange.com/a/83429/6710">solution</a>.</p>
</div>
<div id="pu2" class="pu"><h1><a href="http://jsoftware.com/" rel="nofollow noreferrer">J</a>, <s>78</s> 71 bytes</h1>

<pre><code>1(#\.|."_1#{."1],.2=/\,&amp;_)@&gt;@{[:p.@&gt;[:-&amp;.&gt;/ .(+//.@(*/)&amp;.&gt;)],&amp;.&gt;[:-@=#\
</code></pre>

<p><a href="https://tio.run/nexus/j#TY/daoQwEIXv8xSHFRZtbeIkExWLkvdYJRdLl95Ie799dztJhBbmJ985mSE5HpgnUF2t@kdfIlVPfaGt1XY2a3uNTVjC8zZ967DcprerXgx0/WqMDvWLaYSbrZUqXpirVam9S@siY1vhwbAgdJLxX7isFNGqnfKETRPprnhqt3@ay5pTu8uaS1ramzanKl5yObs@uxY8gjv0nIIJPMAR/Jis6L28b5DtkgPLuS8pdu5Dh9iPcB2svMXCMWhU6uP@@QX53jse0k6kgnSiLWhPdAXdiVyQj@MX" rel="nofollow noreferrer">Try it online!</a></p>

<p>The two challenging portions of this task, getting the eigenvalues and performing the diagonalization, ending up both taking about the same number of bytes. These were disallowed by the rules but in case any are curious, J has builtins for QR decomposition (<code>128!:0</code>) as well as LAPACK addons which could be used to find eigenvalues.</p>



<h2>Explanation (Outdated)</h2>

<p>There are two major portions to this verb: finding the eigenvalues and performing the diagonalization. First, in order to find the eigenvalues, the roots of the characteristic polynomial for the input matrix will have to be found. Using the same input matrix from the example,</p>

<pre><code>   ] m =: _4 ]\ 5 4 2 1 0 1 _1 _1 _1 _1 3 0 1  1 _1 2
 5  4  2  1
 0  1 _1 _1
_1 _1  3  0
 1  1 _1  2
</code></pre>

<p>The characteristic polynomial for a matrix <em>M</em> can be found using |<em>M</em> - <em>λI</em>| = 0 where <em>I</em> is the identity matrix with the same dimensions as <em>M</em>. The expression <em>M</em> - <em>λI</em> can be modeled in J by boxing each element in <em>M</em> with a -1 if it is on the diagonal else otherwise a 0. Each box represents a polynomial in coefficient form.</p>

<pre><code>   (],&amp;.&gt;[:-@=#\) m
┌────┬────┬────┬────┐
│5 _1│4 0 │2 0 │1 0 │
├────┼────┼────┼────┤
│0 0 │1 _1│_1 0│_1 0│
├────┼────┼────┼────┤
│_1 0│_1 0│3 _1│0 0 │
├────┼────┼────┼────┤
│1 0 │1 0 │_1 0│2 _1│
└────┴────┴────┴────┘
</code></pre>

<p>The determinant in J is <code>-/ .*</code> however, that operates on numbers, not boxed polynomials. Instead of multiplication, the polynomial product is needed which can be found using convolution (<code>[:+//.*/</code>). Folded subtraction is still used, and both these verbs need to operate within boxes so under (<code>&amp;.</code>) unbox (<code>&gt;</code>) is used.</p>

<pre><code>   ([:-&amp;.&gt;/ .(+//.@(*/)&amp;.&gt;)],&amp;.&gt;[:-@=#\) m0
┌───────────────┐
│32 _64 42 _11 1│
└───────────────┘
</code></pre>

<p>These are the coefficients of the characteristic polynomial. The roots can be found using <code>p.</code> which converts the representation of a polynomial between coefficients and roots form.</p>

<pre><code>   ([:p.@&gt;[:-&amp;.&gt;/ .(+//.@(*/)&amp;.&gt;)],&amp;.&gt;[:-@=#\) m0
┌─┬───────┐
│1│4 4 2 1│
└─┴───────┘
</code></pre>

<p>The roots are <code>[4, 4, 2, 1]</code> and those are the eigenvalues of <em>M</em>.</p>

<p>Second, the diagonalization must be performed. Each continuous pair of values is tested for equality.</p>

<pre><code>   (2=/\]) 4 4 2 1
1 0 0
</code></pre>

<p>A zero is appended and those values are columinized together with the eigenvalues.</p>

<pre><code>   (],.0,~2=/\]) 4 4 2 1
4 1
4 0
2 0
1 0
</code></pre>

<p>Then each row is padded to the same length as the number of eigenvalues to form a square matrix.</p>

<pre><code>   (#{."1],.0,~2=/\]) 4 4 2 1
4 1 0 0
4 0 0 0
2 0 0 0
1 0 0 0
</code></pre>

<p>Finally each row is shifted right with values falling off at the right and zeros being pushed in on the left. The first row is shifted zero times, the second once, the third twice, and so on.</p>

<pre><code>   (-@i.@#|.!.0"_1#{."1],.0,~2=/\]) 4 4 2 1
4 1 0 0
0 4 0 0
0 0 2 0
0 0 0 1
</code></pre>

<p>The output is the Jordan decomposition of <em>M</em>.</p>
</div>
<div id="pu3" class="pu"><h1>Mathematica, <s>140</s> <s>139</s> 105 bytes</h1>

<pre><code>Total[DiagonalMatrix@@@{{#},{1-Sign[Differences@#^2],1}}]&amp;@(x/.Solve[#~CharacteristicPolynomial~x==0,x])&amp;
</code></pre>

<p>I just found the builtin <code>DiagonalMatrix</code> which allows for an easy way to place the 0s and 1s along the superdiagonal.</p>

<h2>Usage</h2>

<p><img src="https://i.sstatic.net/aucIS.png" alt="Example"></p>
</div>
<div id="pu4" class="pu"><h2>Sage, 79 bytes</h2>
<pre class="lang-py prettyprint-override"><code>lambda A:block_diagonal_matrix([jordan_block(*r)for r in A.charpoly().roots()])
</code></pre>
<p><a href="http://sagecell.sagemath.org/?z=eJw1TdEOgjAMfCfhH_q4mY3IGIOY-MB3kIUMCAoOZiYP-ve2GB-uvd712unq3dqPDppL78Pw6MbZ3cLmfLe6Pc5v1i4hjm7rDpedIp9ChAjzBk023F18Bv9hPIsh7C_GLU-TNJnYP9xqJUDXiLMAowlWQKtzVCoBBfaSXEWqLEsBknSpqFSaRnNY2iCn1R-r8Jw0NVkFUoXI8VOBiby2lvMvdPI4Eg==&amp;lang=sage" rel="nofollow noreferrer">Try it online</a></p>
<p>Since nobody else is posting solutions, I might as well go ahead and post one.</p>
<p><code>A.charpoly.roots()</code> computes the roots (and algebraic multiplicities) of the characteristic polynomial of <code>A</code> (aka the eigenvalues and multiplicities). <code>jordan_block</code> constructs a Jordan block from the given root and multiplicity. <code>block_diagonal_matrix</code> forms a matrix with the Jordan blocks on the diagonal, which is exactly the definition of a Jordan normal form.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/79545/">79545</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




