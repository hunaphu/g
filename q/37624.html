<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::37624</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td></td><td>170626T134654Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/128411#128411">Arnauld</a></td></tr>
<tr d-ix="1"><td>nan</td><td></td><td>240804T043815Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/274663#274663">noodle p</a></td></tr>
<tr d-ix="2"><td>nan</td><td></td><td>181007T092746Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/173575#173575">Shieru A</a></td></tr>
<tr d-ix="3"><td>nan</td><td></td><td>230306T222510Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/258893#258893">EzioMerc</a></td></tr>
<tr d-ix="4"><td>nan</td><td></td><td>170621T010021Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/127617#127617">Downgoat</a></td></tr>
<tr d-ix="5"><td>nan</td><td></td><td>151022T192124Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/61491#61491">user4616</a></td></tr>
<tr d-ix="6"><td>nan</td><td></td><td>220228T031955Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/243482#243482">emanresu</a></td></tr>
<tr d-ix="7"><td>nan</td><td></td><td>220126T050015Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/241776#241776">l4m2</a></td></tr>
<tr d-ix="8"><td>nan</td><td></td><td>201209T070953Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/216135#216135">Arnauld</a></td></tr>
<tr d-ix="9"><td>nan</td><td></td><td>200503T094933Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/204269#204269">ComFreek</a></td></tr>
<tr d-ix="10"><td>nan</td><td></td><td>200206T131557Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/199043#199043">Shieru A</a></td></tr>
<tr d-ix="11"><td>nan</td><td></td><td>151022T185907Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/61489#61489">ETHprodu</a></td></tr>
<tr d-ix="12"><td>nan</td><td></td><td>140912T165542Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/37723#37723">edc65</a></td></tr>
<tr d-ix="13"><td>nan</td><td></td><td>150801T174041Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/54174#54174">Downgoat</a></td></tr>
<tr d-ix="14"><td>nan</td><td></td><td>181017T150135Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/174204#174204">kamoroso</a></td></tr>
<tr d-ix="15"><td>nan</td><td></td><td>170621T012834Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/127625#127625">Calculat</a></td></tr>
<tr d-ix="16"><td>nan</td><td></td><td>180818T122104Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/170840#170840">Arnauld</a></td></tr>
<tr d-ix="17"><td>nan</td><td></td><td>170922T121622Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/143490#143490">Shaggy</a></td></tr>
<tr d-ix="18"><td>nan</td><td></td><td>160209T174121Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/71585#71585">Chiru</a></td></tr>
<tr d-ix="19"><td>nan</td><td></td><td>170214T165919Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/110044#110044">ETHprodu</a></td></tr>
<tr d-ix="20"><td>nan</td><td></td><td>161004T011341Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/95291#95291">ETHprodu</a></td></tr>
<tr d-ix="21"><td>nan</td><td></td><td>161117T162551Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/100193#100193">ETHprodu</a></td></tr>
<tr d-ix="22"><td>nan</td><td></td><td>170120T104850Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/107491#107491">Arnauld</a></td></tr>
<tr d-ix="23"><td>nan</td><td></td><td>170107T093154Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/105982#105982">Arnauld</a></td></tr>
<tr d-ix="24"><td>nan</td><td></td><td>161213T184218Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/103093#103093">ETHprodu</a></td></tr>
<tr d-ix="25"><td>nan</td><td></td><td>160924T192233Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/94424#94424">ETHprodu</a></td></tr>
<tr d-ix="26"><td>nan</td><td></td><td>161128T115448Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/101350#101350">edc65</a></td></tr>
<tr d-ix="27"><td>nan</td><td></td><td>161018T224014Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/96692#96692">ETHprodu</a></td></tr>
<tr d-ix="28"><td>nan</td><td></td><td>160128T024746Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/70342#70342">Conor O&</a></td></tr>
<tr d-ix="29"><td>nan</td><td></td><td>160816T015713Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/89992#89992">Scott</a></td></tr>
<tr d-ix="30"><td>nan</td><td></td><td>160530T222308Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/80967#80967">Cyoce</a></td></tr>
<tr d-ix="31"><td>nan</td><td></td><td>160110T033503Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/69046#69046">user8165</a></td></tr>
<tr d-ix="32"><td>nan</td><td></td><td>160128T015509Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/70340#70340">Mama Fun</a></td></tr>
<tr d-ix="33"><td>nan</td><td></td><td>150212T043530Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/45607#45607">Claudia</a></td></tr>
<tr d-ix="34"><td>nan</td><td></td><td>151022T213858Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/61505#61505">Mwr247</a></td></tr>
<tr d-ix="35"><td>nan</td><td></td><td>150731T163725Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/54133#54133">Downgoat</a></td></tr>
<tr d-ix="36"><td>nan</td><td></td><td>151101T030507Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/62486#62486">Mama Fun</a></td></tr>
<tr d-ix="37"><td>nan</td><td></td><td>150829T151826Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/55618#55618">jrich</a></td></tr>
<tr d-ix="38"><td>nan</td><td></td><td>150807T155426Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/54368#54368">Chiru</a></td></tr>
<tr d-ix="39"><td>nan</td><td></td><td>150625T115045Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/52204#52204">Downgoat</a></td></tr>
<tr d-ix="40"><td>nan</td><td></td><td>150511T045419Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/49967#49967">edc65</a></td></tr>
<tr d-ix="41"><td>nan</td><td></td><td>150212T041156Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/45606#45606">Claudia</a></td></tr>
<tr d-ix="42"><td>nan</td><td></td><td>140912T221713Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/37745#37745">Optimize</a></td></tr>
<tr d-ix="43"><td>005</td><td>Function expressions in ES6 use the arrow notation</td><td>140912T162845Z</td><td><a href="https://codegolf.stackexchange.com/questions/37624/tips-for-golfing-in-ecmascript-6-and-above/37720#37720">William </a></td></tr>
</table>
<div id="pu0" class="pu"><h2>Optimizing small constant ranges for <code>map()</code></h2>
<h3>Context</h3>
<p>Starting with ES6, it has become fairly common to use (and abuse) the <code>map()</code> method instead of a <code>for</code> loop to iterate over a range <span class="math-container">\$[0..N-1]\$</span>, so that the entire answer can be written in functional style:</p>
<pre class="lang-js prettyprint-override"><code>for(i = 0; i &lt; 10; i++) {
  do_something_with(i);
}
</code></pre>
<p>can be replaced by either:</p>
<pre class="lang-js prettyprint-override"><code>[...Array(10).keys()].map(i =&gt; do_something_with(i))
</code></pre>
<p>or more commonly:</p>
<pre class="lang-js prettyprint-override"><code>[...Array(10)].map((_, i) =&gt; do_something_with(i))
</code></pre>
<p>However, using <code>Array(N)</code> is rarely optimal when <span class="math-container">\$N\$</span> is a small constant.</p>
<h3>Optimizations for a range <span class="math-container">\$[0..N-1]\$</span>, with counter</h3>
<p>Below is a summary of shorter alternate methods when the counter <span class="math-container">\$i\$</span> is used within the callback:</p>
<pre><code>N           | Method                               | Example                         | Length
------------+--------------------------------------+---------------------------------+-------
N ≤ 6       | use a raw array of integers          | [0,1,2,3].map(i=&gt;F(i))          | 2N+10
N = 7       | use either a raw array of integers   | [0,1,2,3,4,5,6].map(i=&gt;F(i))    | 24
            | or a string if your code can operate | [...'0123456'].map(i=&gt;F(i))     | 23
            | with characters rather than integers |                                 |
8 ≤ N ≤ 9   | use scientific notation 1e[N-1]      | [...1e7+''].map((_,i)=&gt;F(i))    | 24
N = 10      | use scientific notation 1e9          | [...1e9+''].map((_,i)=&gt;F(i))    | 24
            | or the ES7 expression 2**29+'4' if   | [...2**29+'4'].map(i=&gt;F(i))     | 23
            | the order doesn't matter and your    |                                 |
            | code can operate with characters     |  (order: 5,3,6,8,7,0,9,1,2,4)   |
            | rather than integers                 |                                 |
11 ≤ N ≤ 17 | use scientific notation 1e[N-1]      | [...1e12+''].map((_,i)=&gt;F(i))   | 25
N = 18      | use the fraction 1/3                 | [...1/3+''].map((_,i)=&gt;F(i))    | 24
N = 19      | use the fraction 1/6                 | [...1/6+''].map((_,i)=&gt;F(i))    | 24
20 ≤ N ≤ 21 | use scientific notation 1e[N-1]      | [...1e20+''].map((_,i)=&gt;F(i))   | 25
N = 22      | use scientific notation -1e20        | [...-1e20+''].map((_,i)=&gt;F(i))  | 26
23 ≤ N ≤ 99 | use Array(N)                         | [...Array(23)].map((_,i)=&gt;F(i)) | 27
</code></pre>
<p><sup><strong>NB</strong>: The length of the callback code <code>F(i)</code> is not counted.</sup></p>
<h3>Optimization for the range <span class="math-container">\$[1..9]\$</span>, with counter</h3>
<p>If you'd like to iterate over the range <span class="math-container">\$[1..9]\$</span> and the order doesn't matter, you can use the following ES7 expression (provided that your code can operate with characters rather than integers):</p>
<pre><code>[...17**6+'8'].map(i=&gt;F(i))  // order: 2,4,1,3,7,5,6,9,8; length: 23
</code></pre>
<h3>Optimizations without counter</h3>
<p>The following methods can be used if you just need to iterate <span class="math-container">\$N\$</span> times, without using a counter:</p>
<pre><code>N           | Method                               | Example                         | Length
------------+--------------------------------------+---------------------------------+-------
N ≤ 5       | use a raw array of integers          | [0,0,0,0].map(_=&gt;F())           | 2N+10
6 ≤ N ≤ 10  | use scientific notation 1e[N-1]      | [...1e7+''].map(_=&gt;F())         | 20
11 ≤ N ≤ 14 | use scientific notation 1e[N-1]      | [...1e12+''].map(_=&gt;F())        | 21
N = 15      | use {}                               | [...''+{}].map(_=&gt;F())          | 19
16 ≤ N ≤ 18 | use number+{}                        | [...1+{}].map(_=&gt;F())           | N+2
N = 18      | use the fraction 1/3                 | [...1/3+''].map(_=&gt;F())         | 20
N = 19      | use the fraction 1/6                 | [...1/6+''].map(_=&gt;F())         | 20
19 ≤ N ≤ 24 | use scientific notation 1e[N-16]+{}  | [...1e4+{}].map(_=&gt;F())         | 20
25 ≤ N ≤ 29 | use scientific notation 1e[N-16]+{}  | [...1e10+{}].map(_=&gt;F())        | 21
N = 30      | use {}+{}                            | [...{}+{}].map(_=&gt;F())          | 19
31 ≤ N ≤ 36 | use scientific notation 1e[N-16]+{}  | [...1e15+{}].map(_=&gt;F())        | 21
N = 37      | use scientific notation -1e20        | [...-1e20+{}].map(_=&gt;F())       | 22
38 ≤ N ≤ 44 | use Array(N)                         | [...Array(38)].map(_=&gt;F())      | 23
N = 45      | use {}+{}+{}                         | [...{}+{}+{}].map(_=&gt;F())       | 22
46 ≤ N ≤ 99 | use Array(N)                         | [...Array(46)].map(_=&gt;F())      | 23
</code></pre>
<p><sup><strong>NB</strong>: The length of the callback code <code>F()</code> is not counted.</sup></p>
</div>
<div id="pu1" class="pu"><h1>Abuse third argument to setInterval for assignment</h1>
<p>In the browser you can pass a string instead of a function to <code>setInterval</code>, in which case this isn't shorter, but in Node/Deno that errors, so you should try to abuse this trick.</p>
<p>If you have code like e.g. <code>(M=Math).sin(M.PI)</code> (made up example) where you have that assignment in parentheses, you can shorten it by making <code>M</code> the argument to the arrow function <code>M=&gt;{...}</code> and passing <code>Math</code> as the third argument to <code>setInterval</code>.</p>
<p>This trick saves 2 bytes:</p>
<pre class="lang-javascript prettyprint-override"><code>// before
setInterval(_=&gt;{(c=console).clear();c.log(&quot;Hello, world!&quot;)},50)
// after, 2 bytes shorter
setInterval(c=&gt;{c.clear();c.log(&quot;Hello, world!&quot;)},50,console)
</code></pre>
</div>
<div id="pu2" class="pu"><h1>Convert BigInt back to Number</h1>
<p>(Chrome 67+ / Node.js 10.4+)</p>
<p>BigInt makes arbitrary-precision integer arithmetic more handy in JS, but there is a caveat - most already existing functions that accepts Number, does not accept BigInt. <strong>UPDATE: array indexer DOES support BigInt for some reason.</strong></p>
<p>When we need to convert a BigInt back to Number for some reason, we cannot use <code>+n</code> (<strong><a href="https://developers.google.com/web/updates/2018/05/bigint#operators" rel="nofollow noreferrer">this is explicitly forbidden in the specs</a></strong>), but instead we need to use <code>Number(n)</code> -- except we do not really need to do so.</p>
<p>Instead of using <code>Number(n)</code>, we realise that we can actually convert the BigInt first into a String and then to a Number using <code>+`${n}` </code>, which saves 2 bytes.</p>
<p>But we can do better: wrap the BigInt with an array then directly cast it using <code>+</code> operator. This gives <code>+[n]</code> which saves 3 more bytes. Most importantly this <strong>eliminates the use of <code>Number(n)</code> or even <code>(N=Number)(n)</code> and further <code>N(n)</code>s for multiple uses because <code>+[n]</code> has the same length as <code>N(n)</code>.</strong></p>
<p>You can test this out with this example:</p>

<pre class="lang-javascript prettyprint-override"><code>s=163n;
console.log(Number(s)) // 9 bytes
console.log(+`${s}`)   // 7 bytes
console.log(+[s])      // 4 bytes
</code></pre>
<p><a href="https://tio.run/##y0osSyxOLsosKNHNy09J/f@/2NbQzDjPmis5P684PydVLyc/XcOvNDcptUijWFNTQV9fwVIhqbIktRhFhXaCSnVxbYKmggJIhTk2FdHFsSBpiAoTiIr//wE" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
</div>
<div id="pu3" class="pu"><h1>Shortening getting last element of <code>string</code>/<code>array</code></h1>
<p>Instead of</p>
<pre><code>x[x.length-1] - 13 bytes
(l=x.length)...x[l-1] - (n + 18) bytes
</code></pre>
<p>use</p>
<pre><code>x.at(-1) - 8 bytes
x.length...x.at(-1) - (n + 16) bytes
</code></pre>
<h1>Shortening getting last element of <code>array</code> with mutating</h1>
<p>Instead of</p>
<pre><code>x[x.length-1] - 13 bytes
x.at(-1) - 8 bytes
</code></pre>
<p>use</p>
<pre><code>x.pop() - 7 bytes
</code></pre>
</div>
<div id="pu4" class="pu"><h2>Bind operator <code>::</code> (deprecated and unusable in more recent versions of JS)</h2>
<p>The bind operator can be used to help shorten bytes over repeated functions:</p>
<pre><code>(x='abc'.search(a))+x.search(b) // Before
(x=::'abc'.search)(a)+x(b)      // 5 bytes saved
</code></pre>
<p>Additionally if you want to use the function with a different <code>this</code> e.g.:</p>
<pre><code>s[r='replace'](/a/g,'b')+s[r](/c/g,'d') // Before
(r=s.replace)(/a/g,'b')+s::r(/c/g,'d')  // 1 byte saved
</code></pre>
</div>
<div id="pu5" class="pu"><h2>ES6 functions</h2>
<h3>Math</h3>
<p><code>Math.cbrt(x)</code> saves characters than <code>Math.pow(x,1/3)</code>, however this is obsolete when using <code>x**1/3</code>.</p>
<pre><code>Math.cbrt(x)
Math.pow(x,1/3)
</code></pre>
<p>3 chars saved</p>
<p><code>Math.hypot(...args)</code> is useful when you need the square root of the sum of the squares of the args. Making ES6 code to do that is generally much longer than using a built-in, although it can differ depending on your output format.</p>
<p>The function <code>Math.trunc(x)</code> wouldn't be helpful, as <code>x|0</code> is shorter. (Thanks Mwr247!)</p>
<p>There are many properties that take lots of code to do in ES5, but easier in ES6:</p>
<ul>
<li><code>Math.acosh</code>, <code>asinh</code>, <code>atanh</code>, <code>cosh</code>, <code>sinh</code>, <code>tanh</code>. Calculates the hyperbolic equivalent of trigonometric functions, but are almost never used, <a href="https://codegolf.stackexchange.com/questions/223166/implement-ashs-float-division/223169#223169">except very occasionally</a>.</li>
<li><code>Math.clz32</code>. Might be possible to do in ES5, but is easier now. Counts leading zeros in the 32-bit representation of a number.</li>
</ul>
<p>There are a lot more, so I'm just going to list some:<br />
<code>Math.sign</code> (occasionally useful), <code>Math.fround</code> (useless), <code>Math.imul</code> (useless), <code>Math.log10</code> (sometimes shorter than length), <code>Math.log2</code> (very useful), <code>Math.log1p</code> (almost completely useless).</p>
</div>
<div id="pu6" class="pu"><h1>Abuse BigInt comparison</h1>
<p>Sometimes, you need to use BigInts to support arbitrary integers. These don't usually combine well with regular numbers, so you sometimes need to use BigInt literals like <code>5n</code>. But did you know that you can compare BigInts with regular numbers normally?</p>
<p>If you want to know whether a BigInt is e.g. greater than 100, you can use <code>n&gt;100</code> instead of <code>n&gt;100n</code>, for example.</p>
<p>An example of this is in <a href="https://codegolf.stackexchange.com/questions/243463/convert-to-utf-%e2%88%9e#comment548076_243473">this golf</a> to <a href="https://codegolf.stackexchange.com/a/243473/100664">this answer</a> where comparison to 63 is used to save a byte.</p>
</div>
<div id="pu7" class="pu"><h1>Init with <code>fill</code> in <code>map</code> loop for range</h1>
<p>Title may be hard to read.</p>
<p>Instead of</p>
<pre><code>[...Array(n)].map((_,x)=&gt;(y=0,...))
</code></pre>
<p>, write</p>
<pre><code>Array(n).fill(0).map((y,x)=&gt;...)
</code></pre>
</div>
<div id="pu8" class="pu"><h2>Using <code>flat()</code> when building an array recursively (ES10)</h2>
<p>When elements are appended conditionally to an array with recursive calls, a typical construction is:</p>

<pre class="lang-javascript prettyprint-override"><code>f=k=&gt;k?[...k%3?[k]:[],...f(k-1)]:[] // 35 bytes
</code></pre>
<p><a href="https://tio.run/##y0osSyxOLsosKNHNy09J/f8/zTbb1i7bPlpPTy9b1dg@OjvWKjpWB8hL08jWNdQE8f4n5@cV5@ek6uXkp2ukaRgaaGr@BwA" rel="noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<p>(this example code filters out values that are multiple of 3)</p>
<p>Notice that the spread operators is used twice (costing 6 bytes) and the payload value <code>k</code> has to be put within a singleton array (costing 2 more bytes).</p>
<p>An alternate approach is to apply <code>.flat()</code> immediately after each iteration, saving a byte:</p>
<pre class="lang-javascript prettyprint-override"><code>f=k=&gt;k?[k%3?k:[],f(k-1)].flat():[]  // 34 bytes
</code></pre>
<p><a href="https://tio.run/##y0osSyxOLsosKNHNy09J/f8/zTbb1i7bPjpb1dg@2yo6VidNI1vXUDNWLy0nsURDEyjyPzk/rzg/J1UvJz9dI03D0EBT8z8A" rel="noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
</div>
<div id="pu9" class="pu"><h2>Default parameters for variable initialization</h2>

<p>Suppose you have some long duplicated subexpressions in a lambda:</p>

<pre><code>d.map((x,i)=&gt;[c[i]*c[i+1],c[i]*c[i+1]*x])
</code></pre>

<p>Unfortunately, you <em>cannot</em> just do <code>d.map((x,i)=&gt;e=c[i]*c[i+1],[e,e*x])</code> because apparently <code>e</code> is not available in the scope of the second operand of the comma operator.</p>

<p>But you can "initialize" a variable in a default parameter declaration:</p>

<pre><code>d.map((x,i,_,e=c[i]*c[i+1])=&gt;[e,e*x])
</code></pre>

<p>You have to do it at an <em>unused</em> parameter position. Above, the function passed to <code>map</code> only ever gets invoked with three parameters and hence we can exploit the fourth parameter for our purposes.</p>
</div>
<div id="pu10" class="pu"><h1><code>Array.prototype.find</code> in array traversing</h1>
<p>When traversing an array with <code>Array.prototype.map</code>, all elements are processed. However, when only the first truthy invocation is needed, flags are needed to stop subsequent elements from being processed. When processed with a recursion, more flags may be needed.</p>
<p>However, with <code>Array.prototype.find</code>, flags can be saved. <code>Array.prototype.find</code> receives a function with the same signature as <code>Array.prototype.map</code> does, and returns the first element that the function returns true for that element, or <code>undefined</code> if none returns true.</p>
<p>Consider an example of finding the first non-zero value from a numeric array:</p>

<pre class="lang-javascript prettyprint-override"><code>// For-loop
A=&gt;{for(i of A)if(i)return i}
// Array.prototype.map
A=&gt;A.map(x=&gt;i=i||x,i=0)&amp;&amp;i   // -3
// Array.prototype.filter
A=&gt;A.filter(x=&gt;x)[0]         // -9
// Array.prototype.find
A=&gt;A.find(x=&gt;x)              // -14
</code></pre>
<p>Real case - <a href="https://codegolf.stackexchange.com/a/198979/71546">determine whether a numeric matrix has all non-zero values connected</a>. The function is written in the way that can be invoked by both <code>map</code> and recursion:</p>

<pre class="lang-javascript prettyprint-override"><code>// Uses map: 115 bytes
A=&gt;w=&gt;A.map(x=F=(u,i,a)=&gt;u&amp;&amp;(x||!a)&amp;&amp;[-w,-1,1,w].map(v=&gt;v*v&gt;1|i%w+v&gt;=0&amp;i%w+v&lt;w&amp;&amp;F(A[v+=i],v),x=A[i]=0))&amp;&amp;!+A.join``
// Uses find: 102 bytes
A=&gt;w=&gt;(A.find(F=(u,i)=&gt;u&amp;&amp;[-w,-1,1,w].map(v=&gt;v*v&gt;1|i%w+v&gt;=0&amp;i%w+v&lt;w&amp;&amp;F(A[v+=i],v),A[i]=0)),!+A.join``)
</code></pre>
<p>In the case above, we need to only rewrite one region, so we must use flags to avoid further invocation of <code>F</code> by <code>map</code>, but in the meantime we need to also let the recursion run, so another flag is used to indicate whether the invocation is by <code>map</code> or by recursion. With <code>find</code>, both flags are now unnecessary. However, be careful with the return value of the function. In this case, when <code>u</code> is zero then zero is returned, and otherwise an array is returned, which is truthy.</p>
</div>
<div id="pu11" class="pu"><h1>Array Comprehensions (Firefox 30-57)</h1>

<p><strong>Note: array comprehensions were never standardized, and were made obsolete with Firefox 58. Use at your own peril.</strong></p>

<hr>



<p>Originally, the ECMAScript 7 spec contained a bunch of new array-based features. Though most of these didn't make it into the finalized version, Firefox support(ed) possibly the biggest of these features: fancy new syntax that can replace <code>.filter</code> and <code>.map</code> with <code>for(a of b)</code> syntax. Here's an example:</p>

<pre class="lang-js prettyprint-override"><code>b.filter(a=&gt;/\s/.test(a)).map(a=&gt;a.length)
[for(a of b)if(/\s/.test(a))a.length]
</code></pre>

<p>As you can see, the two lines are not all that different, other than the second not containing the bulky keywords and arrow functions. But this only accounts for the order<code>.filter().map()</code>; what happens if you have <code>.map().filter()</code> instead? It really depends on the situation:</p>

<pre class="lang-js prettyprint-override"><code>b.map(a=&gt;a[0]).filter(a=&gt;a&lt;'['&amp;&amp;a&gt;'@')
[for(a of b)if(a&lt;'['&amp;&amp;a&gt;'@')a[0]]

b.map(a=&gt;c.indexOf(a)).filter(a=&gt;a&gt;-1)
[for(a of b)if((d=c.indexOf(a))&gt;-1)d]

b.map(a=&gt;a.toString(2)).filter(a=&gt;/01/.test(a))
[for(a of b)if(/01/.test(c=a.toString(2)))c]
</code></pre>

<p>Or what if you want <em>either</em> <code>.map</code> <em>or</em> <code>.filter</code>? Well, it usually turns out less OK:</p>

<pre class="lang-js prettyprint-override"><code>b.map(a=&gt;a.toString(2))
[for(a of b)a.toString(2)]

b.filter(a=&gt;a%3&amp;&amp;a%5)
[for(a of b)if(a%3&amp;&amp;a%5)a]
</code></pre>

<p>So my advice is to use array comprehensions wherever you would usually use <code>.map</code> <em>and</em> <code>.filter</code>, but not just one or the other.</p>

<h2>String Comprehensions</h2>

<p>A nice thing about ES7 comprehensions is that, unlike array-specific functions such as <code>.map</code> and <code>.filter</code>, they can be used on <em>any</em> iterable object, not just arrays. This is especially useful when dealing with strings. For example, if you want to run each character <code>c</code> in a string through <code>c.charCodeAt()</code>:</p>

<pre class="lang-js prettyprint-override"><code>x=&gt;[...x].map(c=&gt;c.charCodeAt())
x=&gt;[for(c of x)c.charCodeAt()]
</code></pre>

<p>That's two bytes saved on a fairly small scale. And what if you want to filter certain characters in a string? For example, this one keeps only capital letters:</p>

<pre class="lang-js prettyprint-override"><code>x=&gt;[...x].filter(c=&gt;c&lt;'['&amp;&amp;c&gt;'@')
x=&gt;[for(c of x)if(c&lt;'['&amp;&amp;c&gt;'@')c]
</code></pre>

<p>Hmm, that's not any shorter. But if we combine the two:</p>

<pre class="lang-js prettyprint-override"><code>x=&gt;[...x].filter(c=&gt;c&lt;'['&amp;&amp;c&gt;'@').map(c=&gt;c.charCodeAt())
x=&gt;[for(c of x)if(c&lt;'['&amp;&amp;c&gt;'@')c.charCodeAt()]
</code></pre>

<p>Wow, a whole 10 bytes saved!</p>

<p>Another advantage of string comprehensions is that hardcoded strings save an extra byte, since you can omit the space after <code>of</code>:</p>

<pre class="lang-js prettyprint-override"><code>x=&gt;[...'[](){}&lt;&gt;'].map(c=&gt;x.split(c).length-1)
x=&gt;[for(c of'[](){}&lt;&gt;')x.split(c).length-1]

x=&gt;[...'[](){}&lt;&gt;'].filter(c=&gt;x.split(c).length&gt;3)
x=&gt;[for(c of'[](){}&lt;&gt;')if(x.split(c).length&gt;3)c]
</code></pre>

<h2>Indexing</h2>

<p>Array comprehensions make it a little harder to get the current index in the string/array, but it can be done:</p>

<pre class="lang-js prettyprint-override"><code>a.map((x,i)=&gt;x+i).filter ((x,i)=&gt;~i%2)
[for(x of(i=0,a))if(++i%2)x+i-1]
</code></pre>

<p>The main thing to be careful of is to make sure the index gets incremented <em>every</em> time, not just when a condition is met.</p>

<h2>Generator comprehensions</h2>

<p>Generator comprehensions have basically the same syntax as array comprehensions; just replace the brackets with parentheses:</p>

<pre class="lang-js prettyprint-override"><code>x=&gt;(for(c of x)if(c&lt;'['&amp;&amp;c&gt;'@')c.charCodeAt())
</code></pre>

<p>This creates a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators" rel="nofollow noreferrer">generator</a> which functions in much the same way as an array, but that's a story for another answer.</p>

<h2>Summary</h2>

<p>Basically, although comprehensions are usually shorter than <code>.map().filter()</code>, it all comes down to the specifics of the situation. It's best to try it both ways and see which works out better.</p>

<p>P.S. Feel free to suggest another comprehension-related tip or a way to improve this answer!</p>
</div>
<div id="pu12" class="pu"><p><strong>Spread operator <code>...</code></strong></p>

<p>The spread operator transforms an array value into a comma separated list.</p>

<p>Use case 1:</p>

<p>Directly use an array where a function expects a list</p>

<pre><code>list=[1,2,3]
x=Math.min(...list)
list=[10,20], a.push(...list) // similar to concat()
</code></pre>

<p>Use case 2:</p>

<p>Create an array literal from an iterable (typically a string)</p>

<pre><code>[...'buzzfizz'] // -&gt; same as .split('')
</code></pre>

<p>Use case 3:</p>

<p>Declare a variable number of arguments for a function</p>

<pre><code>F=(...x) =&gt; x.map(v =&gt; v+1)
// example: F(1,2,3) == [2,3,4]
</code></pre>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator" rel="noreferrer">See mozilla doc</a></p>
</div>
<div id="pu13" class="pu"><h2>Writing RegEx literals with <code>eval</code></h2>

<p>The regex constructor can be very bulky due to it's long name. Instead, write a literal with eval and backticks:</p>

<pre><code>eval(`/&lt;${i} [^&gt;]+/g`)
</code></pre>

<p>If the variable <code>i</code> is equal to <code>foo</code>, this will generate:</p>

<pre><code>/&lt;foo [^&gt;]+/g
</code></pre>

<p>This is equal to:</p>

<pre><code>new RegExp("&lt;"+i+" [^&gt;]+","g")
</code></pre>

<hr>

<p>You can also use <code>String.raw</code> to avoid having to repeatedly escape backslashes <code>\</code></p>

<pre><code>eval(String.raw`/\(?:\d{4})?\d{3}\d{3}\d{3}\d{3}\d{3}\d{3}\d{4}/g`)
</code></pre>

<p>This will output:</p>

<pre><code>/(?:\d{4})?\d{3}\d{3}\d{3}/g
</code></pre>

<p>Which is equal to:</p>

<pre><code>RegExp("\\(?:\\d{4})?\\d{3}\\d{3}\\d{3}\\d{3}\\d{3}\\d{3}\\d{4}","g")
</code></pre>

<h1>Keep in mind!</h1>

<p><code>String.raw</code> takes up a lot of bytes and unless you have at <em>least</em> nine backslashes, <code>String.raw</code> will be longer.</p>
</div>
<div id="pu14" class="pu"><h1>Shortening Promise Chains with <code>async</code>/<code>await</code></h1>

<p>Taken from my answer <a href="https://codegolf.stackexchange.com/a/172081/57013">here</a>.</p>

<p>Sometimes you can shorten longer promise chains with <code>async</code>/<code>await</code>.  The main benefit is from getting rid of the beginning of the arrow function in each <code>then</code> callback.  <code>.then(x=&gt;x</code> (10) gets replaced with <code>await(</code> (-4), but you first pay with <code>async</code> (+6).  So to make up for the initial overhead of 6 bytes, you'd need at least two <code>then</code> chains to get any benefit.</p>

<pre><code>+-------------+----------------+
| then chains | async overhead |
+-------------+----------------+
| 0           | +6             |
| 1           | +2             |
| 2           | -2             |
| 3           | -4             |
| …           | …              |
+-------------+----------------+
</code></pre>

<h2>Example 1</h2>

<pre><code>x=&gt;x().then(y=&gt;y.foo()).then(z=&gt;z.bar())
async x=&gt;await(await(x()).foo()).bar()
</code></pre>

<h2>Example 2</h2>

<pre><code>u=&gt;fetch(u).then(r=&gt;r.text()).then(t=&gt;/\0/.test(t))
async u=&gt;/\0/.test(await(await fetch(u)).text()))
</code></pre>
</div>
<div id="pu15" class="pu"><h1>Use <code>**</code> (ES7)</h1>

<p><code>**</code> is the new exponentiation operator. Occasionally useful.</p>

<pre><code>Math.pow(2,2) // size: 13, result: 4 
2**2          // size:  4, result: 4
</code></pre>
</div>
<div id="pu16" class="pu"><h2>Using <code>.padEnd()</code> instead of <code>.repeat()</code> (ES8)</h2>
<p>Under certain circumstances, using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd" rel="noreferrer"><code>.padEnd()</code></a> instead of <code>.repeat()</code> saves bytes.</p>
<p>We can take advantage of the following properties:</p>
<ul>
<li>the default padding string is a single space</li>
<li>when provided, the second parameter is implicitly coerced to a string</li>
</ul>
<h3>Repeating spaces</h3>
<p>With <code>.repeat()</code>:</p>

<pre class="lang-js prettyprint-override"><code>' '.repeat(10)
</code></pre>
<p>Using <code>.padEnd()</code> saves <strong>1 byte</strong>:</p>
<pre class="lang-js prettyprint-override"><code>''.padEnd(10)
</code></pre>
<p><a href="https://tio.run/##y0osSyxOLsosKNHNy09J/Z@mYKsQr2Br919dXa8gMcU1L0XD0EDzf3J@XnF@TqpeTn66hrqHq4@Pv7qCtkKahqaCtnq4f5CPi7rmfwA" rel="noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<h3>Repeating a dynamic value that needs to be coerced to a string</h3>
<p>With <code>.repeat()</code>:</p>

<pre class="lang-js prettyprint-override"><code>x=1;
(x+'').repeat(10)
</code></pre>
<p>Using <code>.padEnd()</code> saves <strong>2 bytes</strong>:</p>
<pre class="lang-js prettyprint-override"><code>x=1;
''.padEnd(10,x)
</code></pre>
<p><a href="https://tio.run/##BcFLCoAgEADQq8xuFEtyr@46iPiJQhzJCG8/vveEP4z43v3bG6XMBRxMcJ4RdQ/pbEmYY5uSI7VBNetKl0DvERQUYSQotBYlLw" rel="noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
</div>
<div id="pu17" class="pu"><h1>Splitting Strings</h1>
<p>Surprised this hasn't been posted already (or maybe I missed it).</p>
<p>If you have an array of 5 or more strings, you can save bytes by instead <code>split</code>ting a string containing all the elements.</p>

<pre class="lang-js prettyprint-override"><code>[&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;]
&quot;one,two,three,four&quot;.split`,` // 1 byte longer
</code></pre>

<pre class="lang-js prettyprint-override"><code>[&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;]
&quot;one,two,three,four,five&quot;.split`,` // 1 byte shorter
</code></pre>

<pre class="lang-js prettyprint-override"><code>[&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;]
&quot;one,two,three,four,five,six&quot;.split`,` // 3 bytes shorter
</code></pre>
<p>For each additional string in your array, you'll save a further 2 bytes with this approach.</p>
<p>If any of your strings contain a comma then change the delimiter to a differet character.</p>
</div>
<div id="pu18" class="pu"><h1>Avoiding commas when storing lots of data</h1>

<p>If you have a lot of data (i. e. indices, characters, …) that you need to store in an array, you might be better off leaving all commas away. This works best if every piece of data has the same string length, 1 obviously being optimal.</p>

<p><strong>43 Bytes (baseline)</strong></p>

<pre class="lang-js prettyprint-override"><code>a=[[3,7,6,1,8,9,4,5,2],[5,4,3,2,7,6,5,4,3]]
</code></pre>

<p><strong>34 Bytes (no commas)</strong></p>

<pre class="lang-js prettyprint-override"><code>a=[[..."376189452"],[..."543276543"]]
</code></pre>

<p>If you're willing to <em>change your array access</em>, you might reduce this even further, storing the same values like so:</p>

<p><strong>27 Bytes (same data, only changes array access)</strong></p>

<pre class="lang-js prettyprint-override"><code>a=[..."376189452543276543"]
</code></pre>
</div>
<div id="pu19" class="pu"><h2>Shorten repeated function calls</h2>

<p>If you have repeated calls to a function with a long-ish name, such as canvas manipulation:</p>

<pre><code>c.lineTo(0,100);c.lineTo(100,100);c.lineTo(100,0);c.lineto(0,0);c.stroke()
</code></pre>

<p>The traditional way to shorten it would be to alias the function name:</p>

<pre><code>c[l='lineTo'](0,100);c[l](100,100);c[l](100,0);c[l](0,0);c.stroke()
</code></pre>

<p>If you have enough calls, a better way is to create a function that does the job for you:</p>

<pre><code>l=(x,y)=&gt;c.lineTo(x,y);l(0,100);l(100,100);l(100,0);l(0,0);c.stroke()
</code></pre>

<p>If most of the function calls are chained, you can make the function return itself, allowing you to cut two bytes off of each successive call:</p>

<pre><code>l=(x,y)=&gt;c.lineTo(x,y)||l;l(0,100)(100,100)(100,0)(0,0);c.stroke()
</code></pre>

<p>Example usage: <a href="https://codegolf.stackexchange.com/a/110039/42545">1</a>, <a href="https://codegolf.stackexchange.com/a/100349/42545">2</a></p>
</div>
<div id="pu20" class="pu"><h2>Random template-string hacks</h2>

<p>This function riffles two strings (i.e. turns <code>"abc","de"</code> into <code>"adbec"</code>):</p>

<pre><code>f=(x,y)=&gt;String.raw({raw:x},...y)
</code></pre>

<p>Note that this only works when <code>x</code> is longer than <code>y</code>. How does it work, you ask? <code>String.raw</code> is designed to be a template tag, like so:</p>

<pre><code>String.raw`x: ${x}\ny: ${y}\nx + y: ${x + y}`
</code></pre>

<p>This basically calls <code>String.raw(["x: ", "\ny: ", "\nx + y: ", ""], x, y, x + y)</code>, though it's not that simple. The template array also has a special <code>raw</code> property, which is basically a copy of the array, but with the raw strings. <code>String.raw(x, ...args)</code> basically returns <code>x.raw[0] + args[0] + x.raw[1] + args[1] + x.raw[2] + ...</code> and so on until <code>x</code> runs out of items.</p>

<p>So now that we know how <code>String.raw</code> works, we can use it to our advantage:</p>

<pre><code>f=(x,y)=&gt;String.raw({raw:x},...y)                   // f("abc", "de") =&gt; "adbec"
f=x=&gt;String.raw({raw:x},...[...x].keys())           // f("abc") =&gt; "a0b1c"
f=(x,y)=&gt;String.raw({raw:x},...[...x].fill(y))      // f("abc", " ") =&gt; "a b c"
</code></pre>

<p>Of course, for that last one, <code>f=(x,y)=&gt;x.split``.join(y)</code> is way shorter, but you get the idea.</p>

<p>Here are a couple of riffling functions that also work if <code>x</code> and <code>y</code> are of equal length:</p>

<pre><code>f=(x,y)=&gt;String.raw({raw:x.match(/.?/g)},...y)
f=(x,y)=&gt;String.raw({raw:x},...y)+y.slice(-1)  // Only works if x.length == y.length
</code></pre>

<p>You can learn more about <code>String.raw</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals" rel="noreferrer">on MDN</a>.</p>
</div>
<div id="pu21" class="pu"><h2>Primality-testing function</h2>

<p>The following 28-byte function returns <code>true</code> for prime numbers and <code>false</code> for non-primes:</p>

<pre><code>f=(n,x=n)=&gt;n%--x?f(n,x):x==1
</code></pre>

<p>This can easily be modified to calculate other things. For example, this 39-byte function counts the number of primes less than or equal to a number:</p>

<pre><code>f=(n,x=n)=&gt;n?n%--x?f(n,x):!--x+f(n-1):0
</code></pre>

<p>If you already have a variable <code>n</code> that you want to check for primality, the primality function can be simplified quite a bit:</p>

<pre><code>(f=x=&gt;n%--x?f(x):x==1)(n)
</code></pre>

<h3>How it works</h3>

<pre><code>f = (         // Define a function f with these arguments:
  n,          //   n, the number to test;
  x = n       //   x, with a default value of n, the number to check for divisibility by.
) =&gt;
  n % --x ?   //   If n is not divisible by x - 1,
  f(n, x)     //     return the result of f(n, x - 1).
              //   This loops down through all numbers between n and 0,
              //     stopping when it finds a number that divides n.
  : x == 1    //   Return x == 1; for primes only, 1 is the smallest number
              //     less than n that divides n.
              //   For 1, x == 0; for 0, x == -1.
</code></pre>

<p>Note: This will fail with a "too much recursion" error when called with a sufficiently large input, such as 12345. You can get around this with a loop:</p>

<pre><code>f=n=&gt;eval('for(x=n;n%--x;);x==1')
</code></pre>
</div>
<div id="pu22" class="pu"><h2>Using the currying syntax for dyadic and recursive functions</h2>
<h3>Dyadic functions</h3>
<p>Whenever a function takes exactly two arguments with no default values, using the currying syntax saves one byte.</p>
<p><strong>Before</strong></p>
<pre class="lang-js prettyprint-override"><code>f =
(a,b)=&gt;a+b  // 10 bytes
</code></pre>
<p>Called with <code>f(a,b)</code></p>
<p><strong>After</strong></p>
<pre class="lang-js prettyprint-override"><code>f =
a=&gt;b=&gt;a+b   // 9 bytes
</code></pre>
<p>Called with <code>f(a)(b)</code></p>
<p><em>Note</em>: <a href="http://meta.codegolf.stackexchange.com/questions/8424/is-this-an-acceptable-way-to-shave-a-byte-in-es6">This post in Meta</a> confirms the validity of this syntax.</p>
<h3>Recursive functions</h3>
<p>Using the currying syntax may also save some bytes when a recursive function takes several arguments but only needs to update some of them between each iteration.</p>
<p><strong>Example</strong></p>
<p>The following function computes the sum of all integers in the range <code>[a,b]</code>:</p>
<pre class="lang-js prettyprint-override"><code>f=(a,b)=&gt;a&gt;b?0:b+f(a,b-1)   // 25 bytes
</code></pre>
<p>Because <code>a</code> remains unchanged during the whole process, we can save 3 bytes by using:</p>
<pre class="lang-js prettyprint-override"><code>f =                         // no need to include this assignment in the answer anymore
a=&gt;F=b=&gt;a&gt;b?0:b+F(b-1)      // 22 bytes
</code></pre>
<p><em>Note</em>: As noticed by Neil in the comments, the fact that an argument is not explicitly passed to the recursive function does not mean that it should be considered immutable. If needed, we could modify <code>a</code> within the function code with <code>a++</code>, <code>a--</code> or whatever similar syntax.</p>
</div>
<div id="pu23" class="pu"><h2>Using uninitialized counters in recursion</h2>
<p><em><strong>Note</strong>: Strictly speaking, this is not specific to ES6. It makes more sense to use and abuse recursion in ES6, however, because of the concise nature of arrow functions.</em></p>
<hr />
<p>It is rather common to come across a recursive function that's using a counter <code>k</code> initially set to zero and incremented at each iteration:</p>
<pre><code>f = (…, k=0) =&gt; [do a recursive call with f(…, k+1)]
</code></pre>
<p>Under certain circumstances, it's possible to omit the initialization
of such a counter and replace <code>k+1</code> with <code>-~k</code>:</p>
<pre><code>f = (…, k) =&gt; [do a recursive call with f(…, -~k)]
</code></pre>
<p>This trick typically <strong>saves 2 bytes</strong>.</p>
<h3>Why and when does it work?</h3>
<p>The formula that makes it possible is <code>~undefined === -1</code>. So, on the first iteration, <code>-~k</code> will be evaluated to <code>1</code>. On the next iterations, <code>-~k</code> is essentially equivalent to <code>-(-k-1)</code> which equals <code>k+1</code>, at least for integers in the range [0 … 2<sup>31</sup>-1].</p>
<p>You must however make sure that having <code>k = undefined</code> on the first iteration will not disrupt the behavior of the function. You should especially keep in mind that most arithmetic operations involving <code>undefined</code> will result in <code>NaN</code>.</p>
<h3>Example #1</h3>
<p>Given a positive integer <code>n</code>, this function looks for the smallest integer <code>k</code> that doesn't divide <code>n</code>:</p>
<pre class="lang-js prettyprint-override"><code>f=(n,k=0)=&gt;n%k?k:f(n,k+1)   // 25 bytes
</code></pre>
<p>It can be shortened to:</p>
<pre class="lang-js prettyprint-override"><code>f=(n,k)=&gt;n%k?k:f(n,-~k)     // 23 bytes
</code></pre>
<p>This works because <code>n % undefined</code> is <code>NaN</code>, which is falsy. That's the expected result on the first iteration.</p>
<p><a href="https://codegolf.stackexchange.com/a/105432/58563">[Link to original answer]</a></p>
<h3>Example #2</h3>
<p>Given a positive integer <code>n</code>, this function looks for an integer <code>p</code> such that <code>(3**p) - 1 == n</code>:</p>
<pre class="lang-js prettyprint-override"><code>f=(n,p=0,k=1)=&gt;n&lt;k?n&gt;k-2&amp;&amp;p:f(n,p+1,k*3)  // 40 bytes
</code></pre>
<p>It can be shortened to:</p>
<pre class="lang-js prettyprint-override"><code>f=(n,p,k=1)=&gt;n&lt;k?n&gt;k-2&amp;&amp;p:f(n,-~p,k*3)    // 38 bytes
</code></pre>
<p>This works because <code>p</code> is not used at all on the first iteration (<code>n&lt;k</code> being false).</p>
<p><a href="https://codegolf.stackexchange.com/a/105923/58563">[Link to original answer]</a></p>
</div>
<div id="pu24" class="pu"><h2>Shorter ways to do <code>.replace</code></h2>

<hr>



<p>If you want to replace all instances of one exact substring with another in a string, the obvious way would be:</p>

<pre class="lang-js prettyprint-override"><code>f=s=&gt;s.replace(/l/g,"y") // 24 bytes
f("Hello, World!")       // -&gt; "Heyyo, Woryd!"
</code></pre>

<p>However, you can do 1 byte shorter:</p>

<pre class="lang-js prettyprint-override"><code>f=s=&gt;s.split`l`.join`y`  // 23 bytes
f("Hello, World!")       // -&gt; "Heyyo, Woryd!"
</code></pre>

<p>Note that this is no longer shorter if you want to use any regex features besides the <code>g</code> flag. However, if you're replacing all instances of a variable, it's usually far shorter:</p>

<pre class="lang-js prettyprint-override"><code>f=(s,c)=&gt;s.replace(RegExp(c,"g"),"") // 36 bytes
f=(s,c)=&gt;s.split(c).join``           // 26 bytes
f("Hello, World!","l") // -&gt; "Heo, Word!"
</code></pre>

<hr>

<p>Sometimes you'll want to map over each char in a string, replacing each one with something else. I often find myself doing this:</p>

<pre class="lang-js prettyprint-override"><code>f=s=&gt;s.split``.map(x=&gt;x+x).join`` // 33 bytes
f=s=&gt;[...s].map(x=&gt;x+x).join``    // 30 bytes
f("abc") // -&gt; "aabbcc"
</code></pre>

<p>However, <code>.replace</code> is almost always shorter:</p>

<pre class="lang-js prettyprint-override"><code>f=s=&gt;s.replace(/./g,x=&gt;x+x)  // 27 bytes
f=s=&gt;s.replace(/./g,"$&amp;$&amp;")  // Also works in this particular case
</code></pre>

<p>Now, if you want to map over each char in a string but don't care about the resulting string, <code>.map</code> is usually better because you can get rid of <code>.join``</code>:</p>

<pre class="lang-js prettyprint-override"><code>f=s=&gt;s.replace(/./g,x=&gt;t+=+x,t=0)&amp;&amp;t // 36 bytes
f=s=&gt;[...s].map(x=&gt;t+=+x,t=0)&amp;&amp;t     // 32 bytes
f("12345")  // -&gt; 15
</code></pre>
</div>
<div id="pu25" class="pu"><h1>How to golf with recursion</h1>



<p>Recursion, though not the fastest option, is very often the shortest. Generally, recursion is shortest if the solution can simplified to the solution to a smaller part of the challenge, especially if the input is a number or a string. For instance, if <code>f("abcd")</code> can be calculated from <code>"a"</code> and <code>f("bcd")</code>, it's usually best to use recursion.</p>

<p>Take, for instance, factorial:</p>

<pre class="lang-js prettyprint-override"><code>n=&gt;[...Array(n).keys()].reduce((x,y)=&gt;x*++y,1)
n=&gt;[...Array(n)].reduce((x,_,i)=&gt;x*++i,1)
n=&gt;[...Array(n)].reduce(x=&gt;x*n--,1)
n=&gt;{for(t=1;n;)t*=n--;return t}
n=&gt;eval("for(t=1;n;)t*=n--")
f=n=&gt;n?n*f(n-1):1
</code></pre>

<p>In this example, recursion is obviously way shorter than any other option.</p>

<p>How about sum of charcodes:</p>

<pre class="lang-js prettyprint-override"><code>s=&gt;[...s].map(x=&gt;t+=x.charCodeAt(),t=0)|t
s=&gt;[...s].reduce((t,x)=&gt;t+x.charCodeAt())
s=&gt;[for(x of(t=0,s))t+=x.charCodeAt()]|t  // Firefox 30+ only
f=s=&gt;s?s.charCodeAt()+f(s.slice(1)):0
</code></pre>

<p>This one is trickier, but we can see that when implemented correctly, recursion saves 4 bytes over <code>.map</code>.</p>

<p>Now let's look at the different types of recursion:</p>

<h2>Pre-recursion</h2>

<p>This is usually the shortest type of recursion. The input is split into two parts <code>a</code> and <code>b</code>, and the function calculates something with <code>a</code> and <code>f(b)</code>. Going back to our factorial example:</p>

<pre class="lang-js prettyprint-override"><code>f=n=&gt;n?n*f(n-1):1
</code></pre>

<p>In this case, <code>a</code> is <strong>n</strong>, <code>b</code> is <strong>n-1</strong>, and the value returned is <code>a*f(b)</code>.</p>

<p><strong>Important note: All</strong> recursive functions <strong>must</strong> have a way to stop recursing when the input is small enough. In the factorial function, this is controlled with the <code>n? :1</code>, i.e. if the input is <strong>0</strong>, return <strong>1</strong> without calling <code>f</code> again.</p>

<h2>Post-recursion</h2>

<p>Post-recursion is similar to pre-recursion, but slightly different. The input is split into two parts <code>a</code> and <code>b</code>, and the function calculates something with <code>a</code>, then calls <code>f(b,a)</code>. The second argument usually has a default value (i.e. <code>f(a,b=1)</code>).</p>

<p>Pre-recursion is good when you need to do something special with the final result. For example, if you want the factorial of a number plus 1:</p>

<pre class="lang-js prettyprint-override"><code>f=(n,p=1)=&gt;n?f(n-1,n*p):p+1
</code></pre>

<p>Even then, however, post- is not always shorter than using pre-recursion within another function:</p>

<pre class="lang-js prettyprint-override"><code>n=&gt;(f=n=&gt;n?n*f(n-1):1)(n)+1
</code></pre>

<p>So when is it shorter? You may notice that post-recursion in this example requires parentheses around the function arguments, while pre-recursion did not. Generally, if both solutions need parentheses around the arguments, post-recursion is around 2 bytes shorter:</p>

<pre class="lang-js prettyprint-override"><code>n=&gt;!(g=([x,...a])=&gt;a[0]?x-a.pop()+g(a):0)(n)
f=([x,...a],n=0)=&gt;a[0]?f(a,x-a.pop()+n):!n
</code></pre>

<p>(programs here taken from <a href="https://codegolf.stackexchange.com/a/94318/42545">this answer</a>)</p>

<h1>How to find the shortest solution</h1>

<p>Usually the only way to find the shortest method is to try all of them. This includes:</p>

<ul>
<li>Loops</li>
<li><code>.map</code> (for strings, either <code>[...s].map</code> or <code>s.replace</code>; for numbers, you can <a href="https://codegolf.stackexchange.com/a/61505/42545">create a range</a>)</li>
<li><a href="https://codegolf.stackexchange.com/a/61489/42545">Array comprehensions</a></li>
<li>Pre-recursion (sometimes within another of these options)</li>
<li>Post-recursion </li>
</ul>

<p>And these are just the most common solutions; the best solution might be a combination of these, or even <a href="https://codegolf.stackexchange.com/a/99460/42545">something entirely different</a>. The best way to find the shortest solution is to <a href="https://www.youtube.com/watch?v=J8vxiVIH7VY" rel="noreferrer">try everything</a>.</p>
</div>
<div id="pu26" class="pu"><h1>Yet another way to avoid <code>return</code></h1>
<p>You know you should <a href="https://codegolf.stackexchange.com/a/55618/21348">use eval for arrow functions with multiple statements and a return</a>. In some unusual case you can save more using an inner subfunction.</p>
<p>I say <em>unusual</em> because</p>
<ol>
<li><p>The result returned must not be the last expression evalued in the loop</p>
</li>
<li><p>There must be (at least) 2 <em>different</em> initializations before the loop</p>
</li>
</ol>
<p>In this case you can use an inner subfunction without return, having one of the initial values passed as a parameter.</p>
<p><strong>Example</strong>
Find the reciprocal of the sum of exp function for values in a range from a to b.</p>
<p>The long way - 55 bytes</p>
<pre><code>(a,b)=&gt;{for(r=0,i=a;i&lt;=b;i++)r+=Math.exp(i);return 1/r}
</code></pre>
<p>With eval - 54 bytes</p>
<pre><code>(a,b)=&gt;eval(&quot;for(r=0,i=a;i&lt;=b;i++)r+=Math.exp(i);1/r&quot;)
</code></pre>
<p>With an inner function - 53 bytes</p>
<pre><code>(a,b)=&gt;(i=&gt;{for(r=0;i&lt;=b;i++)r+=Math.exp(i)})(a)||1/r
</code></pre>
<p>Note that without the requirement of a lower range limit <code>a</code>, I can merge the initializations of i and r and the eval version is shorter.</p>
</div>
<div id="pu27" class="pu"><h1>Destructuring assignments</h1>

<p>ES6 introduces new syntax for destructuring assignments, i.e. cutting a value into pieces and assigning each piece to a different variable. Here are a few examples:</p>

<h3>Strings and arrays</h3>

<pre><code>a=s[0];b=s[1];       // 14 bytes
[a,b]=s;             //  8 bytes

a=s[0];s=s.slice(1); // 20 bytes
a=s.shift();         // 12 bytes, only works if s is an array
[a,...s]=s;          // 11 bytes, converts s to an array
</code></pre>

<h3>Objects</h3>

<pre><code>a=o.asdf;b=o.bye;c=o.length; // 28 bytes
{asdf:a,bye:b,length:c}=o;   // 26 bytes

a=o.a;b=o.b;c=o.c; // 18 bytes
{a,b,c}=o;         // 10 bytes
</code></pre>

<p>These assignments can also be used in function parameters:</p>

<pre><code>f=a=&gt;a[0]+a[1]+a[2]
f=([a,b,c])=&gt;a+b+c

f=b=&gt;b[1]?b[0]+f(b.slice(1)):b[0]*2
f=b=&gt;b[1]?b.shift()+f(b):b[0]*2
f=([a,...b])=&gt;b[0]?a+f(b):a*2
</code></pre>
</div>
<div id="pu28" class="pu"><h1>Golfing Logical Operations in ES6</h1>

<p>"GLOE (S6)"</p>

<h2>General Logic</h2>

<p>Say you have constructed statements <code>s</code> and <code>t</code>. See if you can use any of the following replacements:</p>

<pre><code>Traditional conjuction: s&amp;&amp;t
Equivalent conjuction: s*t OR s&amp;t

Traditional disjunction: s||t
Equivalent disjunction: s+t OR s|t
</code></pre>

<p>(These may not work if the order is wrong; i.e. <code>+</code> and <code>*</code> have a lower order precedence than <code>||</code> and <code>&amp;&amp;</code> do.)</p>

<p>Also, here are some handy logical expressions:</p>

<ul>
<li>Either <code>s</code> or <code>t</code> is true/XOR: <code>s^t</code></li>
<li><code>s</code> and <code>t</code> are the same truth value: <code>!s^t</code> or <code>s==t</code></li>
</ul>

<h2>Array logic</h2>

<p>All members of <code>a</code> satisfy condition <code>p</code>:</p>

<pre><code>a.every(p)                             // 10 bytes (11 bytes saved)
a.map(x=&gt;c&amp;=p(x),c=1)                  // 21 bytes (16 bytes saved)
for(i=0,c=1;i&lt;a.length;c&amp;=p(a[i++]));  // 37 bytes (hideously long)
</code></pre>

<p>At least one member of <code>a</code> satisfies condition <code>p</code>:</p>

<pre><code>a.some(p)                            // 9  bytes (13 bytes saved)
a.map(x=&gt;c|=p(x),c=0)                // 21 bytes (14 bytes saved)
for(i=c=0;i&lt;a.length;c|=p(a[i++]));  // 35 bytes (just please no)
</code></pre>

<p>No members of <code>a</code> satisfy condition <code>p</code>: <code>!a.some(p)</code>.</p>

<p>Element <code>e</code> exists in array <code>a</code>:</p>

<pre><code>a.includes(e)                        // 13 bytes, standard built-in
~a.indexOf(e)                        // 13 bytes, "traditional" method
a.find(x=&gt;e==x)                      // 15 bytes, find (ES6)
a.some(x=&gt;x==e)                      // 15 bytes, some (ES5)
(a+"").search(e)                     // 16 bytes, buggy
a.filter(t=&gt;t==e).length             // 24 bytes, no reason to use this
for(i=c=0;i&lt;a.length;c+=e==a[i++]);  // 35 bytes, super-traditional
</code></pre>

<p>Element <code>e</code> does <em>not</em> exist in array <code>a</code>:</p>

<pre><code>!a.includes(e)
!~a.indexOf(e)
a.every(t=&gt;t!=e)
!a.filter(t=&gt;t==e).length
for(i=0,c=1;i&lt;a.length;c*=e!=a[i++]);
</code></pre>
</div>
<div id="pu29" class="pu"><h1>(strawman) Use <code>do</code> expressions instead of <code>eval</code>ing strings</h1>

<p>[<a href="https://babeljs.io/docs/plugins/preset-stage-0/" rel="nofollow">Babel preset</a>] and [<a href="http://wiki.ecmascript.org/doku.php?id=strawman:do_expressions" rel="nofollow">proposal</a>].</p>

<p>Comes with the added bonus of keeping syntax highlighting.  This <strong>might be a stretch</strong> in some contests, but is nonetheless interesting.  I think if it's supported in Babel, it should qualify as competing.</p>

<p>Consider the following function (37 bytes):</p>

<pre><code>f=n=&gt;{for(o=i=0;i&lt;n;o+=++i);return o}
</code></pre>

<p>This might be golfed down with the classic <code>eval</code> trick (34 bytes (thank you everyone)):</p>

<pre><code>f=n=&gt;eval("for(o=i=0;i&lt;n;)o+=++i")
</code></pre>

<p>But we can do better with <code>do</code> (30 bytes):</p>

<pre><code>f=n=&gt;do{for(o=i=0;i&lt;n;)o+=++i}
</code></pre>

<p><a href="https://babeljs.io/repl/#?evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Cstage-0%2Cstage-2&amp;code=let%20f%3Dn%3D%3Edo%7Blet%20i%2Co%3Bfor(o%3Di%3D0%3Bi%3Cn%3B)o%2B%3D%2B%2Bi%7D%0Aconsole.log(f(15))%3B" rel="nofollow">Working example</a> - note that Babel needs <code>let</code> statements in all above functions as well.</p>

<p>Essentially what I'm trying to say is if a solution can be done with <code>eval</code>, you can almost always shave off a few bytes using <code>do</code>.</p>
</div>
<div id="pu30" class="pu"><h1>Use <code>eval</code> instead of braces for arrow functions</h1>



<p>Arrow functions are awesome. They take the form <code>x=&gt;y</code>, where <code>x</code> is an argument and <code>y</code> is the return value. However, if you need to use a control structure, such as <code>while</code>, you would have to put braces, e.g. <code>=&gt;{while(){};return}</code>. However, we can get around this; luckily, the <code>eval</code> function takes a string, evaluates that string as JS code, and <em>returns the last evaluated expression</em>. For example, compare these two:</p>

<pre class="lang-js prettyprint-override"><code>x=&gt;{while(foo){bar};return baz} // before
x=&gt;eval('while(foo){bar};baz')  // after
//                            ^
</code></pre>

<p>We can use an extension of this concept to further shorten our code: in the eyes of <code>eval</code>, control structures also return their last evaluated expression. For example:</p>

<pre class="lang-js prettyprint-override"><code>x=&gt;{while(foo)bar++;return bar} // before
x=&gt;eval('while(foo)++bar')      // after
//                        ^^^^^
</code></pre>
</div>
<div id="pu31" class="pu"><h1>Returning Values in Arrow Functions</h1>

<p>It's common knowledge that if a single statement follows the arrow function declaration, it returns the result of that statement:</p>

<pre class="lang-js prettyprint-override"><code>a=&gt;{return a+3}
a=&gt;a+3
</code></pre>

<h3>-7 bytes</h3>

<p>So when possible, combine multiple statements into one. This is most easily done by surrounding the statements with parentheses and separating them with commas:</p>

<pre class="lang-js prettyprint-override"><code>a=&gt;{r=0;a.map(n=&gt;r+=n);return r}
a=&gt;(r=0,a.map(n=&gt;r+=n),r)
</code></pre>

<h3>-8 bytes</h3>

<p>But if there are only two statements, it is usually possible (and shorter) to combine them with <code>&amp;&amp;</code> or <code>||</code>:</p>

<pre class="lang-js prettyprint-override"><code>a=&gt;{r=0;a.map(n=&gt;r+=n);return r}

// - Use &amp;&amp; because map always returns an array (true)
// - declaration of r moved into unused map argument to make it only 2 statements
a=&gt;a.map(n=&gt;r+=n,r=0)&amp;&amp;r
</code></pre>

<h3>-9 bytes</h3>

<p>Finally if you are using map (or similar) and need to return a number and you can guarantee the map will never return a 1-length array with a number, you can return the number with <code>|</code>:</p>

<pre class="lang-js prettyprint-override"><code>a=&gt;{a=b=0;a.map(n=&gt;(a+=n,b-=n));return a/b}

// - {} in map ensures it returns an array of undefined, so the | will make the returned
//   array cast from [ undefined, undefined, undefined ] to ",," to NaN to 0 and 0|n = n,
//   if the map returned [ 4 ] it would cast from [ 4 ] to "4" to 4 and make it 4|n
a=&gt;a.map(n=&gt;{a+=n,b-=n},a=b=0)|a/b
</code></pre>
</div>
<div id="pu32" class="pu"><h1>Aliasing using <code>eval</code> and template strings</h1>
<p>This one's more effective with longer code containing more repetition:</p>
<pre><code>a.push([0,1,2,3,4,5,6,7,8,9,10].push([0,1,2,3,4,5,6,7,8,9,10].push([0,1,2,3,4,5,6,7,8,9,10]))) // before
a.push([...Array(11).keys()].push([...Array(11).keys()].push([...Array(11).keys()]))) // before - golfed
a.push((f=_=&gt;[...Array(11).keys()])().push(f().push(f()))) // before - golfed more

eval(`a${b=`.push([...Array(11).keys()]`}${b+b})))`) // after
</code></pre>
<p><em>Probably not the best example, but you get the idea.</em></p>
<p>Although the use case is somewhat limited, it can save quite some bytes, especially because it can get at several char sequences (like <code>[function]([args])</code> or <code>[...</code>) that would otherwise be unable to be aliased.</p>
<p>Be careful with this, however; very often, using this technique can actually increase, not decrease, your byte count.</p>
</div>
<div id="pu33" class="pu"><h1><code>.forEach</code> vs <code>for</code> loops</h1>

<p>Always prefer <code>.map</code> to any for loop. Easy, instant savings.</p>

<hr>

<pre><code>a.map(f)
for(x of a)f(x);
for(i=0;i&lt;a.length;)f(a[i++]);
</code></pre>

<ul>
<li><strong>8 bytes total</strong> for original</li>
<li><strong>8 bytes saved</strong> vs for-of (<strong>50%</strong> reduction)</li>
<li><strong>22 bytes saved</strong> vs C-style for loop (<strong>73%</strong> reduction)</li>
</ul>

<hr>

<pre><code>a.map(x=&gt;f(x,0))
for(x of a)f(x,0);
for(i=0;i&lt;a.length;)f(a[i++],0);
</code></pre>

<ul>
<li><strong>16 bytes total</strong> for original</li>
<li><strong>2 bytes saved</strong> vs for-of (<strong>11%</strong> reduction)</li>
<li><strong>16 bytes saved</strong> vs C-style for loop (<strong>50%</strong> reduction)</li>
</ul>

<hr>

<pre><code>a.map((x,i)=&gt;f(x,i,0))
for(i in a)f(a[i],i,0);
for(i=0;i&lt;a.length;)f(a[i],i++,0);
</code></pre>

<ul>
<li><strong>22 bytes total</strong> for original</li>
<li><strong>1 byte saved</strong> vs for-in (<strong>4%</strong> reduction)</li>
<li><strong>11 bytes saved</strong> vs C-style for loop (<strong>33%</strong> reduction)</li>
</ul>

<hr>

<pre><code>a.map(x=&gt;f(x)&amp;g(x))
for(x of a)f(x),g(x);
for(i=0;i&lt;a.length;)f(x=a[i++]),g(x);
</code></pre>

<ul>
<li><strong>19 bytes total</strong> for original</li>
<li><strong>2 bytes saved</strong> vs for-of (<strong>10%</strong> reduction)</li>
<li><strong>18 bytes saved</strong> vs C-style for loop (<strong>49%</strong> reduction)</li>
</ul>
</div>
<div id="pu34" class="pu"><h1>Filling Arrays - Static Values &amp; Dynamic Ranges</h1>
<p>I originally left these as comments under comprehensions, but since that post was primarily focused on comprehensions, I figured that it would be good to give this it's own place.</p>
<p>ES6 gave us the ability to fill arrays with static values without the use of loops:</p>
<pre><code>// ES5
function(x){for(i=0,a=[];i&lt;x;i++)a[i]=0;return a}

// ES6
x=&gt;Array(x).fill(0)
</code></pre>
<p>Both return an array of length x, filled with the value 0.</p>
<p>If you want to fill arrays with dynamic values (such as a range from 0...x) however, the result is a little longer (although still shorter than the old way):</p>
<pre><code>// ES5
function(x){for(i=0,a=[];i&lt;x;i++)a[i]=i;return a}

// ES6
x=&gt;Array(x).fill().map((a,i)=&gt;i)
</code></pre>
<p>Both return an array of length x, starting with the value 0 and ending in x-1.</p>
<p>The reason you need the <code>.fill()</code> in there is because simply initializing an array won't let you map it. That is to say, doing <code>x=&gt;Array(x).map((a,i)=&gt;i)</code> will return an empty array. You can also get around the need for fill (and thus make it even shorter) by using the spread operator like so:</p>
<pre><code>x=&gt;[...Array(x)]
</code></pre>
<p>Using the spread operator and <code>.keys()</code> function, you can now make a short 0...x range:</p>
<pre><code>x=&gt;[...Array(x).keys()]
</code></pre>
<p>If you want a custom range from x...y, or a specialized range altogether (such as even numbers), you can get rid of <code>.keys()</code> and just use <code>.map()</code>, or use <code>.filter()</code>, with the spread operator:</p>
<pre><code>// Custom range from x...y
(x,y)=&gt;[...Array(y-x)].map(a=&gt;x++)

// Even numbers (using map)
x=&gt;[...Array(x/2)].map((a,i)=&gt;i*2)

// Even numbers (using filter)
x=&gt;[...Array(x).keys()].filter(a=&gt;~a%2)
</code></pre>
</div>
<div id="pu35" class="pu"><h2>Using property shorthands</h2>

<p>Property shorthands allow you to set variables to an arrays' values:</p>

<pre><code>a=r[0];b=r[1] // ES5
[a,b]=r       // ES6 - 6 bytes saved
</code></pre>

<p>This can also be used like:</p>

<pre><code>a=r[0],b=r[2] // ES5
[a,,b]=r      // ES6 - 5 bytes saved
</code></pre>

<p>You can even use this to reverse variables:</p>

<pre><code>c=a,a=b,b=c // ES5 - uses extra variable
[b,a]=[a,b] // ES6 - not shorter, but more flexible
</code></pre>

<p>You can also use this to shorten <code>slice()</code> functions.</p>

<pre><code>z = [1, 2, 3, 4, 5];

a=z.slice(1) // a = [2,3,4,5]; ES5
[,...a]=z    // a = [2,3,4,5]; ES6
</code></pre>

<h2>Base conversions</h2>

<p>ES6 provides a much shorter way to convert form Base-2 (binary) and Base-8 (octal) to decimal:</p>

<pre><code>0b111110111 // == 503
0o767       // == 503
</code></pre>

<p><code>+</code> can be used to convert a binary, octal or hex string to a decimal number. You can use <code>0b</code>, <code>0o</code>, and <code>0x</code>, for binary, octal, and hex respectively.:</p>

<pre><code>parseInt(v,2) // ES5
+('0b'+v)     // ES6 - 4 bytes saved; use '0o' for octal and '0x' for hex
'0b'+v-0      // Shorter, but may not work in all cases
              // You can adapt this your case for better results
</code></pre>

<hr>

<p>If you are using this > 7 times, then it will be shorter to use <code>parseInt</code> and rename it:</p>

<pre><code>(p=parseInt)(v,2)
</code></pre>

<p>Now <code>p</code> can be used for <code>parseInt</code>, saving you many bytes over the long run.</p>
</div>
<div id="pu36" class="pu"><h1>Set function parameter defaults</h1>
<pre><code>($,a,b,_)=&gt;_!=undefined?'asdf':_ // before
($,a,b,_)=&gt;_!=[]._?'asdf':_ // before, but a bit golfed
($,a,b,_='asdf')=&gt;_ // after
</code></pre>
<p>This one's really useful...</p>
<p>However, be sure to understand that something like <code>_=&gt;_||'asdf'</code> is shorter when you're only passing one (useful) argument to the function.</p>
</div>
<div id="pu37" class="pu"><h1>Using <code>eval</code> for arrow functions with multiple statements and a <code>return</code></h1>

<p>One of the more ridiculous tricks I've stumbled across...</p>

<p>Imagine a simple arrow function that needs multiple statements and a <code>return</code>.</p>

<pre><code>a=&gt;{for(o="",i=0;i&lt;a;i++)o+=i;return o}
</code></pre>

<p>A simple function accepting a single parameter <code>a</code>, which iterates over all integers in <code>[0, a)</code>, and tacks them onto the end of the output string <code>o</code>, which is returned. For example, calling this with <code>4</code> as the parameter would yield <code>0123</code>.</p>

<p>Note that this arrow function had to be wrapped in braces <code>{}</code>, and have a <code>return o</code> at the end.</p>

<p>This first attempt weighs in at <strong>39 bytes</strong>.</p>

<p>Not bad, but by using <code>eval</code>, we can improve this.</p>

<pre><code>a=&gt;eval('for(o="",i=0;i&lt;a;i++)o+=i;o')
</code></pre>

<p>This function removed the braces and the return statement by wrapping the code in an <code>eval</code> and simply making the last statement in the <code>eval</code> evaluate to <code>o</code>. This causes the <code>eval</code> to return <code>o</code>, which in turn causes the function to return <code>o</code>, since it is now a single statement.</p>

<p>This improved attempt weighs in at <strong>38 bytes</strong>, saving one byte from the original.</p>

<p>But wait, there's more! Eval statements return whatever their last statement evaluated to. In this case, <code>o+=i</code> evaluates to <code>o</code>, so we don't need the <code>;o</code>! <em>(Thanks, edc65!)</em></p>

<pre><code>a=&gt;eval('for(o="",i=0;i&lt;a;i++)o+=i')
</code></pre>

<p>This final attempt weighs only <strong>36 bytes</strong> - a 3 byte savings over the original!</p>

<p><br /></p>

<p>This technique could be extended to any general case where an arrow function needs to return a value and have multiple statements (that couldn't be combined by other means)</p>

<pre><code>b=&gt;{statement1;statement2;return v}
</code></pre>

<p>becomes</p>

<pre><code>b=&gt;eval('statement1;statement2;v')
</code></pre>

<p>saving a byte.</p>

<p>If <code>statement2</code> evaluates to <code>v</code>, this can be</p>

<pre><code>b=&gt;eval('statement1;statement2')
</code></pre>

<p>saving a total of 3 bytes.</p>
</div>
<div id="pu38" class="pu"><h1>Prefer template string new lines over "\n"</h1>

<p>This will start to pay off at even a single new line character in your code. One use case might be:</p>

<h3>(16 bytes)</h3>

<pre><code>array.join("\n")
</code></pre>

<h3>(15 bytes)</h3>

<pre><code>array.join(`
`)
</code></pre>

<p><strong>Update:</strong> You can even leave away the braces due to tagged template strings (thanks, edc65!):</p>

<h3>(13 bytes)</h3>

<pre><code>array.join`
`
</code></pre>
</div>
<div id="pu39" class="pu"><h2>Using string templates with functions</h2>

<p>When you have a function with one string as the arguments. You can omit the <code>()</code> if you don't have any expressions:</p>

<pre><code>join`` // Works
join`foobar` // Works
join`${5}` // Doesn't work 
</code></pre>
</div>
<div id="pu40" class="pu"><h1>Return intermediate result</h1>
<p>You know that using the comma operator you can execute a sequence of expressions returning the last value. But abusing the literal array syntax, you can return any intermediate value. It's useful in .map() for instance.</p>
<pre><code>// capitalize words
// f is a flag indicating if prev char is space
[...x].map(c=&gt;(f?c=c.toUpperCase():0,f=c&lt;'!',c),f=1).join('')

// shortened to ...
[...x].map(c=&gt;[f?c.toUpperCase():c,f=c&lt;'!'][0],f=1).join('')
</code></pre>
</div>
<div id="pu41" class="pu"><h1><code>Array#concat()</code> and the spread operator</h1>

<p>This largely depends on the situation.</p>

<hr>

<h2>Combining multiple arrays.</h2>

<p>Prefer the concat function unless cloning.</p>

<p><strong>0 bytes saved</strong></p>

<pre><code>a.concat(b)
[...a,...b]
</code></pre>

<p><strong>3 bytes wasted</strong></p>

<pre><code>a.concat(b,c)
[...a,...b,...c]
</code></pre>

<p><strong>3 bytes saved</strong></p>

<pre><code>a.concat()
[...a]
</code></pre>

<p><strong>6 bytes saved</strong></p>

<pre><code>// Concatenate array of arrays
[].concat.apply([],l)
[].concat(...l)
</code></pre>

<hr>

<h2>Prefer using an already existing array to <code>Array#concat()</code>.</h2>

<p>Easy <strong>4 bytes saved</strong></p>

<pre><code>[].concat(a,b)
a.concat(b)
</code></pre>
</div>
<div id="pu42" class="pu"><h2>Tricks learned here since I joined</h2>

<p>My primary programming language is JS and mostly ES6. Since I joined this site a week back, I have learned a lot of useful tricks from fellow members. I am combining some of those here. All credits to community.</p>

<h2>Arrow functions and loops</h2>

<p>We all know that arrow functions save a lot of byts</p>

<pre><code>function A(){do something} // from this
A=a=&gt;do something // to this
</code></pre>

<p>But you have to keep in mind a few things</p>

<ul>
<li>Try to club multiple statements using <code>,</code> i.e. <code>(a=b,a.map(d))</code> - Here, the value which is returned is the last expression <code>a.map(d)</code></li>
<li>if your <code>do something</code> part is more than one statement, then you need to add the surrounding <code>{}</code> brackets.</li>
<li>If there are surrounding <code>{}</code> brackets, you need to add an explicit return statement.</li>
</ul>

<p>The above holds true a lot of times when you have loops involved. So something like:</p>

<pre><code>u=n=&gt;{for(s=[,1,1],r=[i=1,l=2];c=l&lt;n;i+=!c?s[r[l++]=i]=1:1)for(j of r)c-=j&lt;i/2&amp;s[i-j];return n&gt;1?r:[1]}
</code></pre>

<p>Here I am wasting at least 9 characters due to the return. This can be optimized.</p>

<ul>
<li>Try to avoid for loops. Use <code>.map</code> or <code>.every</code> or <code>.some</code> instead. Note that if you want to change the same array that you are mapping over, it will fail.</li>
<li>Wrap the loop in a closure arrow function, converting the main arrow function as single statement.</li>
</ul>

<p>So the above becomes:</p>

<pre><code>u=n=&gt;(s=&gt;{for(r=[i=1,l=2];c=l&lt;n;i+=!c?s[r[l++]=i]=1:1)for(j of r)c-=j&lt;i/2&amp;s[i-j]})([,1,1])|n&gt;1?r:[1]
</code></pre>

<p>removed characters: <code>{}return</code></p>

<p>added characters:   <code>(){}&gt;|</code></p>

<p>Note how I call the closure method, which correctly populates the variable <code>n</code> and then since the closure method is not returning anything (i.e. returning <code>undefined</code>), I bitwise or it and return the array <code>n</code> all in a single statement of the outer arrow function <code>u</code></p>

<h2>Commas and semicolons</h2>

<p>Avoid them what so ever,</p>

<p>If you are declaring variables in a loop, or like mentioned in the previous section, using <code>,</code> separated statements to have single statement arrow functions, then you can use some pretty nifty tricks to avoid those <code>,</code> or <code>;</code> to shave off those last few bytes.</p>

<p>Consider this code:</p>

<pre><code>r=v=&gt;Math.random()*100|0;n=r();m=r();D=v=&gt;A(n-x)+A(m-y);d=0;do{g();l=d;d=D();....
</code></pre>

<p>Here, I am calling a lot of methods to initialize many variables. Each initialization is using a <code>,</code> or <code>;</code>. This can be rewritten as:</p>

<pre><code>r=v=&gt;Math.random()*100|0;n=r(m=r(d=0));D=v=&gt;A(n-x)+A(m-y);do{d=D(l=d,g());....
</code></pre>

<p>Note how I use the fact that the method does not bother the variable passed to it and use that fact to shave 3 bytes.</p>

<h2>Misc</h2>

<p><strong><code>.search</code> instead of <code>.indexOf</code></strong></p>

<p>Both give the same result, but <code>search</code> is shorter. Although search expects a Regular Expression, so use it wisely.</p>

<p><strong><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings">`Template Strings`</a></strong></p>

<p>These are super handy when you have to concat one or more string parts based on certain conditions.</p>

<p>Take the following example to output a quine in JS</p>

<pre><code>(f=x=&gt;alert("(f="+f+")()"))()
</code></pre>

<p>vs.</p>

<pre><code>(f=x=&gt;alert(`(f=${f})()`))()
</code></pre>

<p>In a template string, which is a string inside two backquotes (`), anything inside a <code>${ }</code> is treated as a code and evaluated to insert the resulting answer in the string.</p>

<p>I'll post a few more tricks later. Happy golfing!</p>
</div>
<div id="pu43" class="pu"><p>Function expressions in ES6 use the arrow notation, and it helps a lot saving bytes if compared with the ES5 version:</p>

<pre class="lang-javascript prettyprint-override"><code>f=function(x,y){return x+y}
f=(x,y)=&gt;x+y
</code></pre>

<p>If your function only has one parameter, you can omit the parentheses to save two bytes:</p>

<pre class="lang-javascript prettyprint-override"><code>f=x=&gt;x+1
</code></pre>

<p>If your function has no parameters at all, declare it as if it had one to save one byte:</p>

<pre class="lang-javascript prettyprint-override"><code>f=()=&gt;"something"
f=x=&gt;"something"
</code></pre>

<p>Beware: Arrow functions are not exactly the same as <code>function () {}</code>. The rules for <code>this</code> are different (and better IMO). See <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">docs</a></p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/37624/">37624</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




