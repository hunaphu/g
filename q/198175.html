<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::198175</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td>Rust</td><td>250126T140436Z</td><td><a href="https://codegolf.stackexchange.com/questions/198175/buildings-made-from-cubes/277910#277910">138 Aspe</a></td></tr>
<tr d-ix="1"><td>1785</td><td>Java 11</td><td>200314T082140Z</td><td><a href="https://codegolf.stackexchange.com/questions/198175/buildings-made-from-cubes/201038#201038">Miles</a></td></tr>
<tr d-ix="2"><td>169</td><td>Haskell</td><td>200222T161043Z</td><td><a href="https://codegolf.stackexchange.com/questions/198175/buildings-made-from-cubes/199919#199919">Christia</a></td></tr>
<tr d-ix="3"><td>nan</td><td>Java 8</td><td>200119T233008Z</td><td><a href="https://codegolf.stackexchange.com/questions/198175/buildings-made-from-cubes/198205#198205">Miles</a></td></tr>
<tr d-ix="4"><td>nan</td><td>JavaScript Node.js</td><td>200118T152132Z</td><td><a href="https://codegolf.stackexchange.com/questions/198175/buildings-made-from-cubes/198183#198183">Arnauld</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Rust, <span class="math-container">\$n=8\$</span> in about 36.211623557s</h1>
<p>Rust port of @Arnauld's JavaScript answer.</p>
<p><a href="https://tio.run/##nVdJc@I4FL7zK5QcKHmSuMxcOmMCfe25zKWr5pKiXAqIjrqNTEkyywC/PfO02Mjykk5cRQJv@95mvSdRSvX2VkqKpFql6bLIc7pUrOAyTb8R@fqdqumoZiu2oWn6N5eKcKCP1hy9lCxfYZ6iUrL/aIQe5vYbOo0QPDlVaFMqlJMjFWiGdnR582z@JFPEF@bTEFyWLxTkHHaacrrHUSBSlFyBTAIeaPq6EOiIGEdJHHOHW9GZpk/ieIY5ekDHyGMbk9qt5@PiOVmAQYaIROXjtCGyZnmOGxT9aGvsvkU@ohn41aaP6xz08HTYfSwdbpvHm6RoOhBYcmVeRvav@WdMjy6mkNc4f7liWgCSsx88U8U2RS9FkVuiMZ9a//6lyyf9KR/nc8vVwTimq@PTdyUY/1HxNawT8JB4jVuVia3RL5NRr2y6C5alEJSrTCrdU8YZ8FD/BBBsfnv5ACs32qV4WXBFGJd47BkIW@IP2153MzRx/VU9xgaoU6GwZyBe5gWnOIoCce2oKBRRdPVXAm7a75jfo9DB0HgY0Lg2MwQyeWyieFofhwJjQ1h/funG0mofBwNrnWAbJkQh6Aqg7Ff84cxVJgbtZ@BHUKKr4ifArL13IVsFC/Q/idxXOl@mVb/QwCexXSWbh41@BFWl4FP/8NE@HZPq/Y2ZogJH8baQTM8ffBbF/gwu7isO4Ud8Hu/OaIdu4EiIorjke0G2GfQFd6DwqoPJ@Qz5c6APGyIgQg8SDDpw8jMztx7QJIo35ICTyIwDTQwHjVNtj5tDxxhyftUn8mERHml@lV6JzMjqJ1lSbl1Dc5Adjyt97Z@xYXLQMqGf81mrPZkZNfFV735L9RAggooBfVetjahV72rVoCddXhoBnzrNm@4lh4zpGb2@TqQecTPDOjkXRHNJh9RiSaBZiILOzmT5ojsDAuiO@tIRUGvvsH73IzbaonsDeX8baYTQvZn4zzWBtlV0O0bDKj27S3hIvCPRvckMbDUDG05/EpNuwctomHJp7Uh2MapOyWo7qZcff/Exi69PCPZfN@mGNuChNbbvXHFm69BtIvRraN9ZYLRXv7oFsFOPXKT@kP1gfN6otse5W4osesWNBd1RIWu69aIetc4NR6025hT9riO8Rs8px9eRwMMD104EK9uYC/tXllOXxWRRTx5459zkMa9KsI2umZAKpt@@hhd0U@wo9seoZWxL@Ypr@agDG@sqO8jjubnHB9i6MTQqtMb1ftFqkH2XNxXL@JNEPdcDY9AVpXPJ7moSu@lXVTEWKuMun9ff65yobEO2rWHvyRi2zn18Bff57sqapsaNbD73AX4WjOPb@9u6w2H9x1UOdf54dU4/BkWtdgN32YWLaFFfROtlmMoy10LuEhywV2aQFLor7bpAc7KVdOWb2UI8Kuc3@PYfEDtd0AOk8HS5vYeT0NnvlDY3cXRKv2rRCqjup8vb2/8" rel="nofollow noreferrer">Try it online!</a></p>
<pre class="lang-rust prettyprint-override"><code>use std::collections::HashSet;
use std::time::Instant;

fn build(n: usize) -&gt; usize {
    let mut layer = vec![vec![0; n]; n];
    let mut cube = HashSet::new();
    let mut count = 0;

    for y in 0..n {
        for i in 1..=(n - y) {
            layer[y][0] = i as u8;
            fill(
                n - i,
                y == 0,
                &amp;mut layer,
                &amp;mut cube,
                &amp;mut count,
                n,
            );
            layer[y][0] = 0;
        }
    }

    count
}

fn fill(
    k: usize,
    align_top: bool,
    layer: &amp;mut Vec&lt;Vec&lt;u8&gt;&gt;,
    cube: &amp;mut HashSet&lt;String&gt;,
    count: &amp;mut usize,
    n: usize,
) {
    if k == 0 {
        let current_str = layer_to_string(layer);
        if !cube.contains(&amp;current_str) {
            *count += 1;

            cube.insert(current_str.clone());

            let rotated90 = rotate(n, layer);
            cube.insert(layer_to_string(&amp;rotated90));

            let rotated180 = rotate(n, &amp;rotated90);
            cube.insert(layer_to_string(&amp;rotated180));

            let rotated270 = rotate(n, &amp;rotated180);
            cube.insert(layer_to_string(&amp;rotated270));

            let mirrored = mirror(layer);
            cube.insert(layer_to_string(&amp;mirrored));

            let mirrored_rot90 = rotate(n, &amp;mirrored);
            cube.insert(layer_to_string(&amp;mirrored_rot90));

            let mirrored_rot180 = rotate(n, &amp;mirrored_rot90);
            cube.insert(layer_to_string(&amp;mirrored_rot180));

            let mirrored_rot270 = rotate(n, &amp;mirrored_rot180);
            cube.insert(layer_to_string(&amp;mirrored_rot270));
        }
        return;
    }

    let y0 = layer.iter().position(|row| row.iter().any(|&amp;v| v != 0)).unwrap_or(n);
    if y0 &gt;= n {
        return;
    }

    let y_start = (y0 as isize - 1).max(0) as usize;

    for y in y_start..n {
        for x in 0..n {
            if layer[y][x] == 0 {
                let has_adjacent = (y &gt; 0 &amp;&amp; layer[y - 1][x] != 0)
                    || (y &lt; n - 1 &amp;&amp; layer[y + 1][x] != 0)
                    || (x &gt; 0 &amp;&amp; layer[y][x - 1] != 0)
                    || (x &lt; n - 1 &amp;&amp; layer[y][x + 1] != 0);

                if has_adjacent {
                    let max_i = if align_top {
                        k
                    } else {
                        k.saturating_sub(y0 + 1)
                    };

                    for i in 1..=max_i {
                        layer[y][x] = i as u8;
                        fill(
                            k - i,
                            align_top || (y == 0),
                            layer,
                            cube,
                            count,
                            n,
                        );
                        layer[y][x] = 0;
                    }
                }
            }
        }
    }
}

fn rotate(n: usize, layer: &amp;Vec&lt;Vec&lt;u8&gt;&gt;) -&gt; Vec&lt;Vec&lt;u8&gt;&gt; {
    let mut rotated = vec![vec![0; n]; n];
    for y in 0..n {
        for x in 0..n {
            rotated[y][x] = layer[n - x - 1][y];
        }
    }
    align(rotated)
}

fn mirror(layer: &amp;Vec&lt;Vec&lt;u8&gt;&gt;) -&gt; Vec&lt;Vec&lt;u8&gt;&gt; {
    let mut mirrored = layer.clone();
    mirrored.reverse();
    align(mirrored)
}

fn align(mut layer: Vec&lt;Vec&lt;u8&gt;&gt;) -&gt; Vec&lt;Vec&lt;u8&gt;&gt; {
    let n = layer.len();
    if n == 0 {
        return layer;
    }

    while layer[0].iter().all(|&amp;v| v == 0) {
        let first_row = layer.remove(0);
        layer.push(first_row);
    }

    while (0..n).all(|y| layer[y][0] == 0) {
        for row in &amp;mut layer {
            row.remove(0);
            row.push(0);
        }
    }

    layer
}

fn layer_to_string(layer: &amp;Vec&lt;Vec&lt;u8&gt;&gt;) -&gt; String {
    layer
        .iter()
        .flat_map(|row| row.iter())
        .map(|v| v.to_string())
        .collect::&lt;Vec&lt;_&gt;&gt;()
        .join(&quot;,&quot;)
}

fn main() {
    for n in 1..=8 {
        let start = Instant::now();
        let result = build(n);
        let duration = start.elapsed();
        println!(&quot;N = {} --&gt; {}&quot;, n, result);
        println!(&quot;time: {:?}&quot;, duration);
    }
}
</code></pre>
</div>
<div id="pu1" class="pu"><h1>Java 11, <span class="math-container">\$n=17\$</span> in about 8.5 minutes</h1>
<h3>Based on <a href="https://codegolf.stackexchange.com/a/199919">Haskell solution by Christian Sievers</a> – upvote his!</h3>
<p>This answer is the result of learning enough Haskell to be able to understand Christian's answer, translating it into Java, applying numerous micro-optimizations, and throwing multiple cores at it. The exact runtime varies significantly depending on the number of cores available; this timing result is from my own two-core machine. A 48-core EC2 c5.24xlarge is able to compute <span class="math-container">\$n=17\$</span> in 16 seconds, and <span class="math-container">\$n=20\$</span> in 18 minutes.</p>
<p>Parallelism can be disabled by adding the JVM argument <code>-Djava.util.concurrent.ForkJoinPool.common.parallelism=0</code>. Single-threaded performance is slightly better than double that of the Haskell solution.</p>
<p>Some of the optimizations include:</p>
<ul>
<li>Representing a point using a single int value</li>
<li>Using simplified hand-rolled collections based on int arrays, avoiding the primitive boxing required for the standard Java collections</li>
<li>Reimplementing polyomino enumeration based on <a href="https://doi.org/10.1016%2F0012-365X%2881%2990237-5" rel="nofollow noreferrer">this paper</a> -- my initial attempt at a direct translation of the Haskell code performed extra throwaway work that didn't actually contribute to the computation</li>
<li>Replacing higher-level <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Stream.html" rel="nofollow noreferrer">Stream</a>-based implementations with inlined code, making it very ugly and verbose</li>
</ul>
<p>The bulk of the processing time is spent in <code>Array.sort</code> calls in <code>normalizeInPlace</code>. Finding a way to compare polyomino transformations without sorting could easily result in a further 4x speedup. The forking is also not done very intelligently which leads to unbalanced tasks and unused cores at higher levels of parallelism.</p>
<pre class="lang-java prettyprint-override"><code>import java.util.Arrays;
import java.util.concurrent.RecursiveTask;
import java.util.function.IntPredicate;
import java.util.function.IntUnaryOperator;
import java.util.function.LongSupplier;
import java.util.function.ToLongFunction;

/**
 * Utility methods for working with an int that represents a pair of short values.
 */
class Point {
    static final int start = p(0, 0);
    static final int[] neighbors = new int[] {-0x10000, -0x1, 0x1, 0x10000};

    static int x(int p) {
        return (p &gt;&gt; 16) - 0x4000;
    }

    static int y(int p) {
        return (short)(p) - 0x4000;
    }

    static int p(int x, int y) {
        return ((x + 0x4000) &lt;&lt; 16) | (y + 0x4000);
    }

    static int rot(int p) {
        return p(-y(p), x(p));
    }

    static int mirror(int p) {
        return p(-x(p), y(p));
    }
}

/**
 * Minimal primitive array-based collections.
 */
class IntArrays {
    /** Concatenates the end of the first array with the beginning of the second. */
    static int[] arrayConcat(int[] a, int aOffset, int[] b, int bLen) {
        int aLength = a.length - aOffset;
        int[] result = new int[aLength + bLen];
        System.arraycopy(a, aOffset, result, 0, aLength);
        System.arraycopy(b, 0, result, aLength, bLen);
        return result;
    }

    /** Adds a new value to a sorted set, returning the new result */
    static int[] setAdd(int[] set, int val) {
        int[] dst = new int[set.length + 1];
        int i = 0;
        for (; i &lt; set.length &amp;&amp; set[i] &lt; val; i++) {
            dst[i] = set[i];
        }
        dst[i] = val;
        for (; i &lt; set.length; i++) {
            dst[i + 1] = set[i];
        }
        return dst;
    }

    private static final int[] primes = new int[] {
            5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,
            67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131
    };

    /**
     * Allocate an array large enough to hold a fixed-capacity hash table
     * that can contain &quot;seen&quot; points for generating polyominos of size n.
     */
    static int[] makeHashTable(int n) {
        return new int[primes[-(Arrays.binarySearch(primes, n * 3) + 1)]];
    }

    /** Inserts a new value to a hash table, in-place */
    static void hashInsert(int[] table, int val) {
        int pos = (val * 137) % table.length, startPos = pos;
        if (table[pos] != 0) {
            while ((table[pos = (pos + 1) % table.length]) != 0) {
                if (pos == startPos) {
                    throw new AssertionError(&quot;table full&quot;);
                }
            }
        }
        table[pos] = val;
    }

    /** Checks whether a hash table contains the specified value */
    static boolean hashContains(int[] table, int val) {
        int pos = (val * 137) % table.length, startPos = pos;
        while (true) {
            int curr = table[pos];
            if (curr == val) return true;
            if (curr == 0) return false;
            pos = (pos + 1) % table.length;
            if (pos == startPos) {
                throw new AssertionError(&quot;table full&quot;);
            }
        }
    }
}

/**
 * Recursively generates int arrays representing collections of Points,
 * applying a function to each array to compute a long, and returns the sum
 * of all such values.
 */
class PolyominoVisitor extends RecursiveTask&lt;Long&gt; {
    PolyominoVisitor(ToLongFunction&lt;? super int[]&gt; func, int n) {
        this(func, n, 0, 1, new int[0], IntArrays.makeHashTable(n), new int[]{Point.start});
    }

    private PolyominoVisitor(ToLongFunction&lt;? super int[]&gt; action, int n,
                             int i, int limit, int[] used, int[] seen, int[] untried) {
        this.func = action;
        this.n = n;
        this.start = () -&gt; visit(i, limit, used, seen, untried);
    }

    private final boolean visitSmaller = true;
    private final ToLongFunction&lt;? super int[]&gt; func;
    private final int n;
    private final LongSupplier start;

    @Override
    protected Long compute() {
        return start.getAsLong();
    }

    private long visit(int i, int limit, int[] used, int[] seen, int[] untried) {
        long val = 0;
        if (used.length + 1 == n) {
            // reached the second to last level, so we can apply the function
            // directly to our children
            for (; i &lt; limit; i++) {
                val += func.applyAsLong(IntArrays.setAdd(used, untried[i]));
            }
        } else if (used.length + 6 &lt; n &amp;&amp; limit - i &gt;= 2) {
            // eligible to split
            PolyominoVisitor[] tasks = new PolyominoVisitor[limit - i];
            for (int j = 0; j &lt; tasks.length; j++) {
                tasks[j] = new PolyominoVisitor(func, n,
                        i + j, i + j + 1, used, seen, untried);

            }
            invokeAll(tasks);
            for (PolyominoVisitor task : tasks) val += task.getRawResult();
            return val;
        } else {
            // recursively visit children
            int[] newReachable = new int[4];
            IntPredicate inSeen = p -&gt; !IntArrays.hashContains(seen, p);
            for (; i &lt; limit; i++) {
                int candidate = untried[i];
                int[] child = IntArrays.setAdd(used, candidate);
                int reachableCount = neighbors(candidate, inSeen, newReachable);
                int[] newSeen = seen.clone();
                for (int j = 0; j &lt; reachableCount; j++) IntArrays.hashInsert(newSeen, newReachable[j]);
                int[] newUntried = IntArrays.arrayConcat(untried, i + 1, newReachable, reachableCount);
                val += visit(0, newUntried.length, child, newSeen, newUntried);
            }
        }
        if (visitSmaller &amp;&amp; used.length &gt; 0 &amp;&amp; limit == untried.length) {
            val += func.applyAsLong(used);
        }
        return val;
    }

    /**
     * Write the greater-than-origin neighbors of the given point
     * that pass the provided predicate into the provided array,
     * returning the count written.
     */
    private static int neighbors(int p, IntPredicate pred, int[] dst) {
        int count = 0;
        for (int offset : Point.neighbors) {
            int n = p + offset;
            if (n &gt; Point.start &amp;&amp; pred.test(n)) {
                dst[count++] = n;
            }
        }
        return count;
    }
}

/**
 * Function that computes how many buildings are constructable on a given
 * polyomino base. Considers symmetry, returning 0 if the figure is not the
 * canonical version (i.e. has a smaller transformation).
 *
 * Adapted largely unchanged from Christian Sievers
 * https://codegolf.stackexchange.com/a/199919
 */
class BuildingCounter implements ToLongFunction&lt;int[]&gt; {
    private final int n;

    public BuildingCounter(int n) {
        this.n = n;
    }

    @Override
    public long applyAsLong(int[] fig) {
        return combinations(n - fig.length, fig);
    }

    private static int[] map(int[] fig, IntUnaryOperator func) {
        int[] result = new int[fig.length];
        for (int i = 0; i &lt; fig.length; i++) {
            result[i] = func.applyAsInt(fig[i]);
        }
        return result;
    }

    private static int[] normalizeInPlace(int[] fig) {
        Arrays.sort(fig);
        int d = fig[0] - Point.start;
        for (int i = 0; i &lt; fig.length; i++) {
            fig[i] -= d;
        }
        return fig;
    }

    private static int[] rot(int[] ps) {
        return normalizeInPlace(map(ps, Point::rot));
    }

    private static int[] mirror(int[] ps) {
        return normalizeInPlace(map(ps, Point::mirror));
    }

    private static int myf(int r, int sz, int[] fig) {
        int max = Integer.MIN_VALUE;
        for (int p : fig) {
            if (p &gt; max) max = p;
        }
        int w = Point.x(max);
        if (w % 2 == 0) {
            int wh = w / 2;
            int myb = 0;
            for (int p : fig) {
                if (Point.x(p) == wh) myb++;
            }
            return c12(myb, (sz - myb)/2, r);
        } else {
            return c1h(sz, r);
        }
    }

    private static int mdf(int r, int sz, int[] fig) {
        int lo = Integer.MAX_VALUE;
        for (int p : fig) {
            int tmp = Point.y(p);
            if (tmp &lt; lo) lo = tmp;
        }
        int mdb = 0;
        for (int p : fig) {
            if (Point.x(p) == Point.y(p) - lo) mdb++;
        }
        return c12(mdb, (sz-mdb)/2, r);
    }

    private static long combinations(int r, int[] fig) {
        int[][] alts = new int[7][];
        alts[0] = rot(fig);
        alts[1] = rot(alts[0]);
        alts[2] = rot(alts[1]);
        alts[3] = mirror(fig);
        alts[4] = mirror(alts[0]);
        alts[5] = mirror(alts[1]);
        alts[6] = mirror(alts[2]);
        int[] rfig = alts[0];
        int[] cmps = new int[7];
        for (int i = 0; i &lt; 7; i++) {
            if ((cmps[i] = Arrays.compare(fig, alts[i])) &gt; 0) {
                return 0;
            }
        }
        if (r == 0) {
            return 1;
        }
        int sz = fig.length;
        int qtfc = (sz % 2 == 0) ? c1q(sz, r) : sc1x(4, sz, r);
        int htfc = (sz % 2 == 0) ? c1h(sz, r) : sc1x(2, sz, r);
        int idfc = c1(sz, r);
        int[] fsc = new int[] {qtfc, htfc, qtfc,
                myf(r, sz, fig), mdf(r, sz, fig),
                myf(r, sz, rfig), mdf(r, sz, rfig)};
        int gs = 1;
        int allfc = idfc;
        for (int i = 0; i &lt; fsc.length; i++) {
            if (cmps[i] == 0) {
                allfc += fsc[i];
                gs++;
            }
        }
        return allfc / gs;
    }

    private static int c1(int n, int t) {
        int v = 1;
        for (int x = 1; x &lt;= t; x++) {
            v = v * (n+x-1) / x;
        }
        return v;
    }

    private static int c1h(int n, int t) {
        return c1d(n, t, 2);
    }

    private static int c1q(int n, int t) {
        return c1d(n, t, 4);
    }

    private static int c1d(int n, int t, int q) {
        if (t % q == 0) {
            return c1(n / q, t / q);
        } else {
            return 0;
        }
    }

    private static int sc1x(int m, int n, int t) {
        return c1(1 + n / m, t / m);
    }

    private static int c12(int s, int d, int t) {
        int sum = 0;
        for (int i = t/2; i &gt;= 0; i--) {
            sum += c1(s, t-2*i) * c1(d, i);
        }
        return sum;
    }
}

public class Main {
    public static long count(int n) {
        return new PolyominoVisitor(new BuildingCounter(n), n).compute();
    }

    public static void main(String[] args) {
        if (args.length &gt; 0) {
            System.out.println(args[0] + &quot;: &quot; + count(Integer.parseInt(args[0])));
        } else {
            for (int i = 1; i &lt;= 99; i++) {
                System.out.println(i + &quot;: &quot; + count(i));
            }
        }
    }
}
</code></pre>
<h3>Invocation</h3>
<pre><code>javac Main.java
java Main 17
</code></pre>
<p><a href="https://tio.run/##tVp9b9s2Gv8/n4IrsEGqZcd20mZpXna9YsMV6G7Fsu4OKIyDLNE2E1lSRTm228tn7/0ekpJFmXKyDWeglU0@b3zeHyq34X3Yv43vvn4VyzwrSnaLhcGqFMngdVGEW3lxtLcRZWm0KgqeloNfOb5Jcc9/C@WdA3S2SqNSZOngbVq@L3gsorDkj8B9SMNi@0vOi7DMikOw77J0frPK80Twg3C/ZQT5k/l5cXR0/Pz5EXvOPgBKlFu25OUiiyWbZQVbZ8WdSOdsLcoFC1Mm0pKVi7BkBc8LLnFmyUKWh6Jg2YzJBbG8D5MVlwOQPD6KklBK9j4jvC9HDB9ZhqWI2EykYaLIYQFIVyz3hgEb@hdOqI8TlnIxX0yzQgI25Wuz@qU/3IyG@ASMvoGC@Y/WHnC4BjXitvHo/9w30tCn4OWqSJmXs@trNnrpsz7wT4GuRXnYo7HtpqE04Hv540RyRWQTaIouWt6G9QwRn11eKtH@y7ztbrWLdpGVnSLmXn8L@QJoIvc7KSxFUWTFISIbRWTbJPJQu9LPIhVLWC4vxFKUiAcWUvT0p6HkMYuyJOHK@Swvga/rGDP8QIu9QWwhRFL8k3A8zngak6fR15koZKkJa/@kxSmfizQllzVQkiM@4wGxsc8I51G4moVnVrQ9wl9mM8nLwMBN9er0HU@bylCQWJuD9xULB4n@2q/QL5qQIIOAWSVlw30r5J4iPdnB32xlyZcDJV@U5VsPctUyaTJw8qDi7h/AnCrACscgBPosF227ajDLKcgKr@OYwpzEVsHNygw/JVwd1jQyET6pnXROgOawLrUDAxS9@ofWLii3lIvdWDb1BdhKyT02mlj6ZQKAw90SZS/vAquXrIH23Xf066OYYBkMsd/rNbnSBzwJ4MpA7kg@HO2BEI3DLLtZqDMcZGOsAmjLJIiqewSEK0lSwPFWhrQ4vwjYWcBGyJGjE/yj7@cBG@P7GM8TrJ9g7RTPU6yd4vsLPF9g7@UosCi9xN4Z4M6wf4b97/H8Hs9zojkkBkPiMFQ/z4kn/RzTz5ORPs5F7WKaMjwtSTIKeKo1OrKTsJhT2Ger@YL8bpElMZxvJjY87kdhHkZUsxahxG44TXhFCVFfhkK55DPJefqM5VSFdFmb85TqKW3mWbLNliLNpKpg4jPcd2CIOHx3Gd7xf4DZb8RL5cfUkR8r7WtzfOx7OrENpoKK@Q0Pi2jh6c2ApZD2xCdv8CeTvdh7m0pelI7w2x2Z4qefJ2HEWyLfZyJWcJqIibgaxxVz0Ae5j4cdiDU6OfPZtxrD@HOgC/Z7BQbgRhDOmKcgP2J5wr5BOLb9fr0QCUdlq8GIFT3o8C1GE99JouKkkK9qYVxg9CkXRbZWqnstSQcoOj@q0vZM8WKzVZI8ayTC/SC0f@2@NY7ayAMNy71Z8OhO4szop3hhWazyTl3TZM4jMRPIpdq8thGnWZZwhANhvzFo/2dLGjOVxYq39UqEqdsFyk4BtvrIOhrkSotlgoLIdUMOa7hZmMgW4GFP2Sf6BOf4M47RdoNmy1O3/sm2Si9IxKpF0E1N3TFT1mm0QJR2VIMsA6ITooHfEghynGnRKd55GC1MRsSvKFvmK8qSLEErj7KOrkhrz3jUakm0QDlMEvwCrqsrN5nvdyEFZgvGN@i0UOmtKeaShoVro8A2imfPEpc/gBcmFZ0rr9UBtHtaSbJcCOnpvVR1JygWVcYcToJdIziws23q7@AmX5TOBsrED76zPv5BaUO1auQNnNnECgOhQRNqcatOcYX@NqjbHJ7W62lZIMDbWlBDGfWOZhSz9lIq4621aljyMGBcs3s6lwc5jAyau@ZbcXRqRrcMVWZRZG7QrydcxXUdpzb447Z2YSltujaa46qOVNMO/O2Xe14UIuYGKSsRKUiOhFB5vucouorGYI7mUhKo5z46BUyluL9uRE0Np7F6T0pBRKTRrFI6Stt56PgYsiOwcbjdqELxjfiETBzJBObM2BoFgxoiSg169DFGaFOLRQFdJSpHZKuCRUjkccFtuEabqo7t7FDpQ@fqXSlmA8XbKHYXn6aT1woz6kEv63fnTcaR3B0KeglpUmrPlUiYoQS7vmJjh8Z4IuaCMjTOKOE9pQXQjnlVJeVd1RLvbdfsWkVMKYk841aZFo9LTahu62/dSlNAH28nHQzrvNeZX2guuA30gzynK6yPutsVkd5ndxy9tKek8R1H20v@BMleafH9yvT0iyLq13D9q5rnvBYtE3rWGGRs7HD1XYVUAeh2z@q2BxwRGqoW78aZ05aZmvdoALiBjqiZoeT4zc5NrdZJ6zF3KeUpQaEaINRbERPLq4bXX7hgcRR1SkB2hE1NzHcS0BmC1PAmAy@lC3MR5tWogTl7YOnN75IIQEZTpIxBhCzGPQe0KwhscUwY2Ko204bhYsuEyDgk1getTUtbzVsao20dHiObdNCSzcHHuLVO/8OgwbHuiZW1AtYU/oNVSg/NBJTXrGqKhNbMc9dsuMtxV7XzmO22u3XlX6LoH7gvcAwj1VT8r0LAa6mEzKGskhf9chGm/axATk0bV6zm8myOaE314FxRULe/OfWPBIDqfI9KHePLLgqRmK09ZcCgImBfFUXKqdcQC72nPXe3rjlUI1G7vhpwAjv@SYZgd3HUnociEz/tSyLay9TdGvKf7iprPq7xR2eYnsHZHz5SmLnRnJLBSbIB5gEEhe9KKnQfpMTr9SZ219flacbUCmn//vWnenIga5meSbIFJp5lmG7ZdAUnhwkkbKOGUYmmL9KDD7BCbXiiVF@PMLq7HdCFrIRR4SJyu1zystg2L/@GpAB9NztfgbKQLM3ojQEnWkhXWQpTJQwNniTxPDEATeQMuk40IVMWYSphmGVIJ/BpYiHk13GYUxeo7oNQQXBCeO4cK7MiW2LYLoQsBbqkG8GJPOEsyjKXr46Poyzm8yyZkUGiO77RmAPo5Tg8Hp2fn4/OG3PR341yVBKhBneZJ3ypXnW0WmDT@n7pbnv1zmqawIFbdD3nXNTs@h@c/bAmphrPZlLQbg@9OzpjHJRuntS4CffsE1id8Ajl0PVide@V71iouLPeS6kktX99u3fjvWM8cUShvsJVRXgH6KzEmrC@g23mR8jlAZV60AMJ0nHN7Tx0Sl6YiM/8bfqertfcSq6KelYo3r59LU21jCQaTqD3Rlr4S8fXR2T9KxYfOCagHj@jeVdEd8fSdZPZVgE5Qi4DfZRXr4DuP8V96vdJf5aRpvAoL7bczpQyCz3Yyc9VRWhZTcGGG91p8DkvBj@//ed/fn/97sOPDtPkKA0tAvVdE9I9CPmGWu4yCJFYY1Pbf@MRvD0urtm3bGzuwfZLzppeMK3ZMRtf7O0tt1O7qD1F8IptJVDuE@81WhCQ6/UuDgwXVU4ZjT3ABsyTn@HZ@Oofj1EL/EcGgRp94ZFtir04PWDa@OmmTbKmZV//@w9bll50L/PaZvSic7/UEwQGhszX/PCzy/rLeNrRehxwLds6O0Ggb@IJmk1T7TcHZKJYm6iPL5aB3GpOzB3LrlzsFO5U9McJvTVNyuY7pzOs7cSiTcp@VyrV2AlS7Y2qPQPZ3h9b@6O9/RPaNwnGQf60sd3B4UUbZJ/JyzbIeOLvvd8Fd7rM00zau9Eyt5V0uAKcORM/eYVHlHTpM6WHGjw0cp4qzYo93cHQtOGKe@Mdw6eNM4UzKRkaoy53R064ahYxa/NTOaNLT0ocu6T3A9z1k0kJiAgZjTbeacDaOYLwF134ixb@2I0vYoUfjTzHLnm5jOw3qCRwoNgGSvj9yxuqOoXmRi4YqFzVXDiEUeyhqJUHW@o5ec/IXkPHrI5CJ3qkoZDRoYZCvYmp3KrjrZtmRgOpjJzXHXPZXTn2kpOmdgykxyo67KSv5HVSbmf6e1st9eE3ah2PSyRmPPcPTZj3GBO8tLfpj3wIszk0VT8u56JT0Dojxx62y4CN/cfJfXo6udMnkIstcvrxydImVTSE1KdDIQ9rpNDUJ7ClxxPL/fDpVV5FriqZ1auYA@f3RhjESZ6llmf5BD2MFXWpycYdXiVXy456TUFVHo8v9A01hVe/39YVYfd0hoFc/fFz4dP8O/KI3aHJBIiNad7Menos/TkUaTVq6nW7ZmOoPPj3CHs30bTYnknVKzZ/UL9lsbVpsVV/XLCEUN5NWYCE@nuquWw7FK01rr/amjJ/r5StygGMlZZJqjCoYeixZ6/YMzz02apmDpVOcprzDJzvP@aDlulGKh9esfPzziteh0yiLY3wH383/PXr19H4fw" rel="nofollow noreferrer" title="Java (JDK) – Try It Online">Try it online!</a></p>
<h3>Results</h3>
<p>(when run without an argument)</p>
<pre><code>...
16: 438030079
17: 2092403558
18: 10027947217
19: 48198234188
20: 232261124908
21: 1121853426115
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.haskell.org/" rel="noreferrer">Haskell</a>, <span class="math-container">\$n=16\$</span> in about 9 minutes</h1>

<p>As observed by @xnor in the comments, we can break the problem down into two parts: generate polyominoes (where I reused a lot from <a href="https://codegolf.stackexchange.com/a/188338/56725">here</a>, then count the ways to distribute the remaining cubes.</p>

<p>The symmetries are accounted for by using <a href="https://en.wikipedia.org/wiki/Burnside%27s_lemma" rel="noreferrer">Burnside's lemma</a>. So we need to know how many buildings of a given symmetric shape are fixed by a symmetry. Consider for example a shape has one mirror symmetry where the axis of reflection goes through <span class="math-container">\$s\$</span> squares of the shape and the reflection identifies <span class="math-container">\$d\$</span> pairs of further squares of the shape (so its size is <span class="math-container">\$s+2d\$</span>). Then the buildings of this shape with <span class="math-container">\$r\$</span> additional cubes that have this symmetry correspond to the solutions of <span class="math-container">\$x_1+\dots+x_s+2y_1+\dots+2y_d=r\$</span> with nonnegative integers. The number of solutions is added to the total number of possibly equivalent buildings, and the sum divided by two. Note that a rotational symmetry always fixes zero or one square of a shape.</p>

<p>Compile the code with something like <code>ghc -O2 -o buildings buildings.hs</code>. The executable takes one optional parameter. If it is given, it will compute the number of buildings with that many cubes. Otherwise, it will compute all values.</p>



<pre class="lang-hs prettyprint-override"><code>{-# LANGUAGE BangPatterns #-}

import Data.List (sort)
import qualified Data.Set as S
import System.Environment (getArgs)

data P = P !Int !Int deriving (Eq, Ord)

start :: P
start = P 0 0

neighs :: P -&gt; [P]
neighs (P x y) = [ p | p &lt;- [P (x+1) y, P (x-1) y, P x (y+1), P x (y-1)],
                       p &gt; start ]

count :: Int -&gt; Int -&gt; S.Set P -&gt; S.Set P -&gt; [P] -&gt; Int
count 0 c _ _ _ = c
count _ c _ _ [] = c&#32;
count n c used seen (p:possible) =
  let !c' = count n c used seen possible
      !n' = n-1
      next = S.insert p used
      !sz = S.size next
      !c'' = c' + combinations n' sz (S.toAscList next)
      new = [ n | n &lt;- neighs p, n `S.notMember` seen ]
  in count n' c'' next (foldr S.insert seen new) (new++possible)

class Geom g where
  translate :: Int -&gt; Int -&gt; g -&gt; g
  rot :: g -&gt; g
  mirror :: g -&gt; g

instance Geom P where
  translate !dx !dy (P x y) = P (x+dx) (y+dy)
  rot (P x y) = P (-y) x
  mirror (P x y) = P (-x) y

instance (Geom g, Ord g) =&gt; Geom [g] where
  translate !dx !dy = map $ translate dx dy
  rot = sort . map rot
  mirror = sort . map mirror

normalize :: [P] -&gt; [P]
normalize fig = let (P x y) = head fig
                in translate (-x) (-y) fig

-- fixed points of horizontal mirror symmetry
myf :: Int -&gt; Int -&gt; [P] -&gt; Int
myf r sz fig =
  let w = (maximum [ x | P x _ &lt;- fig ])
      wh = w `div` 2
      myb = sum [ 1 | P x _ &lt;- fig, x == wh ]
  in if even w -- odd width!&#32;
     then c12 myb ((sz-myb) `div` 2) r
     else c1h sz r

-- fixed points of diagonal mirror symmetry
mdf :: Int -&gt; Int -&gt; [P] -&gt; Int
mdf r sz fig =
  let lo = minimum [ y | P _ y &lt;- fig ]
      mdb = sum [ 1 | P x y &lt;- fig, x == y-lo ]
  in c12 mdb ((sz-mdb) `div` 2) r

combinations :: Int -&gt; Int -&gt; [P] -&gt; Int
combinations r sz fig =&#32;
  let rotated = take 4 $ iterate (normalize . rot) fig
      rfig = rotated !! 1
      mirrored = map (normalize . mirror) rotated
      alts = tail rotated ++ mirrored
      cmps = map (compare fig) alts
      -- All fixed points computations assume that the symmetry exists.
      -- fixed points of quarter turn:
      qtfc = if even sz then c1q sz r else sc1x 4 sz r&#32;
      -- fixed points of half turn:
      htfc = if even sz then c1h sz r else sc1x 2 sz r
      -- fixed points of reflections:
      mirror_fc = [ fun r sz f |
                    f   &lt;- [ fig, rfig ],
                    fun &lt;- [ myf, mdf ]    ]
      -- all possibilities, i.e. fixed points of identity:
      idfc = c1 sz r
      fsc = [ qtfc, htfc, qtfc] ++ mirror_fc
      -- fixed points of symmetries that really exist:
      allfc = idfc : [ fc | (fc,EQ) &lt;- zip fsc cmps ]
      -- group size of symmetry group:
      gs = length allfc
      res = if r==0 then 1 else sum allfc `div` gs
  in if any (GT ==) cmps
      -- only count if we have the smallest representative
      then 0 else res&#32;

-- Number of ways to express t as sum of n nonnegative integers.
-- binomial(n+t-1, n-1)
c1 n t = foldl (\v x -&gt; v * (n+x-1) `div` x) 1 [1..t]

-- Number of ways to express t as twice the sum of n/2 nn-integers
c1h n t | even t    = c1 (n `div` 2) (t `div` 2)
        | otherwise = 0

-- Number of ways to express t as four times the sum of n/4 nn-integers.
c1q n t | t `mod` 4 == 0 = c1 (n `div` 4) (t `div` 4)
        | otherwise      = 0

-- Number of ways to express t as an nn-integer plus m times the sum
-- of n/m nn-integers
sc1x m n t = c1 (1 + n `div` m) (t `div` m)

-- Number of ways to express t as the sum of s nn-integers
-- plus twice the sum of d nn-integers
c12 s d t = sum [ c1 s (t-2*t2) * c1 d t2 | t2 &lt;- [ 0 .. t `div` 2 ] ]

count_buildings :: Int -&gt; Int
count_buildings n = count n 0 S.empty S.empty [start]

output :: Int -&gt; IO ()
output n = putStrLn $ show n ++ ": " ++ show (count_buildings n)

main = do args &lt;- getArgs
          case args of
            []  -&gt; mapM_ output [1..]
            [n] -&gt; output (read n)

</code></pre>

<p><a href="https://tio.run/##jVdZb@M2EH73r5jsFlhpfdQ28mTUC6RoEBTYI4Xbp9RIFImWiZUoRaQPpelfb/oNSdly7OxuAlv0cI5vTlLLSH8VWfb8/E//LX28@Hz118XVJf0aqfQ6MkZUStPb/r@djszLojL0W2SiwUepDQUav8OG/rCKMrmQInEcM2Eo0jRrtme1NiIfXKq1rAqVCwX5VJiLKtVhp5NAhK5pis/Z79iyX4mo5FqqlILLhx59qRIwahNB2WRC137JIkMadjpKyHSp7Rb1P9DN9bwhBde0pToE6w2V9ITPL33sU7DtjkKqe8TLfrPcUlCD3ixBn/c6dPqvpA/kYMw7nbhYKQuNsQOBf8xsKK5fLAHP83i5IcV0a/@nFHvarafdzJlInqqwXGnEWQuhKCgnZaG1vM8EPATQDCbO4ncscYK94fUenSlmVP2R/63ElkM6G0ilBdwqrWjDrB/tnpaPwnI29PidNfeOurCZ30sVGVmgbKAcIsFsYIoLHduaYbFwZ2xjc6KQE8U58fkqe/h5NxuownwS@b2o7hz2OeSkatx6R2zWAg4WRZZUe9SWG9pDCvDd7e4ChCRlkdZ0JYqcUtosRcWRMFWkdBYZcZy91H6Bpypsbne/c1lVRdUidWDcRCoWTvv1Ce1nyRafulWQtgiTbcg1l9Sht3Ow38diuzd4uAfJumU5cI7ZZqEUTB8cmJt0/g04U8qjkn5q7WAjqT2YKXGb08AygbCHcrDjaGjDosoxCB5tLH2V217c0RcyhSiX6d6XpYgS3jhqNOR7D8v6awPCrJ1@H88tKrsspDKaigUti0o@FspEWQNS13kuTFV38npxnN5WG/J@xfVq8flG4gIN8mgr8xWiCLRPdizccrUy37yp5c0SnBu6S@T6jsaemNf3HCQrOnoh2sN6OmU5X9ZyQWKNut0Q/CqShDYyMcszcrrMElvxaGx1BoF@7GMRNvZCqhybyLQA25L9qE5GKJFRWqhT8Um@E5/kRHyygqtHKh@f2jp5i2cTnyYSyXEk6sNI1H0oa1qcHU0aR5NDRzsHM@ZbkA8Y99jJg0cxo6oSEEz0VdA5WkDivLOVti/XAfOFreKsnJJG@uyMmunpQmo1ckscKHF7YSPmJaIMWWH7Mtsp7HZ3ijxXnJe60QmfyqiyXRRacc@DVF9k2WG6mXdlvP@Ye6tcoJAiw9W0SzyJLQazHuz1vCwZnOwV4kJmVamJZ3swixiQmqJFaH2FPtjSc4Wo49EWYbWE19Uvo2xxoHv5mu7lS91jV@evqq7EIhOx9X9ykKNba@GGFivlC4OeTh7yC3z4tuAK1ab@lesAq7KcGCQ94m6ZM3m@RxchP@4okpk0UugeyYEYHKGWCW5H0tQNZJlYtPGo7e1COw84ET0bsp5dz/f1AydfD41PP1C4kqgE4PlimOyqM3OZYAATDkKM3g1g6vKPkJ19lKUFYgu05WlaFauS7D1hb6p25EZ5qu0poFKzdIaa9hLaJb@aTocu8yOfcowPB8lNg1TvJmekcKpe/Yk5EloweyiFglfuygC@jUC5rYVrAPRmJjS7XsIoYo5OWTc3I2t46AwzJDtMP6/4OsI@baIagSsQL5bFki@7DBB7uHsUSonUqgNAI1JRocGgAOOoyGWUBapr@qMe37zCDhKLUw5O8zUmo@DvNSYiRtia3mOGdO3V1HmM429EN6PBwMx/BI/ZyNj76pH9PCal@g2kDrcUm35ynWbYcVtogdpP3MDs1rvCf6ICaquNRHSmfPv@PphFscIIkbktuBai8zaiQYcniIMEs3mR3GGA4HQYvsB13sJ1fhoXOW9@CFykWiiozFaa8kOwrMTizQ8iaMdQ7vPHAEe4BDcg8xbIPPyhjO0jow/sQNSiOkpp8iKhGImgmd1py1MDKPrj9wa5fM@/sT3m@I7dvBrSYEC7HGNqNe8yt/crmSV4AXtxyh7tqtbLxhDXcJGXpt49b@wbEpQWK4PjqK3rCwVhQ2YleM5M9VHhJNbLYgMahtmbCb3hp6UER7YR1zySLJ0UFOF1kr3yb5atQR1HKAm7XSwO5jderhgLDtdPt@SxcIvND7mUvVX4/aDi@ypMPz8/j8b/xYssSvVz/8v4fw" rel="noreferrer" title="Haskell – Try It Online">Try it online!</a></p>

<h3>Results</h3>

<pre class="lang-hs prettyprint-override"><code>15: 92038062
16: 438030079
17: 2092403558
18: 10027947217   (2 1/2 h)
19: 48198234188   (10 h)
20: 232261124908  (40 h)
</code></pre>
</div>
<div id="pu3" class="pu"><h1>Java 8, <span class="math-container">\$n=14\$</span> in 2m31s<sup>1</sup></h1>
<p><em><sup>1. Using the AdoptOpenJDK8 distribution, on a <a href="https://ark.intel.com/content/www/us/en/ark/products/189912/intel-core-i5-8210y-processor-4m-cache-up-to-3-60-ghz.html" rel="noreferrer">2-core Amber Lake Intel Core i5</a>-based Mac. On an <a href="https://aws.amazon.com/ec2/instance-types/m5/" rel="noreferrer">Amazon EC2 <strong>m5.xlarge</strong></a>, takes <strong>1m16s</strong>.</sup></em></p>
<p>This takes an inductive approach where, for each rank, it builds off all the buildings of the previous rank by placing cubes in all legal positions (on top of and next to existing cubes), and then removing buildings that are (possibly transformed) duplicates of other buildings. This means that to enumerate the buildings in a rank, all previous ranks must be also be computed. Both compute time and memory are constrained resources — this algorithm relies on keeping millions of Building objects in memory — so I've had a hard time computing beyond <span class="math-container">\$n=14\$</span> on my machine even without the 10 minute time limit.</p>
<p>This solution includes a parallel-Stream-based approach (which can be enabled with the <code>parallel</code> JVM system property) which is faster on a multi-core system but also more memory-hungry. This approach was used for the timing results above. The non-parallel approach takes almost twice as long to count <span class="math-container">\$n=14\$</span> but is able to do so using only a third of the memory.</p>
<p>Garbage collector settings and tuning can have a significant impact on the runtime and ability of the process to complete. I've also tested with OpenJDK 13, but for whatever reason have seen the best results on 8 so far.</p>
<pre class="lang-java prettyprint-override"><code>import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

public final class Building {
    /**
     * A flattened two-dimensional matrix of heights (see toIndex).
     * Buildings are always assumed to be &quot;aligned&quot;, such that they exactly
     * fit within their (width, height) bounding box.
     */
    private final byte[] stacks;
    private final int hashCode;
    private final byte width;
    private final byte height;

    public Building() {
        this(new byte[]{1}, 1);
    }

    private Building(byte[] stacks, int width) {
        assert stacks.length % width == 0;
        this.stacks = stacks;
        this.width = (byte) width;
        this.height = (byte) (stacks.length / width);
        this.hashCode = 31 * width + Arrays.hashCode(stacks);
    }

    /**
     * Return the building created by adding a cube at the specified coordinates.
     * The coordinates must be within the current building bounds or else
     * directly adjacent to one of the sides, but this is not validated.
     */
    Building add(int x, int y) {
        if (x &lt; 0) {
            byte[] newStacks = widen(true);
            newStacks[y * (width + 1)]++;
            return new Building(newStacks, width + 1);
        } else if (x &lt; width) {
            byte[] newStacks;
            if (y &lt; 0) {
                newStacks = new byte[stacks.length + width];
                System.arraycopy(stacks, 0, newStacks, width, stacks.length);
                y = 0;
            } else if (y * width &lt; stacks.length) {
                newStacks = Arrays.copyOf(stacks, stacks.length);
            } else {
                newStacks = Arrays.copyOf(stacks, stacks.length + width);
            }
            newStacks[toIndex(x, y)]++;
            return new Building(newStacks, width);
        } else {
            byte[] newStacks = widen(false);
            newStacks[x + y * (width + 1)]++;
            return new Building(newStacks, width + 1);
        }
    }

    byte[] widen(boolean shift) {
        byte[] newStacks = new byte[stacks.length + height];
        int writeIndex = shift ? 1 : 0;
        for (int i = 0; i &lt; stacks.length; i++) {
            newStacks[writeIndex++] = stacks[i];
            if (i % width == width - 1) {
                writeIndex++;
            }
        }
        return newStacks;
    }
    int toIndex(int x, int y) {
        return x + y * width;
    }

    boolean inBounds(int x, int y) {
        return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &lt; height;
    }

    /**
     * Return a stream of all legal buildings that can be created by adding a
     * cube to this building.
     */
    Stream&lt;Building&gt; grow() {
        int wider = width + 2;
        int max = (height + 2) * wider;

        return StreamSupport.stream(new Spliterators.AbstractSpliterator&lt;Building&gt;(max, 0) {
            int i = -1;

            @Override
            public boolean tryAdvance(Consumer&lt;? super Building&gt; action) {
                while ((++i) &lt; max) {
                    // Try adding a cube to every position on the grid,
                    // as well as adjacent to it
                    int x = i % wider - 1;
                    int y = i / wider - 1;
                    int index = toIndex(x, y);
                    if (x &lt; 0) {
                        if (y &gt;= 0 &amp;&amp; y &lt; height) {
                            if (stacks[index + 1] &gt; 0) {
                                action.accept(add(x, y));
                                return true;
                            }
                        }
                    } else if (x &lt; width) {
                        if (y &lt; 0) {
                            if (stacks[index + width] &gt; 0) {
                                action.accept(add(x, y));
                                return true;
                            }
                        } else if (y &lt; height) {
                            // it is on the existing grid
                            if (stacks[index] &gt; 0) {
                                action.accept(add(x, y));
                                return true;
                            } else {
                                // is it adjacent to a stack?
                                for (Direction d : Direction.values()) {
                                    int x2 = x + d.x, y2 = y + d.y;
                                    if (inBounds(x2, y2) &amp;&amp; stacks[toIndex(x2, y2)] &gt; 0) {
                                        action.accept(add(x, y));
                                        return true;
                                    }
                                }
                            }
                        } else if (stacks[index - width] &gt; 0) {
                            action.accept(add(x, y));
                            return true;
                        }
                    } else if (y &gt;= 0 &amp;&amp; y &lt; height) {
                        if (stacks[index - 1] &gt; 0) {
                            action.accept(add(x, y));
                            return true;
                        }
                    }
                }
                return false;
            }
        }, false);
    }

    Building reflect() {
        byte[] newStacks = new byte[stacks.length];
        for (int x = 0; x &lt; width; x++) {
            for (int y = 0; y &lt; height; y++) {
                newStacks[y + x * height] = stacks[toIndex(x, y)];
            }
        }
        return new Building(newStacks, height);
    }

    Building rotate() {
        byte[] newStacks = new byte[stacks.length];
        for (int x = 0; x &lt; width; x++) {
            for (int y = 0, x2 = height - 1; y &lt; height; y++, x2--) {
                newStacks[x2 + x * height] = stacks[toIndex(x, y)];
            }
        }
        return new Building(newStacks, height);
    }

    Collection&lt;Building&gt; transformations() {
        List&lt;Building&gt; bs = new ArrayList&lt;&gt;(7);
        Building b1 = this, b2 = this.reflect();
        bs.add(b2);
        for (int i = 0; i &lt; 3; i++) {
            bs.add((b1 = b1.rotate()));
            bs.add((b2 = b2.rotate()));
        }
        return bs;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Building building = (Building) o;
        return width == building.width &amp;&amp;
                Arrays.equals(stacks, building.stacks);
    }

    @Override
    public int hashCode() {
        return hashCode;
    }

    private enum Direction {
        N(0, 1), E(1, 0), S(0, -1), W(-1, 0);

        final int x;
        final int y;
        Direction(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    public static int count(int rank) {
        long start = System.nanoTime();
        Collection&lt;Building&gt; buildings = new HashSet&lt;&gt;();

        for (int i = 1; i &lt;= rank; i++) {
            if (i == 1) {
                buildings = Arrays.asList(new Building());
            } else if (Boolean.getBoolean(&quot;parallel&quot;)) {
                // Using parallel streams is generally faster, but requires
                // more memory since more Buildings are retained before being
                // discarded
                ConcurrentMap&lt;Building, Integer&gt; map =
                        new ConcurrentHashMap&lt;&gt;(buildings.size() * 4);
                AtomicInteger atomicInt = new AtomicInteger();
                buildings.parallelStream()
                        .flatMap(Building::grow)
                        .forEach(b -&gt; {
                            map.putIfAbsent(b, atomicInt.incrementAndGet());
                        });
                // Keep only the buildings that do not have a transformation
                // with a lower index
                buildings = map.entrySet().parallelStream()
                        .filter(entry -&gt; {
                            int index = entry.getValue();
                            for (Building b2 : entry.getKey().transformations()) {
                                Integer index2 = map.get(b2);
                                if (index2 != null &amp;&amp; index2 &lt; index) {
                                    return false;
                                }
                            }
                            return true;
                        })
                        .map(Map.Entry::getKey)
                        .collect(Collectors.toList());
            } else {
                Set&lt;Building&gt; set = new HashSet&lt;&gt;(buildings.size() * 4);
                // Only add a building to the set if it doesn't already have a
                // transformation in it.
                buildings.stream()
                        .flatMap(Building::grow)
                        .forEach(b -&gt; {
                            if (!set.contains(b)) {
                                for (Building t : b.transformations()) {
                                    if (set.contains(t)) return;
                                }
                                set.add(b);
                            }
                        });
                buildings = set;
            }
            System.err.println(i + &quot; --&gt; &quot; + buildings.size());
            long now = System.nanoTime();
            double ms = ((double) now - start) / 1000000;
            System.err.println(&quot;time: &quot; + (ms &lt; 1000 ? ms + &quot; ms&quot; : ms / 1000 + &quot; s&quot;));
        }
        return buildings.size();
    }

    public static void main(String[] args) {
        System.out.println(Building.count(Integer.parseInt(args[0])));
    }
}
</code></pre>
<p><a href="https://tio.run/##1Vptc9u4Ef7uX7HxTK@gJdGWrzOdiWynzjXTZq7XzNRp@yHjDyAJSUgoUiUgW@ydf3u6C4Dgi0hJTtrJVZOJKGCxWCyeXTwL@iN/4JN8LbKPyafPn@VqnRcaPmJjuNEyDc9mJzttcZ7Fm6IQmQ5/8I9/5mr5E18fK35QlOt8JePw1ny9zbRYiKJnxHyTxVrmGalWm1WvjNKF4CuUSFMR67xQwzJ35utQ/91mTd2zk5O5zHgKccqVgtcbmSYyW8DPJ4Cf87Mz8w1ncAvzlGstMpGAfswniVyJTKHVOHbFdSG3kM9hKeRiqRUwJQTo/G2WiG0QVjoq7Qp4IYCnj7zER0VrRqU5RAJOeSoXOMfpGNQmXoJeco3/iRLElsc6LStdc6nhUeqlzKhbFsAeZaKXY2dCAFG@ycxSonxbWXBuvteFfOBagF14VGrx4R6U5vEn9OqugMw0LBEZP@SJmA0oADP5YK@1CX1t@jdRKmPvDBY4Z9MH16NYJh6dVT9Pn8YwDazep5OWej@@tYCxMddY09SLThaIBSsTpiJb6CX8xsrB9TVczFomhFYQrltu8b1uGJipg@bavYhdcS3D2lOfOxO7o5ybcdz3U9xkO9EIbosCoeK7nbK2XxpY/ZvQm8LgAqIK0DGCXiPMohJ4Ylo4xBtEnMUXqLWI5VyiRJznBQqgtPLIfY8SjXZYbZQmuNYIBBf09YwGgAryAkSqRKUpkYUgHKMVH3lMAxD4eSYoeowdMhG4i9FGG5cA/styDQ8YFwktoA1lH6@4JkY7v7UAKJubL@fAtnAFF81G@jjkIN7uqv1Gj4uM6WIjGntDHy/0ocRVsGpnpsH9aNSWLKz3CcUeo370GOqR9bAn4yJv6A58@4xtT0pDy741tmzHBfrgagNyZCe9n@0MviuVFquQEwTjfF2yKtAuxtBd1rgdYcGuthJawdZZfOkxf9XRdGBVLkDIvndzb@E@Y9ysX6228lxX/QB43JnAEKfll0FnFzZHgnrOUXgQ1VtcyP8C2c0U5Uyz5kR5ngqegVrKuW7ub88CBkFr02wDtSb7F1IL42ZK4KQeXsEUXjaBN8e0ZBKGNIDErw7isGk06sKudlc9x2h078@JD/J@Nyxl86CxDxP0UQ/0mkqH4FQ/1bvRTAi2X5q8aqE2lBbd@GrjG6dYtV1uh2T22qTyw5pu0Jfw3Xeor3ry6cw2X3kqsPfk4mC5Gh0KPE0hFQuiEp4@GVYUo2l4BPUcbJU2c77h8WIOkmp0@wCxZPCqgvMNLIr8sUVJHJ8QBVx7hF@2AbfihDTmznzsDqw/icl2ndRin46SGsZzt05x9wtO5Da8jbAH@V6jsbaR4Xzj3UxfoXkybcxKnz@8exBFgea0Wh0NqzZZF@Vt8sCzWLCKhl@9Qg66xoXX3uGGqPdidylTAYyNRjLAbUYT@6TMdp/D@6LLQnCXBFpZwjpXkuZATmD4wAINHw/p4QoeBeIDv5t0QureAQa@6CAXkLgwjMPZoGhpRM@PEZUu2bSy@4D4EBnZPc3raLryrH54TDWuykTGJEzG93CzfzLPkW0RxuNYrDUjQmWWMbCOnnOBWNN@4aeT5/Ucw4uOZkEHHGX5z/@Hs5qM6VhsYLhgyYiJ0AWW2EqlKQIpwp7lrF@Vk4ZoXN/yFXmgmSi4PbdfHRxt6MIfTelCuSlBMuF/hVibbIRiwTEu8XnoEtMFwS4JySf0qzS/ytlxOohYVOfy9pJUBJQrVIdm2p6jd@zrd@7ZO3gY7sdJHBUurZifPCPmv8whRznhYOp77knQs9Dpr3SRJ4dbnHpTvQyS4jE0qxvHK/3lQCHmdGvIvqjKuO8pGra2aPBnEj7uFgte2ta8TfYL5a5495JhhOrPqgKnrjDaBeRzqoTems2hacBvuUZq/U3dNraZ0lFrImFdP5LEZLLfm6jj27nT3VljZDXKDGT3mcKlrjh1qJaP/4IHc0M0qpxsbiNM5w37fSMo/X5FU@KgWOyMIbp0j6EHfz0gUiEFd3QZ7C@Iv@8tgt1oZmaLpmGFkm6e8HJkSnTZK7fj2Ei1fNcuXToli/jXBoOevYs@4vog7175maoPS27s6E1RJJOTQLbBEuKXX2Ah9A/0FgA34wUOC@vfwUAWqj1fPWAZWDUGkM@6y/P3AL4arYrjHfS6uye3yOruyY/ruwLu9Vbz@p71VO3tq/3OJbvINqua6TQG/5Vd0M38GN6wKdWiY7ijlgk1/ZNNTFujDK3fJGxnPY0N0uMnG7xt8LfllE62s912ShzlwBWUcwp6TzvfxMihtJkMQ/JTc6I0xw1FyYLu8d01aMaz/L1ciWY49QZ4fVlhg5ferd0JCt2WX5pRNzVRd23s6I08e5uE6Om9PWrO6MDDFaUL1spWQTB4/fraBhYB3z2y0zUvOC4vPe2lt8iq/64I95WYu7gx9/YLkQlqLTFs0HmFvdUvENG4x6pP1yovBKwEfpWAamNhW9rvzRC3XNJruEjMqTcS2NWnLZEq5kUidqub1jtMv2ljcO8ob2DF13A9SGbInztvTXFn/Q6ESv6bgu0MftdDnlrvQ4FXv6os3@xlPcPrWSqn2zslFgwaHNK7S7TR56aXL@mea9@AvHjD4yWLYHJzgDWir8L1Rr@d30YK3cGicb2mEDexECtsvs2SPwnN9pHJp54@3MYfhVhj0Yowar7QcpeASW5eDy35g8Bqrn2q9imjF1YomOaP6HrDjvfGEa0NjS/KO7L9OQ6XKSKembGHXdi8QzJDKAT/QWUlO0C@TQKpj6FLLEy9gh9FiTbvMI1j6sAKnMaoS@cIVNnmDPuLUzPyhTtesXhxLVf24dhqdJj@/zdLxOPrmD17jj5iGGThG9oAjDCzA3vkY3tusPqPGkKdm4QdHPuyik6U@sxRQu@cNkfmJAyNd5l5K5tgeHg6Yy7PhVGMmyop3oTKfquBpxgBSekCr09dG3e46Tg83JPM1DdNYgTZF7hM@vMVOl4Ui44KlHb8aQy/6MsizhfuTRu0Z55fC336kGrD@4MvvnjcdxxRUSX0vtegjkMhRw2RYGY6RZKHhdkpTHB/TvGpC9bOdIaQZfnjfjpGnyRHnofsgYxizP4KzNCJZXQBnMP0wnxmh2w81TjDS2MgQ41XZiC8Iu1k/Eqd4rbjD6vRtKnT/VVOZ52zYYr6kMsEs6/MGB46OASLb14sVBNSzuR8o73JFSJDy25dOqfzSwn8wUjFh4t7X4s9nTydfHYT27@E@gmndHM82yA/uxEzvY1pPk8v/wM" rel="noreferrer" title="Java (OpenJDK 8) – Try It Online">Try it online!</a> (non-parallel, up to n=12)</p>
<h3>Invocation</h3>
<pre><code>javac Building.java
java -XX:+UseParallelGC -Xms14g -Xmx14g -Dparallel=true Building 14
</code></pre>
<p>ParallelGC is the default on Java 8, but is included in case you are using a later version JDK where G1GC is the default.</p>
<h3>Output</h3>
<pre><code>1 --&gt; 1
time: 0.410181 ms
2 --&gt; 2
time: 97.807367 ms
3 --&gt; 4
time: 99.648279 ms
4 --&gt; 12
time: 101.00362 ms
5 --&gt; 35
time: 102.4856 ms
6 --&gt; 129
time: 105.723149 ms
7 --&gt; 495
time: 113.747058 ms
8 --&gt; 2101
time: 130.012756 ms
9 --&gt; 9154
time: 193.924776 ms
10 --&gt; 41356
time: 436.551396 ms
11 --&gt; 189466
time: 991.984875 ms
12 --&gt; 880156
time: 3.899371721 s
13 --&gt; 4120515
time: 18.794214388 s
14 --&gt; 19425037
time: 151.782854829 s
19425037
</code></pre>
<p>(For reference, <span class="math-container">\$15 \rightarrow 92{,}038{,}062\$</span>)</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://nodejs.org" rel="noreferrer">JavaScript (Node.js)</a>, <span class="math-container">\$N=10\$</span> in 4m02s<sup>1</sup></h1>
<p><em><sup>1: on an Intel Code i7, 7th Gen</sup></em></p>
<p>This only includes some trivial optimizations and is therefore quite inefficient. It does at least confirm the results listed in the challenge.</p>
<pre class="lang-javascript prettyprint-override"><code>function build(n) {
  let layer = [],
      cube = new Set,
      count = 0,
      x, y;

  for(y = 0; y &lt; n; y++) {
    for(layer[y] = [], x = 0; x &lt; n; x++) {
      layer[y][x] = 0;
    }
  }

  function fill(k, alignTop) {
    let x, y;

    if(k == 0) {
      if(!cube.has(layer + '')) {
        let transf;

        count++;

        cube.add(layer + '');
        cube.add((transf = rotate(n, layer)) + '');
        cube.add((transf = rotate(n, transf)) + '');
        cube.add((transf = rotate(n, transf)) + '');

        cube.add((transf = mirror(layer)) + '');
        cube.add((transf = rotate(n, transf)) + '');
        cube.add((transf = rotate(n, transf)) + '');
        cube.add((transf = rotate(n, transf)) + '');
      }
      return;
    }

    let y0;

    for(y0 = 0; !layer[y0].some(v =&gt; v); y0++) {}

    for(y = Math.max(0, y0 - 1); y &lt; n; y++) {
      for(x = 0; x &lt; n; x++) {
        if(
          !layer[y][x] &amp;&amp; (
            (y &amp;&amp; layer[y - 1][x]) ||
            (y &lt; n - 1 &amp;&amp; layer[y + 1][x]) ||
            (x &amp;&amp; layer[y][x - 1]) ||
            (x &lt; n - 1 &amp;&amp; layer[y][x + 1])
          )
        ) {
          for(let i = 1; i &lt;= (alignTop ? k : k - y0 - 1); i++) {
            layer[y][x] = i;
            fill(k - i, alignTop || !y);
            layer[y][x] = 0;
          }
        }
      }
    }
  }

  for(y = 0; y &lt; n; y++) {
    for(let i = 1; i &lt;= n - y; i++) {
      layer[y][0] = i;
      fill(n - i, !y);
      layer[y][0] = 0;
    }
  }

  return count;
}

function rotate(n, layer) {
  let rot = [],
      x, y;

  for(y = 0; y &lt; n; y++) {
    for(rot[y] = [], x = 0; x &lt; n; x++) {
      rot[y][x] = layer[n - x - 1][y];
    }
  }
  return align(rot);
}

function mirror(layer) {
  return align([...layer].reverse());
}

function align(layer) {
  while(!layer[0].some(v =&gt; v)) {
    let s = layer.shift();
    layer = [...layer, s];
  }
  while(!layer[0].some((_, y) =&gt; layer[y][0])) {
    layer = layer.map(r =&gt; {
      return [...r.slice(1), 0];
    });
  }
  return layer;
}
</code></pre>
<p><a href="https://tio.run/##xVbBcpswEL37KzaXIAbM4FunxOmpx/bS3jyeDrFFrBoLjxAOTMK3uysJgcCJm04O9YwN3n37dt9qWft3ekrLjWBHOefFlp69qqRQSsE20kvOWcU3khUcHiqWbwn34XkGkFMJedpQAUtYrUO0qNemeqBo4PQJflDZW4uKSzTH1lCH0CQz/JIVgjTKk0ADd8DxEgQmgXHqFKtmbbJAbbC1wdYDFsAiV/Vag7S5nam3SmRFZCzPyT6ENGeP/GdxtARKT18WAMvIHpbIMyRA043SF@3S0tQFAXiePyAMixQpL7OOp5cfBK5F0aTbrUuTXHqJoUI5opCppISHRibm/JcYY/pg0LWoAxPCHtb/qO0DQW13FVRWgtup6UeiiTvlelJjM3433azF66gsDpScYHkPJx@HN9YT2TohGPEtlbvokNYkxvmKYQ4L/7VxNwFXJlyPYH8PfRl65G9vwfUBYGq0dRCVVMF8eHmZojCRcrvo4C107aAQoWlfQ11yKrSi9R3ocO@K7B58bD7DXiwSvNwtgdgHFr7AHj7jez40k43bdLkOWDJymiWAwWxYBKgCbho/ucISu852Nr1rJyvnr7ttIlG1rJmI6QuIRzK0AG4EOEWP0dMdaEbcrKNkhqZ@KU7XS7/h0THa7@9f3Bj5rrVtcKa/pnwly0wWOlwJvQJ9ZCqDP5YxWkM6wyhgFUWR9q0jQU9UlJT4EwYDdAiediynpHvSJs@7@9NR2vKjcscySboj6X8hbeoQSq2pfYub/MIW@yqBc5hDqo7PpDqkRyIU9Hm0xHQ2LCRnG0oWfgixbaOfjBupabADZzuO3IwjV@P4Ca/2pDYFL4ucRpJhiZ76NBvU2vPikXjfMdjDh5yrDQvz@b3@Zv81jPCK4SvfDlTt@Q8" rel="noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a> (up to <span class="math-container">\$N=8\$</span>)</p>
<h3>Output</h3>
<pre><code>N = 1 --&gt; 1
time: 10.352ms
N = 2 --&gt; 2
time: 0.935ms
N = 3 --&gt; 4
time: 0.877ms
N = 4 --&gt; 12
time: 2.530ms
N = 5 --&gt; 35
time: 9.060ms
N = 6 --&gt; 129
time: 33.333ms
N = 7 --&gt; 495
time: 157.160ms
N = 8 --&gt; 2101
time: 1559.707ms
N = 9 --&gt; 9154
time: 18555.900ms
N = 10 --&gt; 41356
time: 242855.989ms
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/198175/">198175</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




