<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::68186</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>070</td><td>Python 3.8 prerelease</td><td>250130T233903Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/278006#278006">V_R</a></td></tr>
<tr d-ix="1"><td>030</td><td>SM83/Z80</td><td>210711T172305Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/231236#231236">NoLonger</a></td></tr>
<tr d-ix="2"><td>014</td><td>TeaScript</td><td>151230T173339Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/68201#68201">Downgoat</a></td></tr>
<tr d-ix="3"><td>013</td><td>Brachylog v2</td><td>190429T212935Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/184931#184931">Unrelate</a></td></tr>
<tr d-ix="4"><td>007</td><td>Jelly</td><td>220309T174015Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/243901#243901">Unrelate</a></td></tr>
<tr d-ix="5"><td>056</td><td>R</td><td>220324T160212Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/245541#245541">Dominic </a></td></tr>
<tr d-ix="6"><td>020</td><td>Vyxal</td><td>220324T140840Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/245537#245537">Seggan</a></td></tr>
<tr d-ix="7"><td>019</td><td>K ngn/k</td><td>201123T145945Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/215550#215550">coltim</a></td></tr>
<tr d-ix="8"><td>009</td><td>Jelly</td><td>201123T143141Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/215549#215549">caird co</a></td></tr>
<tr d-ix="9"><td>011</td><td>05AB1E</td><td>190429T071847Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/184909#184909">Kevin Cr</a></td></tr>
<tr d-ix="10"><td>013</td><td>Husk</td><td>201123T152624Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/215552#215552">Dominic </a></td></tr>
<tr d-ix="11"><td>046</td><td>Perl 5</td><td>190429T230147Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/184935#184935">Xcali</a></td></tr>
<tr d-ix="12"><td>150</td><td>C++ gcc</td><td>190428T095648Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/184896#184896">movatica</a></td></tr>
<tr d-ix="13"><td>079</td><td>Python 3</td><td>190428T084913Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/184895#184895">user8568</a></td></tr>
<tr d-ix="14"><td>136</td><td>Java</td><td>160112T111609Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/69229#69229">Minimal</a></td></tr>
<tr d-ix="15"><td>012</td><td>Japt</td><td>151230T205220Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/68227#68227">Mama Fun</a></td></tr>
<tr d-ix="16"><td>115</td><td>SWIProlog</td><td>151230T153546Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/68190#68190">Fatalize</a></td></tr>
<tr d-ix="17"><td>nan</td><td>Turing Machine Simulator</td><td>151230T211838Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/68232#68232">KoreanwG</a></td></tr>
<tr d-ix="18"><td>036</td><td>Ruby</td><td>160102T004812Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/68370#68370">daniero</a></td></tr>
<tr d-ix="19"><td>nan</td><td>Perl</td><td>151231T145345Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/68283#68283">alyx-bre</a></td></tr>
<tr d-ix="20"><td>048</td><td>Brachylog</td><td>151231T113303Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/68278#68278">Fatalize</a></td></tr>
<tr d-ix="21"><td>014</td><td>Jolf</td><td>151230T224404Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/68238#68238">Conor O&</a></td></tr>
<tr d-ix="22"><td>1425</td><td>ùîºùïäùïÑùïöùïü</td><td>151230T194159Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/68222#68222">Mama Fun</a></td></tr>
<tr d-ix="23"><td>111</td><td>Python 2.7</td><td>151230T193220Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/68220#68220">agtoever</a></td></tr>
<tr d-ix="24"><td>016</td><td>CJam</td><td>151230T155646Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/68192#68192">geokavel</a></td></tr>
<tr d-ix="25"><td>118</td><td>JavaScript</td><td>151230T173346Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/68202#68202">nicael</a></td></tr>
<tr d-ix="26"><td>014</td><td>Pyth</td><td>151230T181735Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/68208#68208">Blue</a></td></tr>
<tr d-ix="27"><td>072</td><td>Haskell</td><td>151230T175916Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/68205#68205">nimi</a></td></tr>
<tr d-ix="28"><td>040</td><td>JavaScript</td><td>151230T160312Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/68194#68194">apsiller</a></td></tr>
<tr d-ix="29"><td>155</td><td>PHP ‚Äì</td><td>151230T161628Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/68195#68195">user1525</a></td></tr>
<tr d-ix="30"><td>079</td><td>Ruby</td><td>151230T155913Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/68193#68193">Doorknob</a></td></tr>
<tr d-ix="31"><td>027</td><td>MATL</td><td>151230T155046Z</td><td><a href="https://codegolf.stackexchange.com/questions/68186/cracking-the-enigma/68191#68191">Luis Men</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://docs.python.org/3.8/" rel="nofollow noreferrer">Python 3.8 (pre-release)</a>, 70 bytes</h1>
<p>Throws an error when no occurrence is found.</p>

<pre class="lang-none prettyprint-override"><code>f=lambda a,b:[x==y for x,y in zip(a,b)]!=[0]*len(b)and-~f(a[1:],b)or 0
</code></pre>
<p><a href="https://tio.run/##TYtBC4IwGIbv/Yq10xYGRpcQdlE@m7BQZGEgHiY2EmwO8aAd@utrXaL3@DzPa9f5MZrjyU7OaTaoZ9sppII2qhfGVqTHCS3BinqDXr0lXtBmy@qw2Q13Q1qqTLd/a6LqQ9R45@vQ2ak3M9EEx/wM6a1KZXYtMsm5KEBKmYgcqhzEBQcIV55AGUOZJVxiSje/M/ztW3IQIveF@wA" rel="nofollow noreferrer" title="Python 3.8 (pre-release) ‚Äì Try It Online">Try it online!</a></p>
<h2>Explanation</h2>
<p>We can write <code>x if cond else y</code> as <code>cond and x or y</code>. <code>x</code> is a recursion step, <code>y</code> is the base case. The code recursively chops off the first character of <code>a</code> until <code>b</code> fits at the start of <code>a</code> without any matching characters. When we've found something that works, we return 0. Each recursive step adds one (<code>-~f(...)</code>), giving us a count of how many characters we had to chop off to get here, which is exactly the index we want to return.</p>
<p>The <code>cond</code> part be <code>False</code> in two ways: either the list comprehension contains a truthy value because some characters in <code>a</code> and <code>b</code> matched, or it is shorter than <code>b</code>, which happens if we chop off enough characters that <code>a</code> is shorter than <code>b</code>. By comparing the list comprehension to <code>[0]*len(b)</code> we check for both at once.</p>
<p>When there's no place where <code>b</code> can fit in <code>a</code>, we chop off characters until <code>a</code> is just the empty string, and call <code>f(&quot;&quot;,b)</code> until the recursion limit is met.</p>
</div>
<div id="pu1" class="pu"><h1>SM83/Z80, 30 bytes</h1>
<p>First input (encrypted) in <code>hl</code>, second (unencrypted) in <code>de</code>.
Output in <code>bc</code>.</p>
<pre><code>01 00 00 E5 D5 09 7E A7
28 11 1A A7 28 0A BE 23
13 20 F3 03 D1 E1 18 EB
02 FF FF D1 E1 C9
</code></pre>
<pre><code>ecr:
 ld bc,0                // 01 00 00 setup bc
oloop:
 push hl                // E5       store originals
 push de                // D5
 add hl,bc              // 09       handle offset
iloop:
 ld a,(hl)              // 7E
 and a                  // A7       test if at end of arg 2
 jr z,succ              // 28 11    if so succeed
 ld a,(de)              // 1A       load encrypted char
 and a                  // A7       if at end
 jr z,fail              // 28 0A    fail
 cp (hl)                // BE       compare to other side
 inc hl                 // 23
 inc de                 // 13       next char
 jr nz,iloop            // 20 F3    if unequal, loop
 inc bc                 // 03       else inc offset
 pop de                 // D1
 pop hl                 // E1       reload originals
 jr oloop               // 18 EB    and jump back
fail:
 ld bc,-1               // 02 FF FF insert failure
succ:
 pop de                 // D1
 pop hl                 // E1       reload original args
 ret                    // C9       return
</code></pre>
</div>
<div id="pu2" class="pu"><h1>TeaScript, 14 bytes <s>20</s></h1>
<pre><code>xc(yl#`[^${l}]
</code></pre>
<p>Similar to @aspillers clever JavaScript <a href="https://codegolf.stackexchange.com/a/68194/40695">solution</a>.</p>
<h2>Explanation</h2>
<pre><code>             // Implicit: x = 1st input, y = 2nd input
x            // First input
 c           // returns index of regex match
 yl#         // Loop through every char in `y`
    `[^${l}] // Replace template, ${l} because current char in `y<span class="math-container">`</span>
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/JCumin/Brachylog" rel="nofollow noreferrer">Brachylog</a> (v2), <s>16</s> 13 bytes</h1>
<pre><code>{s ∞z‚ÇÇ}·∂†‚àã‚Üô.‚â†·µê‚àß
</code></pre>
<p><a href="https://tio.run/##VU0/S8NAFP8qxw2iUDq4Osgl99K75pKeyZUclA5pKW1FWzCFoLVLhNIigqtbcXHtYlE/gt8i90XitYv6Gx7v/f693k3aH91eTYen1XxUfq3P52a5NcWDPis/Xy9N8ZQfzXKMjnGuc3yC7/dHP51MpjPUG6DxBM1G4wxdD7IsHQ7qeGEryo@dnYvy/bmaZ9/bO1MUi3K3MatHs3ypm/XGKmb1VlUd1MEOa4CnE0/xtuSKMSFBKeWKFiQtEEGktSQ@0QEJlNZtKlSiQuaDACkFk9EFruHEJiByIOIuU7hb62DiuBS8BuNNX1gDAyFaBwH@4J@gAbxYODEI2gwIDQn1qYxjGYXgJBxC6Vk7hbaKXSZISA8h5vvM0s09DgSnECrukv3T372Luj8" rel="nofollow noreferrer" title="Brachylog ‚Äì Try It Online">Try it online!</a></p>
<p>Takes input as a list <code>[message, word]</code>. The header prints it all very prettily but the output of the actual predicate is just a 0-index if it succeeds and declarative failure if it doesn't.</p>
<pre><code>{    }·∂†          Find every possible
   z             zip of the word with
    ‚ÇÇ            an equal-length
 s ∞              contiguous substring of the ciphertext.
       ‚àã         One of those
          ‚â†·µê     contains no pair the elements of which are equal,
        ‚Üô.  ‚àß    and its index is the output.
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, <s>9</s> 7 bytes</h1>
<pre><code>t&quot;∆ë√ê∆§i1
</code></pre>
<p><a href="https://tio.run/##VYy9DcIwFIRXQa5pGME/z3mOXxwrduQsQAFKScMWQMUASExAQUtE9mASg6ngq@47nW67Hsd9zjs2H6fDfNms8nRlj9vz9Lqfc2YCK9BD0tH03kRE8hBjlNRCaoEatlwwLqQCXaGpLRWHH4oPADqQCECqbrhyXFnlQ/CdA5EMOK/LCq1Flln63EMnoDMS47cHovYvKOhjkEjcqaJ1gb0B" rel="nofollow noreferrer" title="Jelly ‚Äì Try It Online">Try it online!</a></p>
<pre><code>   √ê∆§      For each suffix,
  ∆ë        is it the same after
t          trimming off
 &quot;         the corresponding letter of the word from each of its letters?
     i1    Find the first index of 1.
</code></pre>
<h3>Wait, what?</h3>
<p>This beats the original, <code>W‚Ç¨·∏ü&quot;∆ë√ê∆§i1</code>, by completely dropping the step of wrapping each letter into a singleton list. As for <em>how</em>:</p>
<p>A Jelly string is a list of characters, which is to say it's a Python list of length-1 Python strings. For example, <code>‚Äúthis‚Äù</code> is really <code>[&quot;t&quot;,&quot;h&quot;,&quot;i&quot;,&quot;s&quot;]</code>.</p>
<p>Most list builtins are built to handle lists whether that's what they got or not, by passing all arguments through <a href="https://github.com/DennisMitchell/jellylanguage/blob/master/jelly/interpreter.py#L373" rel="nofollow noreferrer"><code>iterable</code></a>, and in the case of a single character this wraps it in a singleton list to obtain a length-1 Jelly string. <a href="https://github.com/DennisMitchell/jellylanguage/blob/master/jelly/interpreter.py#L234" rel="nofollow noreferrer"><code>·∏ü</code></a> does this, and as a result its output is also always a list--so <code>·∏ü&quot;</code>, mapped over corresponding pairs, gives a list of lists, and for it to ever not change a suffix of the ciphertext each of its characters has to be pre-wrapped to match.</p>
<p>However, <a href="https://github.com/DennisMitchell/jellylanguage/blob/master/jelly/interpreter.py#L1772" rel="nofollow noreferrer"><code>t</code> <em>does not call <code>iterable</code> on its left argument</em></a>, so here <code>t&quot;</code> operates on <em>the Python string characters themselves</em> of the ciphertext suffix, and either leaves them alone or trims them to <code>''</code>.</p>
<p>Finally, <code>∆ë</code> performs a strict, non-vectorizing equality check, and <code>&quot;</code> only maps its given link over pairs of corresponding elements up to the length of the shorter argument, placing the remainder of the longer argument into the result verbatim. If the ciphertext suffix is longer, the remainder automatically matches itself leaving only the prefix of length equal to the word to be considered, but if the word is longer, the result cannot be equal to the suffix because it is itself longer than the suffix.</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://www.r-project.org" rel="nofollow noreferrer">R</a>, 56 bytes</h1>
<pre><code>\(x,y)match(T,Map(\(i)all(x[i+seq(y)]!=y),seq(x)-1),0)-1</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m72waMH6tMyi4pL4gvzi4syknFTbpaUlaboWNy1iNCp0KjVzE0uSMzRCdHwTCzRiNDI1E3NyNCqiM7WLUws1KjVjFW0rNXVA7ApNXUNNHQMgCdX_MDe1uDgxPdU2NUejuKSouCAns0RDycnD3dUtItwtxDM0wDPEw8MnwDUkJMTZx9813N_Vx1dJR0lJU5OrPL8oBVVfOFCZa5CTa5Cns0cIVBWquzWg9umANGtycWG13hUJ4LTLw9XHx58IOyAeXbAAQgMA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Counterintuitively (at least to me), <code>match(TRUE,NA,nomatch=0)</code> returns <code>0</code>, rather than <code>NA</code>, but this is actually helpful here.<br />
We could save 2 bytes (delete <code>-1</code>) by using R's native 1-based indexing; and a further 1 or 2 bytes by returning nothing (using <code>which()[1]</code>) or <code>NA</code> (delete <code>,0</code>) to indicate no occurrence.</p>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a>, 20 bytes</h1>
<pre><code>:«é'‚Å∞l;∆õ‚Å∞Z∆õ‚âà;a√ün;~·∏Éh·∏ü
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/#WyIiLCIiLCI6x44n4oGwbDvGm+KBsFrGm+KJiDthw59uO37huINo4bifIiwiIiwiQkhHRUZYV0ZUSVVQSVRISExQRVRUVENMT0VXT0VMTVxuV0VUVEVSQkVSSUNIVCJd" rel="nofollow noreferrer">Try it Online!</a></p>
<p>I wrote this so long ago, waiting for <code>·∏ü</code> to work on strings, that I forgot how this even works</p>
</div>
<div id="pu7" class="pu"><h1><a href="https://codeberg.org/ngn/k" rel="nofollow noreferrer">K (ngn/k)</a>, 19 bytes</h1>
<pre><code>{**&amp;(#y)(~|/y=)':x}
</code></pre>
<p><a href="https://ngn.bitbucket.io/k#eJyFkF+LgkAUxd/9FGLLroY1uVGEsg/+GRtrUskJgwgKV00qbdMgaeuzr+VS7r50XwbmnHPP5ReIp3r9la3lHHv5BvkH9yYezxRFxNPLLL/sxYBu0kdpkawldhEso410lHJpz83PFJmxjIL6UJ+6OjEmtkEQwjYkhKjYgq4F8YiRGLf4gGMFjg0VEYaThPb8lpQVVYN6HxmDIS5sCGJsFXKrVGFlqqpZylMIdQcrDsTaYCRrpqwNNdtx7LEJFdeApq0XIQ1OiKMiLJvatVcoo2g4RIU4uM7vRgpQqyzbpSIAXvLph8kmaKbZ0lv7R2+1jEO/6SVb8HXw0yxK4hR0e0KvC7x94YjisJGt/IYfR+F2Cd6FTqfTqpUPRRnx7pCJ9BNIPP2HEWUdsltMaN83VGHx9I3G3fboqUL772oId9tzeDxdYfe457HiCpGnbwwrDT/svacr" rel="nofollow noreferrer">Try it online!</a></p>
<p>Takes the encoded message as <code>x</code> and the word as <code>y</code>. Returns <code>0N</code> (the integer null) if no possible occurrence was found.</p>
<ul>
<li><code>(#y)(~|/y=)':x</code> use <a href="https://k.miraheze.org/wiki/Windows" rel="nofollow noreferrer"><code>i f':x stencil</code></a> to apply <code>(~|/y=)</code> to each <code>(#y)</code>-length window of the input <code>x</code>
<ul>
<li><code>(#y)</code> get the length of the input word</li>
<li><code>(~|/y=)</code> check if any letters are in the same position in the word and the slice of the encoded message; then negate the resulting bitmask</li>
</ul>
</li>
<li><code>**&amp;</code> return the index of the first possible occurrence of the word in the encoded message</li>
</ul>
</div>
<div id="pu8" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, <s>10</s> 9 bytes</h1>
<pre><code>·π°‚ÅπL¬§=S‚Ç¨i0
</code></pre>
<p><a href="https://tio.run/##VYy9DcIwFIRXQa4pWIDCP8@x4xfHih05C1CAsgAljEBFi4REQ0uRNohBkkUMpoKvuu90ut2m7/cpTcNlPgw4Xtd@Pt63q/S8kfHxOk3DOSXCVAGyizLo1umgFDoIIXCsIdaAFVkuCGVcgCyULg1mhx@ydwDSI/OAoqyosFQY4bx3jQUWNVgn80oZo0gi8XMPDYNGcxW@PSDWf0FAGzxXSK3IWmbIGw" rel="nofollow noreferrer" title="Jelly ‚Äì Try It Online">Try it online!</a></p>
<p>Uses 1-indexing, which is Jelly's default. <a href="https://tio.run/##VYyxDcIwFERXQa4pWIAitr9jxz@OFTtyFqAAZQE6YAQqKJGQaGgp0gYxSLKIwVTwqnun021WXbeNcewv077H4bp00@G@Xky7c3zeyPB4Hcf@FCOhMgfRBuFVY5WXEi147xlWECrAksxnJKOMg8ilKjQmhx@StwDCIXWAvCgzbjKuuXXO1gZoUGCsSCuptSSRhM891BRqxaT/9oBY/QUOjXdMYmZ40iJB3g" rel="nofollow noreferrer">10 bytes</a> to use 0-indexing. This returns <span class="math-container">\$0\$</span> if no occurrence is found (<span class="math-container">\$-1\$</span> for the 0-indexed version)</p>
<h2>How it works</h2>
<pre><code>·π°‚ÅπL¬§=S‚Ç¨i0 - Main link. Takes M on the left and W on the right
   ¬§      - Create a nilad:
 ‚Åπ        -   W
  L       -   Length
·π°         - Overlapping slices of length W of M
    =     - Compare for equality with W
     S‚Ç¨   - Count the number of 1s in each
       i0 - First index of 0, else 0 if not found
</code></pre>
</div>
<div id="pu9" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, <s>14</s> <s>13</s> 11 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>≈íIg√π√ÖŒî√∏‚Ç¨√ã√†‚â†
</code></pre>
<p>-1 byte thanks to <em>@ovs</em>.</p>
<p><a href="https://tio.run/##yy9OTMpM/f//6CTP9MM7D7eem3J4x6OmNYe7Dy941Lng/38nD3dXt4hwtxDP0ADPEA8PnwDXkJAQZx9/13B/Vx9frnAg1zXIyTXI09kjBAA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##VYsxCsIwFIavIpl7B2maF1/a1zY0KS2UggoiTg6C4OAiKIhb8QA9gAfQObh6iF6kVif9xv/7/vVmNl8t@u1uzEbdqRmx8W6a98@mXLqHO76upbt3h5u7uLY7t/3e66uKcZyALAtpVa6VRSQN1tqAUihSoJh5rBgGyDhkKkDLaq9iPg8EyAmqMKIhQCBKvwJ@@BMlgDTEDZAIY18kvoiENkZnCfBCQaLlkAvIrQmQ/ER8TxhFOMzhB1bXbw" rel="nofollow noreferrer">verify all test cases</a>.</p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>≈í            # Get all substrings of the first (implicit) input
 Ig          # Get the length of the second input
   √π         # Only leave the substrings of that length
    √ÖŒî       # Find the first (0-based) index which is truthy for:
             # (which results in -1 if none are truthy)
      √∏      #  Zip/transpose; create pairs of the characters in the current substring
             #  and the second (implicit) input
       ‚Ç¨√ã    #  Check for each if both characters are equal (1 if truthy; 0 if falsey)
         √†   #  Get the maximum (basically equal to an `any` builtin)
          ‚â†  #  And invert the boolean (!= 1)
             # (after which the result is output implicitly)
</code></pre>
</div>
<div id="pu10" class="pu"><h1><a href="https://github.com/barbuz/Husk" rel="nofollow noreferrer">Husk</a>, <s>14</s> 13 bytes</h1>
<p>Or <strong><a href="https://tio.run/##VYsxCsIwGIXvktlLNM2f/ml/29BEWyjFVRBxEBe3OhTcRC/g5uAibq4ewDuYi8TYSb/lwXvfm2/WC798Xtyuc/3B9Uc/Xb3OW7c/u@7m@tOMQr4f1@fde980jGMCsq6kVROtLCJpsNbGVEBVAI3ZiFWhgJJDqWK0rB01LOKxAJmgSjMKAgJRMQzww99QA0hD3ACJdByJPBKZ0MboMgdeKci1DLqAiTUxUpSL4YRZhqFOv7C2/QA" rel="nofollow noreferrer">12 bytes</a></strong> using 1-based indexing and returning <code>0</code> for no-occurrence.</p>
<pre><code>‚ÜêVoŒ†z‚â†‚Å∞‚Üì_L‚Å∞·π´¬≤
</code></pre>
<p><a href="https://tio.run/##VYsxCsIwGIXvktlLNM2f/ml/29BEWyjFVRBxEBe3OhTcRC/g5uAibq4ewDuYi8TYSb/lwXvfm2/WC798Xtyuc/3B9UcfYrp6nbduf3bdzfWnGYV8P67Pu/e@aRjHBGRdSasmWllE0mCtjamAqgAasxGrQgElh1LFaFk7aljEYwEyQZVmFAQEomIY4Ie/oQaQhrgBEuk4EnkkMqGN0WUOvFKQaxl0ARNrYqQoF8MJswxDnX5hbfsB" rel="nofollow noreferrer" title="Husk ‚Äì Try It Online">Try it online!</a></p>
<pre><code>‚Üê                   # subtract 1 to get 0-based indexing
 V                  # index of first element of
            ·π´¬≤      # all suffixes of arg 2,
        ‚Üì_          # with n elements removed from the end, 
          L‚Å∞        # where n is the length of arg 1,
                    # that satisfies
  »Ø¬¨                # NOT
    Œ£               # any
     z=‚Å∞            # elements are equal when zipped with arg 1
</code></pre>
</div>
<div id="pu11" class="pu"><h1><a href="https://www.perl.org/" rel="nofollow noreferrer">Perl 5</a>, 46 bytes</h1>

<p>Uses @apsillers' regex idea.</p>



<pre class="lang-perl prettyprint-override"><code>$a=&lt;&gt;=~s/./[^$&amp;]/gr;/$a/g;$_=(length$a)/-4+pos
</code></pre>

<p><a href="https://tio.run/##K0gtyjH9/18l0dbGzrauWF9PPzpORS1WP73IWl8lUT/dWiXeViMnNS@9JEMlUVNf10S7IL/4/39XJMDl4erj4/8vv6AkMz@v@L@ur6megaHBf92CHAA" rel="nofollow noreferrer" title="Perl 5 ‚Äì Try It Online">Try it online!</a></p>
</div>
<div id="pu12" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C++ (gcc)</a>, <s>160</s> <s>153</s> 150 bytes</h1>



<pre class="lang-cpp prettyprint-override"><code>#include&lt;map&gt;
int f(std::string c,std::string w){int i=-1,k,e=1;while(e&amp;&amp;w.size()+i++&lt;c.size())for(e=k=0;k&lt;w.size();)e+=c[i+k]==w[k++];return e?-1:i;}
</code></pre>

<p><a href="https://tio.run/##bY/NboJAFIXX8hQTjA2EsalbkDb8DA4yIhEMJtaFGQY7QZEIhqTGZ6fQ2oZFz@6e892bc2lRjA@UNs2Q5/R4Tdj0tC9eBZ5XIJXKKlHVsrrw/AAo7E@1fOsQro8nMINMn2j1Bz8yiT091c8l/2SSrHBFmdLHIKfni8T0TH/RsukvoclM0emWK9lO1@ttpig77cKq6yUH7G08Ubl2b4YJS3nOAN2XTKKwlkHRFqhSSRyVEIxKFYyS91yEbT9Qw7Zzx8iC8PcObWvz889Hpz3PJVm4CYPvc6KJZ8jZxE7krgM3wpgEKIoiiyxRvERkIUIxbg20MtHKtXAkypoAHuoOAEk0TMtGzgy7c4@0OEaELP/BUE99bPDINwg5ITFDROz5wrB9w/bsIAyDlY/M2EV@4LRbNlpHoYWJ4dv9Xex5uE3nnfq@15mdcW@@AA" rel="nofollow noreferrer" title="C++ (gcc) ‚Äì Try It Online">Try it online!</a></p>
</div>
<div id="pu13" class="pu"><h1><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python 3</a>, 79 bytes</h1>



<pre class="lang-python prettyprint-override"><code>lambda x,y:[sum(map(str.__eq__,x[i:],y))for i in range(len(x)-len(y))].index(0)
</code></pre>

<p><a href="https://tio.run/##fY5Ba4NAEIXP9Vd4212wodCb0IO6Y1bdqOgGA2kQ26ytEFe7saC/3sYe0hRK32Vg5nvvTT8N7516nOun5/lUtS/Hyhytyd6fP1vcVj0@D3pVlvKjLK1x39gHayKk7rTZmI0ydaXeJD5JhUdyv4zL8bBq1FGO@IHMvW7UgGuMXLYGf1f4ItimgWCMpyCE8HgCRQJ8gywTFZcNZC5kgccEIsQwrm7H9Sj4axaEEV9QBpwn38igJ9s07q4k3OgXKcdX2Q8/LJJadxrdtuwA/Jy7OXAabhwaOzSiaZ6nWQxuEUCc@ksiha3IPcadmP75AYsitnDhov@a5y8" rel="nofollow noreferrer" title="Python 3 ‚Äì Try It Online">Try it online!</a></p>
</div>
<div id="pu14" class="pu"><h2>Java, 136 Characters</h2>

<p>Regex-based solution inspired by <a href="https://codegolf.stackexchange.com/users/7796/apsillers">apsillers</a> JavaScript version.</p>

<pre><code>class L{public static void main(String[]a){a=a[0].split(a[1].replaceAll("(.)","[^$1]"));System.out.print(a.length&gt;1?a[0].length():-1);}}
</code></pre>
</div>
<div id="pu15" class="pu"><h1>Japt, 12 bytes (non-competitive)</h1>
<pre><code>U√†Vr'.&quot;[^$&amp;]
</code></pre>
<p>I'm gonna need some help with this one.</p>
</div>
<div id="pu16" class="pu"><h1>SWI-Prolog, 115 bytes</h1>
<pre><code>a(S,W,R):-length(S,L),length(W,M),N is L-M,between(0,N,I),\+ (between(0,M,J),K is I+J,nth0(J,W,A),nth0(K,S,A)),R=I.
</code></pre>
<p>Usage example: <code>a(`ABCDEFGHIJKL`,`HELLO`,R).</code>. This uses the character codes strings declared with backticks. The answer is unified with <code>R</code>. If no match is found, this outputs <code>false.</code>.</p>
<h3>Explanation:</h3>
<pre><code>a(S,W,R):-
    length(S,L),length(W,M),     
    N is L-M,
    between(0,N,I),             % I is successively unified with an integer between 0 
                                % and the last possible index of the coded message

    \+ (                        % This will only be true if what's inside the parentheses 
                                % cannot be proven to be true

        between(0,M,J),         % J is successively unified with an integer between 0 
                                % and the length of the desired word
        K is I+J,
        nth0(J,W,A),nth0(K,S,A) % Check if one letter is the same in both string at 
                                % the same index
    ),                          % If it the case, then it will be 'true' and thus 
                                % the predicate \+ will be false, meaning we need to
                                % backtrack to try a different value of I

    R=I.                        % If we get here it means it didn't find any matching 
                                % letter for this value of I, which is then the answer.
</code></pre>
<p><a href="http://swish.swi-prolog.org/p/EpBwLrkw.pl" rel="nofollow noreferrer">Try it  here</a></p>
</div>
<div id="pu17" class="pu"><h2><a href="http://morphett.info/turing/turing.html">Turing Machine Simulator</a> - 15660 bytes (Non-Competing)</h2>

<p>Can't have an Enigma challenge without turing machine code.</p>

<pre><code>0 * * l 0
0 _ _ l ,
, _ , l 1
1 _ 0 r 2
2 * * r 2
2 , * r 3
3 * * r 3
3 , * r 4
4 * * r 4
4 _ * r 13
4 A a l a'                                                                                                                                                                                                        
4 B b l b'                                                                                                                                                                                                        
4 C c l c'                                                                                                                                                                                                        
4 D d l d'                                                                                                                                                                                                        
4 E e l e'                                                                                                                                                                                                        
4 F f l f'                                                                                                                                                                                                        
4 G g l g'                                                                                                                                                                                                        
4 H h l h'                                                                                                                                                                                                        
4 I i l i'                                                                                                                                                                                                        
4 J j l j'                                                                                                                                                                                                        
4 K k l k'                                                                                                                                                                                                        
4 L l l l'                                                                                                                                                                                                        
4 M m l m'                                                                                                                                                                                                        
4 N n l n'                                                                                                                                                                                                        
4 O o l o'                                                                                                                                                                                                        
4 P p l p'                                                                                                                                                                                                        
4 Q q l q'                                                                                                                                                                                                        
4 R r l r'                                                                                                                                                                                                        
4 S s l s'                                                                                                                                                                                                        
4 T t l t'                                                                                                                                                                                                        
4 U u l u'                                                                                                                                                                                                        
4 V v l v'                                                                                                                                                                                                        
4 W w l w'                                                                                                                                                                                                        
4 X x l x'                                                                                                                                                                                                        
4 Y y l y'                                                                                                                                                                                                        
4 Z z l z'
a' * * l a'
a' , * l a
b' * * l b'
b' , * l b
c' * * l c'
c' , * l c
d' * * l d'
d' , * l d
e' * * l e'
e' , * l e
f' * * l f'
f' , * l f
g' * * l g'
g' , * l g
h' * * l h'
h' , * l h
i' * * l i'
i' , * l i
j' * * l j'
j' , * l j
k' * * l k'
k' , * l k
l' * * l l'
l' , * l l
m' * * l m'
m' , * l m
n' * * l n'
n' , * l n
o' * * l o'
o' , * l o
p' * * l p'
p' , * l p
q' * * l q'
q' , * l q
r' * * l r'
r' , * l r
s' * * l s'
s' , * l s
t' * * l t'
t' , * l t
u' * * l u'
u' , * l u
v' * * l v'
v' , * l v
w' * * l w'
w' , * l w
x' * * l x'
x' , * l x
y' * * l y'
y' , * l y
z' * * l z'
z' , * l z

a * * l a
a _ * r A
a a * r A
a b * r A
a c * r A
a d * r A
a e * r A
a f * r A
a g * r A
a h * r A
a i * r A
a j * r A
a k * r A
a l * r A
a m * r A
a n * r A
a o * r A
a p * r A
a q * r A
a r * r A
a s * r A
a t * r A
a u * r A
a v * r A
a w * r A
a x * r A
a y * r A
a z * r A
b * * l b
b _ * r B
b a * r B
b b * r B
b c * r B
b d * r B
b e * r B
b f * r B
b g * r B
b h * r B
b i * r B
b j * r B
b k * r B
b l * r B
b m * r B
b n * r B
b o * r B
b p * r B
b q * r B
b r * r B
b s * r B
b t * r B
b u * r B
b v * r B
b w * r B
b x * r B
b y * r B
b z * r B
c * * l c
c _ * r C
c a * r C
c b * r C
c c * r C
c d * r C
c e * r C
c f * r C
c g * r C
c h * r C
c i * r C
c j * r C
c k * r C
c l * r C
c m * r C
c n * r C
c o * r C
c p * r C
c q * r C
c r * r C
c s * r C
c t * r C
c u * r C
c v * r C
c w * r C
c x * r C
c y * r C
c z * r C
d * * l d
d _ * r D
d a * r D
d b * r D
d c * r D
d d * r D
d e * r D
d f * r D
d g * r D
d h * r D
d i * r D
d j * r D
d k * r D
d l * r D
d m * r D
d n * r D
d o * r D
d p * r D
d q * r D
d r * r D
d s * r D
d t * r D
d u * r D
d v * r D
d w * r D
d x * r D
d y * r D
d z * r D
e * * l e
e _ * r E
e a * r E
e b * r E
e c * r E
e d * r E
e e * r E
e f * r E
e g * r E
e h * r E
e i * r E
e j * r E
e k * r E
e l * r E
e m * r E
e n * r E
e o * r E
e p * r E
e q * r E
e r * r E
e s * r E
e t * r E
e u * r E
e v * r E
e w * r E
e x * r E
e y * r E
e z * r E
f * * l f
f _ * r F
f a * r F
f b * r F
f c * r F
f d * r F
f e * r F
f f * r F
f g * r F
f h * r F
f i * r F
f j * r F
f k * r F
f l * r F
f m * r F
f n * r F
f o * r F
f p * r F
f q * r F
f r * r F
f s * r F
f t * r F
f u * r F
f v * r F
f w * r F
f x * r F
f y * r F
f z * r F
g * * l g
g _ * r G
g a * r G
g b * r G
g c * r G
g d * r G
g e * r G
g f * r G
g g * r G
g h * r G
g i * r G
g j * r G
g k * r G
g l * r G
g m * r G
g n * r G
g o * r G
g p * r G
g q * r G
g r * r G
g s * r G
g t * r G
g u * r G
g v * r G
g w * r G
g x * r G
g y * r G
g z * r G
h * * l h
h _ * r H
h a * r H
h b * r H
h c * r H
h d * r H
h e * r H
h f * r H
h g * r H
h h * r H
h i * r H
h j * r H
h k * r H
h l * r H
h m * r H
h n * r H
h o * r H
h p * r H
h q * r H
h r * r H
h s * r H
h t * r H
h u * r H
h v * r H
h w * r H
h x * r H
h y * r H
h z * r H
i * * l i
i _ * r I
i a * r I
i b * r I
i c * r I
i d * r I
i e * r I
i f * r I
i g * r I
i h * r I
i i * r I
i j * r I
i k * r I
i l * r I
i m * r I
i n * r I
i o * r I
i p * r I
i q * r I
i r * r I
i s * r I
i t * r I
i u * r I
i v * r I
i w * r I
i x * r I
i y * r I
i z * r I
j * * l j
j _ * r J
j a * r J
j b * r J
j c * r J
j d * r J
j e * r J
j f * r J
j g * r J
j h * r J
j i * r J
j j * r J
j k * r J
j l * r J
j m * r J
j n * r J
j o * r J
j p * r J
j q * r J
j r * r J
j s * r J
j t * r J
j u * r J
j v * r J
j w * r J
j x * r J
j y * r J
j z * r J
k * * l k
k _ * r K
k a * r K
k b * r K
k c * r K
k d * r K
k e * r K
k f * r K
k g * r K
k h * r K
k i * r K
k j * r K
k k * r K
k l * r K
k m * r K
k n * r K
k o * r K
k p * r K
k q * r K
k r * r K
k s * r K
k t * r K
k u * r K
k v * r K
k w * r K
k x * r K
k y * r K
k z * r K
l * * l l
l _ * r L
l a * r L
l b * r L
l c * r L
l d * r L
l e * r L
l f * r L
l g * r L
l h * r L
l i * r L
l j * r L
l k * r L
l l * r L
l m * r L
l n * r L
l o * r L
l p * r L
l q * r L
l r * r L
l s * r L
l t * r L
l u * r L
l v * r L
l w * r L
l x * r L
l y * r L
l z * r L
m * * l m
m _ * r M
m a * r M
m b * r M
m c * r M
m d * r M
m e * r M
m f * r M
m g * r M
m h * r M
m i * r M
m j * r M
m k * r M
m l * r M
m m * r M
m n * r M
m o * r M
m p * r M
m q * r M
m r * r M
m s * r M
m t * r M
m u * r M
m v * r M
m w * r M
m x * r M
m y * r M
m z * r M
n * * l n
n _ * r N
n a * r N
n b * r N
n c * r N
n d * r N
n e * r N
n f * r N
n g * r N
n h * r N
n i * r N
n j * r N
n k * r N
n l * r N
n m * r N
n n * r N
n o * r N
n p * r N
n q * r N
n r * r N
n s * r N
n t * r N
n u * r N
n v * r N
n w * r N
n x * r N
n y * r N
n z * r N
o * * l o
o _ * r O
o a * r O
o b * r O
o c * r O
o d * r O
o e * r O
o f * r O
o g * r O
o h * r O
o i * r O
o j * r O
o k * r O
o l * r O
o m * r O
o n * r O
o o * r O
o p * r O
o q * r O
o r * r O
o s * r O
o t * r O
o u * r O
o v * r O
o w * r O
o x * r O
o y * r O
o z * r O
p * * l p
p _ * r P
p a * r P
p b * r P
p c * r P
p d * r P
p e * r P
p f * r P
p g * r P
p h * r P
p i * r P
p j * r P
p k * r P
p l * r P
p m * r P
p n * r P
p o * r P
p p * r P
p q * r P
p r * r P
p s * r P
p t * r P
p u * r P
p v * r P
p w * r P
p x * r P
p y * r P
p z * r P
q * * l q
q _ * r Q
q a * r Q
q b * r Q
q c * r Q
q d * r Q
q e * r Q
q f * r Q
q g * r Q
q h * r Q
q i * r Q
q j * r Q
q k * r Q
q l * r Q
q m * r Q
q n * r Q
q o * r Q
q p * r Q
q q * r Q
q r * r Q
q s * r Q
q t * r Q
q u * r Q
q v * r Q
q w * r Q
q x * r Q
q y * r Q
q z * r Q
r * * l r
r _ * r R
r a * r R
r b * r R
r c * r R
r d * r R
r e * r R
r f * r R
r g * r R
r h * r R
r i * r R
r j * r R
r k * r R
r l * r R
r m * r R
r n * r R
r o * r R
r p * r R
r q * r R
r r * r R
r s * r R
r t * r R
r u * r R
r v * r R
r w * r R
r x * r R
r y * r R
r z * r R
s * * l s
s _ * r S
s a * r S
s b * r S
s c * r S
s d * r S
s e * r S
s f * r S
s g * r S
s h * r S
s i * r S
s j * r S
s k * r S
s l * r S
s m * r S
s n * r S
s o * r S
s p * r S
s q * r S
s r * r S
s s * r S
s t * r S
s u * r S
s v * r S
s w * r S
s x * r S
s y * r S
s z * r S
t * * l t
t _ * r T
t a * r T
t b * r T
t c * r T
t d * r T
t e * r T
t f * r T
t g * r T
t h * r T
t i * r T
t j * r T
t k * r T
t l * r T
t m * r T
t n * r T
t o * r T
t p * r T
t q * r T
t r * r T
t s * r T
t t * r T
t u * r T
t v * r T
t w * r T
t x * r T
t y * r T
t z * r T
u * * l u
u _ * r U
u a * r U
u b * r U
u c * r U
u d * r U
u e * r U
u f * r U
u g * r U
u h * r U
u i * r U
u j * r U
u k * r U
u l * r U
u m * r U
u n * r U
u o * r U
u p * r U
u q * r U
u r * r U
u s * r U
u t * r U
u u * r U
u v * r U
u w * r U
u x * r U
u y * r U
u z * r U
v * * l v
v _ * r V
v a * r V
v b * r V
v c * r V
v d * r V
v e * r V
v f * r V
v g * r V
v h * r V
v i * r V
v j * r V
v k * r V
v l * r V
v m * r V
v n * r V
v o * r V
v p * r V
v q * r V
v r * r V
v s * r V
v t * r V
v u * r V
v v * r V
v w * r V
v x * r V
v y * r V
v z * r V
w * * l w
w _ * r W
w a * r W
w b * r W
w c * r W
w d * r W
w e * r W
w f * r W
w g * r W
w h * r W
w i * r W
w j * r W
w k * r W
w l * r W
w m * r W
w n * r W
w o * r W
w p * r W
w q * r W
w r * r W
w s * r W
w t * r W
w u * r W
w v * r W
w w * r W
w x * r W
w y * r W
w z * r W
x * * l x
x _ * r X
x a * r X
x b * r X
x c * r X
x d * r X
x e * r X
x f * r X
x g * r X
x h * r X
x i * r X
x j * r X
x k * r X
x l * r X
x m * r X
x n * r X
x o * r X
x p * r X
x q * r X
x r * r X
x s * r X
x t * r X
x u * r X
x v * r X
x w * r X
x x * r X
x y * r X
x z * r X
y * * l y
y _ * r Y
y a * r Y
y b * r Y
y c * r Y
y d * r Y
y e * r Y
y f * r Y
y g * r Y
y h * r Y
y i * r Y
y j * r Y
y k * r Y
y l * r Y
y m * r Y
y n * r Y
y o * r Y
y p * r Y
y q * r Y
y r * r Y
y s * r Y
y t * r Y
y u * r Y
y v * r Y
y w * r Y
y x * r Y
y y * r Y
y z * r Y
z * * l z
z , * r Z
z a * r Z
z b * r Z
z c * r Z
z d * r Z
z e * r Z
z f * r Z
z g * r Z
z h * r Z
z i * r Z
z j * r Z
z k * r Z
z l * r Z
z m * r Z
z n * r Z
z o * r Z
z p * r Z
z q * r Z
z r * r Z
z s * r Z
z t * r Z
z u * r Z
z v * r Z
z w * r Z
z x * r Z
z y * r Z
z z * r Z
A * * * 5
A A * l 6
B * * * 5
B B * l 6
C * * * 5
C C * l 6
D * * * 5
D D * l 6
E * * * 5
E E * l 6
F * * * 5
F F * l 6
G * * * 5
G G * l 6
H * * * 5
H H * l 6
I * * * 5
I I * l 6
J * * * 5
J J * l 6
K * * * 5
K K * l 6
L * * * 5
L L * l 6
M * * * 5
M M * l 6
N * * * 5
N N * l 6
O * * * 5
O O * l 6
P * * * 5
P P * l 6
Q * * * 5
Q Q * l 6
R * * * 5
R R * l 6
S * * * 5
S S * l 6
T * * * 5
T T * l 6
U * * * 5
U U * l 6
V * * * 5
V V * l 6
W * * * 5
W W * l 6
X * * * 5
X X * l 6
Y * * * 5
Y Y * l 6
Z * * * 5
Z Z * l 6
5 , * r 15
5 A a r 7
5 B b r 7
5 C c r 7
5 D d r 7
5 E e r 7
5 F f r 7
5 G g r 7
5 H h r 7
5 I i r 7
5 J j r 7
5 K k r 7
5 L l r 7
5 M m r 7
5 N n r 7
5 O o r 7
5 P p r 7
5 Q q r 7
5 R r r 7
5 S s r 7
5 T t r 7
5 U u r 7
5 V v r 7
5 W w r 7
5 X x r 7
5 Y y r 7
5 Z z r 7
7 * * r 7
7 , * r 4
6 * * l 6
6 _ * r 8
8 * _ r 9
9 * * r 9
9 _ * l 10
9 a A r 9
9 b B r 9
9 c C r 9
9 d D r 9
9 e E r 9
9 f F r 9
9 g G r 9
9 h H r 9
9 i I r 9
9 j J r 9
9 k K r 9
9 l L r 9
9 m M r 9
9 n N r 9
9 o O r 9
9 p P r 9
9 q Q r 9
9 r R r 9
9 s S r 9
9 t T r 9
9 u U r 9
9 v V r 9
9 w W r 9
9 x X r 9
9 y Y r 9
9 z Z r 9
10 * * l 10
10 , * l 11
11 * * l 11
11 , * l 12
12 _ 1 r 2
12 0 1 r 2
12 1 2 r 2
12 2 3 r 2
12 3 4 r 2
12 4 5 r 2
12 5 6 r 2
12 6 7 r 2
12 7 8 r 2
12 8 9 r 2
12 9 0 l 12
13 * _ l 13
13 , _ l 14
14 * _ l 14
14 , _ l halt
15 * * r 15
15 _ * l 16
16 * _ l 16
16 , _ l 17
17 * _ l 17
17 , _ l 18
18 * _ l 18
18 _ x * halt
</code></pre>

<p><a href="http://morphett.info/turing/turing.html?1b6a7eb727ffd1e51882">Test it out here</a></p>

<p>Brief overview:</p>

<ol>
<li>Set up a counter on the left</li>
<li>Find first uppercase letter in target and make it lowercase. If all letters are lowercase move to step 5.</li>
<li>Find first uppercase letter in code. If most recent letter matches, move on to step 4. Else make letter lowercase and go back to step 2.</li>
<li>Increment counter, make all letters capital, delete first letter in code. Go back to step 2. If no letters are left in code, return clear tape and print x.</li>
<li>Clear all the tape but the counter.</li>
</ol>
</div>
<div id="pu18" class="pu"><h1>Ruby, <s>43</s> 36 bytes</h1>

<p>edit: String interpolation inside string interpolation inside a regex, yikes.</p>

<p>The lazy approach: translates the word to a "negative" regex -- The <code>=~</code> operator does the rest.</p>



<pre class="lang-rb prettyprint-override"><code>-&gt;m,w{m=~/#{"[^#{w.chars*'][^'}]"}/}
</code></pre>

<p>Test:</p>

<pre class="lang-rb prettyprint-override"><code>f=-&gt;m,w{m=~/#{"[^#{w.chars*'][^'}]"}/}

require "minitest/autorun"

describe :f do
  it "works for the given test cases" do
    assert_equal 13, f["BHGEFXWFTIUPITHHLPETTTCLOEWOELM", "WETTERBERICHT"]
    assert_equal 0, f["ABCDEFGHIJKL", "HELLO"]
    assert_equal nil, f["EEEEEEEEEEEE", "HELLO"]
    assert_equal 11, f["XEEFSLBSELDJMADNADKDPSSPRNEBWIENPF", "DEUTSCHLAND"]
    assert_equal nil, f["HKKH", "JJJJJ"]
  end
end
</code></pre>
</div>
<div id="pu19" class="pu"><h1>Perl, 38 + 1 = 39 bytes</h1>
<pre><code>perl -E &quot;$r=&lt;&gt;=~s!.![^$&amp;]!gr;say@-if&lt;&gt;=~/$r/x&quot; &lt; input
</code></pre>
<p>where input looks like:</p>
<pre><code>WETTERBERICHT
BHGEFXWFTIUPITHHLPETTTCLOEWOELMRXXPAKAXMAMTXXUDLTWTNHKELEPPLHPRQ
</code></pre>
<p>This is the same idea as the javascript one.</p>
</div>
<div id="pu20" class="pu"><h1><a href="https://github.com/JCumin/Brachylog" rel="nofollow noreferrer">Brachylog</a>, 48 bytes</h1>
<pre><code>[S:W]hlL,WlM,L-M=:0reI,'(0:MeJ+I=:SrmA,W:JmA),I.
</code></pre>
<p>This is a direct translation of my Prolog answer. The <code>brachylog_main/2</code> generated predicate expects a list of two character codes strings with the coded string first as input, and returns the index as output, e.g. <code>brachylog_main([`ABCDEFGHIJKL`,`HELLO`],R).</code>.</p>
<h3>Explanation</h3>
<pre><code>[S:W]                                            ¬ß Unify the input with the list [S,W]

     hlL,WlM,                                    ¬ß L and M are the length of S and W

             L-M=:0reI,                          ¬ß Enumerate integers between 0 and the 
                                                 ¬ß last possible index

                       '(                   ),I. ¬ß Unify the output with the current 
                                                 ¬ß enumerated integer if what's inside the 
                                                 ¬ß parenthesis cannot be proven to be true

                         0:MeJ                   ¬ß Enumerate integers between 0 and the
                                                 ¬ß length of the word desired

                              +I=:SrmA,W:JmA     ¬ß Check if both strings contain at matching
                                                 ¬ß indexes the same letter (unified with A)
</code></pre>
</div>
<div id="pu21" class="pu"><h1><a href="https://github.com/ConorOBrien-Foxx/Jolf/" rel="nofollow">Jolf</a>, 14 bytes</h1>

<p><a href="http://conorobrien-foxx.github.io/Jolf/#code=IHNpz4FJIi4nW14kJl0&amp;input=QkhHRUZYV0ZUSVVQSVRISExQRVRUVENMT0VXT0VMTQoKV0VUVEVSQkVSSUNIVA" rel="nofollow">Try it here!</a></p>

<pre><code> siœÅI".'[^$&amp;]
_s            search
  i            input 1 for
    I          input 2
   œÅ            replacing (2 byte rho character)
     ".'         all characters
        [^$&amp;]    with that
</code></pre>
</div>
<div id="pu22" class="pu"><h1>ùîºùïäùïÑùïöùïü, 14 chars / 25 bytes</h1>
<pre><code>√Æƒä‚±Æ(√≠,‚Ü™`‚ÅÖ‚¶É$}]`
</code></pre>
<p><kbd><a href="http://molarmanful.github.io/ESMin/interpreter.html?eval=true&amp;input=%5B%22BHGEFXWFTIUPITHHLPETTTCLOEWOELM%22%2C%22WETTERBERICHT%22%5D&amp;code=%C3%AE%C4%8A%E2%B1%AE%28%C3%AD%2C%E2%86%AA%60%E2%81%85%E2%A6%83%24%7D%5D%60" rel="nofollow noreferrer">Try it here (Firefox only).</a></kbd></p>
<p>Kudos to @apsillers for the idea.</p>
<h1>Explanation</h1>
<pre><code>               // implicit: √Æ = input1, √≠ = input2
√Æƒä             // search for first occurrence of:
  ‚±Æ(√≠,‚Ü™`‚ÅÖ‚¶É$}]` // regex created by wrapping each word in [^ and ] (negation matches)
</code></pre>
</div>
<div id="pu23" class="pu"><h2>Python 2.7, 111 characters</h2>

<p>Tries all starting positions (a) and checks of any of the letters match (using the list comprehension). It returns "None" (Python's "NULL") if nothing is found (the for loop end and nothing is returned, which defaults to "None".</p>

<pre><code>def d(c,s):
 for a in range(len(c)):
  if a not in [((c+s)[a+i:]).index(l)+a for i,l in enumerate(s)]:
   return a
</code></pre>

<p>Testsuite:</p>

<pre><code>cases = {
         ("BHGEFXWFTIUPITHHLPETTTCLOEWOELM","WETTERBERICHT"):13,
         ("ABCDEFGHIJKL","HELLO"):0,
         ("EEEEEEEEEEEE","HELLO"):-1,
         ("XEEFSLBSELDJMADNADKDPSSPRNEBWIENPF","DEUTSCHLAND"):11
        }

for idx,(code,string) in enumerate(cases):
    output=d(code,string)
    print "Case: {}: d({:&lt;35},{:&lt;16}) gives: {}. Correct answer is: {}.".format(idx+1,code,string,output,cases[(code,string)])
</code></pre>
</div>
<div id="pu24" class="pu"><h1>CJam, <s>17</s> 16 bytes</h1>

<pre><code>ll:A,ew{A.=:+!}#
</code></pre>

<p><a href="http://cjam.aditsu.net/#code=ll%3AA%2Cew%7BA.%3D%3A%2B!%7D%23&amp;input=BHGEFXWFTIUPITHHLPETTTCLOEWOELM%0AWETTERBERICHT" rel="nofollow">Try it here</a>.</p>

<p>Thanks to @PeterTaylor for saving a byte.</p>

<p>Explanation:</p>

<pre><code>ll:A,ew    e# Finds every slice in the coded message with the length of the word
{A.=:+     e# Compare the characters in each slice to the characters in the word, and add up the result. If the sum is zero, then the slice and the word have no characters in common.
!}#        e# Invert truthiness (0 -&gt; 1, non-0 -&gt; 0) Return index of first truthy value.
</code></pre>
</div>
<div id="pu25" class="pu"><h1>JavaScript, <s>129</s> <s>121</s> <s>118</s> <s>119<sup>*</sup></s> 118 bytes</h1>
<pre><code>(w,t){for(j=0;(x=t.length)&lt;(y=w.length);t=' '+t,j++){for(a=i=0;++i&lt;y;)w[i]==t[i]?a=1:a;if(!a)break}return x==y?-1:j}
</code></pre>
<p><code>w</code> is the coded message, <code>t</code> is the test string. This doesn't use regexes, but just compares letter by letter, shifting the test string (i.e. &quot;WETTERBERICHT&quot;) by appending space before it. Easy and boring.</p>
<hr />
<p><sup>* test case with no match didn't work, now it does</sup></p>
</div>
<div id="pu26" class="pu"><h1>Pyth, 14 bytes</h1>
<pre><code>f!s.eqb@&gt;zTkQ0
</code></pre>
<p>I'm not sure if this is Ok but if the input is impossible, nothing is written to stdout and a zero division error is written to stderr. Takes the input on 2 lines, the second one is surrounded by quotes.</p>
<p>Explanation:</p>
<pre><code>               - autoassign z to first input
               - autoassign Q to second input
f            0 - The first value starting from 0 where the output is truthy
   .e       Q  - Enumerate over the second value
        &gt;zT    - z[T:]
       @   k   - The kth item (number in enumeration)
      b        - The character in the enumeration
     q         - Are the two characters equal?
  s            - Sum the values
 !             - Invert them (want first where there isn't a collision)
</code></pre>
<p><a href="http://pyth.herokuapp.com/?code=f!s.eqb%40%3EzTkQ0&amp;input=BHGEFXWFTIUPITHHLPETTTCLOEWOELM%0A%22WETTERBERICHT%22&amp;debug=0" rel="noreferrer">Try it here!</a></p>
</div>
<div id="pu27" class="pu"><h2>Haskell, 72 bytes</h2>

<pre><code>l=length
h i w s|l s&lt;l w= -1|and$zipWith(/=)w s=i|1&lt;2=h(i+1)w$tail s
h 0
</code></pre>

<p>Usage: <code>h 0 "DEUTSCHLAND"  "XEEFSLBSELDJMADNADKDPSSPRNEBWIENPF"</code> -> <code>11</code>.</p>

<p>Simple recursive approach: if the word <code>w</code>can be placed at the beginning of the string <code>s</code>, return the index counter <code>i</code>, else repeat with <code>i</code> incremented and the tail of <code>s</code>. Stop and return <code>-1</code> if the length of <code>s</code> is less than the length of <code>w</code>.</p>
</div>
<div id="pu28" class="pu"><h1>JavaScript, 40</h1>
<pre><code>(c,p)=&gt;c.search(p.replace(/./g,&quot;[^$&amp;]&quot;))
</code></pre>
<p>Using <code>replace</code>, this maps the plaintext input into a regular expression of form <code>/[^H][^E][^L][^L][^O]/</code> (e.g., for plaintext input <code>HELLO</code>) and then uses <code>search</code> to test for the first index of the ciphertext substring that matches that regex. This regex means &quot;a pattern where the first character is not <code>H</code>, the second character is not <code>E</code>, etc.&quot;</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_string_as_a_parameter" rel="noreferrer"><code>$&amp;</code> is a special sequence for <code>replace</code> output</a> that substitutes in the value matched by the first <code>replace</code> argument (in this case, each single character matched by <code>/./</code>).</p>
</div>
<div id="pu29" class="pu"><h1>PHP ‚Äì 155 bytes</h1>
<pre><code>&lt;?php for($p=$argv[1],$q=$argv[2],$l=strlen($q),$i=0,$r=-1;$i&lt;strlen($p)-$l;$i++)if(levenshtein($q,substr($p,$i,$l),2,1,2)==$l){$r=$i;break;}echo$r.&quot;\n&quot;;
</code></pre>
<p>Save as <code>crack.php</code> and run with the arguments in the command line. E.g.:</p>
<pre><code>$ php crack.php BHGEFXWFTIUPITHHLPETTTCLOEWOELM WETTERBERICHT
13
</code></pre>
</div>
<div id="pu30" class="pu"><h2>Ruby, <s>91</s> 79 bytes</h2>



<pre class="lang-ruby prettyprint-override"><code>-&gt;a,b{[*a.chars.each_cons(b.size)].index{|x|x.zip(b.chars).all?{|y|y.uniq==y}}}
</code></pre>

<p>Curse you, <code>Enumerator</code>! Why do I have to convert from string to array to Enumerator to array and waste precious bytes? >:(</p>

<pre class="lang-ruby prettyprint-override"><code>-&gt;a,b{                  # define lambda
[*                      # convert to array...
  a.chars               # get enumerator from string
  .each_cons(b.size)    # each consecutive group of (b.size) letters
]
.index{|x|              # find index of...
  x.zip(b.chars)        # zip group with second input string
  .all?{|y|             # is the block true for every element?
    y.uniq==y           # uniqueify results in same array (no dups)
}}}
</code></pre>
</div>
<div id="pu31" class="pu"><h1><a href="https://esolangs.org/wiki/MATL" rel="nofollow">MATL</a>, 27 bytes</h1>

<pre><code>jYbZ)tnb!wlhYCw!=a~ftn?1)1-
</code></pre>

<h3>Examples</h3>

<pre><code>&gt;&gt; matl jYbZ)tnb!wlhYCw!=a~ftn?1)1-
&gt; EEEEEEEEEEEE, HELLO

&gt;&gt; matl jYbZ)tnb!wlhYCw!=a~ftn?1)1-
&gt; XEEFSLBSELDJMADNADKDPSSPRNEBWIENPF, DEUTSCHLAND
11
</code></pre>

<h3>Explanation</h3>

<pre><code>j           % input string
YbZ)        % split into two strings based on space. Trailing comma is not a problem
tnb!wlhYC   % arrange first string into sliding columns of the size of the second
w!=         % compare with transposed second string, element-wise with broadcast
a~          % detect columns where all values are 0 (meaning unequal characters)
f           % find indices of such columns
tn?         % if there's at least one such column
1)1-        % pick index of the first and subtract 1 for 0-based indexing
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/68186/">68186</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




