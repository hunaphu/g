<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::224491</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>673</td><td>TypeScript's type system</td><td>240531T045958Z</td><td><a href="https://codegolf.stackexchange.com/questions/224491/interpret-gelatin/273364#273364">noodle m</a></td></tr>
<tr d-ix="1"><td>nan</td><td>Bash PATH=".$PATH"</td><td>240531T021153Z</td><td><a href="https://codegolf.stackexchange.com/questions/224491/interpret-gelatin/273362#273362">鳴神裁四点一号</a></td></tr>
<tr d-ix="2"><td>193</td><td>APL Dyalog Unicode</td><td>210428T175705Z</td><td><a href="https://codegolf.stackexchange.com/questions/224491/interpret-gelatin/224605#224605">user</a></td></tr>
<tr d-ix="3"><td>226</td><td>JavaScript ES6</td><td>210427T112831Z</td><td><a href="https://codegolf.stackexchange.com/questions/224491/interpret-gelatin/224540#224540">Arnauld</a></td></tr>
<tr d-ix="4"><td>129</td><td>Pip</td><td>210428T030502Z</td><td><a href="https://codegolf.stackexchange.com/questions/224491/interpret-gelatin/224571#224571">DLosc</a></td></tr>
<tr d-ix="5"><td>147</td><td>Charcoal</td><td>210427T210849Z</td><td><a href="https://codegolf.stackexchange.com/questions/224491/interpret-gelatin/224559#224559">Neil</a></td></tr>
<tr d-ix="6"><td>015</td><td>Jelly</td><td>210426T230328Z</td><td><a href="https://codegolf.stackexchange.com/questions/224491/interpret-gelatin/224495#224495">Unrelate</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>TypeScript's type system, <s>858</s> <s>763</s> 673 bytes</h1>

<pre class="lang-typescript prettyprint-override"><code>//@ts-ignore
type U&lt;n,a=[]&gt;=a extends{length:n}?a:U&lt;n,[...a,1]&gt;;type I&lt;o,w&gt;=U&lt;o extends'a'?w:o&gt;;type J&lt;o,v,d=v,s=[]&gt;=v extends[1,...infer v]?o extends'D'?v:J&lt;o,v,d,[...s,...d]&gt;:s;type K&lt;o,a,b&gt;=[o,a]extends['_',[...b,...infer d]]?d:[...a,...b];type F&lt;z,w,v=U&lt;w&gt;,M='D'|'S'&gt;=z extends`${infer c}${infer r}`?c extends M?F&lt;r,w,J&lt;c,v&gt;&gt;:z extends`${infer n extends'a'|number}${infer d}${infer r}`?F&lt;r,w,K&lt;d,I&lt;n,w&gt;,v&gt;&gt;:r extends`~${infer r}`?F&lt;r,w,K&lt;c,v,v&gt;&gt;:r extends`${infer m extends M}${infer r}`?F&lt;r,w,K&lt;c,v,J&lt;m,U&lt;w&gt;&gt;&gt;&gt;:r extends`${infer n extends'a'|number}${infer r}`?F&lt;r,w,K&lt;c,v,I&lt;n,w&gt;&gt;&gt;:r extends`${infer z}~${infer r}`?F&lt;r,w,K&lt;c,v,K&lt;z,v,v&gt;&gt;&gt;:F&lt;r,w,K&lt;c,v,U&lt;w&gt;&gt;&gt;:v[&quot;length&quot;]
</code></pre>
<p><a href="https://www.typescriptlang.org/play/?ssl=2&amp;ssc=661&amp;pln=1&amp;pc=1#code/PTACBcGcFoEsHMB2B7ATgUwFDgJ4Ad0ACAVQB5EAaAQwF4BtAXQD4arD0APcdRAE0gDeAGx7xwACwBciAL4B+KpLKU6AOnVUKARmYBuXAUIBJUsgoB3FmWTsuPfgHIqDuecnIm+-EQBSpigBuFLw0QZD0zKG23HyQdFoU6qqwiABm6KiEAQxyNpwxjgAiLgGSfmZBvBRq6pCJ6rzMkpBehgDS-poARix0ZlQM+fZxDgD6DtVJXfXJaRmEjTm8kjWqmlMMrUQAYqQAXhaBNGSWFACyNA7FAD4OAMoOLHvRwwAGACQCKemZAMYyn2+81QMlecl+L1ihDOcl2qEOfl+gSYTEkzyGsQ+XzmmUQkMczmuiAArgBbLoZAHYn4LKlAzIgsFww4dKomSinAIoySZDH8V4AP0BOMIjNhpHh5goHSRQS5qN5dkxwpppPxkGhdJFYuZUplgQoflJFBOKO5ioKkCx9MIeL5kCcDiJZIpIJVwNB4sl0tIsoo7IsZp56utIr2MiF1I9TIlLN9Bo6BzlQd1Pr9pu5AToACIRIgxOJswxMJgQIQACroSDgQi-KiQKuSUvAQhURA4Qjcau1+tVwjmWASUVV4lCKCENCEFLcVCk9C8WBUVAdjCQUfj5DEqCwXhYMvIVKd8REacZAJUISEOgABgohC018fAEpWxha8hSXPENxeBOt6oSwMIhK2ra9CBoQhdgcABqO5oIFUYACZxjvABWJhm0ILCAD05GwbwKyrcAtHAyDSBgh47wAdgwsscLwoDCOrRDSKg0YqDuOCJkIRDr1olssMIXCSzLRiQPAABmVjyOg6DCnkuCtBQ+90MwsSiIAFmksZKPvCSMPwwxxNQ7TCmvaDuK0RD+ME4S1II8SADZtNGeDOLg6DRlGDznDvRyDPU6sqJc2TfPvGjMPowzgKIgAObSqE8xzijvXibKiwLwAATlMzzPKoFLwvSoSGIcoiH207jVLokroqY4iSIgqD5O42Lirs0SyurKztPyxK4M4vLuI0gKuuIqSmpkrLYOUrQsvavD7KM8qtMmsZ5MKfLPIk0YNMKWb9KWmLupMtbOO8zbLOqltMq0Zy1vg-aEO4iLOuW7rgrW-b+ssvjBKwgAKU9Z3nRdl1tdB4CocBYACIhV3XJ9ALGrR4rW7zoIK6CNMsha6vEubevYiy70OmqOpusbeJcrHHPMyz9MEoHvwyOcFyXDtEEh6HYfhkcxyRoA" rel="nofollow noreferrer">Try it at the TS playground</a></p>
<p>This is a recursive generic type <code>F</code> that takes the program as a string-type <code>c</code> and the input as a number-type <code>w</code>, and yields the result number-type.</p>
<p>It's one in the morning. This is my longest TypeScript-types submission yet. It only supports numbers between 0 and 999 because of a limitation of how numbers work in TS types. Took forever to debug. My suffering ;_;</p>
<h1>Explanation</h1>
<pre class="lang-typescript prettyprint-override"><code>/* This line tells the compiler to ignore any
     pesky warnings: */
// @ts-ignore

/* U takes a number n and returns an array of that
     many ones.
   This is used for doing arithmetic, we use this
     list as a unary number and at the end return
     its length.
   This is also why we can only use numbers between 0
     and 999; the recursion limit is 999 iterations,
     and a list can't have negative length.
   Until a is of length n, append 1 and recurse,
     starting with empty a. */
type U&lt;n, a = []&gt; = a extends { length: n } ? a : U&lt;n, [...a, 1]&gt;;

/* I converts a parsed nilad o to a unary number.
   o is either a number or 'a'. If 'a', we take
     w, the input to the program. Otherwise, take
     o.
   That is then passed to U and returned. */
type I&lt;o, w&gt; = U&lt;o extends &quot;a&quot; ? w : o&gt;;

/* J evaluates a parsed monad o 'D' or 'S' on value v.
   Handling both in one type is nice because they
     have a tiny bit of shared code: in order to
     calculate the square, we add n to the running
     total 's' n times, but that involves decrementing
     n each time, so we decrement first and then check
     if the monad was 'D'. If it was, return the
     decremented result, otherwise continue with the
     squaring logic. */
type J&lt;o, v, d = v, s = []&gt; = v extends [1, ...infer v]
  ? o extends &quot;D&quot;
    ? v
    : J&lt;o, v, d, [...s, ...d]&gt;
  : s;

/* K evaluates a parsed dyad o '+' or '_' on
     values a and b.
   Remember a and b are unary numbers, so to add
     them you concatenate, and to subtract we
     pattern-match a against (b + infer d) to get
     the difference d. */
type K&lt;o, a, b&gt; = [o, a] extends [&quot;_&quot;, [...b, ...infer d]] ? d : [...a, ...b];

// And now for the main act...

/* type parameters key:
     z = remaining code
     w = input
     v = value, starts as w
     M = alias for &quot;match either 'D' or 'S' (the
       monads)&quot;
     c = first character, r = the rest

   F acts in a recursive &quot;loop&quot; by parsing an arity
     pattern, modifying v as needed, and removing the
     parsed bit from z. This loop continues until z is
     empty, at which point v is returned. */

type F&lt;z, w, v = U&lt;w&gt;, M = &quot;D&quot; | &quot;S&quot;&gt; = z extends `${infer c}${infer r}`
  ? c extends M           // if c is a monad:
    ? F&lt;r, w, J&lt;c, v&gt;&gt;    //   set v to J&lt;c, v&gt;
    : z extends `${infer n extends &quot;a&quot; | number}${infer d}${infer r}`
                          // if c is a nilad, inferring the
                          //   next character as the dyad d:
    ? F&lt;r, w, K&lt;d, I&lt;n, w&gt;, v&gt;&gt;
                          //   d(c, v)
    : r extends `~${infer r}`
                          // if the next character is ~:
    ? F&lt;r, w, K&lt;c, v, v&gt;&gt; //   c(v, v)
    : r extends `${infer m extends M}${infer r}`
                          // if the next character is a monad m:
    ? F&lt;r, w, K&lt;c, v, J&lt;m, U&lt;w&gt;&gt;&gt;&gt;
                          //   c(v, m(w))
    : r extends `${infer n extends &quot;a&quot; | number}${infer r}`
                          // if the next character is a nilad n:
    ? F&lt;r, w, K&lt;c, v, I&lt;n, w&gt;&gt;&gt;
                          //   c(v, n)
    : r extends `${infer d}~${infer r}`
                          // if the next character is a dyad d
                          //   followed by ~:
    ? F&lt;r, w, K&lt;c, v, K&lt;d, v, v&gt;&gt;&gt;
                          //   c(v, d(v, v))
    : F&lt;r, w, K&lt;c, v, U&lt;w&gt;&gt;&gt;
                          // otherwise: c(v, w)
  : v[&quot;length&quot;]; // final result, converted back to decimal
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.gnu.org/software/bash/" rel="nofollow noreferrer">Bash</a> <code>PATH=&quot;.:$PATH&quot;</code>, 233 + 1 = 234 bytes</h1>
<p>Filename is <code>f</code> and it must be <code>chmod u+x</code>ed.
Self recursion, now $1 is a and $3 is v.</p>
<pre class="lang-bash prettyprint-override"><code>L()(f &quot;${p:${2-1}}&quot; $a $[$1])
a=$2 v=${3-$a}
p=${1//_/-}
p=${p//+\~/T}
p=${p//-\~/Z}
((S=v*v,D=v-1,T=2*v))
case $p in '')echo $v;;[+-][!+-]*)((S=a*a,D=a-1,T=2*a))
L v${p::2} 2;;[+-]*)L v${p::1}a;;[D-Z]*)L ${p::1};;*)L ${p::2}v 2
esac
</code></pre>
<p><a href="https://tio.run/##PVDRSsMwFH3PV1xLYE2zGBrBh3YRhSk@DBTap3Uj3NWW@qArVINQ0l@Pmat7OZxz7j1w7zng0Pkav2C12hnz@PJkDNy1fhOzuIWIjn1GRyVS5yKgCLSi6Z4R1FSB1XS8ERQd6QNLpTRSnHkvJd9NsrwoEdTWkTgutE3scq2tSJelVolljNQ4NEB7eP@ExYI1dXcEavO84mJfXQVI2CmHCYYczjkMuQ3Y03mZcqDO6wn791KHwVqL7Z83W3l@EcpZUKQZsPbz06TuPo5v8M1/oCWvD@Wzjq4zeiIRHEJHIGyYhEbuI@8Nn4qi4NyYAMjN5G9/AQ" rel="nofollow noreferrer" title="Bash – Try It Online">Try it online!</a></p>
<hr />
<h1><a href="https://www.gnu.org/software/bash/" rel="nofollow noreferrer">Bash</a>, 245 bytes</h1>
<p>Full program, expect $1 is program and $2 is program argument:</p>
<pre class="lang-bash prettyprint-override"><code>L(){
v=$[$1]
p=${p:${2-1}}
}
a=${v=$2}
p=${1//_/-}
p=${p//+\~/T}
p=${p//-\~/Z}
while [ $p ];do((S=v*v,D=v-1,T=2*v))
case $p in [+-][!+-]*)((S=a*a,D=a-1,T=2*a))
L v${p::2} 2;;[+-]*)L v${p::1}a;;[D-Z]*)L ${p::1};;*)L ${p::2}v 2
esac
done
echo &quot;$v&quot;
</code></pre>
<p><a href="https://tio.run/##dVNdc6IwFH3Pr7jL4lZMMxJErWXoUx77Rp9qnUwqqTq7BYYgu46Df90NaC3BkQeGc3Ny7rkfvAu1Pn70nb6SBZDyXyCX6xTo0y/v@Nx39qgM7blNFygL7X32aO89QqsKVUhorM@8qjmhwyEfktN3Nhzit8Pw5YKIRq8V@rve/JEwBzuDRRCn/X4UloPynoUlofcvoTcoHQcthZI1Y5PAHJPF/Id@DZyaKwZCc8WZKzT3Gcra06NXgRcE84b5FaOV0CFGXpvYORQEF@BVJXhIKrFEcZpI1FRt2aV1dM5GcyliIDlkebqC9FOuBKTbIoA4RT9BfmbF7nS0UZqa5VLJpJAxvO9AbZKVFhCqkPlG/T7VZNk126oLuxvcOc3dMAgaB0uRFdtchpbd/7gQLbtJajkWyoRSMg6T9EvqfKFR07xtYWnBE2kn1Vk1yzdJofV6hPoKemQUQ/gEPerGUNa4/ugR9ZZYVznbKU76NaVJYDX9OuIIjGdqwvGkjRAXUYRbAc812CZEGDPGIkz5OUDHBptOx25bu@OEjgxIaNsLYi422Z4JqekbHyLtHHOuXwJg0kk1mc7Gs4dvds1pGzXYI9/QFphP2O2ejIwyEMMcc8FuadctQgPoDKEDEWNm5MGEneqQTihwhHUDeNM0v0P3Xd@gz3DE255mZkFTc8pcD1lnwHzEfcav52beRlHEI4bNitvFuT7122YOjB/4zf0kJkZMG2nvETWHMeuY0esgGP7OR011/7qRxtaNrvuufxGGJ63l7LRjjDDF@HBbhLroPw" rel="nofollow noreferrer" title="Bash – Try It Online">Try it online!</a></p>
<p>Fixed version</p>
<h2>Ungolfed</h2>
<pre class="lang-bash prettyprint-override"><code># Define lexer
# $1 is expression for new v
# $2 is erased characters from program (default: 1)
L(){
   v=$[$1]
   p=${p:${2-1}}
}

# Define program argument and current value
a=${v=$2}

# Program, but replace underscore with hyphen
# Also replace two letter monad into one letter
p=${1//_/-}
p=${p//+\~/T}
p=${p//-\~/Z}

# Loop until program gets empty
while [ $p ]; do
   ((S=v*v,D=v-1,T=2*v,Z=0)) # Precalculate monadic value for 1 rule

   case $p in
   [+-][!+-]*) # 2,1 or 2,0
      ((S=a*a,D=a-1)) # Calculate monadic values
      L v${p::2} 2 # expands to v+1, v+D, v-(v-v), etc.
   ;;[+-]*) # 2
      L v${p::1}a # expands to v+a or v-a
   ;;[SDTZ]*) # 1
      L ${p::1}
   ;;*) # 0,2
      L ${p::2}v 2 # expands to 1+v
   esac
done

# finally
echo &quot;$v&quot;
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.dyalog.com/" rel="nofollow noreferrer">APL (Dyalog Unicode)</a>, 193 bytes (SBCS)</h1>

<pre class="lang-apl prettyprint-override"><code>B M N←'(?&lt;!⍨)([+_])' '(D|S|⍨[+_])' '[0-9⍵]'
_←-⍨
S←×⍨
D←¯1∘+
{(⍎'{','⍵}',⍨'.'⎕R' \0 '⌽(B,M)(B,N)(∊'('N')'B)(∊B'(?!'N'|'M')')⎕R')⊢\1)⍵\2((' ')⊢\0(' ')⊢⍨\2\1(' ')⊢\0⍵('⊢'a' '(.)~'⎕R'⍵' '⍨\1'⊢⍺)⍵}
</code></pre>
<p><a href="https://tio.run/##dVM9axtBEO3vV6yr2WV0Zlf35YMEg9hWKrKlTlkWgtUYItwFyyodYSKTJiRVilTpUqUJpLH/yf4RZfYS49tVpOKYN/tm5s2H3Ooyf/POXb5d7vcTNmUzf/sR@PmLE7/7Lvgc7UIAA67XZk2eJzyXeet3PxeQWeLn9JIZMh4/B0uT9fBD@e0XzC7IvuZ@dw/XMAIKuYERceAU/P2nV8A6ycB/@M0no6mgz0xwv70DDjMQMOnBhNScEF7DlHyiDxP@7lunBKXrxpyTnt4hnywq0I079fxARA5kgQu9nIrN3@rkJhzYCvqwXyHlzd5v37NlxtiKOXZFDXCYv2YLDEEGOklJd1/pmWB4pOauxMsVu2BkuYyC98sMDYt@TQyreoiyZWadMThwjWXEJ0gkRK21QWX/eVUVkVRTyThpIkIVEczVUAbxtcSYP46hSkXjxpBstJY@jrE6KVc3bdWeDfmBNRQc8Ysyye/Q1vr4UIoi4Wu0aJ0@lj@MKwt7TXaRwJBIx76zGCZ9hs1Y59AgDcP2IyyTgFKWSUCLxg61tXFrjUxnTaunKmgLW2p7uMs2lWSMNRrj7odtylKVsaSNtht79GTzJq2gSc7wwlS8nvZAEp2J0/hcVcUVyv@NNbrI4nAP/X9HYz043WQ0FfsD" rel="nofollow noreferrer" title="APL (Dyalog Unicode) – Try It Online">Try it online!</a></p>
<p>Takes the program on the left and the argument on the right. I figured this'd be easy with APL's trains and regex, but apparently not ⍨.</p>
<pre class="lang-apl prettyprint-override"><code>⍝ Regexes (regices?) for dyads (B), monads (M), and nilads (N)
B M N←'(?&lt;!⍨)([+_])' '(D|S|⍨[+_])' '[0-9⍵]'
_←-⍨ ⍝ The _ dyad (flipped because APL is RTL)
S←×⍨ ⍝ The S monad (multiply with itself)
D←¯1∘+ ⍝ The D monad (add -1 to decrement)
</code></pre>
<p>The actual function:</p>
<pre class="lang-apl prettyprint-override"><code>{(⍎'{','⍵}',⍨'.'⎕R' \0 '⌽(B,M)(B,N)(∊'('N')'B)(∊B'(?!'N'|'M')')⎕R')⊢\1)⍵\2((' ')⊢\0(' ')⊢⍨\2\1(' ')⊢\0⍵('⊢'a' '(.)~'⎕R'⍵' '⍨\1'⊢⍺)⍵}
</code></pre>
<p>First <code>'a' '(.)~'⎕R'⍵' '⍨\1'⊢⍺</code> replaces <code>a</code> with <code>⍵</code> and <code>+~</code> and <code>_~</code> with <code>⍨+</code> and <code>⍨_</code>. This is just to make life simpler later. The next part is</p>
<pre class="lang-apl prettyprint-override"><code>(B,M)(B,N)(∊'('N')'B)(∊B'(?!'N'|'M')')⎕R')⊢\1)⍵\2((' ')⊢\0(' ')⊢⍨\2\1(' ')⊢\0⍵('
</code></pre>
<p>This may look like a mess, but it's actually pretty simple:</p>
<ul>
<li>The pattern <code>BM</code> (dyad, monad) becomes <code>((M⍵)B⊢)</code>, but reversed.</li>
<li>The pattern <code>BN</code> (dyad, nilad) becomes <code>(NB⊢)</code>, but reversed.</li>
<li>The pattern <code>NB</code> (nilad, dyad) becomes <code>(NB⍨⊢)</code>, but reversed.</li>
<li>The pattern <code>B</code> (dyad not followed by a nilad or monad) becomes <code>(⍵B⊢)</code>, but reversed.</li>
<li>Monads not preceded by dyads are left as is.</li>
</ul>
<p>This is pretty much an exact translation of the rules in the question. After this, <code>⌽</code> reverses everything because unlike Jelly, APL goes from right to left (this is also why <code>_</code> takes its arguments reversed). Then <code>'.'⎕R' \0 '</code> puts a space on each side of each character so that APL doesn't throw up the result thinking <code>SD</code> is a single token. Then the result <code>r</code> is turned into <code>{r⍵}</code> and evaluated to obtain a dfn. This function is applied to the outer function's right argument, <code>⍵</code>.</p>
</div>
<div id="pu3" class="pu"><h1>JavaScript (ES6), <s> 306 ... 227 </s> 226 bytes</h1>
<p>Expects <code>(program)(ω)</code>.</p>

<pre class="lang-javascript prettyprint-override"><code>s=&gt;g=(v,w=v,n=0,h=_=&gt;(O={a:w,'+':&quot;x+y&quot;,_:&quot;x-y&quot;,S:&quot;x*x&quot;,D:&quot;x-1&quot;,'+~':&quot;x*2&quot;,'_~':&quot;0&quot;}[c=(s+'a').match(/.~?/g)[n++]]||+c)[2]&gt;O?2:O&gt;g)=&gt;(I=h(i=h(E=(o,x,y)=&gt;eval(o)),o=O),o)?g(i?E(o,v,I?I-2?E(O,w):w:O):I?E(O,o,v):v,w,n-=i==I|i&amp;1):v
</code></pre>
<p><a href="https://tio.run/##dVPBjtowEL3nK6wcGnttQgIBlqwMF1OJEwcfKbKsELKp2IQmKbDaXb6gUi89tv/R79kf6CfQyRZ146w2Erbf@M3Mm/HwWe91GRXprupk@To@b/i55JOE4z078D3LuMduueITvOAPOjwwhzqhfaT3NlOwd2CXsF8dbSZq7NvAONWUqx4cVX307KdlxHFJHe0Q905X0S3uuqdpNyHLjNLV6vGRRmTZW00W0164mCQE0s35LU7hN@M4Z0d2D7Z4r7c4J4TlfAELmSY4nc7ges/m03mnB@cFO5DwEC5IOH9BcEdCqIRlHZ5yPn9MP/hgOBfxl69pEWNnU4KkItbrj@k2lvdZhD3iVrmsijRLMHHL3TatsP0ps4m7yYuZBu0l4hP0YCG0jSu03BUJQweG4uMujqp4vUIclRe/LqLduuLdP5/ShbB3mJAbcI7yrMy3sbvNEwwx3J1ez7I19ocEUYSLGDzQpr4hmB6IIepCvX5l8v/p0RQ5f35/f/75A1YHhch5/vXNqVM@kZszlcj4RiYcDJvIUlpK2jD0PINtQotSIYSkvroY/IHB9kcDrxm7pcTvG7DjN7VYwqMmu2dC39RNTxKUU6Vg0QgNW6mGo/FgfP3KrjlNoQa7HxixNVVD8X5P@kYZlqCKKi3ei123yEKtb9CClhCm5dqEreosSKippNAA9dK0oEUPvMCgj6lUTU1js6CR@coKHhkyUNVXgVBv3830tqRUUlCz4mZxXuAHTTEnoU7q3fnsmNgSIKQ5R775GOOWGBgHLehrPt@MHrxtpDF1/bd9h7@IoMPGcLbaAdX@BQ" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<h2>Commented</h2>
<h3>Header and helper function <code>h</code></h3>
<pre class="lang-javascript prettyprint-override"><code>s =&gt;                 // outer function taking the program string s
g = (                // g = inner recursive function taking:
  v,                 //   v = current output value
  w = v,             //   w = initial value of v (aka ω)
  n = 0,             //   n = pointer in the command stream
  h = _ =&gt; (         //   h is a helper function which turns the next
                     //   command into a JS code snippet or an integer,
                     //   along with the arity of the command:
    O = {            //     1) command:
      a   : w,       //       'a' : use w
      '+' : &quot;x+y&quot;,   //       '+' : add y to x
      _   : &quot;x-y&quot;,   //       '_' : subtract y from x
      S   : &quot;x*x&quot;,   //       'S' : square x
      D   : &quot;x-1&quot;,   //       'D' : decrement x
      '+~': &quot;x*2&quot;,   //       '+~': double x
      '_~': &quot;0&quot;      //       '_~': yield 0
    }[               //
      c = (s + 'a')  //       append an explicit 'a' command at the end
      .match(/.~?/g) //       split the commands (either &quot;x&quot; or &quot;x~&quot;)
      [n++]          //       load the next command into c
    ]                //
    || +c            //       if the above is undefined, use +c (it's a digit)
  )                  //     2) arity of the command:
  [2] &gt; O ? 2        //       dyad if the 3rd character is 'y'
          : O &gt; g    //       monad if it's a code snippet, or nilad otherwise
) =&gt;                 //
</code></pre>
<h3>Body of <code>g</code></h3>
<pre class="lang-javascript prettyprint-override"><code>( I =                // (O, I) = (2nd command, 2nd arity)
  h( i =             // (o, i) = (1st command, 1st arity)
    h( E =           // E is a helper function
      (o, x, y) =&gt;   //   which takes o, x, y
        eval(o)      //   and evaluates o in this local context
    ),               //
    o = O            //
  ),                 //
  o                  // we eventually test o
) ?                  // if o is defined:
  g(                 //   do a recursive call to g:
    i ?              //     if the 1st command is not a nilad:
      E(             //       v = result of a call to E with:
        o,           //         the 1st command
        v,           //         x = v
        I ?          //         if the 2nd command is not a nilad:
          I - 2 ?    //           if the 2nd command is a monad:
            E(O, w)  //             y = result of the 2nd command as a monad
          :          //           else (the 2nd command is a dyad):
            w        //             y = w
        :            //         else:
          O          //           y = O
      )              //       end of call
    :                //     else (the 1st command is a nilad):
      I ?            //       if the 2nd command is not a nilad:
        E(O, o, v)   //         v = result of the 2nd command as a dyad
      :              //       else:
        v,           //         v is left unchanged
    w,               //     pass w unchanged
    n -=             //     decrement n if only one command was 'consumed':
      i == I | i &amp; 1 //       i.e. if i = I or i is odd
  )                  //   end of recursive call
:                    // else:
  v                  //   we're done: return the final output value
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/dloscutoff/pip" rel="noreferrer">Pip</a>, 129 bytes</h1>
<pre><code>YaLRqR&quot;+~_~_&quot;&lt;&gt;2;^&quot;TZ-&quot;`\W\w?|[A-Z]|..`Y V$0R['^.XU`([A-Z]|^.)$`][`&amp;y``&amp;a`]R(^&quot;DSTZ&quot;).CXX'Y.[B.vB.'*.B&quot;2*&quot;.B0]R`\W$`_.yR`^\W`y._y
</code></pre>
<p><a href="https://tio.run/##Jcy7CsIwFADQX5FLaNqGXkpxsyhGR6ek2kea5GZ0q4sSKP31KLie4SzPJaUx3NRLgdj85qE9NgcH3VQBzf38Oa3mXE12RaRx92C1MtzhcKf8zw4LRtZQFomyQFblDq66m6DAyzDwEY3Et0ReooSmBJS1Vb@XkceoyM09RfQxJeFDEFpoLbxI@y8" rel="noreferrer" title="Pip – Try It Online">Try it online!</a></p>
<h3>How?</h3>
<p>We're basically going to use a translate-and-eval approach. Unlike Jelly (<em>cough</em>), Pip's execution model is rather different from Gelatin's, so the translation takes some work. We are fortunate in some ways: <code>0-9</code> and <code>+</code> can be used as they are, and so can <code>a</code> if we take the input number as a command-line argument.</p>
<pre><code>Ya
</code></pre>
<p>Copy the input number into <code>y</code>, which will be our flow-through value.</p>
<pre><code>qR&quot;+~_~_&quot;&lt;&gt;2;^&quot;TZ-&quot;
</code></pre>
<p>Read the Gelatin program from stdin and make some substitutions: <code>+~</code> -&gt; <code>T</code> (for Twice, since <code>x+x</code> = <code>2*x</code>), <code>_~</code> -&gt; <code>Z</code> (for Zero, since <code>x-x</code> = <code>0</code>), and <code>_</code> -&gt; <code>-</code> (so we can eval it later). After these substitutions, we have two dyads (<code>+</code> and <code>-</code>), four monads (<code>D</code>, <code>S</code>, <code>T</code>, and <code>Z</code>), and eleven nilads (<code>0</code> through <code>9</code>, plus <code>a</code>). Note that all monads are capital letters. Note also that both dyads are symbols, whereas all monads and nilads are alphanumeric.</p>
<pre><code>LR  ...  `\W\w?|[A-Z]|..`
</code></pre>
<p>Parse the arity patterns with regex and loop over all matches. The first branch <code>\W\w?</code> matches a dyad followed by a monad, nilad, or nothing; the second branch <code>[A-Z]</code> matches a single monad; and the third branch <code>..</code> matches two characters, which in practice is the only remaining case, a nilad followed by a dyad.</p>
<pre><code>$0R['^.XU`([A-Z]|^.)$`][`&amp;y``&amp;a`]
</code></pre>
<p>Starting from the arity pattern stored in the match variable <code>$0</code>, we make some more replacements. This stage adds the right argument for monads and for solitary dyads: A monad at the beginning of the pattern must be pattern 1; its argument should be <code>y</code>, the flow-through value. After that replacement, any other monad (pattern 2,1) or any other single character (pattern 2) should have a right argument of <code>a</code>, the input number.</p>
<pre><code>...  R(^&quot;DSTZ&quot;).CXX'Y.[B.vB.'*.B&quot;2*&quot;.B0]
</code></pre>
<p>Next, we replace monads with the appropriate Pip expressions: <code>Dx</code> (here <code>x</code> represents the right argument, either <code>y</code> or <code>v</code>) becomes <code>Yx-1</code>; <code>Sx</code> becomes <code>Yx*x</code>; <code>Tx</code> becomes <code>Y2*x</code>; and <code>Zx</code> becomes <code>Y0</code>. (The <code>Y</code> enforces correct precedence of operations in the 2,1 pattern.)</p>
<pre><code>...  R`\W$`_.yR`^\W`y._
</code></pre>
<p>Finally, we fill in the missing argument of each dyad. An operator at the end of the pattern is a dyad with a left argument (pattern 0,2), so its right argument should be <code>y</code>, the flow-through value. An operator at the beginning of the pattern is a dyad with a right argument (pattern 2,0 or 2,1 or 2), so its left argument should be `y.</p>
<pre><code>Y V  ...
</code></pre>
<p>Evaluate the resulting expression as Pip code, and store the result back into <code>y</code>.</p>
<pre><code>y
</code></pre>
<p>After the loop, output the final value of <code>y</code>.</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="noreferrer">Charcoal</a>, 147 bytes</h1>
<pre><code>Ｎθ≔θζＦ⁺⪫⪪⪫⪪Ｓ+~¦d¦_~¦z¦i«≡№DSdiz++__ι²«Ｆ⁼²Ｌυ⊞υθＦ²⊞υ⎇⊖Ｌυζι»¹«≔⎇υθζε≡ιD≦⊖εS≦×εεd≦⊗εz≦⁻εε⎚¿υ⊞υε≔εζ»⊞υ⎇⁼aιθＩι¿‹²Ｌυ«≔⎇⁼+§υ¹⁺§υ⁰§υ²⁻§υ⁰§υ²ζ≔…⟦ζι⟧⁻Ｌυ³υ»»Ｉζ
</code></pre>
<p><a href="https://tio.run/##fVJNb4IwGD7Lr2g4lcCS6Q5L3MngDi66mOBtWUyFF2lSC9J2myzur7O2gKIuu0DbPB99nrdxRso4J6yuZ7xQ8lXtNlDivffkTISgW473Aar0Ls1LhJdMCfySU46jglHZX1p2JEvKt9gLkOv/uOaX2O@62VT2S13PQ9/OQHxSGWcIh7niErvTKKGV76/XboBog4iJADQam@XA@j/vFWECjwI0B76VGVaeRi6V0KsAmUu3wNH5dAUlJ@UBTyEuYQdcQoLPbB3O2mnmsTUcNoZt/I5u9E0TAQJr092e2ps2THfqjtGCFC2159ixGljUh80hlXhFdyA06BKXXMrlasOupaobqQXlqi@VQEoUk2MUMiAltmc66oCmSBdwqkmDETAt2bpBM3YDPSlcV9qOwyV2ZLagkAipO@kKNSZzEDcj@6PgTszXYhM54wl8Ga@hmZF9d73De@8CMzIYm/t/kNdm6qzDQ8wgzPICv5lX8N6JnG4aoAdDUk2ao7PUz1tim7HSEev60fGj@u6D/QI" rel="noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Takes the argument as the first input and the script as the second input. Explanation:</p>
<pre><code>Ｎθ≔θζ
</code></pre>
<p>Input the argument and copy it to the flow-though value.</p>
<pre><code>Ｆ⁺⪫⪪⪫⪪Ｓ+~¦d¦_~¦z¦i«
</code></pre>
<p>Transform the script by replacing the <code>+~</code> and <code>_~</code> operators with single-byte operators and appending the identity operator (in case the script ends with a dyadic operator). Loop over each operator.</p>
<pre><code>≡№DSdiz++__ι
</code></pre>
<p>See how many arguments this operator expects.</p>
<pre><code>²«Ｆ⁼²Ｌυ⊞υθＦ²⊞υ⎇⊖Ｌυζι»
</code></pre>
<p>If this is a dyad, then if there is already a dyad on the stack then push the argument as its RHS. Push the flow-through value and the dyad, ensuring that the dyad is between its operands. Note that the flow-through value is incorrect if there is already a dyad on the stack but that will be fixed up later.</p>
<pre><code>¹«≔⎇υθζε≡ιD≦⊖εS≦×εεd≦⊗εz≦⁻εε⎚¿υ⊞υε≔εζ»
</code></pre>
<p>If this is a monad, then get either the flow-through value or the argument (depending on whether there is a dyad on the stack), apply the monad to it, then save it to the flow-through value or the stack (again depending on whether there is a dyad on the stack).</p>
<pre><code>⊞υ⎇⁼aιθＩι
</code></pre>
<p>Otherwise push either the argument (if this is an <code>a</code> operator) or the numeric value of the digit to the stack, assuming that the next operator is a dyad.</p>
<pre><code>¿‹²Ｌυ«
</code></pre>
<p>If we now have a dyad with both its arguments on the stack, then:</p>
<pre><code>≔⎇⁼+§υ¹⁺§υ⁰§υ²⁻§υ⁰§υ²ζ
</code></pre>
<p>Update the flow-through value with the result of the dyad.</p>
<pre><code>≔…⟦ζι⟧⁻Ｌυ³υ
</code></pre>
<p>If there were in fact two dyads on the stack, then recalculate the stack with the new flow-through value and the current dyad, otherwise clear the stack.</p>
<pre><code>»»Ｉζ
</code></pre>
<p>Once the script has been processed output the final flow-through value.</p>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="noreferrer">Jelly</a>, 15 bytes</h1>
<pre><code>⁾D’y“S²a⁸~`”yKv
</code></pre>
<p><a href="https://tio.run/##RVCxrsIwDPwVtg6HRENLgd0boydUVSYDC2JG6lKV9xdPgpmFiYmJAf4kPxKcpO91iezz2XeXw/54bL135xe5/rd1/YXfD@vOz27n@mu7OfnPbeZ@7lvv6zoDZ9PJsplO6kwsM7Sb57EFiIhhRCGzSIxANkWsKQ9cM08DdKzLENHHKl4NcGxMum8hFY33CQKxNM61SjIUwFUyIdaCobclyJUJXIOjq3VSUZ/KgxRSkowOmYUJo3t0JJ38xyVdiXnyIRssoQzAn3LYLYavIVQpcNE0Xw" rel="noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<pre><code>⁾D’y               Substitute D for Jelly's decrement builtin.
                   (This is done alone because ’ is a string terminator.)
    “      ”y      Substitute
     S²            S for square,
       a⁸          a for left argument,
         ~`        and ~ for reuse argument.
                   (+ and _ are already plus and minus.)
             K     Join the program on spaces to split up multi-digit numbers,
              v    and evaluate it as Jelly with the right argument as its sole argument.
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/224491/">224491</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




