<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::193793</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>021</td><td>x86 32bit machine code</td><td>191002T100035Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/193842#193842">Peter Co</a></td></tr>
<tr d-ix="1"><td>034</td><td>Python 3.11+</td><td>230419T142544Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/260265#260265">ShadowRa</a></td></tr>
<tr d-ix="2"><td>037</td><td>Red</td><td>210601T174713Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/226674#226674">9214</a></td></tr>
<tr d-ix="3"><td>034</td><td>Rust</td><td>210601T195400Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/226683#226683">Aiden4</a></td></tr>
<tr d-ix="4"><td>090</td><td>Windows Batch</td><td>191004T193836Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/193975#193975">peter fe</a></td></tr>
<tr d-ix="5"><td>027</td><td>Ruby</td><td>191003T224149Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/193929#193929">Value In</a></td></tr>
<tr d-ix="6"><td>043</td><td>Python 2</td><td>191002T131858Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/193853#193853">negative</a></td></tr>
<tr d-ix="7"><td>010</td><td>J</td><td>191001T231543Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/193811#193811">Jonah</a></td></tr>
<tr d-ix="8"><td>031</td><td>PHP</td><td>191003T130351Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/193910#193910">Night2</a></td></tr>
<tr d-ix="9"><td>022</td><td>Perl 5 p</td><td>191003T131500Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/193911#193911">Grimmy</a></td></tr>
<tr d-ix="10"><td>011</td><td>K4</td><td>191002T110124Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/193849#193849">mkst</a></td></tr>
<tr d-ix="11"><td>054</td><td>C# Visual C# Interactive Compiler</td><td>191001T202033Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/193807#193807">Gymhgy</a></td></tr>
<tr d-ix="12"><td>030</td><td>C gcc</td><td>191001T190304Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/193801#193801">S.S. Ann</a></td></tr>
<tr d-ix="13"><td>036</td><td>Scala</td><td>191002T092733Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/193838#193838">Soapy</a></td></tr>
<tr d-ix="14"><td>036</td><td>x86 SIMD machine code AVX512VBMI</td><td>191002T092724Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/193837#193837">Peter Co</a></td></tr>
<tr d-ix="15"><td>011</td><td>Charcoal</td><td>191002T094649Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/193841#193841">Neil</a></td></tr>
<tr d-ix="16"><td>091</td><td>Excel</td><td>191002T092820Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/193839#193839">Wernisch</a></td></tr>
<tr d-ix="17"><td>010</td><td>Japt P</td><td>191001T191545Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/193804#193804">Shaggy</a></td></tr>
<tr d-ix="18"><td>091</td><td>C gcc endian agnostic</td><td>191002T074200Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/193831#193831">Peter Co</a></td></tr>
<tr d-ix="19"><td>009</td><td>05AB1E</td><td>191001T184018Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/193799#193799">Dorian</a></td></tr>
<tr d-ix="20"><td>046</td><td>Zsh</td><td>191001T232751Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/193812#193812">GammaFun</a></td></tr>
<tr d-ix="21"><td>053</td><td>R</td><td>191001T183823Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/193798#193798">Robin Ry</a></td></tr>
<tr d-ix="22"><td>034</td><td>APL+WIN</td><td>191001T202454Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/193808#193808">Graham</a></td></tr>
<tr d-ix="23"><td>013</td><td>Jelly</td><td>191001T203925Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/193810#193810">Nick Ken</a></td></tr>
<tr d-ix="24"><td>040</td><td>Forth gforth</td><td>191001T183700Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/193797#193797">reffu</a></td></tr>
<tr d-ix="25"><td>037</td><td>Python 3</td><td>191001T190326Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/193802#193802">Joel</a></td></tr>
<tr d-ix="26"><td>057</td><td>JavaScript ES7</td><td>191001T172427Z</td><td><a href="https://codegolf.stackexchange.com/questions/193793/little-endian-number-to-string-conversion/193794#193794">Arnauld</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>x86 32-bit machine code, <s>24</s> 21 bytes</h1>
<p>changelog: -3 bytes: replace standard add/cmp/jbe/add with a DAS hack by @peter ferrie</p>
<p>64-bit: still 24 bytes.  Long mode removed the DAS opcode.<br />
16-bit mode: the default operand-size is 16-bit but the problem spec is inherently 32-bit.  Including hard-coded 8 hex digits.</p>
<hr />
<p><strong>Byte-reverse with <code>bswap</code> then manual int-&gt;hex in standard order</strong> (most-significant nibble first, writing hex digits to a char output buffer in ascending order.)  This avoids needing to unroll the loop to switch order between nibbles within a byte vs. across bytes.</p>
<p>Callable as <code>void lehex(char buf[8] /*edi*/, uint32_t x /*esi*/);</code> like x86-64 System V, except this doesn't work in 64-bit mode.  (It needs the output pointer in EDI for <code>stosb</code>.  The input number can be in any register other than ECX or EAX.)</p>
<pre><code>     1                             lehex:
     2 00000000 0FCE                   bswap  esi
     3 00000002 6A08                   push   8            ; 8 hex digits
     4 00000004 59                     pop    ecx
     5                             .loop:                ;do{
     6 00000005 C1C604                 rol    esi, 4       ; rotate high nibble to the bottom
     7                             
     8 00000008 89F0                   mov    eax, esi
     9 0000000A 240F                   and    al, 0x0f     ; isolate low nibble
    10 0000000C 3C0A                   cmp al, 10          ; set CF according to digit &lt;= 9
    11 0000000E 1C69                   sbb al, 0x69        ; read CF, set CF and conditionally set AF
    12 00000010 2F                     das                 ; magic, which happens to work
    13                             
    14 00000011 AA                     stosb               ; *edi++ = al
    15 00000012 E2F1                   loop  .loop       ; }while(--ecx)
    16                             
    17 00000014 C3                     ret
</code></pre>
<p>size = 0x15 = 21 bytes.</p>
<p><a href="https://tio.run/##bVRda9swFH33r7iPbeqExEnbuGaFsK1Q6Dro9lZKkO3rWNSWjCTXCWO/PbuSPcdJI2gVS/fznHPFtMYyLnbjjOlyv8@kKpmB708PgFtMasPiAmHuRfCw@vUDWFHIRkOtwUgo2TtdBeOYm4GxBing9@NPH2pRcLJ4JkfPKzDH7Z0HtGLdsAoANXefVa1z2pYwWBF9kj2kfMONbs1kZTdMtt6kkLK6g5MVpfKPs1SycJaa@7DoAyppmEHI@SYHwWPbFvVgcoRYGiNLz/mW8sP5sq3fF8hE6rbCh@l2mnXxuJaFDUiAdPGccVJWznI2HXaj0cDXB2BJIlXKxcamdr3dh85Lx3EX/yY8eClkKbn5vTsVkkiRcsOlICp27mJFBvamUYTq6smGvocwzF3glGn4BBQxt@GJD03OkxxyVlUoHKONVO8tDtpIHX/yG2HKr67gC9XqrCwPAJN262z@UtQCL8ZjYuqyDabQ7CMwqEknH6h2B2ohU7KEqc2d@cBFUtQOHuY6CoGk2DJUi5SpnYfCkPtaG6aM126tpg5CGgAfgcCm4AJ7E13HThmVD8v@sOWcWrOUVyT1o2OromC2mF0vbxbz4NTJ3pIoZsF8cX1z298mxA7BYzXv9YdR1J5T22zDuPDJwBjbLp1IAqZRnATF1CZx7dOPjwnAytLToRLQsTaKPibDsC6RhblWRGTDTQ4v3x5pZLhw8aXAccW0GROYYwoGMnO4kpdVASqEBgk/KuwTZJSgRU1Z1MIzakpIp7ZuISmm6uoDRYNmYBQjDcjIZcu4IgUo1HVhhuFbKOMdxaiMgldKdLV860YoOldQ66EsY2Tc35B@WiLh/KI5fOeVq0UWaR/4DOHz6eJ2QOcR2cuQxUmK2Vmyjz1cT69U0Nvxg2BLcVOX9qj9L@Y0p32IDo/Y@vll3aqknZxacG3S9TyY5KeOMTnOescsPb1P3AtXdfdxnX2aBzIIR0FnUKCguQ8HM2ph7Kr2wfCSXv4AYkxYrZ2cLCyYWm2bhidInt17q1mJNmGGajLgztB/QvcEJtftxcy3DlTP5VmAZkcA4ZYf9LWVqkOD/s5k2/8D" rel="nofollow noreferrer" title="Assembly (fasm, x64, Linux) – Try It Online">TIO FASM 32-bit x86 test case</a> with an asm caller that uses a <code>write</code> system call to write the output after calling it twice to append 2 strings into a buffer.  Tests all hex digits 0..F, including 9 and A at the boundary between numeral vs. letter.</p>
<p><strong>The <a href="https://github.com/HJLebbink/asm-dude/wiki/DAS" rel="nofollow noreferrer"><code>DAS</code></a> hack</strong> - x86 has a half-carry flag, for carry out of the low nibble.  Useful for packed-BCD stuff like the DAS instruction, intended for use after subtracting two 2-digit BCD integers.  With the low nibble of AL being outside the 0-9 range, we're definitely abusing it here.</p>
<p>Notice the <code>if (old_AL &gt; 99H) or (old_CF = 1)</code> THEN  <code>AL ← AL − 60H;</code> part of the Operation section in the manual; sbb <em>always</em> sets CF here so that part always happens.  That and the ASCII range for upper-case letters is what motivates the choice of <code>sbb al, 0x69</code>.</p>
<ul>
<li><code>cmp 0xD, 0xA</code> doesn't set CF</li>
<li>sbb <code>0xD - 0x69</code> wraps to AL=<code>0xA4</code> as input to DAS. (And sets CF, clears AF)</li>
<li>no AL -= 6 in the first part of DAS (because 4 &gt; 9 is false and AF=0)</li>
<li>AL -= 0x60 in the second part, leaving <code>0x44</code>, the ASCII code for <code>'D'</code></li>
</ul>
<p>vs. a numeral:</p>
<ul>
<li><code>cmp 0x3, 0xA</code> sets CF</li>
<li>sbb <code>3 - 0x69 - 1</code> = AL = 0x99 and sets CF and AF</li>
<li>AL -= 6 in the first part of DAS (9 &gt; 9 is false but AF is set), leaving 0x93</li>
<li>AL -= 0x60 in the second part, leaving 0x33, the ASCII code for <code>'3'</code>.</li>
</ul>
<p>Subtracting <code>0x6a</code> in SBB will set AF for every digit &lt;= 9 so all the numerals follow the same logic.  And leave it cleared for every alphabetic hex digit.  i.e. correctly exploiting the 9 / A split handling of DAS.</p>
<p><code>'A'</code> is 0x41, <code>'9'</code> is 0x39.  So <code>0xa + '0'</code> needs an extra <code>7</code> added to get from <code>'9'+1</code> to <code>'A'</code>.  DAS involves a <code>-=6</code> or <code>-=0x60</code>, hence the use of SBB to subtract an extra <code>1</code> for one of the cases.</p>
<hr />
<p><a href="https://stackoverflow.com/questions/53823756/how-to-convert-a-number-to-hex">Normally</a> (for performance) you'd use a lookup table for a scalar loop, or possibly a branchless 2x <code>lea</code> and <code>cmp/cmov</code> conditional add.  But 2-byte <code>al, imm8</code> instructions are a big win for code-size.</p>
<hr />
<p><strong>x86-64 version version</strong>: just the part that's different, between <code>and al, 0xf</code> and <code>stosb</code>.</p>
<pre><code>;; x86-64 int -&gt; hex  in 8 bytes
    10 0000000C 0430                   add    al, '0'
    11 0000000E 3C39                   cmp    al, '9'
    12 00000010 7602                   jbe  .digit
    13 00000012 0427                     add    al, 'a'-10 - '0'     ; al =  al&gt;9 ? al+'a'-10 : al+'0'
    14                             .digit:
</code></pre>
<p>Notice that the <code>add al, '0'</code> <em>always</em> runs, and the conditional add only adds the difference between <code>'a'-10</code> and <code>'0'</code>, to make it just an <code>if</code> instead of <code>if</code>/<code>else</code>.</p>
<p>Tested and works, using the same <code>main</code> caller as <a href="https://codegolf.stackexchange.com/questions/193793/little-endian-num-2-string-conversion/193831#193831">my C answer</a>, which uses <code>char buf[8]</code> and <code>printf(&quot;%.8s\n&quot;, buf)</code>.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.python.org" rel="nofollow noreferrer">Python 3.11+</a>, 34 bytes</h1>
<pre class="lang-python prettyprint-override"><code>lambda n:n.to_bytes(4)[::-1].hex()
</code></pre>
<p>This is a version of <a href="https://codegolf.stackexchange.com/a/193802/70305">Joel's Python 3</a> solution that works only on Python 3.11 and higher. Pre-3.11, the <code>byteorder</code> argument to <code>int.to_bytes</code>/<code>int.from_bytes</code> was mandatory; in 3.11 it is now defaulted to <code>'big'</code>, so, golf-wise, you can omit it, let <code>to_bytes</code> produce the big-endian version, then reverse it with a slice, saving three characters.</p>
<p>(Side-note: The Attempt This Online link actually cheats and just uses Joel's solution when the Python version is below 3.11; ATO is still on 3.10.6 so it can't run this code as of April, 2023)</p>
<p><a href="https://ato.pxeger.com/run?1=m72soLIkIz9vwRKuNNuYpaUlaboWN5VyEnOTUhIV8qzy9Ery45MqS1KLNUw0o62sdA1j9TJSKzQ0oSqrMnML8otKFIori7ky00CUXllqUXFmfl58Zl5avoKNgoaxjqGhphWXAhCk2WI1WEc9J7OkJCdVXRNiNldBUWZeiUaahpGhiaGphZmJsZEmQtDYwMTczFwT6oIFCyA0AA" rel="nofollow noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu2" class="pu"><h1><a href="http://www.red-lang.org" rel="nofollow noreferrer">Red</a>, 37 bytes</h1>
<pre><code>func[x][reverse/skip form to-hex x 2]
</code></pre>
<p>This breaks TIO because of the outdated compiler it uses.</p>
<h2><a href="http://www.red-lang.org" rel="nofollow noreferrer">Red</a>, 43 bytes</h2>
<pre><code>func[x][load next mold reverse to-binary x]
</code></pre>
<p><a href="https://tio.run/##FcxbDkAwEAXQrdwNSDxKxTL8Nv1Ap4mEjoySWn2xgHOEXB7JwVh45iH7KywmWbPx5BAoRey8OQjdJCchcjGvYZIHyeZD1hBhPoemVLrTf4G6UlXbd6qpbX4B" rel="nofollow noreferrer" title="Red – Try It Online">Try it online!</a></p>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.rust-lang.org/" rel="nofollow noreferrer">Rust</a>, 34 bytes</h1>

<pre class="lang-rust prettyprint-override"><code>|n|print!(&quot;{:08x}&quot;,n.swap_bytes())
</code></pre>
<p><a href="https://tio.run/##KyotLvmflqeQm5iZp6FZzaWgkJNaopBmlZanUWpspKlgq/C/Jq@moCgzr0RRQ6naysCiolZJJ0@vuDyxID6psiS1WENT8781V5qGsYGJuZm5JlftfwA" rel="nofollow noreferrer" title="Rust – Try It Online">Try it online!</a></p>
<p>Rust has built-in hex formatting, but it displays in big-endian format, so I reversed the byte order first. Capitalize the <code>x</code> if you want uppercase hex digits instead of lowercase ones.</p>
</div>
<div id="pu4" class="pu"><h2>Windows Batch, 90 bytes</h2>

<pre><code>@for /l %%x in (24,-8,0)do @set/aa=%1^>^>%%x^&255&cmd/cexit !a!&&lt;nul set/p=!=exitcode:~-2!</code></pre>

<p>Run the command-line with /v to enable the delayed expansion.</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, <s>31</s> 27 bytes</h1>

<p>Ended up being a port of <a href="https://codegolf.stackexchange.com/a/193910/52194">Night2's PHP answer</a> because Ruby has the same pack/unpack functionality.</p>



<pre class="lang-ruby prettyprint-override"><code>-&gt;*i{i.pack(?V).unpack'H8'}
</code></pre>

<p><a href="https://tio.run/##KypNqvyfZvtf104rszpTryAxOVvDPkxTrzQPxFT3sFCv/V@ekZmTqpCeWlLMpVBQWlKskBatEq9Xkh@fGcuVmpfy38jQxNDUwszE2IjL2MDE3MwcAA" rel="nofollow noreferrer" title="Ruby – Try It Online">Try it online!</a></p>

<p>My original 31-byte answer that didn't take advantage of the H8 unpack mode because I didn't know about it:</p>

<pre class="lang-ruby prettyprint-override"><code>-&gt;*i{'%02x'*4%i.pack(?V).bytes}
</code></pre>

<p><a href="https://tio.run/##KypNqvyfZvtf104rs1pd1cCoQl3LRDVTryAxOVvDPkxTL6myJLW49n95RmZOqkJ6akkxl0JBaUmxQlq0SrxeSX58ZixXal7KfyNDE0NTCzMTYyMuYwMTczNzAA" rel="nofollow noreferrer" title="Ruby – Try It Online">Try it online!</a></p>
</div>
<div id="pu6" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>, 43 bytes</h1>



<pre class="lang-python prettyprint-override"><code>lambda n:[("%08x"%n)[i^6]for i in range(8)]
</code></pre>

<p><a href="https://tio.run/##FcjRCsIgFAbge5/iIAwURmzOnAx6EjMwyjpRv0N2UU9v7Lv81t/2LDAtn87tnT7XWyIsQclu8F/ZQQe@uJhLJSYG1YTHXXkd217YKwgyox2P3tnJ9IKmwc5u7kVcBK2VsZGUh1dhqKygdfsD" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>

<p><em>-4 bytes thanks to <a href="https://codegolf.stackexchange.com/users/89587/benrg">benrg</a></em></p>

<p>Outputs a list of characters. Computed by retrieving, in order, the hex digits of the input at indices <code>6, 7, 4, 5, 2, 3, 0, 1</code>.</p>
</div>
<div id="pu7" class="pu"><h1><a href="http://jsoftware.com/" rel="nofollow noreferrer">J</a>, 10 bytes</h1>
<pre><code>8{._1{3!:3
</code></pre>
<p><a href="https://tio.run/##y/qvpKeepmBrpaCuoKNgoGAFxLp6Cs5BPm7/Lar14g2rjRWtjP9rcnGlJmfkK6QpGBuYmJuZw3hGhiaGphZmJsZG/wE" rel="nofollow noreferrer" title="J – Try It Online">Try it online!</a></p>
<h2>how</h2>
<p><code>3!:3</code> is a J &quot;foreign conjunction&quot; for hex representation, documented <a href="https://www.jsoftware.com/help/dictionary/dx003.htm" rel="nofollow noreferrer">here</a>.  That is, it's a builtin for converting to hex.  However, it's output it not quite what we want. Eg, running:</p>
<pre><code>3!:3 (304767)
</code></pre>
<p>produces:</p>
<pre><code>e300000000000000
0400000000000000
0100000000000000
0000000000000000
7fa6040000000000
</code></pre>
<p>The meaning of the other lines is explained on the doc page I linked to above.  In any case, it's clear we want the first 8 chars of the last line.</p>
<p><code>_1{</code> get the last line.</p>
<p><code>8{.</code> gets the first 8 characters of it.</p>
</div>
<div id="pu8" class="pu"><h1><a href="https://php.net/" rel="nofollow noreferrer">PHP</a>, 31 bytes</h1>



<pre class="lang-php prettyprint-override"><code>&lt;?=unpack(H8,pack(V,$argn))[1];
</code></pre>

<p><a href="https://tio.run/##K8go@P/fxt62NK8gMTlbw8NCB0yH6agkFqXnaWpGG8Za/09NzshXUIrJU7L@b2RoYmhqYWZibMRlbGBibmb@L7@gJDM/r/i/rhsA" rel="nofollow noreferrer" title="PHP – Try It Online">Try it online!</a></p>

<p>Taking advantage of PHP's <a href="https://www.php.net/manual/en/function.pack.php" rel="nofollow noreferrer">pack</a> and <a href="https://www.php.net/manual/en/function.unpack.php" rel="nofollow noreferrer">unpack</a>, I pack the unsigned input with "32 bit little endian byte order" format (<code>V</code>) into a binary string and then unpack it with "hex string, high nibble first" format (<code>H</code>) and print the result.</p>

<p>This seems to be one of the rare cases where PHP's built-ins are actually shorter than implementing a simple algorithm!</p>
</div>
<div id="pu9" class="pu"><h1><a href="https://www.perl.org/" rel="nofollow noreferrer">Perl 5</a> (-p), 22 bytes</h1>



<pre class="lang-perl prettyprint-override"><code>$_=unpack H8,pack V,$_
</code></pre>

<p><a href="https://tio.run/##K0gtyjH9/18l3rY0ryAxOVvBw0IHTIfpqMT//29kaGJoamFmYmzEZWxgYm5m/i@/oCQzP6/4v25BDgA" rel="nofollow noreferrer" title="Perl 5 – Try It Online">Try it online!</a></p>
</div>
<div id="pu10" class="pu"><h1><a href="https://kx.com/download/" rel="nofollow noreferrer">K4</a>, <s>12</s> 11 bytes</h1>

<p><strong>Solution:</strong></p>

<pre><code>,/$|4_0x0\:
</code></pre>

<p><strong>Examples:</strong></p>

<pre><code>q)k),/$|4_0x0\:304767
"7fa60400"
q)0W
"0004a67f"
</code></pre>

<p><strong>Explanation:</strong></p>

<p>Pretty much exactly what the question asks:</p>

<pre><code>,/$|4_0x0\: / the solution
      0x0\: / split to bytes
    4_      / drop first 4 bytes
   |        / reverse
  $         / convert to string
,/          / flatten
</code></pre>

<p><strong>Notes:</strong></p>

<ul>
<li><strong>-1 byte</strong> as K4 numbers are longs (64bit) by default, so dropping 4 bytes (32bits)</li>
</ul>
</div>
<div id="pu11" class="pu"><h1><a href="http://www.mono-project.com/docs/about-mono/releases/5.0.0/#csc" rel="nofollow noreferrer">C# (Visual C# Interactive Compiler)</a>, 54 bytes</h1>

<pre class="lang-cs prettyprint-override"><code>x=&gt;$&quot;{(x=x&gt;&gt;16|x&lt;&lt;16)&gt;&gt;8&amp;16711935|(x&amp;16711935)&lt;&lt;8:x8}&quot;
</code></pre>
<p>Saved 4 bytes thanks to @PeterCordes</p>
<p><a href="https://tio.run/##Sy7WTS7O/O9WmpdsU5qZV6JTXFKUmZdul2b7v8LWTkWpWqPCtsLOztCspsLGxtBM087OQs3QzNzQ0NLYtEajAs7WtLGxsKqwqFX6b80VXpRZkuqTmZeqkaZhZGhiaGphZmJspKkJlQGKGhuYmJuZA0X@AwA" rel="nofollow noreferrer" title="C# (Visual C# Interactive Compiler) – Try It Online">Try it online!</a></p>
<h3>Explanation</h3>
<pre class="lang-cs prettyprint-override"><code>x=&gt;                                                    //Lambda taking in an uint
     (x=x&gt;&gt;16|x&lt;&lt;16)                                   //Swap the first two and the last two bytes of the uint (0x7fa60400 -&gt; 0x04007fa6)
                    &gt;&gt;8&amp;16711935|(x&amp;16711935)&lt;&lt;8       //Swap each pair of bytes in every group of 2 bytes (0x04007fa6 -&gt; 0x0004a67f)
  $&quot;{                                           :x8}&quot;  //Format as hex string, padded with leading zeroes to length 8
</code></pre>
</div>
<div id="pu12" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C (gcc)</a>, 30 bytes</h1>



<pre class="lang-c prettyprint-override"><code>f(x){printf("%.8x",htonl(x));}
</code></pre>

<p><a href="https://tio.run/##dcrdCsIgGIDhc69CFrFPqLEf2wZGV9LJ0NmE9TlMYzB27SbRae/hwyvPDylj1LCybXEGvYbsWPRrdpq8xTkxE3s8GJRzUCO9vrwytphuhKSXPgeD8LZGMbIRmtJQV7y69C1vaia@tAQvp8FBfsf8Rxqakndt9/9wow8OaSnIHj8" rel="nofollow noreferrer" title="C (gcc) – Try It Online">Try it online!</a></p>
</div>
<div id="pu13" class="pu"><h1><a href="http://www.scala-lang.org/" rel="nofollow noreferrer">Scala</a>, <s>58</s> <s>40</s> 36 bytes</h1>



<pre class="lang-scala prettyprint-override"><code>"%08X"format Integer.reverseBytes(_)
</code></pre>

<p><a href="https://tio.run/##XcpBC4IwGIDhu7/iQwq2S0xdToQFdevQKYIgIr5sE0NnbEMQ8bfboFu3F97HVdji0j/fqvJwwsbAFL2Uhi4kQVu7EvbW4ng7e9uY@k5LuJjGgwxuwBZ0SY7GU7n7fbnEa1ZcY93bDj2EpWplN1YNyjp1GL1y5EGX6BOwbw1x8WrSJE14si1ynqV0BimBMcYxFzqmfzBjXOTih4TGnHHGAormefkC" rel="nofollow noreferrer" title="Scala – Try It Online">Try it online!</a></p>

<p>Still uses the builtin to reverse the bytes of an <code>Int</code>, but uses <code>format</code> to format the <code>Int</code> as a Hex. No need to call <code>toHexString</code>.</p>

<p>Removed the parens on <code>format</code>. This now means that the argument can be taken implicitly using <code>_</code>.</p>
</div>
<div id="pu14" class="pu"><h1>x86 SIMD machine code (AVX512-VBMI), 36 bytes</h1>

<p>(16 bytes of which are a hex lookup table)</p>

<p>This is a function that takes an integer in <code>xmm0</code> and returns 8 bytes of ASCII char data in <code>xmm0</code>, for the caller to store wherever it wants.  (e.g. to video memory after interleaving with attribute bytes, or into a string under construction, or whatever)</p>

<p>From C, call it as <code>__m128i retval = lehex(_mm_cvtsi32_si128(x))</code> with the x86-64 System V calling convention, or MS Windows <code>vectorcall</code>.</p>

<pre><code># disassembly with machine-code bytes (the answer) and NASM source code.
0000000000401000 &lt;lehex&gt;:
  401000:       c5 f1 72 d0 04          vpsrld      xmm1, xmm0, 4         ; AVX1
  401005:       c5 f1 60 c8             vpunpcklbw  xmm1, xmm1, xmm0      ; AVX1
  401009:    62 f2 75 08 8d 05 01 00 00 00 vpermb  xmm0, xmm1, [rel .hex_lut]
  401013:       c3                      ret    

0000000000401014 &lt;lehex.hex_lut&gt;:
  401014:     30 31 ...  61 62 ...     .hex_lut:  db "0123456789abcdef"
</code></pre>

<p>Total = 0x24 = 36 bytes.</p>

<p><strong>See <a href="https://stackoverflow.com/questions/53823756/how-to-convert-a-number-to-hex">How to convert a number to hex?</a> on SO for how this works.</strong>  (SSE2 for the shift / punpck, then <code>vpermb</code> saves work that we'd need for <code>pshufb</code>.  AVX1 instead of SSE2/SSSE3 also avoids a <code>movaps</code> register copy.)</p>

<p>Notice that <code>punpcklbw</code> with the source operands in that order will give us the most-significant nibble of the low input byte in the lowest byte element, then the least-significant nibble of the lowest source byte.  (In that SO answer, a <code>bswap</code> is used on the input to get a result in standard printing order with only SSE2.  But here we <em>want</em> that order: high nibble in lower element within each byte, but still little-endian byte order).</p>

<p>If we had more data constants, we could save addressing-mode space by doing one <code>mov edx, imm32</code> then using <code>[rdx+16]</code> or whatever addressing modes.  Or <code>vpbroadcastb xmm0, [rdx+1]</code>.</p>

<p>But I think a 16-byte hex LUT + <code>vpermb</code> is still better than implementing the <code>n&gt;9 : n+'a'-10 : n+'0'</code> condition: that requires 3 constants and at least 3 instructions with AVX512BW byte-masking (compare into mask, <code>vpaddb</code>, merge-masked <code>vpaddb</code>), or more with AVX1 or SSE2.  (See <a href="https://stackoverflow.com/questions/53823756/how-to-convert-a-number-to-hex">How to convert a number to hex?</a> on SO for an SSE2 version of that).  And each AVX512BW instruction is at least 6 bytes long (4-byte EVEX + opcode + modrm), longer with a displacement in the addressing mode.</p>

<p>Actually it would take at least <em>4</em> instructions because we need to clear high garbage with <code>andps</code>, (or EVEX <code>vpandd</code> with a 4-byte broadcast memory operand) before the compare.  And each of those needs a different vector constant.  AVX512 has broadcast memory operands, but only for elements of 32-bit and wider.  e.g. <a href="https://www.felixcloutier.com/x86/paddb:paddw:paddd:paddq" rel="nofollow noreferrer">EVEX <code>vpaddb</code></a>'s last operand is only <code>xmm3/m128</code>, not <code>xmm3/m128/m8bcst</code>.  (Intel's load ports can only do 32 and 64-bit broadcasts for free as part of a load uop so Intel designed AVX512BW to reflect that and not be able to encode byte or word broadcast memory operands at all, instead of giving them the option to do dword broadcasts so you can still compress your constants to 4 bytes :/.)</p>

<p><strong>The reason I used <a href="https://www.felixcloutier.com/x86/vpermb" rel="nofollow noreferrer">AVX512VBMI <code>vpermb</code></a> instead of SSSE3 / AVX1 <code>pshufb</code> is twofold:</strong></p>

<ul>
<li><code>vpermb</code> ignores high bits of the selectors.  <code>(v)pshufb</code> zeros bytes according to the high bit of the control vector and would have needed an extra <code>pand</code> or <code>andps</code> to actually isolate nibbles.  With XMM / 16-byte size, <code>vpermb</code> only looks at the low 4 bits of the shuffle-control elements, i.e. bits <code>[3:0]</code> in Intel's notation in the <a href="https://www.felixcloutier.com/x86/vpermb" rel="nofollow noreferrer">Operation section</a>.</li>
<li><code>vpermb</code> can take the data to be shuffled (the lookup table) as a memory operand.  <code>(v)pshufb</code>'s xmm/mem operand is the shuffle-control vector.</li>
</ul>

<p>Note that AVX512VBMI is only available on CannonLake / Ice Lake so you probably need a simulator to test this, like Intel's SDE.</p>
</div>
<div id="pu15" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 11 bytes</h1>

<pre><code>⪫⮌⪪﹪%08xＮ²ω
</code></pre>

<p><a href="https://tio.run/##S85ILErOT8z5/z@gKDOvRMMrPzNPIyi1LLWoOFUjuCAns0TDNz@lNCdfQ0nVwKJCSUfBM6@gtMSvNDcptUhDU1NHwQhElGtqWv//b2xgYm5m/l@3LAcA" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Explanation:</p>

<pre><code>        Ｎ   Input as a number
   ﹪%08x    Format using literal string
  ⪪      ²  Split into pairs of characters
 ⮌          Reverse
⪫         ω Join
            Implicitly print
</code></pre>

<p>19 bytes without resorting to Python formatting:</p>

<pre><code>⪫…⮌⪪⍘⁺Ｘ²¦³⁶Ｎ¹⁶¦²¦⁴ω
</code></pre>

<p><a href="https://tio.run/##S85ILErOT8z5/z@gKDOvRMMrPzNPw7kyOSfVOSO/QCMotSy1qDhVI7ggJ7NEwymxODW4BKguXSMgp7RYIyC/PLVIw0hHwdhMU0fBM6@gtMSvNDcJKKYJ5BuCBI1ALBMgLtfUtP7/39jAxNzM/L9uWQ4A" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Explanation:</p>

<pre><code>           Ｎ        Input as a number
     ⁺              Plus
       ²            Literal 2
      Ｘ             To power
         ³⁶         Literal 36
    ⍘               Convert to base
            ¹⁶      Literal 16
   ⪪           ²    Split into pairs of digits
  ⮌                 Reverse the list
 …               ⁴  Take the first 4 pairs
⪫                 ω Join together
                    Implicitly print
</code></pre>
</div>
<div id="pu16" class="pu"><h1>Excel, 91 bytes</h1>

<pre><code>=RIGHT(DEC2HEX(A1,8),2)&amp;MID(DEC2HEX(A1,8),5,2)&amp;MID(DEC2HEX(A1,8),3,2)&amp;LEFT(DEC2HEX(A1,8),2)
</code></pre>
</div>
<div id="pu17" class="pu"><h1><a href="https://github.com/ETHproductions/japt" rel="nofollow noreferrer">Japt</a> <a href="https://codegolf.meta.stackexchange.com/a/14339/"><code>-P</code></a>, 10 <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>sG ùT8 ò w
</code></pre>
<p><a href="https://petershaggynoble.github.io/Japt-Interpreter/?v=1.4.6&amp;flags=LVA&amp;code=c0cg%2bVQ4IPIgdw&amp;input=MzA0NzY3" rel="nofollow noreferrer">Try it</a></p>
<pre><code>sG ùT8 ò w     :Implicit input of integer
s              :Convert to string
 G             :  In base-16
   ù           :Left pad
    T          :  With 0
     8         :  To length 8
       ò       :Split into 2s
         w     :Reverse
               :Implicitly join and output
</code></pre>
</div>
<div id="pu18" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C (gcc)</a> endian agnostic, no standard libs, <s>92</s> 91 bytes</h1>

<p><code>h(n)</code> is a single-digit integer->hex helper function.<br>
<code>f(x,p)</code> takes an integer and a <code>char[8]</code> pointer.  The result is 8 bytes of <code>char</code> data.  (<em>Not</em> 0-terminated unless the caller does that.)</p>

<p>Assumptions: ASCII character set.  2's complement <code>int</code> so right shift eventually brings down the sign bit, and converting a <code>uint32_t</code> to <code>int</code> doesn't munge the bit-pattern if the high bit is set.  <code>int</code> is at least 32-bit.  (Wider might let it work on 1's complement or sign-magnitude C implementations).</p>

<p>Non-assumptions: anything about implementation byte-order or signedness of <code>char</code>.</p>



<pre class="lang-c prettyprint-override"><code>i;h(n){n&amp;=15;return n&gt;9?n+87:n+48;}f(x,p)char*p;{for(i=5;--i;x&gt;&gt;=8)*p++=h(x&gt;&gt;4),*p++=h(x);}
</code></pre>

<p><a href="https://tio.run/##hZHdcpswEIXv9RQ7ybRAMP6JcUyi4rxAO73IRS7STEcGCdTShZGE48TDq5dIYGcm03aqK1bLnj3fURYVWdafS8yqNufwSZtc1tNy00ta@hgc8GO6WFHFTasQcHN9i2GyvsEwTmgn/P2kCbKSqYuGHkStfJmuaBRJut9s0iS4aMIwLX1bxMHkVAS06yUakJTMZuc5FxI5uFWAdcMngJznGvjeKAYNUxw1abGoK8Hz7391BLeAoce8aDGHG/c592gHw5nNQEssKg65LKTdiYYXXEG0gZLvCdnVMoc39fc4xAmcmMBBwUg16n6@g@2z4SCk0gZYpmqthxtN4Hje4b8Z@nIHKLfb6jT6JE0p8R@jASUdIX@@DnEJ/mISfYcQkNGtsw7bVjxcP6aHh@Qx9V68jo5r3RpgYFOVlY0EMoZMPY8MprajPPvpcN28sBHVO65EVT/ZutDTMQz/chEvVslVvLycuP@sO3ffKOtG@Gcfpon@hmfH1rh26MGP1oKakkMCO1bZzAfak@pyHq@v1v9XHFrHd5@7YPrfmahYofvo67KP7llVvQI" rel="nofollow noreferrer" title="C (gcc) – Try It Online">Try it online!</a>  including test caller using <code>printf("%.8s\n", buf)</code> to print output buffer without 0-terminating it.</p>

<p><strong>Ungolfed:</strong></p>

<pre class="lang-c prettyprint-override"><code>int h(n){n&amp;=15;return n&gt;9 ? n+'a'-10 : n+'0';}      // single digit integer -&gt; hex

int i;
void ungolfed_f(x,p)char*p;{
    for(i=5; --i; x&gt;&gt;=8)   // LS byte first across bytes
        *p++=h(x&gt;&gt;4),      // MS nibble first within bytes
        *p++=h(x);
}
</code></pre>

<p>Doing <code>n&amp;=15;</code> inside <code>h(x)</code> is break-even; 6 bytes there vs. 3 each for <code>&amp;15</code> to isolate the low nibble at both call sites.</p>

<p><code>,</code> is a sequence point (or equivalent in modern terminology) so it's safe to do <code>*p++= stuff</code> twice in one statement when separated by the <code>,</code> operator.</p>

<p><code>&gt;&gt;</code> on signed integer is implementation-defined as either arithmetic or logical.  GNU C defines it as arithmetic 2's complement.  But on any 2's complement machine it doesn't really matter because we never look at the shifted-in 0s or copies of the sign bit.  The original MSB will eventually get down into the low byte unchanged.  This is not the case on sign/magnitude, and I'm not sure about 1's complement.</p>

<p>So this may only be portable to 2's complement C implementations.  (Or where <code>int</code> is <em>wider</em> than 32 bits so bit 31 is just part of the magnitude.)  unsigned -> signed conversion also munges the bit-pattern for negative integers, so <code>&amp;15</code> on an <code>int</code> would only extract nibbles of the original unsigned value on 2's complement.  Again, unless <code>int</code> was <em>wider</em> than 32-bit so all inputs are non-negative.</p>

<p>The golfed version has UB from falling off the end of a non-void function.  Not to return a value, just to avoid declaring it <code>void</code> instead of default <code>int</code>.  Modern compilers will break this with optimization enabled.</p>

<hr>

<p>Motivation: I was considering an x86 or ARM Thumb asm answer, thought it might be fun to do it manually in C, maybe for compiler-generated asm as a starting point.  See <a href="https://stackoverflow.com/questions/53823756/how-to-convert-a-number-to-hex">https://stackoverflow.com/questions/53823756/how-to-convert-a-number-to-hex</a> for speed-efficient x86 asm, including an AVX512VBMI version that's only 2 instructions (but needs control vectors for vpmultishiftqb and vpshufb so wouldn't be great for golf).  Normally it takes extra work for SIMD to byte-reverse into printing order on little-endian x86 so this byte-reversed hex output is actually easier than normal.</p>

<hr>

<p><strong>Other ideas</strong></p>

<p>I considered taking the integer by reference and looping over its bytes with <code>char*</code>, on a little-endian C implementation (like x86 or ARM).  But I don't think that would have saved much.</p>

<p>Using <code>sprintf</code> to do 1 byte at a time, 64 bytes after golfing:</p>

<pre class="lang-c prettyprint-override"><code>int i;
void f(x,p)char*p;{
        for(i=4;sprintf(p,"%.2x",x&amp;255),--i;x&gt;&gt;=8)
                p+=2;
}
</code></pre>

<p>But if we're using printf-like functions we might as well byte-swap and do a <code>%x</code> printf of the whole thing like <a href="https://codegolf.stackexchange.com/questions/193793/little-endian-num-2-string-conversion/193801#193801">@JL2210's answer</a>.</p>
</div>
<div id="pu19" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E" rel="nofollow noreferrer">05AB1E</a>, <s>10</s> 9 bytes</h1>

<pre><code>žJ+h¦2ôRJ
</code></pre>

<p><a href="https://tio.run/##yy9OTMpM/f//6D4v7YxDy4wObwny@v/f0MjYxNQMAA" rel="nofollow noreferrer" title="05AB1E – Try It Online">Try it online!</a></p>

<p>-1 byte by inspiration of the Jelly answer.</p>

<pre><code>žJ+   add 2^32 to input
h     convert to hex
¦     drop leading 1
2ô    split in groups of 2
R     reverse groups
J     and join them
</code></pre>
</div>
<div id="pu20" class="pu"><h1><a href="https://www.zsh.org/" rel="noreferrer">Zsh</a>, 46 bytes</h1>



<pre class="lang-sh prettyprint-override"><code>i=$1
repeat 4 printf %02x $[j=i%256,i=i/256,j]
</code></pre>

<p><a href="https://tio.run/##qyrO@J@moVn9P9NWxZCrKLUgNbFEwUShoCgzryRNQdXAqEJBJTrLNlPVyNRMJ9M2Ux9EZ8X@r@XiSssvUshTyMxTMDYwMTczVzAyNDE0tTAzMTayruZSUEhTUMkDUqnJGflctf8B" rel="noreferrer" title="Zsh – Try It Online">Try it online!</a></p>
</div>
<div id="pu21" class="pu"><h1><a href="https://www.r-project.org/" rel="nofollow noreferrer">R</a>, <s>54</s> 53 bytes</h1>



<pre class="lang-r prettyprint-override"><code>format.hexmode(scan()%/%256^(0:3)%%256%*%256^(3:0),8)
</code></pre>

<p><a href="https://tio.run/##K/r/Py2/KDexRC8jtSI3PyVVozg5MU9DU1Vf1cjULE7DwMpYUxXEVNWCCBhbGWjqWGj@NzI0MTS1MDMxNvoPAA" rel="nofollow noreferrer" title="R – Try It Online">Try it online!</a></p>

<p>Each group of 2 characters is actually the hex representation of a digit in base 256. <code>scan()%/%256^(0:3)%%256</code> converts to a base 256 number with 4 digits reversed, 
<code>...%*%256^(3:0)</code> joins them as a single integer, and <code>format.hexmode(...,8)</code> converts that number to its hex representation with 8 digits.</p>
</div>
<div id="pu22" class="pu"><h1>APL+WIN, <s>36</s> 34 bytes</h1>
<p>2 bytes saved by converting to index zero</p>
<p>Prompts for integer:</p>
<pre><code>'0123456789abcdef'[,⊖4 2⍴(8⍴16)⊤⎕]
</code></pre>
<p><a href="https://tio.run/##SyzI0U2pTMzJT9dNzkksLs5M/v@ob6qvz6O2CcZcQJanP5BlwPWooz3tv7qBoZGxiamZuYVlYlJySmqaerTOo65pJgpGj3q3aFgACUMzzUddS4DaYv8DdfxP4zI2MDE3M@dK4zIyNDE0tTAzMTYCAA" rel="nofollow noreferrer" title="APL (Dyalog Classic) – Try It Online">Try it online! Courtesy Dyalog Classic</a></p>
</div>
<div id="pu23" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 13 bytes</h1>

<pre><code>+Ø%b⁴Ḋs2Ṛ‘ịØh
</code></pre>

<p><a href="https://tio.run/##ASkA1v9qZWxsef//K8OYJWLigbThuIpzMuG5muKAmOG7i8OYaP///zMwNDc2Nw" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>

<p>A full program that takes an integer as its argument and prints a string. </p>
</div>
<div id="pu24" class="pu"><h1><a href="http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/" rel="nofollow noreferrer">Forth (gforth)</a>, <strike>52 51</strike> 40 bytes</h1>

<pre class="lang-forth prettyprint-override"><code>: f hex 0 4. do &lt;# # # 0. #&gt; type loop ;
</code></pre>
<p><a href="https://tio.run/##FYvBCoMwFMDufkXQs6XVTmWK/zJsOwdKH8XB9vVVySGXJMR0rPU73Mr5SWD1PzRW4SJTxY1WVDPHXzxbjMJ4hYL7CkajEqqEeqa8bueXz/7aWBJj0RhrHkNn2wakaLXtux7JJw" rel="nofollow noreferrer" title="Forth (gforth) – Try It Online">Try it online!</a></p>
<h3>Code explanation</h3>
<pre class="lang-forth prettyprint-override"><code>: f           \ start a new word definition
  hex         \ set the current base to base 16
  0           \ convert the input number to a double-cell integer
  4. do       \ start a counted loop from 0 to 3
    &lt;# # #    \ start a formatted numeric string and move last 2 digits to format area
    0.        \ move remaining digits down the stack
    #&gt;        \ delete top two stack value and convert format area to string
    type      \ output string
  loop        \ end loop
;             \ end word definition
</code></pre>
</div>
<div id="pu25" class="pu"><h1><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python 3</a>, 37 bytes</h1>



<pre class="lang-python prettyprint-override"><code>lambda n:n.to_bytes(4,"little").hex()
</code></pre>

<p><a href="https://tio.run/##K6gsycjPM/6fZhvzPycxNyklUSHPKk@vJD8@qbIktVjDREcpJ7OkJCdVSVMvI7VCQ/N/QVFmXolGmoaRoYmhqYWZibGRpiYXTNDYwMTczFxT8z8A" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>

<p><strong>Arithmetic-based recursive solution (<s>50</s> 49 bytes, works also for <a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>)</strong>:</p>



<pre class="lang-python prettyprint-override"><code>f=lambda n,i=4:i*'1'and"%02x"%(n%256)+f(n&gt;&gt;8,i-1)
</code></pre>

<p><a href="https://tio.run/##NchLCoAgFADAfaeIQPSVQX7SCPQuRkhCvSJc1Olt1SznevN2oioluj0cyxpq5MnpObVU0IBrQwb5NIQhkaOBLjL0fuKpF1CuO2FmkUmhxTgZrSRA9acatDUWoHw" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>

<p><em>-1 byte thanks to @JonathanAllan</em></p>
</div>
<div id="pu26" class="pu"><h1>JavaScript (ES7), <s> 59 </s> 57 bytes</h1>
<p>String manipulation.</p>

<pre class="lang-javascript prettyprint-override"><code>n=&gt;(n+2**32).toString(16).match(/\B../g).reverse().join``
</code></pre>
<p><a href="https://tio.run/##VcwxEsIgEEDR3lOkhDgumwTBJhZewdYiDEIkExeHMLk@Yumv3/zF7GazKXzyieLTFT8WGq@Mjn3bDj2HHO85BZpZpzi8TbYvJh43ADFzSG53aXOMwxIDTVOxkba4OljjzDzrO9mdL0rWDW@EaBBRGqX94Z8NKLXSlfyqTHujUCKWLw" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<h3>How?</h3>
<p>We first convert <span class="math-container">\$n + 2^{32}\$</span> to hexadecimal to make sure that all leading <span class="math-container">\$0\$</span>'s are included:</p>
<pre class="lang-javascript prettyprint-override"><code>(304767 + 2**32).toString(16) // --&gt; '10004a67f'
</code></pre>
<p><a href="https://tio.run/##y0osSyxOLsosKNHNy09J/Z@cn1ecn5Oql5OfrvFfw9jAxNzMXEFbwUhLy9hIU68kP7ikKDMvXcPQTPO/5n8A" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<p>We use the regular expression <code>/\B../g</code> to match all groups of 2 digits, ignoring the leading <span class="math-container">\$1\$</span> thanks to <code>\B</code> (non-<em>word boundary</em>).</p>
<pre class="lang-javascript prettyprint-override"><code>'10004a67f'.match(/\B../g) // --&gt; [ '00', '04', 'a6', '7f' ]
</code></pre>
<p><a href="https://tio.run/##y0osSyxOLsosKNHNy09J/Z@cn1ecn5Oql5OfrvFf3dDAwMAk0cw8TV0vN7EkOUNDP8ZJT08/XfO/5n8A" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<p>We <code>reverse()</code> and <code>join()</code> to get the final string.</p>
<hr />
<h1>JavaScript (ES6), 61 bytes</h1>
<p>Recursive function.</p>

<pre class="lang-javascript prettyprint-override"><code>f=(n,k=4)=&gt;k?[(x=n&amp;255)&gt;&gt;4&amp;&amp;'']+x.toString(16)+f(n&gt;&gt;8,k-1):''
</code></pre>
<p><a href="https://tio.run/##Vcq7DoMgFADQvV/hJBBfF72AaQL9iI5NB2LF@Ag0ahr/ntqxZz6T/ditW8f3Xvjw6mN0mvp81si0mW8Pemif1kIwYzBNCXlmR7mH@76OfqBcssxRb0ybzwVnV0JiF/wWlr5cwkAdrTly0UpsasaSqkoAAK1U7vLfGkAl1Vl@zqaclYAA8Qs" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/193793/">193793</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




