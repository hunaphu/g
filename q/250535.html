<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::250535</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>147</td><td>JavaScript Node.js</td><td>250409T193726Z</td><td><a href="https://codegolf.stackexchange.com/questions/250535/ies-extra-robust-color-parsing/279122#279122">l4m2</a></td></tr>
<tr d-ix="1"><td>237</td><td>AWK</td><td>250409T170444Z</td><td><a href="https://codegolf.stackexchange.com/questions/250535/ies-extra-robust-color-parsing/279116#279116">xrs</a></td></tr>
<tr d-ix="2"><td>273</td><td>C clang</td><td>221222T162222Z</td><td><a href="https://codegolf.stackexchange.com/questions/250535/ies-extra-robust-color-parsing/255925#255925">PisuCat</a></td></tr>
<tr d-ix="3"><td>052</td><td>Japt v2.0a0</td><td>221212T231232Z</td><td><a href="https://codegolf.stackexchange.com/questions/250535/ies-extra-robust-color-parsing/255434#255434">Kamil Dr</a></td></tr>
<tr d-ix="4"><td>nan</td><td></td><td>221211T011006Z</td><td><a href="https://codegolf.stackexchange.com/questions/250535/ies-extra-robust-color-parsing/255397#255397">bigyihsu</a></td></tr>
<tr d-ix="5"><td>337</td><td>Python 3</td><td>221210T161703Z</td><td><a href="https://codegolf.stackexchange.com/questions/250535/ies-extra-robust-color-parsing/255393#255393">The Thon</a></td></tr>
<tr d-ix="6"><td>227</td><td>C#</td><td>220808T140052Z</td><td><a href="https://codegolf.stackexchange.com/questions/250535/ies-extra-robust-color-parsing/250825#250825">Acer</a></td></tr>
<tr d-ix="7"><td>029</td><td>Vyxal</td><td>220803T020511Z</td><td><a href="https://codegolf.stackexchange.com/questions/250535/ies-extra-robust-color-parsing/250654#250654">emanresu</a></td></tr>
<tr d-ix="8"><td>050</td><td>JavaScript + HTML</td><td>220802T185108Z</td><td><a href="https://codegolf.stackexchange.com/questions/250535/ies-extra-robust-color-parsing/250644#250644">naffetS</a></td></tr>
<tr d-ix="9"><td>234</td><td>JavaScript</td><td>220802T193442Z</td><td><a href="https://codegolf.stackexchange.com/questions/250535/ies-extra-robust-color-parsing/250645#250645">Leaf</a></td></tr>
<tr d-ix="10"><td>044</td><td>Vyxal</td><td>220731T190314Z</td><td><a href="https://codegolf.stackexchange.com/questions/250535/ies-extra-robust-color-parsing/250549#250549">naffetS</a></td></tr>
<tr d-ix="11"><td>340</td><td>Rust</td><td>220802T094738Z</td><td><a href="https://codegolf.stackexchange.com/questions/250535/ies-extra-robust-color-parsing/250633#250633">Lamdba</a></td></tr>
<tr d-ix="12"><td>138</td><td>JavaScript Browser</td><td>220801T095348Z</td><td><a href="https://codegolf.stackexchange.com/questions/250535/ies-extra-robust-color-parsing/250578#250578">tsh</a></td></tr>
<tr d-ix="13"><td>039</td><td>Jelly</td><td>220731T161004Z</td><td><a href="https://codegolf.stackexchange.com/questions/250535/ies-extra-robust-color-parsing/250539#250539">Jonathan</a></td></tr>
<tr d-ix="14"><td>047</td><td>05AB1E</td><td>220801T092320Z</td><td><a href="https://codegolf.stackexchange.com/questions/250535/ies-extra-robust-color-parsing/250577#250577">Kevin Cr</a></td></tr>
<tr d-ix="15"><td>117</td><td>Retina 0.8.2</td><td>220731T184133Z</td><td><a href="https://codegolf.stackexchange.com/questions/250535/ies-extra-robust-color-parsing/250545#250545">Neil</a></td></tr>
<tr d-ix="16"><td>064</td><td>Vyxal</td><td>220731T125503Z</td><td><a href="https://codegolf.stackexchange.com/questions/250535/ies-extra-robust-color-parsing/250536#250536">lyxal</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 147 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>f=(X,d=-8,t=[w=0,n=(x=X+0+0).length/3|0,n*2].map(b=&gt;+(y=x.substr(b,n).slice(d).replace(/[g-z]/gi,0),w+=y[0]&lt;1,'0x0'+y.slice(0,2))))=&gt;w&gt;2?f(X,d+1):t
</code></pre>
<p><a href="https://tio.run/##jZJdb4IwFIbv@RUku7BIxQMq4rayoMC@vF1i4lwUWhkLgoOqaPbfXadeLEucvGnSjzw5eXpyPmbrWRHm8ZI30oyy/ZyIhUaYkoaFORlvCOCUoJKMVFBB0RKWRvy92foSz3Vjoi1mSxQQW0VbUmrFKih4jgKcKlqRxCFDVNFytkxm4tgcR43dpBnFGBS8Ucl2DJNbHdeghJq6PfGADUWE2BvbuJv/eKi6cs33N1MpZ1T@Nw1bvgIAD1wpXyWsqMSCpButdsfsWj1w@gPX@3M9sa32wLV6Uu64ceYMeLz2ztd1XGcAnuQPX3z/koMP4Psg@bJc4W8CFr5yJfYQafcZcL6@yPYFK0smDUwWtntsTo2uFVIIwp5BddZh0DWoaR1g0xNNEU0DowXQ7gCY3bOF9aPE/cPj0/OwmvBxq8ZONZ7HC/Rrwt5eN/VmtMAlscMsLbKEaUkWoTkqxUztvwE" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<p>Seems only one other JS answer compute and it's 200+ bytes</p>
<p>Fix that <code>0e01</code> is also treated as 0</p>
<p>Also the two branch in description is unnecessary</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.gnu.org/software/gawk/" rel="nofollow noreferrer">AWK</a>, 237 bytes</h1>
<pre><code>{$0=toupper($0);for(gsub(/[^0-9A-F]/,0);(k=length)%3||!k;)$0=$0 0
for(z=k/3;l&lt;k;l+=z)a[++x]=(z&lt;2?0:X)substr($0,l+1,z)
for(;z&gt;8||z&gt;2&amp;&amp;a[1]~/^0/&amp;&amp;a[2]~/^0/&amp;&amp;a[3]~/^0/;z--)for(n=0;n++&lt;3;)sub(/^./,X,a[n])
for(;m++&lt;3;)printf substr(a[m],1,2)}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=RY9PSsQwGMX3nmKEOiQkMWm7GU0zUvxzhoGQQoTpWNJJSydVidWLuCmIK080h_AOttOCu8f7-L33vc8v_WL6_rt1OVkdf98CJlzV1vW2AQGDPK8asDu0j4DKjJGrlDwoigcfGFFu7c49wYu4684NhwMYsAU7GwkvDI15mRheIuGhlgi9KgF8Et2w6w0c8g5uzMclCrGHJ4b79arr_DpaLrUM1QfNGB1l9C_jSXJPCBwRKxi3CCUxh6cXs0uKN1hLq-bI_XSsm8K6fDHXarlXOMQRfJ9Gz9v7nya9K6r01hXP95P1Bw" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>This went through a ton of iterations to properly handle all cases. Might try a different approach another time.</p>
<pre><code>{$0=toupper($0);         # uppercase input
for(gsub(/[^0-9A-F]/,0); # replace invalid chars
(k=length)%3||!k;)       # check input
$0=$0 0                  # append 0s if nec
for(z=k/3;               # grab length of 'word'
l&lt;k;l+=z)                # iterate through input
a[++x]                   # insert in array [1,2,3]
=(z&lt;2?0:X)               # prepend 0 if nec
substr($0,l+1,z)         # then add our word
for(;z&gt;8||               # if word too long or
z&gt;2&amp;&amp;                    # if short and 
a[1]~/^0/&amp;&amp;a[2]~/^0/&amp;&amp;a[3]~/^0/ 
                         # all words start w/ 0
;z--)                    # shrink length of words
for(n=0;n++&lt;3;)          # for each array member
sub(/^./,X,a[n])         # remove first char
for(;m++&lt;3;)             # for each member of array
printf substr(a[m],1,2)} # print first two chars
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="http://clang.llvm.org/" rel="nofollow noreferrer">C (clang)</a>, 273 bytes</h1>

<pre class="lang-c prettyprint-override"><code>int p(char*c){unsigned int l=(strlen(c)+2)/3,i,j,r,g,b,v;for(j=0;j&lt;3;j++){v=0;for(i=0;i&lt;l;i++)v=v&lt;&lt;4|(*c?*c&gt;47&amp;&amp;*c&lt;58?*c++-48:*c&gt;64&amp;&amp;*c&lt;71?*c++-55:*c&gt;96&amp;&amp;*c&lt;103?*c++-87:*c++&amp;0:0);!j?r=v:j==1?g=v:(b=v);}while(r&gt;255||g&gt;255||b&gt;255){r/=16;g/=16;b/=16;}return (r&lt;&lt;16)|(g&lt;&lt;8)|b;}
</code></pre>
<p><a href="https://tio.run/##hZJPb9owGMbP5VOkTEU2SVfnnxOwA2JldH96nbTDLsQ2wVFqOhNSaYTPzpzAYephfg9@/P70kyw9Mrtn1VoV5w9SserAhUP3NZe7j9vZ4F@kpSoMO0tVO6@Abdd6zODxoPayUII7Ha4yYLxKKMCgG8CH0JNe6Wmv8HKvIZudBmWGSElDUrouPDZm6aA0KWlFpIFN1lAatWDM5mM2i5LRaMxonJrFde@jdGogjnqY@BcYxx2c4B76KLzQNJl2OUJTBMltOddZMy2zzJ8X5gLyrIHk9LaVlQB6FsRx2xaXyLuAR/2Q@ZgU/Zn350mL@qCVAzSlPoYtKChNYZuTU9/Iy1oqAAfHwc2rKaregOEdwj9/qaFnyrq0BYda8CGE5P/OoRJ7q@UHYRTjJJ2gxafH5ed3q/2RxVLuFo@1bOzu6vnHamW3rIZV@PM7r@vGqmGeY8GiidjwIEkZRzmbBNwXsUBJwHFq7w4FIUJRjBBOrPLTl6/fvj9bNdRPrznXuf4XRAan818" rel="nofollow noreferrer" title="C (clang) – Try It Online">Try it online!</a></p>
<h3>Ungolfed</h3>

<pre class="lang-c prettyprint-override"><code>int parse(char *c) {
    unsigned int length;
    unsigned int i, j;
    unsigned int r, g, b;
    unsigned int value;

    /* Round up to multiple of 3, then divide by 3 to get the component length */
    length = (strlen(c) + 2) / 3;

    /* For each component (r,g,b) */
    for (j = 0; j &lt; 3; j++) {
        value = 0; /* Start at 0 */

        for (i = 0; i &lt; l; i++) {
            int char_value;

            if (*c != '\0') {
                /* Parse a hex digit */
                if (*c &gt; '0' &amp;&amp; *c &lt; '9') {
                    char_value = *c - '0';
                } else if (*c &gt; 'A' &amp;&amp; *c &lt;= 'F') {
                    char_value = *c - 'A' + 10;
                } else if (*c &gt;= 'a' &amp;&amp; *c &lt;= 'f') {
                    char_value = *c - 'a' + 10;
                } else {
                    /* Invalid digits are 0 */
                    char_value = 0;
                }

                /* Next character */
                *c++;
            } else {
                /* At the end of the string. Pretend string is right padded with '0' */
                char_value = 0;
            }

            /* Now append. If there are more than 8 digits, the leftmost ones will be lost to overflow */
            value = value &lt;&lt; 4 | char_value;
        }

        /* Set the correct component value */
        if (j == 0) {
            r = value;
        } else if (j == 1) {
            g = value;
        } else {
            b = value;
        }
    }

    /* Remove the last few digits until all are within the range 0-255 */
    while (r &gt; 255 || g &gt; 255 || b &gt; 255) {
        r /= 16;
        g /= 16;
        b /= 16;
    }

    /* Return the colour as an integer in the form 0x00RRGGBB */
    return (r &lt;&lt; 16) | (g &lt;&lt; 8) | b;
}
</code></pre>
<h3>Explanation</h3>
<p>This algorithm is different from the one given, so why does it work? Well when I was reading the rant I noticed the part where if the component length was greater than 8 digits, it would remove the leftmost digits until there were 8. The number 8 stuck out to me as 8 hex digits fit neatly inside a 32-bit integer. And the whole removing leading '0' thing also fits with the whole integer idea, as you can't tell a leading '0' from no leading '0' anyway in an integer. Also the steps for lengths &lt;= 3 seemed to be superfluous as they could be explained using just the general case.</p>
<p>Going through each of the steps given:</p>
<ol>
<li><p>&quot;Replace chars not matching [0-9a-fA-F] with '0'&quot;. This is handled by invalid hex digits being treated as &quot;0&quot;. Essentially, just as 'a' and 'A' both equal 10, '0' and 'G' both equal 0.</p>
</li>
<li><p>&quot;Append &quot;0&quot; until the length is divisible by 3&quot;. This is handled in two ways. First the length of the string is rounded up to a multiple of 3 (using <code>(length + 2) / 3 * 3</code>), then if the end of the string is encountered, treat it as if it were 0 <em>without incrementing the pointer</em> (Here be UB).</p>
</li>
<li><p>&quot;Split into 3 parts of equal size&quot;. This is simply dividing the rounded up length by 3 to get the component length (which simplifies into <code>(length + 2) / 3</code> since the rounded up length is not used anywhere else) and counting this many characters for each component.</p>
</li>
<li><p>&quot;Remove chars from the front of each part until they are 8 chars each&quot;. This is handled with integer overflow; the leading digits get shifted out once 8 characters are parsed.</p>
</li>
<li><p>&quot;Remove chars from the front of each part until one of them starts with something that isn't &quot;0&quot; or until all parts are empty&quot;. This is done for free with integers.</p>
</li>
<li><p>&quot;Look at the length of the parts: Are shorter than 2? If so, prepend each part with a &quot;0&quot; until each part is 2 chars long. If not, remove characters from the back of each part until they are 2 chars each&quot;. The prepending part is also done for free. The while loop handles the case where the components are longer than 2 characters.</p>
</li>
</ol>
<p>As for the case with 3 or fewer characters: those steps actually turn out to line up with the steps for 4 or more anyway:</p>
<ol>
<li><p>&quot;Replace chars not matching [0-9a-fA-F] with &quot;0&quot;&quot;. Literally identical.</p>
</li>
<li><p>&quot;Append &quot;0&quot; until the length is 3 chars&quot;. For lengths 1-3, this is equivalent to step 2 of the general case. For length of 0 the general step would result in &quot;&quot; rather than &quot;000&quot; at this stage.</p>
</li>
<li><p>&quot;Split into 3 parts, 1 char each&quot;. This is also equivalent to step 3 of the general case, although &quot;&quot; would be split into the parts &quot;&quot;, &quot;&quot;, &quot;&quot;, whereas &quot;000&quot; would become &quot;0&quot;, &quot;0&quot;, &quot;0&quot;.</p>
</li>
<li><p>&quot;Prepend each part with &quot;0&quot;&quot;. This is essentially equivalent to step 6 of the general case. As the maximum length of a component is 1, step 4 of the general case does not apply. Step 5 would turn &quot;0&quot;, &quot;0&quot;, &quot;0&quot; into &quot;&quot;, &quot;&quot;, &quot;&quot; making the two equivalent again. Then, since they are shorter than 2, they would be prepended with a 0. &quot;&quot;, &quot;&quot;, &quot;&quot; would be prepended with 2 zeros giving us &quot;00&quot;, &quot;00&quot;, &quot;00&quot;, which is what it should be.</p>
</li>
</ol>
<h3>Notes</h3>
<ul>
<li><p>This could be how it was implemented in IE. The implementation seems sensible for a hex code parser. That it accepts &quot;long&quot; colours could be future proofing for if 36-bit or 48-bit colour becomes popular (In that case I think the fact that #ABC becomes #0A0B0C rather than something like #AABBCC may have been a bug). That it &quot;pads&quot; may have been some sort of fix. That it accepts invalid characters may just be the nature of their hex parsing implementation.</p>
</li>
<li><p>For some reason (TIO) clang does not like it when I do <code>!j?r=v:j==1?g=v:b=v</code>, forcing me to add parentheses to make <code>!j?r=v:j==1?g=v:(b=v)</code>. In contrast MSVC didn't care. I am not digging through the spec to find out who is wrong, so I took the 2 byte penalty instead.</p>
</li>
</ul>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/ETHproductions/japt" rel="nofollow noreferrer">Japt</a> v2.0a0, 52 <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>u r/[^1-9A-F]/S
Êc3 ª3
úSV òVz3)®t8n)x2Ãù ®¯2 ù2 rS0
</code></pre>
<p><a href="https://petershaggynoble.github.io/Japt-Interpreter/?v=2.0a0&amp;code=dSByL1teMS05QS1GXS9TCspjMyCqMwr6U1Yg8lZ6MymudDhuKXgyw/kgrq8yIPkyIHJTMA&amp;input=WwoicmVkIgoicnVsZXMiCiIxMjM0NTY3ODkwQUJDREUxMjM0NTY3ODkwQUJDREUiCiJyQURpb0FDdGl2RSIKIkZMVUZGIgoiRiIKIiIKInpxYnR0diIKIjZkYjZlYzQ5ZWZkMjc4Y2QwYmM5MmQxZTVlMDcyZDY4IgoiMTAyMzAwNDUwMDY3IgoiR0hJSktMIgoiMDAwMDAwIgpdLW1S" rel="nofollow noreferrer">Try it</a></p>
<p>Outputs as an array of hex values.</p>
<p>Explanation:</p>
<pre><code>u r/[^1-9A-F]/S 
u               # Convert input to uppercase
  r/[^1-9A-F]/S # Replace everything other than 1-9 and A-F with spaces
                # Store as U

Êc3 ª3 
Ê      # The length of U
 c3    # Rounded up to the nearest multiple of 3
    ª3 # If the result is 0, use 3 instead
       # Store as V

úSV òVz3)®t8n)x2Ãù ®¯2 ù2 rS0
úSV                           # Right-pad U with spaces until the length is V
    ò   )                     # Split into substrings with length:
     Vz3                      #  V divided by 3
         ®      Ã             # For each substring:
          t8n)                #  Get the last 8 characters
              x2              #  Trim any leading spaces
                 ù            # Left-pad each substring to the same length
                   ®          # For each padded substring:
                    ¯2        #  Get the first 2 characters
                       ù2     #  Left-pad with spaces to length 2
                          rS0 #  Replace all spaces with &quot;0&quot;
</code></pre>
</div>
<div id="pu4" class="pu">
<h1><a href="https://go.dev" rel="nofollow noreferrer">Go</a>, 359 bytes</h1>
<pre class="lang-go prettyprint-override"><code>import.&quot;regexp&quot;
func f(s string)(k string){s=MustCompile(`[^0-9a-fA-F]`).ReplaceAllString(s,&quot;0&quot;)
for;len(s)%3&gt;0;s+=&quot;0&quot;{}
L:=len(s)/3
S:=[]string{s[:L],s[L:2*L],s[2*L:]}
if len(s)&lt;4{return &quot;0&quot;+S[0]+&quot;0&quot;+S[1]+&quot;0&quot;+S[2]}
for i:=range S{a:=S[i]
for;len(a)&gt;8;a=a[1:]{}
for;a!=&quot;&quot;&amp;&amp;a[0]!='0';a=a[1:]{}
for;len(a)&lt;2;a=&quot;0&quot;+a{}
for;len(a)&gt;2;a=a[:len(a)-1]{}
k+=a}
return}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=XVJRTuMwEBW_PoWxVEhoAmnahdbFlUKhsBCkFRFfIYAVOZHVNIniBCFFOQk_FdIeYsVJdk-zTkyRqH_mzfOz38zYb-9xtv6T03BJYwZXlKeAr_KsKA9RtCrR76qMzPG_nXhDFixmrzkCUZWGMNIEFGXB01jXlhtUC3JbiXKerXKeMO3Zf7TMCTUjx1wEz_rhHcsTGjInSbxOrwkDWUgHUVZME5ZqQu8NZ9ZU9Imk6wa4mCj6aAg8TPxA2dTCx25gCN_F9kEHZMBBA3gElf50VBesrIoUyov6nm8FfQUGG2BLubSFHJOCprJ9r6aYeD4Pvqqh-mw8pYT6AxzUnXpKdwlCe3tUXrhL9q39rW116tSWdOtCv9Ezu1NjlZmD9tCyT2gDVKmNmvffj2687WtoOqxBSAUTEBP41T1aIAMt3PtFGwvnnGfOvOQvFzIb2MPRj-OT8cRyzubnF1tpK68SJmS8vPp5feNKYG0vpObyZIStqZqNqqEGv6R_GWmoJyCZwZ54SJEBQ0P-hVDXQQM-W1ivVfwP" rel="nofollow noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu5" class="pu"><h1><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python 3</a>, <s>339</s> 337 bytes</h1>

<pre class="lang-python prettyprint-override"><code>def f(s):
 s=re.sub('[g-zG-Z ]','0',s)
 if len(s)&lt;4:s=s.ljust(3,'0');return['0'+h for h in s]
 while len(s)%3:s+='0'
 L=len(s);l=[s[i:i+L//3]for i in range(0,L,L//3)];l=[j[len(j)-8:]for j in l]
 while l[0]and all(k[0]=='0'for k in l):l=[m[1:]for m in l]
 if len(l[0])&lt;2:return[n.rjust(2,'0')for n in l]
 return[o[:2]for o in l]
import re
</code></pre>
<p><a href="https://tio.run/##XZBNc4IwEEDv@RW5dCAjagBFjdIZq8V@cO2lDAeRoFEMNAm2@uctQZzONKfN7nu72ZRntSu4e72mNIOZKREBUPqC9mSVmEa07V5W3U8YG5aBDUsiAFkGc8prcDYg0pe9fF9JZbq6jqaCqkrwqI47O5gVAu4g41DGAH7vWE5b88ElsuPXEIChf0tNcz@SESOsE/b7bqxVplWx5ltqYiu0dB7FmttH2tmj7pg04F6D@d@MCMdrnsJ1npuHOvb1JM0dGg6RusUxsm/u8e62a2kZzRzSLsJ7olnPadbTAr8LLVFExGk6FW2BHctCqLp8vT3Hrj9UiTNhPuNlpUw0LQXjymSW0X00rMxkqP5V@rOhpSKJoOvDVdAUiCqnEtiOOxh6o/EEz58Wy@d/VyDmS1bMF4qdnkEQfgQBCAC4fCVKnYCXJh7dDCY0S53ReJPiZDNxUpsOKR45qTcGNnZcjAdDjL0RWL28vr2HADfnFw" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
<h4>Commented</h4>
<pre class="lang-python prettyprint-override"><code>def f(s):                      # Create a function, f, which takes in a string, s
 s=re.sub('[g-zG-Z ]','0',s)   # Apply the regex so all non-hex characters are replaced with '0'
 if len(s)&lt;4:                  # If the length is less than 4:
  s=s.ljust(3,'0')             #  Append '0' until the length is 3
  return['0'+h for h in s]     #  Return the elements, prepended by a '0'
 while len(s)%3:               # Until the length is divisible by 3:
  s+='0'                       #  Append '0'
 L=len(s)                      # Assign L to the length of s
 l=[s[i:i+L//3]for i in        # Split s into
    range(0,L,L//3)]           # three equal chunks
 l=[j[len(j)-8:]for j in l]    # Remove characters from the front if the length is more than 8
 while l[0]and all(            # While the strings are not empty
       k[0]=='0'for k in l):   # And all the strings start with '0':
  l=[m[1:]for m in l]          #  Remove the first character from each string
 if len(l[0])&lt;2:               # If the length of the first string is less than 2:
  return[n.rjust(2,'0')        # Return each string,
         for n in l]           # with a '0' prepended until the length is 2
 return[o[:2]for o in l]       # Return the first two characters of each string
import re                      # Import the re module for regex handling
</code></pre>
</div>
<div id="pu6" class="pu"><h1><a href="https://www.microsoft.com/net/core/platform" rel="nofollow noreferrer">C#</a>, <s>235</s> <s>229</s> 227 bytes</h1>
<p>-6 bytes thanks to <a href="https://codegolf.stackexchange.com/users/52210/kevin-cruijssen">Kevin Cruijssen</a></p>

<pre class="lang-cs prettyprint-override"><code>s=&gt;{int l;for(s=Regex.Replace(s,&quot;[^0-9a-fA-F]|^$&quot;,&quot;0&quot;);(l=s.Length)%3&gt;0;s+=&quot;0&quot;);for(s=l&lt;4?&quot;0&quot;+s[0]+0+s[1]+0+s[2]:s;(l=s.Length/3)&gt;8|s[0]+s[l]+s[2*l]&lt;145&amp;l&gt;2;s=string.Concat(s.Where((_,i)=&gt;i%l&gt;0)));return s.Where((_,i)=&gt;i%l&lt;2);}
</code></pre>
<p><a href="https://tio.run/##jVNtj9owDP7Or4iq3dQO6EIpbyvt1AG93Y1J027TfWDcVFLDRQopJCli4/jtLG3hxNg0zVIS27EfO7ZDZJ2kAg6ZpHyB7n5IBUuvci7ZY8rXF6pByhgQRVMu7WvgICi5sPgCW2V/hkXGYjHargRImVt7lQphsZTok0gXIl6iXQVpkipWlKBNShP0MabctI4XOUUZJ32phEavoZsRz5Yg4hmDPnmMRRCgOfIP0g92lCvEvHkqTOnryLDV8VcsJmDKmjF5wPVeXJ@H9Wj69PDCqBnYsDyT@dIeA1@oR@uqGWBPVv3iokRhffetFqtygqdVrI9GeTjTN/Lc93XTCrpPhZWcsHxzXrFpv@G2XrLA8aRfZq/LxkmsTGnfP4IA0/xeo5Yf0CsWYMuyPAEqExz9ed13LG9/ONXDe65MCTuZIspXmUI@2iEjMmp6G3@NCkaEQ5qGA0U3o1xsOE231e50ezh8NxiOLsTCIWMgc@b6/c3th3GhgiQ/8vVzPVNqk3PtZNYG4vZgnjidLknwjPScpAEtwB0naXeLaNhpYuy2MG53chkXZKD9X14A25UeKEjKR@CosMxfgnEUFVw4DAe4yLHpDobd3hERSrsj9kmXXOpmR04nnQAuszvzOOX1nJhulUwZ2PeCKtA/QA9R2cPbVI@n8Y1rx6Lq9h3kX8GUyA/Q732em9LKyfsH6v9haIN1BpzAaJ3FzDwV6wS9r@wPvwA" rel="nofollow noreferrer" title="C# – Try It Online">Try it online!</a></p>
<hr />
<p>Ungolfed:</p>
<pre class="lang-cs prettyprint-override"><code>input =&gt; {
    //the three while loops are golfed into for loops in the submission, with the last two then being combined into one

    // replace non hex chars with 0
    input = Regex.Replace(input, &quot;[^0-9a-fA-F]|^$&quot;, &quot;0&quot;);

    // pad input to next multiple of 3
    while (input.Length % 3 &gt; 0) {
        input += &quot;0&quot;; 
    }
    // add 0 at the start of each section if the input is now 3 chars long
    // the final two zeroes here get coerced to strings
    if (input.Length == 3) input = &quot;0&quot; + input[0] + 0 + input[1] + 0 + input[2];

    // used to keep track of the current section length (changes as 0s are removed)
    int partLength = input.Length / 3;

    // if part length is &gt;8 continuously remove the first char from each part (notice the first char of each part is always 0 mod partLength)
    while (partLength &gt; 8) {
        // because LINQ, the .Where has to be cast to something to actually evaluate within a while, string.Concat is the shortest way (including other changes to have other variables be the correct type)
        input = string.Concat(input.Where((_, i) =&gt; i % partLength &gt; 0));
    }

    //if every part starts with 0, remove the first char from each
    //this is golfed into a sum using char codes in the submission ((int)'0' = 48)
    while (input[0] == '0' &amp;&amp; input[partLength] == '0' &amp;&amp; input[2 * partLength] == '0' &amp;&amp; partLength &gt; 2) {
        input = string.Concat(input.Where((_, i) =&gt; i % partLength &gt; 0));
    }
    //return the first two chars from each part
    return input.Where((_, i) =&gt; i % partLength &lt; 2);
}
</code></pre>
</div>
<div id="pu7" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a>, 29 bytes</h1>
<pre><code>S⇩3ẇ3↲∑k6Ǐ~vḟİ∑3/⟑8NȯHH2∆Z2Ẏ₴
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/#WyIiLCIiLCJT4oepM+G6hzPihrLiiJFrNsePfnbhuJ/EsOKIkTMv4p+ROE7Ir0hIMuKIhloy4bqO4oK0IiwiIiwiIl0=" rel="nofollow noreferrer">Try it Online!</a></p>
<pre><code>S⇩                            # Stringify (&quot;&quot; -&gt; 0 edgecase) and lowercase
  3ẇ                          # Cut into chunks of length 3
     3↲                       # Pad each to length 3 with spaces (will be zeroed)
      ∑                       # Concatenate
       k6                     # Lowercase hex
          Ǐ                   # Append the leading zero
          ~vḟ                 # Without popping, for each char in input, find it in the hex
             İ                # Index into the hex + 0 - ones not found, -1s, get indexed into the end
              ∑               # Concat into a string
               3/             # Divide into 3 parts
                 ⟑            # Over each...
                  8Nȯ         # Get last 8 chars
                     HH       # Convert to/from hex to remove leading zeroes
                       2∆Z    # zfill each to length 2
                          2Ẏ  # Get the first two chars of each
                            ₴ # Print 
</code></pre>
</div>
<div id="pu8" class="pu"><h1>JavaScript + HTML, 50 bytes</h1>
<pre class="lang-javascript prettyprint-override"><code>document.body.setAttribute('bgcolor','#'+prompt())
</code></pre>
<p>Works in any browser, as the legacy behavior was kept with <code>bgcolor</code> (even though it won't work with CSS). Displays as graphical output.</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;script&gt;document.body.setAttribute("bgcolor",'#'+prompt());&lt;/script&gt;</code></pre>
</div>
</div>
</p>
<p>If graphical output is not allowed, then:</p>
<h1>JavaScript + HTML, 97 bytes</h1>
<pre><code>c=document.body;c.setAttribute('bgcolor','#'+prompt());alert(getComputedStyle(c).backgroundColor)
</code></pre>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;script&gt;c=document.body;c.setAttribute('bgcolor','#'+prompt());alert(getComputedStyle(c).backgroundColor)&lt;/script&gt;</code></pre>
</div>
</div>
</p>
<p>Uses the computed styles generated. Will output like <code>rgb(X, Y, Z)</code>.</p>
<p>To output a hex code, this would be 156 bytes:</p>
<pre><code>c=document.body;c.setAttribute('bgcolor','#'+prompt());alert(getComputedStyle(c).backgroundColor.match(/\d+/g).map(x=&gt;(x|256).toString(16).slice(1)).join``)
</code></pre>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;script&gt;c=document.body;c.setAttribute('bgcolor','#'+prompt());alert(getComputedStyle(c).backgroundColor.match(/\d+/g).map(x=&gt;(x|256).toString(16).slice(1)).join``)&lt;/script&gt;</code></pre>
</div>
</div>
</p>
</div>
<div id="pu9" class="pu"><h2>JavaScript, <s>238</s> 234 bytes</h2>
<p>Way longer than the others, but actually competing!</p>
<pre class="lang-js prettyprint-override"><code>c=&gt;(M=Math,s='slice',t=M.ceil(c.length/3),c=c.padEnd(M.max(t*3,3)).replace(/[g-zG-Z ]/g,'0'),c=[c[s](0,t),c[s](t,t*2),c[s](t*2)]).map(p=&gt;p[s](i=M.min(...c.map(p=&gt;(r=p.search(/[^0].{0,7}$/),r&lt;0?3e333:r))),i+2).padStart(2,'0')).join('')
</code></pre>
<p>Less golfed:</p>
<pre class="lang-js prettyprint-override"><code>c =&gt; (
  M = Math, s = 'slice', // these are shorter
  t = M.ceil(c.length / 3), // prepare length for the parts
  c = c
    .padEnd(M.max(t*3, 3)) // pad with spaces until length divisible by 3, with a minimum of 3
    .replace(/[g-zG-Z ]/g, '0'), // replace all non-hex characters with '0'
  c = [c[s](0, t), c[s](t, t*2), c[s](t*2)] // split into 3 equal parts
).map(p =&gt; (
  i = M.min(...c.map(p=&gt;(r=p.search(/[^0].{0,7}$/),r&lt;0?3e333:r))), // search for a character that's not '0' in the last 8 characters, returning its index, or infinity when negative (no match found), and take the lowest of the parts
  p[s](i, i+2).padStart(2, '0') // slice max two characters from the lowest non-'0', and pad to two characters
)).join('')
</code></pre>
</div>
<div id="pu10" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a>, <s>51</s> <s>50</s> <s>47</s> 44 bytes</h1>
<pre><code>⇧ƛk^$c∧;ṅ3/\0ÞḞṅ3/8Nvȯ∩\03*:£øl:L2∵Ẏ¥p¥p2Nȯ∩
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/#WyJBIiwiIiwi4oenxptrXiRj4oinO+G5hTMvXFwww57huJ7huYUzLzhOdsiv4oipXFwwMyo6wqPDuGw6TDLiiLXhuo7CpXDCpXAyTsiv4oipIiwiIiwicmVkXG5ydWxlc1xuMTIzNDU2Nzg5MEFCQ0RFMTIzNDU2Nzg5MEFCQ0RFXG5yQURpb0FDdGl2RVxuRkxVRkZcbkZcblxuenFidHR2XG42ZGI2ZWM0OWVmZDI3OGNkMGJjOTJkMWU1ZTA3MmQ2OFxuXCIxMDIzMDA0NTAwNjdcIiJd" rel="nofollow noreferrer">Try it Online!</a></p>
<p>A huge mess, but at least I outgolfed lyxal.</p>
</div>
<div id="pu11" class="pu"><h1>Rust, <s>372</s> <s>367</s> 340 bytes</h1>
<pre class="lang-rust prettyprint-override"><code>|mut s:Vec&lt;u8&gt;|{for c in &amp;mut s{if!c.is_ascii_hexdigit(){*c=48}}s.extend(b&quot;000&quot;);let d:Vec&lt;_&gt;=s.chunks((s.len()-1).max(3)/3).take(3).map(|c|&amp;c[c.len().saturating_sub(8)..]).collect();d.iter().flat_map(|c|match&amp;c[d.iter().map(|c|c.iter().take_while(|c|**c==48).count()).min().unwrap()..]{[]=&gt;*b&quot;00&quot;,&amp;[c]=&gt;[48,c],&amp;[x,y,..]=&gt;[x,y]}).collect()}
</code></pre>
<p>Ungolfed:</p>
<pre class="lang-rust prettyprint-override"><code>fn f(mut s: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
    for c in &amp;mut s {
        if !c.is_ascii_hexdigit() {
            *c = b'0'
        }
    }
    s.extend(b&quot;000&quot;);

    let chunks: Vec&lt;_&gt; = s
        .chunks((s.len() - 1).max(3) / 3)
        .take(3)
        .map(|c| &amp;c[c.len().saturating_sub(8)..])
        .collect();

    let to_remove = chunks
        .iter()
        .map(|c| c.iter().take_while(|c| **c == b'0').count())
        .min()
        .unwrap();

    chunks
        .iter()
        .flat_map(|c| match &amp;c[to_remove..] {
            [] =&gt; *b&quot;00&quot;,
            &amp;[c] =&gt; [b'0', c],
            &amp;[c1, c2, ..] =&gt; [c1, c2],
        })
        .collect()
}
</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=990189c8ef3583746ba6bb6363264c8d" rel="nofollow noreferrer">Playground</a></p>
<p>The chunking is a little tricky, but otherwise a relatively boring solution.</p>
</div>
<div id="pu12" class="pu"><h1>JavaScript (Browser), 138 bytes, non-competitive</h1>
<pre class="lang-javascript prettyprint-override"><code>c=&gt;(document.body.innerHTML=`&lt;font id=g color=${c}&gt;`,getComputedStyle(g)).color.match(/\d+/g).map(n=&gt;(n|256).toString(16).slice(1)).join``
</code></pre>
<p>The same color parsing algorithm also works on browsers other than IE (I had tested on my Firefox 103 and it works). But the code will output <code>#ff0000</code> for input <code>red</code> so marked non-competitive.</p>
<p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>f=

c=&gt;(document.body.innerHTML=`&lt;font id=g color=${c}&gt;`,getComputedStyle(g)).color.match(/\d+/g).map(n=&gt;(n|256).toString(16).slice(1)).join``

console.log(f('red                             '));
console.log(f('rules                           '));
console.log(f('1234567890ABCDE1234567890ABCDE  '));
console.log(f('rADioACtivE                     '));
console.log(f('FLUFF                           '));
console.log(f('F                               '));
console.log(f('                                '));
console.log(f('zqbttv                          '));
console.log(f('6db6ec49efd278cd0bc92d1e5e072d68'));
console.log(f('102300450067                    '));</code></pre>
</div>
</div>
</p>
<p>Save ~30 bytes by <a href="https://codegolf.stackexchange.com/users/64489/kaiido">Kaiido</a></p>
</div>
<div id="pu13" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, <s> 44 </s> 39 <a href="https://github.com/DennisMitchell/jelly/wiki/Code-page" rel="nofollow noreferrer">bytes</a></h1>
<p>-5 thanks to UnrelatedString (clever use of <code>;Ṫ</code> for the empty string special case).</p>
<pre><code>ØhḊiⱮŒla;Ṫ$œs3z0ZŻ€ṫ€-7ZḊẸ€Ḣ¬Ɗ¡ƬḊƇṪḣ2ZF
</code></pre>
<p>A full program that accepts a string and prints the resulting colour code (keeping character casing from the input*).</p>
<p><strong><a href="https://tio.run/##y0rNyan8///wjIyHO7oyH21cd3RSTqL1w52rVI5OLjauMog6uvtR05qHO1cDSV3zKKCih7t2gER2LDq05ljXoYXHgMyuY@1AHQ93LDaKcvv//796kaNLZr6jc0lmmas6AA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></strong> Or see the <a href="https://tio.run/##y0rNyan8///wjIyHO7oyH21cd3RSTqL1w52rVI5OLjauMog6uvtR05qHO1cDSV3zKKCih7t2gER2LDq05ljXoYXHgMyuY@1AHQ93LDaKcvv/cHfP0T2H24FqsoD4UcMcBV07hUcNcyP//49WL0pNUddRUC8qzUktBjEMjYxNTM3MLSwNHJ2cXVzRuGClji6Z@Y7OJZllYK6bT6ibG5gBIkC4qjCppKQMxDJLSTJLTTaxTE1LMTK3SE4xSEq2NEoxTDVNNTA3SjGzAFtoYGRsYGBiamBgZq4eCwA" rel="nofollow noreferrer" title="Jelly – Try It Online">test-suite</a>.</p>
<h3>How?</h3>
<pre><code>ØhḊiⱮŒla;Ṫ$œs3z0ZŻ€ṫ€-7ZḊẸ€Ḣ¬Ɗ¡ƬḊƇṪḣ2ZF - ...f(X)
Øh                                     - hex characters = &quot;0123456789abcdef&quot;
  Ḋ                                    - dequeue -&gt; &quot;123456789abcdef&quot;
     Œl                                - lower-case X
    Ɱ                                  - map with:
   i                                   -   first 1-indexed index or 0 if not found
          $                            - last two links as a monad - f(X):
         Ṫ                             -   tail (yields zero when X is empty)
        ;                              -   X (without its tail) concatenated with that (its tail or a zero)
       a                               - logical AND the hex-char-indicator list with X or [0] (vectorises)
           œs3                         - split into three equal chunks
                 Ż€                    - prefix each with a zero
                   ṫ€-7                - tail each from index -7 -&gt; last (up to) eight values
                       Z               - transpose
                              Ƭ        - collect up while distinct, applying:
                             ¡         -   repeat...
                            Ɗ          -   ...number of times: last three links as a monad:
                        Ẹ€             -     any? for each
                          Ḣ            -     head
                           ¬           -     logical NOT
                       Ḋ               -   ...action: dequeue
                                Ƈ      - keep those which are truthy under:
                               Ḋ       -   dequeue
                                 Ṫ     - tail
                                  ḣ2   - head to index two
                                    Z  - transpose
                                     F - flatten
                                       - implicit, smashing print
</code></pre>
</div>
<div id="pu14" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, <s>48</s> 47 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>lA6.$S0:₄¦«3ô¨S3ä8δ.£'e¶:øJ0Û¶'e:2£₄¦D‚ì2.£€Sø˜
</code></pre>
<p>Output as a lowercase list of characters without <code>#</code>.</p>
<p><a href="https://tio.run/##yy9OTMpM/f8/x9FMTyXYwOpRU8uhZYdWGx/ecmhFsPHhJRbntugdWqyeemib1eEdXgaHZx/app5qZXRoMVihy6OGWYfXGOmBuGuCD@84Pef//6LSnNRiAA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/V9Waa@k8KhtkoKSfeX/HEczPZVgA6tHTS2Hlh1abXx4y6EVwcaHl1ic26J3aLF66qFtVod3eBkcnn1om3qqldGhxWCFLo8aZh1eY6QH4q4JPrzj9Jz/Ov@jlYpSU5R0lIpKc1KLgbShkbGJqZm5haWBo5OziysaF6TQ0SUz39G5JLMMxHPzCXVzA9FADERVhUklJWVAhllKkllqsollalqKkblFcopBUrKlUYphqmmqgblRipkFyCYDI2MDAxNTAwMzc6VYAA" rel="nofollow noreferrer">verify all test cases</a>.</p>
<p><strong>Explanation:</strong></p>

<p>Step 1: Convert the input to lowercase, and replace all invalid letters with a <code>0</code>:</p>
<pre class="lang-python prettyprint-override"><code>l              # Lowercase the (implicit) input-string
 A             # Push the lowercase alphabet
  6.$          # Remove its first 6 characters: &quot;ghijklmnopqrstuvwxyz&quot;
     S         # Convert it to a list of characters
      0:       # And replace all those characters with a &quot;0&quot; in the uppercase input
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f8/x9FMTyXYwOr//6LSnNRiAA" rel="nofollow noreferrer">Try just step 1 online.</a></p>
<p>Step 2: Pad with trailing 0s, and split it into three equal-sized parts (with each part as a list of characters):</p>
<pre class="lang-python prettyprint-override"><code>₄              # Push 1000
 ¦             # Remove it's first character: &quot;000&quot;
  «            # Append it
   3ô          # Split it into parts of size 3
     ¨         # Remove the last (potentially shorter) part
      S        # Convert it to a flattened list of characters
       3ä      # Split it into 3 equal-sized parts
</code></pre>
<p><a href="https://tio.run/##AScA2P9vc2FiaWX//2xBNi4kUzA64oKEwqbCqzPDtMKoUzPDpP//cnVsZXM" rel="nofollow noreferrer">Try just the first two steps online.</a></p>
<p>Step 3: Only keep the last 8 characters of each inner list:</p>
<pre class="lang-python prettyprint-override"><code> δ             # Map over each inner list
8 .£           # Only keep (up to) the last 8 characters
</code></pre>
<p><a href="https://tio.run/##AS0A0v9vc2FiaWX//2xBNi4kUzA64oKEwqbCqzPDtMKoUzPDpDjOtC7Co///cnVsZXM" rel="nofollow noreferrer">Try just the first three steps online.</a></p>
<p>Step 4: Remove leading 0s from each list, until a column doesn't start with a <code>0</code> anymore:</p>
<pre class="lang-python prettyprint-override"><code>'e¶:          '# Replace all &quot;e&quot; with a newline
               # (workaround, because &quot;0e0&quot; would be interpret as 0 in 05AB1E)
    ø          # Zip/transpose; swapping rows/columns
     J         # Join each inner list together
      0Û       # Trim all leading 0s
        ¶'e:  '# Undo the workaround, by replacing all newlines back to &quot;e&quot;s
</code></pre>
<p><a href="https://tio.run/##AT0Awv9vc2FiaWX//2xBNi4kUzA64oKEwqbCqzPDtMKoUzPDpDjOtC7CoydlwrY6w7hKMMObwrYnZTr//3J1bGVz" rel="nofollow noreferrer">Try just the first four steps online.</a></p>
<p>Step 5: Only keep the first two characters of each row, potentially prepending the result with <code>0</code>s, and output the final result:</p>
<pre class="lang-python prettyprint-override"><code>2£             # Only keep the first two triplets of the list
  ₄¦           # Push &quot;000&quot; again
    D‚         # Pair it with itself: [&quot;000&quot;,&quot;000&quot;]
      ì        # Prepend this in front of the list
       2.£     # Now only keep the last two triplets
          €S   # Convert each inner string back to a list of characters
            ø  # Zip/transpose back; swapping rows/columns
             ˜ # Flatten the pair of triplets of characters
               # (after which the sixtet of characters is output implicitly as result)
</code></pre>
</div>
<div id="pu15" class="pu"><h1><a href="https://github.com/m-ender/retina/wiki/The-Language/a950ad7d925ec9316e3e2fb2cf5d49fd15d23e3d" rel="nofollow noreferrer">Retina 0.8.2</a>, 117 bytes</h1>
<pre><code>T`op`a-fA-FRd
$
00
^((.)*?)((?&lt;_-2&gt;.)*)((?&lt;-_&gt;.)*)0?0?$
00$1¶00$3¶00$4¶
.+(.{8})
$1
+`^0(..+¶)0(.+¶)0
$1$2
(..).*¶
$1
</code></pre>
<p><a href="https://tio.run/##XYpLDoIwGIT3/zlq0kpo2oI8EiNBsG5cGd0iQmtCYnwgstB4LQ7AxbCydDPzzZepdVNdjsMEr/Nhl19v@dE@xbbcKkDAGGQYUzKNCMbR/GCLhRkj24cRWcSi3w/xvjPpjOn2HVAL03fwIYA4WHnGMKVW3xHTYxmNBBhJ6NS8ER@GWiuon2f9AC4cd@b5QcjiZZKu/ibUcVpd46Sp2hXIzV5KkACve9E0LXiq8HTphvqkhB@UihVlKBTXM818obzgCw" rel="nofollow noreferrer" title="Retina 0.8.2 – Try It Online">Try it online!</a> Link includes test cases. Explanation:</p>
<pre><code>T`op`a-fA-FRd
</code></pre>
<p>Replace non-hex digits with zeros.</p>
<pre><code>$
00
</code></pre>
<p>Append two zeros in case the length is not a multiple of 3.</p>
<pre><code>^((.)*?)((?&lt;_-2&gt;.)*)((?&lt;-_&gt;.)*)0?0?$
00$1¶00$3¶00$4¶
</code></pre>
<p>Divide the string into three equal parts, discarding the trailing zeros just added if necessary. Prefix <code>00</code> to each part in case it is short.</p>
<pre><code>.+(.{8})
$1
</code></pre>
<p>Trim each part to the last 8 digits.</p>
<pre><code>+`^0(..+¶)0(.+¶)0
$1$2
</code></pre>
<p>Trim leading zeros while all parts have one, but don't trim to fewer than two digits.</p>
<pre><code>(..).*¶
$1
</code></pre>
<p>Keep only the first two digits of each part and join everything together.</p>
</div>
<div id="pu16" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a>, <s>67</s> 64 bytes</h1>
<pre><code>k6:⇧∪ṅ\^pøB?0øṙ₅:ǒ3εǒ+↲›3/?L4&lt;[2↳›|8Nvȯ{:vh0J≈|ƛh0=ßḢ}ƛ₃[0p|2Ẏ}ṅ
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/#WyJBIiwiIiwiazY64oen4oiq4bmFXFxecMO4Qj8ww7jhuZnigoU6x5IzzrXHkivihrLigLozLz9MNDxbMuKGs+KAunw4TnbIr3s6dmgwSuKJiHzGm2gwPcOf4biifcab4oKDWzBwfDLhuo594bmFIiwiIiwicmVkXG5ydWxlc1xuMTIzNDU2Nzg5MEFCQ0RFMTIzNDU2Nzg5MEFCQ0RFXG5yQURpb0FDdGl2RVxuRkxVRkZcbkZcblxuenFidHR2XG42ZGI2ZWM0OWVmZDI3OGNkMGJjOTJkMWU1ZTA3MmQ2OCJd" rel="nofollow noreferrer">Try it Online!</a></p>
<p>A big mess of unicode and lesser-used overloads of things</p>
<h2>Explained</h2>
<p>There are 10 parts here:</p>
<pre><code>Generating the hex-digit regex: k6:⇧∪ṅ\^pøB
Replacing non-hex with 0: ?0øṙ
Padding to nearest multiple of 3: ₅:ǒ3εǒ+↲›
Splitting into 3 equal parts: 3/
The length 4 conditional branch: ?L4&lt;[
  Making each bit 2 digits with 0s if needed: 2↳›
|
  Getting the last 8 characters: 8Nvȯ
  Removing 0s until something doesn't start with a 0: {:vh0J≈|ƛh0=ßḢ}
  Either prepending a 0 or getting the last 2 chars: ƛ₃[0p|2Ẏ}
Outputting the result: ṅ
</code></pre>
<h3>Generating the hex-digit regex</h3>
<pre><code>k6:⇧∪ṅ\^pøB
k6           # The string &quot;0123456789abcdef&quot;
  :⇧         # Uppercased (&quot;0123456789ABCDEF&quot;)
    ∪ṅ       # Unioned with the lowercase string (&quot;0123456789abcdefABCDEF&quot;)
       \^p   # With a caret prepended (&quot;^0123456789abcdefABCDEF&quot;)
          øB # Surrounded in &quot;[]&quot; (&quot;[^0123456789abcdefABCDEF]&quot;)
</code></pre>
<p>This regex (<code>[^0123456789abcdefABCDEF]</code>, called <code>re</code> from here) will be used in the next step to determine which characters to replace with 0s.</p>
<h3>Replacing non-hex with 0</h3>
<pre><code>?0øṙ # Before this part, the stack is [re]
?    # Push the input : [re, input]
 0   # Push a 0 to the stack : [re, input, 0]
  øṙ # Replace matches of re in input with 0
</code></pre>
<p>This completes the step of replacing invalid characters with 0s, which is common to strings less than 4 chars and strings with at least 4 chars. This string will be called <code>0-str</code> from here.</p>
<h3>Padding to nearest multiple of 3</h3>
<pre><code>₅:ǒ3εǒ+↲› # Before this part, the stack is [0-str]
₅:        # Push two copies of the length of 0-str without popping it
  ǒ3ε     # Modulo the first copy by 3 and take the absolute difference of that and 3 to get how far away the length is from the next multiple of 3. Note that this may result in the result being 3 because a string of length that is divisible by 3 will return 3, as 3 - (length % 3 =&gt; 0) = 3
     ǒ    # Modulo 3 again to make a 3 a 0
      +↲› # Add that to the remaining copy of the length to get how many characters should be in the padded string, left pad 0-str with spaces to that many characters and replace all spaces with 0s.
</code></pre>
<p>The result of this step is common to both string length possibilities and will be referred to as <code>pad-0-str</code>.</p>
<h3>Splitting into 3 equal parts</h3>
<pre><code>3/ # Before this part, the stack is [pad-0-str]
3/ # Divide the string into 3 equal parts
</code></pre>
<p>Yes, there really <em>is</em> a built-in for this. The result will be referred to as <code>3-part-pad</code>.</p>
<h3>The length 4 conditional branch</h3>
<pre><code>?L4&lt;[...|...} # Before this part, the stack is [3-pad-str]
?L            # Is the length of the input
  4&lt;          # Less than 4?
    [...      # If so, move onto the steps for a string with less than 4 characters
        |...} # Otherwise, move onto the steps for a string with at least 4 characters. A `}` is used instead of a `]` because it saves a byte over `;]` later on.
</code></pre>
<p>The stack hasn't changed after this step.</p>
<h4>Less than 4 - Making each bit 2 digits with 0s if needed</h4>
<pre><code>2↳› # Before this part, the stack is [3-pad-str]
2↳  # Right pad each part of 3-pad-str to be two characters, using spaces. This is needed because components of 3-pad-str will be empty if the input is the empty string. In the case of the empty string, this returns &quot;  &quot;. Otherwise, it returns &quot; &quot; + char
  › # Replace the spaces with 0s. This turns &quot;  &quot; into &quot;00&quot; and everything else into &quot;0&quot; + char.
</code></pre>
<p>The result of this will be called <code>res</code>.</p>
<h4>At least 4 - Getting the last 8 characters</h4>
<pre><code>8Nvȯ # Before this part, the stack is [3-pad-str]
8N   # Push -8 to the stack : [3-pad-str, -8]
  vȯ # Push [part[-8:] for part in 3-pad-str]
</code></pre>
<p>The result of this will be referred to as <code>last-8</code></p>
<h4>At least 4 - Removing 0s until something doesn't start with a 0</h4>
<pre><code>{:vh0J≈|ƛh0=ßḢ}   # Before this part, the stack is [last-8]
{                  # While ...
 :vh               # the first character of each part of last-8 (leaving last-8 on the stack)...
    0J≈            # are all equal to 0:
       |ƛh0=       # For each item, check if the first character is 0
            ßḢ}    # And if so, remove the head of that part. The `}` here closes both the map lambda and the while loop.

</code></pre>
<p>This is probably the messiest section. The result of this will be referred to as <code>second-last</code>.</p>
<h4>At least 4 - Either prepending a 0 or getting the last 2 chars</h4>
<pre><code>ƛ₃[0p|2Ẏ} # Before this part, the stack is [second-last]
ƛ         # For each item in second-last, which has leading 0s removed:
 ₃[       # If the length is 1:
   0p     #   Prepend a 0
     |2Ẏ} # Else: take the last two characters.
          # The `}` here closes both this inner if-statement, the map lambda, and the outer if-statement
</code></pre>
<p>The result of this part will be referred to as <code>res</code>. This is analogous to the step taken in the less than 4 branch.</p>
<h3>Outputting the result</h3>
<pre><code>ṅ # Join res on empty string - concatenate into a single string.
</code></pre>
<p>I could have used the <code>s</code> flag here, but at this point, we're already play the long golf game, so I thought I might as well go flagless.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/250535/">250535</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




