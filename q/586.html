<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::586</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>131</td><td>Uiua</td><td>250112T003957Z</td><td><a href="https://codegolf.stackexchange.com/questions/586/robot-finds-kitten/277600#277600">janMakos</a></td></tr>
<tr d-ix="1"><td>472</td><td>Python3</td><td>250111T010808Z</td><td><a href="https://codegolf.stackexchange.com/questions/586/robot-finds-kitten/277580#277580">Ajax1234</a></td></tr>
<tr d-ix="2"><td>535</td><td>Python 2.6</td><td>110215T155619Z</td><td><a href="https://codegolf.stackexchange.com/questions/586/robot-finds-kitten/950#950">roobs</a></td></tr>
<tr d-ix="3"><td>504</td><td>Python 2.6</td><td>110206T122700Z</td><td><a href="https://codegolf.stackexchange.com/questions/586/robot-finds-kitten/595#595">mthurlin</a></td></tr>
<tr d-ix="4"><td>451</td><td>Scala 2.8</td><td>110206T170309Z</td><td><a href="https://codegolf.stackexchange.com/questions/586/robot-finds-kitten/612#612">Daniel C</a></td></tr>
<tr d-ix="5"><td>539</td><td>Ruby</td><td>110208T140022Z</td><td><a href="https://codegolf.stackexchange.com/questions/586/robot-finds-kitten/706#706">Mongus P</a></td></tr>
<tr d-ix="6"><td>nan</td><td>C++  799chars</td><td>110206T184659Z</td><td><a href="https://codegolf.stackexchange.com/questions/586/robot-finds-kitten/619#619">Loki Ast</a></td></tr>
<tr d-ix="7"><td>648</td><td>Ruby</td><td>110207T091257Z</td><td><a href="https://codegolf.stackexchange.com/questions/586/robot-finds-kitten/649#649">Nemo157</a></td></tr>
<tr d-ix="8"><td>681</td><td>c++  681 necessary characters</td><td>110207T043510Z</td><td><a href="https://codegolf.stackexchange.com/questions/586/robot-finds-kitten/642#642">dmckee -</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Uiua, 131 bytes</h1>
<pre class="lang-none prettyprint-override"><code>‚äÉ(‚ä¢‚äö=@R|¬¨‚àä&quot; K&quot;|‚ä¢‚äö=@K)‚äú‚àò‚ä∏‚â†@\n
‚óá‚ßà-‚äô‚óå‚ä¢path(‚â°/+‚åµ‚üú+‚åü‚äÇ‚äÇ‚äÇ‚à©¬Ø‚äô:‚äô‚äô‚à©‚â°‚áå‚à©‚ÇÑ(‚â°‚äÇ0‚çú¬Ø‚á°‚ä¢‚äö)‚à©‚äÉ(‚áå‚Üô|‚Üò+‚ÇÅ)‚äô::‚üú‚ÇÇ(‚äì‚åü‚äè‚â°‚äè)‚§ö¬∞‚äü)ùÑê‚âç
‚â°&amp;p‚çö$&quot;_ _&quot;‚äÉ(‚äè‚äô&quot;ESWN&quot;‚äó¬±‚äôA‚ÇÇ|/+‚çâ‚åµ)
</code></pre>
<p><em>Newlines are unnecessary, and are present for readability</em></p>
<p><a href="https://uiua.org/pad?src=0_15_0-dev_1__IyBFeHBlcmltZW50YWwhCkYg4oaQICgKICDiioMo4oqi4oqaPUBSfMKs4oiKIiBLInziiqLiipo9QEsp4oqc4oiY4oq44omgQFxuCiAg4peH4qeILeKKmeKXjOKKonBhdGgo4omhLyvijLXin5wr4oyf4oqC4oqC4oqC4oipwq_iipk64oqZ4oqZ4oip4omh4oeM4oip4oKEKOKJoeKKgjDijZzCr-KHoeKKouKKminiiKniioMo4oeM4oaZfOKGmCvigoEp4oqZOjrin5zigoIo4oqT4oyf4oqP4omh4oqPKeKkmsKw4oqfKfCdhJDiiY0KICDiiaEmcOKNmiQiXyBfIuKKgyjiio_iipkiRVNXTiLiipfCseKKmUHigoJ8LyvijYnijLUpCikKRiAkICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKICAkICMgIGQgICAgICAzICAgIEtqICAgICMKICAkICMgICAgICAgICAgICAgICAgICAgICMKICAkICMgUiAgICAgICAgICAgICAgICAgICMKICAkICMgICAgICBxICAgICAgICAgICAgICMKICAkICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKJnAiLS0tIgpGICQgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwogICQgIyAgZCAgciAgIDMgICAgS2ogICAgIwogICQgIyAgICBwICAgICAgICBwICAgICAgIwogICQgIyAgICAgICAgIFQgICAgICAgIFggIwogICQgIyAgICAgIHEgICBzICAgdCAgICAgIwogICQgIyAgICAgICAgICAgICAgICAgICAgIwogICQgIyAgUiBvICAgIGQgICAgIFcgICAgIwogICQgIyAgICAgICAgICAgICAgICAgICAgIwogICQgIyAgICBnICAgICAgdCAgICAgVSAgIwogICQgIyAgICAgICAgICAgICAgICAgICAgIwogICQgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwomcCItLS0iCkYgJCAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiAgJCAjICBzcGRmbXNkbHdlOW13IFdFSzMjCiAgJCAjICAgIHdlICAgIGhpICAgICAgICAjCiAgJCAjICAgcmRmICAgICAgICAgZnNzenIjCiAgJCAjICAgICBzZGZnICBnamt0aSAgICAjCiAgJCAjICAgZmMgIGQgZyBpICAgICAgICAjCiAgJCAjICAgICBkZmcgICAgc2RkICAgICAjCiAgJCAjICAgIGcgICAgICAgIHpmZyAgICAjCiAgJCAjICBkZiAgIGRmICAgICAgICAgICAjCiAgJCAjICAgICAgICAgICAgIHhjZiAgIFIjCiAgJCAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCg==" rel="nofollow noreferrer">Test suite</a></p>
</div>
<div id="pu1" class="pu"><h1>Python3, 472 bytes</h1>
<pre class="lang-py prettyprint-override"><code>E=enumerate
S=lambda x:(len(x[2]),sum(a for _,a in x[2]))
def f(b):
 d,D={(x,y):v for x,r in E(b)for y,v in E(r)},{}
 x,y=[i for i in d if'R'==d[i]][0]
 q=[(x,y,[],[])]
 while q:
  (x,y,p,P),*q=q
  if'K'==d[(x,y)]:return p
  for X,Y in[(0,1),(1,0),(-1,0),(0,-1)]:
   U=(*(C:=(x+X,y+Y)),p+[((X,Y),1)]if[]==p or p[-1][0]!=(X,Y)else p[:-1]+[((X,Y),p[-1][-1]+1)],P+[C])
   if d.get(C)in[' ','K']and C not in P and(C not in D or D[C]&gt;=S(U)):q+=[U];D[C]=S(U)
  q=sorted(q,key=S)
</code></pre>
<p><a href="https://tio.run/##jVRLT@MwED5vfsUsHGpTg/q47GblvbSckFaIUlHkjVDBdmtI87ANbUH89u44aYuAquwomWa@eX2epFMs/TTPuj8Ku1qdcpU9zpQdexUNeDqe3coxLGKSqowsRCehzD3OyBh0buGGjcFkUME0kkqDJrc0jkCyPn8hC7ak8VMVuWA2RJ6iO5hL9lSblr6yl9cI/UsuTBVqgkeC0Y2LBudSmCQRrSSCkotQkYkEL4rAfGpSBSW2g8pRsHPKjkpeIoDZZ1V2RSKJrfKPNoMCXaHHiF1jF0FarE0ZabMW6uP6p8WO25iAgTDk5Ij0Yk4WzRFbNq8pZUVTEILZFBMTo0XCeQFYsBDH7UDzO6@8KnUKsRjBbUIdEhBMZedN0Uto6GI0yJOJ8qRHkVIDGgypJ@NMQg@y3IdpnAOaZGv2Q8c@5v/mAzKkNC6bXAyTXwGqECxbcpdbryQp2YNa8gFduTZwODg4iA53SnQIOPVKukGd3QddwZ8lwBe74UrKj/DuloGN6/wPLbuTVrHpUHzoj3K5eRi9p@Xw9vDF2fBweXiuB3L1VTTApLbqwsN90Xsm0f1yEq6QeuZkOlc/Z3O4Oj3rrhvNVdBT856WlXrbWjv3bDe0nNTIeHL/4M1btL4LB56A@fg6q@CQJHccGeC5dtevSsNaffom1rK4C96LvZMIm8TnN6lxnjjcJ9/Wf18hjkzytiS0Sb2y5E@eKQbuxBWp8aTxN2tQXA9RYU3miSbbQm2KS@oT2tmJdhFd/QM" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu2" class="pu"><h2>Python 2.6 (535 characters)</h2>

<pre><code>exec 'eJzNlLFugzAQhneewhki2/KBworksVOkDu3QgVqVE2hBioFgCDhV371nJ1VbKR3SKYtl/jvs77MwtenafiBVqbs9WGcjLW05MB69tj05QEfqhpTNaMpeDyXDhsQORd3wLCK+YwT7u6PzFVK/Ep9Tsn6gmU50UTA2woHzc01KuqYZ20PPZSh85/iCO2etzBnTG8tcvlLxnovTPFVxzyGEC4lpiBay5xiuYMXBcRVtzxqTfP+IpqrelaRFsheoYJbBNvFj13asxd23gXHGmZU7bTaFDgiZH+MUYydtKBuZRuS0nvPmOt564Sl3CmlxcWAG6D3lXIkpeUMGB7nyfj82HW3FWvjTTVSYCXNJEUupEimannu+nl04WyM8XoB1F13E9S6Pt+ki0vDZXOdyd5su8X9cnm7DBa/tLGW4yh7yKCn1rIF+9vSTj/HiBeqCS1M3bMrnwOvbl5Ysi+eGLlkBhosjxl1fNwM5Ak7xH6CiT3SdT4U='.decode('base64').decode('zlib')
</code></pre>

<p>Unpacks to a severely mistreated A* implementation. Reads stdin. Searches for solutions with minimal total distance. Breaks ties by preferring minimal number of directions. Lists moves to stdout. Finds kittens.</p>

<p><strong>Unpacked</strong>:</p>

<p>The source has been manually anti-golfed in a few places in order to obtain a smaller compressed representation. For example, a for loop over the compass directions was unrolled.</p>

<pre><code>import heapq,sys 
a=set() 
for v,p in enumerate(sys.stdin): 
 for u,s in enumerate(p): 
  if s in' KR':a.add((u,v)) 
  if s=='K':(q,r)=(u,v) 
  if s=='R':y=(u,v) 
o=[((abs(y[0]-q)+abs(y[1]-r),(y[0]!=q)+(y[1]!=r)),(0,0),y)] 
c=set() 
w={} 
while o: 
 _,h,x=heapq.heappop(o) 
 c.add(x) 
 s=lambda(u,v):(u,v-1) 
 y=s(x) 
 m=1 
 while y in a-c: 
  w[y]=[(h,x,(m,'N'))]+w.get(y,[]) 
  heapq.heappush(o,((abs(y[0]-q)+abs(y[1]-r)+h[0]+m,(y[0]!=q)+(y[1]!=r)+h[1]+1),(h[0]+m,h[1]+1),y)) 
  m+=1 
  y=s(y) 
 s=lambda(u,v):(u,v+1) 
 y=s(x) 
 m=1 
 while y in a-c: 
  w[y]=[(h,x,(m,'S'))]+w.get(y,[]) 
  heapq.heappush(o,((abs(y[0]-q)+abs(y[1]-r)+h[0]+m,(y[0]!=q)+(y[1]!=r)+h[1]+1),(h[0]+m,h[1]+1),y)) 
  m+=1 
  y=s(y) 
 s=lambda(u,v):(u+1,v) 
 y=s(x) 
 m=1 
 while y in a-c: 
  w[y]=[(h,x,(m,'E'))]+w.get(y,[]) 
  heapq.heappush(o,((abs(y[0]-q)+abs(y[1]-r)+h[0]+m,(y[0]!=q)+(y[1]!=r)+h[1]+1),(h[0]+m,h[1]+1),y)) 
  m+=1 
  y=s(y) 
 s=lambda(u,v):(u-1,v) 
 y=s(x) 
 m=1 
 while y in a-c: 
  w[y]=[(h,x,(m,'W'))]+w.get(y,[]) 
  heapq.heappush(o,((abs(y[0]-q)+abs(y[1]-r)+h[0]+m,(y[0]!=q)+(y[1]!=r)+h[1]+1),(h[0]+m,h[1]+1),y)) 
  m+=1 
  y=s(y) 
 if x==(q,r): 
  z='' 
  while x in w: 
   _,x,(m,d)=min(w[x]) 
   z='%s %d\n'%(d,m)+z 
  print z, 
  o=[]
</code></pre>
</div>
<div id="pu3" class="pu"><h2>Python 2.6 (504 characters)</h2>
<pre><code>import sys,itertools
W,Q=len,list   
M=[]
B=[]
for l in sys.stdin.readlines():
    r=Q(l.strip())
    B.append([0]*W(r))
    M.append(r)
    if &quot;R&quot; in r:x,y=r.index(&quot;R&quot;),W(B)-1
def S(B,M,x,y,P):
    c=M[y][x]
    b=B[y][x]
    if b and W(P)&gt;b:return 0
    B[y][x]=W(P)
    if c==&quot;K&quot;:return P  
    elif c==&quot;R&quot; and P:return 0
    if c in &quot;R &quot;:
        b=[]
        for q,w,s in((1,0,&quot;E&quot;),(-1,0,&quot;W&quot;),(0,-1,&quot;N&quot;),(0,1,&quot;S&quot;)):
            r=S(B,M,x+q,y+w,P+s)
            if r and(W(r)&lt;W(b)or not b):b=r
        if b:return b
    return 0
print &quot;\n&quot;.join(k+str(W(Q(g)))for k,g in itertools.groupby(S(B,M,x,y,&quot;&quot;)))
</code></pre>
</div>
<div id="pu4" class="pu"><h2>Scala 2.8 (451 characters)</h2>
<p>...but it doesn't solve ties in favor of least amount of directions (though it does find the least amount of steps).</p>
<pre><code>val m=io.Source.stdin.getLines.map(_.toArray).toSeq
var l=m.indexWhere(_ contains'R')
var c=m(l)indexOf'R'
val q=collection.mutable.Queue(l-&gt;c-&gt;&quot;&quot;)
def s{val((l,c),p)=q.dequeue
if(&quot;R &quot;contains m(l)(c))for((i,j,k)&lt;-Seq((-1,0,&quot;N&quot;),(0,1,&quot;E&quot;),(1,0,&quot;S&quot;),(0,-1,&quot;W&quot;)))q.enqueue(((l+i,c+j),p+k))
m(l)(c)='X'}
def P(s:String){if(s.nonEmpty){val (h,t)=s.span(s.head==)
println(s.head+&quot; &quot;+h.size)
P(t)}}
def Q{s
val((l,c),p)=q.head
if (m(l)(c)=='K')P(p)else Q}
Q
</code></pre>
<p>Scala 2.8, 642 characters, solves ties correctly;</p>
<pre><code>val m=io.Source.stdin.getLines.toSeq
var b=Map(0-&gt;0-&gt;0).withDefault(_=&gt;Int.MaxValue)
var l=m.indexWhere(_ contains'R')
var c=m(l)indexOf'R'
val q=collection.mutable.PriorityQueue(l-&gt;c-&gt;List((' ',0)))(Ordering.by(t=&gt;(-t._2.map(_._2).sum,-t._2.size)))
def s{val(p@(l,c),u@(h@(d,n))::t)=q.dequeue
if(&quot;R &quot;.contains(m(l)(c))&amp;&amp;u.map(_._2).sum&lt;=b(p)){b=b.updated(p,u.map(_._2).sum)
for((i,j,k)&lt;-Seq((-1,0,'N'),(0,1,'E'),(1,0,'S'),(0,-1,'W'))){
val o=if(k==d)(d,n+1)::t else (k,1)::h::t
q.enqueue(((l+i,c+j),o))}}}
def P(l:List[(Char,Int)]){l.reverse.tail.foreach{t=&gt;println(t._1+&quot; &quot;+t._2)}}
def Q{s;val((l,c),p)=q.head;if (m(l)(c)=='K')P(p)else Q}
Q
</code></pre>
<p>It discovered a shorter path for the second example than the one given in the problem:</p>
<pre><code>N 1
E 10
N 4
E 2
</code></pre>
</div>
<div id="pu5" class="pu"><h2>Ruby - 539 characters</h2>
<p>Could do with a lot of improvement, but it does work for shortest steps as well as directions.</p>
<pre><code>M=[*$&lt;]
r=M.map{|q|q.index('R')||0}
k=M.map{|q|q.index('K')||0}
D=M.map{|q|q.split('').map{[99,[]]}} 
def c h 
h.map{|i|i.inject([[]]){|a,b|a.last[0]!=b ? a&lt;&lt;[b, 1]:a.last[1]+=1;a}}.sort_by{|a|a.length}[0]
end
def t x,y,s,i
z,w=D[x][y][0],D[x][y][1]
if [' ','R','K'].index(M[x][y, 1])&amp;&amp;(z&gt;s||z==s&amp;&amp;c(w).length&gt;=c([i]).length)
D[x][y]=[s,z==s ? w&lt;&lt;i:[i]]
s+=1
t x+1,y,s,i+['S']
t x-1,y,s,i+['N']
t x,y+1,s,i+['E']
t x,y-1,s,i+['W']
end
end
t r.index(r.max), r.max, 0, []
puts c(D[k.index(k.max)][k.max][1]).map{|a|a*''}
</code></pre>
</div>
<div id="pu6" class="pu"><h3>C++ <strike>1002</strike> <strike>899</strike> 799chars</h3>

<p>Note requires the use of C++0x to eliminate the space between > > in templates.</p>

<p>It does find the route with the minimum number of turns.</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;set&gt;
#include&lt;memory&gt;
#define D make_pair
#define F first
#define S second
using namespace std;typedef pair&lt;int,int&gt;L;typedef vector&lt;L&gt;R;typedef multiset&lt;pair&lt;float,pair&lt;L,R&gt;&gt;&gt;B;vector&lt;string&gt; M;string l;int z,c,r=0;set&lt;L&gt; s;B b;L n;B::iterator f;R v;void A(int x,int y,int w){n=f-&gt;S.F;for(c=1;(z=M[n.S+=y][n.F+=x])==32||(z==75);++c)v.back()=D(w,c),b.insert(D(f-&gt;F+c+1./c,D(n,v)));}int main(){for(;getline(cin,l);++r){if((c=l.find(82))!=string::npos)b.insert(D(0,D(D(c,r),R())));M.push_back(l);}while(!b.empty()){f=b.begin();n=f-&gt;S.F;v=f-&gt;S.S;if(M[n.S][n.F]==75)break;if(s.find(n)==s.end()){s.insert(n);v.push_back(L());A(0,1,83);A(0,-1,78);A(1,0,69);A(-1,0,87);}b.erase(f);}for(c=v.size(),r=0;r&lt;c;++r)n=v[r],printf("%c %d\n",n.F,n.S);}
</code></pre>

<p>It <code>Dijkstra's Algorithm</code> for solving the shortest path problem.<br>
To distinguish between multiple equal size routes a long straight line has less weight that multiple short lines (this favors routes with less turns).</p>

<pre><code>Cost of a path:  Len + 1/Len

Looking at Test Case 1:
========================
Thus Path E13 + N2 has a cost of 
      13 + 1/13 + 2 + 1/2
An alternative path E9 + N2 + E4 has a cost of
      9 + 1/9 + 2 + 1/2 + 4 + 1/4

The difference is
      Straight Path:   1/13 &lt;   Bendy Path: (1/9 + 1/4)
</code></pre>

<p>In a more readable form:</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;set&gt;
#include&lt;memory&gt;

using namespace std;
typedef pair&lt;int,int&gt;                   L;
typedef vector&lt;L&gt;                       R;
typedef multiset&lt;pair&lt;float,pair&lt;L,R&gt;&gt;&gt; B;
vector&lt;string&gt;                          M;

string      l;
int         z,c,r=0;
set&lt;L&gt;      s;
B           b;
L           n;
B::iterator f;
R           v;

void A(int x,int y,int w)
{
    n=f-&gt;second.first;
    for(c=1;(z=M[n.second+=y][n.first+=x])==32||(z==75);++c)
        v.back()=make_pair(w,c),
        b.insert(make_pair(f-&gt;first+c+1./c,make_pair(n,v)));
}

int main()
{
    for(;getline(cin,l);++r)
    {
        if((c=l.find(82))!=string::npos)
            b.insert(make_pair(0,make_pair(make_pair(c,r),R())));
        M.push_back(l);
    }

    while(!b.empty())
    {
        f=b.begin();
        n=f-&gt;second.first;
        v=f-&gt;second.second;

        if(M[n.second][n.first]==75)
            break;

        if(s.find(n)==s.end())
        {
            s.insert(n);
            v.push_back(L());
            A(0,1,83);
            A(0,-1,78);
            A(1,0,69);
            A(-1,0,87);
        }
        b.erase(f);
    }

    for(c=v.size(),r=0;r&lt;c;++r)
        n=v[r],
        printf("%c %d\n",n.first,n.second);
}
</code></pre>
</div>
<div id="pu7" class="pu"><h2>Ruby - 648 characters</h2>

<p>Another one that fails the least number of directions test as I can't think of any easy way to embed it in A*.</p>

<pre><code>m=$&lt;.read.gsub /[^RK\n ]/,'#'
l=m.index($/)+1
s=m.index'R'
g=m.index'K'
h=-&gt;y{(g%l-y%l).abs+(g/l-y/l).abs}
n=-&gt;y{[y+1,y-1,y+l,y-l].reject{|i|m[i]=='#'}}
a=o=[s]
d=Array.new(m.length,9e9)
c,k,f=[],[],[]
d[s]=0
f[s]=h[s]
r=-&gt;y,u{u&lt;&lt;y;(y=k[y])?redo:u}
(x=o.min_by{|y|f[y]}
x==g ? (a=r[x,[]].reverse;break):0
o-=[x];c&lt;&lt;x
n[x].map{|y|c&amp;[y]!=[]?0:(t=d[x]+1
o&amp;[y]==[]?(o&lt;&lt;y;b=true):b=t&lt;d[y]
b ? (k[y]=x;d[y]=t;f[y]=t+h[y]):0)})until o==[]
k=a.inject([[],nil]){|k,u|(c=k[1]) ? (k[0]&lt;&lt;(c==u-1?'E':c==u+1?'W':c==u+l ? 'N':'S')) : 0;[k[0],u]}[0].inject(["","",0]){|k,v|k[1]==v ? k[2]+=1 : (k[0]+=k[1]+" #{k[2]}\n";k[1]=v;k[2]=1);k}
puts k[0][3,9e9]+k[1]+" #{k[2]}\n"
</code></pre>
</div>
<div id="pu8" class="pu"><h2>c++ -- 681 necessary characters</h2>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
using namespace std;
int d[]={-1,0,1,0},i,j,k,l,L=0,p=41,S;string I,m,D("ESWN");
int r(int o,int s){S=s;while((m[o]==32||m[o]==37)&amp;&amp;m[o+S]-35)
if(m[o+S]-p)S+=s;else return o+S;return 0;}
void w(int o){for(i=0;i&lt;m.length();++i)for(j=0;j&lt;4;++j)
if(k=r(o,d[j])){stringstream O;O&lt;&lt;D[j]&lt;&lt;" "&lt;&lt;int((k-o)/d[j])&lt;&lt;"\n"&lt;&lt;I;
I=O.str();if(p-41)--p,m[k]=37,w(k);cout&lt;&lt;I;exit(0);}}
int main(){while(getline(cin,I))m+=I,l=I.length();
d[1]-=d[3]=l;I="";for(i=0;i&lt;m.length();++i)
switch(m[i]){case 82:case 75:m[i]/=2;case 32:break;default:m[i]=35;}
do{for(i=0;i&lt;m.length();++i)if(r(i,-1)+r(i,-l)+r(i,1)+r(i,l))
{if(m[i]==37)w(i);m[i]=p+1;}}while(++p);}
</code></pre>

<p>It first replaces all the obstacles on the map with into <code>#</code>s (and changes the values of <code>K</code> and <code>R</code>, to leave headroom in the character space for very long paths. <em>Then it scribbles on the map.</em> An iterative process marks all the successively accessible squares until it is able to reach the kitten in one move. After that is uses the <em>same</em> accessibility checking routine to find a string of positions that lead back to the start in minimal instructions. These instructions are loaded into a string by pre-pending, so that they print in the proper order.</p>

<p>I don't intend to golf it further as it does not properly resolve ties and can not be easily adapted to do so.</p>

<p>It fails on </p>

<pre><code>#####
#   #
# # #
#R#K#
#   #
#####
</code></pre>

<p>producing</p>

<pre><code> $ ./a.out &lt; kitten_4.txt
N 2
E 2
S 2
</code></pre>

<p><strong>More or less readable version:</strong></p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
using namespace std;

int d[]={-1,0,1,0}
  , i, j, k
  , l      /* length of a line on input */
  , L=0    /* length of the whole map */
  , p=41   /* previous count  ( starts 'R'/2 ) */
  , S      /* step accumulator for step function */
  ; 
string I/*nput line, later the instructions*/
  , m/*ap*/
  , D("ESWN"); /* Reversed sence for back tracking the path */

int r/*eachable?*/(int o/*ffset*/, int s/*step*/){
//   cerr &lt;&lt; "\tReachable?" 
//        &lt;&lt; endl
//        &lt;&lt; "\t\tOffset: " &lt;&lt; o &lt;&lt; " (" &lt;&lt; o/5 &lt;&lt; ", " &lt;&lt; o%5 &lt;&lt; ")" 
//        &lt;&lt; "  [" &lt;&lt; m[o] &lt;&lt; "]" &lt;&lt; endl
//        &lt;&lt; "\t\tStep: " &lt;&lt; s 
//        &lt;&lt; endl
//        &lt;&lt; "\t\tSeeking: " &lt;&lt; "[" &lt;&lt; char(p) &lt;&lt; "]" 
//        &lt;&lt; endl
//        &lt;&lt; "\t\tWall:    " &lt;&lt; "[" &lt;&lt; char(35) &lt;&lt; "]" 
//        &lt;&lt; endl;
  S=s;
  while ( ( (m[o]==32)      /* Current character is a space */ 
        || (m[o]==37) ) /* Current character is a kitten */ 
      &amp;&amp; (m[o+S]-35) /* Target character is not a wall */ 
      )
    {
//     cerr &lt;&lt; "\t\tTry: " &lt;&lt; o+S &lt;&lt; "(" &lt;&lt; (o+S)/5 &lt;&lt; ", " &lt;&lt; (o+S)%5 &lt;&lt; ")" 
//   &lt;&lt; "  [" &lt;&lt; m[o+S] &lt;&lt; "]" &lt;&lt; endl;
    if (m[o+S]-p       /* Target character is not the previous count */ 
    ) {
//       cerr &lt;&lt; "\t\twrong " &lt;&lt; "  [" &lt;&lt; m[o+S] &lt;&lt; "] !!!" &lt;&lt; endl;
      S+=s;
    }
    else  {             /* Target character *is* the previous count */
//       cerr &lt;&lt; "\t\tFound " &lt;&lt; "  [" &lt;&lt; m[o+S] &lt;&lt; "] !!!" &lt;&lt; endl;
      return o+S;
    } 
  /* while ends */
      }
  return 0;
}

void w/*on*/(int o/*ffset*/){
//   cerr &lt;&lt; "\tWON" &lt;&lt; endl
//        &lt;&lt; "\t\tOffset: " &lt;&lt; o &lt;&lt; "(" &lt;&lt; o/5 &lt;&lt; ", " &lt;&lt; o%5 &lt;&lt; ")" 
//        &lt;&lt; "  [" &lt;&lt; m[o] &lt;&lt; "]" 
//        &lt;&lt; endl
//        &lt;&lt; "\t\tSeeking: " &lt;&lt; "[" &lt;&lt; char(p) &lt;&lt; "]" 
//        &lt;&lt; endl;
  for(i=0;i&lt;m.length();++i) /* On all map squares */
    for(j=0;j&lt;4;++j)
      if (k=r(o,d[j])) {
//  cerr &lt;&lt; "found path segment..." 
//       &lt;&lt; (k-o)/d[j] &lt;&lt; " in the " &lt;&lt; d[j] &lt;&lt; " direction." &lt;&lt; endl;
    stringstream O;
    O &lt;&lt; D[j] 
      &lt;&lt; " " 
      &lt;&lt; int((k-o)/d[j]) 
      &lt;&lt; "\n" 
      &lt;&lt; I;
    I = O.str();
//  cerr &lt;&lt; I &lt;&lt; endl;
    /* test for final solution */
    if (p-41) 
      --p,m[k]=37, w(k); /* recur for further steps */
    cout &lt;&lt; I;
    exit(0);
      }
    /* inner for ends */
  /* outer for ends */
}


int main(){
  while(getline(cin,I))
    m+=I,l=I.length();
//   cerr &lt;&lt; "Read the map: '" &lt;&lt; m &lt;&lt; "'." &lt;&lt; endl;
  d[1]-=d[3]=l;I="";
//   cerr &lt;&lt; "Direction array:    " &lt;&lt; D &lt;&lt; endl;
//   cerr &lt;&lt; "Displacement array: " &lt;&lt; d[0] &lt;&lt; d[1] &lt;&lt; d[2] &lt;&lt; d[3] &lt;&lt; endl;
//   cerr &lt;&lt; "Line length: " &lt;&lt; l &lt;&lt; endl;
  /* Rewrite the map so that all obstacles are '#' and the start and
     goal are '%' and ')' respectively. Now I can do pathfinding *on*
     the map. */
  for(i=0;i&lt;m.length();++i)
    switch (m[i]) {
    case 82:         /* ASCII 82 == 'R' (41 == ')'  ) */
    case 75:m[i]/=2; /* ASCII 75 == 'K' (37 == '%' ) */
    case ' ':break;
    default: m[i]=35; /* ASCII 35 == '#' */ 
    };
//   cerr &lt;&lt; "Re-wrote the map: '" &lt;&lt; m &lt;&lt; "'." &lt;&lt; endl;
  do { /* For each needed count */
//     cerr &lt;&lt; "Starting to mark up for step count " 
//   &lt;&lt; p-41+1  &lt;&lt; " '" &lt;&lt; char(p) &lt;&lt; "'" &lt;&lt; endl;
    for(i=0;i&lt;m.length();++i){ /* On all map squares */
//        cerr &lt;&lt; "\tTrying position (" &lt;&lt; i/l &lt;&lt; ", " &lt;&lt; i%l &lt;&lt; ")" 
//      &lt;&lt; "  [" &lt;&lt; m[i] &lt;&lt; "]"
//      &lt;&lt; endl;
      if ( r(i, -1) /* west  */ +
       r(i, -l) /* north */ +
       r(i,  1) /* east  */ +
       r(i,  l) /* south */ 
       ) {
//    cerr &lt;&lt; "Got a hit on : '" &lt;&lt; m &lt;&lt; "'." &lt;&lt; endl;
//    cerr &lt;&lt; "\twith '" &lt;&lt; char(m[i]) &lt;&lt;" at position " &lt;&lt; i &lt;&lt; endl;
//    cerr &lt;&lt; "target is " &lt;&lt; char(37) &lt;&lt; endl;
    if(m[i]==37)
      w(i); /* jump into the win routine which never returns */
    m[i]=p+1;
//  cerr &lt;&lt; "Marked on map: '" &lt;&lt; m &lt;&lt; "'." &lt;&lt; endl;
      }
    }
  } while(++p);
}
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/586/">586</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




