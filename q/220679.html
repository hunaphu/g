<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::220679</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td>Rust</td><td>250421T021147Z</td><td><a href="https://codegolf.stackexchange.com/questions/220679/matching-abacaba-type-patterns/279242#279242">138 Aspe</a></td></tr>
<tr d-ix="1"><td>066</td><td>Wolfram Language Mathematica</td><td>220217T025326Z</td><td><a href="https://codegolf.stackexchange.com/questions/220679/matching-abacaba-type-patterns/242926#242926">att</a></td></tr>
<tr d-ix="2"><td>031</td><td>05AB1E</td><td>210402T164804Z</td><td><a href="https://codegolf.stackexchange.com/questions/220679/matching-abacaba-type-patterns/222786#222786">Kevin Cr</a></td></tr>
<tr d-ix="3"><td>141</td><td>JavaScript ES6</td><td>210314T231648Z</td><td><a href="https://codegolf.stackexchange.com/questions/220679/matching-abacaba-type-patterns/220680#220680">Arnauld</a></td></tr>
<tr d-ix="4"><td>205</td><td>Python 3</td><td>210315T215754Z</td><td><a href="https://codegolf.stackexchange.com/questions/220679/matching-abacaba-type-patterns/220734#220734">Noodle9</a></td></tr>
<tr d-ix="5"><td>030</td><td>Brachylog</td><td>210315T153252Z</td><td><a href="https://codegolf.stackexchange.com/questions/220679/matching-abacaba-type-patterns/220711#220711">xash</a></td></tr>
<tr d-ix="6"><td>nan</td><td>J</td><td>210315T031226Z</td><td><a href="https://codegolf.stackexchange.com/questions/220679/matching-abacaba-type-patterns/220685#220685">Jonah</a></td></tr>
<tr d-ix="7"><td>077</td><td>Retina</td><td>210315T114116Z</td><td><a href="https://codegolf.stackexchange.com/questions/220679/matching-abacaba-type-patterns/220700#220700">Neil</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.rust-lang.org" rel="nofollow noreferrer">Rust</a>, <del>740</del> <del>631</del> <del>619</del> <del>608</del> <del>516</del> <del>500</del> <del>489</del> 483 bytes</h1>
<p>Saved 109+12+11+92+16+11+6=257 bytes thanks to @ceilingcat</p>
<hr />
<p>Golfed version. <a href="https://ato.pxeger.com/run?1=bVXBcts2EJ3O9OSvWPMgkw3NECQty5TpjMeX6pCRp-30ImsyCA1VSCiKQ4CNbIZf0ksO7U_12nu_obsAKUtJQRLELnbfPiyI5R9_1o3SX7781ejV-eTv7_5plAClH9M03xaFyLXclipNf-Rq_bPQ01UJK3eWjpSuvfObX0V-3Sj5LG7aQmi39DeNBm762vSN6XMvc2dBIUrX838X-eliObx62DQtxSecDL3paluDBFlCGARlS9IHkiRJPKgatXZnC5SyD8tAlnrret40f5WxrkMG8D7jQV5sS-FapGfy5W2DpkrU2n32pt2ntSwE5DdhW1u83JuSLzFV2TEjA7IjkMZwecLh6D0tFqoMFRuuT12n3XXtU4e9403lCmZBvi01x5DuqPJaNQSvMHjX5VloUCuCUq1cOc51NRpVNj_XWdkOZNb_R-Z-n5v1gDtb3AfBMljJ8hFjBBteuZ_l5_tXElPTYW7WFvocc9Rkqqu7fq-__xd3c4M8XQ_aE8BGkbVQWkEGZoeMlprj-ODcU_d2_pZevFjRbYZrDvic0ni3m8_nO2r2TbqYRXHE4jiO4pgxFqHk-C_IEWqwMdtIYuTF0A0f0_WDyKAlCTMeiJkYNWPJIR5LWBwlNhQOIhwnrPeMUYwSRloKhFZmgmCQHuGir-V7BMkMP-oiNvCNDJ0o6tlbC2tFF03e3t5yfmsbx8t22I7BQ9OYvZm9qYWhScSA2cc4EAeSy-nJfv_ErsJTKx5ToNP5ckJvvtnT_gzaNxsGYx_242jiw2QQYpy5OphkpBgnqFz6x5jsKvTh4uLQljQTfOI9NEMJd86HCA2jvTpmPiSTrxGt-urIaswOmZLmMtmLl7SMBOkmX0PFFI-Nift-ZUZ1hYuNw0GXhGgRhcmxTDEvxobvN4nP1yL_KGpM8-LsoWmjyyTvznywYxZ3Z8spvH4Ni7t6qxSeu_qjD3fkY8ZLC1TVWNSKEovKL3gOZfkb_ITlmTa1kLnUsGpKU5JTLDXGgWqCq30Q75CmR8XBHOBAalG7XvAsK3f4InrdcNgH3updITFEhoVd96D7qSbPhaJqMBhl8IOJZJZyt91UvBag1wJePjSohWoKrfZIL2t6cNruwYHzG2jTNx20HX7fyN2C-0MGF0NYrsBALg9oYViuqOydur2ZZ7jMK0oLL4onqHgpc9jin4rLoqmF8e1O-rI3_Or-Aw" rel="nofollow noreferrer">Attempt This Online!</a></p>
<pre class="lang-rust prettyprint-override"><code>use std::collections::HashSet;fn f(I:&amp;str)-&gt;Vec&lt;usize&gt;{let(n,mut a,mut r,mut u,mut c)=(I.len(),vec![],vec![],HashSet::new(),0);for i in 0..n{for j in i..n{a.push(I[i..=j].into());c+=1}}let b=a.clone();for z in a{u.insert(z);}while c&gt;0{r.push(c);let mut s=HashSet::new();for x in u{for y in&amp;b{let p=format!(&quot;{x}{y}{x}&quot;);if I.contains(&amp;p){s.insert(p);}}}c=0;for p in&amp;s{if&quot;&quot;&lt;p&amp;&amp;p.len()&lt;=n{let mut h=HashSet::new();for P in 0..n{h.insert(I[P..].find(p).map(|i|P+i));}c+=h.len()-1}}u=s}r}
</code></pre>
<p>Ungolfed version. <a href="https://ato.pxeger.com/run?1=jVndUttIFr5nn2GrOlzENnEUy3YIMYEtltrMUFOZpCbJzgWhjCy1sYIseaUWhkl4kr2Zi92X2qfZ75zullqySSLASK3u8_udn27_-z95Wag___xvqeZPD_7317-UhRSFiiaTMEsSGao4S4vJ5OegWLyX6nCneh0rmU8mr_NseYa7QGX5oXj2TPwm_1XGuYzEPMuFITGZvDLrX02Pj7u9nZ1nmHmalakqRBaGZZ7LNJS4n4tAFOWsUHmcXok4FUreKlEW9KQWUry7U4ssFfM4jZ7OggJskuwqDj0m-GERF2IpMSMCZ9AMVXKHO83mRuZJsFoRJZelpgKaRL5QQa7ANpK3kL9MIybMxP8BtW6CRKZKqMyV5ZIZTB2a0yyPr-I0SKZamEtvZ56KjWld0m0iHkPZfq20HuiJp8ek9h9SfNkRuOI5m8KLi6lcrtRdtye-fq1XueN6AV25VGWeisEhj9zv8L9EKiY1hS5XaiGONGE8dXuH1QxQrifUbJxZsMnZ3HVWAV-kVzKHcQLtuL6IlQiDNM2UmEltUauNw-C4Ic8PiL8slSY2hatisnghYUmLsbcrAu0rNt_xMeQ3LyaTVK5J_Ep-Bq6EwHlWXi3EKiuKeJZYHOAxZvgzEOFxEpPXErZ5zhRz6O3A87brAC5sXkIsfFPIIA8XgB2R2wOYECp7wliQKdLNHEElZneQbOC5lH6XIpVAKy2WNR4RNRqLncJhVnmmX4va67vk1os4XHAsaXnmcV4oJzjEXoDHXARz2GmvptKWCR4WQbiI5Q2ZEjiY3RlFSZl1jDETXgmc1VJzC1XGH6-f6hVH4jHpdV7P9S4OG9MtGqoF7vqWPSwAahDz6r5YBisWU8d_LpNAxaRS5gg_C8JrO2LDnI3eKfQ6b6tceDHNGJaQrSmsB7bdr3qKHfvqoOuJaL5riX8SaTzksigTJbrvs6Xs8ooe-e7XLJW9SgWpGr77UGexMIug-HIFDjFlzSACKJ76FKlkPTEP4qTQSGBSSQCoLAMVLg5diguZy764JK6XEGkFqSRlX6QEJXYpD7Dy2vWMlVrRLF0HeVTs1iJuxLgXp4XMVXfTrL1GkjC6peVyBnmpqoSqhKPcxE_5CtkMVJFshe89lNRqoaFCkCR9a0ogO0lguFQFwHeWwmpa8T4RpqW-J3yiDZ8PXPqa3DUS30CoeCmLmqYhV-DtpePKS4FYLyWhwSQpy8xzFTbphwVDwr0mBFw_gRjvy5nKYQTSyRdXgDU4VEs_Uk0PkGwDmjCF-oQYOO-G0gtklfk8ydYEBqPZQHSLRVYmUdpRYoGyimHyfc-rkjTXOwfttRO5iHhNhl3f4prX7cCRukkIkrBEIEJedAZIepyY4FFT1jlKKSVmBDfJ9Bz_rQIFxKbFj9Tx-VTeavzrgl0_T6lFgidWpZpuVOl_ytCUGpP2Sfk1FHfn14U1ndK7ta2k1gU_B2mEwsM13NaDEK2JQB5L7mzR5MUA02aRhBRVeWsGArz_k0x1oQN8nSJnrVSIbrZOYcT3-rHXKLRYM62nTpO4QKklpfVsqq9t5lQeY1MWSeQvTkTn4jO9idtvHChy5aNcR0Y4x8yjzxe8Moqpp3uo9K3P48nnJ_5FmyS3hUFRlAg0UVCOk-Lk_enZ2bOPH14_PUAZBHA1U4NS6BxfpVy5RLgIKHBkjgR1Hdx5beqvuc0lorfiYxpTHu0DqrTMdKiIjjxDfRRrChiKSyriMmqSMk2Xcf0RacOKeyozGIJ1ieFpLtmVSDmO0xq0trjMW5XFolED7eT7Fl6GnvhFyhXpkK3uyMK6JqIVQgYlWjTmgqdz0yGX2nLYs5R-lTowQ_SFELhoFk2mtIyvFtwbIu-RgyLKWMssiucx7p16RFGeV7gkw7oaAhxTOGEGwlQM2vjcZg8Wyo3AkSfOtJLUdTsllaY3IkKPFxM39JtBUOV6Y7VO2qGsyT1kpoLEJEcqTIjIKxOeUcOqcRomZURgiEoyA-XAZmTqWqamMbex0Htqc-42hVsJZ7yhbr3fI8H2yjRGtt1zZaIYNBnVCk2zu51iOwB-t500RxLx0ES50qGooAxVrUATYlVpOs1SbNwUT3CdGqcAVlC1_GbY08FuwFTYVd5Ws2lZHDtN2uTcrQOJyZbubjGuY9fnnnhD_UCSZasJl_M4pcId6O2RDQPtKciqNxk3ktejI0dyesivx43ED177Hrbb2OlGDknyETdW1WqnVDBudSp4gEmru3zhFA_ikdJ2nLwHhFgkNFIBkFCuIkzvNfpgsjutnZpFrgEbe7ctlndjysZVa-NmYeVA1aLK6NnCaznzOz2X4t-zPEeHIxO55Ia1Wk_KEtRusjhCZroxJxFLr1HTiCCFwIPY2ih0bRUoEVS5sWnScjbsaIE630l8jk7f04soOaHWUmZIyjz-DrdW9TYcURCN5XkmItz4fKKt9ETT53_-NgIf-bQHvLC9eCRCLnfU_QEHjZLnbSzWbafmapHGHSiT6u5-uaefXT5t8flzqO9deDmSnC4kdnt09EIBZQnKW1itcPe1ld-45bPtW2fd2Ub0cu3ZJr-Lvl4F16wd9ZOWxaZmkMFZ9ritZG-LKyzOeMekxXSMpxPoxqbQvb4Rr3YftiHH4Qal-53tT_eNgD7gTGZ7fSedUeXUKU2KPZJor05szbM7ggdE25526izH9dc9hqPN2eG3koshjiZE79tMsrFbC0SoY6QfzyrNBOKQ4ND7hvE3m-ZT3U00D1IbmG0D9QGIgtY7dMrVgVTC3XBX73UMXhYyWWFTPS9T7hU2u9imbTePPdd9V9sWZL7rrSdHLoPDB_D00hMfuQxRA6JkBSGuX5uV8eFO6nvyNJDzJrvRUZYXi3hlW2eNHZ3HIltPZqjbS9moUIVUTTmphfA2ZNwoLVbK7WjZ2A4OKNR4z-g0fTIyG2qeZhoF3oRjI7xE0qnOlfXxMSXAI3Ejw0fnlYC7SKy77-jjzds39C9I5vTLt4tA4O8R3d_evn379pYu_Z_GRv5wNPRHo9FwNPJ9f4in3fqscneIEVy-vujJp1U-luGPP8zNkKmNxz6vAM0xD_v-2KXnj_3RcKxZ4WaI-7FvVo7wOBz7NEqMMItfEBmIR3SxVsvbIOmzfPQx9K28QxZnODTS6xl6Fv3Qy5OTkyA40VeAH_2Bq0l8wJevf339S9dgwIawNA0P59EKeXFYn5_L2xX7XO9g6l3M8YZP-emir__79ma_L6r74UFfHNiHEd68dF76NLA_xuBFv0nTfznoi-fP3bk0coC_UUXaxxM81xdDTBxWwyPU7vFBm6IeftmYte-7ktLIi3H1-ILUGEPccZvUiPj5-yR7pRkPvYSyo4EdGw8wYzgYN5-J5_N9lnfD8CE1FEieR-K886n8MnwxDu87faHv_dF954K3-OeneYYsvAzy675pQuj-QhNaIbZVkqKf-YA4pDz9W1mwU3mzXGXmya5zHNNVfSGnELOnv1VDAHu8m-l5f8SrrkWEGXP7CT6Y4F0OtVKtMzHVa57DF2WIpEi5wS45EnvMV59dZMtVkMtqN2c2zzbfWEq1hp_Qs33apWO2L5O_3Qtu3qCJJt639jy3bLG5YpIXvUZeRklDt_Koa6bpcxT9LRHa7juUozQOqY-gU-4ylyZl3uvvRM1Xo_Yr0v8D" rel="nofollow noreferrer">Attempt This Online!</a></p>
<pre class="lang-rust prettyprint-override"><code>use std::collections::HashSet;
use std::iter::FromIterator; // Required for collect::&lt;HashSet&lt;_&gt;&gt;()

/// Counts occurrences of a substring in text using the Python find-based logic.
/// This method correctly counts overlapping occurrences based on the start index found.
///
/// Equivalent to the Python `count_occurrences_original_method`.
fn count_occurrences(text: &amp;str, substring: &amp;str) -&gt; usize {
    if text.is_empty() || substring.is_empty() {
        return 0;
    }

    let text_length = text.len();
    let sub_length = substring.len();
    // If substring is longer than text, it cannot be found
    if sub_length &gt; text_length {
        return 0;
    }

    let mut found_indices_set: HashSet&lt;Option&lt;usize&gt;&gt; = HashSet::new();

    // Iterate through possible start positions in the text
    for start_pos in 0..text_length {
        // text.find() searches the *entire* string starting from byte 0.
        // We need the equivalent of Python's text.find(substring, start_pos),
        // which finds the first occurrence *at or after* start_pos.
        // We can achieve this by searching within the slice starting from start_pos.
        let search_slice = &amp;text[start_pos..];
        let found_in_slice = search_slice.find(substring);

        // If found, map the index relative to the slice back to the original text's index.
        let found_index_option = found_in_slice.map(|index_in_slice| start_pos + index_in_slice);

        // Add the result (Some(index) or None) to the set.
        // The Python code implicitly adds -1 if find fails after the last match;
        // here, `None` represents that &quot;not found from this start_pos onwards&quot;.
        found_indices_set.insert(found_index_option);
    }

    // The number of actual occurrences is len(set) - 1.
    // If substring is not found at all, the set will contain only `None`, len is 1. 1 - 1 = 0.
    // If found k &gt; 0 times, the set contains k `Some(index)` values + possibly `None`.
    // The length will be k or k+1. Subtracting 1 gives k.
    // Use saturating_sub to prevent underflow if len is 0 (shouldn't happen here).
    let count = found_indices_set.len().saturating_sub(1);

    count
}


/// Calculates a sequence of counts related to repeating substring patterns.
///
/// Equivalent to the Python `f_explicit`.
fn f_explicit_rust(input_string: &amp;str) -&gt; Vec&lt;usize&gt; {
    let w = input_string;
    let n_w = w.len();

    // Handle empty string case early
    if n_w == 0 {
        return Vec::new();
    }

    // 1. Generate all possible substrings (owned Strings)
    let mut all_substrings_list: Vec&lt;String&gt; = Vec::new();
    for i in 0..n_w {
        for j in i..n_w {
            // Use byte slicing [i..=j] for direct equivalent of Python's w[i:j+1]
            // This assumes simple ASCII/UTF-8 where byte indices align with characters okay.
            // For complex Unicode, a char-based approach would be needed.
            let substring = w[i..=j].to_string(); // Create an owned String
            all_substrings_list.push(substring);
        }
    }

    // 2. Keep a copy of the initial list of substrings ('v' in original)
    // Need to clone as the original list might be consumed or modified implicitly later
    let base_substrings_for_combination: Vec&lt;String&gt; = all_substrings_list.clone();

    // 3. Initialize the result list
    let mut results: Vec&lt;usize&gt; = Vec::new();

    // Initial 'n' is the total count of all generated substrings (including duplicates)
    let mut current_iteration_count = all_substrings_list.len();

    // 4. Initialize the collection of *unique* substrings for pattern generation ('s' in original)
    // We start with the unique set derived from the initial list.
    // Convert the Vec&lt;String&gt; into a HashSet&lt;String&gt;. This consumes the Vec.
    let mut current_unique_substrings: HashSet&lt;String&gt; = HashSet::from_iter(all_substrings_list);

    // 5. Main loop: continues as long as the count is positive
    while current_iteration_count &gt; 0 {
        // 6. Record the count for this iteration
        results.push(current_iteration_count);

        // 7. Generate the next set of pattern substrings ('s' update)
        let mut next_pattern_substrings_set: HashSet&lt;String&gt; = HashSet::new();

        // Iterate through unique substrings from the current generation ('sub1')
        // Borrow elements from the set to avoid moving them.
        for sub1 in current_unique_substrings{
            // Iterate through all original substrings ('sub2' from 'base_substrings_for_combination')
            // Borrow elements from the base list.
            for sub2 in &amp;base_substrings_for_combination {
                // Form the combined pattern: sub1 + sub2 + sub1
                // Using format! creates a new owned String.
                let combined_pattern = format!(&quot;{}{}{}&quot;, sub1, sub2, sub1);

                // Check if this pattern exists within the original input string 'w'
                // `w.contains()` takes a &amp;str pattern.
                if w.contains(&amp;combined_pattern) {
                    // Insert the owned String into the set.
                    next_pattern_substrings_set.insert(combined_pattern);
                }
            }
        }

        // 8. Recalculate the count 'n' for the *next* iteration based on the new set
        let mut next_iteration_total_occurrences = 0;
        // Iterate through the newly found unique patterns ('pattern_sub')
        // Borrow elements from the set.
        for pattern_sub in &amp;next_pattern_substrings_set {
            // Count occurrences of this pattern in the original string 'w'
            // Pass string slices (&amp;str) to the helper function.
            let occurrences = count_occurrences(w, pattern_sub);
            next_iteration_total_occurrences += occurrences;
        }

        // 9. Update state for the next iteration
        current_iteration_count = next_iteration_total_occurrences;
        // Move ownership of the newly created set to become the current set for the next loop.
        current_unique_substrings = next_pattern_substrings_set;
    }

    // 10. Return the collected counts
    results
}


fn main() {
    let tests = vec![
        &quot;&quot;, &quot;P&quot;, &quot;MOM&quot;, &quot;alfalfa&quot;, &quot;aha aha!&quot;, &quot;xxOOOxxxxxOOOxxx&quot;, &quot;3123213332331112232&quot;,
        &quot;2122222111111121221&quot;, &quot;13121311213121311212&quot;, &quot;344112222321431121114&quot;,
        &quot;141324331112324224341&quot;, &quot;344342224124222122433&quot;, &quot;331123321122132312321&quot;,
        &quot;11221112211212122222122&quot;, &quot;2222222112211121112212121&quot;, &quot;AAAaaAAAAAAAaAaAAaAaAAAAA&quot;,
        &quot;1100000010010011011011111100&quot;, &quot;1111221211122111111221211121&quot;,
    ];

    let expected: Vec&lt;Vec&lt;usize&gt;&gt; = vec![
        vec![], vec![1], vec![6, 1], vec![28, 8], vec![36, 9, 1], vec![136, 64, 9],
        vec![190, 55, 1], vec![190, 80, 3], vec![210, 114, 25, 2], vec![231, 48],
        vec![231, 49], vec![231, 61, 1], vec![231, 74], vec![276, 149, 4],
        vec![325, 166, 6], vec![325, 198, 30], vec![406, 204], vec![406, 261, 56, 2],
    ];

    let checker = ['\u{274c}', '\u{2713}']; // [Cross mark, Check mark]

    println!(&quot;Testing Rust explicit function:&quot;);
    for (t, e_vec) in tests.iter().zip(expected.iter()) {
        let s_list = f_explicit_rust(t);
        let success = s_list == *e_vec; // Compare the Vec&lt;usize&gt; results
        println!(&quot;\&quot;{}\&quot; -&gt; {:?} {}&quot;, t, s_list, checker[success as usize]);
        // assert!(success); // Optionally panic on failure
    }
}
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.wolfram.com/wolframscript/" rel="nofollow noreferrer">Wolfram Language (Mathematica)</a>, 66 bytes</h1>
<pre><code>Counts@Level[z@@@Subsequences@#,-3]&amp;
z[Longest@a___,__,a___]:=z@a!
</code></pre>
<p><a href="https://tio.run/##hU5Na4NAEL37KxoDOSXg7G4vhZSVXBMM5CgiU1ljIDHUjyKW5q/bmR0LpZc@Z@f7PeeGXeVu2F0KnMrttLv3ddfavftw13S01p76t9a9964uXGuX643OVsGY7u/12bWdxTzP12Qcs5ftaHExHZtL3aXLzWtpdxU2WHSuIWq2epwKrB@fQRiug/DI7pAcOOC1ZPNphU/0FpwPQ5IkA0Mi9zQorUBrrbQGAEUVtxVlBBBwBdwGWqfn3Zz4dW0MeAZpGd8GMJ5gQCsj0pQoyg3MDE2lMsBd/gFt@QHT6RzWI67c56XA38NOwc99Sq5V87WyIVv88TCOY8RYgPSJI4ho5AFiIMaIIpnPWrP2r9KLE0vR03M0f@rnf@Zh8DV9Aw" rel="nofollow noreferrer" title="Wolfram Language (Mathematica) – Try It Online">Try it online!</a></p>
<p>Returns an <code>Association</code> with corresponding values. Prepend <code>List@@</code> for list output.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 31 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>āεo&lt;VŒε.œYùεĆ4ô€¨yªεÂQ}P}1å]O0Ü
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//SOO5rfk2YUcnnduqd3Ry5OGd57YeaTM5vOVR05pDKyoPrTq39XBTYG1AreHhpbH@Bofn/P9vaGgEQkYg0sgQAA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/V9Waa@k8KhtkoKSfeWhlS5K/480ntuabxN2aN3RSee26h2dHHl457mtR9pMDm951LTm0IrKQ6vObT3cFFgbUGt4eGmsv8HhOf@V9MJ0/kcrKekoKAWACF9/XxCVmJMGQmBmRqICECuC2IaGRiBkBCKNDEEiFRX@/v4VIAChlWIB" rel="nofollow noreferrer">verify some more test cases</a> (pretty slow, so the larger test cases are omitted in the test suite).</p>
<p><strong>Explanation:</strong></p>

<p>Step 1: Loop over the possible sizes <span class="math-container">\$n\$</span> of the <span class="math-container">\$Z_n\$</span> based on the input-length.<sup><em>†</em></sup></p>
<p>We can calculate the valid <span class="math-container">\$n\$</span> to check with the following formula: <span class="math-container">\$m = \left\lceil\log_2(L)\right\rceil\$</span>, where <span class="math-container">\$L\$</span> is the input-length, and the result <span class="math-container">\$m\$</span> indicates the range <span class="math-container">\$[1,m]\$</span> to check for Zimin 'words': <span class="math-container">\$Z_{n=1}^m\$</span>.</p>
<p>In 05AB1E code, this would have resulted in <code>g.²îLεo&lt;VŒε.œYùεĆ4ô€¨yªεÂQ}P}1å]O0Ü</code> (<strong>35 bytes</strong>): <a href="https://tio.run/##yy9OTMpM/f8/Xe/QpsPrfM5tzbcJOzrp3Fa9o5MjD@88t/VIm8nhLY@a1hxaUXlo1bmth5sCawNqDQ8vjfU3ODzn/39DQyMQMgKRRoYA" rel="nofollow noreferrer">try it online</a>.</p>
<p><sup><em>†</em></sup> Since we have to strip trailing 0s at the end in case no <span class="math-container">\$Z\$</span> were found for them anyway, we simply don't calculate this maximum. Instead, we'll just check in the range <span class="math-container">\$[1,L]\$</span> for Zimin words. Less efficient in terms of performance, but 4 bytes shorter, which is all we care about with <a href="/questions/tagged/code-golf" class="post-tag" title="show questions tagged &#39;code-golf&#39;" rel="tag">code-golf</a>. :)</p>
<p>We can also calculate the amount of parts in the resulting Zimin 'word' (<span class="math-container">\$Z_n\$</span>), which is the oeis sequence <a href="https://oeis.org/A000225" rel="nofollow noreferrer">A000225</a>: <span class="math-container">\$2^n-1\$</span>.</p>
<pre class="lang-python prettyprint-override"><code>ā              # Push a list in the range [1, (implicit) input-length]
 ε             # Map over each of these integers:
  o            #  Take 2 to the power this integer
   &lt;           #  Decrease it by 1
    V          #  Pop and store this in variable `Y`
</code></pre>
<p>Step 2: For each of these amount of parts <span class="math-container">\$Y\$</span>, we check how many substrings of the input are valid Zimin 'words' (<span class="math-container">\$Z_Y\$</span>).</p>
<p>Step 2a: We do this by first generating all substrings of the input, and mapping over them:</p>
<pre class="lang-python prettyprint-override"><code>  Œ            #  Get all substrings of the (implicit) input-list
   ε           #  Inner map over each substring:
</code></pre>
<p>Step 2b: Then we'll get all partitions of the current substring of exactly <span class="math-container">\$Y\$</span> amount of parts:</p>
<pre class="lang-python prettyprint-override"><code>    .œ         #   Get all partitions of this subtring
      Yù       #   Only leave the partitions of `Y` amount of parts
</code></pre>
<p>Step 2c: We then check for each of these (correctly sized) partitions of this substring if it's a valid Zimin 'word'.<br />
We do this by checking two things:</p>
<ol>
<li>Is the current list of parts in this partition a palindrome?</li>
<li>Is every <span class="math-container">\$ABA\$</span> part within the current partition a palindrome?</li>
</ol>
<p>As for step 2c2, we do so by first adding a dummy trailing item to the partition; then splitting the partition-list into sublists of size 4; then we remove the trailing item from each of these sublists; after which we can check for each <span class="math-container">\$[A,B,A]\$</span> sublist whether it's a palindrome.</p>
<pre class="lang-python prettyprint-override"><code>        ε      #   Inner map over each remaining partition:
         Ć     #    Enclose the partition; append its own first part at the end
          4ô   #    Split the partition into parts of size 4
            €¨ #    Remove the final part of each quartet
         yª    #    Append the full partition to this list of triplets as well
           ε   #    Inner map over this list of lists:
               #     Check if the current list is a palindrome by:
            Â  #      Bifurcating: short for Duplicate &amp; Reverse copy
             Q #      Check if the list and reversed copied list are the same
           }   #    After this inner-most map:
            P  #    Check if all were truthy by taking the product
</code></pre>
<p>Alternatively for step 2c2, <code>Ć4ô€¨</code> could have been <code>4ô3δ∍</code> instead: Split the partition-list into sublists of size 4 (with 3 in the trailing sublist); shorten each sublist to size 3 by removing trailing item(s); same as above. <a href="https://tio.run/##yy9OTMpM/f//SOO5rfk2YUcnnduqd3Ry5OGd57aaHN5ifG7Lo47eykOrzm093BRYG1BreHhprL/B4Tn//xsaGoGQEYg0MgQA" rel="nofollow noreferrer">Try it online.</a></p>
<p>Step 2d: And we then check if there is at least one valid Zimin 'word' (<span class="math-container">\$Z_Y\$</span>) among the mapped partitions for this substring:</p>
<pre class="lang-python prettyprint-override"><code>       }       #   After the map over the partitions of the current substring:
        1å     #   Check if any were truthy by checking if it contains a 1
               #   (NOTE: we can't use the max builtin `à` here like we usually do when
               #    we want to mimic an `any` builtin, because lists could be empty here,
               #    resulting in an empty string)
</code></pre>
<p>Step 3: Now we sum the amount of truthy results per size <span class="math-container">\$Y\$</span>:</p>
<pre class="lang-python prettyprint-override"><code>]              # Close all remaining nested maps
 O             # Sum the inner-most lists together
</code></pre>
<p>Step 4: And finally we clean-up all trailing 0s (both the <span class="math-container">\$\geq m\$</span> sizes we've checked in our golfed approach, as well as any trailing <span class="math-container">\$Z\$</span> within the <span class="math-container">\$[1,m]\$</span> range that simply resulted in <span class="math-container">\$0\$</span>), before outputting the result:</p>
<pre class="lang-python prettyprint-override"><code>  0Ü           # Remove any trailing 0s from this list
               # (after which the resulting list is output implicitly)
</code></pre>
</div>
<div id="pu3" class="pu"><h1>JavaScript (ES6), <s> 148 142 </s> 141 bytes</h1>
<p><em>Saved 6 bytes thanks to @user81655</em></p>
<p>Expects an array of characters.</p>
<pre class="lang-javascript prettyprint-override"><code>f=(a,o=[],s='')=&gt;a.map(c=&gt;{for(s+=c,i=p='';s.match(`^${p+='(.+)'+p.replace(/\(.../g,_=&gt;&quot;\\&quot;+n++)}$`);n=1)o[+i]=-~o[i++]})+a?f(a.slice(1),o):o
</code></pre>
<p><a href="https://tio.run/##jZJvT8MgEMbf@ymQmAwCdh6wfxrmJzDzfVcdqeusqaNZjVli9KvPY50zUTa9FAohv4fn7nhyr67JV2X9cr70D/PNprDMSW/TTDa20@F27JJnV7Pcjt8Kv2KNsLksbY1nVw2evOSPbHZ39lYL22GJ4B1RJ6t5Xbl8zrpTliRJdyHv7ZhOp1QsheDvZzN@tbTAfSrKzJ5/@LQUInvnwl0XzCVNVSIKXHp@6Te5Xza@mieVX7CCpShHKTkSGeek2yVpdhIhb@k/SIiiN5Mb@ifal3HYVUX46FFYDSUZxvFHR3Cc0mO47ksykiRuYL2eTCbrEO2fRhMPEn2DMlENDUor0ForrQFA4Y7@1hhdSNLrHfKhEMOANsIODmgMceioBqARHNtpt/g2si8mIA@AySg0o@IJGQNbP5iW2eogQH8KaZDExPsCBrQybTVwoXBtIC4wOuRAI6YMBDqUA9WiAn04VNJwPXZEhVTQTtulqMbAxLOAbUPCpOCrQWpX0r3AAN8GGHxgJtt8Ag" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<h3>How?</h3>
<p>For each substring in the input string, we apply the following patterns while they match:</p>
<pre><code>P₀  ^(.+)$
P₁  ^(.+)(.+)\1$
P₂  ^(.+)(.+)\1(.+)\1\2\1$
P₃  ^(.+)(.+)\1(.+)\1\2\1(.+)\1\2\1\3\1\2\1$
    ...
</code></pre>
<p>Apart from the delimiters <code>^</code> and <code>$</code> which are ignored below, these patterns are built recursively as follows:</p>
<ul>
<li><p><span class="math-container">\$P_0\$</span> is <code>(.+)</code></p>
</li>
<li><p><span class="math-container">\$P_{k+1}\$</span> is <span class="math-container">\$P_{k}\$</span>, followed by <code>(.+)</code>, followed by <span class="math-container">\$P_k\$</span> with each <span class="math-container">\$n\$</span>-th group <code>(.+)</code> replaced with the back reference <code>\{n}</code> (1-indexed)</p>
<p>e.g. for <span class="math-container">\$P_2 \rightarrow P_3\$</span>:</p>
<pre><code>(.+)(.+)\1(.+)\1\2\1 -> (.+)(.+)\1(.+)\1\2\1 (.+) <s>(.+)(.+)</s>\1<s>(.+)</s>\1\2\1
                                                   \1  \2    \3</code></pre>
</li>
</ul>
<p>It's worth noting that:</p>
<ul>
<li>if a substring matches some <span class="math-container">\$P_i\$</span>, it also matches all <span class="math-container">\$P_j,\:j&lt;i\$</span></li>
<li>if a substring doesn't match some <span class="math-container">\$P_i\$</span>, it also won't match any <span class="math-container">\$P_j,\:j&gt;i\$</span></li>
</ul>
<p>We keep track of the results in the array <code>o[]</code>, which is eventually returned. Whenever <span class="math-container">\$P_i\$</span> matches a substring, we increment <code>o[i]</code>.</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python 3</a>, 205 bytes</h1>

<pre class="lang-python prettyprint-override"><code>def f(w):
 R=range(len(w));s=[w[i:j+1]for i in R for j in R[i:]];v=[*s];n=len(s);r=[]
 while n:r+=[n];s={i+j+i for i in s for j in v if i+j+i in w};n=sum(len({w.find(a,b)for b in R})-1for a in s)
 return r
</code></pre>
<p><a href="https://tio.run/##TVPbkppAEH3nKzq8CHE2Rc@M9yJVfsCWqX1leWB1iBjDWoCrieW3m@4eXNPM5Zy@nGlwPPzptu@1ud02roQyOsXzAF7Spqh/umjvanLEizbNTlk13w0xL98bqKCq4QUY7gRSLM8XH2n2tc0Xdcplbbxo0iwP4LSt9g7qeTNMszonqUs13A0r@BRqH0IfUJXgw8ROV9Jqj7@ljcvpW1nVm6hQbzHnv8nB1/gJmRUiFAfQuO7Y1NDcOtd2LaQQhaGC8Acvz6tn3op9yUPgtgCaXxifz6vV6szmd/YZ1EajMUYbg4iaGLs1ITL0xgzZjZROU5YeSLqxFqWCtKy4Ea0UWDTaemkCmrDFvsIQ1RbZywdQlgS4nNphPar1/YkUSj@8aLz3p323uu/WZ/gsfji4XC6LYumtoMcvZF40EUM/0A@2JPHxXqvX/o9iGAfufHDrzm34V8hyBRnyMlay6amCKQMzVjBTIE5kMrbkEDZLFIxG9xizKU0j5UiIPqMCTQlaXAYV2OkDzj7hGHsRYRMrcEJnoaWjhRrWwTGf/6AzatIkzG1CEZ3YB2bNEYM8iIP11q1/uYbfdPB61BO7HigQhGYQB3xFO@X4kv6tDpHcTQX378P/ODK@rWXUxUIOTVV3UTkIL901hKfvcGmvcOmPyVyatvl1EN/@AQ" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
<p><em>Quite</em> verbose.<br />
Inputs a string and returns a list of the number of substrings that are instances <span class="math-container">\$Z_1, Z_2, \dots, Z_n\$</span>.</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/JCumin/Brachylog" rel="noreferrer">Brachylog</a>, 30 bytes</h1>
<pre><code>{s{h∧1|~cṪ↺₁hʰb=h↰ᶠ⌉+₁}ᵘ}ᶠcọtᵐ
</code></pre>
<p><a href="https://tio.run/##TU69SgNBEH6VcwsbFW5mtlW4BwiXXiw2B7pFQFAhJ2cCXhEMKFha2glWaRSMb@Bb3L7IOT8r@O3s7Px88@3MrkITb@eXFzh2C1ccnRRusZ/W29T3w26zHD6ex@66i@nhDe5WzfD1nta71N/Hn@3sODJv@HxNj5sDLjH3ZclpM3w/3cjceOrcYeGm4ib1RJ4wPxfTMIaC757EbVvXdSuwV2oESAhEhEQAgJxJGTligEEykDIwna@6HCidvAedYC2vZQCvAx4IvUlzgBx7yBPEKXqQqnzALG3IOK8jejxr@6kU6D7iEP72Q9sW87bGMJYcaVZVFUJlCHzMMUy0VIAZmAnK0vpZK2v/S8Gd/QI" rel="noreferrer" title="Brachylog – Try It Online">Try it online!</a></p>
<ul>
<li><code>{s … }ᶠ</code> for every substring:</li>
<li><code>{h∧1| …}</code> on every non-empty string, return 1. Also try …</li>
<li><code>~c</code> input split into groups, so that …</li>
<li><code>Ṫ↺₁…b=</code> it unifies with <code>[A,B,A]</code> (this works, too, but is sadly longer).</li>
<li><code>hʰ</code> B is non-empty</li>
<li><code>h↰ᶠ</code> take <code>A</code> and call the predicate recursively, finding all results</li>
<li><code>⌉+₁</code> get the highest number and add 1</li>
<li><code>ᵘ</code> Find all unique values. So for <code>aha aha</code> we get <code>[1,2,3]</code> from <code>[aha aha, aha, a]</code>.</li>
<li><code>cọtᵐ</code> join the results from all the substrings, count the occurrences of each number, and return them</li>
</ul>
</div>
<div id="pu6" class="pu"><h1><a href="http://jsoftware.com/" rel="nofollow noreferrer">J</a>, <sup>63 58 53 52 51</sup> 47 bytes</h1>
<pre><code>_1}.1#.a:~:[:([#~[e.&amp;,(],,)&amp;.&gt;/)^:a:~@;&lt;@(&lt;\)\.
</code></pre>
<p><a href="https://tio.run/##PYzRCoIwFIbvfYpTgnMwl2ea2LIQgq4So1utGKFIBN16k6@@pq7G/rOd7zvbUy85aWEngQCDEKRJwOFwOR31HT8cXa7kICvpV@5QNdxj/pUx6vH9it6kUfk2y/2spjXX1Gke3RtaIEVZEGfuCIFAjozMvc8kUovOliWAlkwPJyZSSC1Ur3bcVkQJbP7zqlNgsrAOjUxi42fb92VZ9uOaz9/XGAJiDGINwk5ihMJkKvYiiP4C" rel="nofollow noreferrer" title="J – Try It Online">Try it online!</a></p>
<p><sup>-2 bytes thanks to Bubbler</sup></p>
<p><sup>-3 bytes thanks to FrownyFrog for golfier way to create all substrings of a string.</sup></p>
<h2>how</h2>
<p>We'll use <code>MOM</code> as our example:</p>
<ul>
<li><p><code>[:...;&lt;@(&lt;\)\.</code> All substrings of the input, boxed.</p>
<pre><code>┌─┬─┬─┬──┬──┬───┐
│M│O│M│MO│OM│MOM│
└─┴─┴─┴──┴──┴───┘
</code></pre>
</li>
<li><p><code>(...)^:a:~</code> Using the substrings as both the left and right args <code>~</code>,
apply the verb in parens until a fixed point, keeping track of each iteration's
results <code>^:a:</code>.</p>
</li>
<li><p><code>(...(],,)&amp;.&gt;/)</code> To create the next &quot;level&quot; of candidates, create all possible
combinations that look like <code>&lt;level_n&gt;&lt;orig substring&gt;&lt;level_n&gt;</code> where
<code>level_n</code> is any element from the current level, and <code>&lt;orig substring&gt;</code> is
one of the original input substrings (level 0).  Then the 1st level looks like:</p>
<pre><code>┌─────┬─────┬─────┬───────┬───────┬─────────┐
│MMM  │OMO  │MMM  │MOMMO  │OMMOM  │MOMMMOM  │
├─────┼─────┼─────┼───────┼───────┼─────────┤
│MOM  │OOO  │MOM  │MOOMO  │OMOOM  │MOMOMOM  │
├─────┼─────┼─────┼───────┼───────┼─────────┤
│MMM  │OMO  │MMM  │MOMMO  │OMMOM  │MOMMMOM  │
├─────┼─────┼─────┼───────┼───────┼─────────┤
│MMOM │OMOO │MMOM │MOMOMO │OMMOOM │MOMMOMOM │
├─────┼─────┼─────┼───────┼───────┼─────────┤
│MOMM │OOMO │MOMM │MOOMMO │OMOMOM │MOMOMMOM │
├─────┼─────┼─────┼───────┼───────┼─────────┤
│MMOMM│OMOMO│MMOMM│MOMOMMO│OMMOMOM│MOMMOMMOM│
└─────┴─────┴─────┴───────┴───────┴─────────┘
</code></pre>
</li>
<li><p><code>[#~[e.&amp;,...</code> Check if each original substring is an element of this candidate
list <code>[e.&amp;,</code>, and use that to filter the original substrings <code>[#~</code>.  In the above
example, only <code>MOM</code> passes.</p>
</li>
<li><p>After the above process iterates to its fixed point (no more matches), the result
is:</p>
<pre><code>┌───┬─┬─┬──┬──┬───┐
│M  │O│M│MO│OM│MOM│
├───┼─┼─┼──┼──┼───┤
│MOM│ │ │  │  │   │
├───┼─┼─┼──┼──┼───┤
│   │ │ │  │  │   │
└───┴─┴─┴──┴──┴───┘
</code></pre>
</li>
<li><p><code>a:~:</code> Since we don't want to count empty boxes, we perform an elementwise
test for &quot;not equal to the empty box <code>a:</code>&quot;, giving us a 0-1 matrix:</p>
<pre><code>1 1 1 1 1 1
1 0 0 0 0 0
0 0 0 0 0 0
</code></pre>
</li>
<li><p><code>1#.</code> Sum rows:</p>
<pre><code>6 1 0
</code></pre>
</li>
<li><p><code>_1}.</code> And kill the last element:</p>
<pre><code>6 1
</code></pre>
</li>
</ul>
</div>
<div id="pu7" class="pu"><h1><a href="https://github.com/m-ender/retina/wiki/The-Language" rel="nofollow noreferrer">Retina</a>, 77 bytes</h1>
<pre><code>K`(.+)
/\(/{G`
%&quot;$+&quot;~`^
w`
&quot;¶0&quot;(Am`^0
K`

$+2
(.*?\))+(.*)$
$&amp;¶$&amp;(.+)$2\$#1$2
</code></pre>
<p><a href="https://tio.run/##K0otycxLNPz/3ztBQ09bk0s/RkO/2j2BS1VJRVupLiGOqzyBS@nQNgMlDcfchDgDLu8ELi4VbSMuDT0t@xhNTW0granCpaJ2aJuKGsgAFaMYFWVDFaP//w2NDY2AGExAGUYA" rel="nofollow noreferrer" title="Retina – Try It Online">Try it online!</a> No test suite because of the advanced use of result history. Explanation:</p>
<pre><code>K`(.+)
</code></pre>
<p>Start by considering matches of Z₁.</p>
<pre><code>/\(/{`
</code></pre>
<p>Repeat while the working area contains a <code>(</code>.</p>
<pre><code>G`
</code></pre>
<p>Do nothing. This is here solely to record the value at the start of each pass of the loop in the stage history, so that it can be referred to later on.</p>
<pre><code>%&quot;$+&quot;~`^
w`
</code></pre>
<p>Processing each line of regex separately, evaluate it as an overlapped count command on the original input, thereby returning a list of counts.</p>
<pre><code>&quot;¶0&quot;(`
</code></pre>
<p>If the list contains a <code>0</code> (strictly speaking this can only happen on the second pass, as I use a newline to check that it's a leading 0)...</p>
<pre><code>Am`^0
</code></pre>
<p>... then delete all <code>0</code> values (including the first if the input string was empty), otherwise:</p>
<pre><code>K`

$+2
</code></pre>
<p>Retrieve the value saved in step 2. (Because Retina numbers stages in post-order traversal, this is the <code>G</code> command.) Unfortunately <code>$</code> doesn't work directly in a <code>K</code> command, so the easiest way to do this is to delete the result and then substitute the empty string with the saved value.</p>
<pre><code>(.*?\))+(.*)$
$&amp;¶$&amp;(.+)$2\$#1$2
</code></pre>
<p>Append an additional regex that matches the next Zimin word.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/220679/">220679</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




