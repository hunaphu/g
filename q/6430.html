<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::6430</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>049</td><td>Binary Lambda Calculus</td><td>230808T150723Z</td><td><a href="https://codegolf.stackexchange.com/questions/6430/shortest-terminating-program-whose-output-size-exceeds-grahams-number/263884#263884">2014MELO</a></td></tr>
<tr d-ix="1"><td>175</td><td>7</td><td>230727T014601Z</td><td><a href="https://codegolf.stackexchange.com/questions/6430/shortest-terminating-program-whose-output-size-exceeds-grahams-number/263392#263392">2014MELO</a></td></tr>
<tr d-ix="2"><td>079</td><td>Python 3</td><td>230211T173641Z</td><td><a href="https://codegolf.stackexchange.com/questions/6430/shortest-terminating-program-whose-output-size-exceeds-grahams-number/257706#257706">EIG 520</a></td></tr>
<tr d-ix="3"><td>053</td><td>Python 3</td><td>210922T204327Z</td><td><a href="https://codegolf.stackexchange.com/questions/6430/shortest-terminating-program-whose-output-size-exceeds-grahams-number/235610#235610">E. Z. L.</a></td></tr>
<tr d-ix="4"><td>014</td><td>Functoid</td><td>220808T211635Z</td><td><a href="https://codegolf.stackexchange.com/questions/6430/shortest-terminating-program-whose-output-size-exceeds-grahams-number/250842#250842">2014MELO</a></td></tr>
<tr d-ix="5"><td>060</td><td>Ruby</td><td>211211T164950Z</td><td><a href="https://codegolf.stackexchange.com/questions/6430/shortest-terminating-program-whose-output-size-exceeds-grahams-number/238383#238383">Binary19</a></td></tr>
<tr d-ix="6"><td>101</td><td>Python 3</td><td>211127T174928Z</td><td><a href="https://codegolf.stackexchange.com/questions/6430/shortest-terminating-program-whose-output-size-exceeds-grahams-number/237769#237769">Binary19</a></td></tr>
<tr d-ix="7"><td>nan</td><td>Binary Lambda Calculus</td><td>210224T192054Z</td><td><a href="https://codegolf.stackexchange.com/questions/6430/shortest-terminating-program-whose-output-size-exceeds-grahams-number/219734#219734">Patcail</a></td></tr>
<tr d-ix="8"><td>089</td><td>Javascript</td><td>210221T234044Z</td><td><a href="https://codegolf.stackexchange.com/questions/6430/shortest-terminating-program-whose-output-size-exceeds-grahams-number/219469#219469">Patcail</a></td></tr>
<tr d-ix="9"><td>018</td><td>GolfScript</td><td>200930T012315Z</td><td><a href="https://codegolf.stackexchange.com/questions/6430/shortest-terminating-program-whose-output-size-exceeds-grahams-number/211819#211819">2014MELO</a></td></tr>
<tr d-ix="10"><td>050</td><td>Ruby</td><td>170514T004810Z</td><td><a href="https://codegolf.stackexchange.com/questions/6430/shortest-terminating-program-whose-output-size-exceeds-grahams-number/120499#120499">Simply B</a></td></tr>
<tr d-ix="11"><td>068</td><td>JavaScript</td><td>190427T004402Z</td><td><a href="https://codegolf.stackexchange.com/questions/6430/shortest-terminating-program-whose-output-size-exceeds-grahams-number/184844#184844">Naruyoko</a></td></tr>
<tr d-ix="12"><td>028</td><td>Pyth</td><td>171030T172214Z</td><td><a href="https://codegolf.stackexchange.com/questions/6430/shortest-terminating-program-whose-output-size-exceeds-grahams-number/146671#146671">KSmarts</a></td></tr>
<tr d-ix="13"><td>083</td><td>Javascript</td><td>150515T165918Z</td><td><a href="https://codegolf.stackexchange.com/questions/6430/shortest-terminating-program-whose-output-size-exceeds-grahams-number/50230#50230">SuperJed</a></td></tr>
<tr d-ix="14"><td>047</td><td>GolfScript</td><td>140123T150300Z</td><td><a href="https://codegolf.stackexchange.com/questions/6430/shortest-terminating-program-whose-output-size-exceeds-grahams-number/19224#19224">Peter Ta</a></td></tr>
<tr d-ix="15"><td>085</td><td>Python</td><td>130609T211001Z</td><td><a href="https://codegolf.stackexchange.com/questions/6430/shortest-terminating-program-whose-output-size-exceeds-grahams-number/11841#11841">Bakuriu</a></td></tr>
<tr d-ix="16"><td>nan</td><td>Haskell</td><td>120625T112708Z</td><td><a href="https://codegolf.stackexchange.com/questions/6430/shortest-terminating-program-whose-output-size-exceeds-grahams-number/6456#6456">ceased t</a></td></tr>
<tr d-ix="17"><td>nan</td><td>Python 111+n</td><td>120622T052512Z</td><td><a href="https://codegolf.stackexchange.com/questions/6430/shortest-terminating-program-whose-output-size-exceeds-grahams-number/6436#6436">beary605</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://tromp.github.io/cl/cl.html" rel="nofollow noreferrer">Binary Lambda Calculus</a>, <s>7.625</s> <s>7.5</s> <s>6.75</s> 6.125 bytes, <s>61</s> <s>60</s> <s>54</s> 49 bits</h1>
<pre><code>0100011010000110011000000101101100000011100111010
</code></pre>
<p>This encodes:</p>
<pre><code>(\x.x x) (\y.y (y (\g m.m g (\f n.f (f n)))))
</code></pre>
<p>To simplify things a bit, let <code>H = (\g m.m g 2)</code> where <code>2</code> is the <a href="https://en.wikipedia.org/wiki/Church_encoding" rel="nofollow noreferrer">Church numeral</a> <code>(\f n.f (f n))</code>. These are the first few steps of the reduction:</p>
<pre><code>(\x.x x) (\y.y (y H))
(\y.y (y H)) (\y.y (y H))
(\y.y (y H)) ((\y.y (y H)) H)
(\y.y (y H)) (H (H H))
H (H H) (H (H H) H)
H (H H) H (H H) 2
H (H H) 2 (H H) 2
2 (H H) 2 (H H) 2
H H (H H 2) (H H) 2
H H 2 H 2 (H H) 2
2 H 2 H 2 (H H) 2
H (H 2) H 2 (H H) 2
H (H 2) 2 2 (H H) 2
2 (H 2) 2 2 (H H) 2
H 2 (H 2 2) 2 (H H) 2
H 2 2 2 2 2 (H H) 2
2 2 2 2 2 2 (H H) 2
2^^6 (H H) 2
</code></pre>
<p>The next step is applying <code>H H</code> <span class="math-container">\$2\uparrow\uparrow6\$</span> times to <code>2</code>. After an odd number of aplications the result is not a number, but after an even number of aplications it is. Here <span class="math-container">\$2\uparrow\uparrow6\$</span> is not an aproximation, and since it is even, the final answer will be a number. We will use <span class="math-container">\$\frac{2\uparrow\uparrow6}{2}\$</span> times a function that applies <code>H H</code> twice. The function <code>H H (H H n)</code> grows as fast as the <a href="https://en.wikipedia.org/wiki/Ackermann_function" rel="nofollow noreferrer">Ackermann function</a>, to see this, let's take a look at a more general case. The function <code>k H 2 n</code> grows as fast as <span class="math-container">\$2\uparrow^kn\$</span>:</p>
<pre><code>0 H 2 n = 2 n = n^2 &gt; 2*n = 2{0}n

k+1 H 2 n = H (k H 2) n = H (\x.k H 2 x) n &gt;= H (\x. 2{k}x) n
    = n (\x. 2{k}x) 2 = 2{k+1}(n+1) &gt; 2{k+1}n
</code></pre>
<p>Applying this to <code>H H (H H n)</code> we get <code>H H (H H n) = H H n H 2 = n H 2 H 2 = H (n-1 H 2) H 2 = H (n-1 H 2) 2 2 = 2 (n-1 H 2) 2 2 = n-1 H 2 (n-1 H 2 2) 2 &gt;= n-1 H 2 2{n-1}2 2 &gt;= 2{n-1}2{n-1}2 2 = 2{n}3 2 &gt; 2{n}3</code>, which is about the same as <span class="math-container">\$A(n,n)\$</span>. So the size of the expression <code>2^^6 (H H) 2</code> is about <span class="math-container">\$g_{\frac{2\uparrow\uparrow6}{2}} &gt; g_{64}\$</span>.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://esolangs.org/wiki/7" rel="nofollow noreferrer">7</a>, 17.5 bytes</h1>
<pre><code>00000000: 505e 91e7 a3a4 63c8 edda 476d ea0b d556  P^....c...Gm...V
00000010: d7e                                      ..
</code></pre>
<p>Written in octal:</p>
<pre><code>24057221717216443074435566443555724057252555375
</code></pre>
<p><a href="https://tio.run/##HYqxDQAACMJeUhT5/zI0LrRJkY0OCkilkNNdoRty5nHtD8R5ifYC" rel="nofollow noreferrer" title="7 – Try It Online">Try it online!</a></p>
<p><code>721gge644355</code> is a function that, given a function <code>f_a()</code>, returns <code>f_(a+1)()</code>:</p>
<pre><code>|f_a() 721gge644355
|c7{f_a()}ggerr          # Where {f_a()} represents the pacified version of f_a()

# Applying the result to some number n, to see that it worked:
|n c7{f_a()}ggerr
|n|f_a() nr
   f_a() n               # Make n copies of f_a(), resulting in f^n_a()
 n        r              # Apply it to n, resulting in f^n_a(n) = f_(a+1)(n)
</code></pre>
<p>From that, a function <code>f_w()</code> can be written:</p>
<pre><code>|n cc71721644307443556ggerrr
|n|n|721gge644355 nrr
   n                              # A function (\x -&gt; x^n), representing f_0()
     721gge644355 nr              # Add 1 n times to the index of f_0(), resulting in f_n()
 n                  r             # Apply the result to n, resulting in f_n(n) = f_w(n)
</code></pre>
<p>The full program computes <code>f^256_w(2)</code>, which is greater than Graham's number:</p>
<pre><code>|| 24057221717216443074435566443555724057252555375
||cg6r|cc71721644307443556ggerrr|cg6r|crcrrre|r
||cg6r|cc71721644307443556ggerrr|cg6r|crcrrre|r r
||cg6r|cc71721644307443556ggerrr|cg6r|crcrrre r
||cg6r|cc71721644307443556ggerrr|cg6r crcrrre
                                 cg6r              # The number 2
                                      cr           # Raise 2, to itself returning 4
                                        cr         # Raise 4, to itself returning 256
       cc71721644307443556ggerrr          r        # Make 256 copies of f_w(), resulting in f^256_w()
  cg6r                                     r       # Apply this function to 2, resulting in f^256_w(2)
                                            e      # Print the result in the same encoding as the source code
</code></pre>
<p>We can see the code working by reducing it to just <code>f_w(2)</code>. This outputs <code>2^2^18</code>, which is represented by <code>2^18</code> copies of <code>2405</code> in the same encoding as the source.</p>
<pre><code>2405722171721644307443556644355575375
</code></pre>
<p><a href="https://tio.run/##HcXBEQAgCAPBliQQrv/KouNnl0RzjFQUqp3pw8Pe/Rk3Ti4" rel="nofollow noreferrer" title="7 – Try It Online">Try it online!</a></p>
</div>
<div id="pu2" class="pu"><h1>Python 3, 79 bytes</h1>
<pre><code>f=lambda x,y:f(x-1,f(x,y-1))if x*y else x+y+1
z=9;exec(&quot;z=f(z,z);&quot;*99);print(z)
</code></pre>
<p>f(x,y) is a modified version of ackermann for golfing purposes
<br><br>
f(x,y) = f(x-1,f(x,y-1)) if both x and y are greater than 0
<br>
f(x,0) and f(0,y) each add one to the nonzero entry (if both are zero, it is 1)</p>
<p>Then the program does recursion on f(x,x) 99 times.</p>
</div>
<div id="pu3" class="pu"><h1>Python 3, 53 bytes</h1>
<pre class="lang-python prettyprint-override"><code>m=lambda x:-x if x&lt;0 else m(x-m(x-1))/2;print(1/m(9))
</code></pre>
<p>It computes the reciprocal of the gap between the 9 and the smallest tame fusible number above it, which is shown <a href="https://arxiv.org/pdf/2003.14342.pdf" rel="nofollow noreferrer">here</a> to be at least <span class="math-container">\$f_{\varepsilon_0}(2)\$</span> in the fast-growing hierarchy, thus beating Graham's number.</p>
<h1>Pyth, <s>24</s> 22 bytes</h1>
<p>-2 bytes thanks to r.e.s.</p>
<pre><code>DlHR?&lt;HZ_H/l-Hl-H12)lT
</code></pre>
<p>Same algorithm as before. I changed the argument 9 to 10 (which due to the predefined variable <code>T</code> doesn't increase the length), thus making the output at least <span class="math-container">\$f_{\varepsilon_0}(3)\$</span>, absolutely dominating Graham's number and every other answer so far.</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/bforte/Functoid" rel="nofollow noreferrer">Functoid</a>, 14 bytes</h1>
<pre><code>B&quot;W(BiCA])9.Ef
</code></pre>
<p><a href="https://tio.run/##SyvNSy7Jz0z5/99JKVzDKdPZMVbTUs817f9/AA" rel="nofollow noreferrer" title="Functoid – Try It Online">Try it online!</a></p>
<p>The pointer wraps around whenever it moves out of the source code, this happens once here, making the code equivalent to <code>B&quot;W(BiCA])9.EfB&quot;W(BiCA])9.Ef</code>. The string <code>&quot;W(BiCA])9.EfB&quot;</code> gets converted to base 10 and becomes <code>&quot;91772447243986&quot;</code>. Now we can rewrite the code as <code>BkW(BiCA])9.Ef</code>, where <code>k</code> represents that big number.</p>
<pre><code>BkW(BiCA])9         # set the current function to B k W (B i C A ]) 9
           .        # evaluate and print the current function as a number
            Ef      # terminate the program
            
</code></pre>
<p>Let <code>f_a</code> be a lambda function equivalent to <span class="math-container">\$f_a\$</span> in the <a href="https://en.wikipedia.org/wiki/Fast-growing_hierarchy" rel="nofollow noreferrer">fast growing hierarchy</a>. To increase the index by 1, the function needs to be applied to itself <code>n</code> times <span class="math-container">\$f_a^n(n) = f_{a+1}(n)\$</span>. In code this would be <code>f_(a+1) n = n f_a n = C A f_a n</code>. To get any finite index we just need to apply <code>C A</code> a lot of times to <code>f_0 = ]</code>:</p>
<pre><code>f_0 = ]
f_1 = C A ]
f_2 = C A (C A ])
f_3 = C A (C A (C A ]))
...
</code></pre>
<p><span class="math-container">\$f_\omega(n) = f_n(n)\$</span> = <code>n (C A) ] n = W (i (C A) ]) n</code></p>
<p>The expression <code>B k W (B i C A ]) 9</code> can be reduced to <code>k (W (i (C A) ])) 9 = k f_ω 9</code> and this returns <span class="math-container">\$f_\omega^{91772447243986}(9)\$</span>.</p>
</div>
<div id="pu5" class="pu"><h1>Ruby, 60 bytes</h1>
<pre><code>f=-&gt;n{n.times{eval(&quot;n.times{&quot;*n+&quot;n+=1&quot;+&quot;}&quot;*n)};n};f.call(64)
</code></pre>
<p>This is <span class="math-container">\$f_{\omega+1}(64)\$</span>, exactly, which is slightly bigger than Graham's number :) I copied this from Simply Beautiful Art on their Bignum Bakeoff post.</p>
</div>
<div id="pu6" class="pu"><h1>Python 3, <s>174</s> <s>171</s> <s>168</s> <s>148</s> <s>125</s> <s>117</s> <s>116</s> <s>112</s> 101 bytes</h1>
<p>3^^^...^3 with Graham's number arrows i.e. G(65) (boring, I know)</p>
<pre class="lang-python prettyprint-override"><code>a=lambda b,c:3if b&lt;2else(a(a(b-1,c),c-1)if c else 3*b)
G=lambda k:a(3,G(k-1))if k else 4
print(G(65))
</code></pre>
<p>Pretty human-readable. a implements arrow notation, G is Graham's sequence.</p>
<h2>Improvements</h2>
<ul>
<li>Replaced G(64)+1 with G(65), saving two bytes</li>
<li>Replaced <code>if c==1:return a**b</code> with <code>if c==0:return a*b</code>, saving one byte</li>
<li>Renamed ar function to a and renamed variable a to k, saving three bytes</li>
<li>Turned G function from a proper function into a lambda, saving twenty bytes, believe it or not!</li>
<li>Turned a function from a proper function also into a lambda, saving twenty-three bytes!</li>
<li>Removed k from a function since we will only be using it with base 3, saving eight bytes.</li>
<li>Removed an unnecessary space</li>
<li>Removed some more unnecessary spaces, saving four bytes</li>
<li>Shortened definitions of a and G, saving eleven bytes</li>
</ul>
</div>
<div id="pu7" class="pu"><h1>Binary Lambda Calculus, 78 bits = 9.75 bytes</h1>
<p>Here is an expression in Binary Lambda Calculus that is less than 10 bytes, yet surpasses Graham's Number. This is over 5x shorter than my <a href="https://codegolf.stackexchange.com/questions/6430/post/219469">previous post</a> in JavaScript. Since <a href="https://esolangs.org/wiki/Binary_lambda_calculus" rel="noreferrer">Binary Lambda Calculus</a> is radically different than JavaScript, I decided to answer this in a separate post.</p>
<pre><code>010101000001110011101000000101011000000101101101011010000110100000011100111010
</code></pre>
<p>You can find some interpreters <a href="https://tromp.github.io/cl/cl.html" rel="noreferrer">here</a>.</p>
<h2><strong><a href="https://codegolf.stackexchange.com/questions/31695/post/219649">Explanation I made on another post</a></strong></h2>
<p>Essentially, this binary expression encodes this lambda calculus expression:</p>
<pre><code>(\f x.f (f x))(\f n.n (\g m.m g m) f n)(\x.x x)(\f x.f (f x))
</code></pre>
<p>The decodings can be described like this:</p>
<ul>
<li><code>(\f x.f (f x))</code> at the start and at the end corresponds to the Church Numeral <span class="math-container">\$2\$</span>.</li>
<li><code>(\f n.n (\g m.m g m) f n)</code> takes in a function <span class="math-container">\$f\$</span> and a number <span class="math-container">\$n\$</span>, and returns <span class="math-container">\$f_n (n)\$</span> where <span class="math-container">\$f_0 (n) = f(n)\$</span> and <span class="math-container">\$f_{m+1} (n) = f_m^n (n)\$</span> using functional recursion. Let's call this function <span class="math-container">\$S\$</span>.</li>
<li><code>(\x.x x)</code> corresponds to the function that raises a number to the power of itself, or <span class="math-container">\$f(x)=x^x\$</span>.</li>
</ul>
<p>Since Church Numerals naturally nest the function that they apply to, the lambda calculus string gets reduced as follows:
<span class="math-container">$$2Sf2 \rightarrow S(Sf)2$$</span>
Since each <span class="math-container">\$S\$</span> adds <span class="math-container">\$\omega\$</span> to the growth rate of the function, and the <span class="math-container">\$f(x)=x^x\$</span> has growth rate <span class="math-container">\$f_2\$</span> in the Fast Growing Hierarchy, then <span class="math-container">\$(Sf)\$</span> has growth rate <span class="math-container">\$f_{\omega}\$</span>, and <span class="math-container">\$S(Sf) = 2Sf\$</span> has growth rate <span class="math-container">\$f_{\omega2}\$</span>.</p>
<p>This means the expression <span class="math-container">\$2Sf2\$</span> described above has the value of about <span class="math-container">\$f_{\omega2} (2)\$</span> in the Fast-growing Hierarchy. This is greater than Graham's Number.</p>
<p>Therefore, Graham's Number can be beaten by a program that less than 10 bytes!</p>
</div>
<div id="pu8" class="pu"><h1>Javascript, 50 Bytes, <span class="math-container">\$f_{\omega+8} (9)\$</span></h1>
<pre><code>n=(y,x=9)=&gt;y?y-9?n(y-1,x?n(y,x-1)*9:9):x:n(x);n(8)
</code></pre>
<p>Here, n is a binary function. The function is defined as followed:</p>
<ul>
<li><code>n(9,x) = x</code></li>
<li><code>n(y,0) = n(y-1,9)</code></li>
<li><code>n(y,x) = n(y-1,n(y,x-1)*9)</code></li>
</ul>
<p>The <code>*9</code> ensures that <code>n(y,x)</code> is an increasing function with respect to x.</p>
<ul>
<li><code>n(9,x)</code> = x</li>
<li><code>n(10,x)</code> = 9^(x+1)</li>
<li><code>n(11,x)</code> ~ 9^^x</li>
<li><code>n(12,x)</code> ~ 9^^^x</li>
<li><code>n(y+1,x)</code> recurses over <code>n(y,x)</code> with respect to x.</li>
</ul>
<p>We also defined n(y)=n(y,9), so n(y) grows as fast as  <span class="math-container">\$f_{\omega}\$</span>  in the Fast Growing Hierarchy.</p>
<p>Now here is the twist:</p>
<ul>
<li><code>n(0,x)=n(x)=n(x,9)</code></li>
</ul>
<p>This starts an entirely new hierarchy starting from <code>y=0</code> all the way up to <code>y=8</code>.</p>
<ul>
<li><code>n(0,x)</code> grows at <span class="math-container">\$f_{\omega}\$</span> in the FGH</li>
<li><code>n(1,x)</code> grows at <span class="math-container">\$f_{\omega+1} = G\$</span></li>
<li><code>n(2,x)</code> grows at <span class="math-container">\$f_{\omega+2}\$</span></li>
<li>...</li>
<li><code>n(8,x)</code> grows at <span class="math-container">\$f_{\omega+8}\$</span></li>
</ul>
<p>Therefore, <code>n(8)</code> ~ <span class="math-container">\$f_{\omega+8} (9) &gt; G_{64}\$</span></p>
</div>
<div id="pu9" class="pu"><h1><a href="http://www.golfscript.com/golfscript/" rel="nofollow noreferrer">GolfScript</a>, <s>24</s> <s>20</s> 18 bytes</h1>
<pre><code>&quot;`'1$,*~'+&quot;{.~~})*
</code></pre>
<p><a href="https://tio.run/##S8/PSStOLsosKPn/XylB3VBFR6tOXVupWq@urlZT6/9/AA" rel="nofollow noreferrer" title="GolfScript – Try It Online">Try it online!</a></p>
<pre><code>&quot;`'1$,*~'+&quot;         # Push this string
           {.~~})*  # Becomes {.~}126* and this duplicates and executes the string 126 times
</code></pre>
<p>When executed, this string modifies the string at the top of the stack:</p>
<pre><code> `          # Parse it to a string inside the string  'foo'  -&gt; '&quot;foo&quot;'
  '1$,*~'+  # Add '1$,*~' at the end                  '&quot;foo&quot;' -&gt; '&quot;foo&quot;1$,*~'
</code></pre>
<p>When we execute this new string it does whatever <code>foo</code> used to do, but many times.</p>
<pre><code>     1$,     # Get the number of bytes of the string at the top of the stack
&quot;foo&quot;   *    # Make that many copies of foo
         ~   # Execute all of them
</code></pre>
<p>We will be dealing with only one string, that will modify itself 126 times. Let <code>L</code> be the number of loops and <code>B</code> the number of bytes the string has. These values can be calculated with <span class="math-container">\$B=2^{L+1}+3L+7\$</span>, but for simplicity's sake we will round <code>B</code> down to <code>L</code>. The number of bytes grows exponentially because every time a loop is added, every <code>&quot;</code> becomes <code>\&quot;</code> and every <code>\</code> becomes <code>\\</code>. Now the loops execute <code>L</code> times instead of <code>B</code>. When the string has no loops it just adds <code>&quot;</code> <code>&quot;1$,*~</code> around itself, in other words <code>L = L + 1</code>. With <code>a</code> loops it executes <code>L</code> times the version with <code>a-1</code> loops. This is exactly the same definition of <code>f</code> in the <a href="https://en.wikipedia.org/wiki/Fast-growing_hierarchy" rel="nofollow noreferrer">fast growing hierarchy</a> for when <code>a</code> is a successor:</p>
<p><span class="math-container">$$f_0(L)=L+1$$</span>
<span class="math-container">$$f_a(L)=f_{a-1}^L(L)$$</span></p>
<p>Before each execution <code>a</code> and <code>L</code> are the same number, so every time we execute the string, <code>L</code> becomes <span class="math-container">\$f_\omega(L)\$</span>.</p>
<p>We execute it 126 times starting with <code>L = 0</code>, so the number of bytes in the output will be:</p>
<p><span class="math-container">$$f_\omega^{126}(0)=f_\omega^{122}(f_8(8))&gt;f_\omega^{122}(122)=f_{\omega+1}(122)$$</span></p>
</div>
<div id="pu10" class="pu"><h2>Ruby, <s>54</s> <s>52</s> 50 bytes</h2>

<pre><code>f=-&gt;b{a*=a;eval"f[b-1];"*b*a};eval"f[a];"*a=99;p a
</code></pre>

<hr>

<h2>Ruby, <s>85</s> <s>81</s> <s>76</s> <s>71</s> <s>68</s> <s>64</s> <s>63</s> <s>59</s> 57 bytes</h2>

<pre><code>f=-&gt;a,b=-a{eval"a*=b&lt;0?f[a,a]:b&lt;1?a:f[a,b-1];"*a};p f[99]
</code></pre>

<p>Pretty much fast growing hierarchy with f(a+1) > f<sub>ω+1</sub>(a).</p>

<hr>

<h2>Ruby, 61 bytes</h2>

<pre><code>f=-&gt;a,b=-a{a&lt;0?9:b==0?a*a:f[f[a-1,b],b&gt;0?b-1:f[a,b+1]]};f[99]
</code></pre>

<p>Basically an Ackermann function with a twist.</p>

<hr>

<h2>Ruby, <s>63</s> 59 bytes</h2>

<pre><code>n=99;(H=-&gt;a{b,*c=a;n.times{b ?H[[b-1]*n*b+c]:n+=n}})[n];p n
</code></pre>

<hr>

<h2>Another Ruby, <s>74</s> 71 bytes</h2>

<pre><code>def f(a,b=a)a&lt;0?b:b&lt;0?f(a-1):f(a-1,f(a,b-1))end;n=99;n.times{n=f n};p n
</code></pre>

<p>Basically Ackermann function to itself 99 times.</p>
</div>
<div id="pu11" class="pu"><h1>JavaScript, 68 bytes, however uncompeting for using ES6</h1>

<pre><code>a=(x,y)=&gt;y?x?a(a(x-1,y)*9,y-1):a(9,y-1):x;b=x=&gt;x?a(9,b(x-1)):9;b(99)
</code></pre>

<p><code>a</code> function is similar to up-arrow notation with base 9.</p>

<pre><code>       /a(a(x-1,y)*9,y-1)  x&gt;0, y&gt;0
a(x,y)=|a(9,y-1)           x=0, y&gt;0
       \x                  y=0
</code></pre>

<p><code>b</code> function is: b(x)=b<sup>x</sup>(9).</p>

<p><code>b(99)</code> is ~f<sub>ω+1</sub>(99), compared to Graham's number&lt;f<sub>ω+1</sub>(64).</p>
</div>
<div id="pu12" class="pu"><h1><a href="https://github.com/isaacg1/pyth" rel="noreferrer">Pyth</a>, <s>29</s> 28 bytes</h1>

<pre><code>M?*GHgtGtgGtH^ThH=ZTV99=gZTZ
</code></pre>

<p>Defines a lambda for hyper-operation and recursively calls it. Like the definition for Graham's number, but with larger values.</p>

<p>This:</p>

<pre><code>M?*GHgtGtgGtH^3hH
</code></pre>

<p>Defines a lambda, roughly equal to the python</p>

<pre><code>g = lambda G, H:
  g(G-1, g(G, H-1)-1) if G*H else 3^(H+1)
</code></pre>

<p>This gives the hyper-operation function, g(G,H) = 3↑<sup>G+1</sup>(H+1).<br>
So, for example, g(1,2)=3↑<sup>2</sup>3 = 7,625,597,484,987, <a href="https://tio.run/##K6gsyfj/39dey90jvcS9JN29xCPOOMMj3VDB6P9/AA" rel="noreferrer" title="Pyth – Try It Online">which you can test here</a>.</p>

<p><code>V&lt;x&gt;&lt;y&gt;</code> starts a loop that executes the body, <code>y</code>, <code>x</code> times.<br>
<code>=gZT</code> is the body of the loop here, which is equivalent to <code>Z=g(Z,10)</code></p>

<p>The code:</p>

<pre><code>M?*GHgtGtgGtH^3hH=Z3V64=gZ2)Z
</code></pre>

<p>Should recursively call the hyperoperation above 64 times, giving Graham's Number.</p>

<p>In my answer, however, I've replaced the single digits with <code>T</code>, which is initialized to 10, and increased the depth of recursion to 99. Using <a href="http://googology.wikia.com/wiki/Graham_Array_Notation" rel="noreferrer">Graham Array Notation</a>, Graham's Number is [3,3,4,64], and my program outputs the larger [10,11,11,99]. I've also removed the <code>)</code> that closes the loop to save one byte, so it prints each successive value in the 99 iterations.</p>
</div>
<div id="pu13" class="pu"><h1>Javascript, 83 bytes</h1>

<p>Another Ackermann function solution.</p>

<pre><code>(function a(m,n,x){return x?a(a(m,n,x-1),n,0):(m?a(m-1,n?a(m,n-1):1):n+1)})(9,9,99)
</code></pre>
</div>
<div id="pu14" class="pu"><h2>GolfScript (<strike>49</strike> 47 chars)</h2>

<pre><code>4.,{\):i\.0={.0+.({&lt;}+??\((\+.@&lt;i*\+}{(;}if.}do
</code></pre>

<p>See <a href="https://codegolf.stackexchange.com/a/18931/194">Lifetime of a worm</a> for lots of explanation. In short, this prints a number greater than f<sub>ω<sup>ω</sup></sub>(2).</p>
</div>
<div id="pu15" class="pu"><p><strong>Python: 85</strong></p>

<pre><code>f=lambda a,a:a*a
exec'f=lambda a,b,f=f:reduce(f,[a]*b,1)'*99
exec'f('*64+'3'+',3)'*64
</code></pre>

<p>Which maybe could be shortened to <em>74 + <code>length(X)</code></em>:</p>

<pre><code>f=lambda a,a:a*a
exec'f=lambda a,b,f=f:reduce(f,[a]*b,1)'*int('9'*X)
f(3,3)
</code></pre>

<p>Where <code>X</code> is an appropriate big number such that the resultant hyperoperation on <code>3, 3</code> is bigger than Grahams number(if this number is less than <code>99999999999</code> then some byte is saved).</p>

<hr>

<p>Note: I assume the python code is executed on the interactive interpreter hence the result is printed to stdout, otherwise add <code>9</code> bytes to each solution for the call to <code>print</code>.</p>
</div>
<div id="pu16" class="pu"><h2>Haskell, <sub><del>59</del> <del>57</del> <del>55</del></sub> 63</h2>

<pre><code>(f%s)1=s;(f%s)n=f.(f%s)$n-1
main=print$((flip((%3)%(3^))3)%4)66
</code></pre>

<p>How it works: <code>%</code> simply takes a function and composes it <code>n-1</code> times on top of <code>s</code>; i.e. <code>%3</code> takes a function <code>f</code> and returns a function of <code>n</code> that equals applying it <code>f</code> to 3, <code>n-1</code> times in a row. If we iterate the application of this higher-order function, we get a fast-growing sequence of functions – starting with exponentiation, it's exactly the sequence of Knuth-arrow-forest sizes:
<br><code>((%3)%(3^))1 n = (3^)n     = 3ⁿ = 3↑n</code>
<br><code>((%3)%(3^))2 n = ((3^)%3)n = (3↑)ⁿ⁻¹ $ 3  = 3↑↑n</code>
<br><code>((%3)%(3^))3 n = (((3^)%3)%3)n = (3↑↑)ⁿ⁻¹ $ 3  = 3↑↑↑n</code>
<br> and so on. <code>((%3)%(3^))n 3</code> is <code>3 ↑ⁿ 3</code>, which is what appears in the calculation to Graham's number. All that's left to do is composing the function <code>(\n -&gt; 3 ↑ⁿ 3) ≡ flip((%3)%(3^))3</code> more than 64 times, on top of 4 (the number of arrows the calculation starts with), to get a number larger than Graham's number. It's obvious that the logarithm (what a lamely slow function that is!) of <code>g₆₅</code> is still larger than <code>g₆₄=G</code>, so if we print that number the output length exceeds <code>G</code>.</p>

<p>⬛</p>
</div>
<div id="pu17" class="pu"><h2>Python (111+n), n=length(x)</h2>

<p>Although this one is not as short as the answerer's Ruby program, I'll post it anyway, to rule this possibility out.</p>

<p>It uses the Ackermann function, and calls the Ackermann function with m and n being the values from another call to the Ackermann function, and recurses 1000 times.</p>

<p>This is <b>probably</b> bigger than Graham's number, but I'm not sure, because nobody knows the exact length of it. It can be easily extended, if it's not bigger.</p>

<pre><code>x=999
b='A('*x+'5,5'+')'*x
def A(m,n):n+1 if m==0 else A(m-1,A(m,n-1)if n&gt;0 else 1)
exec('print A('%s,%s')'%(b,b))
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/6430/">6430</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




