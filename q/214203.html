<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::214203</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>013</td><td>C++ GCC</td><td>251003T124500Z</td><td><a href="https://codegolf.stackexchange.com/questions/214203/gluing-tetrahedra-together/283991#283991">Deadcode</a></td></tr>
<tr d-ix="1"><td>011</td><td>Rust</td><td>201108T231337Z</td><td><a href="https://codegolf.stackexchange.com/questions/214203/gluing-tetrahedra-together/214928#214928">wastl</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C++ (GCC)</a>, 13+ terms</h1>
<pre class="lang-cpp prettyprint-override"><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;cstdint&gt;
#include &lt;cinttypes&gt;
#include &lt;array&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;functional&gt;
#include &lt;unordered_set&gt;
#include &lt;chrono&gt;

//#define USE_GMP
//#define DEBUG_PRINT

#ifdef USE_GMP
#include &lt;gmp.h&gt;
#   if GMP_NUMB_BITS != 64
#   error This is hard-coded for 64-bit limbs
#   endif
#endif

typedef __int128 Coord;
typedef std::array&lt;Coord, 3&gt; Coord3;
typedef std::array&lt;Coord3, 4&gt; Tetrahedron;
class Tet
{
    void initFaces()
    {
        faceAttached[0] = false; // t[0],t[1],t[2]
        faceAttached[1] = false; // t[0],t[1],t[3]
        faceAttached[2] = false; // t[0],t[2],t[3]
        faceAttached[3] = false; // t[1],t[2],t[3]
    }
public:
    Tetrahedron t;
    bool faceAttached[4];
    Tet(                    ) : t( ) {initFaces();}
    Tet(const Tetrahedron &amp;t) : t(t) {initFaces();}
};
typedef std::vector&lt;Tet&gt; Polytet;

// vertex indices of faces with identical chirality
static int tetrahedronFaces[4][4] =
{
    {0, 1, 2, 3},
    {0, 3, 1, 2},
    {0, 2, 3, 1},
    {1, 3, 2, 0},
};

Coord3 operator-(const Coord3 &amp;a)
{
    Coord3 c;
    c[0] = -a[0];
    c[1] = -a[1];
    c[2] = -a[2];
    return c;
}
Coord3 operator+(const Coord3 &amp;a, const Coord3 &amp;b)
{
    Coord3 c;
    c[0] = a[0] + b[0];
    c[1] = a[1] + b[1];
    c[2] = a[2] + b[2];
    return c;
}
Coord3 operator-(const Coord3 &amp;a, const Coord3 &amp;b)
{
    Coord3 c;
    c[0] = a[0] - b[0];
    c[1] = a[1] - b[1];
    c[2] = a[2] - b[2];
    return c;
}
Coord3 operator*(const Coord3 &amp;a, const Coord b)
{
    Coord3 c;
    c[0] = a[0] * b;
    c[1] = a[1] * b;
    c[2] = a[2] * b;
    return c;
}
Coord3 cross(const Coord3 a, const Coord3 b)
{
    Coord3 c;
    c[0] = a[1]*b[2] - a[2]*b[1];
    c[1] = a[2]*b[0] - a[0]*b[2];
    c[2] = a[0]*b[1] - a[1]*b[0];
    return c;
}
Coord dot(const Coord3 &amp;a, const Coord3 &amp;b)
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}
bool volumesOverlap(const Tetrahedron &amp;a, const Tetrahedron &amp;b)
{
    // Take advantage of the fact that the two tetrahedrons are regular and congruent, and
    // just check if any edge of tetrahedron "a" intersects with any face of tetrahedron "b".
    // Don't count it if only the endpoint of an edge intersects.
    static int edges[6][2] =
    {
        {0, 1},
        {1, 2},
        {2, 0},
        {0, 3},
        {1, 3},
        {2, 3},
    };
    for (int edgeNum=0; edgeNum&lt;6; edgeNum++)
    {
        Coord3 p0 = a[edges[edgeNum][0]];
        Coord3 p1 = a[edges[edgeNum][1]];
        for (int faceNum=0; faceNum&lt;4; faceNum++)
        {
            Tetrahedron normalizedTetrahedron; // first 3 points are the face, and the 4th point is for calculating the normal
            for (int i=0; i&lt;4; i++)
                normalizedTetrahedron[i] = b[tetrahedronFaces[faceNum][i]];
            Coord3 center = {{0, 0, 0}}; // multiplied by 3 compared to original coordinates
            // Get center of face by averaging its vertices' coordinates; the
            // division by 3 is implied by omitting the multiplication by 3.
            for (int p=0; p&lt;3; p++)
                for (int d=0; d&lt;3; d++)
                    center[d] += normalizedTetrahedron[p][d];
            Coord3 normal;
            for (int d=0; d&lt;3; d++)
                normal[d] = normalizedTetrahedron[3][d] * 3 - center[d];
            Coord intersectNumerator   = dot(normal, normalizedTetrahedron[0] - p0);
            Coord intersectDenominator = dot(normal,                       p1 - p0);
            if (intersectDenominator == 0)
                continue; // edge is parallel to face, which we don't count as an overlap
            if (intersectDenominator &lt; 0)
            {
                intersectNumerator   = -intersectNumerator;
                intersectDenominator = -intersectDenominator;
            }
            if (intersectNumerator &lt;= 0 || intersectNumerator &gt;= intersectDenominator)
                continue;
            // These coordinates are all multiplied by intersectDenominator
            Coord3 intersectionPoint = p0 * intersectDenominator + (p1 - p0) * intersectNumerator;
            Coord3 triangle[3];
            for (int i=0; i&lt;3; i++)
                triangle[i] = normalizedTetrahedron[i] * intersectDenominator;
            // Check if the intersection point is inside the triangle
            Coord3 d = intersectionPoint - triangle[0];
            Coord3 edge1 = triangle[1] - triangle[0];
            Coord3 edge2 = triangle[2] - triangle[0];
            Coord uNumerator = d[1]*edge2[0] - d[0]*edge2[1];
            Coord vNumerator = d[0]*edge1[1] - d[1]*edge1[0];
            Coord uvDenominator = edge1[1]*edge2[0] - edge1[0]*edge2[1];
            if (uvDenominator == 0)
                continue;
            if (uvDenominator &lt; 0)
            {
                uNumerator = -uNumerator;
                vNumerator = -vNumerator;
                uvDenominator = -uvDenominator;
            }
            if (uNumerator &lt;= 0 || vNumerator &lt;= 0)
                continue;
            if (uNumerator + vNumerator &lt; uvDenominator)
                return true;
        }
    }
    return false;
}

class NormalizedPolytet : public std::vector&lt;Tetrahedron&gt;
{
public:
    NormalizedPolytet(const Polytet &amp;polytet)
    {
        reserve(polytet.size());
        for (auto tet=polytet.cbegin(); tet!=polytet.cend(); ++tet)
        {
            Tetrahedron &amp;t = emplace_back(tet-&gt;t);
            std::sort(t.begin(), t.end());
        }
        std::sort(this-&gt;begin(), this-&gt;end());
    }
};

bool operator&lt;(const Polytet &amp;_a, const Polytet &amp;_b)
// implicitly assume a.size()==b.size()
{
    NormalizedPolytet a(_a), b(_b);
    for (auto ta=a.cbegin(), tb=b.cbegin(); ta!=a.cend(); ++ta,++tb)
    {
        auto result = *ta &lt;=&gt; *tb;
        if (result != 0)
            return result &lt; 0;
    }
    return false;
}
bool operator&gt;(const Polytet &amp;a, const Polytet &amp;b)
{
    return !(a &lt; b);
}
bool operator==(const Polytet &amp;_a, const Polytet &amp;_b)
// implicitly assume a.size()==b.size()
{
    NormalizedPolytet a(_a), b(_b);
    for (auto ta=a.cbegin(), tb=b.cbegin(); ta!=a.cend(); ++ta,++tb)
    {
        auto result = *ta &lt;=&gt; *tb;
        if (result != 0)
            return false;
    }
    return true;
}

namespace std
{
    template&lt;&gt;
    struct hash&lt;Polytet&gt;
    {
        std::size_t operator()(const Polytet &amp;_polytet) const noexcept
        {
            NormalizedPolytet polytet(_polytet);
            std::size_t seed = polytet.size();
            for (auto t=polytet.cbegin(); t!=polytet.cend(); ++t)
            {
                for (auto c=t-&gt;cbegin(); c!=t-&gt;cend(); ++c)
                {
                    for (auto i=c-&gt;cbegin(); i!=c-&gt;cend(); ++i)
                    {
                        seed ^= std::hash&lt;uint64_t&gt;{}((uint64_t)(*i      )) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2);
                        seed ^= std::hash&lt;uint64_t&gt;{}((uint64_t)(*i &gt;&gt; 64)) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2);
                    }
                }
            }
            return seed;
        }
    };
};

#ifdef USE_GMP
void mpz_set_int128(mpz_t &amp;dst, const __int128 &amp;src)
{
    __int128 abssrc = src &lt; 0 ? -src : src;
    mpz_import(dst, 2, -1, 4, 0, 0, &amp;abssrc);
    if (src &lt; 0)
        mpz_neg(dst, dst);
}
void mpz_get_int128(__int128 &amp;dst, const mpz_t &amp;src)
{
    dst = 0;
    size_t count;
    uint64_t limbs[2];

    mpz_export(limbs, &amp;count, -1, sizeof(uint64_t), 0, 0, src);

    ((int64_t*)&amp;dst)[0] = limbs[0];
    if (count &gt; 1)
        ((int64_t*)&amp;dst)[1] = limbs[1];

    if (mpz_sgn(src) &lt; 0)
        dst = -dst;
}
#endif

int main(int argc, char *argv[])
{
    auto startTime = std::chrono::steady_clock::now();

    static const Tetrahedron start =
    {{
        {{-1,-1,-1}},
        {{-1, 1, 1}},
        {{ 1,-1, 1}},
        {{ 1, 1,-1}}
    }};
    Polytet startPolytet;
    startPolytet.emplace_back(start);

#ifdef USE_GMP
    mpz_t power3, power9_2;
    mpz_init(power3  ); mpz_set_ui(power3  , 1);
    mpz_init(power9_2); mpz_set_ui(power9_2, 2);
    mpz_t
        x , y , z ,
        x0, y0, z0,
        x1, y1, z1,
        x2, y2, z2,
        x3, y3, z3,
        xx_numerator_mpz, xx_denominator_mpz,
        xy_numerator_mpz, xy_denominator_mpz,
        xz_numerator_mpz, xz_denominator_mpz,
        yx_numerator_mpz, yx_denominator_mpz,
        yy_numerator_mpz, yy_denominator_mpz,
        yz_numerator_mpz, yz_denominator_mpz,
        zx_numerator_mpz, zx_denominator_mpz,
        zy_numerator_mpz, zy_denominator_mpz,
        zz_numerator_mpz, zz_denominator_mpz;
    mpz_inits(
        x , y , z ,
        x0, y0, z0,
        x1, y1, z1,
        x2, y2, z2,
        x3, y3, z3,
        xx_numerator_mpz, xx_denominator_mpz,
        xy_numerator_mpz, xy_denominator_mpz,
        xz_numerator_mpz, xz_denominator_mpz,
        yx_numerator_mpz, yx_denominator_mpz,
        yy_numerator_mpz, yy_denominator_mpz,
        yz_numerator_mpz, yz_denominator_mpz,
        zx_numerator_mpz, zx_denominator_mpz,
        zy_numerator_mpz, zy_denominator_mpz,
        zz_numerator_mpz, zz_denominator_mpz, NULL);
#else
    Coord power3   = 1;
    Coord power9_2 = 2;
#endif
    auto *polytets = new std::unordered_set&lt;Polytet&gt;;
    polytets-&gt;insert(startPolytet);
    size_t prevPolytetCount = 0;
    for (int tetCount=1;;)
    {
        auto currentTime = std::chrono::steady_clock::now();
        size_t polytetCount = polytets-&gt;size();
        std::cout &lt;&lt; tetCount &lt;&lt; ": " &lt;&lt; polytetCount &lt;&lt; " [" &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(currentTime - startTime).count() &lt;&lt; " ms]" &lt;&lt; std::endl;
        if (prevPolytetCount &gt; polytetCount)
        {
            std::cerr &lt;&lt; "Quit due to apparent overflow" &lt;&lt; std::endl;
            break;
        }
        prevPolytetCount = polytetCount;
        ++tetCount;
#ifdef DEBUG_PRINT
        if (tetCount > 6)
            break;
#endif
#ifdef USE_GMP
        mpz_mul_ui(power3  , power3  , 3);
        mpz_mul_ui(power9_2, power9_2, 9);
#else
        power3   *= 3;
        power9_2 *= 9;
#endif
        auto *newPolytets = new std::unordered_set&lt;Polytet&gt;;
        for (auto basePolytet=polytets-&gt;cbegin(); basePolytet!=polytets-&gt;cend(); ++basePolytet)
        {
            for (auto tetToAttachTo=basePolytet-&gt;cbegin(); tetToAttachTo!=basePolytet-&gt;cend(); ++tetToAttachTo)
            {
                for (int faceNum=0; faceNum&lt;4; faceNum++)
                {
                    if (!tetToAttachTo-&gt;faceAttached[faceNum])
                    {
                        Polytet newPolytet;
                        newPolytet.reserve(tetCount);
                        Tet *tetCopyToAttachTo; // take note of this just for speed
                        for (auto tetToCopy=basePolytet-&gt;cbegin(); tetToCopy!=basePolytet-&gt;cend(); ++tetToCopy)
                        {
                            Tet &amp;t = newPolytet.emplace_back();
                            for (int p=0; p&lt;4; p++)
                            for (int d=0; d&lt;3; d++)
                                t.t[p][d] = tetToCopy-&gt;t[p][d] * 3;
                            memcpy(t.faceAttached, tetToCopy-&gt;faceAttached, sizeof(t.faceAttached));
                            if (tetToCopy == tetToAttachTo)
                            {
                                t.faceAttached[faceNum] = true;
                                tetCopyToAttachTo = &amp;t;
                            }
                        }
                        Coord3 newVertex = {{0, 0, 0}};
                        // Get center of face by averaging its vertices' coordinates; the
                        // division by 3 is implied by omitting the multiplication by 3.
                        for (int p=0; p&lt;4; p++)
                        {
                            if (p == 3 - faceNum)
                                continue;
                            for (int d=0; d&lt;3; d++)
                                newVertex[d] += tetToAttachTo-&gt;t[p][d];
                        }
                        for (int d=0; d&lt;3; d++)
                            newVertex[d] += newVertex[d] - tetToAttachTo-&gt;t[3 - faceNum][d] * 3;
                        // Add new tetrahedron
                        Tet &amp;t = newPolytet.emplace_back();
                        for (int p=0; p&lt;3; p++)
                        {
                            int p0 = p;
                            if (!(faceNum &amp; 1))
                                p0 ^=      (p  &lt;  2           ? 1 : 0); // swap first two vertices to preserve chirality
                            int p1  = p0 + (p0 &gt;= 3 - faceNum ? 1 : 0); // skip the opposite vertex
                            for (int d=0; d&lt;3; d++)
                                t.t[p][d] = tetToAttachTo-&gt;t[p1][d] * 3;
                        }
                        t.t[3] = newVertex;
                        t.faceAttached[0] = true;
                        t.faceAttached[1] = false;
                        t.faceAttached[2] = false;
                        t.faceAttached[3] = false;
                        // Check for overlap between this newly attached tetrahedron and the existing ones
                        for (auto tetCheckIntersection=newPolytet.cbegin(); tetCheckIntersection!=newPolytet.cend(); ++tetCheckIntersection)
                        {
                            if (&amp;*tetCheckIntersection == tetCopyToAttachTo)
                                continue; // skip this check for speed (it'll always be false anyway)
                            if (volumesOverlap(t.t, tetCheckIntersection-&gt;t))
                                goto discardThisNewPolytet;
                        }
                        // Canonicalize the rotation of this new polytet, so that it can be compared against others
                        bool haveRunningLeast = false;
                        Polytet runningLeastPolytet;
                        for (auto tetToRotateNormalize=newPolytet.cbegin(); tetToRotateNormalize!=newPolytet.cend(); ++tetToRotateNormalize)
                        {
                            // only rotate-normalize to tetrahedrons with exactly 1 attached face; every polytet is guaranteed to have some
                            int faceToRotateNormalize;
                            {
                                int attachCount = 0;
                                for (int i=0; i&lt;4; i++)
                                    if (tetToRotateNormalize-&gt;faceAttached[i])
                                    {
                                        faceToRotateNormalize = i;
                                        if (++attachCount &gt; 1)
                                            break;
                                    }
                                if (attachCount &gt; 1)
                                    continue;
                            }
                            Tetrahedron n;
                            for (int i=0; i&lt;4; i++)
                                n[i] = tetToRotateNormalize-&gt;t[tetrahedronFaces[faceToRotateNormalize][i]];
                            for (int faceRotation=0; faceRotation&lt;3; faceRotation++)
                            {
                                // Solve for an affine transformation that rotates and translates the polytet so that "tetToRotateNormalize" goes into the same position as the first face of the "start" tetrahedron
                                Coord xx_numerator =   ( n[2][1] - n[3][1])*(n[0][2] - n[1][2])  - (n[0][1] - n[1][1])*(n[2][2] - n[3][2]) ; Coord xx_denominator = (-(n[1][0]*n[2][1]*n[0][2]) + n[1][0]*n[3][1]*n[0][2] + n[0][0]*n[2][1]*n[1][2] - n[0][0]*n[3][1]*n[1][2] + n[1][0]*n[0][1]*n[2][2] - n[0][0]*n[1][1]*n[2][2] + n[0][0]*n[3][1]*n[2][2] - n[1][0]*n[3][1]*n[2][2] + n[3][0]*(-(n[1][1]*n[0][2]) + n[2][1]*n[0][2] + n[0][1]*n[1][2] - n[2][1]*n[1][2] - n[0][1]*n[2][2] + n[1][1]*n[2][2]) + (-(n[1][0]*n[0][1]) + n[0][0]*n[1][1] - n[0][0]*n[2][1] + n[1][0]*n[2][1])*n[3][2] + n[2][0]*(-(n[3][1]*n[0][2]) - n[0][1]*n[1][2] + n[3][1]*n[1][2] + n[1][1]*(n[0][2] - n[3][2]) + n[0][1]*n[3][2]));
                                Coord xy_numerator = (-((n[2][0] - n[3][0])*(n[0][2] - n[1][2])) + (n[0][0] - n[1][0])*(n[2][2] - n[3][2])); Coord xy_denominator = (-(n[1][0]*n[2][1]*n[0][2]) + n[1][0]*n[3][1]*n[0][2] + n[0][0]*n[2][1]*n[1][2] - n[0][0]*n[3][1]*n[1][2] + n[1][0]*n[0][1]*n[2][2] - n[0][0]*n[1][1]*n[2][2] + n[0][0]*n[3][1]*n[2][2] - n[1][0]*n[3][1]*n[2][2] + n[3][0]*(-(n[1][1]*n[0][2]) + n[2][1]*n[0][2] + n[0][1]*n[1][2] - n[2][1]*n[1][2] - n[0][1]*n[2][2] + n[1][1]*n[2][2]) + (-(n[1][0]*n[0][1]) + n[0][0]*n[1][1] - n[0][0]*n[2][1] + n[1][0]*n[2][1])*n[3][2] + n[2][0]*(-(n[3][1]*n[0][2]) - n[0][1]*n[1][2] + n[3][1]*n[1][2] + n[1][1]*(n[0][2] - n[3][2]) + n[0][1]*n[3][2]));
                                Coord xz_numerator =   ( n[2][0] - n[3][0])*(n[0][1] - n[1][1])  - (n[0][0] - n[1][0])*(n[2][1] - n[3][1]) ; Coord xz_denominator = (-(n[1][0]*n[2][1]*n[0][2]) + n[1][0]*n[3][1]*n[0][2] + n[0][0]*n[2][1]*n[1][2] - n[0][0]*n[3][1]*n[1][2] + n[1][0]*n[0][1]*n[2][2] - n[0][0]*n[1][1]*n[2][2] + n[0][0]*n[3][1]*n[2][2] - n[1][0]*n[3][1]*n[2][2] + n[3][0]*(-(n[1][1]*n[0][2]) + n[2][1]*n[0][2] + n[0][1]*n[1][2] - n[2][1]*n[1][2] - n[0][1]*n[2][2] + n[1][1]*n[2][2]) + (-(n[1][0]*n[0][1]) + n[0][0]*n[1][1] - n[0][0]*n[2][1] + n[1][0]*n[2][1])*n[3][2] + n[2][0]*(-(n[3][1]*n[0][2]) - n[0][1]*n[1][2] + n[3][1]*n[1][2] + n[1][1]*(n[0][2] - n[3][2]) + n[0][1]*n[3][2]));
                                Coord yx_numerator =  -((n[1][1] - n[3][1])*(n[0][2] - n[2][2])) + (n[0][1] - n[2][1])*(n[1][2] - n[3][2]) ; Coord yx_denominator = (-(n[1][0]*n[2][1]*n[0][2]) + n[1][0]*n[3][1]*n[0][2] + n[0][0]*n[2][1]*n[1][2] - n[0][0]*n[3][1]*n[1][2] + n[1][0]*n[0][1]*n[2][2] - n[0][0]*n[1][1]*n[2][2] + n[0][0]*n[3][1]*n[2][2] - n[1][0]*n[3][1]*n[2][2] + n[3][0]*(-(n[1][1]*n[0][2]) + n[2][1]*n[0][2] + n[0][1]*n[1][2] - n[2][1]*n[1][2] - n[0][1]*n[2][2] + n[1][1]*n[2][2]) + (-(n[1][0]*n[0][1]) + n[0][0]*n[1][1] - n[0][0]*n[2][1] + n[1][0]*n[2][1])*n[3][2] + n[2][0]*(-(n[3][1]*n[0][2]) - n[0][1]*n[1][2] + n[3][1]*n[1][2] + n[1][1]*(n[0][2] - n[3][2]) + n[0][1]*n[3][2]));
                                Coord yy_numerator =   ( n[1][0] - n[3][0])*(n[0][2] - n[2][2])  - (n[0][0] - n[2][0])*(n[1][2] - n[3][2]) ; Coord yy_denominator = (-(n[1][0]*n[2][1]*n[0][2]) + n[1][0]*n[3][1]*n[0][2] + n[0][0]*n[2][1]*n[1][2] - n[0][0]*n[3][1]*n[1][2] + n[1][0]*n[0][1]*n[2][2] - n[0][0]*n[1][1]*n[2][2] + n[0][0]*n[3][1]*n[2][2] - n[1][0]*n[3][1]*n[2][2] + n[3][0]*(-(n[1][1]*n[0][2]) + n[2][1]*n[0][2] + n[0][1]*n[1][2] - n[2][1]*n[1][2] - n[0][1]*n[2][2] + n[1][1]*n[2][2]) + (-(n[1][0]*n[0][1]) + n[0][0]*n[1][1] - n[0][0]*n[2][1] + n[1][0]*n[2][1])*n[3][2] + n[2][0]*(-(n[3][1]*n[0][2]) - n[0][1]*n[1][2] + n[3][1]*n[1][2] + n[1][1]*(n[0][2] - n[3][2]) + n[0][1]*n[3][2]));
                                Coord yz_numerator =  -((n[1][0] - n[3][0])*(n[0][1] - n[2][1])) + (n[0][0] - n[2][0])*(n[1][1] - n[3][1]) ; Coord yz_denominator = (-(n[1][0]*n[2][1]*n[0][2]) + n[1][0]*n[3][1]*n[0][2] + n[0][0]*n[2][1]*n[1][2] - n[0][0]*n[3][1]*n[1][2] + n[1][0]*n[0][1]*n[2][2] - n[0][0]*n[1][1]*n[2][2] + n[0][0]*n[3][1]*n[2][2] - n[1][0]*n[3][1]*n[2][2] + n[3][0]*(-(n[1][1]*n[0][2]) + n[2][1]*n[0][2] + n[0][1]*n[1][2] - n[2][1]*n[1][2] - n[0][1]*n[2][2] + n[1][1]*n[2][2]) + (-(n[1][0]*n[0][1]) + n[0][0]*n[1][1] - n[0][0]*n[2][1] + n[1][0]*n[2][1])*n[3][2] + n[2][0]*(-(n[3][1]*n[0][2]) - n[0][1]*n[1][2] + n[3][1]*n[1][2] + n[1][1]*(n[0][2] - n[3][2]) + n[0][1]*n[3][2]));
                                Coord zx_numerator =  -((n[0][1] - n[3][1])*(n[1][2] - n[2][2])) + (n[1][1] - n[2][1])*(n[0][2] - n[3][2]) ; Coord zx_denominator = (-(n[1][0]*n[2][1]*n[0][2]) + n[1][0]*n[3][1]*n[0][2] + n[0][0]*n[2][1]*n[1][2] - n[0][0]*n[3][1]*n[1][2] + n[1][0]*n[0][1]*n[2][2] - n[0][0]*n[1][1]*n[2][2] + n[0][0]*n[3][1]*n[2][2] - n[1][0]*n[3][1]*n[2][2] + n[3][0]*(-(n[1][1]*n[0][2]) + n[2][1]*n[0][2] + n[0][1]*n[1][2] - n[2][1]*n[1][2] - n[0][1]*n[2][2] + n[1][1]*n[2][2]) + (-(n[1][0]*n[0][1]) + n[0][0]*n[1][1] - n[0][0]*n[2][1] + n[1][0]*n[2][1])*n[3][2] + n[2][0]*(-(n[3][1]*n[0][2]) - n[0][1]*n[1][2] + n[3][1]*n[1][2] + n[1][1]*(n[0][2] - n[3][2]) + n[0][1]*n[3][2]));
                                Coord zy_numerator =   ( n[0][0] - n[3][0])*(n[1][2] - n[2][2])  - (n[1][0] - n[2][0])*(n[0][2] - n[3][2]) ; Coord zy_denominator = (-(n[1][0]*n[2][1]*n[0][2]) + n[1][0]*n[3][1]*n[0][2] + n[0][0]*n[2][1]*n[1][2] - n[0][0]*n[3][1]*n[1][2] + n[1][0]*n[0][1]*n[2][2] - n[0][0]*n[1][1]*n[2][2] + n[0][0]*n[3][1]*n[2][2] - n[1][0]*n[3][1]*n[2][2] + n[3][0]*(-(n[1][1]*n[0][2]) + n[2][1]*n[0][2] + n[0][1]*n[1][2] - n[2][1]*n[1][2] - n[0][1]*n[2][2] + n[1][1]*n[2][2]) + (-(n[1][0]*n[0][1]) + n[0][0]*n[1][1] - n[0][0]*n[2][1] + n[1][0]*n[2][1])*n[3][2] + n[2][0]*(-(n[3][1]*n[0][2]) - n[0][1]*n[1][2] + n[3][1]*n[1][2] + n[1][1]*(n[0][2] - n[3][2]) + n[0][1]*n[3][2]));
                                Coord zz_numerator =   ( n[0][0] - n[3][0])*(n[1][1] - n[2][1])  - (n[1][0] - n[2][0])*(n[0][1] - n[3][1]) ; Coord zz_denominator = ( n[1][0]*n[2][1]*n[0][2] - n[1][0]*n[3][1]*n[0][2] - n[0][0]*n[2][1]*n[1][2] + n[0][0]*n[3][1]*n[1][2] - n[1][0]*n[0][1]*n[2][2] + n[0][0]*n[1][1]*n[2][2] - n[0][0]*n[3][1]*n[2][2] + n[1][0]*n[3][1]*n[2][2] + n[3][0]*(n[1][1]*n[0][2] - n[2][1]*n[0][2] - n[0][1]*n[1][2] + n[2][1]*n[1][2] + n[0][1]*n[2][2] - n[1][1]*n[2][2]) + n[1][0]*n[0][1]*n[3][2] - n[0][0]*n[1][1]*n[3][2] + n[0][0]*n[2][1]*n[3][2] - n[1][0]*n[2][1]*n[3][2] + n[2][0]*(n[3][1]*n[0][2] + n[0][1]*n[1][2] - n[3][1]*n[1][2] - n[0][1]*n[3][2] + n[1][1]*(-n[0][2] + n[3][2])));
                                Coord x0_ = ( n[1][0]*n[2][1]*n[0][2] - n[1][0]*n[3][1]*n[0][2] - n[0][0]*n[2][1]*n[1][2] + n[0][0]*n[3][1]*n[1][2] - n[1][0]*n[0][1]*n[2][2] + n[0][0]*n[1][1]*n[2][2] + n[0][0]*n[3][1]*n[2][2] - n[1][0]*n[3][1]*n[2][2] + n[3][0]*(n[2][1]*(n[0][2] - n[1][2]) + n[1][1]*(n[0][2] + n[2][2]) - n[0][1]*(n[1][2] + n[2][2])) + n[1][0]*(n[0][1] + n[2][1])*n[3][2] - n[0][0]*(n[1][1] + n[2][1])*n[3][2] + n[2][0]*(n[3][1]*(-n[0][2] + n[1][2]) - n[1][1]*(n[0][2] + n[3][2]) + n[0][1]*(n[1][2] + n[3][2])));
                                Coord y0_ = ( n[1][0]*n[2][1]*n[0][2] + n[1][0]*n[3][1]*n[0][2] - n[0][0]*n[2][1]*n[1][2] - n[0][0]*n[3][1]*n[1][2] - n[3][0]*((n[1][1] + n[2][1])*n[0][2] + (-n[0][1] + n[2][1])*n[1][2]) - n[1][0]*n[0][1]*n[2][2] + n[0][0]*n[1][1]*n[2][2] + n[3][0]*(n[0][1] + n[1][1])*n[2][2] - n[0][0]*n[3][1]*n[2][2] - n[1][0]*n[3][1]*n[2][2] + (-(n[1][0]*n[0][1]) + n[0][0]*n[1][1] + (n[0][0] + n[1][0])*n[2][1])*n[3][2] + n[2][0]*(n[3][1]*(n[0][2] + n[1][2]) + n[0][1]*(n[1][2] - n[3][2]) - n[1][1]*(n[0][2] + n[3][2])));
                                Coord z0_ = (-n[1][0]*n[2][1]*n[0][2] - n[1][0]*n[3][1]*n[0][2] + n[0][0]*n[2][1]*n[1][2] + n[0][0]*n[3][1]*n[1][2] - n[3][0]*n[2][1]*(n[0][2] + n[1][2]) + n[1][0]*n[0][1]*n[2][2] - n[0][0]*n[1][1]*n[2][2] - n[0][0]*n[3][1]*n[2][2] - n[1][0]*n[3][1]*n[2][2] + n[3][0]*n[1][1]*(n[0][2] + n[2][2]) + n[3][0]*n[0][1]*(-n[1][2] + n[2][2]) + n[1][0]*(n[0][1] + n[2][1])*n[3][2] + n[0][0]*(-n[1][1] + n[2][1])*n[3][2] + n[2][0]*(n[3][1]*(n[0][2] + n[1][2]) + n[1][1]*(n[0][2] - n[3][2]) - n[0][1]*(n[1][2] + n[3][2])));
#ifdef USE_GMP
                                mpz_set_int128(xx_numerator_mpz, xx_numerator); mpz_set_int128(xx_denominator_mpz, xx_denominator);
                                mpz_set_int128(xy_numerator_mpz, xy_numerator); mpz_set_int128(xy_denominator_mpz, xy_denominator);
                                mpz_set_int128(xz_numerator_mpz, xz_numerator); mpz_set_int128(xz_denominator_mpz, xz_denominator);
                                mpz_set_int128(yx_numerator_mpz, yx_numerator); mpz_set_int128(yx_denominator_mpz, yx_denominator);
                                mpz_set_int128(yy_numerator_mpz, yy_numerator); mpz_set_int128(yy_denominator_mpz, yy_denominator);
                                mpz_set_int128(yz_numerator_mpz, yz_numerator); mpz_set_int128(yz_denominator_mpz, yz_denominator);
                                mpz_set_int128(zx_numerator_mpz, zx_numerator); mpz_set_int128(zx_denominator_mpz, zx_denominator);
                                mpz_set_int128(zy_numerator_mpz, zy_numerator); mpz_set_int128(zy_denominator_mpz, zy_denominator);
                                mpz_set_int128(zz_numerator_mpz, zz_numerator); mpz_set_int128(zz_denominator_mpz, zz_denominator);
                                mpz_set_int128(x0, x0_);
                                mpz_set_int128(y0, y0_);
                                mpz_set_int128(z0, z0_);
#endif
                                // Apply the affine transformation to the polytet
                                Polytet newRotatedPolytet;
                                newRotatedPolytet.reserve(tetCount);
                                for (auto tetToRotate=newPolytet.cbegin(); tetToRotate!=newPolytet.cend(); ++tetToRotate)
                                {
                                    Tet &amp;nt = newRotatedPolytet.emplace_back();
                                    for (int vertexNum=0; vertexNum&lt;4; vertexNum++)
                                    {
#ifdef USE_GMP
                                        mpz_set_int128(x1, tetToRotate-&gt;t[vertexNum][0]);
                                        mpz_set_int128(y1, tetToRotate-&gt;t[vertexNum][1]);
                                        mpz_set_int128(z1, tetToRotate-&gt;t[vertexNum][2]);

                                        mpz_set(x, x0); mpz_mul(x, x, power3); mpz_div(x, x, zz_denominator_mpz);
                                        mpz_set(y, y0); mpz_mul(y, y, power3); mpz_div(y, y, zz_denominator_mpz);
                                        mpz_set(z, z0); mpz_mul(z, z, power3); mpz_div(z, z, zz_denominator_mpz);

                                        mpz_set(x2, x1); mpz_mul(x2, x2, xx_numerator_mpz); mpz_mul(x2, x2, power9_2); mpz_div(x2, x2, xx_denominator_mpz);
                                        mpz_set(x3, y1); mpz_mul(x3, x3, xy_numerator_mpz); mpz_mul(x3, x3, power9_2); mpz_div(x3, x3, xy_denominator_mpz); mpz_add(x2, x2, x3);
                                        mpz_set(x3, z1); mpz_mul(x3, x3, xz_numerator_mpz); mpz_mul(x3, x3, power9_2); mpz_div(x3, x3, xz_denominator_mpz); mpz_add(x2, x2, x3); mpz_div(x2, x2, power3); mpz_add(x, x, x2);
                                        mpz_set(y2, x1); mpz_mul(y2, y2, yx_numerator_mpz); mpz_mul(y2, y2, power9_2); mpz_div(y2, y2, yx_denominator_mpz);
                                        mpz_set(y3, y1); mpz_mul(y3, y3, yy_numerator_mpz); mpz_mul(y3, y3, power9_2); mpz_div(y3, y3, yy_denominator_mpz); mpz_add(y2, y2, y3);
                                        mpz_set(y3, z1); mpz_mul(y3, y3, yz_numerator_mpz); mpz_mul(y3, y3, power9_2); mpz_div(y3, y3, yz_denominator_mpz); mpz_add(y2, y2, y3); mpz_div(y2, y2, power3); mpz_add(y, y, y2);
                                        mpz_set(z2, x1); mpz_mul(z2, z2, zx_numerator_mpz); mpz_mul(z2, z2, power9_2); mpz_div(z2, z2, zx_denominator_mpz);
                                        mpz_set(z3, y1); mpz_mul(z3, z3, zy_numerator_mpz); mpz_mul(z3, z3, power9_2); mpz_div(z3, z3, zy_denominator_mpz); mpz_add(z2, z2, z3);
                                        mpz_set(z3, z1); mpz_mul(z3, z3, zz_numerator_mpz); mpz_mul(z3, z3, power9_2); mpz_div(z3, z3, zz_denominator_mpz); mpz_add(z2, z2, z3); mpz_div(z2, z2, power3); mpz_add(z, z, z2);

                                        mpz_get_int128(nt.t[vertexNum][0], x);
                                        mpz_get_int128(nt.t[vertexNum][1], y);
                                        mpz_get_int128(nt.t[vertexNum][2], z);

#else
                                        nt.t[vertexNum][0] = x0_*power3/zz_denominator + (tetToRotate-&gt;t[vertexNum][0]*xx_numerator*power9_2/xx_denominator + tetToRotate-&gt;t[vertexNum][1]*xy_numerator*power9_2/xy_denominator + tetToRotate-&gt;t[vertexNum][2]*xz_numerator*power9_2/xz_denominator)/power3;
                                        nt.t[vertexNum][1] = y0_*power3/zz_denominator + (tetToRotate-&gt;t[vertexNum][0]*yx_numerator*power9_2/yx_denominator + tetToRotate-&gt;t[vertexNum][1]*yy_numerator*power9_2/yy_denominator + tetToRotate-&gt;t[vertexNum][2]*yz_numerator*power9_2/yz_denominator)/power3;
                                        nt.t[vertexNum][2] = z0_*power3/zz_denominator + (tetToRotate-&gt;t[vertexNum][0]*zx_numerator*power9_2/zx_denominator + tetToRotate-&gt;t[vertexNum][1]*zy_numerator*power9_2/zy_denominator + tetToRotate-&gt;t[vertexNum][2]*zz_numerator*power9_2/zz_denominator)/power3;
#endif
                                    }
                                    memcpy(nt.faceAttached, tetToRotate-&gt;faceAttached, sizeof(nt.faceAttached));
                                }
                                // Update the running "least" rotation
                                if (!haveRunningLeast ||
                                    runningLeastPolytet &gt; newRotatedPolytet)
                                {
                                    haveRunningLeast = true;
                                    runningLeastPolytet = newRotatedPolytet;
                                }
                                // Switch to the next rotation of this face
                                Coord3 tmpFace = n[2];
                                n[2] = n[1];
                                n[1] = n[0];
                                n[0] = tmpFace;
                            }
                        }
                        newPolytets-&gt;insert(runningLeastPolytet);
                    }
                discardThisNewPolytet:;
                }
            }
        }
#ifdef DEBUG_PRINT
        for (auto thisPolytet=newPolytets-&gt;cbegin(); thisPolytet!=newPolytets-&gt;cend(); ++thisPolytet)
        {
            bool first = true;
            for (auto thisTet=thisPolytet-&gt;cbegin(); thisTet!=thisPolytet-&gt;cend(); ++thisTet)
            {
                printf(first ? "\n{" : ",\n");
                first = false;
                printf("{{%" PRId64 ", %" PRId64 ", %" PRId64 "}, {%" PRId64 ", %" PRId64 ", %" PRId64 "}, {%" PRId64 ", %" PRId64 ", %" PRId64 "}, {%" PRId64 ", %" PRId64 ", %" PRId64 "}}",
                    (int64_t)thisTet-&gt;t[0][0], (int64_t)thisTet-&gt;t[0][1], (int64_t)thisTet-&gt;t[0][2],
                    (int64_t)thisTet-&gt;t[1][0], (int64_t)thisTet-&gt;t[1][1], (int64_t)thisTet-&gt;t[1][2],
                    (int64_t)thisTet-&gt;t[2][0], (int64_t)thisTet-&gt;t[2][1], (int64_t)thisTet-&gt;t[2][2],
                    (int64_t)thisTet-&gt;t[3][0], (int64_t)thisTet-&gt;t[3][1], (int64_t)thisTet-&gt;t[3][2]);
            }
            printf("}\n");
        }
#endif
        delete polytets;
        polytets = newPolytets;
    }
    delete polytets;
#ifdef USE_GMP
    mpz_clears(
        x , y , z ,
        x1, y1, z1,
        x2, y2, z2,
        x3, y3, z3,
        xx_numerator_mpz, xx_denominator_mpz,
        xy_numerator_mpz, xy_denominator_mpz,
        xz_numerator_mpz, xz_denominator_mpz,
        yx_numerator_mpz, yx_denominator_mpz,
        yy_numerator_mpz, yy_denominator_mpz,
        yz_numerator_mpz, yz_denominator_mpz,
        zx_numerator_mpz, zx_denominator_mpz,
        zy_numerator_mpz, zy_denominator_mpz,
        zz_numerator_mpz, zz_denominator_mpz, NULL);
#endif
&#9;return 0;
}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=7V3NcuNIcj5bT1HihHtIilQToKJ3WxQ5sTOznpiI2d72jMaXXq0CBCAJbhJgAKAkUMMn8WUvvjjCNz-Nn8aZ9QPUL0iqFbbDFqIlAYmqzK-ysrKy_tD_8u_harEu8Of6Ngz_41NnWJTRNDw58UedQWf4Z79z9bd_XZc3w9__5-bfvkrScLGOYnIBiZLs9G521JCSrCjzOFjKNKAk6a2aLsS8aamQ4LmsVnEhE4M8DyqFsLjN8qS8UyTcx2GZ5TJlkRQK85t1GpZJlgYLmbpOszyK8zi6LmIVy12epdns6Ojt26-i-CZJY_LrL3-8_uFPHyXK93_89tcfrj_-_OOHyyPIewPkOlXD6na5okUnhCQ3BN5df_j1T99ef_vj5S_keErendFXcZ5nObm8SwoC_-6CPBqGWRRH5AbI786G86Qki2Q5L1jqNEpujr5if45QaSj7-ho06Pm_J99lUKxJTQdVn59TRV7QNwMynrE0Y3ei8YCczchlXObBXRyBNiZH4SIoCiQdPR0BCHKfJRFJ0qT8hyCMi26PEtkrvG6A-oeyDELI_2l0RaZAWRTxhLx9S0ogDMpPHv7yr-xZPHeWsSOLb83it2UZ61k8Pcv2aLWeL5LwnD5JGiHlhJLmWbZQmZ5dTUTiLrFcPXJO4E2PPEnqm2zrPGGWFqUi6k3J8pRGnq1Wh6wtXEDmGfmYLaoyBphgteQ-zsv4ESosSiAvyW4o5oI8QGsiSRSnZRIGCxLeJXmwSMrqqCgDIEGGkpQNFCoZSgj_yJRbwtNoQLwB8cGytoOaMmZEieIzoqB49BGII6BAOY6Y5ZFsFecBFGLIFcHJb4Iel8cJIdNyyKxrGMBfQfE4xaspPqf4nJLH5TpPkcdWl3uiyx0QlTBvBYI4yAmZ63AQDaVroBATpe8BzVDJM6ANHdCGDmjD_aD1W6GRPYD1ydxEJREbSDXRgifMs6JQseha2oXFu-rPWclRWl9Wiycw9OdMl4i83yioRjli-WgKj6V2QCZRVu5drTw3508NjfP32L0v0GyPqGO6zxbrZVz8GZr_IljZXEstTKHWEsF1XAafYxJE90FaBrcxuo7yLkb3AZ7hLijpU_mQyW6iIEEeA9rb9SLISZBGKOM2X4ObGeCjYP3PaxAMTjP8jN1jkFYkjrgICU0n6KAfivMCvBt3WZgWPZiRdt45Fdy_z9KvgX22Bh8GPShIyNJFRfFC57nK0LdlKJZJbUQwDpIHxPfFp3dXtHq1no66P-7UhGPz5Wfu4uT0Yy39WEsvnrfMaDAM6AocH9bL6Wgibi_e1bcnJ3onzO1nNaI2yQrBE1-B9XCTlFN6tpSenLLGgtrnWPjtxVl9K7CoePCSzQwCsCX0Nps4kkMNrLqbJAfLAEBYScyauNHF1IDo0xnYAatFiJoQF_RgIVhcCQEnTcD4K-Jr-AkCTxByIoMVlxXapwRb9_yT0SHyUl9BAklVkmLDGI0LMj9h9eO_7ZYWdLlelMlqkUCwN6-gwGG2XEFpoYAZgVD3NkmxV0YmcFfGhcIc8v8Ql4I579ORTwDtPbhFNSSgPez7sdf_WmY0QQ3p3KLkPikgUGZYMBxd1tiyZVLWmhWww6AUyU_tel6hnlcXY_hl03OdLsJ0EaaLbOnwYuX8FIGrmzoqaHUFr601wNJP7CB3CGd5UbBL7hjlQsc0Bo9fw7TgaJwMmAvrOeHVlHYCjPPAIYF2N6tRr5Xp93EK1ZRStipT-wXt3cIUHGXXznJKRqZ2wLWDXaxZCM08aUHAiIPFIl6gHbNW-3CXhHfkIQZYjVsOCnS_Geue9gNxoWN4MhA5lDw06RN3XlWXQxtdzb11429wXIAKyW-_2SDOplbhLQrXm-_lXVzEciOnjhPqQXMzNjG2NlOngzb-kTraKXYmfbuSTkhX2JOcxKFrLqLMkyC9XcTQghxtkzvqscNR1wwSd-tMrhyYDQ1-J2IRdHJy8ZuOJkkLGC-xqIfLthUsIlOL_oYN3pHdT2EDwl64TkejyH1y-XIuf3cusm5sD5wFxpGUDXM1OGrnz541972am6f2GN6am-eSfa-2L5FXhiDyO2BgC9PYtPunHbn3cCyKxobrFjeiaGd435JS18RQIexyMWvTtdyrpIMU0mQ9UfioKE2WfGBS5jLX7VHzmydgcy0wOuHzSR_q9spnK8g5YRMu-nyGaMwzGJjIUzIGBz7IEfzerNiNHhvn4Crz-7jLX58WwKLb62mBbrAu6cBmKpKF8xjiqm5vgtTjhgwDCiSenNSiVHF4qVM6aPQQXUHfeD0Pws9dyDiclVpXTJVQZHnZLU-55AEpT6m0nq5pLcNdUgxnTSb6KGeks0dsmChG8Re68q7r4WFDgrEheEoaGYZJCQMqqEiwFBJwHU6nc37Hx5BmJQfd6wAwzbvATBriMG0H06BWM-CeAztJ68Exvm7UHQzg11yvXcoJqhi6PdBzvwygKczg77zRGdo7T3FsNBNurvw9eIZJiy0rKpzpKjQ1qA_nj7sAj6AmNF7T6Wt9KPXBVW5UBfM74FXSYBkXKxwFQUPgxS1pMyvjixkf1ufrsCR3QXF3wcs_09CyRgQKui7ruuj2jLoQnoXXSJrFj2G8Kh2t39Q6z9-tGdnaPkNRxDEGFKqzsgRMrMZs3srqq3b1dw3PcAreqWEXHtPnmlNodgkmN5VjMg1ljskxfa45JvYxoJ0rVReq6K9TpjZau2uIuN6dXZezp223Kx563X7CMvR60MmNHt_H49_97v38PcavlMfFBXnXq59mM-L3zF77OVKB1buzL5a6NagqZWtrOMjU6JgntAPQ1q7ous5ytcFFMb6k1MVHMPioKIX3qVeb3hR5KPxKTQzmBZDBXvE3OE_yDRni7TkSGAxkCS4LOyrK1h-QoTcgZ2xyZABuk_LgOkDfwHk1ZoEs0viW5Ydf1H_W8G8b-A1YqQS8TBJ8eAmQuafn7Y6OUhlFVCVbiaOTrHVJ4kdaEvoGsNNcrEDIJ7tp7ECUj5WNMuh2-ct-DwH22Dw0kyKCZ1QAGzHPiNeowMjqNVk9ARDz0gq9TVGJPVWLrNRD-IPqE6uKOFZZBtAy8SbIb0NQ212Qkz7c33-6EiqjDbkog7y8TKDH4c2ArZ-C7yrjIKquw0UWfj4_T7OHrigyn1o1J54pLzHFKs2xPoEu6b-tPFOKVFxl0qiEprVQCePArJ_PrQpnTCXXS2YcZE05VUI1-qZnth1hDujaH-J8PGB_31_7ktGnSdllr8EFTeqmtk5qKuDs2TIAH0sGoA5qZ0Gl14V-BFYV_GxIo4hHML4KfjYjiQaqqeBn40k04FrBz8aXaFCiCn42Y4n2eJ2KccI1iB8gJWrGCpTWpK6M1FVL6o2ReuNOXRlIqhYklYGkakFSGUiqFiQbA8mmBcnGQLJpQbIxkGwMJKrxFN1Xg_h_bhAD8uHXn34CH_FVDAE0zcqmYYTLAdftTXQ6eBag-xPRK-Br6vH7PJQscMYtfmBeX9lOU0fWjKlIP5wlKQy7y67sW3tKj7vK43v-4jva4dVdcj0jKF5NvcnEOtAI13kep_v3SSKzgKCKb8DrYTfjnK1LjN7qHHDfOScd_KtwQjr5ROkKpGid01WU6zAoygvl1TJZLJIihn4yKmBgKRVr2HS7vVMaGXR7TMKyuGpkQMVJax4YCRj6nSkoXXMXDFac51TIP66TkkTrGGf3gxUuWOFS6n2c3yyyB5d0vOZ5HHy2zVtYql2G1WShMywaDcsllcfTBo9cqKWzxgvd5HK9UDvg5m4s1beelHa9zd17pYExu-fNqz8l44lKxtYF5PdK82qaGLSrjwe2srqRUA7zoIj5-2ljws2AS3p_LCeoR2BSApdVKHNklxnbAnWZTaWsskgl0bGWSp5Ba1LtNUI9aDnazUuY0rGCYDhTdneJpd5Dh6cizmzq1T2obNKcimnKun26c0EcTfo03apq4LONbbiFI81KvnsjKdjOC1ResYKhoZOnVsHIurVyMUF7xWIKu-7a9SdKSCdOJQUpgXmLdurSSIvSZ45FaWuePRao5as8LdlqNK7KiIIPZ4LYl_2B7VrGy3BVdctT2foGMiv1BR9oqul7OxTCHSfjiMsnLW1Pv9qriqnA2nLoMpW--mDNr9sy5HzT0mzwMmdHdr8ROwTih39iuyTVbRrOfC-7_ULj_HJbMeTr0BbQXsk0nkCzwW0PvHp3twz78pMT6YHtrq5Fvk9E8-WlbYuIfLnN5DmIdDTK89AEJylyt5sAK_lDFNHYQNqR1No_PNd77rudR1w77AYZ4aa01W73dNzl-iBviNfbXf_A969Tdgu2SS4I8aW33xCPnJNRj_aKxUOw4jvNcP-iaKcY1K54vyttiN5ZII-w7RG4D2KEuzmkytQEf05WtO1mq1VWJNAts-3Z_z0dkdIYvN1m5m4RyJpuoa_N2s1F6wxGu7sBLYd0ImDfLP7hWcZ7ZKn3iWCV8L1LZB6XD3GcsugK9IHrcJypskFVbF6MH5OC-vAs1Xb1yZcSf1GhP0p7SqZSS1YCMSPlsZJUjsiMpF_SGbzp2zjywELtyw_oJ6QmA7oNa9XT0BXaRPn1YkGCxUNQFVANrPZwgzAQ2qUgZG2HNJj0wKpBXJvfjfk2g6qKkiIM8gjP83zYI9p3ty80tCDNUjyaAeEdtZs8K1lHLyJ5dP98-AZRYMb2ZMPwPAxS1Ea9oTS4DRKcbs-AS-62OLoAfQcRzM_rNAX7_CkO6ArBjjYhhje5lGtnybXRxc9YtLheJ3Vat5HSbd1G0udaN1QF3TxO1R8P631mpNQ2vtPd6fFjEOJKvNf4APQyExKDmVWiujCqu10HeQBmxnb8ot6hDpfuyBAvMdw1Ctfem-4O2OliDwWsTb21XfvuqLYKFOMPrSDamDtxjLYPL2EN2qY-3LG3u7wy9pMTWV3K0tw-lzYb1na5nYSM51lo9ovH2wEou_r3DOwPtBe--95uLqV9T76R0rJD34kPGfzMva2YVhLPGH3Jz7sKsNsywcH8ki2g-aN8cN3BDT1mCoVKixuET50-de7MBxUslMD3C_qIvYPwLKIf6NjU1YFuKsaNrOi7IFMRLDEnBKIoImCcWFxcH7EBSofOOHf2GmuIi60myEtCBIPzLtSmf8W2itLN895Vr9_FTe5s42oKBLjrEbhnZK8m86R-nXTMkk4aYZGyobI77NKMo6s-l9rnknC_RfNqLL-ib0ZaJq-WOdLyeHUewW3E3_hGHk95c2Lh5stqsLw5YaWGN6Jsepl8W1m0MlhLpUlRsNLtKbIyafqeUgSvripFeYpqfFaJvOYEXlGasVqaoYH9hDj0DhTFhsaNPgQHRtoxKyYZbqUYLuDrcqxCwMhuuFRVXAdNRVoNtzdphL0a7qvhvozhbuwe12a4imttPK7NcBWH3XjczavhvhruyxhupYUK1ON6muWpQn3N43qSsmlST8c3aYS9Gu6r4b6M4VYWj-u1hgq-FuOOavJol-G-hgqvhvtShruxe9yWUIEVzohxFcO1hwrVa6jwargvZLgbW6gw0ixPdaNKqOBp9mzFN2mEvRruq-G-jOHaQoWRxePqhstDBc_icd2G-xoqvBruSxmubVbBYbiKa203XHuosDFCBV1nfbl0drM1NK8oyW62Q6fZGjVrNWjTOHearWa0ij2ODHv0ZDsxi2S2GdVmzdKNnY1ybJTbN_LodWKYscOXaCo3K2FkMORWPZQ5cRvef2psdP2_3Ji-0AcKcLb1FItrOGm6l0bpXc3KeNQkpNfttjbCnsWMakdgSWUxD7VavQaSBbDhyxTAh5pEtcMk3N2i2yTc3eKwqSq7hoRQrhD9taqZgy1rbNagJ1jvcmZt9rdfVygNGWut9lo7wdo8LNZhqX-pp2u1nQN6PWYdw8MdhjtoancYYyWPq-CHhlbPq9YGjdtvyKlGdVvWHcie_qNRDWeyvwNxK8oRCzkcXmMhjjNDrks7N289CllTpLO8TXrj4J5K28NodZ62A5ZtGMyjhtrK5DMw2I5ttmGwHGBUaYdjsB4GbcFgOSqqrRc8A4PtiGkbBktdVF9YF9aDq20YLHVRfWFdWI_DtmCwHJbVJmSegcF2yLYNg6UuNl9YF9aju20YLHWx-cK6wOPfEBI_w5DoufFnZNzQw-bXPePgo-vCcw6rFf9yr2NfVCZvf9rJUTqMx_ZGRTv3qorLyHLIET1xWTe-7tzvunub6-5ddPttkaRHRVJ-VkQr7iEH7pTy4p46ds6Bn9OsH3APYP2w797Rp0M7Z3HpDcAbyErGvYQ1Fhqd7r8lVG8hrZy9L-C8aeXsX4nvrBzAuvuIfoD7nOV6QZ_FQWhOjpJ7TjY90eGF6VboQCSJ-GyRyMgvIhH9pSwRny0SGdkq8XC1-qAwT9YrEvyB8Z0MSxLtqy9U_U3uL1cH_XyHgg0I9KdyY-NJbNia3AY2miiIoqYA42cC3lgBb74IsKWmrYCNalBMh6amzeOx7ZNhrsJVuqVU_IsreuhqSWIpnJT7BZqqbikV__KLHtJaktiwNbndiq8L8BxLqXRLqUW6LWUfwG2WIgM2qsGwFObWqudYyka3lA37Lo_xnRlLEkvhpNwv4GJ1S9mw7wMZX7WxJLFha3K7FV8X4DmWstEtpRbptpR9ALdZigzYqAbDUnh35B_a_UifwEvxqKYS1oAFHaisFnYesKtejp0P7Ghnq35NZddlFhICWBjb9JlG32orSifK2SMj7uvLHXRf1PRb7XjBSWuE15c7UolHtTcPH3hsrDzUcd9bVsb9q8CsQlBW9WxlVVZlVQcpq7IqqzpIWZVVWdULK8tHZW2erayNVVmbg5S1sSprc5CyNlZlbRzK2nO0jtfu02p48U-cpNZvnAjM1q-cpId95mQ_SG_fkl9XEQhl52zZQVbSWeBR1k597navc3jHxgHa337bSyWW47NkZg7CX2qcbznnu9-nWVxYLRMGL1Q1vzwkZXgnJnrS-LE0j0KjTey3qDMm5XKF5wQR8Sd_x5FAvFLW6HGZYJ_EHkus_-cH9sTsYwgM0Mt_3kb6klj9_T1L3e39uWHr8fZzM7frs8RbMXEj_xea4qU0Mwb8xffLlCJIc2NNkmMtTTM71qRxfcWM_ReO9Lyjzf5VSJcAR-Kpw7lEKOp7Bcql3njNhrrKISy66TJA35DOX9KnDjknncFf0o6lkgRwxwF9zq3z9PT3HQK6jt6dASvietgOyP9Ywm1nYDVB8ZHjHlcgdmQjFsM6XnnuVxBb7i3Ecwvx3EK8w4T4biG-W4h_mJCxW8jYLWTM5xJl7mqrFta1VW1zqwcLUbyIy3p-vpA_hSh_4_Cj8p6JMrI6ProcQked7_rW7et3bf-vfteWmtvf8c_djyZHW_ZfVvP_ufpv_O9_AQ" rel="nofollow noreferrer" title="C++ (GCC) – Attempt This Online">Attempt This Online!</a></p>
<p>This matches the output of wastl's program up to 12 terms, and does so much faster (62 times faster on my machine).</p>
<p>Certain design elements were quite natural and are shared between both our programs – namely, the use of 128-bit integer coordinates, the coordinates of the starting tetrahedron, and multiplying all coordinates by 3 for each successive term. The remaining details are implemented from scratch though, without consulting wastl's program.</p>
<p>The finding of standardized rotations of each polytet (for comparison purposes) is done by solving for the affine transformation that moves one of the faces of one of the tetrahedrons to the first face of the starting tetrahedron. For speed, this is limited only to the attached faces of those tetrahedrons that have only one attached face, taking advantage of the fact that it's guaranteed that all polytets will have some (because a polytet can never curve around and perfectly meet one of its own faces).</p>
<p>Output:</p>
<pre><code>1: 1 [0 ms]
2: 1 [0 ms]
3: 1 [0 ms]
4: 4 [1 ms]
5: 10 [3 ms]
6: 39 [11 ms]
7: 164 [59 ms]
8: 767 [321 ms]
9: 3656 [2553 ms]
10: 18186 [16792 ms]
11: 91532 [110263 ms]
12: 468203 [704540 ms]
13: 2417721 [4459145 ms]
14: 584897 [4882079 ms]
</code></pre>
<p>(The timings shown are cumulative.)</p>
<p>Clearly, 128-bit integers are not sufficient to go beyond A276272(13), but this program seems to do at least better than wastl's at it, giving a plausible value [though shown by <code>USE_GMP</code> to be incorrect]. In any case, the fact that both programs agree up to A276272(12) strongly suggests that they're both correct up to that point (and would be beyond that point by using larger integers), and that the OEIS entry can finally be updated.</p>
<p>It uses about 20% more RAM than wastl's program, but that can probably be improved. There's still plenty of room for further speed-ups, such as adding multithreading. Disk storage and merge-sorting could be used to get past the RAM limit.</p>
<p>[Edit] Output with GMP enabled:</p>
<pre><code>1: 1 [0 ms]
2: 1 [0 ms]
3: 1 [1 ms]
4: 4 [3 ms]
5: 10 [14 ms]
6: 39 [63 ms]
7: 164 [320 ms]
8: 767 [1812 ms]
9: 3656 [11373 ms]
10: 18186 [71473 ms]
11: 91532 [459047 ms]
12: 468203 [2896937 ms]
13: 2420658 [18468569 ms]
</code></pre>
<p>With <code>USE_GMP</code> enabled, the GNU Multiple Precision Arithmetic Library is used for applying the affine transform (but not for solving for it, or any other calculations – so overflow will still eventually happen). This is more than 3 times slower, but extends the number of terms that can be correctly calculated, and should do so up to the point that RAM becomes the limiting factor instead.</p>
<p>The timings shown above are already obsolete, as I've optimized the use of GMP a bit more since doing the above run (during which the slowdown factor was more than 4). I've restarted it, so that it will reach A276272(14) sooner (which is projected to use 42 GB of RAM). To go beyond that I'll need to implement use of disk storage, since I only have 64 GB of RAM.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.rust-lang.org/" rel="nofollow noreferrer">Rust</a>, 11 (hopefully correct) terms</h1>

<pre class="lang-rust prettyprint-override"><code>
use ::std::ops::{Add, Sub, Mul};
use ::std::rc::Rc;
use ::std::hash::{Hash, Hasher};
use ::std::collections::HashSet;
use ::std::iter;
use ::std::fmt::{self, Formatter, Display};
use ::std::time::Instant;

type Coord = i128;

#[derive(Copy, Clone, PartialEq, Eq, Debug)]
struct Vec3([Coord; 3]);

impl Vec3 {
    fn dot(self, other: Vec3) -&gt; Coord {
        self.0.iter().zip(other.0.iter()).map(|(a, b)| a * b).sum()
    }
}

impl Display for Vec3 {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        write!(f, "({}, {}, {})", self.0[0], self.0[1], self.0[2])
    }
}

impl Mul&lt;Vec3&gt; for Coord {
    type Output = Vec3;

    fn mul(self, mut vec: Vec3) -&gt; Vec3 {
        for i in &amp;mut vec.0 {
            *i *= self;
        }
        vec
    }
}

impl Add for Vec3 {
    type Output = Vec3;

    fn add(mut self, other: Vec3) -&gt; Vec3 {
        for (i, n) in self.0.iter_mut().enumerate() {
            *n += other.0[i];
        }
        self
    }
}

impl Sub for Vec3 {
    type Output = Vec3;

    fn sub(self, other: Vec3) -&gt; Vec3 {
        self + (-1 * other)
    }
}

#[derive(Clone, Debug)]
struct Tetrahedron([Vec3; 4]);

impl Default for Tetrahedron {
    fn default() -&gt; Tetrahedron {
        Tetrahedron([
            Vec3([-1, -1, -1]),
            Vec3([-1,  1,  1]),
            Vec3([ 1, -1,  1]),
            Vec3([ 1,  1, -1]),
        ])
    }
}

impl Display for Tetrahedron {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        write!(f, "Tetrahedron({}, {}, {}, {})", self.0[0], self.0[1], self.0[2], self.0[3])
    }
}

impl Tetrahedron {
    fn collides(&amp;self, other: &amp;Tetrahedron) -&gt; bool {
        let mut othervecs = [3 * self.0[1], 3 * self.0[2], 3 * self.0[3]];
        let sum = self.0[0] + self.0[1] + self.0[2] + self.0[3];
        let mut same = 0;

        for (i, &amp;vec) in self.0.iter().enumerate() {
            let sum = sum - vec;
            let vec = 3 * vec;
            let through = vec - sum;
            for (j, &amp;u) in other.0.iter().enumerate() {
                let u = 3 * u;
                if u == vec { same += 1 }
                let up = (sum - u).dot(through);
                for &amp;v in &amp;other.0[j+1..] {
                    let v = 3 * v;
                    let edge = v - u;
                    let ep = edge.dot(through);

                    if up.signum() != ep.signum() || up.abs() &gt;= ep.abs() {
                        continue
                    }

                    let intersection = ep * u + up * edge;
                    if othervecs.iter().enumerate().all(|(i, &amp;ov)| {
                        let mid = othervecs[(i+1)%3] + othervecs[(i+2)%3];
                        let ov = 2 * ov - mid;
                        (2 * intersection - ep * mid).dot(ep * ov) &gt; 0
                    }) {
                        return true
                    }
                }
            }

            if i != 3 { othervecs[i] = vec; }
        }
        if same == 4 { panic!("EQUAL TETRAHEDRA IN .collides()"); }
        false
    }

    // Mirroring also scales by 3
    fn mirror(&amp;self, i: usize) -&gt; Tetrahedron {
        let mut sum = Vec3([0; 3]);
        for (j, &amp;vec) in self.0.iter().enumerate() {
            if j != i { sum = sum + vec; }
        }

        let mut copy = self.clone();
        copy.scale();

        copy.0[i] = 2 * sum - copy.0[i];
        copy.swap(i, 3);
        copy.rotate_left(i);

        copy
    }

    fn scale(&amp;mut self) {
        for vec in self.0.iter_mut() {
            *vec = 3 * *vec;
        }
    }

    fn rotate_left(&amp;mut self, n: usize) {
        self.0[..3].rotate_left(n)
    }

    fn swap(&amp;mut self, a: usize, b: usize) {
        self.0.swap(a, b)
    }

    fn reverse(&amp;mut self) {
        self.0.reverse()
    }
}

type EndpointIter&lt;'a&gt; = Box&lt;dyn Iterator&lt;Item = Endpoint&gt; + 'a&gt;;

#[derive(Debug, Clone)]
struct Endpoint {
    tree: Rc&lt;TetraTree&gt;,
    hedron: Rc&lt;Tetrahedron&gt;,
}

impl Endpoint {
    fn iter_endpoints(&amp;self) -&gt; EndpointIter {
        let mut hedron = Rc::clone(&amp;self.hedron);
        //Rc::make_mut(&amp;mut hedron).swap(0, 3);
        Rc::make_mut(&amp;mut hedron).reverse();

        Box::new(self.clone().into_iter_directions()
            .chain(self.tree.iter_endpoints(
                Rc::new(TetraTree {
                    subtrees: [None, None, None],
                    hedron,
                })
            ))
        )
    }

    fn into_iter_directions(self) -&gt; EndpointIter&lt;'static&gt; {
        Box::new(iter::successors(Some(self), |this| {
            let mut this = this.clone();
            Rc::make_mut(&amp;mut this.tree).rotate_left(1);
            Rc::make_mut(&amp;mut this.hedron).0[1..].rotate_left(1);
            Some(this)
        }).take(3))
    }

    fn iter_extensions(&amp;self) -&gt; EndpointIter {
        let mut tree = self.tree.as_ref().clone();
        tree.scale();

        let mut hedron = self.hedron.as_ref().clone();
        //hedron.swap(0, 3);
        hedron.reverse();
        hedron.scale();

        Box::new(Endpoint {
            tree: Rc::new(tree),
            hedron: Rc::clone(&amp;self.hedron),
        }.into_iter_directions().filter_map(|endpoint| {
            let mut new = endpoint.hedron.mirror(3);
            new.swap(0, 3);
            if endpoint.tree.collides(&amp;new) {
                None
            } else {
                let mut hedron = endpoint.hedron;
                Rc::make_mut(&amp;mut hedron).scale();

                Some(Endpoint {
                    tree: Rc::new(TetraTree {
                        subtrees: [Some(endpoint.tree), None, None],
                        hedron,
                    }),
                    hedron: Rc::new(new),
                })
            }
        }).chain(self.tree.iter_extensions(Rc::new(TetraTree {
            subtrees: [None, None, None],
            hedron: Rc::new(hedron),
        }))))
    }

    fn iter_tetrahedra&lt;'a&gt;(&amp;'a self)
      -&gt; Box&lt;dyn Iterator&lt;Item = &amp;Tetrahedron&gt; + 'a&gt; {
        Box::new(
          iter::once(self.hedron.as_ref()).chain(self.tree.iter_tetrahedra())
        )
    }
}

impl Default for Endpoint {
    fn default() -&gt; Endpoint {
        Endpoint::from(Tetrahedron::default())
    }
}

impl From&lt;Tetrahedron&gt; for Endpoint {
    fn from(mut hedron: Tetrahedron) -&gt; Endpoint {
        let mirrored = hedron.mirror(0);
        hedron.scale();

        Endpoint {
            tree: Rc::new(TetraTree {
                subtrees: [None, None, None],
                hedron: Rc::new(mirrored),
            }),
            hedron: Rc::new(hedron),
        }
    }
}

impl Hash for Endpoint {
    fn hash&lt;H: Hasher&gt;(&amp;self, hasher: &amp;mut H) {
        let mut stuff: Vec&lt;_&gt; = self.tree.hash_helper(1).collect();
        stuff.push(self.tree.len());
        stuff.sort();
        stuff.hash(hasher);
    }
}

impl PartialEq for Endpoint {
    fn eq(&amp;self, other: &amp;Endpoint) -&gt; bool {
        self.iter_endpoints().any(|ep| ep.tree == other.tree)
    }
}

impl Eq for Endpoint {}

#[derive(Debug, Clone)]
struct TetraTree {
    subtrees: [Option&lt;Rc&lt;TetraTree&gt;&gt;; 3],
    hedron: Rc&lt;Tetrahedron&gt;,
}

impl TetraTree {
    fn iter_endpoints&lt;'x&gt;(&amp;'x self, behind: Rc&lt;TetraTree&gt;) -&gt; EndpointIter&lt;'x&gt; {
        let mut iterator = self.subtrees.iter().enumerate()
          .filter_map(|(i, opt)| opt.as_ref().map(|some| (i, some)));

        if let Some(first) = iterator.next() {
            let closure = move |(i, subtree): (usize, &amp;'x Rc&lt;TetraTree&gt;)| -&gt; EndpointIter&lt;'x&gt; {
                let mut behind = behind.as_ref().clone();
                behind.rotate_left(3-i);

                let mut this = self.clone();
                this.rotate_left(i);

                Rc::make_mut(&amp;mut this.hedron).reverse();

                this.subtrees.swap(1, 2);
                this.subtrees[0] = Some(Rc::new(behind));

                for (j, subtree) in this.subtrees.iter_mut().enumerate().skip(1)
                  .filter_map(|(j, s)| s.as_mut().map(|s| (j, s))) {
                    Rc::make_mut(subtree).rotate_left(j);
                }

                subtree.iter_endpoints(Rc::new(this))
            };
            Box::new(closure(first).chain(iterator.flat_map(closure)))
        } else {
            let mut hedron = self.hedron.as_ref().clone();
            //hedron.swap(0, 3);
            hedron.reverse();
            Endpoint {
                tree: Rc::clone(&amp;behind),
                hedron: Rc::new(hedron),
            }.into_iter_directions()
        }
    }

    fn rotate_left(&amp;mut self, i: usize) {
        self.subtrees.rotate_left(i);
        Rc::make_mut(&amp;mut self.hedron).rotate_left(i);
    }

    fn collides(&amp;self, hedron: &amp;Tetrahedron) -&gt; bool {
        self.hedron.collides(hedron) ||
          self.subtrees.iter()
            .filter_map(Option::as_ref)
            .any(|subtree| subtree.collides(hedron))
    }

    fn scale(&amp;mut self) {
        for subtree in self.subtrees.iter_mut().filter_map(Option::as_mut) {
            Rc::make_mut(subtree).scale();
        }
        Rc::make_mut(&amp;mut self.hedron).scale();
    }

    fn iter_extensions(&amp;self, behind: Rc&lt;TetraTree&gt;) -&gt; EndpointIter {
        Box::new(self.subtrees.iter().enumerate().flat_map(move |(i, next)| {
            let mut behind = behind.as_ref().clone();
            behind.rotate_left(3-i);

            let mut this = self.clone();
            this.rotate_left(i);

            let hedron = Rc::make_mut(&amp;mut this.hedron);
            hedron.reverse();

            this.subtrees.swap(1, 2);
            this.subtrees[0] = Some(Rc::new(behind));

            for (j, subtree) in this.subtrees.iter_mut().enumerate().skip(1)
              .filter_map(|(j, s)| s.as_mut().map(|s| (j, s))) {
                let subtree = Rc::make_mut(subtree);
                subtree.scale();
                subtree.rotate_left(j);
            }

            if let Some(next) = next {
                hedron.scale();
                next.iter_extensions(Rc::new(this))
            } else {
                let mut mirrored = hedron.mirror(3);
                mirrored.swap(0, 3);
                hedron.scale();

                if this.collides(&amp;mirrored) {
                    Box::new(iter::empty()) as EndpointIter
                } else {
                    Box::new(iter::once(Endpoint {
                        tree: Rc::new(this),
                        hedron: Rc::new(mirrored),
                    }))
                }
            }
        }))
    }

    fn iter_tetrahedra&lt;'a&gt;(&amp;'a self)
      -&gt; Box&lt;dyn Iterator&lt;Item = &amp;Tetrahedron&gt; + 'a&gt; {
        Box::new(iter::once(self.hedron.as_ref()).chain(
          self.subtrees.iter()
            .filter_map(Option::as_deref)
            .flat_map(TetraTree::iter_tetrahedra)
        ))
    }

    fn len(&amp;self) -&gt; usize {
        1usize + self.subtrees.iter()
              .filter_map(Option::as_deref).map(TetraTree::len).sum::&lt;usize&gt;()
    }

    fn hash_helper&lt;'a&gt;(&amp;'a self, behind: usize)
      -&gt; Box&lt;dyn Iterator&lt;Item = usize&gt; + 'a&gt; {
        let sub: Vec&lt;_&gt; = self.subtrees.iter().filter_map(Option::as_deref)
          .map(|a| (a, a.len())).collect();
        let sum = sub.iter()
          .map(|&amp;(_, len)| len).sum::&lt;usize&gt;() + behind + 1;
        Box::new(iter::once(behind).chain(
            sub.into_iter().flat_map(move |(sub, len)|
                        iter::once(len).chain(sub.hash_helper(sum - len)))
        ))
    }
}

impl PartialEq for TetraTree {
    fn eq(&amp;self, rhs: &amp;TetraTree) -&gt; bool {
        self.subtrees == rhs.subtrees
    }
}

impl Eq for TetraTree {}

fn main() {
    let verbose = std::env::args().skip(1).any(|arg| arg == "-v");
    let begin = Instant::now();

    println!("1: 1 [{}ms]", begin.elapsed().as_millis());
    if verbose {
        println!("{}\n--", Tetrahedron::default());
    }

    let mut polytets = HashSet::new();
    polytets.insert(Endpoint::default());

    for i in 2.. {
        println!("{}: {} [{}ms]", i, polytets.len(), begin.elapsed().as_millis());

        if verbose {
            for polytet in &amp;polytets {
                for hedron in polytet.iter_tetrahedra() {
                    println!("{}", hedron);
                }
                println!("--");
            }
        }

        polytets = polytets.iter()
          .flat_map(Endpoint::iter_extensions)
          .collect();
    }
}

</code></pre>
<p><a href="https://tio.run/##vVrrb9vIEf8s/xUbF3XIWKYt6z4UlCwgTXJIgN4rcfvFFQxKWlnMUSSPSzr2Wfrb05nZN0VFvmvRAFbIfcxrZ34zs1LViPrr16NGcBbHol7EcVGKOH56vVj02adm1mc/NNl25C6o5nH8ce4NrRKxgk3v4b8@w09e@XvmRZbxeZ0WORDHBZ947S1Ia155A8t1DRQFz5Z99n1RrZMaVvTZ21SUWfLoU6/TNY/jD7mokxzIHtWPJWdviqJasCuWDi7/BmN/uVnwKr3nwZuifOyzN1mR8z77OanqNMne/dZn@PeWz5q7cHok6qqZ1@xffD4MbojQiA2nIZBJ12VG4@zpqLfM2aKoAylkUYPWMc2F7Gyi@MOqHs5HFxGqGITR72kZ0FozFEbrpAw2QdJns3DDEvYK/o9Esw7Co972aKu4KtXZsqhcCcBQwYkUYRmzk3VTW3uRIGTJj1w0WU3ifKmA7YsA1h8HT9s@k3/hcZ9JQW8upuZxYB8vp5404BZjlGJC8hhlyfQ/NXUJYlyRmGA0FHPdZMpQKOE9nzum0tr0kFTK0lyqAYuiCxrvvUrZqyuSZASvW/iDSVcc8FfPMHvlSBaLAIl3H5onSZD2WR6iOM4J3sJmOEWeN2teJTUPQiVhzk6vmDrYm3Sq5cStrqAQU88TVDSz4ICQOM1OWXA2AJehVfqIrLdLP2859jWvq2TFF1WRBzfEk31n3fstXyboLCims1J7vJwNSJTWdM8jjGaRIXQ26DP5Nw37/jCjP2@YqdUdw8whMt0bHbtC/zdB4upk4@WZMWMeh764uyIiRKYLLrSc6tRPnJUk6awoMhIx4zXFEi2EcBDgPzdD8ARHDuf10n8dTslFkQggDbuyioBHGQr2@dJ5HpqtFEnJmsP@C/RbEzcnIFA7dLrCxuEPn2cY8yM9Ds8wjjK7o/WqKpq7Fczg/Bnuozni/Bk4N8TXh9hdxkSrUfQbotBLlzgiCT9JvSCmB2xrN5SwI5CiNmGE6K/kCSUJlOLkniBMY8Hn00EUTRVXqZhWa2TH@OIOrXiPhN1hZIhzLV5yBQpcRiK9yzFZsBew1HndbHA2mQl4ntCUfFaS9OZFXqd5w@Xr9shyTXOwmpAJG/mXaCM4/wYfUJqR4W@8r8PSUZJlkNfQHYp7yGyaMXlOisnZ7L4J0tNB@Nchepk3eImDI2djgda7RMBDWwEZPRngoCf5mZQc1sijojeQhE3YhVLaWqPidVPlDADSGMR8StuAtinaGMDXkTGdSlcckZvgH6yTMXHFvoOlZZKn8xfB8btf/vn6H@z63fXH1@/fvf34mn34kUUm6sPjUFJYJpngR8Ty/Jz9kFZVUaX5HYPhgol5knHBZo9sKLMqTWvISGPWiPR33gnNJlwp2iSkXqiyxomeZ8Yt6PgZbZFioJj4PXUN4fCcQ82lIWaOGSkgpjgckUqBdGkauJAmxdOUgWZG7Z4vUDCBWw0tmaqoQbzbjC/rILXUpCExnRKbE536Q5PlMdi7UrxK6xaEXikU2hqaLs8TW1Tk5hhs9XcTRcOpJ2QeWtlQHYdAoghAPdhBSmpPxaKVhN@j27f1Uxv0rM5AVHO8yxdlAeHyATQev0wmoOXfi4fx4jFnOJTURTWGBzxavXQCBwwr3WqaCgtVTtv6Qm@gAqfiPGYf52NyyGt4m0D2lo5px@U7zOgE6ZIABelcuBpTOZLc3FXD83Pl@lfAAvoPcjraFalcikd5fo6T6@RXTmd@YveF0soX2sf2rzPGJZ8DE8Zxzr8Erq9HIF9xSyos0kr1QXgavV40XyVpLlejpaKWooRByBxpGgtq0IIaETeJmN38SHWe/Zz25RIppnzZEssQP63rdMrWad7xS2iw6nQ@IfZGU9wLjVgzn3MhikoEn4o1lxT6bFOvUrGxuR4th0NwLvifiwYdNqYlqGHohc7gm@v1wUD9Anm3ayMJiGvREtswqoFIMAwdm9AhPNQ8F2SOZ7gbSqkhjg4yEbcVX8LhOyrShAt4O87qeGgnhfNzNem7pxp0fNGMuezMmbnR1TMhKufI3uQwNkg7IwjXbPf4drRMM4JS7Gy1O7f8AJhhcaEmtdYqpUm9erCmpSqmHrOHDGorZ1itEzrGAKVuxiGfOjWfZ@4W85EJtz2Y4NhSuZFvybYtdyLWDVna76kSdkWwF8Lgrl5gW1aouxvmW@nb3fhiXXuPpAeRpc3e9YkwbMdSrTE@wVQTnLxMZJY66jGMqn2Jx21@VPLxsQeeGZMAVORziTrt8NljAytSYBFx29ECtzKR1/96p69f4nhZFevAkT2OzS6Pzfewzst/XQyJmPXCmLU7Qk8IWVtjCHEssP2gutgHDN/Cg7YPH046bd/Q8kj/3IYHHci1Ed4WdpkF7xzH72N13TjRNfCKXlWP/z70S9@6WS7pImV8O/HAGnfdrnhWQrU7CCN1XSlxlHZFZSNWjgtlPIeztNOQ@LzlSDCQsuCoVcfcOHbpxH9rd/96gd/6kxytSgG6rfwRsLbcYKcn05G@kCJscaXYYb89WNN5buD4wE8lQv7YK/Am2Fc8p8rziO6UeeOXD4gVD6osnvFVmi9atWRHlfIw8U49VaCiD1zL3tHbEJx4qQu7jKKsoXmFT5uRaU4Afm/otgOfwlCGEqQn5EzgvkwrAUd3ZWSIcoBe9@4D0qpoKqwc1sU9Z8RPCRjGLFBtANrA13qzV22ruLQXkJYPnfVEr6cm3TJpeJbqHNeq2dodHGAFllwdzdfB8syvmxUhczaU8wd9dumy0bN4SXUlLazRQ2oRamK6ndWmxA7PZ9B9lxuJX1PgSwl0xxWQHhheoCHlTukGG8kKHEBneU91LYNnpc9KL3Xrota0Y9qUZFiryqxO20z@U@6jHE0lOuNsyyypSXa1jNKyVxH94fpzXwHaWYG20oqTV1Q1qU6tO2s4CWFvmfmcdjzd7aGNF7Qdt8tr3ZJ3d4Pi3b691crsv751LW1264WbDUFRF17RhO@aEoLjWB6YWUH5QO3e6FDY4RUeviJRW801SVcQdYsDcyooukPC1CCyXj1gfLv6W33acxOFX0keSg02mCxQI5iHrabmWaD7Tcw9BLl7ERc3erce@9F3T8geHcLhPwbD/wsU/tMgLL9ZmKm@vNP9Rh72Or5oBzsw21wGmzRPfgBM8H/FvV1j96iXfaj39l8OxHd1rHtLegW/Pb2gjctd1T5JL69fDGyZGl3nsNb9Dl@X9SOUvCwRXhTJLOaK3N5JjVm7TW7fOaD2fr@7r32g/tK9mlcD/49285md5p/Ebii/HfQ2eGMgTP5KwlGO2larOvYk9qaKch6JP5CPp98S6YBQUUsQYEW/UIjjMRGfBFYMp5fyrG9xWabjA4ch6TqnoAK63b@1MfugbSVgJAAYSZ8lqpNr9Xzu15Iz11Jy80lw20dzAxB1WAJkVlnglA1Ge/xHIaX1mB5x0lVOR8IR@GscYipx0f5zyJI46r4D6Ll9rfwyBReE1nG629J2W2b70moldFFzTZC@U9Lo88DuE1ab947202EDM/h1FspNCCS//61mhaBbVfyVD8/v4SirO2EThCxxYGzD4AM5Hp/dH@MJ4v4Zv0sxFaofBsERFF8kApYVGDrLXwTHg5gN2M3Tdi2mx325I@JZUgq@wI4ackwKCClkrw@oqWVCdS2Vp@2/87MzILDnzkdVLBrMyyJ7hCjG7K5@CyXdA9fpOXAFwas6sJdKLrkj@1OZyyjakSYGg1qtoFIxVMnbDykqu1hXVWKniNCX20aFJ9NvqdIDZtXk7j2bRn9X1mNdLJuOyF8BdtV5V@Vex3zWWk6ImsCxtmtlXbXQDXl0Tvk7OPsruLcIGvh7sipJa/Za0PtY4RF9iXYNbgenBxg1kr8uUkhjUw4GyCd4iGO5dqSDAOiAv@BWgAmiPPFYoEnV3cp1myForqaQz/gak7IkodlMniuPDVz/cgPwMYnkXoUUX/8D" rel="nofollow noreferrer" title="Rust – Try It Online">Try it online!</a> The footer contains some compatability implementations because TIO's Rust is a little old. (This has already been <a href="https://chat.stackexchange.com/transcript/message/54872387#54872387">reported</a> and added to the <a href="https://gist.github.com/cairdcoinheringaahing/46f79623ea7b5cfe67286d0a5e96d307" rel="nofollow noreferrer">list</a>.)</p>
<p>Output:</p>
<pre class="lang-rust prettyprint-override"><code>1: 1 [0ms]
2: 1 [0ms]
3: 1 [2ms]
4: 4 [8ms]
5: 10 [35ms]
6: 39 [139ms]
7: 164 [738ms]
8: 767 [4328ms]
9: 3656 [31298ms]
10: 18186 [287871ms]
11: 91532 [3154716ms]
</code></pre>
<p>As you can see, it also reports how long it took. (These are cumulated times.) You can use the <code>-v</code> option to list all tetrahedra for each polytet.</p>
<p>I don't really have a good way of verifying the results beyond A276272(5). I hope it works, but I'm not sure.</p>
<p>The idea is that we store the polytet as a tree of tetrahedra that also encodes orientation. But for collision detection we need actual tetrahedra. We start with the tetrahedron with vertices (-1, -1, -1), (-1, 1, 1), (1, -1, 1), (1, 1, -1) and scale all tetrahedra by 3 for every term. This avoids the need for fractions.</p>
<p>Can probably be made faster, but I don't know how.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/214203/">214203</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




