<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::214203</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>015</td><td>C++ GCC</td><td>251003T124500Z</td><td><a href="https://codegolf.stackexchange.com/questions/214203/gluing-tetrahedra-together/283991#283991">Deadcode</a></td></tr>
<tr d-ix="1"><td>011</td><td>Rust</td><td>201108T231337Z</td><td><a href="https://codegolf.stackexchange.com/questions/214203/gluing-tetrahedra-together/214928#214928">wastl</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C++ (GCC)</a>, <s>12</s> <s>13</s> 15+ terms</h1>
<pre class="lang-cpp prettyprint-override"><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;cstdint&gt;
#include &lt;cinttypes&gt;
#include &lt;array&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;functional&gt;
#include &lt;unordered_set&gt;
#include &lt;chrono&gt;

//#define USE_GMP

#ifdef USE_GMP
#include &lt;gmp.h&gt;
#   if GMP_NUMB_BITS != 64
#   error This is hard-coded for 64-bit limbs
#   endif
#endif

auto startTime = std::chrono::steady_clock::now();

typedef uint8_t TetIndex;
typedef uint8_t TetIndexFace; // lowest 2 bits are used for a face index

#ifdef USE_GMP
class Tetrahedron
{
public:
    mpz_t t[4][3];
    Tetrahedron(const Tetrahedron &amp;_t) : Tetrahedron()
    {
        for (int p=0; p&lt;4; p++)
            for (int d=0; d&lt;3; d++)
                mpz_set(t[p][d], _t.t[p][d]);
    }
    Tetrahedron()
    {
        for (int p=0; p&lt;4; p++)
            for (int d=0; d&lt;3; d++)
                mpz_init(t[p][d]);
    }
    ~Tetrahedron()
    {
        for (int p=0; p&lt;4; p++)
            for (int d=0; d&lt;3; d++)
                mpz_clear(t[p][d]);
    }
};
#else
typedef __int128 Coord;
typedef std::array&lt;Coord, 3&gt; Coord3;
typedef std::array&lt;Coord3, 4&gt; Tetrahedron;
#endif

class Tet
{
    void initFaces()
    {
        faceAttached[0] = NULL; // t[0],t[1],t[2]
        faceAttached[1] = NULL; // t[0],t[1],t[3]
        faceAttached[2] = NULL; // t[0],t[2],t[3]
        faceAttached[3] = NULL; // t[1],t[2],t[3]
    }
public:
    Tetrahedron t;
    Tet *faceAttached[4];
    TetIndex index; // 1-based; 0=unassigned
    Tet(                    ) : t( ) {initFaces();}
    Tet(const Tetrahedron &amp;t) : t(t) {initFaces();}
    void assignIndex(TetIndex &amp;nextIndex)
    {
        if (index == 0)
            index = nextIndex++;
    }
};
class Polytet : public std::vector&lt;Tet&gt;
{
public:
    TetIndex nextIndex;
    void resetIndexing(size_t first) // This function should not be called if the polytet hasn't yet been populated
    {
       &#32;
        for (auto t=begin(); t!=end(); ++t)
            t-&gt;index = 0;
        (*this)[first].index = 1;
        nextIndex = 2;
    }
};

// vertex indices of faces with identical chirality
static int tetrahedronFaces[4][4] =
{
    {0, 1, 2, 3},
    {0, 3, 1, 2},
    {0, 2, 3, 1},
    {1, 3, 2, 0},
};

static int tetrahedronEdges[6][2] =
{
    {0, 1},
    {1, 2},
    {2, 0},
    {0, 3},
    {1, 3},
    {2, 3},
};

#ifndef USE_GMP
Coord3 operator+(const Coord3 &amp;a, const Coord3 &amp;b)
{
    Coord3 c;
    c[0] = a[0] + b[0];
    c[1] = a[1] + b[1];
    c[2] = a[2] + b[2];
    return c;
}
Coord3 operator-(const Coord3 &amp;a, const Coord3 &amp;b)
{
    Coord3 c;
    c[0] = a[0] - b[0];
    c[1] = a[1] - b[1];
    c[2] = a[2] - b[2];
    return c;
}
Coord3 operator*(const Coord3 &amp;a, const Coord b)
{
    Coord3 c;
    c[0] = a[0] * b;
    c[1] = a[1] * b;
    c[2] = a[2] * b;
    return c;
}
Coord dot(const Coord3 &amp;a, const Coord3 &amp;b)
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}
#endif

class TetrahedronOverlap
{
    const Tetrahedron *a, *b;
public:
    void setA(const Tetrahedron &amp;x) {a = &amp;x;}
    void setB(const Tetrahedron &amp;x) {b = &amp;x;}
#ifdef USE_GMP
private:
    mpz_t intersectNumerator, intersectDenominator, uNumerator, vNumerator, uvDenominator, uvNumeratorSum;
    mpz_t center[3], normal[3], tmp[3], p0p1[3], intersectionPoint[3], delta[3], edge1[3], edge2[3];
    mpz_t triangle[3][3];
    void dot(mpz_t &amp;result, const mpz_t _a[3], const mpz_t _b[3])
    {
        mpz_mul   (result, _a[0], _b[0]);
        mpz_addmul(result, _a[1], _b[1]);
        mpz_addmul(result, _a[2], _b[2]);
    }
public:
    TetrahedronOverlap()
    {
        mpz_inits(intersectNumerator, intersectDenominator, uNumerator, vNumerator, uvDenominator, uvNumeratorSum, NULL);
        for (int d=0; d&lt;3; d++)
        {
            mpz_init(center[d]);
            mpz_init(normal[d]);
            mpz_init(tmp[d]);
            mpz_init(p0p1[d]);
            mpz_init(intersectionPoint[d]);
            mpz_init(delta[d]);
            mpz_init(edge1[d]);
            mpz_init(edge2[d]);
        }
        for (int p=0; p&lt;3; p++)
            for (int d=0; d&lt;3; d++)
                mpz_init(triangle[p][d]);
    }
    ~TetrahedronOverlap()
    {
        mpz_clears(intersectNumerator, intersectDenominator, uNumerator, vNumerator, uvDenominator, uvNumeratorSum, NULL);
        for (int d=0; d&lt;3; d++)
        {
            mpz_clear(center[d]);
            mpz_clear(normal[d]);
            mpz_clear(tmp[d]);
            mpz_clear(p0p1[d]);
            mpz_clear(intersectionPoint[d]);
            mpz_clear(delta[d]);
            mpz_clear(edge1[d]);
            mpz_clear(edge2[d]);
        }
        for (int p=0; p&lt;3; p++)
            for (int d=0; d&lt;3; d++)
                mpz_clear(triangle[p][d]);
    }
    bool operator()()
    {
        // Take advantage of the fact that the two tetrahedrons are regular and congruent, and
        // just check if any edge of tetrahedron "a" intersects with any face of tetrahedron "b".
        // Don't count it if only the endpoint of an edge intersects.
        for (int edgeNum=0; edgeNum&lt;6; edgeNum++)
        {
            const mpz_t *p0 = a-&gt;t[tetrahedronEdges[edgeNum][0]];
            const mpz_t *p1 = a-&gt;t[tetrahedronEdges[edgeNum][1]];
            for (int faceNum=0; faceNum&lt;4; faceNum++)
            {
                const mpz_t *normalizedTetrahedron[4][3]; // first 3 points are the face, and the 4th point is for calculating the normal
                for (int i=0; i&lt;4; i++)
                    for (int d=0; d&lt;3; d++)
                        normalizedTetrahedron[i][d] = &amp;b-&gt;t[tetrahedronFaces[faceNum][i]][d];
                // Center coordinates will be multiplied by 3 compared to original coordinates.
                // Get center of face by averaging its vertices' coordinates; the
                // division by 3 is implied by omitting the multiplication by 3.
                for (int d=0; d&lt;3; d++)
                    mpz_set(center[d], *(normalizedTetrahedron[0][d]));
                for (int p=1; p&lt;3; p++)
                    for (int d=0; d&lt;3; d++)
                        mpz_add(center[d], center[d], *(normalizedTetrahedron[p][d]));
                for (int d=0; d&lt;3; d++)
                {
                    mpz_neg(normal[d], center[d]);
                    mpz_addmul_ui(normal[d], *(normalizedTetrahedron[3][d]), 3);
                }
                for (int d=0; d&lt;3; d++)
                {
                    mpz_sub(tmp [d], *(normalizedTetrahedron[0][d]), p0[d]);
                    mpz_sub(p0p1[d],                         p1[d],  p0[d]);
                }
                dot(intersectNumerator  , normal, tmp);
                dot(intersectDenominator, normal, p0p1);
                int cmp = mpz_cmp_ui(intersectDenominator, 0);
                if (cmp == 0)
                    continue; // edge is parallel to face, which we don't count as an overlap
                if (cmp &lt; 0)
                {
                    mpz_neg(intersectNumerator  , intersectNumerator  );
                    mpz_neg(intersectDenominator, intersectDenominator);
                }
                if (mpz_cmp_ui(intersectNumerator, 0) &lt;= 0 || mpz_cmp(intersectNumerator, intersectDenominator) &gt;= 0)
                    continue;
                // These coordinates are all multiplied by intersectDenominator
                for (int d=0; d&lt;3; d++)
                {
                    mpz_mul(intersectionPoint[d], p0[d], intersectDenominator);
                    mpz_addmul(intersectionPoint[d], p0p1[d], intersectNumerator);
                }
                for (int i=0; i&lt;3; i++)
                    for (int d=0; d&lt;3; d++)
                        mpz_mul(triangle[i][d], *(normalizedTetrahedron[i][d]), intersectDenominator);
                // Check if the intersection point is inside the triangle
                for (int d=0; d&lt;3; d++)
                {
                    mpz_sub(delta[d], intersectionPoint[d], triangle[0][d]);
                    mpz_sub(edge1[d], triangle[1][d]      , triangle[0][d]);
                    mpz_sub(edge2[d], triangle[2][d]      , triangle[0][d]);
                }
                mpz_mul   (uNumerator, delta[1], edge2[0]);
                mpz_submul(uNumerator, delta[0], edge2[1]);
                mpz_mul   (vNumerator, delta[0], edge1[1]);
                mpz_submul(vNumerator, delta[1], edge1[0]);
                mpz_mul   (uvDenominator, edge1[1], edge2[0]);
                mpz_submul(uvDenominator, edge1[0], edge2[1]);
                cmp = mpz_cmp_ui(uvDenominator, 0);
                if (cmp == 0)
                    continue;
                if (cmp &lt; 0)
                {
                    mpz_neg(uNumerator, uNumerator);
                    mpz_neg(vNumerator, vNumerator);
                    mpz_neg(uvDenominator, uvDenominator);
                }
                if (mpz_cmp_ui(uNumerator, 0) &lt;= 0 || mpz_cmp_ui(vNumerator, 0) &lt;= 0)
                    continue;
                mpz_add(uvNumeratorSum, uNumerator, vNumerator);
                if (mpz_cmp(uvNumeratorSum, uvDenominator) &lt; 0)
                    return true;
            }
        }
        return false;
    }
#else
public:
    bool operator()()
    {
        // Take advantage of the fact that the two tetrahedrons are regular and congruent, and
        // just check if any edge of tetrahedron "a" intersects with any face of tetrahedron "b".
        // Don't count it if only the endpoint of an edge intersects.
        for (int edgeNum=0; edgeNum&lt;6; edgeNum++)
        {
            Coord3 p0 = (*a)[tetrahedronEdges[edgeNum][0]];
            Coord3 p1 = (*a)[tetrahedronEdges[edgeNum][1]];
            for (int faceNum=0; faceNum&lt;4; faceNum++)
            {
                Tetrahedron normalizedTetrahedron; // first 3 points are the face, and the 4th point is for calculating the normal
                for (int i=0; i&lt;4; i++)
                    normalizedTetrahedron[i] = (*b)[tetrahedronFaces[faceNum][i]];
                Coord3 center = {{0, 0, 0}}; // multiplied by 3 compared to original coordinates
                // Get center of face by averaging its vertices' coordinates; the
                // division by 3 is implied by omitting the multiplication by 3.
                for (int p=0; p&lt;3; p++)
                    for (int d=0; d&lt;3; d++)
                        center[d] += normalizedTetrahedron[p][d];
                Coord3 normal;
                for (int d=0; d&lt;3; d++)
                    normal[d] = normalizedTetrahedron[3][d] * 3 - center[d];
                Coord intersectNumerator   = dot(normal, normalizedTetrahedron[0] - p0);
                Coord intersectDenominator = dot(normal,                       p1 - p0);
                if (intersectDenominator == 0)
                    continue; // edge is parallel to face, which we don't count as an overlap
                if (intersectDenominator &lt; 0)
                {
                    intersectNumerator   = -intersectNumerator;
                    intersectDenominator = -intersectDenominator;
                }
                if (intersectNumerator &lt;= 0 || intersectNumerator &gt;= intersectDenominator)
                    continue;
                // These coordinates are all multiplied by intersectDenominator
                Coord3 intersectionPoint = p0 * intersectDenominator + (p1 - p0) * intersectNumerator;
                Coord3 triangle[3];
                for (int i=0; i&lt;3; i++)
                    triangle[i] = normalizedTetrahedron[i] * intersectDenominator;
                // Check if the intersection point is inside the triangle
                Coord3 delta = intersectionPoint - triangle[0];
                Coord3 edge1 = triangle[1]       - triangle[0];
                Coord3 edge2 = triangle[2]       - triangle[0];
                Coord uNumerator = delta[1]*edge2[0] - delta[0]*edge2[1];
                Coord vNumerator = delta[0]*edge1[1] - delta[1]*edge1[0];
                Coord uvDenominator = edge1[1]*edge2[0] - edge1[0]*edge2[1];
                if (uvDenominator == 0)
                    continue;
                if (uvDenominator &lt; 0)
                {
                    uNumerator = -uNumerator;
                    vNumerator = -vNumerator;
                    uvDenominator = -uvDenominator;
                }
                if (uNumerator &lt;= 0 || vNumerator &lt;= 0)
                    continue;
                if (uNumerator + vNumerator &lt; uvDenominator)
                    return true;
            }
        }
        return false;
    }
#endif
};

void attachNewTet(Tet &amp;t, Tet &amp;tetToAttachTo, const int faceNum)
{
#ifdef USE_GMP
    mpz_t *newVertex = t.t.t[0];
    // Get center of face by averaging its vertices' coordinates.
    for (int d=0; d&lt;3; d++)
        mpz_set(newVertex[d], tetToAttachTo.t.t[tetrahedronFaces[faceNum][0]][d]);
    for (int p=1; p&lt;3; p++)
        for (int d=0; d&lt;3; d++)
            mpz_add(newVertex[d], newVertex[d], tetToAttachTo.t.t[tetrahedronFaces[faceNum][p]][d]);
    // Finalize the new vertex
    for (int d=0; d&lt;3; d++)
    {
        mpz_div_ui(newVertex[d], newVertex[d], 3);
        mpz_mul_ui(newVertex[d], newVertex[d], 2);
        mpz_sub   (newVertex[d], newVertex[d], tetToAttachTo.t.t[3 - faceNum][d]);
    }
#else
    Coord3 &amp;newVertex = t.t[0];
    newVertex = {{0, 0, 0}};
    // Get center of face by averaging its vertices' coordinates.
    for (int p=0; p&lt;4; p++)
    {
        if (p == 3 - faceNum)
            continue;
        for (int d=0; d&lt;3; d++)
            newVertex[d] += tetToAttachTo.t[p][d];
    }
    // Finalize the new vertex
    for (int d=0; d&lt;3; d++)
        newVertex[d] = newVertex[d]/3 * 2 - tetToAttachTo.t[3 - faceNum][d];
#endif
    // Copy the other vertices
    for (int p=0; p&lt;3; p++)
    {
        int p1 = tetrahedronFaces[faceNum][p];
        for (int d=0; d&lt;3; d++)
#ifdef USE_GMP
            mpz_set(t.t.t[1+p][d], tetToAttachTo.t.t[p1][d]);
#else
            t.t[1+p][d] = tetToAttachTo.t[p1][d];
#endif
    }
    t.faceAttached[0] = NULL;
    t.faceAttached[1] = NULL;
    t.faceAttached[2] = NULL;
    t.faceAttached[3] = &amp;tetToAttachTo;
    tetToAttachTo.faceAttached[faceNum] = &amp;t;
}

// First two tetrahedrons are implied. Each element is a subsequent tetrahedron, with the value indicating where
// it's attached. The lower 2 bits indicate which face (can only have 3 different values, because at least 1 face
// will always already be attached). The remaining bits indicate which tetrahedron (which can never be zero,
// because that one is attached implicitly).
class CompressedPolytet : public std::vector&lt;TetIndexFace&gt;
{
public:
    void append(Polytet &amp;polytet, Tet &amp;tetToCompress, int vertexMap[4], int faceRotation)
    // indices of vertexMap[] are compressed-output vertices; elements of vertexMap[] are the original vertices of tetToCompress
    {
        tetToCompress.assignIndex(polytet.nextIndex);
        for (int _faceNum=0; _faceNum&lt;3; _faceNum++)
        {
            int rotatedFaceNum = (_faceNum + faceRotation) % 3;
            int faceNum = 3 - vertexMap[3 - rotatedFaceNum];
            if (!tetToCompress.faceAttached[faceNum])
                continue;
            Tet *attachedTet = tetToCompress.faceAttached[faceNum];
            attachedTet-&gt;assignIndex(polytet.nextIndex);
            push_back((((TetIndexFace)(tetToCompress.index - 1)) &lt;&lt; 2) + _faceNum);
           &#32;
            int attachedFace = 0;
            while (attachedTet-&gt;faceAttached[attachedFace] != &amp;tetToCompress)
                attachedFace++;
            int vertexMap2[4];
            int rotation = 0;
            while (vertexMap[tetrahedronFaces[rotatedFaceNum][rotation]] != tetrahedronFaces[faceNum][0])
                rotation++;
            vertexMap2[1] = tetrahedronFaces[attachedFace][0];
            vertexMap2[3] = tetrahedronFaces[attachedFace][1];
            vertexMap2[2] = tetrahedronFaces[attachedFace][2];
            vertexMap2[0] = tetrahedronFaces[attachedFace][3];
            /*if (faceNum == 3)
            {
                int tmp = vertexMap2[3];
                vertexMap2[3] = vertexMap2[2];
                vertexMap2[2] = tmp;
            }*/
            append(polytet, *attachedTet, vertexMap2, rotation);
        }
    }
};

namespace std
{
    template&lt;&gt;
    struct hash&lt;CompressedPolytet&gt;
    {
        std::size_t operator()(const CompressedPolytet &amp;polytet) const noexcept
        {
            std::size_t seed = polytet.size();
            for (auto i=polytet.cbegin(); i!=polytet.cend(); ++i)
                seed ^= std::hash&lt;uint32_t&gt;{}(*i) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2);
            return seed;
        }
    };
};

int main(int argc, char *argv[])
{
#ifdef USE_GMP
    Tetrahedron start;
    for (int d=0; d&lt;3; d++)
    {
        mpz_set_si(start.t[0][d], -9);
        for (int p=1; p&lt;4; p++)
            mpz_set_si(start.t[p][d], 9);
    }
    for (int p=1; p&lt;4; p++)
        mpz_set_si(start.t[p][p-1], -9);
#else
    static Tetrahedron start =
    {{
        {{-9,-9,-9}},
        {{-9, 9, 9}},
        {{ 9,-9, 9}},
        {{ 9, 9,-9}}
    }};
#endif

    TetrahedronOverlap overlap;

    auto *polytets = new std::unordered_set&lt;CompressedPolytet&gt;;
    polytets-&gt;insert(CompressedPolytet()); // add empty vector as the starter polytet (meaning it has two tetrahedrons)
    size_t prevPolytetCount = 0;
   &#32;
    size_t blahNum = 0;

    for (int tetCount=1;;)
    {
        auto currentTime = std::chrono::steady_clock::now();
        size_t polytetCount = polytets-&gt;size();
        std::cout &lt;&lt; tetCount &lt;&lt; ": " &lt;&lt; polytetCount &lt;&lt; " [" &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(currentTime - startTime).count() &lt;&lt; " ms]" &lt;&lt; std::endl;
        if (prevPolytetCount &gt; polytetCount)
        {
            std::cerr &lt;&lt; "Quit due to apparent overflow" &lt;&lt; std::endl;
            break;
        }
        prevPolytetCount = polytetCount;
        if (++tetCount &lt;= 2)
            continue;
        /*if (tetCount &gt; 6)
            break;*/
       &#32;
        Polytet polytet;
        polytet.reserve(tetCount); // Important, to ensure pointers don't change
        Tet &amp;t0    = polytet.emplace_back(start);
        attachNewTet(polytet.emplace_back(), t0, 3);

        auto *newPolytets = new std::unordered_set&lt;CompressedPolytet&gt;;
        polytet.resize(tetCount);
        for (auto basePolytet=polytets-&gt;cbegin(); basePolytet!=polytets-&gt;cend(); ++basePolytet)
        {
            int tetNumToUncompress = 2;
            for (auto elementToUncompress=basePolytet-&gt;cbegin(); elementToUncompress!=basePolytet-&gt;cend(); ++elementToUncompress)
            {
                int faceNum          = *elementToUncompress &amp; 3;
                int tetNumToAttachTo = *elementToUncompress &gt;&gt; 2;
                Tet &amp;tetToAttachTo = polytet[tetNumToAttachTo];
                attachNewTet(polytet[tetNumToUncompress++], tetToAttachTo, faceNum);
            }
            if (tetNumToUncompress != tetCount - 1)
            {
                std::cerr &lt;&lt; "Error! Got " &lt;&lt; tetNumToUncompress &lt;&lt; ", expected " &lt;&lt; tetCount - 1 &lt;&lt; std::endl;
                exit(-1);
            }

            Tet &amp;newTet = polytet[tetCount - 1];
            for (int tetNumToAttachTo = 0; tetNumToAttachTo &lt; tetCount-1; tetNumToAttachTo++)
            {
                Tet &amp;tetToAttachTo = polytet[tetNumToAttachTo];
                for (int faceNum=0; faceNum&lt;3; faceNum++) // skip last face because it's always already attached
                {
                    if (tetToAttachTo.faceAttached[faceNum])
                        continue;
                    attachNewTet(newTet, tetToAttachTo, faceNum);
                    // Canonicalize the rotation of this new polytet in compressed form, so that it can be compared against others
                    bool haveRunningLeast = false;
                    CompressedPolytet runningLeastPolytet;

                    Tet *t = &amp;polytet[1];
                    for (int i=0; i&lt;tetCount; i++)
                    {
                        int attachedFace;
                        int vertexMap[4];
                        {
                            Tet &amp;singlyAttachedTet = polytet[i];
                            for (int j=0; j&lt;3; j++)
                                if (singlyAttachedTet.faceAttached[j])
                                    goto skipThisTet; // not a singly attached tet
                            t = singlyAttachedTet.faceAttached[3];
                            attachedFace = 0;
                            while (t-&gt;faceAttached[attachedFace] != &amp;singlyAttachedTet)
                                attachedFace++;
                            static int vertexMapTable[4][4] =
                            {
                                {3, 0, 2, 1},
                                {2, 0, 1, 3},
                                {1, 0, 3, 2},
                                {0, 1, 2, 3},
                            };
                            memcpy(vertexMap, vertexMapTable[attachedFace], sizeof(vertexMap));
                        }
                        for (int rotationStep=0; rotationStep&lt;3; rotationStep++)
                        {
                            polytet.resetIndexing(i);
                            CompressedPolytet newRotatedPolytet;
                            newRotatedPolytet.reserve(tetCount - 2);
                            newRotatedPolytet.append(polytet, *t, vertexMap, rotationStep);

                            // Update the running "least" rotation
                            if (!haveRunningLeast ||
                                std::lexicographical_compare(
                                    newRotatedPolytet  .begin(), newRotatedPolytet  .end(),
                                    runningLeastPolytet.begin(), runningLeastPolytet.end()))
                            {
                                haveRunningLeast = true;
                                runningLeastPolytet = newRotatedPolytet;
                            }
                        }
                    skipThisTet:;
                    }
                    if (auto [insertedItem, wasInserted] = newPolytets-&gt;emplace(runningLeastPolytet); wasInserted)
                    {
                        // Check for overlap between this newly attached tetrahedron and the existing ones,
                        // and defer this until after the deduplication, to save a lot of time
                        overlap.setA(newTet.t);
                        for (auto tetCheckIntersection=polytet.cbegin(); tetCheckIntersection!=polytet.cend(); ++tetCheckIntersection)
                        {
                            if (&amp;*tetCheckIntersection == &amp;tetToAttachTo || &amp;*tetCheckIntersection == &amp;newTet)
                                continue; // skip this check for speed (it'll always be false anyway)
                            overlap.setB(tetCheckIntersection-&gt;t);
                            if (overlap())
                            {
                                newPolytets-&gt;erase(insertedItem);
                                break;
                            }
                        }
                    }
                    tetToAttachTo.faceAttached[faceNum] = NULL;
                }
            }

            polytet[1].faceAttached[0] = NULL;
            polytet[1].faceAttached[1] = NULL;
            polytet[1].faceAttached[2] = NULL;
        }

        delete polytets;
        polytets = newPolytets;

        for (int p=0; p&lt;4; p++)
            for (int d=0; d&lt;3; d++)
#ifdef USE_GMP
                mpz_mul_ui(start.t[p][d], start.t[p][d], 3);
#else
                start[p][d] *= 3;
#endif
    }
&#9;return 0;
}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=7Txdc9w2ks-nXwErdcrMaEaeD5c31mhUlXiTlKuSrC-R70U3N8UhIQ1tDsklQcmKrHu8P3Ev-3KP-7a_5n7NdeOLAAFyRnacva06VGJxwO5Go9FodDcA_tdfwzypSvx_dR2Gf7s8HJUsWoTHx9Px4fBw9Kfp4fIv_12xq9FX__Nv__lFnIZJFVFyBkBxdrI5P6ir4qxkBQ22Zh3UxOm1DRcibsqsKvjN7nJampVBUQR3VkVynRUx21gt3NCQZYVZk8SlRfyqSkMWZ2mQmLVVmhURLWi0KqnNy6bI0uz84ODp0y8iehWnlLz55dvV9z--PgCoK6jSv2uk623OO0kIia8IvFv99ObHb1bfvLr4hTxZkOfP-CtaFFlBLjZxSeC_TVBEozCLaESuoPr5s9E6ZiSJt-tSQKdRfHXwhfhzEFQsIyULCnYRbylZwHN0eiqYPT0tGQ2iu1WYZOG709M0u-315wcHKFLktwLxfrVi5IKyV2lE389b33wXhHROnj4lSXZLS0amBHgqSVBQUpWS0YBcARSJEd4RSZgEZYnkimBDI2Du4P4gr9ZJHJ4eQJ_INv8VmmOXz5aXs-WcVxnAvTBLS2bWkKMV65NTC6jP0e75v1iQqR50hOSL8ZzkZ8_gn-Pjvn5vwUQIE53N4J8mjOIPFKLHLvPlZbQckhU7kc99we6Dw_Tn5idOY82QxcR__J5chAkNCoeNhzloaFJSrVErYJdNpl-RlxlMsFrTuLryKX3G3wzJ7FzAzNqBZkPy7NyU9VzPB61oB6LLN1kcEZQUqnDpSgNqv2YsCIHO5XgJ8-enNz_8wFWdwe8hu5zgP9OlH2PSijFrwZj6MKZdGLMGxqSJ8WDNJHOSMD2TyMCi-ayeY3x-i1nLG5iM1gFM6TkZL6oUZBlfpzRSwL2mBmDBeQhv-uTekPNczwff5GUCh3lx-JCJljlzPc3lUUrfi8fmOIJ17fE-kMWCjG1NlfVEIx8fG2oqFOZ1ltwxENMpEbIUKicWkbMLXAnum1IWLGmi85r3gpbyNSxyvTL-lYJtu4qLEvoLEuaGXq0-pNxkVRKRNGNkTUkYJAnYU-gO21CSS642QZl-ycgdRRiaQn1eJQGT41JLwZ7kfGlgizW9jsEMzAl7soBJgk_Hx8wWERudKymN5_pNb8CA1f4lZ315oiAmNYTuPVRPDaHCIkluaMGEZsUwuiS74mpdkltYqkkc0ZTF0FsSbuIiSGJ2dwCrGFQRtDusVhauG7guPIN5ICf1_XhIJkMyBWPxMNQ1M1Fp1ExFpaqZ8J9QOYYa5NLf4rfRNbT4fMnnqtmiQUe3IqlpHsy2DJiZbBGWxdRcF4U5I1lOiwBU7VhOFll9FAyJXbHuS4ZkRSiEHgrbFeCfY7KGP6p-Iuonon6i66eifirqp7K-oKwqUqT60GRt9BuwNmphbdTC2mg_1gadrJE9GBuQtcuVUVmzpCsdfkiUsb1lJLGx8cFajBq2OViLkcKmBqLvD-7SphT1TzDFkiCXJF0zO4D2B8Cuabi4gQLz9LXPLL8HexxAT4_em6YYoL9pg14r6Ia_lxfxDRgo07mDWUaLEizqT9VWjNuwrvsjTbNtnIrayoC4MZ6rGxusfvdLtZ0bTYUU6cL6OAS7WmyDhD-ybc7_5uN8wh9062CHX2fwi9dGNGEBf6JgCCb6aao9U-msFnGQXicUqvUbLi_UAwFyBCtBlTClBaJyJYhbVWuoai5p-GpbJWiHFZkV6ssQwcfK1VKQQRQBsAk5EZCT3ZBTATmt3bcWh0IqnONFKW-07H3mQR5yR8jo0C5PtebR5LMnFSQyZWMBSLVpB0Blan_LVaz9tat47bBCHdvfCyXtfj-13z-0BgOz3yQkUROjOzLpUiYeVPwjaJOIfrrUSUB06ZOMoNoUSrxu1yjxfk-VEsAdOiUAOpSqBvjdtEoKqF2t1lmWaG-g13dUCp3u4B0lQXQTpCy4puiNooMNHikY8k3A-C92m5l-oMhvFPQafO2CBGmENvu6qGCwh_jTJP-2AmMOoVX4Dn33IL3jSwZvxlgyD4PDWn-lJ4ywPHHShF0fnpgt_DHDECDMKpBZzLCVLE3uON_gH-Q45EgiSEXLdTMn7rggBEwElLx8PHuuH9sV3lyyBvkYXaLRObt0XGdJaAmr1HLeQWGym8KkSUH3AWUm-yAfMZUhH5uadO_olcWJmJ0Qp0WGfZK5KJQ9D4DIjHApC7WQ2kO5JvBfz2AwxTBgeAdsQnQTYpgGQSAHEK04nOgexdiXGHsR-2aCBbtj1qji71iMEwgdt3VD-CLWkjJcAhwCzh3qIJGX3OKBFMGvRePK47okwRAWnAsW50kMYez6DoQWZtscJAZCykhWxBCMYtRXI5746H9PlRenAkckFsCSEVyjPDH7iAEmhpZfmtTmKGofxSi-iUsMuDlTmGrdaiZhgWB6mBT_YcAUuMviYwZC5Q71KgFeec8_MmNu2vquyA2TOmkzqR-rJNIpNPnbg9V8J6s7mnfnpGImpdf1gmkw42nM4B_GbVXFJmIb6zPOOgTlHoIPn6E_ZbXG5Z3sMfQYnXT3FIlJZ2Dog-FFvW4j5vYSgxbX3SJERVA8fPJQsvAsX0vhIbMeRJRoCEJZiCV-m-Pg-SmNfehXpMfRnXSfKmDhYU5XYt9CrIklAUuEGbYEjZEw37ebONyQWwo9qRfYoMSFNJPxdVvbZ76mu9XaL2JfbYcKWIQsSflq9xp-7JJvHAxXetwnZyBs8uGDGrG9_fM-Od89TD6jfbGhJbVWGVx7YQQbq4yv0c8wkTFu9jnactbuLX9FT4bibSTlLHal_Di7Jf2K2W_oVyhhaJ88XnYat1gatz3lgw6G8qVxSTYFVPtYcVrGkfDEFB-fyXireMmXMsJaLYbxcrfxVrGVgTbhDhkvH0FsahObPoqYqzdG3smMqoUMJjoZNvZRk2yhari4Y407acOV7d604k7acWW7Lu5E47byrPprZwtUg3t32Ye-o9fOEtgg8olr32-5dpkjWnXZIhPpxpuY2YHkZG0-cTmrOpcxhLhxIR4rWeVGN3NM_tRUy7CqldUhYonAP3pY5L4CK5oc1jKqnyTwVZCUVKVTxK69mf_9_-TK75JckVtEPK3SGwT9x6RVFO5kN-5nS6iYW0NeJ-D_VialzU_hElz3u7Mi7txVW4siZbEg97gZjP89PPB-PzYp8g-dE-lI-zqwezqcOgdAjhctY5f7k1VyZATOx2crsOjUAmnjgWcWyACEOapZbuHJG_UBZYyoVezclioA8rnPM2gQNtaMBmF_AQPSQlicr_GR_TvF315mHuHUtAh_5Nb7XZUWGY989ft6LB6elKvieQUhtTec-jtH2XK-OYESCAfWtoFfcMekp3TPBOkYA9mMsQnfMbf3iICNSLZ1dsfLFv4_ZwQrO8pDGbLwyHVkBnmtguLBCOAbMacE2B9_auJPH4NvOMFoiGRYNlBhFdBQYd5AxUptlG5cShJrIo4SWdQnXTzd2HNX0TDZUjQ62MKZ2yD1kXGZTeURxsyS7qjaYbosCY5udkA3pTSyKvY1bZVr0m7sqo8SWE3i2KLXiJc-V6jEz2XhsT5xZJWfrv2J3uKhVzxzewShjPhL2UUmDt9eZOroj-Fz46mwxgEqbELtTtLbfxVnKWH6neC5c6XTn-IUCv9tl_uj9q40DyLXZPaHc9TuLo-XRuZp1zbWPt6YirNtlj6ewdxkECT6HfriYPpFpEFv5UHWneKyT7CAa813ozqYNLefZBJqF8q0gVJWa3h6pCjQOdW9N05SiNAfn9VxxYbmab0z681I57dWSs8VhVrKaAB4Dszoj60prvHYR79M8WG00RCgGWc8fKrOOO0trJ9PZ-BwTHGFbfDQGEJ9_UGy8zLLRfIig38KLWqvcGd-4SIA9xc65s1uuXqMWtOyCIs2OZb3alx1zSdSS2v9VMXAJJ6BmjiyEQPGTlquffjeTjrfTjvf8qsbtvWXcBarFo6SL8fE478HXL8wbeJNocmQ_YR8C_iEJnRLhXMZELAOJf0zptRMtKFIjaF63ARJRcUJfZFcuQV1odhgzL4s5YKGtCFC4Fe_CnXzS-JQGb7xKd4LMWbDvNkGpjpMS5D6FdCD5nlD5ZCsaRhUEGsEjCQ0gC5NOCq2yI-PBMltcAcNJwXeW8PTJIqHvmCioNsgTpFVHxtmiq8nqpCnlMIMQGK_0iIbYmOKD56dzFIemqqWhETDmCV3_RN56Pplts0LWpY02nVRRF-Xa94YES5CnuMVDEXkSF7wMN0E1RTfa5J25Mcgv3wmdp-4vH7OGE_E9NWENy5Z1BhLrh-hZn2UVSyvmDYHc6UtXjxuPlRmSqHIPGrNZcNsWO9OzDs8sqcn9Q0ej_VYGTlI9Yy2ZOXJQtqeMGIXKBUafSdgMZGn8MA7tMRG_pnM5g7-lUZE81rLA3_ZtBtRAK5ET-yue6e064f63Vt-X0upI_5YkD2o2zQM9NH5vgOBJa_KzWodhO96UEyF7vdsJsR1oBGZ9Pvk7AxcE5CyEniDpiNqxR3Ste8cYYGZm4A5sbpgddlEX-JFWnvquHI2EdTtL5MfPdhTfTXO0SyM3NtYrZXFWS8bmnOpaC05411-s9sNhdvsgsH-ZOlbtC2BOSGxgT7bA70ZBBvo0z3Qp-3o4z3Qm4mepwOcfnruwuTdtVPBr3vxbVer426I2ZSL1dFOcCGHbd4ILAdP7TkqVgO9CJhzfmiQG-qBd45bi9t2abClZY5zCVYjeR2IUVjGQPPOzvnPEuLckN8k3Jw5q9l5w4zzNU3eWzR2_tRdpuZaqJaxvoxs04y-D2nOWmy1Sb2ksOAu1EXHE6ztNYxHfZcxXii4UF9qjJ_Ulfp2Y-xOHd7Qv8vr8VwKeMd9Nl2x8_uH3iBG6zV-_4LO_vCHF-sXmJDkGGDYnvf1r_NzKwLDIhMD-NoZmzkfHFQ3dFr4ChcU1-GQhJuggNEurm8uly2xv7mdxq_3NwLonQEo-NarMu5xXB66cfd69MK37spo3HcV3ENKeuovdOC4Dy0_nXw0UUzV3r28lelIgCxEN-t-3t-PXgz5fw_yrqWuJfifXUs4rKeWCAqiNw_1XfLGOMgLK2pbYi4AuGYOpA6WIoATWmZ9SsIz6YT4FCbewC1hyvccwF6_z_dQgigiMKnZHRHuJu6SoJfGhQMOrrot3NvSIBVhNs53J2wQgyInIDR1I9t5ybde9BJnQq2TYCNco7Hsth5vhQjDPm_qIZdNWBUYA-z9eQo9YyWDNnO1uJq2QlAGHxcnrcaA58NTcoh_LUpYTy55vcVSVBXc0q5CCE_OrFdbiFDikoKNi8rzntmtUf0Fjv4J38Hq9UUL23JZtwFqZexA8vxFU_rnFpdt3q5gixYFb-RfKhjoCAI5EDYsKQGPuFBJryBka2sdyxqirHdNq8V10lUKky27D8fHtVAXYB93pGAQxejupIHQ4Ek_qLVG8lFDKOuPl-6LG6ppiznzaptnBQvwUAlIh6ZlVVCx_0KLUm05boL0uk4siFBsjI_1wsQX05AKx5gPtqF5VuLXi9GH5sci42dPDkzuvv5o29HoP06Iuvu2meet4ZcdJIVFPZHqxdR4_8QE0AurAdAVicFrsBYX2ZtURZ_19wFcrmQUaoIvjIZMBj2gTxqwmlcP7D6eofIkdVmQgYcUOWqGkM3Oq_ROGwF0JlwK7n5BrYWXTdIeJ9Sni5fueBwfN3NtQ-KP3ez9HDl7m6MrIhkxpzEi3CFn2359i58_ekK-z5iw0x76CDYk9H0OCx_4YYeWiYcGO4wcFvo-Zr1R8xbCw4H1k0s-5YKzRa5baTs55RlxcM6c2prl0cR9vdcJq09Sja6TXjPzpBcazvJdnJMEU3QifS8TZiIvaGfpVNTiNNhy8kKo0K78Z8dZoNY9QSzWBBDDuaemq4IJ9CDNUvw8icrp6wwAP9sYl9xSK4crTo0sG4p5OyRlJpKLsDRjCnJN6yNfwTVEAyBYnpx3T3ph4WcuMYv6c5WiK_cDT5YuzP3HZnHDssLAfa2WTS8uTzghfRXJeTe6sTSPVGiXoP1khV8LsDQzQf4mFaSZCm2HbG9NdfSoBKEkd19b-TXV77iDNBbd_7fY_7c4b952nVvTHQCld9q1Ff9th8qb5TrDL77B9MTvCAEV7ufg54MCIlqoM9nQo06S2PMdXPnyImbpzuQ1i0yX7c7nOVztlk1Xjq9ZjA__aLW6CNYJ1R8a6sLu1jEOMeN7otP6o0Gd0FMObXwyqBN6wqFn9UeIOqGdTyW1lYdukW3pNszv6kznsCk5axCHPHzLrmp431VR3XTrGz3flAH-hVG-cWn-xllo_u6akN1jZwYT9Re84g7WsbimF1aHn0Xe93UzXvEVB9yJZsD9aGaedhNx8otmVnFoiazfsjKoAibmTR7hThtfDcXKQg75Jt6hptRJgu-SOGvahw87VZg7dgkMRZhdF0G-wXV5JVfT3l4m0xENIScyphh6X_IgYvfkwuJZZWvavpecdr_bnu22MB7nwD3JtCe_IvB8jMK2T1j_G2O5OvVT9uOhzvAY8VIkx2j0ilHwrm6D8pWskGcmXutoVQbePU9HIS40MB_rrugznWiUZBIQHDt2i5_kU05hY_nVGUx1twHUuORb7VlKy3YNw3QfYET0ihaCNhiBOCHBFeMVFF5FlT6Rz7MbJe66ByTJ-F0VFm_dw6SqSO5P-IfAhJN8wjrsi_E9QTBIKIRXxjlUT1reB-bL1PvgPtZ4o7IcDXwUcVuoETl9-EA6YIVIdvsc1hl3HjLxsQq1mpQ57hv0IGyqTzesqfDj8XYSVHS3YozUNz0fv6PzroFTcsnUx5Y-1e7YU60IStozp-YOVrA0Mny-8ljz4q_dI8i0Du-0U2xkCuogqfMg0S7wyePApy64wVdEE8r0F0NLJz9Y2mbSWO4_5YPAHee7sBinGhubR42fM-_xLiwcUICRwQJzbtZxrn-S-28QdzyIz5HLr5L_Rf79Xw" rel="nofollow noreferrer" title="C++ (GCC) – Attempt This Online">Attempt This Online!</a></p>
<p>This matches the output of wastl's program up to 12 terms, and does so much faster (<s>62</s> <s>65</s> 2600 times faster on my machine).</p>
<p>Certain design elements were quite natural and are shared between both our programs – namely, the use of 128-bit integer coordinates, the coordinates of the starting tetrahedron, and multiplying all coordinates by 3 for each successive term. The remaining details are implemented from scratch though, without consulting wastl's program.</p>
<p>The fact that both versions of my program agree with wastl's up to <span class="math-container">\$A276272(12)\$</span> strongly suggests that they're all correct up to that point (and beyond it by using larger integers), and that the OEIS entry can finally be updated.</p>
<p>My previous version used affine transformations to rotate each polytet for comparison and deduplication. I wanted to keep that version up, rather than relegating it to the edit history, but the 65536 character limit prevented that.</p>
<p>This new version does its rotations entirely while remaining in tree representation, using Cartesian coordinates only to check for overlaps between tetrahedrons.</p>
<p>Compared to the previous affine transform version, it's 32 times faster when both are in <code>USE_GMP</code> mode. In basic 128-bit integer mode, it's 40 times faster. In both modes, it uses about 32 times less RAM than the affine transform version (about 27 times less RAM than wastl's program).</p>
<p>It does deduplication by serializing the tree representation with every possible choice of singly-attached tetrahedron as its root node, doing 3 rotations of each, and choosing the serialization that is lexicographically least for hash-table comparison against polytets that were previously identified as unique using the same method.</p>
<p>As such, it's conceptually similar to the previous version – both take advantage of the fact that all polytets have some tetrahedrons that are attached on only one face, because due to a tetrahedron's dihedral angle being irrational, a polytet can never curve around and attach to one of its own faces.</p>
<p>So, the computationally expensive affine transformation is replaced with a tree re-rooting. This operation now being very fast, it can do a new optimization: Delaying the tetrahedron overlap/collision checking until after deduplication, so that a provisionally new polytet won't be checked for overlaps just to find that it's a duplicate.</p>
<p>The timings shown in the output are cumulative.</p>
<p>Output in basic 128-bit integer mode:</p>
<pre><code>1: 1 [0 ms]
2: 1 [0 ms]
3: 1 [0 ms]
4: 4 [0 ms]
5: 10 [0 ms]
6: 39 [0 ms]
7: 164 [2 ms]
8: 767 [13 ms]
9: 3656 [78 ms]
10: 18186 [455 ms]
11: 91532 [2775 ms]
12: 468203 [17162 ms]
</code></pre>
<p>Output in <code>USE_GMP</code> (GNU Multiple Precision Arithmetic Library) mode:</p>
<pre><code>1: 1 [0 ms]
2: 1 [0 ms]
3: 1 [0 ms]
4: 4 [0 ms]
5: 10 [0 ms]
6: 39 [2 ms]
7: 164 [12 ms]
8: 767 [72 ms]
9: 3656 [399 ms]
10: 18186 [2288 ms]
11: 91532 [13316 ms]
12: 468203 [78887 ms]
13: 2417722 [467574 ms]
14: 12595984 [2817342 ms]
15: 66068726 [16595584 ms]
</code></pre>
<p>In this <code>USE_GMP</code> version, it is no longer possible for calculations with Cartesian coordinates to overflow. As such, it could in theory keep going up to <span class="math-container">\$A276272(63)\$</span> given enough time and RAM, at which point it would no longer be able to serialize polytet trees at 1 byte per tetrahedron.</p>
<p>There's still plenty of room for further speed-ups, such as adding multithreading, and applying various more specific optimizations. Disk storage and merge-sorting could be used to do away with the RAM limit, allowing time to become the only limit.</p>
<h2>Output from the affine transform version</h2>
<p>The version uses about 20% more RAM than wastl's program.</p>
<p>In basic 128-bit integer mode:</p>
<pre><code>1: 1 [0 ms]
2: 1 [0 ms]
3: 1 [0 ms]
4: 4 [0 ms]
5: 10 [2 ms]
6: 39 [10 ms]
7: 164 [53 ms]
8: 767 [296 ms]
9: 3656 [2350 ms]
10: 18186 [15845 ms]
11: 91532 [106165 ms]
12: 468203 [683449 ms]
13: 2417721 [4291118 ms]
14: 663520 [4734026 ms]
</code></pre>
<p>The 128-bit math is clearly overflowing beyond <span class="math-container">\$A276272(13)\$</span>, and as the version below shows, that value itself is also incorrect.</p>
<p>In <code>USE_GMP</code> mode:</p>
<pre><code>1: 1 [0 ms]
2: 1 [0 ms]
3: 1 [1 ms]
4: 4 [2 ms]
5: 10 [12 ms]
6: 39 [53 ms]
7: 164 [269 ms]
8: 767 [1607 ms]
9: 3656 [9653 ms]
10: 18186 [61997 ms]
11: 91532 [389137 ms]
12: 468203 [2459990 ms]
13: 2417722 [15555313 ms]
</code></pre>
<p>It may even be enough to reach <span class="math-container">\$A276272(14)\$</span>, though that's projected to use 42 GB RAM (getting close to my machine's 64 GB), so I won't be able to run it beyond that.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.rust-lang.org/" rel="nofollow noreferrer">Rust</a>, 11 (hopefully correct) terms</h1>

<pre class="lang-rust prettyprint-override"><code>
use ::std::ops::{Add, Sub, Mul};
use ::std::rc::Rc;
use ::std::hash::{Hash, Hasher};
use ::std::collections::HashSet;
use ::std::iter;
use ::std::fmt::{self, Formatter, Display};
use ::std::time::Instant;

type Coord = i128;

#[derive(Copy, Clone, PartialEq, Eq, Debug)]
struct Vec3([Coord; 3]);

impl Vec3 {
    fn dot(self, other: Vec3) -&gt; Coord {
        self.0.iter().zip(other.0.iter()).map(|(a, b)| a * b).sum()
    }
}

impl Display for Vec3 {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        write!(f, "({}, {}, {})", self.0[0], self.0[1], self.0[2])
    }
}

impl Mul&lt;Vec3&gt; for Coord {
    type Output = Vec3;

    fn mul(self, mut vec: Vec3) -&gt; Vec3 {
        for i in &amp;mut vec.0 {
            *i *= self;
        }
        vec
    }
}

impl Add for Vec3 {
    type Output = Vec3;

    fn add(mut self, other: Vec3) -&gt; Vec3 {
        for (i, n) in self.0.iter_mut().enumerate() {
            *n += other.0[i];
        }
        self
    }
}

impl Sub for Vec3 {
    type Output = Vec3;

    fn sub(self, other: Vec3) -&gt; Vec3 {
        self + (-1 * other)
    }
}

#[derive(Clone, Debug)]
struct Tetrahedron([Vec3; 4]);

impl Default for Tetrahedron {
    fn default() -&gt; Tetrahedron {
        Tetrahedron([
            Vec3([-1, -1, -1]),
            Vec3([-1,  1,  1]),
            Vec3([ 1, -1,  1]),
            Vec3([ 1,  1, -1]),
        ])
    }
}

impl Display for Tetrahedron {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        write!(f, "Tetrahedron({}, {}, {}, {})", self.0[0], self.0[1], self.0[2], self.0[3])
    }
}

impl Tetrahedron {
    fn collides(&amp;self, other: &amp;Tetrahedron) -&gt; bool {
        let mut othervecs = [3 * self.0[1], 3 * self.0[2], 3 * self.0[3]];
        let sum = self.0[0] + self.0[1] + self.0[2] + self.0[3];
        let mut same = 0;

        for (i, &amp;vec) in self.0.iter().enumerate() {
            let sum = sum - vec;
            let vec = 3 * vec;
            let through = vec - sum;
            for (j, &amp;u) in other.0.iter().enumerate() {
                let u = 3 * u;
                if u == vec { same += 1 }
                let up = (sum - u).dot(through);
                for &amp;v in &amp;other.0[j+1..] {
                    let v = 3 * v;
                    let edge = v - u;
                    let ep = edge.dot(through);

                    if up.signum() != ep.signum() || up.abs() &gt;= ep.abs() {
                        continue
                    }

                    let intersection = ep * u + up * edge;
                    if othervecs.iter().enumerate().all(|(i, &amp;ov)| {
                        let mid = othervecs[(i+1)%3] + othervecs[(i+2)%3];
                        let ov = 2 * ov - mid;
                        (2 * intersection - ep * mid).dot(ep * ov) &gt; 0
                    }) {
                        return true
                    }
                }
            }

            if i != 3 { othervecs[i] = vec; }
        }
        if same == 4 { panic!("EQUAL TETRAHEDRA IN .collides()"); }
        false
    }

    // Mirroring also scales by 3
    fn mirror(&amp;self, i: usize) -&gt; Tetrahedron {
        let mut sum = Vec3([0; 3]);
        for (j, &amp;vec) in self.0.iter().enumerate() {
            if j != i { sum = sum + vec; }
        }

        let mut copy = self.clone();
        copy.scale();

        copy.0[i] = 2 * sum - copy.0[i];
        copy.swap(i, 3);
        copy.rotate_left(i);

        copy
    }

    fn scale(&amp;mut self) {
        for vec in self.0.iter_mut() {
            *vec = 3 * *vec;
        }
    }

    fn rotate_left(&amp;mut self, n: usize) {
        self.0[..3].rotate_left(n)
    }

    fn swap(&amp;mut self, a: usize, b: usize) {
        self.0.swap(a, b)
    }

    fn reverse(&amp;mut self) {
        self.0.reverse()
    }
}

type EndpointIter&lt;'a&gt; = Box&lt;dyn Iterator&lt;Item = Endpoint&gt; + 'a&gt;;

#[derive(Debug, Clone)]
struct Endpoint {
    tree: Rc&lt;TetraTree&gt;,
    hedron: Rc&lt;Tetrahedron&gt;,
}

impl Endpoint {
    fn iter_endpoints(&amp;self) -&gt; EndpointIter {
        let mut hedron = Rc::clone(&amp;self.hedron);
        //Rc::make_mut(&amp;mut hedron).swap(0, 3);
        Rc::make_mut(&amp;mut hedron).reverse();

        Box::new(self.clone().into_iter_directions()
            .chain(self.tree.iter_endpoints(
                Rc::new(TetraTree {
                    subtrees: [None, None, None],
                    hedron,
                })
            ))
        )
    }

    fn into_iter_directions(self) -&gt; EndpointIter&lt;'static&gt; {
        Box::new(iter::successors(Some(self), |this| {
            let mut this = this.clone();
            Rc::make_mut(&amp;mut this.tree).rotate_left(1);
            Rc::make_mut(&amp;mut this.hedron).0[1..].rotate_left(1);
            Some(this)
        }).take(3))
    }

    fn iter_extensions(&amp;self) -&gt; EndpointIter {
        let mut tree = self.tree.as_ref().clone();
        tree.scale();

        let mut hedron = self.hedron.as_ref().clone();
        //hedron.swap(0, 3);
        hedron.reverse();
        hedron.scale();

        Box::new(Endpoint {
            tree: Rc::new(tree),
            hedron: Rc::clone(&amp;self.hedron),
        }.into_iter_directions().filter_map(|endpoint| {
            let mut new = endpoint.hedron.mirror(3);
            new.swap(0, 3);
            if endpoint.tree.collides(&amp;new) {
                None
            } else {
                let mut hedron = endpoint.hedron;
                Rc::make_mut(&amp;mut hedron).scale();

                Some(Endpoint {
                    tree: Rc::new(TetraTree {
                        subtrees: [Some(endpoint.tree), None, None],
                        hedron,
                    }),
                    hedron: Rc::new(new),
                })
            }
        }).chain(self.tree.iter_extensions(Rc::new(TetraTree {
            subtrees: [None, None, None],
            hedron: Rc::new(hedron),
        }))))
    }

    fn iter_tetrahedra&lt;'a&gt;(&amp;'a self)
      -&gt; Box&lt;dyn Iterator&lt;Item = &amp;Tetrahedron&gt; + 'a&gt; {
        Box::new(
          iter::once(self.hedron.as_ref()).chain(self.tree.iter_tetrahedra())
        )
    }
}

impl Default for Endpoint {
    fn default() -&gt; Endpoint {
        Endpoint::from(Tetrahedron::default())
    }
}

impl From&lt;Tetrahedron&gt; for Endpoint {
    fn from(mut hedron: Tetrahedron) -&gt; Endpoint {
        let mirrored = hedron.mirror(0);
        hedron.scale();

        Endpoint {
            tree: Rc::new(TetraTree {
                subtrees: [None, None, None],
                hedron: Rc::new(mirrored),
            }),
            hedron: Rc::new(hedron),
        }
    }
}

impl Hash for Endpoint {
    fn hash&lt;H: Hasher&gt;(&amp;self, hasher: &amp;mut H) {
        let mut stuff: Vec&lt;_&gt; = self.tree.hash_helper(1).collect();
        stuff.push(self.tree.len());
        stuff.sort();
        stuff.hash(hasher);
    }
}

impl PartialEq for Endpoint {
    fn eq(&amp;self, other: &amp;Endpoint) -&gt; bool {
        self.iter_endpoints().any(|ep| ep.tree == other.tree)
    }
}

impl Eq for Endpoint {}

#[derive(Debug, Clone)]
struct TetraTree {
    subtrees: [Option&lt;Rc&lt;TetraTree&gt;&gt;; 3],
    hedron: Rc&lt;Tetrahedron&gt;,
}

impl TetraTree {
    fn iter_endpoints&lt;'x&gt;(&amp;'x self, behind: Rc&lt;TetraTree&gt;) -&gt; EndpointIter&lt;'x&gt; {
        let mut iterator = self.subtrees.iter().enumerate()
          .filter_map(|(i, opt)| opt.as_ref().map(|some| (i, some)));

        if let Some(first) = iterator.next() {
            let closure = move |(i, subtree): (usize, &amp;'x Rc&lt;TetraTree&gt;)| -&gt; EndpointIter&lt;'x&gt; {
                let mut behind = behind.as_ref().clone();
                behind.rotate_left(3-i);

                let mut this = self.clone();
                this.rotate_left(i);

                Rc::make_mut(&amp;mut this.hedron).reverse();

                this.subtrees.swap(1, 2);
                this.subtrees[0] = Some(Rc::new(behind));

                for (j, subtree) in this.subtrees.iter_mut().enumerate().skip(1)
                  .filter_map(|(j, s)| s.as_mut().map(|s| (j, s))) {
                    Rc::make_mut(subtree).rotate_left(j);
                }

                subtree.iter_endpoints(Rc::new(this))
            };
            Box::new(closure(first).chain(iterator.flat_map(closure)))
        } else {
            let mut hedron = self.hedron.as_ref().clone();
            //hedron.swap(0, 3);
            hedron.reverse();
            Endpoint {
                tree: Rc::clone(&amp;behind),
                hedron: Rc::new(hedron),
            }.into_iter_directions()
        }
    }

    fn rotate_left(&amp;mut self, i: usize) {
        self.subtrees.rotate_left(i);
        Rc::make_mut(&amp;mut self.hedron).rotate_left(i);
    }

    fn collides(&amp;self, hedron: &amp;Tetrahedron) -&gt; bool {
        self.hedron.collides(hedron) ||
          self.subtrees.iter()
            .filter_map(Option::as_ref)
            .any(|subtree| subtree.collides(hedron))
    }

    fn scale(&amp;mut self) {
        for subtree in self.subtrees.iter_mut().filter_map(Option::as_mut) {
            Rc::make_mut(subtree).scale();
        }
        Rc::make_mut(&amp;mut self.hedron).scale();
    }

    fn iter_extensions(&amp;self, behind: Rc&lt;TetraTree&gt;) -&gt; EndpointIter {
        Box::new(self.subtrees.iter().enumerate().flat_map(move |(i, next)| {
            let mut behind = behind.as_ref().clone();
            behind.rotate_left(3-i);

            let mut this = self.clone();
            this.rotate_left(i);

            let hedron = Rc::make_mut(&amp;mut this.hedron);
            hedron.reverse();

            this.subtrees.swap(1, 2);
            this.subtrees[0] = Some(Rc::new(behind));

            for (j, subtree) in this.subtrees.iter_mut().enumerate().skip(1)
              .filter_map(|(j, s)| s.as_mut().map(|s| (j, s))) {
                let subtree = Rc::make_mut(subtree);
                subtree.scale();
                subtree.rotate_left(j);
            }

            if let Some(next) = next {
                hedron.scale();
                next.iter_extensions(Rc::new(this))
            } else {
                let mut mirrored = hedron.mirror(3);
                mirrored.swap(0, 3);
                hedron.scale();

                if this.collides(&amp;mirrored) {
                    Box::new(iter::empty()) as EndpointIter
                } else {
                    Box::new(iter::once(Endpoint {
                        tree: Rc::new(this),
                        hedron: Rc::new(mirrored),
                    }))
                }
            }
        }))
    }

    fn iter_tetrahedra&lt;'a&gt;(&amp;'a self)
      -&gt; Box&lt;dyn Iterator&lt;Item = &amp;Tetrahedron&gt; + 'a&gt; {
        Box::new(iter::once(self.hedron.as_ref()).chain(
          self.subtrees.iter()
            .filter_map(Option::as_deref)
            .flat_map(TetraTree::iter_tetrahedra)
        ))
    }

    fn len(&amp;self) -&gt; usize {
        1usize + self.subtrees.iter()
              .filter_map(Option::as_deref).map(TetraTree::len).sum::&lt;usize&gt;()
    }

    fn hash_helper&lt;'a&gt;(&amp;'a self, behind: usize)
      -&gt; Box&lt;dyn Iterator&lt;Item = usize&gt; + 'a&gt; {
        let sub: Vec&lt;_&gt; = self.subtrees.iter().filter_map(Option::as_deref)
          .map(|a| (a, a.len())).collect();
        let sum = sub.iter()
          .map(|&amp;(_, len)| len).sum::&lt;usize&gt;() + behind + 1;
        Box::new(iter::once(behind).chain(
            sub.into_iter().flat_map(move |(sub, len)|
                        iter::once(len).chain(sub.hash_helper(sum - len)))
        ))
    }
}

impl PartialEq for TetraTree {
    fn eq(&amp;self, rhs: &amp;TetraTree) -&gt; bool {
        self.subtrees == rhs.subtrees
    }
}

impl Eq for TetraTree {}

fn main() {
    let verbose = std::env::args().skip(1).any(|arg| arg == "-v");
    let begin = Instant::now();

    println!("1: 1 [{}ms]", begin.elapsed().as_millis());
    if verbose {
        println!("{}\n--", Tetrahedron::default());
    }

    let mut polytets = HashSet::new();
    polytets.insert(Endpoint::default());

    for i in 2.. {
        println!("{}: {} [{}ms]", i, polytets.len(), begin.elapsed().as_millis());

        if verbose {
            for polytet in &amp;polytets {
                for hedron in polytet.iter_tetrahedra() {
                    println!("{}", hedron);
                }
                println!("--");
            }
        }

        polytets = polytets.iter()
          .flat_map(Endpoint::iter_extensions)
          .collect();
    }
}

</code></pre>
<p><a href="https://tio.run/##vVrrb9vIEf8s/xUbF3XIWKYt6z4UlCwgTXJIgN4rcfvFFQxKWlnMUSSPSzr2Wfrb05nZN0VFvmvRAFbIfcxrZ34zs1LViPrr16NGcBbHol7EcVGKOH56vVj02adm1mc/NNl25C6o5nH8ce4NrRKxgk3v4b8@w09e@XvmRZbxeZ0WORDHBZ947S1Ia155A8t1DRQFz5Z99n1RrZMaVvTZ21SUWfLoU6/TNY/jD7mokxzIHtWPJWdviqJasCuWDi7/BmN/uVnwKr3nwZuifOyzN1mR8z77OanqNMne/dZn@PeWz5q7cHok6qqZ1@xffD4MbojQiA2nIZBJ12VG4@zpqLfM2aKoAylkUYPWMc2F7Gyi@MOqHs5HFxGqGITR72kZ0FozFEbrpAw2QdJns3DDEvYK/o9Esw7Co972aKu4KtXZsqhcCcBQwYkUYRmzk3VTW3uRIGTJj1w0WU3ifKmA7YsA1h8HT9s@k3/hcZ9JQW8upuZxYB8vp5404BZjlGJC8hhlyfQ/NXUJYlyRmGA0FHPdZMpQKOE9nzum0tr0kFTK0lyqAYuiCxrvvUrZqyuSZASvW/iDSVcc8FfPMHvlSBaLAIl3H5onSZD2WR6iOM4J3sJmOEWeN2teJTUPQiVhzk6vmDrYm3Sq5cStrqAQU88TVDSz4ICQOM1OWXA2AJehVfqIrLdLP2859jWvq2TFF1WRBzfEk31n3fstXyboLCims1J7vJwNSJTWdM8jjGaRIXQ26DP5Nw37/jCjP2@YqdUdw8whMt0bHbtC/zdB4upk4@WZMWMeh764uyIiRKYLLrSc6tRPnJUk6awoMhIx4zXFEi2EcBDgPzdD8ARHDuf10n8dTslFkQggDbuyioBHGQr2@dJ5HpqtFEnJmsP@C/RbEzcnIFA7dLrCxuEPn2cY8yM9Ds8wjjK7o/WqKpq7Fczg/Bnuozni/Bk4N8TXh9hdxkSrUfQbotBLlzgiCT9JvSCmB2xrN5SwI5CiNmGE6K/kCSUJlOLkniBMY8Hn00EUTRVXqZhWa2TH@OIOrXiPhN1hZIhzLV5yBQpcRiK9yzFZsBew1HndbHA2mQl4ntCUfFaS9OZFXqd5w@Xr9shyTXOwmpAJG/mXaCM4/wYfUJqR4W@8r8PSUZJlkNfQHYp7yGyaMXlOisnZ7L4J0tNB@Nchepk3eImDI2djgda7RMBDWwEZPRngoCf5mZQc1sijojeQhE3YhVLaWqPidVPlDADSGMR8StuAtinaGMDXkTGdSlcckZvgH6yTMXHFvoOlZZKn8xfB8btf/vn6H@z63fXH1@/fvf34mn34kUUm6sPjUFJYJpngR8Ty/Jz9kFZVUaX5HYPhgol5knHBZo9sKLMqTWvISGPWiPR33gnNJlwp2iSkXqiyxomeZ8Yt6PgZbZFioJj4PXUN4fCcQ82lIWaOGSkgpjgckUqBdGkauJAmxdOUgWZG7Z4vUDCBWw0tmaqoQbzbjC/rILXUpCExnRKbE536Q5PlMdi7UrxK6xaEXikU2hqaLs8TW1Tk5hhs9XcTRcOpJ2QeWtlQHYdAoghAPdhBSmpPxaKVhN@j27f1Uxv0rM5AVHO8yxdlAeHyATQev0wmoOXfi4fx4jFnOJTURTWGBzxavXQCBwwr3WqaCgtVTtv6Qm@gAqfiPGYf52NyyGt4m0D2lo5px@U7zOgE6ZIABelcuBpTOZLc3FXD83Pl@lfAAvoPcjraFalcikd5fo6T6@RXTmd@YveF0soX2sf2rzPGJZ8DE8Zxzr8Erq9HIF9xSyos0kr1QXgavV40XyVpLlejpaKWooRByBxpGgtq0IIaETeJmN38SHWe/Zz25RIppnzZEssQP63rdMrWad7xS2iw6nQ@IfZGU9wLjVgzn3MhikoEn4o1lxT6bFOvUrGxuR4th0NwLvifiwYdNqYlqGHohc7gm@v1wUD9Anm3ayMJiGvREtswqoFIMAwdm9AhPNQ8F2SOZ7gbSqkhjg4yEbcVX8LhOyrShAt4O87qeGgnhfNzNem7pxp0fNGMuezMmbnR1TMhKufI3uQwNkg7IwjXbPf4drRMM4JS7Gy1O7f8AJhhcaEmtdYqpUm9erCmpSqmHrOHDGorZ1itEzrGAKVuxiGfOjWfZ@4W85EJtz2Y4NhSuZFvybYtdyLWDVna76kSdkWwF8Lgrl5gW1aouxvmW@nb3fhiXXuPpAeRpc3e9YkwbMdSrTE@wVQTnLxMZJY66jGMqn2Jx21@VPLxsQeeGZMAVORziTrt8NljAytSYBFx29ECtzKR1/96p69f4nhZFevAkT2OzS6Pzfewzst/XQyJmPXCmLU7Qk8IWVtjCHEssP2gutgHDN/Cg7YPH046bd/Q8kj/3IYHHci1Ed4WdpkF7xzH72N13TjRNfCKXlWP/z70S9@6WS7pImV8O/HAGnfdrnhWQrU7CCN1XSlxlHZFZSNWjgtlPIeztNOQ@LzlSDCQsuCoVcfcOHbpxH9rd/96gd/6kxytSgG6rfwRsLbcYKcn05G@kCJscaXYYb89WNN5buD4wE8lQv7YK/Am2Fc8p8rziO6UeeOXD4gVD6osnvFVmi9atWRHlfIw8U49VaCiD1zL3tHbEJx4qQu7jKKsoXmFT5uRaU4Afm/otgOfwlCGEqQn5EzgvkwrAUd3ZWSIcoBe9@4D0qpoKqwc1sU9Z8RPCRjGLFBtANrA13qzV22ruLQXkJYPnfVEr6cm3TJpeJbqHNeq2dodHGAFllwdzdfB8syvmxUhczaU8wd9dumy0bN4SXUlLazRQ2oRamK6ndWmxA7PZ9B9lxuJX1PgSwl0xxWQHhheoCHlTukGG8kKHEBneU91LYNnpc9KL3Xrota0Y9qUZFiryqxO20z@U@6jHE0lOuNsyyypSXa1jNKyVxH94fpzXwHaWYG20oqTV1Q1qU6tO2s4CWFvmfmcdjzd7aGNF7Qdt8tr3ZJ3d4Pi3b691crsv751LW1264WbDUFRF17RhO@aEoLjWB6YWUH5QO3e6FDY4RUeviJRW801SVcQdYsDcyooukPC1CCyXj1gfLv6W33acxOFX0keSg02mCxQI5iHrabmWaD7Tcw9BLl7ERc3erce@9F3T8geHcLhPwbD/wsU/tMgLL9ZmKm@vNP9Rh72Or5oBzsw21wGmzRPfgBM8H/FvV1j96iXfaj39l8OxHd1rHtLegW/Pb2gjctd1T5JL69fDGyZGl3nsNb9Dl@X9SOUvCwRXhTJLOaK3N5JjVm7TW7fOaD2fr@7r32g/tK9mlcD/49285md5p/Ebii/HfQ2eGMgTP5KwlGO2larOvYk9qaKch6JP5CPp98S6YBQUUsQYEW/UIjjMRGfBFYMp5fyrG9xWabjA4ch6TqnoAK63b@1MfugbSVgJAAYSZ8lqpNr9Xzu15Iz11Jy80lw20dzAxB1WAJkVlnglA1Ge/xHIaX1mB5x0lVOR8IR@GscYipx0f5zyJI46r4D6Ll9rfwyBReE1nG629J2W2b70moldFFzTZC@U9Lo88DuE1ab947202EDM/h1FspNCCS//61mhaBbVfyVD8/v4SirO2EThCxxYGzD4AM5Hp/dH@MJ4v4Zv0sxFaofBsERFF8kApYVGDrLXwTHg5gN2M3Tdi2mx325I@JZUgq@wI4ackwKCClkrw@oqWVCdS2Vp@2/87MzILDnzkdVLBrMyyJ7hCjG7K5@CyXdA9fpOXAFwas6sJdKLrkj@1OZyyjakSYGg1qtoFIxVMnbDykqu1hXVWKniNCX20aFJ9NvqdIDZtXk7j2bRn9X1mNdLJuOyF8BdtV5V@Vex3zWWk6ImsCxtmtlXbXQDXl0Tvk7OPsruLcIGvh7sipJa/Za0PtY4RF9iXYNbgenBxg1kr8uUkhjUw4GyCd4iGO5dqSDAOiAv@BWgAmiPPFYoEnV3cp1myForqaQz/gak7IkodlMniuPDVz/cgPwMYnkXoUUX/8D" rel="nofollow noreferrer" title="Rust – Try It Online">Try it online!</a> The footer contains some compatability implementations because TIO's Rust is a little old. (This has already been <a href="https://chat.stackexchange.com/transcript/message/54872387#54872387">reported</a> and added to the <a href="https://gist.github.com/cairdcoinheringaahing/46f79623ea7b5cfe67286d0a5e96d307" rel="nofollow noreferrer">list</a>.)</p>
<p>Output:</p>
<pre class="lang-rust prettyprint-override"><code>1: 1 [0ms]
2: 1 [0ms]
3: 1 [2ms]
4: 4 [8ms]
5: 10 [35ms]
6: 39 [139ms]
7: 164 [738ms]
8: 767 [4328ms]
9: 3656 [31298ms]
10: 18186 [287871ms]
11: 91532 [3154716ms]
</code></pre>
<p>As you can see, it also reports how long it took. (These are cumulated times.) You can use the <code>-v</code> option to list all tetrahedra for each polytet.</p>
<p>I don't really have a good way of verifying the results beyond A276272(5). I hope it works, but I'm not sure.</p>
<p>The idea is that we store the polytet as a tree of tetrahedra that also encodes orientation. But for collision detection we need actual tetrahedra. We start with the tetrahedron with vertices (-1, -1, -1), (-1, 1, 1), (1, -1, 1), (1, 1, -1) and scale all tetrahedra by 3 for every term. This avoids the need for fractions.</p>
<p>Can probably be made faster, but I don't know how.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/214203/">214203</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




