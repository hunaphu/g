<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::214203</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>014</td><td>C++ GCC</td><td>251003T124500Z</td><td><a href="https://codegolf.stackexchange.com/questions/214203/gluing-tetrahedra-together/283991#283991">Deadcode</a></td></tr>
<tr d-ix="1"><td>011</td><td>Rust</td><td>201108T231337Z</td><td><a href="https://codegolf.stackexchange.com/questions/214203/gluing-tetrahedra-together/214928#214928">wastl</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C++ (GCC)</a>, <s>12</s> <s>13</s> 14+ terms</h1>
<pre class="lang-cpp prettyprint-override"><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;cstdint&gt;
#include &lt;cinttypes&gt;
#include &lt;array&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;functional&gt;
#include &lt;unordered_set&gt;
#include &lt;chrono&gt;

//#define USE_GMP

#ifdef USE_GMP
#include &lt;gmp.h&gt;
#   if GMP_NUMB_BITS != 64
#   error This is hard-coded for 64-bit limbs
#   endif
#endif

auto startTime = std::chrono::steady_clock::now();

void quitOverflow()
{
    auto currentTime = std::chrono::steady_clock::now();
    std::cerr &lt;&lt; "Quitting due to detected overflow" &lt;&lt; " [" &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(currentTime - startTime).count() &lt;&lt; " ms]" &lt;&lt; std::endl;
    exit(-1);
}

typedef uint8_t TetIndex;
typedef uint8_t TetIndexFace; // lowest 2 bits are used for a face index
typedef __int128 Coord;
typedef std::array&lt;Coord, 3&gt; Coord3;
typedef std::array&lt;Coord3, 4&gt; Tetrahedron;
class Tet
{
    void initFaces()
    {
        faceAttached[0] = NULL; // t[0],t[1],t[2]
        faceAttached[1] = NULL; // t[0],t[1],t[3]
        faceAttached[2] = NULL; // t[0],t[2],t[3]
        faceAttached[3] = NULL; // t[1],t[2],t[3]
    }
public:
    Tetrahedron t;
    Tet *faceAttached[4];
    TetIndex index; // 1-based; 0=unassigned
    Tet(                    ) : t( ) {initFaces();}
    Tet(const Tetrahedron &amp;t) : t(t) {initFaces();}
    void assignIndex(TetIndex &amp;nextIndex)
    {
        if (index == 0)
            index = nextIndex++;
    }
};
class Polytet : public std::vector&lt;Tet&gt;
{
public:
    TetIndex nextIndex;
    void resetIndexing(size_t first) // This function should not be called if the polytet hasn't yet been populated
    {
       &#32;
        for (auto t=begin(); t!=end(); ++t)
            t-&gt;index = 0;
        (*this)[first].index = 1;
        nextIndex = 2;
    }
};

// vertex indices of faces with identical chirality
static int tetrahedronFaces[4][4] =
{
    {0, 1, 2, 3},
    {0, 3, 1, 2},
    {0, 2, 3, 1},
    {1, 3, 2, 0},
};

static int tetrahedronEdges[6][2] =
{
    {0, 1},
    {1, 2},
    {2, 0},
    {0, 3},
    {1, 3},
    {2, 3},
};

Coord3 operator-(const Coord3 &amp;a)
{
    Coord3 c;
    c[0] = -a[0];
    c[1] = -a[1];
    c[2] = -a[2];
    return c;
}
Coord3 operator+(const Coord3 &amp;a, const Coord3 &amp;b)
{
    Coord3 c;
    c[0] = a[0] + b[0];
    c[1] = a[1] + b[1];
    c[2] = a[2] + b[2];
    return c;
}
Coord3 operator-(const Coord3 &amp;a, const Coord3 &amp;b)
{
    Coord3 c;
    c[0] = a[0] - b[0];
    c[1] = a[1] - b[1];
    c[2] = a[2] - b[2];
    return c;
}
Coord3 operator*(const Coord3 &amp;a, const Coord b)
{
    Coord3 c;
    c[0] = a[0] * b;
    c[1] = a[1] * b;
    c[2] = a[2] * b;
    return c;
}
#ifndef USE_GMP
Coord dot(const Coord3 &amp;a, const Coord3 &amp;b)
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}
#endif

#ifdef USE_GMP
void mpz_set_int128(mpz_t &amp;dst, const __int128 &amp;src)
{
    __int128 abssrc = src &lt; 0 ? -src : src;
    mpz_import(dst, 2, -1, 8, 0, 0, &amp;abssrc);
    if (src &lt; 0)
        mpz_neg(dst, dst);
}
void mpz_get_int128(__int128 &amp;dst, const mpz_t &amp;src)
{
    dst = 0;
    size_t count;
    uint64_t limbs[2];

    mpz_export(limbs, &amp;count, -1, sizeof(uint64_t), 0, 0, src);

    if (count &gt; 2)
        quitOverflow();

    bool isNegative = mpz_sgn(src) &lt; 0;

    ((uint64_t*)&amp;dst)[0] = limbs[0];
    if (count &gt; 1)
    {
        if (limbs[1] &gt; INT64_MAX)
            if (!isNegative || limbs[1] &gt; (uint64_t)INT64_MIN || limbs[0] != 0)
                quitOverflow();
        ((uint64_t*)&amp;dst)[1] = limbs[1];
    }

    if (isNegative)
        dst = -dst;
}
#endif

class TetrahedronOverlap
{
#ifdef USE_GMP
    mpz_t intersectNumerator, intersectDenominator, uNumerator, vNumerator, uvDenominator, uvNumeratorSum;
    mpz_t center[3], normal[3], tmp[3], p0p1[3], intersectionPoint[3], delta[3], edge1[3], edge2[3];
    mpz_t a[4][3];
    mpz_t b[4][3];
    mpz_t triangle[3][3];
    void setTetrahedron(mpz_t dst[4][3], const Tetrahedron &amp;src)
    {
        for (int p=0; p&lt;4; p++)
            for (int d=0; d&lt;3; d++)
                mpz_set_int128(dst[p][d], src[p][d]);
    }
    void dot(mpz_t &amp;result, const mpz_t a[3], const mpz_t b[3])
    {
        mpz_mul   (result, a[0], b[0]);
        mpz_addmul(result, a[1], b[1]);
        mpz_addmul(result, a[2], b[2]);
    }
public:
    TetrahedronOverlap()
    {
        mpz_inits(intersectNumerator, intersectDenominator, uNumerator, vNumerator, uvDenominator, uvNumeratorSum, NULL);
        for (int d=0; d&lt;3; d++)
        {
            mpz_init(center[d]);
            mpz_init(normal[d]);
            mpz_init(tmp[d]);
            mpz_init(p0p1[d]);
            mpz_init(intersectionPoint[d]);
            mpz_init(delta[d]);
            mpz_init(edge1[d]);
            mpz_init(edge2[d]);
        }
        for (int p=0; p&lt;4; p++)
        {
            for (int d=0; d&lt;3; d++)
            {
                mpz_init(a[p][d]);
                mpz_init(b[p][d]);
            }
        }
        for (int p=0; p&lt;3; p++)
            for (int d=0; d&lt;3; d++)
                mpz_init(triangle[p][d]);
    }
    ~TetrahedronOverlap()
    {
        mpz_clears(intersectNumerator, intersectDenominator, uNumerator, vNumerator, uvDenominator, uvNumeratorSum, NULL);
        for (int d=0; d&lt;3; d++)
        {
            mpz_clear(center[d]);
            mpz_clear(normal[d]);
            mpz_clear(tmp[d]);
            mpz_clear(p0p1[d]);
            mpz_clear(intersectionPoint[d]);
            mpz_clear(delta[d]);
            mpz_clear(edge1[d]);
            mpz_clear(edge2[d]);
        }
        for (int p=0; p&lt;4; p++)
        {
            for (int d=0; d&lt;3; d++)
            {
                mpz_clear(a[p][d]);
                mpz_clear(b[p][d]);
            }
        }
        for (int p=0; p&lt;3; p++)
            for (int d=0; d&lt;3; d++)
                mpz_clear(triangle[p][d]);
    }
    void setA(const Tetrahedron &amp;x) {setTetrahedron(a, x);}
    void setB(const Tetrahedron &amp;x) {setTetrahedron(b, x);}
    bool operator()()
    {
        // Take advantage of the fact that the two tetrahedrons are regular and congruent, and
        // just check if any edge of tetrahedron "a" intersects with any face of tetrahedron "b".
        // Don't count it if only the endpoint of an edge intersects.
        for (int edgeNum=0; edgeNum&lt;6; edgeNum++)
        {
            const mpz_t *p0 = a[tetrahedronEdges[edgeNum][0]];
            const mpz_t *p1 = a[tetrahedronEdges[edgeNum][1]];
            for (int faceNum=0; faceNum&lt;4; faceNum++)
            {
                mpz_t *normalizedTetrahedron[4][3]; // first 3 points are the face, and the 4th point is for calculating the normal
                for (int i=0; i&lt;4; i++)
                    for (int d=0; d&lt;3; d++)
                        normalizedTetrahedron[i][d] = &amp;b[tetrahedronFaces[faceNum][i]][d];
                // Center coordinates will be multiplied by 3 compared to original coordinates.
                // Get center of face by averaging its vertices' coordinates; the
                // division by 3 is implied by omitting the multiplication by 3.
                for (int d=0; d&lt;3; d++)
                    mpz_set(center[d], *(normalizedTetrahedron[0][d]));
                for (int p=1; p&lt;3; p++)
                    for (int d=0; d&lt;3; d++)
                        mpz_add(center[d], center[d], *(normalizedTetrahedron[p][d]));
                for (int d=0; d&lt;3; d++)
                {
                    mpz_neg(normal[d], center[d]);
                    mpz_addmul_ui(normal[d], *(normalizedTetrahedron[3][d]), 3);
                }
                for (int d=0; d&lt;3; d++)
                {
                    mpz_sub(tmp [d], *(normalizedTetrahedron[0][d]), p0[d]);
                    mpz_sub(p0p1[d],                         p1[d],  p0[d]);
                }
                dot(intersectNumerator  , normal, tmp);
                dot(intersectDenominator, normal, p0p1);
                int cmp = mpz_cmp_ui(intersectDenominator, 0);
                if (cmp == 0)
                    continue; // edge is parallel to face, which we don't count as an overlap
                if (cmp &lt; 0)
                {
                    mpz_neg(intersectNumerator  , intersectNumerator  );
                    mpz_neg(intersectDenominator, intersectDenominator);
                }
                if (mpz_cmp_ui(intersectNumerator, 0) &lt;= 0 || mpz_cmp(intersectNumerator, intersectDenominator) &gt;= 0)
                    continue;
                // These coordinates are all multiplied by intersectDenominator
                for (int d=0; d&lt;3; d++)
                {
                    mpz_mul(intersectionPoint[d], p0[d], intersectDenominator);
                    mpz_addmul(intersectionPoint[d], p0p1[d], intersectNumerator);
                }
                for (int i=0; i&lt;3; i++)
                    for (int d=0; d&lt;3; d++)
                        mpz_mul(triangle[i][d], *(normalizedTetrahedron[i][d]), intersectDenominator);
                // Check if the intersection point is inside the triangle
                for (int d=0; d&lt;3; d++)
                {
                    mpz_sub(delta[d], intersectionPoint[d], triangle[0][d]);
                    mpz_sub(edge1[d], triangle[1][d]      , triangle[0][d]);
                    mpz_sub(edge2[d], triangle[2][d]      , triangle[0][d]);
                }
                mpz_mul   (uNumerator, delta[1], edge2[0]);
                mpz_submul(uNumerator, delta[0], edge2[1]);
                mpz_mul   (vNumerator, delta[0], edge1[1]);
                mpz_submul(vNumerator, delta[1], edge1[0]);
                mpz_mul   (uvDenominator, edge1[1], edge2[0]);
                mpz_submul(uvDenominator, edge1[0], edge2[1]);
                cmp = mpz_cmp_ui(uvDenominator, 0);
                if (cmp == 0)
                    continue;
                if (cmp &lt; 0)
                {
                    mpz_neg(uNumerator, uNumerator);
                    mpz_neg(vNumerator, vNumerator);
                    mpz_neg(uvDenominator, uvDenominator);
                }
                if (mpz_cmp_ui(uNumerator, 0) &lt;= 0 || mpz_cmp_ui(vNumerator, 0) &lt;= 0)
                    continue;
                mpz_add(uvNumeratorSum, uNumerator, vNumerator);
                if (mpz_cmp(uvNumeratorSum, uvDenominator) &lt; 0)
                    return true;
            }
        }
        return false;
    }
#else
    const Tetrahedron *a, *b;
public:
    void setA(const Tetrahedron &amp;x) {a = &amp;x;}
    void setB(const Tetrahedron &amp;x) {b = &amp;x;}
    bool operator()()
    {
        // Take advantage of the fact that the two tetrahedrons are regular and congruent, and
        // just check if any edge of tetrahedron "a" intersects with any face of tetrahedron "b".
        // Don't count it if only the endpoint of an edge intersects.
        for (int edgeNum=0; edgeNum&lt;6; edgeNum++)
        {
            Coord3 p0 = (*a)[tetrahedronEdges[edgeNum][0]];
            Coord3 p1 = (*a)[tetrahedronEdges[edgeNum][1]];
            for (int faceNum=0; faceNum&lt;4; faceNum++)
            {
                Tetrahedron normalizedTetrahedron; // first 3 points are the face, and the 4th point is for calculating the normal
                for (int i=0; i&lt;4; i++)
                    normalizedTetrahedron[i] = (*b)[tetrahedronFaces[faceNum][i]];
                Coord3 center = {{0, 0, 0}}; // multiplied by 3 compared to original coordinates
                // Get center of face by averaging its vertices' coordinates; the
                // division by 3 is implied by omitting the multiplication by 3.
                for (int p=0; p&lt;3; p++)
                    for (int d=0; d&lt;3; d++)
                        center[d] += normalizedTetrahedron[p][d];
                Coord3 normal;
                for (int d=0; d&lt;3; d++)
                    normal[d] = normalizedTetrahedron[3][d] * 3 - center[d];
                Coord intersectNumerator   = dot(normal, normalizedTetrahedron[0] - p0);
                Coord intersectDenominator = dot(normal,                       p1 - p0);
                if (intersectDenominator == 0)
                    continue; // edge is parallel to face, which we don't count as an overlap
                if (intersectDenominator &lt; 0)
                {
                    intersectNumerator   = -intersectNumerator;
                    intersectDenominator = -intersectDenominator;
                }
                if (intersectNumerator &lt;= 0 || intersectNumerator &gt;= intersectDenominator)
                    continue;
                // These coordinates are all multiplied by intersectDenominator
                Coord3 intersectionPoint = p0 * intersectDenominator + (p1 - p0) * intersectNumerator;
                Coord3 triangle[3];
                for (int i=0; i&lt;3; i++)
                    triangle[i] = normalizedTetrahedron[i] * intersectDenominator;
                // Check if the intersection point is inside the triangle
                Coord3 delta = intersectionPoint - triangle[0];
                Coord3 edge1 = triangle[1]       - triangle[0];
                Coord3 edge2 = triangle[2]       - triangle[0];
                Coord uNumerator = delta[1]*edge2[0] - delta[0]*edge2[1];
                Coord vNumerator = delta[0]*edge1[1] - delta[1]*edge1[0];
                Coord uvDenominator = edge1[1]*edge2[0] - edge1[0]*edge2[1];
                if (uvDenominator == 0)
                    continue;
                if (uvDenominator &lt; 0)
                {
                    uNumerator = -uNumerator;
                    vNumerator = -vNumerator;
                    uvDenominator = -uvDenominator;
                }
                if (uNumerator &lt;= 0 || vNumerator &lt;= 0)
                    continue;
                if (uNumerator + vNumerator &lt; uvDenominator)
                    return true;
            }
        }
        return false;
    }
#endif
};

void attachNewTet(Tet &amp;t, Tet &amp;tetToAttachTo, const int faceNum)
{
    Coord3 &amp;newVertex = t.t[0];
    newVertex = {{0, 0, 0}};
    // Get center of face by averaging its vertices' coordinates.
    for (int p=0; p&lt;4; p++)
    {
        if (p == 3 - faceNum)
            continue;
        for (int d=0; d&lt;3; d++)
            newVertex[d] += tetToAttachTo.t[p][d];
    }
    // Finalize the new vertex
    for (int d=0; d&lt;3; d++)
        newVertex[d] = newVertex[d]/3 * 2 - tetToAttachTo.t[3 - faceNum][d];
    // Copy the other vertices
    for (int p=0; p&lt;3; p++)
    {
        int p1 = tetrahedronFaces[faceNum][p];
        for (int d=0; d&lt;3; d++)
            t.t[1+p][d] = tetToAttachTo.t[p1][d];
    }
    t.faceAttached[0] = NULL;
    t.faceAttached[1] = NULL;
    t.faceAttached[2] = NULL;
    t.faceAttached[3] = &amp;tetToAttachTo;
    tetToAttachTo.faceAttached[faceNum] = &amp;t;
}

class NormalizedPolytet : public std::vector&lt;Tetrahedron&gt;
{
public:
    NormalizedPolytet(const Polytet &amp;polytet)
    {
        reserve(polytet.size());
        for (auto tet=polytet.cbegin(); tet!=polytet.cend(); ++tet)
        {
            Tetrahedron &amp;t = emplace_back(tet-&gt;t);
            std::sort(t.begin(), t.end());
        }
        std::sort(this-&gt;begin(), this-&gt;end());
    }
};

bool operator&lt;(const Polytet &amp;_a, const Polytet &amp;_b)
// implicitly assume a.size()==b.size()
{
    NormalizedPolytet a(_a), b(_b);
    for (auto ta=a.cbegin(), tb=b.cbegin(); ta!=a.cend(); ++ta,++tb)
    {
        auto result = *ta &lt;=&gt; *tb;
        if (result != 0)
            return result &lt; 0;
    }
    return false;
}
bool operator&gt;(const Polytet &amp;a, const Polytet &amp;b)
{
    return !(a &lt; b);
}
bool operator==(const Polytet &amp;_a, const Polytet &amp;_b)
// implicitly assume a.size()==b.size()
{
    NormalizedPolytet a(_a), b(_b);
    for (auto ta=a.cbegin(), tb=b.cbegin(); ta!=a.cend(); ++ta,++tb)
    {
        auto result = *ta &lt;=&gt; *tb;
        if (result != 0)
            return false;
    }
    return true;
}

// First two tetrahedrons are implied. Each element is a subsequent tetrahedron, with the value indicating where
// it's attached. The lower 2 bits indicate which face (can only have 3 different values, because at least 1 face
// will always already be attached). The remaining bits indicate which tetrahedron (which can never be zero,
// because that one is attached implicitly).
class CompressedPolytet : public std::vector&lt;TetIndexFace&gt;
{
public:
    void append(Polytet &amp;polytet, Tet &amp;tetToCompress, int vertexMap[4], int faceRotation)
    // indices of vertexMap[] are compressed-output vertices; elements of vertexMap[] are the original vertices of tetToCompress
    {
        tetToCompress.assignIndex(polytet.nextIndex);
        for (int _faceNum=0; _faceNum&lt;3; _faceNum++)
        {
            int rotatedFaceNum = (_faceNum + faceRotation) % 3;
            int faceNum = 3 - vertexMap[3 - rotatedFaceNum];
            if (!tetToCompress.faceAttached[faceNum])
                continue;
            Tet *attachedTet = tetToCompress.faceAttached[faceNum];
            attachedTet-&gt;assignIndex(polytet.nextIndex);
            push_back((((TetIndexFace)(tetToCompress.index - 1)) &lt;&lt; 2) + _faceNum);
           &#32;
            int attachedFace = 0;
            while (attachedTet-&gt;faceAttached[attachedFace] != &amp;tetToCompress)
                attachedFace++;
            int vertexMap2[4];
            int rotation = 0;
            while (vertexMap[tetrahedronFaces[rotatedFaceNum][rotation]] != tetrahedronFaces[faceNum][0])
                rotation++;
            vertexMap2[1] = tetrahedronFaces[attachedFace][0];
            vertexMap2[3] = tetrahedronFaces[attachedFace][1];
            vertexMap2[2] = tetrahedronFaces[attachedFace][2];
            vertexMap2[0] = tetrahedronFaces[attachedFace][3];
            /*if (faceNum == 3)
            {
                int tmp = vertexMap2[3];
                vertexMap2[3] = vertexMap2[2];
                vertexMap2[2] = tmp;
            }*/
            append(polytet, *attachedTet, vertexMap2, rotation);
        }
    }
};

namespace std
{
    template&lt;&gt;
    struct hash&lt;Polytet&gt;
    {
        std::size_t operator()(const Polytet &amp;_polytet) const noexcept
        {
            NormalizedPolytet polytet(_polytet);
            std::size_t seed = polytet.size();
            for (auto t=polytet.cbegin(); t!=polytet.cend(); ++t)
            {
                for (auto c=t-&gt;cbegin(); c!=t-&gt;cend(); ++c)
                {
                    for (auto i=c-&gt;cbegin(); i!=c-&gt;cend(); ++i)
                    {
                        seed ^= std::hash&lt;uint64_t&gt;{}((uint64_t)(*i      )) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2);
                        seed ^= std::hash&lt;uint64_t&gt;{}((uint64_t)(*i &gt;&gt; 64)) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2);
                    }
                }
            }
            return seed;
        }
    };
    template&lt;&gt;
    struct hash&lt;CompressedPolytet&gt;
    {
        std::size_t operator()(const CompressedPolytet &amp;polytet) const noexcept
        {
            std::size_t seed = polytet.size();
            for (auto i=polytet.cbegin(); i!=polytet.cend(); ++i)
                seed ^= std::hash&lt;uint32_t&gt;{}(*i) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2);
            return seed;
        }
    };
};

int main(int argc, char *argv[])
{
    static Tetrahedron start =
    {{
        {{-9,-9,-9}},
        {{-9, 9, 9}},
        {{ 9,-9, 9}},
        {{ 9, 9,-9}}
    }};

    TetrahedronOverlap overlap;

    auto *polytets = new std::unordered_set&lt;CompressedPolytet&gt;;
    polytets-&gt;insert(CompressedPolytet()); // add empty vector as the starter polytet (meaning it has two tetrahedrons)
    size_t prevPolytetCount = 0;
   &#32;
    size_t blahNum = 0;

    for (int tetCount=1;;)
    {
        auto currentTime = std::chrono::steady_clock::now();
        size_t polytetCount = polytets-&gt;size();
        std::cout &lt;&lt; tetCount &lt;&lt; ": " &lt;&lt; polytetCount &lt;&lt; " [" &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(currentTime - startTime).count() &lt;&lt; " ms]" &lt;&lt; std::endl;
        if (prevPolytetCount &gt; polytetCount)
        {
            std::cerr &lt;&lt; "Quit due to apparent overflow" &lt;&lt; std::endl;
            break;
        }
        prevPolytetCount = polytetCount;
        if (++tetCount &lt;= 2)
            continue;
        /*if (tetCount &gt; 12)
            break;*/

        Polytet polytet;
        polytet.reserve(tetCount); // Important, to ensure pointers don't change
        Tet &amp;t0    = polytet.emplace_back(start);
        attachNewTet(polytet.emplace_back(), t0, 3);

        auto *newPolytets = new std::unordered_set&lt;CompressedPolytet&gt;;
        polytet.resize(tetCount);
        for (auto basePolytet=polytets-&gt;cbegin(); basePolytet!=polytets-&gt;cend(); ++basePolytet)
        {
            int tetNumToUncompress = 2;
            for (auto elementToUncompress=basePolytet-&gt;cbegin(); elementToUncompress!=basePolytet-&gt;cend(); ++elementToUncompress)
            {
                int faceNum          = *elementToUncompress &amp; 3;
                int tetNumToAttachTo = *elementToUncompress &gt;&gt; 2;
                Tet &amp;tetToAttachTo = polytet[tetNumToAttachTo];
                attachNewTet(polytet[tetNumToUncompress++], tetToAttachTo, faceNum);
            }
            if (tetNumToUncompress != tetCount - 1)
            {
                std::cerr &lt;&lt; "Error! Got " &lt;&lt; tetNumToUncompress &lt;&lt; ", expected " &lt;&lt; tetCount - 1 &lt;&lt; std::endl;
                exit(-1);
            }

            Tet &amp;newTet = polytet[tetCount - 1];
            for (int tetNumToAttachTo = 0; tetNumToAttachTo &lt; tetCount-1; tetNumToAttachTo++)
            {
                Tet &amp;tetToAttachTo = polytet[tetNumToAttachTo];
                for (int faceNum=0; faceNum&lt;3; faceNum++) // skip last face because it's always already attached
                {
                    if (tetToAttachTo.faceAttached[faceNum])
                        continue;
                    attachNewTet(newTet, tetToAttachTo, faceNum);
                    // Canonicalize the rotation of this new polytet in compressed form, so that it can be compared against others
                    bool haveRunningLeast = false;
                    CompressedPolytet runningLeastPolytet;

                    Tet *t = &amp;polytet[1];
                    for (int i=0; i&lt;tetCount; i++)
                    {
                        int attachedFace;
                        int vertexMap[4];
                        {
                            Tet &amp;singlyAttachedTet = polytet[i];
                            for (int j=0; j&lt;3; j++)
                                if (singlyAttachedTet.faceAttached[j])
                                    goto skipThisTet; // not a singly attached tet
                            t = singlyAttachedTet.faceAttached[3];
                            attachedFace = 0;
                            while (t-&gt;faceAttached[attachedFace] != &amp;singlyAttachedTet)
                                attachedFace++;
                            static int vertexMapTable[4][4] =
                            {
                                {3, 0, 2, 1},
                                {2, 0, 1, 3},
                                {1, 0, 3, 2},
                                {0, 1, 2, 3},
                            };
                            memcpy(vertexMap, vertexMapTable[attachedFace], sizeof(vertexMap));
                        }
                        for (int rotationStep=0; rotationStep&lt;3; rotationStep++)
                        {
                            polytet.resetIndexing(i);
                            CompressedPolytet newRotatedPolytet;
                            newRotatedPolytet.reserve(tetCount - 2);
                            newRotatedPolytet.append(polytet, *t, vertexMap, rotationStep);

                            // Update the running "least" rotation
                            if (!haveRunningLeast ||
                                std::lexicographical_compare(
                                    newRotatedPolytet  .begin(), newRotatedPolytet  .end(),
                                    runningLeastPolytet.begin(), runningLeastPolytet.end()))
                            {
                                haveRunningLeast = true;
                                runningLeastPolytet = newRotatedPolytet;
                            }
                        }
                    skipThisTet:;
                    }
                    if (auto [insertedItem, wasInserted] = newPolytets-&gt;emplace(runningLeastPolytet); wasInserted)
                    {
                        // Check for overlap between this newly attached tetrahedron and the existing ones,
                        // and defer this until after the deduplication, to save a lot of time
                        overlap.setA(newTet.t);
                        for (auto tetCheckIntersection=polytet.cbegin(); tetCheckIntersection!=polytet.cend(); ++tetCheckIntersection)
                        {
                            if (&amp;*tetCheckIntersection == &amp;tetToAttachTo || &amp;*tetCheckIntersection == &amp;newTet)
                                continue; // skip this check for speed (it'll always be false anyway)
                            overlap.setB(tetCheckIntersection-&gt;t);
                            if (overlap())
                            {
                                newPolytets-&gt;erase(insertedItem);
                                break;
                            }
                        }
                    }
                    tetToAttachTo.faceAttached[faceNum] = NULL;
                }
            }

            polytet[1].faceAttached[0] = NULL;
            polytet[1].faceAttached[1] = NULL;
            polytet[1].faceAttached[2] = NULL;
        }

        delete polytets;
        polytets = newPolytets;

        for (int p=0; p&lt;4; p++)
            for (int d=0; d&lt;3; d++)
                start[p][d] *= 3;
    }
&#9;return 0;
}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=7T1dc-M2ks_nXwE7dY4kSx59TM0mluWtJJukpiqZnUs8V1fl0rkgEpY4Q5FaErTH8ej-yL3syz3e2_2N-wP3a64bXwRIkJI9mZvbqmV5bBLsbjQa6EZ3A-D8-38Gm7jI8d_1Mgj-6-pokPNwFpycjIdH_aPBn8dH87_-R8FvBl_9T_jfX0RJEBchI-cAFKWnq4uDsihKc54xurbLoCRKli5cgLgJd4rgmd9vWG4X0iyj905BvEyziK-cGm5ZwNPMLomj3CF-UyQBj9KExnZpkaRZyDIWXufM5WWVpUl6cXDw7NkXIbuJEkbe_Pr99Y8_vz4AqBsoMs8l0nK9EY0khEQ3BN5dv3rz87fX3768_JUczsiL5-IVy7I0I5erKCfws6JZOAjSkIXkBopfPB8sIk7iaL3IJXQSRjcHX8g_B7TgKck5zfhltGZkBvfh2Zlk9uws54yG99dBnAbvzs6S9K7TnR4c3KZRSP5SRPzPtyy7ibH04OEASBNBLSiyjCX700NECQUNIefn5OifgDaHDiZhwQhQDBmH7oAGparCIwFGrsRfp4awyCj2ynVAc37uvFpHMfQhC9IkzC86NpeDUgLd0yAtEt7pyhrW-bysA0QWS3bZ-4h3BiNgfntwgCMMu6-A0fbVNSeXjL9MQvZ-2vjmBxqwKXn2jEBTWM7JmEAX5YRmjBS56jdKbgCKRAhvCF1fA6XR-CvyXQrDrKxAsCcG9rl40yeTCwkzaQaa9MnzC-QpoysWgoymB0FM8xyLVH-Kno6SiCPHOXQzFspXeCGH33BOA8C_Gs6ht1-9-ekn0TIOz31-NcJf47kfY9SIMWnAGPswxm0YkwrGqIqxPdgUizgKzsSTJQ3Cp7qI9Byaz-fmjehO2UmigtFgQaEHp2Q4KxKQZbRMWKiBO8RzdckZgTdd8mDJebo1ODBcc-7wdcwlDvfiiC6TNQvmOobL44S9l7fVfgTb0hFtILMZGXYPbP5UOTHIJydTJbitHjCv0_ieg5jOiJSlHGrShJ5foh18qEpZsmSITkveM5ar12ABOnn0GwPNuYmyHNoLEhZmTttekq_SIg5JknKyYCSgcQzqA83hK0Y2iqsVzZMvOblnCMMSKN8UMeWqX0oplAMI1K8jTBmfLdgySkC4hB_OQP_x7uSEuyLigwstpeHUvOn0OLDavRKsz081xKiEMK2H4rElVJgiCBg6LkdWBL1L0hsxrHNyBxMViUKwXBG0lgSrKKNxxO8PwIJBESBwwsvBIsYGDFj4ITOl1A_DPhn1yRiMxLZvSiay0CoZy0JdMhKPUDiEEuTSX-P34RJqfDEXumrXaNExtShqhge7LgtmomqUZoukGwZGPs0GSjlU8THV05AqCKRMA2maBhT-6pKRKhmZkrEqGauSjPEiS5DGtlrvSbXePnELFq2MIB_khCyq7CA3orzCFPIkyvdgrSaSJ7A2aGBt0MDaYD_Weq2skT0Y65FFnSursGTJFNr8gJeV2G6WrDdM-d4yU9SQmd5C9iLy0FvInsOqe1IWW-NgVXw7YeLWm9_QPVSTeQcfOTkOc65rNvP8cZ4FunZTSBc5FKNvBb_PyZD8kQzw9gwLZLuRZLTepBnvCLKgRANQqq9A38TPsaShvC-0_4pWadmQRMKWEh9-CWfHsL8s2S-ZtVqg2mSxDy9LA6nMuvC1ZAn6SC-eXytPVQjRtIS9Fy0Rb4B3gSUbhHTSm45G7ur2ybaZxgkMckHGZfNc_1XBLtI0Bh_6FVuCabtF91V01TJB8XRRPgqwY6rsdbHZXTlMJe9aeeyaR745V4LD2LkgL19dArWfv_mXyuwLUIcWQx8-EAupbLdCf_mqhACGDmuzua_lurzeplHZJq3421KoJVtlHbKTB_DH1gHjVupJAquP6QZGRkU9dI9znFZYBt46f1WspQHpl2V_Ykm6jhJZWlgQt9Z9ceuCle9-LdZTq6qAIV1wCPvgSGRrGotbvt6Iv5vhZiRuTO3geLxO4UmUhizmVNwxmPlG5m4Md3YlFGdht2hRL4K4libLmEGxeSN0DsyFJT9lMkDMkoTWOsdNFLrnDjrh2eCEvZkNp2Rz_hx-nZy4Q8TAhAgTnk_gVxVGM2wZMeRlM78K50L55G1XjxnTDLS2yjSAn1fEFXtBrbZoGU3m1Vbgm3UR45DVRNAk98W8ZQ1ohKNhCKAW3EjAjXbCjQXcuGxDQ5ighnItNhIWGLzzvPOJR3JfhDdWc3Z14IPTlZrPjtKC0JaMA6B0oxkANab5rdCj5td17WqGlTrX_F5qYvv7sft-u7eOPDxaWx68uiM4oY6ieEEWXpDtHpxPPlK7Zadqi1TX6H_bUw2CmNHsb0EPBKOtiiAh2jRBQjSqgnzdrAvy_Z7KIIFbtEECtKhDCfDZ9UGy0q4QEubzaYTq3GaV0HP1N768zfsueajM4xBrvHcyN_D-2z1xFxaucFx1pNXp1tQQEyf0HSM0vKUJp0uGGQVMktzQALyOFeXiid-ldiwvU5IZWxYxzQhNQpyal1nB0P2GR5v82wJYDlYseIfOIU3uhRckqrHacUSPSp1X2QyEFbnOKuzi6NSu4U8ppnGkQx1xrCVN4nvBN_iZG1QTJEETWXNZzWl9PCAEGA_scXV7_sLcNo9u2zPpbYYi3KzlPhSVOTgj82kL-mgH-qiKbrhHaSnu1S1qpbrdT9uAAWnFIIAKrVGlXFKUt0hckQkRkpVDQY0YJnpfPD2HDpSix7QcMBjQOMD0GqbvEUDWUuPBtCXCVkTIf-TTOgd2h4bqy9-wCJUVRH68uKolyJTo5gCEUHXjA-L4TkwL0IdpFuIMJJJxcYx5R_AcebSJIxaSxT1ILEjXGxBXiGsXaRYtATy2EU999H9kOhLR2T4kRmFepUsUJq4QYFYQ84Ff2tSmKGcfxTC6jXLMkgqmcHVobZiEWZSbPtL8B2LpRIDXWXxML6jYoJxK-6TX8XfLUNhQj723bPeoyXY_dYQoj9_mbw9WNztZ3VF9XRU1M5hoMV6FxYynMot_6LfrIrIRm1ifCNb7ZOIhuP0E7cmLBfpAZI-uxwi7vaVITHlMfR-MuPTrJmL1VmIsWvdJCdFZAJEC8FBy8ByHVOMhsx5ElGgAQpFZJbjDzvNTGvrQMZ2E6N6sDl4wv4BOF3JtUU6COQFLhMsiMRojabvvVlGwIncMWlLOqDTHmTNViZmmus99VbcPa7-IfaUtQ8Ah5EjKV7pX92OTfP1gxRvDLjkHYWNOTUHuHcR0ycXubvIZ7csVy5kzy-DECz1YmWV8lX4CRcakiC8aUVq7t_w1PZVnaSKptLgu5cfZLeVUTH5Hp0ILwzj_0bzVuEXKuO0pH3QwtPOMU7ItoNLBipI8CqUbpvn4RMZbB5W-tCeWGjEMG8I1m5gOQC20kfDGxPUEYmOX2PhRxOrjxkoo2qkHKYORSegOm8JSYAuHRh13aHBHTbiq3ttG3FEzrqq3jjsyuI086_a6KRVd4d5N9qHvaHVtCqwQ-ci57_ecu-weLdpskY10681e7UCqpbY-cjorWqcxhLitQzxWstqNribi_Pm7hm7VM2uNiCMCf-_hpRZleVbl0JcQUsA3NM6Zztt8weDhQLW0knfpUbDwi6mT_N-Z46EYZb7fN6uzsKH_nsf5P8njqJV9kcHp9Gj3MUkcjTvajfvJMjj2IPK6H_-_EjhNHpKQ4KLbno-pWw29Q0QmS2bk4UEu-g-3W9Hux6Zj_qazMS2Z7Rrsnq6uyT6Qk1lD3238aTLVMxLn6XkSvExSgzTxIHIapAfCHJQsN_DkjTeBMsbyOmpvSlIA-Y3PJ6kQtmarCmH_BQakgbDcjukj-5kify8zj3CnGoQ_qJf7naQGGQ985fv6Sh6etJPkeQXBvDeQ-8zxvdK3WogGwoG5recX3Anp6LFng7T0garG2pzSott7xN5WDN2o3dG8gf9PGTurhoogisw8ch3Y4WWjoEQYBPhWtKsA9scf2_jjx-Bb7jcaIhUQ9nRABzR0gNnTUVoTpds6JYU1kjtCHeqjNp5uXd3VNGy2NI0WtlBzK6SeGBG6VB5hzBzpDoodpsuR4OB2B3RVSgOnYF_TVtRN2q1b9CSBlSROHHqVSO1TBWliK-FWHz-i4jDGK3aHZyTwiMYxhDLyL-OXqTyrcZnqzWSWz13ZZ3ycsLt_lpvtQeFOuRnDdrntYYqXH-MhSmeubVuFu0tUZD3QyTENaO-0fbws0zjl5TlCO-W2f7fVDf4B_WYw0zIqYHfqjMLBPnU69c2cx2cTMPRjtGwVHqwml9ygrU83MlpM4VdmZOyV6sQvVQQQBrox8NjMHydQHDmjk41aY66Jc1SVJz9tODzleztqfTtufSsOQLlKoeAcHh0cLQWBKc64yR28r8xMvevEj5Zq9eRPjYLKimh6x-rQTrXH8FBQdss66vUp7vvu2Eux1pkdxmcaLCiP7zB-WBaXJ3kYb8oRuEeucMqCeA0Ec72gwbsOIA4ueMV5F0LIcas6P1U196E_RG3evVUWwirKBxclkni0EeXJICc_dF4V3rU5ulAWLbp4nEjEmkHE43s8Gwa2m1Alw9lsoe6UXax3Mu1cU-Bp0QFi01LNpLTpjBoxA98LIGdJnR7i61LctA-_FtXeFZTk1luQcw98r_PZBfxdlDJDQ6gg6rva1YSh3p_rQwZSzu5ssnVFeFEVYV2C1dMfhx1gjyy6NVqz2d_7w-kPZwK3yqUXsBXn3H4QOSpvvlLlR07J92CVCIvZmklPnpK8WOTsL5i_tNH6Mg-JU8MtjQsmT8_JTNYdTBVMSJ5_mSvvAWlDOCZO4Wb6EK7CYSpWFvN6J8AAGZOUK5jfYS4GV-SG4fFhWVEOncECWkBgRzmJGYUmjQQq1ih2CdH4jt5DxXGGJ6Bx05DmoSuZyNiaRgmy6mPDzqd2ZBHylDCY_ZDYbyxL-1iZ5kOkgtNE5AF0Tdao654qk_5dut5AP-a7Tbo5uVy16dIf22xwVFXtuO2T6arEkqJyHn6mm6vncpFRyOuXlIusV1dP9tYByBJjLsZHYFgfpAXfFNy4AlM9Wrx4wnXQaUCNopLWJZcVlXDendrna_WkUp6u9XgO11bCV9-jH3HtSfm60xBiZygVFv4gYTFrqvHAFXfERv6RTKY1_BuDiD5VKQ98cmlXQi5x_MhtutdRqDv9_lhCnKXWwxEfZmQP6i4NC31wsW9H4LUp8pWcvOGyB3S34zIhj-oOyKgrvgIw7oKUtcArNGui1twhXfc8MF6guTGYE6cJTpNtdHF-y1WdupxtBH0y2-bHdPbYHFuvjSxMkzSxWg6Wmq9cGTlXmtZcMN7sWg89w0XjVptgsT-a-xx2R2C1_IOFPtkDvZpxsNDHe6CPm9GHe6BXs2rPeqh-RndBeXctC4mj2GJ13Wl4PZ6vysVpaCu4lMN6U4nie89cHZWzgZkEbJ3vW-T6puNr7rH0dxO6ZvkGdQlmI-UQceGIc3Z-IR5zcCcCccp_da6mn4uK8ZZutjxyai2uVl0zHXsony1J2fuAbXiDYa77ZQq_Ywj5ogPJRc5gOp4RN5zxrBWqrxB44hlvNLNrgJQ0gxmYnpJccCieDaVg32xYSTGaBTbF6FA8G4qRPzHkpyrEhSL6V_UBGdG7-njqxcO2PKva7fQiidBFOz18_zWb_OEPXy--xjy3oAEm_EXXPF3gKWB_9u2xtQKpF88_utZ6Ds8tcZ-UC41Eaxoz3aUeNWfvUYpSdxWPH6cxT1aAyKMAkU8BPIPM36GTsezQXvTU7mvvCLRdaI3RpxcOIM2WAQSDK5qBMcyWt1dzHd-pz2jY6QbxNSIyk51TyvDhYfB1X_xs1ccxTCnBH7eUCFhPKZEUJKtbdaC9fpRPrwgqANERPSXyXObwpFCdT155xpgUj8bEb6XkMAF0aoCY6kCXn4Yh5lr4PZHBBy5Qos8upALhjv6uS2fNaCIzrTi8a0GkHAtqvEFVt6qe78Sqp3F4bKhFTFfSUdYH_Y0HrxFno-nUGy8_5bNXNoMuc6W4qqohKUPEg2PUYODXqs6I-FaVQ-nzficLL5HCrkr_wuGyKfapfxVMfxEMHAwq4m_ni2Ce2vFaQMz9zpd-8wwKmy23DSJZqIQ6s78kgVc93EEUq7mjCoLiyZRVfIiSjjZyOgNqZCZ05aX4xgfFfVwgFZbkRcbkkifLcr3Kv6LJslzrlAH5EG9L--vkNkUnWyPOWWvxYmCmaShPl7hK0QMr8frJNqPSflSEsvme1C9-e0tRmJUKVM4Z1vtDG8DMHxZAWzwOr8FKXKZvEp2DKL_gVOdK5SJs8JlVkc2gB_SwAmt49cDuEx_oeMJcM9LzkCLH1URCtfF66aCJAM6ZdQr1JbpyFF5VSXtCEd9YvKr3x8kJ7g93VwL9EbzrXimtrfaujGelLg_0t1ya5ezare_x84yH5MeUS_vsoY9gfcLeb-RnDo8c0w4Vthg3vMrPEbotq-VecLFTpl0s0ZlamjYrenp8OK2XliwPRvXXe21q_Kih0ba5cmJvrkTDmb-LNiTGRK1cuVVpU5kddnO1OnbdMyJSQ2jX2lrL9rvGZXi8HAWQ3bnnSNcXLqHSJE3wA3J6OdfkgcR24igXllo7WlFi5VpRzOs-yVOZYoYpGRPRC1busqRLcHpBsGJ5tr65Ei-xboK59F-KBF24n0TKfGavGFSvevSRWbiv9bTpxRVpR6SvAxbv3hK8qruYjCvQvJmpOYKt5gObo85qQrwZsrk23dDjHIQS33_jZFl1u6MW0niZ9r_F9r9FvXnbtlXUNAC_IFat1x34b1uGvH0tU_wiLagnfukRqAg_Bz_wSImsoVzPgBa1ksSW7-DKlx2zr_Z8bvVSSdPdWd0aV7tl05bprV7WpxnNsLqki5iZT0G2YbePMQExEdthxuVnHVuhxwLa-qhjK_RIQE_Kz0S2Qtc-Ztl0bdtFtmbrYHNf5rv7Vck5nWi-PGeAfOfCTdWNb4y-aQP8K2di64r9jFpoP7cpZHvf2cFE-Y3VqIV1vOqmF2aHX2T2_3U1XvFdNfBaNAPuR1tWzk-klmW2c8t9R2TdhplBX2Bi3mxCXG8Vs6GcWciRWMo9MpRaSYi1stqc9uHDziEsHLsYuiJIlxndrHBevlazaWcvk1kTDSHl_hPfSxFE7FYuvDyzbEnb91JuWmm3Z7stjMc5qG8e3JNfGXg-ZsA2K6z_jTVdne2b5cULx4yIEa9kUoyFLzkD7-qO5i9Vgdou99pEqyrw7ngaCnGhhflYd8Vso0ajpJJ_4NjxO_xosnYKK9OvSVnq40QwjHOx4SJNWN48wjDNBxghu2GZpA1GIIoJveGigMGrsDCHYER2I8e9F5TEqTgexqN1ff-2vhT3p-KUnnSST6vLMfbl7B4TQnhpbf32byergTXsL6vBPdV442A57vko4uJgJXL68IG0wEqR7PY5nGMlImQSfRWYYZJvMD3egbCp3OOyYNKPxwOBUNBei9VT33Z8_NZ32fnkkurPz32s3XFVLaM569iquYMVvCrZRt_1WPPiL90jyHQ2hjZTrGQKyiCpdZPqLvDR48DHdXCLr5DFjJtvuue1_GDumklruv89v3kqMqNyczTpzXSGbHvwD2o1CMKDrfxfTdR_bvJX9fd_AQ" rel="nofollow noreferrer" title="C++ (GCC) – Attempt This Online">Attempt This Online!</a></p>
<p>This matches the output of wastl's program up to 12 terms, and does so much faster (<s>62</s> <s>65</s> 2600 times faster on my machine).</p>
<p>Certain design elements were quite natural and are shared between both our programs – namely, the use of 128-bit integer coordinates, the coordinates of the starting tetrahedron, and multiplying all coordinates by 3 for each successive term. The remaining details are implemented from scratch though, without consulting wastl's program.</p>
<p>The fact that both versions of my program agree with wastl's up to <span class="math-container">\$A276272(12)\$</span> strongly suggests that they're all correct up to that point (and beyond it by using larger integers), and that the OEIS entry can finally be updated.</p>
<p>My previous version used affine transformations to rotate each polytet for comparison and deduplication. I wanted to keep that version up, rather than relegating it to the edit history, but the 65536 character limit prevented that.</p>
<p>This new version does its rotations entirely while remaining in tree representation, using Cartesian coordinates only to check for overlaps between tetrahedrons.</p>
<p>Compared to the previous affine transform version, it's 32 times faster when both are in <code>USE_GMP</code> mode. In basic 128-bit integer mode, it's 40 times faster. In both modes, it uses about 32 times less RAM than the affine transform version (about 27 times less RAM than wastl's program).</p>
<p>It does deduplication by serializing the tree representation with every possible choice of singly-attached tetrahedron as its root node, doing 3 rotations of each, and choosing the serialization that is lexicographically least for hash-table comparison against polytets that were previously identified as unique using the same method.</p>
<p>As such, it's conceptually similar to the previous version – both take advantage of the fact that all polytets have some tetrahedrons that are attached on only one face, because due to a tetrahedron's dihedral angle being irrational, a polytet can never curve around and attach to one of its own faces.</p>
<p>So, the computationally expensive affine transformation is replaced with a tree re-rooting. This operation now being very fast, it can do a new optimization: Delaying the tetrahedron overlap/collision checking until after deduplication, so that a provisionally new polytet won't be checked for overlaps just to find that it's a duplicate.</p>
<p>The timings shown in the output are cumulative.</p>
<p>Output in basic 128-bit integer mode:</p>
<pre><code>1: 1 [0 ms]
2: 1 [0 ms]
3: 1 [0 ms]
4: 4 [0 ms]
5: 10 [0 ms]
6: 39 [0 ms]
7: 164 [2 ms]
8: 767 [13 ms]
9: 3656 [78 ms]
10: 18186 [455 ms]
11: 91532 [2775 ms]
12: 468203 [17162 ms]
</code></pre>
<p>Output in <code>USE_GMP</code> mode:</p>
<pre><code>1: 1 [0 ms]
2: 1 [0 ms]
3: 1 [0 ms]
4: 4 [0 ms]
5: 10 [0 ms]
6: 39 [2 ms]
7: 164 [12 ms]
8: 767 [72 ms]
9: 3656 [399 ms]
10: 18186 [2288 ms]
11: 91532 [13316 ms]
12: 468203 [78887 ms]
13: 2417722 [467574 ms]
14: 12595984 [2817342 ms]
</code></pre>
<p>There's still plenty of room for further speed-ups, such as adding multithreading, and applying various more specific optimizations. Disk storage and merge-sorting could be used to do away with the RAM limit, allowing time to become the only limit.</p>
<h2>Output from the affine transform version</h2>
<p>The version uses about 20% more RAM than wastl's program.</p>
<p>In basic 128-bit integer mode:</p>
<pre><code>1: 1 [0 ms]
2: 1 [0 ms]
3: 1 [0 ms]
4: 4 [0 ms]
5: 10 [2 ms]
6: 39 [10 ms]
7: 164 [53 ms]
8: 767 [296 ms]
9: 3656 [2350 ms]
10: 18186 [15845 ms]
11: 91532 [106165 ms]
12: 468203 [683449 ms]
13: 2417721 [4291118 ms]
14: 663520 [4734026 ms]
</code></pre>
<p>The 128-bit math is clearly overflowing beyond <span class="math-container">\$A276272(13)\$</span>, and as the version below shows, that value itself is also incorrect.</p>
<p>In <code>USE_GMP</code> mode:</p>
<pre><code>1: 1 [0 ms]
2: 1 [0 ms]
3: 1 [1 ms]
4: 4 [2 ms]
5: 10 [12 ms]
6: 39 [53 ms]
7: 164 [269 ms]
8: 767 [1607 ms]
9: 3656 [9653 ms]
10: 18186 [61997 ms]
11: 91532 [389137 ms]
12: 468203 [2459990 ms]
13: 2417722 [15555313 ms]
</code></pre>
<p>It may even be enough to reach <span class="math-container">\$A276272(14)\$</span>, though that's projected to use 42 GB RAM (getting close to my machine's 64 GB), so I won't be able to run it beyond that.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.rust-lang.org/" rel="nofollow noreferrer">Rust</a>, 11 (hopefully correct) terms</h1>

<pre class="lang-rust prettyprint-override"><code>
use ::std::ops::{Add, Sub, Mul};
use ::std::rc::Rc;
use ::std::hash::{Hash, Hasher};
use ::std::collections::HashSet;
use ::std::iter;
use ::std::fmt::{self, Formatter, Display};
use ::std::time::Instant;

type Coord = i128;

#[derive(Copy, Clone, PartialEq, Eq, Debug)]
struct Vec3([Coord; 3]);

impl Vec3 {
    fn dot(self, other: Vec3) -&gt; Coord {
        self.0.iter().zip(other.0.iter()).map(|(a, b)| a * b).sum()
    }
}

impl Display for Vec3 {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        write!(f, "({}, {}, {})", self.0[0], self.0[1], self.0[2])
    }
}

impl Mul&lt;Vec3&gt; for Coord {
    type Output = Vec3;

    fn mul(self, mut vec: Vec3) -&gt; Vec3 {
        for i in &amp;mut vec.0 {
            *i *= self;
        }
        vec
    }
}

impl Add for Vec3 {
    type Output = Vec3;

    fn add(mut self, other: Vec3) -&gt; Vec3 {
        for (i, n) in self.0.iter_mut().enumerate() {
            *n += other.0[i];
        }
        self
    }
}

impl Sub for Vec3 {
    type Output = Vec3;

    fn sub(self, other: Vec3) -&gt; Vec3 {
        self + (-1 * other)
    }
}

#[derive(Clone, Debug)]
struct Tetrahedron([Vec3; 4]);

impl Default for Tetrahedron {
    fn default() -&gt; Tetrahedron {
        Tetrahedron([
            Vec3([-1, -1, -1]),
            Vec3([-1,  1,  1]),
            Vec3([ 1, -1,  1]),
            Vec3([ 1,  1, -1]),
        ])
    }
}

impl Display for Tetrahedron {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        write!(f, "Tetrahedron({}, {}, {}, {})", self.0[0], self.0[1], self.0[2], self.0[3])
    }
}

impl Tetrahedron {
    fn collides(&amp;self, other: &amp;Tetrahedron) -&gt; bool {
        let mut othervecs = [3 * self.0[1], 3 * self.0[2], 3 * self.0[3]];
        let sum = self.0[0] + self.0[1] + self.0[2] + self.0[3];
        let mut same = 0;

        for (i, &amp;vec) in self.0.iter().enumerate() {
            let sum = sum - vec;
            let vec = 3 * vec;
            let through = vec - sum;
            for (j, &amp;u) in other.0.iter().enumerate() {
                let u = 3 * u;
                if u == vec { same += 1 }
                let up = (sum - u).dot(through);
                for &amp;v in &amp;other.0[j+1..] {
                    let v = 3 * v;
                    let edge = v - u;
                    let ep = edge.dot(through);

                    if up.signum() != ep.signum() || up.abs() &gt;= ep.abs() {
                        continue
                    }

                    let intersection = ep * u + up * edge;
                    if othervecs.iter().enumerate().all(|(i, &amp;ov)| {
                        let mid = othervecs[(i+1)%3] + othervecs[(i+2)%3];
                        let ov = 2 * ov - mid;
                        (2 * intersection - ep * mid).dot(ep * ov) &gt; 0
                    }) {
                        return true
                    }
                }
            }

            if i != 3 { othervecs[i] = vec; }
        }
        if same == 4 { panic!("EQUAL TETRAHEDRA IN .collides()"); }
        false
    }

    // Mirroring also scales by 3
    fn mirror(&amp;self, i: usize) -&gt; Tetrahedron {
        let mut sum = Vec3([0; 3]);
        for (j, &amp;vec) in self.0.iter().enumerate() {
            if j != i { sum = sum + vec; }
        }

        let mut copy = self.clone();
        copy.scale();

        copy.0[i] = 2 * sum - copy.0[i];
        copy.swap(i, 3);
        copy.rotate_left(i);

        copy
    }

    fn scale(&amp;mut self) {
        for vec in self.0.iter_mut() {
            *vec = 3 * *vec;
        }
    }

    fn rotate_left(&amp;mut self, n: usize) {
        self.0[..3].rotate_left(n)
    }

    fn swap(&amp;mut self, a: usize, b: usize) {
        self.0.swap(a, b)
    }

    fn reverse(&amp;mut self) {
        self.0.reverse()
    }
}

type EndpointIter&lt;'a&gt; = Box&lt;dyn Iterator&lt;Item = Endpoint&gt; + 'a&gt;;

#[derive(Debug, Clone)]
struct Endpoint {
    tree: Rc&lt;TetraTree&gt;,
    hedron: Rc&lt;Tetrahedron&gt;,
}

impl Endpoint {
    fn iter_endpoints(&amp;self) -&gt; EndpointIter {
        let mut hedron = Rc::clone(&amp;self.hedron);
        //Rc::make_mut(&amp;mut hedron).swap(0, 3);
        Rc::make_mut(&amp;mut hedron).reverse();

        Box::new(self.clone().into_iter_directions()
            .chain(self.tree.iter_endpoints(
                Rc::new(TetraTree {
                    subtrees: [None, None, None],
                    hedron,
                })
            ))
        )
    }

    fn into_iter_directions(self) -&gt; EndpointIter&lt;'static&gt; {
        Box::new(iter::successors(Some(self), |this| {
            let mut this = this.clone();
            Rc::make_mut(&amp;mut this.tree).rotate_left(1);
            Rc::make_mut(&amp;mut this.hedron).0[1..].rotate_left(1);
            Some(this)
        }).take(3))
    }

    fn iter_extensions(&amp;self) -&gt; EndpointIter {
        let mut tree = self.tree.as_ref().clone();
        tree.scale();

        let mut hedron = self.hedron.as_ref().clone();
        //hedron.swap(0, 3);
        hedron.reverse();
        hedron.scale();

        Box::new(Endpoint {
            tree: Rc::new(tree),
            hedron: Rc::clone(&amp;self.hedron),
        }.into_iter_directions().filter_map(|endpoint| {
            let mut new = endpoint.hedron.mirror(3);
            new.swap(0, 3);
            if endpoint.tree.collides(&amp;new) {
                None
            } else {
                let mut hedron = endpoint.hedron;
                Rc::make_mut(&amp;mut hedron).scale();

                Some(Endpoint {
                    tree: Rc::new(TetraTree {
                        subtrees: [Some(endpoint.tree), None, None],
                        hedron,
                    }),
                    hedron: Rc::new(new),
                })
            }
        }).chain(self.tree.iter_extensions(Rc::new(TetraTree {
            subtrees: [None, None, None],
            hedron: Rc::new(hedron),
        }))))
    }

    fn iter_tetrahedra&lt;'a&gt;(&amp;'a self)
      -&gt; Box&lt;dyn Iterator&lt;Item = &amp;Tetrahedron&gt; + 'a&gt; {
        Box::new(
          iter::once(self.hedron.as_ref()).chain(self.tree.iter_tetrahedra())
        )
    }
}

impl Default for Endpoint {
    fn default() -&gt; Endpoint {
        Endpoint::from(Tetrahedron::default())
    }
}

impl From&lt;Tetrahedron&gt; for Endpoint {
    fn from(mut hedron: Tetrahedron) -&gt; Endpoint {
        let mirrored = hedron.mirror(0);
        hedron.scale();

        Endpoint {
            tree: Rc::new(TetraTree {
                subtrees: [None, None, None],
                hedron: Rc::new(mirrored),
            }),
            hedron: Rc::new(hedron),
        }
    }
}

impl Hash for Endpoint {
    fn hash&lt;H: Hasher&gt;(&amp;self, hasher: &amp;mut H) {
        let mut stuff: Vec&lt;_&gt; = self.tree.hash_helper(1).collect();
        stuff.push(self.tree.len());
        stuff.sort();
        stuff.hash(hasher);
    }
}

impl PartialEq for Endpoint {
    fn eq(&amp;self, other: &amp;Endpoint) -&gt; bool {
        self.iter_endpoints().any(|ep| ep.tree == other.tree)
    }
}

impl Eq for Endpoint {}

#[derive(Debug, Clone)]
struct TetraTree {
    subtrees: [Option&lt;Rc&lt;TetraTree&gt;&gt;; 3],
    hedron: Rc&lt;Tetrahedron&gt;,
}

impl TetraTree {
    fn iter_endpoints&lt;'x&gt;(&amp;'x self, behind: Rc&lt;TetraTree&gt;) -&gt; EndpointIter&lt;'x&gt; {
        let mut iterator = self.subtrees.iter().enumerate()
          .filter_map(|(i, opt)| opt.as_ref().map(|some| (i, some)));

        if let Some(first) = iterator.next() {
            let closure = move |(i, subtree): (usize, &amp;'x Rc&lt;TetraTree&gt;)| -&gt; EndpointIter&lt;'x&gt; {
                let mut behind = behind.as_ref().clone();
                behind.rotate_left(3-i);

                let mut this = self.clone();
                this.rotate_left(i);

                Rc::make_mut(&amp;mut this.hedron).reverse();

                this.subtrees.swap(1, 2);
                this.subtrees[0] = Some(Rc::new(behind));

                for (j, subtree) in this.subtrees.iter_mut().enumerate().skip(1)
                  .filter_map(|(j, s)| s.as_mut().map(|s| (j, s))) {
                    Rc::make_mut(subtree).rotate_left(j);
                }

                subtree.iter_endpoints(Rc::new(this))
            };
            Box::new(closure(first).chain(iterator.flat_map(closure)))
        } else {
            let mut hedron = self.hedron.as_ref().clone();
            //hedron.swap(0, 3);
            hedron.reverse();
            Endpoint {
                tree: Rc::clone(&amp;behind),
                hedron: Rc::new(hedron),
            }.into_iter_directions()
        }
    }

    fn rotate_left(&amp;mut self, i: usize) {
        self.subtrees.rotate_left(i);
        Rc::make_mut(&amp;mut self.hedron).rotate_left(i);
    }

    fn collides(&amp;self, hedron: &amp;Tetrahedron) -&gt; bool {
        self.hedron.collides(hedron) ||
          self.subtrees.iter()
            .filter_map(Option::as_ref)
            .any(|subtree| subtree.collides(hedron))
    }

    fn scale(&amp;mut self) {
        for subtree in self.subtrees.iter_mut().filter_map(Option::as_mut) {
            Rc::make_mut(subtree).scale();
        }
        Rc::make_mut(&amp;mut self.hedron).scale();
    }

    fn iter_extensions(&amp;self, behind: Rc&lt;TetraTree&gt;) -&gt; EndpointIter {
        Box::new(self.subtrees.iter().enumerate().flat_map(move |(i, next)| {
            let mut behind = behind.as_ref().clone();
            behind.rotate_left(3-i);

            let mut this = self.clone();
            this.rotate_left(i);

            let hedron = Rc::make_mut(&amp;mut this.hedron);
            hedron.reverse();

            this.subtrees.swap(1, 2);
            this.subtrees[0] = Some(Rc::new(behind));

            for (j, subtree) in this.subtrees.iter_mut().enumerate().skip(1)
              .filter_map(|(j, s)| s.as_mut().map(|s| (j, s))) {
                let subtree = Rc::make_mut(subtree);
                subtree.scale();
                subtree.rotate_left(j);
            }

            if let Some(next) = next {
                hedron.scale();
                next.iter_extensions(Rc::new(this))
            } else {
                let mut mirrored = hedron.mirror(3);
                mirrored.swap(0, 3);
                hedron.scale();

                if this.collides(&amp;mirrored) {
                    Box::new(iter::empty()) as EndpointIter
                } else {
                    Box::new(iter::once(Endpoint {
                        tree: Rc::new(this),
                        hedron: Rc::new(mirrored),
                    }))
                }
            }
        }))
    }

    fn iter_tetrahedra&lt;'a&gt;(&amp;'a self)
      -&gt; Box&lt;dyn Iterator&lt;Item = &amp;Tetrahedron&gt; + 'a&gt; {
        Box::new(iter::once(self.hedron.as_ref()).chain(
          self.subtrees.iter()
            .filter_map(Option::as_deref)
            .flat_map(TetraTree::iter_tetrahedra)
        ))
    }

    fn len(&amp;self) -&gt; usize {
        1usize + self.subtrees.iter()
              .filter_map(Option::as_deref).map(TetraTree::len).sum::&lt;usize&gt;()
    }

    fn hash_helper&lt;'a&gt;(&amp;'a self, behind: usize)
      -&gt; Box&lt;dyn Iterator&lt;Item = usize&gt; + 'a&gt; {
        let sub: Vec&lt;_&gt; = self.subtrees.iter().filter_map(Option::as_deref)
          .map(|a| (a, a.len())).collect();
        let sum = sub.iter()
          .map(|&amp;(_, len)| len).sum::&lt;usize&gt;() + behind + 1;
        Box::new(iter::once(behind).chain(
            sub.into_iter().flat_map(move |(sub, len)|
                        iter::once(len).chain(sub.hash_helper(sum - len)))
        ))
    }
}

impl PartialEq for TetraTree {
    fn eq(&amp;self, rhs: &amp;TetraTree) -&gt; bool {
        self.subtrees == rhs.subtrees
    }
}

impl Eq for TetraTree {}

fn main() {
    let verbose = std::env::args().skip(1).any(|arg| arg == "-v");
    let begin = Instant::now();

    println!("1: 1 [{}ms]", begin.elapsed().as_millis());
    if verbose {
        println!("{}\n--", Tetrahedron::default());
    }

    let mut polytets = HashSet::new();
    polytets.insert(Endpoint::default());

    for i in 2.. {
        println!("{}: {} [{}ms]", i, polytets.len(), begin.elapsed().as_millis());

        if verbose {
            for polytet in &amp;polytets {
                for hedron in polytet.iter_tetrahedra() {
                    println!("{}", hedron);
                }
                println!("--");
            }
        }

        polytets = polytets.iter()
          .flat_map(Endpoint::iter_extensions)
          .collect();
    }
}

</code></pre>
<p><a href="https://tio.run/##vVrrb9vIEf8s/xUbF3XIWKYt6z4UlCwgTXJIgN4rcfvFFQxKWlnMUSSPSzr2Wfrb05nZN0VFvmvRAFbIfcxrZ34zs1LViPrr16NGcBbHol7EcVGKOH56vVj02adm1mc/NNl25C6o5nH8ce4NrRKxgk3v4b8@w09e@XvmRZbxeZ0WORDHBZ947S1Ia155A8t1DRQFz5Z99n1RrZMaVvTZ21SUWfLoU6/TNY/jD7mokxzIHtWPJWdviqJasCuWDi7/BmN/uVnwKr3nwZuifOyzN1mR8z77OanqNMne/dZn@PeWz5q7cHok6qqZ1@xffD4MbojQiA2nIZBJ12VG4@zpqLfM2aKoAylkUYPWMc2F7Gyi@MOqHs5HFxGqGITR72kZ0FozFEbrpAw2QdJns3DDEvYK/o9Esw7Co972aKu4KtXZsqhcCcBQwYkUYRmzk3VTW3uRIGTJj1w0WU3ifKmA7YsA1h8HT9s@k3/hcZ9JQW8upuZxYB8vp5404BZjlGJC8hhlyfQ/NXUJYlyRmGA0FHPdZMpQKOE9nzum0tr0kFTK0lyqAYuiCxrvvUrZqyuSZASvW/iDSVcc8FfPMHvlSBaLAIl3H5onSZD2WR6iOM4J3sJmOEWeN2teJTUPQiVhzk6vmDrYm3Sq5cStrqAQU88TVDSz4ICQOM1OWXA2AJehVfqIrLdLP2859jWvq2TFF1WRBzfEk31n3fstXyboLCims1J7vJwNSJTWdM8jjGaRIXQ26DP5Nw37/jCjP2@YqdUdw8whMt0bHbtC/zdB4upk4@WZMWMeh764uyIiRKYLLrSc6tRPnJUk6awoMhIx4zXFEi2EcBDgPzdD8ARHDuf10n8dTslFkQggDbuyioBHGQr2@dJ5HpqtFEnJmsP@C/RbEzcnIFA7dLrCxuEPn2cY8yM9Ds8wjjK7o/WqKpq7Fczg/Bnuozni/Bk4N8TXh9hdxkSrUfQbotBLlzgiCT9JvSCmB2xrN5SwI5CiNmGE6K/kCSUJlOLkniBMY8Hn00EUTRVXqZhWa2TH@OIOrXiPhN1hZIhzLV5yBQpcRiK9yzFZsBew1HndbHA2mQl4ntCUfFaS9OZFXqd5w@Xr9shyTXOwmpAJG/mXaCM4/wYfUJqR4W@8r8PSUZJlkNfQHYp7yGyaMXlOisnZ7L4J0tNB@Nchepk3eImDI2djgda7RMBDWwEZPRngoCf5mZQc1sijojeQhE3YhVLaWqPidVPlDADSGMR8StuAtinaGMDXkTGdSlcckZvgH6yTMXHFvoOlZZKn8xfB8btf/vn6H@z63fXH1@/fvf34mn34kUUm6sPjUFJYJpngR8Ty/Jz9kFZVUaX5HYPhgol5knHBZo9sKLMqTWvISGPWiPR33gnNJlwp2iSkXqiyxomeZ8Yt6PgZbZFioJj4PXUN4fCcQ82lIWaOGSkgpjgckUqBdGkauJAmxdOUgWZG7Z4vUDCBWw0tmaqoQbzbjC/rILXUpCExnRKbE536Q5PlMdi7UrxK6xaEXikU2hqaLs8TW1Tk5hhs9XcTRcOpJ2QeWtlQHYdAoghAPdhBSmpPxaKVhN@j27f1Uxv0rM5AVHO8yxdlAeHyATQev0wmoOXfi4fx4jFnOJTURTWGBzxavXQCBwwr3WqaCgtVTtv6Qm@gAqfiPGYf52NyyGt4m0D2lo5px@U7zOgE6ZIABelcuBpTOZLc3FXD83Pl@lfAAvoPcjraFalcikd5fo6T6@RXTmd@YveF0soX2sf2rzPGJZ8DE8Zxzr8Erq9HIF9xSyos0kr1QXgavV40XyVpLlejpaKWooRByBxpGgtq0IIaETeJmN38SHWe/Zz25RIppnzZEssQP63rdMrWad7xS2iw6nQ@IfZGU9wLjVgzn3MhikoEn4o1lxT6bFOvUrGxuR4th0NwLvifiwYdNqYlqGHohc7gm@v1wUD9Anm3ayMJiGvREtswqoFIMAwdm9AhPNQ8F2SOZ7gbSqkhjg4yEbcVX8LhOyrShAt4O87qeGgnhfNzNem7pxp0fNGMuezMmbnR1TMhKufI3uQwNkg7IwjXbPf4drRMM4JS7Gy1O7f8AJhhcaEmtdYqpUm9erCmpSqmHrOHDGorZ1itEzrGAKVuxiGfOjWfZ@4W85EJtz2Y4NhSuZFvybYtdyLWDVna76kSdkWwF8Lgrl5gW1aouxvmW@nb3fhiXXuPpAeRpc3e9YkwbMdSrTE@wVQTnLxMZJY66jGMqn2Jx21@VPLxsQeeGZMAVORziTrt8NljAytSYBFx29ECtzKR1/96p69f4nhZFevAkT2OzS6Pzfewzst/XQyJmPXCmLU7Qk8IWVtjCHEssP2gutgHDN/Cg7YPH046bd/Q8kj/3IYHHci1Ed4WdpkF7xzH72N13TjRNfCKXlWP/z70S9@6WS7pImV8O/HAGnfdrnhWQrU7CCN1XSlxlHZFZSNWjgtlPIeztNOQ@LzlSDCQsuCoVcfcOHbpxH9rd/96gd/6kxytSgG6rfwRsLbcYKcn05G@kCJscaXYYb89WNN5buD4wE8lQv7YK/Am2Fc8p8rziO6UeeOXD4gVD6osnvFVmi9atWRHlfIw8U49VaCiD1zL3tHbEJx4qQu7jKKsoXmFT5uRaU4Afm/otgOfwlCGEqQn5EzgvkwrAUd3ZWSIcoBe9@4D0qpoKqwc1sU9Z8RPCRjGLFBtANrA13qzV22ruLQXkJYPnfVEr6cm3TJpeJbqHNeq2dodHGAFllwdzdfB8syvmxUhczaU8wd9dumy0bN4SXUlLazRQ2oRamK6ndWmxA7PZ9B9lxuJX1PgSwl0xxWQHhheoCHlTukGG8kKHEBneU91LYNnpc9KL3Xrota0Y9qUZFiryqxO20z@U@6jHE0lOuNsyyypSXa1jNKyVxH94fpzXwHaWYG20oqTV1Q1qU6tO2s4CWFvmfmcdjzd7aGNF7Qdt8tr3ZJ3d4Pi3b691crsv751LW1264WbDUFRF17RhO@aEoLjWB6YWUH5QO3e6FDY4RUeviJRW801SVcQdYsDcyooukPC1CCyXj1gfLv6W33acxOFX0keSg02mCxQI5iHrabmWaD7Tcw9BLl7ERc3erce@9F3T8geHcLhPwbD/wsU/tMgLL9ZmKm@vNP9Rh72Or5oBzsw21wGmzRPfgBM8H/FvV1j96iXfaj39l8OxHd1rHtLegW/Pb2gjctd1T5JL69fDGyZGl3nsNb9Dl@X9SOUvCwRXhTJLOaK3N5JjVm7TW7fOaD2fr@7r32g/tK9mlcD/49285md5p/Ebii/HfQ2eGMgTP5KwlGO2larOvYk9qaKch6JP5CPp98S6YBQUUsQYEW/UIjjMRGfBFYMp5fyrG9xWabjA4ch6TqnoAK63b@1MfugbSVgJAAYSZ8lqpNr9Xzu15Iz11Jy80lw20dzAxB1WAJkVlnglA1Ge/xHIaX1mB5x0lVOR8IR@GscYipx0f5zyJI46r4D6Ll9rfwyBReE1nG629J2W2b70moldFFzTZC@U9Lo88DuE1ab947202EDM/h1FspNCCS//61mhaBbVfyVD8/v4SirO2EThCxxYGzD4AM5Hp/dH@MJ4v4Zv0sxFaofBsERFF8kApYVGDrLXwTHg5gN2M3Tdi2mx325I@JZUgq@wI4ackwKCClkrw@oqWVCdS2Vp@2/87MzILDnzkdVLBrMyyJ7hCjG7K5@CyXdA9fpOXAFwas6sJdKLrkj@1OZyyjakSYGg1qtoFIxVMnbDykqu1hXVWKniNCX20aFJ9NvqdIDZtXk7j2bRn9X1mNdLJuOyF8BdtV5V@Vex3zWWk6ImsCxtmtlXbXQDXl0Tvk7OPsruLcIGvh7sipJa/Za0PtY4RF9iXYNbgenBxg1kr8uUkhjUw4GyCd4iGO5dqSDAOiAv@BWgAmiPPFYoEnV3cp1myForqaQz/gak7IkodlMniuPDVz/cgPwMYnkXoUUX/8D" rel="nofollow noreferrer" title="Rust – Try It Online">Try it online!</a> The footer contains some compatability implementations because TIO's Rust is a little old. (This has already been <a href="https://chat.stackexchange.com/transcript/message/54872387#54872387">reported</a> and added to the <a href="https://gist.github.com/cairdcoinheringaahing/46f79623ea7b5cfe67286d0a5e96d307" rel="nofollow noreferrer">list</a>.)</p>
<p>Output:</p>
<pre class="lang-rust prettyprint-override"><code>1: 1 [0ms]
2: 1 [0ms]
3: 1 [2ms]
4: 4 [8ms]
5: 10 [35ms]
6: 39 [139ms]
7: 164 [738ms]
8: 767 [4328ms]
9: 3656 [31298ms]
10: 18186 [287871ms]
11: 91532 [3154716ms]
</code></pre>
<p>As you can see, it also reports how long it took. (These are cumulated times.) You can use the <code>-v</code> option to list all tetrahedra for each polytet.</p>
<p>I don't really have a good way of verifying the results beyond A276272(5). I hope it works, but I'm not sure.</p>
<p>The idea is that we store the polytet as a tree of tetrahedra that also encodes orientation. But for collision detection we need actual tetrahedra. We start with the tetrahedron with vertices (-1, -1, -1), (-1, 1, 1), (1, -1, 1), (1, 1, -1) and scale all tetrahedra by 3 for every term. This avoids the need for fractions.</p>
<p>Can probably be made faster, but I don't know how.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/214203/">214203</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




