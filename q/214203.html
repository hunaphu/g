<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::214203</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>016</td><td>C++ GCC</td><td>251003T124500Z</td><td><a href="https://codegolf.stackexchange.com/questions/214203/gluing-tetrahedra-together/283991#283991">Deadcode</a></td></tr>
<tr d-ix="1"><td>011</td><td>Rust</td><td>201108T231337Z</td><td><a href="https://codegolf.stackexchange.com/questions/214203/gluing-tetrahedra-together/214928#214928">wastl</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C++ (GCC)</a>, <s>12</s> <s>14</s> 16 terms</h1>
<pre class="lang-cpp prettyprint-override"><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;array&gt;
#include &lt;vector&gt;
#include &lt;unordered_set&gt;
#include &lt;chrono&gt;

//#define USE_GMP

#ifdef USE_GMP
#include &lt;gmp.h&gt;
#   if GMP_NUMB_BITS != 64
#   error This is hard-coded for 64-bit limbs
#   endif
#endif

auto startTime = std::chrono::steady_clock::now();

typedef uint8_t TetIndex;
typedef uint8_t TetIndexFace; // lowest 2 bits are used for a face index

#ifdef USE_GMP
class Tetrahedron
{
public:
    mpz_t t[4][3];
    Tetrahedron(const Tetrahedron &amp;_t) : Tetrahedron()
    {
        for (int p=0; p&lt;4; p++)
            for (int d=0; d&lt;3; d++)
                mpz_set(t[p][d], _t.t[p][d]);
    }
    Tetrahedron()
    {
        for (int p=0; p&lt;4; p++)
            for (int d=0; d&lt;3; d++)
                mpz_init(t[p][d]);
    }
    ~Tetrahedron()
    {
        for (int p=0; p&lt;4; p++)
            for (int d=0; d&lt;3; d++)
                mpz_clear(t[p][d]);
    }
};
#else
typedef __int128 Coord;
typedef std::array&lt;Coord, 3&gt; Coord3;
typedef std::array&lt;Coord3, 4&gt; Tetrahedron;
#endif

class Tet
{
    void initFaces()
    {
        faceAttached[0] = NULL; // t[0],t[1],t[2]
        faceAttached[1] = NULL; // t[0],t[1],t[3]
        faceAttached[2] = NULL; // t[0],t[2],t[3]
        faceAttached[3] = NULL; // t[1],t[2],t[3]
    }
public:
    Tetrahedron t;
    Tet *faceAttached[4];
    TetIndex index; // 1-based; 0=unassigned
    Tet(                    ) : t( ) {initFaces();}
    Tet(const Tetrahedron &amp;t) : t(t) {initFaces();}
    void assignIndex(TetIndex &amp;nextIndex)
    {
        if (index == 0)
            index = nextIndex++;
    }
};
class Polytet : public std::vector&lt;Tet&gt;
{
public:
    TetIndex nextIndex;
    void resetIndexing(size_t first) // This function should not be called if the polytet hasn't yet been populated
    {
       &#32;
        for (auto t=begin(); t!=end(); ++t)
            t-&gt;index = 0;
        (*this)[first].index = 1;
        nextIndex = 2;
    }
};

// vertex indices of faces with identical chirality
static int tetrahedronFaces[4][4] =
{
    {0, 1, 2, 3},
    {0, 3, 1, 2},
    {0, 2, 3, 1},
    {1, 3, 2, 0},
};

static int tetrahedronEdges[6][2] =
{
    {0, 1},
    {1, 2},
    {2, 0},
    {0, 3},
    {1, 3},
    {2, 3},
};

#ifndef USE_GMP
Coord3 operator+(const Coord3 &amp;a, const Coord3 &amp;b)
{
    Coord3 c;
    c[0] = a[0] + b[0];
    c[1] = a[1] + b[1];
    c[2] = a[2] + b[2];
    return c;
}
Coord3 operator-(const Coord3 &amp;a, const Coord3 &amp;b)
{
    Coord3 c;
    c[0] = a[0] - b[0];
    c[1] = a[1] - b[1];
    c[2] = a[2] - b[2];
    return c;
}
Coord3 operator*(const Coord3 &amp;a, const Coord b)
{
    Coord3 c;
    c[0] = a[0] * b;
    c[1] = a[1] * b;
    c[2] = a[2] * b;
    return c;
}
Coord dot(const Coord3 &amp;a, const Coord3 &amp;b)
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}
#endif

class TetrahedronOverlap
{
    const Tetrahedron *a, *b;
public:
    void setA(const Tetrahedron &amp;x) {a = &amp;x;}
    void setB(const Tetrahedron &amp;x) {b = &amp;x;}
#ifdef USE_GMP
private:
    mpz_t intersectNumerator, intersectDenominator, uNumerator, vNumerator, uvDenominator, uvNumeratorSum;
    mpz_t center[3], normal[3], tmp[3], p0p1[3], intersectionPoint[3], delta[3], edge1[3], edge2[3];
    mpz_t triangle[3][3];
    void dot(mpz_t &amp;result, const mpz_t _a[3], const mpz_t _b[3])
    {
        mpz_mul   (result, _a[0], _b[0]);
        mpz_addmul(result, _a[1], _b[1]);
        mpz_addmul(result, _a[2], _b[2]);
    }
public:
    TetrahedronOverlap()
    {
        mpz_inits(intersectNumerator, intersectDenominator, uNumerator, vNumerator, uvDenominator, uvNumeratorSum, NULL);
        for (int d=0; d&lt;3; d++)
        {
            mpz_init(center[d]);
            mpz_init(normal[d]);
            mpz_init(tmp[d]);
            mpz_init(p0p1[d]);
            mpz_init(intersectionPoint[d]);
            mpz_init(delta[d]);
            mpz_init(edge1[d]);
            mpz_init(edge2[d]);
        }
        for (int p=0; p&lt;3; p++)
            for (int d=0; d&lt;3; d++)
                mpz_init(triangle[p][d]);
    }
    ~TetrahedronOverlap()
    {
        mpz_clears(intersectNumerator, intersectDenominator, uNumerator, vNumerator, uvDenominator, uvNumeratorSum, NULL);
        for (int d=0; d&lt;3; d++)
        {
            mpz_clear(center[d]);
            mpz_clear(normal[d]);
            mpz_clear(tmp[d]);
            mpz_clear(p0p1[d]);
            mpz_clear(intersectionPoint[d]);
            mpz_clear(delta[d]);
            mpz_clear(edge1[d]);
            mpz_clear(edge2[d]);
        }
        for (int p=0; p&lt;3; p++)
            for (int d=0; d&lt;3; d++)
                mpz_clear(triangle[p][d]);
    }
    bool operator()()
    {
        // Take advantage of the fact that the two tetrahedrons are regular and congruent, and
        // just check if any edge of tetrahedron "a" intersects with any face of tetrahedron "b".
        // Don't count it if only the endpoint of an edge intersects.
        for (int edgeNum=0; edgeNum&lt;6; edgeNum++)
        {
            const mpz_t *p0 = a-&gt;t[tetrahedronEdges[edgeNum][0]];
            const mpz_t *p1 = a-&gt;t[tetrahedronEdges[edgeNum][1]];
            for (int faceNum=0; faceNum&lt;4; faceNum++)
            {
                const mpz_t *normalizedTetrahedron[4][3]; // first 3 points are the face, and the 4th point is for calculating the normal
                for (int i=0; i&lt;4; i++)
                    for (int d=0; d&lt;3; d++)
                        normalizedTetrahedron[i][d] = &amp;b-&gt;t[tetrahedronFaces[faceNum][i]][d];
                // Center coordinates will be multiplied by 3 compared to original coordinates.
                // Get center of face by averaging its vertices' coordinates; the
                // division by 3 is implied by omitting the multiplication by 3.
                for (int d=0; d&lt;3; d++)
                    mpz_set(center[d], *(normalizedTetrahedron[0][d]));
                for (int p=1; p&lt;3; p++)
                    for (int d=0; d&lt;3; d++)
                        mpz_add(center[d], center[d], *(normalizedTetrahedron[p][d]));
                for (int d=0; d&lt;3; d++)
                {
                    mpz_neg(normal[d], center[d]);
                    mpz_addmul_ui(normal[d], *(normalizedTetrahedron[3][d]), 3);
                }
                for (int d=0; d&lt;3; d++)
                {
                    mpz_sub(tmp [d], *(normalizedTetrahedron[0][d]), p0[d]);
                    mpz_sub(p0p1[d],                         p1[d],  p0[d]);
                }
                dot(intersectNumerator  , normal, tmp);
                dot(intersectDenominator, normal, p0p1);
                int cmp = mpz_cmp_ui(intersectDenominator, 0);
                if (cmp == 0)
                    continue; // edge is parallel to face, which we don't count as an overlap
                if (cmp &lt; 0)
                {
                    mpz_neg(intersectNumerator  , intersectNumerator  );
                    mpz_neg(intersectDenominator, intersectDenominator);
                }
                if (mpz_cmp_ui(intersectNumerator, 0) &lt;= 0 || mpz_cmp(intersectNumerator, intersectDenominator) &gt;= 0)
                    continue;
                // These coordinates are all multiplied by intersectDenominator
                for (int d=0; d&lt;3; d++)
                {
                    mpz_mul(intersectionPoint[d], p0[d], intersectDenominator);
                    mpz_addmul(intersectionPoint[d], p0p1[d], intersectNumerator);
                }
                for (int i=0; i&lt;3; i++)
                    for (int d=0; d&lt;3; d++)
                        mpz_mul(triangle[i][d], *(normalizedTetrahedron[i][d]), intersectDenominator);
                // Check if the intersection point is inside the triangle
                for (int d=0; d&lt;3; d++)
                {
                    mpz_sub(delta[d], intersectionPoint[d], triangle[0][d]);
                    mpz_sub(edge1[d], triangle[1][d]      , triangle[0][d]);
                    mpz_sub(edge2[d], triangle[2][d]      , triangle[0][d]);
                }
                mpz_mul   (uNumerator, delta[1], edge2[0]);
                mpz_submul(uNumerator, delta[0], edge2[1]);
                mpz_mul   (vNumerator, delta[0], edge1[1]);
                mpz_submul(vNumerator, delta[1], edge1[0]);
                mpz_mul   (uvDenominator, edge1[1], edge2[0]);
                mpz_submul(uvDenominator, edge1[0], edge2[1]);
                cmp = mpz_cmp_ui(uvDenominator, 0);
                if (cmp == 0)
                    continue;
                if (cmp &lt; 0)
                {
                    mpz_neg(uNumerator, uNumerator);
                    mpz_neg(vNumerator, vNumerator);
                    mpz_neg(uvDenominator, uvDenominator);
                }
                if (mpz_cmp_ui(uNumerator, 0) &lt;= 0 || mpz_cmp_ui(vNumerator, 0) &lt;= 0)
                    continue;
                mpz_add(uvNumeratorSum, uNumerator, vNumerator);
                if (mpz_cmp(uvNumeratorSum, uvDenominator) &lt; 0)
                    return true;
            }
        }
        return false;
    }
#else
public:
    bool operator()()
    {
        // Take advantage of the fact that the two tetrahedrons are regular and congruent, and
        // just check if any edge of tetrahedron "a" intersects with any face of tetrahedron "b".
        // Don't count it if only the endpoint of an edge intersects.
        for (int edgeNum=0; edgeNum&lt;6; edgeNum++)
        {
            Coord3 p0 = (*a)[tetrahedronEdges[edgeNum][0]];
            Coord3 p1 = (*a)[tetrahedronEdges[edgeNum][1]];
            for (int faceNum=0; faceNum&lt;4; faceNum++)
            {
                Tetrahedron normalizedTetrahedron; // first 3 points are the face, and the 4th point is for calculating the normal
                for (int i=0; i&lt;4; i++)
                    normalizedTetrahedron[i] = (*b)[tetrahedronFaces[faceNum][i]];
                Coord3 center = {{0, 0, 0}}; // multiplied by 3 compared to original coordinates
                // Get center of face by averaging its vertices' coordinates; the
                // division by 3 is implied by omitting the multiplication by 3.
                for (int p=0; p&lt;3; p++)
                    for (int d=0; d&lt;3; d++)
                        center[d] += normalizedTetrahedron[p][d];
                Coord3 normal;
                for (int d=0; d&lt;3; d++)
                    normal[d] = normalizedTetrahedron[3][d] * 3 - center[d];
                Coord intersectNumerator   = dot(normal, normalizedTetrahedron[0] - p0);
                Coord intersectDenominator = dot(normal,                       p1 - p0);
                if (intersectDenominator == 0)
                    continue; // edge is parallel to face, which we don't count as an overlap
                if (intersectDenominator &lt; 0)
                {
                    intersectNumerator   = -intersectNumerator;
                    intersectDenominator = -intersectDenominator;
                }
                if (intersectNumerator &lt;= 0 || intersectNumerator &gt;= intersectDenominator)
                    continue;
                // These coordinates are all multiplied by intersectDenominator
                Coord3 intersectionPoint = p0 * intersectDenominator + (p1 - p0) * intersectNumerator;
                Coord3 triangle[3];
                for (int i=0; i&lt;3; i++)
                    triangle[i] = normalizedTetrahedron[i] * intersectDenominator;
                // Check if the intersection point is inside the triangle
                Coord3 delta = intersectionPoint - triangle[0];
                Coord3 edge1 = triangle[1]       - triangle[0];
                Coord3 edge2 = triangle[2]       - triangle[0];
                Coord uNumerator = delta[1]*edge2[0] - delta[0]*edge2[1];
                Coord vNumerator = delta[0]*edge1[1] - delta[1]*edge1[0];
                Coord uvDenominator = edge1[1]*edge2[0] - edge1[0]*edge2[1];
                if (uvDenominator == 0)
                    continue;
                if (uvDenominator &lt; 0)
                {
                    uNumerator = -uNumerator;
                    vNumerator = -vNumerator;
                    uvDenominator = -uvDenominator;
                }
                if (uNumerator &lt;= 0 || vNumerator &lt;= 0)
                    continue;
                if (uNumerator + vNumerator &lt; uvDenominator)
                    return true;
            }
        }
        return false;
    }
#endif
};

void attachNewTet(Tet &amp;t, Tet &amp;tetToAttachTo, const int faceNum)
{
#ifdef USE_GMP
    mpz_t *newVertex = t.t.t[0];
    // Get center of face by averaging its vertices' coordinates.
    for (int d=0; d&lt;3; d++)
        mpz_set(newVertex[d], tetToAttachTo.t.t[tetrahedronFaces[faceNum][0]][d]);
    for (int p=1; p&lt;3; p++)
        for (int d=0; d&lt;3; d++)
            mpz_add(newVertex[d], newVertex[d], tetToAttachTo.t.t[tetrahedronFaces[faceNum][p]][d]);
    // Finalize the new vertex
    for (int d=0; d&lt;3; d++)
    {
        mpz_div_ui(newVertex[d], newVertex[d], 3);
        mpz_mul_ui(newVertex[d], newVertex[d], 2);
        mpz_sub   (newVertex[d], newVertex[d], tetToAttachTo.t.t[3 - faceNum][d]);
    }
#else
    Coord3 &amp;newVertex = t.t[0];
    newVertex = {{0, 0, 0}};
    // Get center of face by averaging its vertices' coordinates.
    for (int p=0; p&lt;4; p++)
    {
        if (p == 3 - faceNum)
            continue;
        for (int d=0; d&lt;3; d++)
            newVertex[d] += tetToAttachTo.t[p][d];
    }
    // Finalize the new vertex
    for (int d=0; d&lt;3; d++)
        newVertex[d] = newVertex[d]/3 * 2 - tetToAttachTo.t[3 - faceNum][d];
#endif
    // Copy the other vertices
    for (int p=0; p&lt;3; p++)
    {
        int p1 = tetrahedronFaces[faceNum][p];
        for (int d=0; d&lt;3; d++)
#ifdef USE_GMP
            mpz_set(t.t.t[1+p][d], tetToAttachTo.t.t[p1][d]);
#else
            t.t[1+p][d] = tetToAttachTo.t[p1][d];
#endif
    }
    t.faceAttached[0] = NULL;
    t.faceAttached[1] = NULL;
    t.faceAttached[2] = NULL;
    t.faceAttached[3] = &amp;tetToAttachTo;
    tetToAttachTo.faceAttached[faceNum] = &amp;t;
}

// First two tetrahedrons are implied. Each element is a subsequent tetrahedron, with the value indicating where
// it's attached. The lower 2 bits indicate which face (can only have 3 different values, because at least 1 face
// will always already be attached). The remaining bits indicate which tetrahedron (which can never be zero,
// because that one is attached implicitly).
class CompressedPolytet : public std::vector&lt;TetIndexFace&gt;
{
public:
    void append(Polytet &amp;polytet, Tet &amp;tetToCompress, int vertexMap[4], int faceRotation)
    // indices of vertexMap[] are compressed-output vertices; elements of vertexMap[] are the original vertices of tetToCompress
    {
        tetToCompress.assignIndex(polytet.nextIndex);
        for (int _faceNum=0; _faceNum&lt;3; _faceNum++)
        {
            int rotatedFaceNum = (_faceNum + faceRotation) % 3;
            int faceNum = 3 - vertexMap[3 - rotatedFaceNum];
            if (!tetToCompress.faceAttached[faceNum])
                continue;
            Tet *attachedTet = tetToCompress.faceAttached[faceNum];
            attachedTet-&gt;assignIndex(polytet.nextIndex);
            push_back((((TetIndexFace)(tetToCompress.index - 1)) &lt;&lt; 2) + _faceNum);
           &#32;
            int attachedFace = 0;
            while (attachedTet-&gt;faceAttached[attachedFace] != &amp;tetToCompress)
                attachedFace++;
            int vertexMap2[4];
            int rotation = 0;
            while (vertexMap[tetrahedronFaces[rotatedFaceNum][rotation]] != tetrahedronFaces[faceNum][0])
                rotation++;
            vertexMap2[1] = tetrahedronFaces[attachedFace][0];
            vertexMap2[3] = tetrahedronFaces[attachedFace][1];
            vertexMap2[2] = tetrahedronFaces[attachedFace][2];
            vertexMap2[0] = tetrahedronFaces[attachedFace][3];
            /*if (faceNum == 3)
            {
                int tmp = vertexMap2[3];
                vertexMap2[3] = vertexMap2[2];
                vertexMap2[2] = tmp;
            }*/
            append(polytet, *attachedTet, vertexMap2, rotation);
        }
    }
};

namespace std
{
    template&lt;&gt;
    struct hash&lt;CompressedPolytet&gt;
    {
        std::size_t operator()(const CompressedPolytet &amp;polytet) const noexcept
        {
            std::size_t seed = polytet.size();
            for (auto i=polytet.cbegin(); i!=polytet.cend(); ++i)
                seed ^= std::hash&lt;uint32_t&gt;{}(*i) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2);
            return seed;
        }
    };
};

int main(int argc, char *argv[])
{
#ifdef USE_GMP
    Tetrahedron start;
    for (int d=0; d&lt;3; d++)
    {
        mpz_set_si(start.t[0][d], -9);
        for (int p=1; p&lt;4; p++)
            mpz_set_si(start.t[p][d], 9);
    }
    for (int p=1; p&lt;4; p++)
        mpz_set_si(start.t[p][p-1], -9);
#else
    static Tetrahedron start =
    {{
        {{-9,-9,-9}},
        {{-9, 9, 9}},
        {{ 9,-9, 9}},
        {{ 9, 9,-9}}
    }};
#endif

    TetrahedronOverlap overlap;

    auto *polytets = new std::unordered_set&lt;CompressedPolytet&gt;;
    polytets-&gt;insert(CompressedPolytet()); // add empty vector as the starter polytet (meaning it has two tetrahedrons)
    size_t prevPolytetCount = 0;
   &#32;
    size_t blahNum = 0;

    for (int tetCount=1;;)
    {
        auto currentTime = std::chrono::steady_clock::now();
        size_t polytetCount = polytets-&gt;size();
        std::cout &lt;&lt; tetCount &lt;&lt; ": " &lt;&lt; polytetCount &lt;&lt; " [" &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(currentTime - startTime).count() &lt;&lt; " ms]" &lt;&lt; std::endl;
        if (prevPolytetCount &gt; polytetCount)
        {
            std::cerr &lt;&lt; "Quit due to apparent overflow" &lt;&lt; std::endl;
            break;
        }
        prevPolytetCount = polytetCount;
        if (++tetCount &lt;= 2)
            continue;
        /*if (tetCount &gt; 6)
            break;*/
       &#32;
        Polytet polytet;
        polytet.reserve(tetCount); // Important, to ensure pointers don't change
        Tet &amp;t0    = polytet.emplace_back(start);
        attachNewTet(polytet.emplace_back(), t0, 3);

        auto *newPolytets = new std::unordered_set&lt;CompressedPolytet&gt;;
        polytet.resize(tetCount);
        for (auto basePolytet=polytets-&gt;cbegin(); basePolytet!=polytets-&gt;cend(); ++basePolytet)
        {
            int tetNumToUncompress = 2;
            for (auto elementToUncompress=basePolytet-&gt;cbegin(); elementToUncompress!=basePolytet-&gt;cend(); ++elementToUncompress)
            {
                int faceNum          = *elementToUncompress &amp; 3;
                int tetNumToAttachTo = *elementToUncompress &gt;&gt; 2;
                Tet &amp;tetToAttachTo = polytet[tetNumToAttachTo];
                attachNewTet(polytet[tetNumToUncompress++], tetToAttachTo, faceNum);
            }
            if (tetNumToUncompress != tetCount - 1)
            {
                std::cerr &lt;&lt; "Error! Got " &lt;&lt; tetNumToUncompress &lt;&lt; ", expected " &lt;&lt; tetCount - 1 &lt;&lt; std::endl;
                exit(-1);
            }

            Tet &amp;newTet = polytet[tetCount - 1];
            for (int tetNumToAttachTo = 0; tetNumToAttachTo &lt; tetCount-1; tetNumToAttachTo++)
            {
                Tet &amp;tetToAttachTo = polytet[tetNumToAttachTo];
                for (int faceNum=0; faceNum&lt;3; faceNum++) // skip last face because it's always already attached
                {
                    if (tetToAttachTo.faceAttached[faceNum])
                        continue;
                    attachNewTet(newTet, tetToAttachTo, faceNum);
                    // Canonicalize the rotation of this new polytet in compressed form, so that it can be compared against others
                    bool haveRunningLeast = false;
                    CompressedPolytet runningLeastPolytet;

                    Tet *t = &amp;polytet[1];
                    for (int i=0; i&lt;tetCount; i++)
                    {
                        int attachedFace;
                        int vertexMap[4];
                        {
                            Tet &amp;singlyAttachedTet = polytet[i];
                            for (int j=0; j&lt;3; j++)
                                if (singlyAttachedTet.faceAttached[j])
                                    goto skipThisTet; // not a singly attached tet
                            t = singlyAttachedTet.faceAttached[3];
                            attachedFace = 0;
                            while (t-&gt;faceAttached[attachedFace] != &amp;singlyAttachedTet)
                                attachedFace++;
                            static int vertexMapTable[4][4] =
                            {
                                {3, 0, 2, 1},
                                {2, 0, 1, 3},
                                {1, 0, 3, 2},
                                {0, 1, 2, 3},
                            };
                            memcpy(vertexMap, vertexMapTable[attachedFace], sizeof(vertexMap));
                        }
                        for (int rotationStep=0; rotationStep&lt;3; rotationStep++)
                        {
                            polytet.resetIndexing(i);
                            CompressedPolytet newRotatedPolytet;
                            newRotatedPolytet.reserve(tetCount - 2);
                            newRotatedPolytet.append(polytet, *t, vertexMap, rotationStep);

                            // Update the running "least" rotation
                            if (!haveRunningLeast ||
                                std::lexicographical_compare(
                                    newRotatedPolytet  .begin(), newRotatedPolytet  .end(),
                                    runningLeastPolytet.begin(), runningLeastPolytet.end()))
                            {
                                haveRunningLeast = true;
                                runningLeastPolytet = newRotatedPolytet;
                            }
                        }
                    skipThisTet:;
                    }
                    if (auto [insertedItem, wasInserted] = newPolytets-&gt;emplace(runningLeastPolytet); wasInserted)
                    {
                        // Check for overlap between this newly attached tetrahedron and the existing ones,
                        // and defer this until after the deduplication, to save a lot of time
                        overlap.setA(newTet.t);
                        for (auto tetCheckIntersection=polytet.cbegin(); tetCheckIntersection!=polytet.cend(); ++tetCheckIntersection)
                        {
                            if (&amp;*tetCheckIntersection == &amp;tetToAttachTo || &amp;*tetCheckIntersection == &amp;newTet)
                                continue; // skip this check for speed (it'll always be false anyway)
                            overlap.setB(tetCheckIntersection-&gt;t);
                            if (overlap())
                            {
                                newPolytets-&gt;erase(insertedItem);
                                break;
                            }
                        }
                    }
                    tetToAttachTo.faceAttached[faceNum] = NULL;
                }
            }

            polytet[1].faceAttached[0] = NULL;
            polytet[1].faceAttached[1] = NULL;
            polytet[1].faceAttached[2] = NULL;
        }

        delete polytets;
        polytets = newPolytets;

        for (int p=0; p&lt;4; p++)
            for (int d=0; d&lt;3; d++)
#ifdef USE_GMP
                mpz_mul_ui(start.t[p][d], start.t[p][d], 3);
#else
                start[p][d] *= 3;
#endif
    }
&#9;return 0;
}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=7TzbcuS2cs_RV2DlijwzmtHOZWuPV6NRlb3Hdm2V7bOxtXlRJlMcEtJwl0MyJCitrFV-JC_nJY95y9fka9KNGwEC5Iz24pNTFZS94oCNRqPR3ehuAPyP_wrzpCrx_9V1GP735eGoZNEiPD6ejg-Hh6O_TA-Xf_3Pil2Nvvmff_nqqzgNkyqi5AyA4uxkc35QV8VZyQoabM06qInTaxsuKIrgzqy4oSHLCrOmSrMiogWNViVl5otwU2Rpdn5w8PTpVxG9ilNK3vz2_erHn18fANQVVOnfdaPrbc4pIITEVwTerX558_N3q-9eXfxGnizI82f8FS2KrCAXm7gk8N8mKKJRmEU0IldQ_fzZaB0zksTbdSmg0yi-OvhK_DkIKpaRkgUFu4i3lCzgOTo9FcSenpaMBtHdKkyy8N3paZrd9vrzgwN2l1Okt4pT9s2KkQvKXqURfT9vffNDENI5efqUJNktLRmZEqCpJEFBSVVKQgNyBVAkRniHJWESlCWiK4INjYC4g_uDvFoncXh6AGMi2_x36I5dPltezpZzXmUA98IsLZlZQ45WrE9OLaA-b3bP_8WCRPVgICRfjOckP3sG_xwf9_V7CyZCmOhsBv80YRR9IBA9dpkvL6PlkKzYiXzuC3IfHKK_ND1xGmuCLCL-_Y-kIkxoUDhkPMxBQpOSaolaAblsMv2GvMxAwWpJ4-LK9fKMvxmS2bmAmbUDzYbk2bnJ67nWBy1oB2LIN1kcEeQUinDpcgNqv2UsCAHP5XgJ-vPLm59-4qLO4PeQXU7wn-nS32LS2mLW0mLqazHtajFrtJg0WzxYmmQqCdOaRAYWzme1jnH9FlrLO5iM1gGo9JyMF1UKvIyvUxop4F5TArCgHsKbPrk3-DzX-uBTXibaMG8bPmWiZ05cT1N5lNL34rE5j2Bde3wMZLEgY1tSZT3RjY-PDTEVAvM6S-4YsOmUCF4KkRPLw9kFrgT3TS4LkjTSeU17QUv5GlagXhn_TsG2XcVFCeMFDnNDf1WlIYuBF-Umq5KIpBkja0rCIEnAnsJw2IaSXFK1Ccr0a0buKMLQFOrzKgmYnJeaC7aS86WBLdb0OgYzMCfsyQKUBJ-Oj5nNIjY6V1waz_Wb3oABqf1LTvryREFMagg9eqieGkyFRZLc0IIJyYphdkl2xcW6JLcx25A4oimLYbQk3MRFkMTs7gBWMagiaHdYLSxcNnBdeAZ6IJX6fjwkkyGZgrF4GOqamag0aqaiUtVM-E-oHEMNUunv8fvoGnp8vuS6avZo4NG9SGyaBrMvA2Yme4RlMTXXRWHOSJbTIgBRO5bKIquPgiGxK9Z9SZCsCAXTQ2G7AvxzTNbwR9VPRP1E1E90_VTUT0X9VNYXlFVFilgfmqSNPgNpoxbSRi2kjfYjbdBJGtmDsAFZu1QZlTVJutKhh0QZ25tHsjV2PliLWcM-B2sxU9jVQIz9wV3alKD-BVQsCXKJ0jWzA-h_AOSahosbKDBP3_rM8nuwxwGM9Oi9aYoB-rs26LWCbvh7eRHfgIEynTvQMlqUYFF_qbZi3oZ13Z9pmm3jVNRWBsSN8Vzd2GD1u9-q7dzoKqSIF9bHIdjVYhsk_JFtc_43H-cT_qB7Bzv8OoNfvDaiCQv4EwVDMNFPU-2ZSme1iIP0OqFQrd9wfqEcCJAjWAmqhCkpEJUrgdyqWkNVc0nDV9sqQTus0KxQXoYIPlauloIMogiATciJgJzshpwKyGntvrU4FFLgHC9KeaNl7wtP8pA7QsaAdnmqNY0mnT0pIJHJGwtAik07AApT-1suYu2vXcFrhxXi2P5eCGn3-6n9_qE1GJh9lpBEKUZ3ZNIlTDyo-HuQJhH9dImTgOiSJxlBtQmUeN0uUeL9niIlgDtkSgB0CFUN8IdJlWRQu1itsyzR3kCv74gUOt3BO0qC6CZIWXBN0RtFBxs8UjDkm4DxX-w2M_1Akd8o6DX42gUJ0ght9nVRwWQP8aeJ_m0FxhxCq_Ad-u5BeseXDN6NsWQeBoe1_EpPGGF54qQJuz48MXv4c4YhQJhVwLOYYS9ZmtxxusE_yHHKEUWQip7rbk7ceUEIUATkvHw8e64f2wXeXLIG-RhdotE5u3RcZ4loCavUct6BYbIbw6SJQY8BeSbHIB8xlSEfm5J078iVRYnQTojTIsM-yVwU8p4HQGRGOJeFWEjpoVwS-K9nMJliGjC8AzIhugkxTIMgkAOIXhxK9IhiHEuMo4h9mmDB7tAaVfwDi1GB0HFbN5gvYi3JwyXAIeDcwQ4cecktHnAR_Fo0rjyuSxIMYcG5YHGexBDGru-AaWG2zYFjwKSMZEUMwShGfXXDEx_-H6ny4lTgiMgCWDKCa-QnZh8xwMTQ8msT2xxZ7cMYxTdxiQE3JwpTrVtNJCwQTE-Toj8MmAJ3SXzMRKjcoV4lwCvv-WdmzE1b32W5YVInbSb1Y4VEOoUmfXuQmu8kdUf3rk4qYlJ6XS-YBjGezgz6Yd5WVWw2bCN9xkmHoNyD8OELjKes1ri8kz2mHqOT7pEiMukMDH0wvKjXbcjcUWLQ4rpbhKgIiodPHkxWO8vXUu2QWE9D5GgITFmIJX6b4-T5MY19za9Ijzd30n2qgIUHna7EvoVYE0sClggzbAkaI2G-bzdxuCG3FEZSL7BBiQtpJuPrtr7PfF13i7Wfxb7aDhGwEFmc8tXuNf04JN88GK70uE_OgNnkwwc1Y3v7531yvnuafEb7YkNLaq0yuPbCDDZWGV-nX0CRMW72OdpSa_fmv8InQ_E2lFKLXS4_zm5Jv2L2Gf0KxQztk8fLTuMWS-O2J3_QwVC-NC7JJoNqHytOyzgSnpii4wsZbxUv-VJGWKvZMF7uNt4qtjKaTbhDxstHIJvayKaPQubKjZF3MqNqwYOJToaNfdgkWSgabtuxbjtpayv7vWltO2lvK_t1205021aa1XjtbIHqcO8h-5rvGLWzBDaQfOLa9znXLnNGqy5bZDa68SZmdjRysjafuJxVncsYQty4EI_lrHKjmzkmf2qqZVrVyuogsVjgnz0scl-BFU0Kax7VTxL4KkhKqtIpYtfezP_-f3LlD0muyC0inlbpDYL-Y9Iqqu1kd9svllAxt4a8TsD_rUxKm5_CObjud2dFXN1VW4siZbEg97gZjP89PPBxPzYp8nedE-lI-zqwezqcOgdAjhctc5f7k1VyZkSbj89WYNGpBdJGA88skAEwc1ST3EKTN-oDzBhRq9i5LVUA6HOfZ9BAbKwZDcT-AgakBbE4X-ND-zeKv73EPMKpaWH-yK33uyotPB756vf1WDw0KVfF8wpCam849TeOsqW-OYESMAfWtoGfccekp2TPBOmYA9mNsQnfodt7RMBGJNuq3fGyhf4vGcHKgfJQhiw8fB2ZQV4ro3gwAu2NmFMC7N9-arafPqa94QSjIZJh2UCFVYBDhXkDFSu1YbpxMclWE3GUyMI-6aLpxtZdhcMkS-HoIAs1t4HqI-MyG8sjjJnF3VG1w3RZHBzd7IBucmlkVexr2irXpN3YVR_FsBrFsYWvES99qVCJn8vCY33iyCo_XfsLvcVDr3jm9ghCGfGXsotMHL69yNTRH8PnxlNhjQNU2IXanaS3_yzOUoL6neC5cyXTn-IUCv9tl_uj9q40DSLXZI6HU9TuLo-XRuZp1zbWPt6YirNtkj6ewNwkEDj6A_riYPpFpEFv5UHWneyyT7CAa813ozqINLefZBJqV5Npo0lZreHpkaxA51SP3jhJIUJ_fFbHFRuSp-XOrDcjnc8tlJ4rCjWX0QDwHJgxHltSXOOxj3yZ7MNoo8FAM854-FSZcfpbWD-fzsDhmOIK26ChMYX6-oMk52WWi-RFBv8UmtVe5s78zEUA7i906M1uvnqMWtOyCIs2OZb3alxxzSdSSmv5VMVoSTwTNXF4IyaMnbRc-_C9nXS-nXa-5Vc3bOsv4SxSrTaKv7wlHv894PKFaRNvCk2G7Cfke2hPaEK3VDiXAQHrUNJ_w5Sa2WwoUmMoHjdBUlFxQl8kV25BXCh2GLOvS7mgIW6IEPjVr0Ld_JJtqAzfuIr3QozZMG-2AVUHtQSuXwE-6J53VA7JmoZBBbFGwEhCAxjShDfFHvnxkSC5De6g46TAe2t4mkTR0BdEFHQbxCmS6iPDTPH1RBXSlFLQAET2Oy2yIXam6ODZySzloanqSXA0jFly1z-Rh65fZtu8oGVJo10XRfR1ueaNEeEi5DlewVBIjuQFD9NNUF3xvSZpR34O8stnYveJ8-vXjPFETF8pvHHJom6x5PIRatJHWcXyimlzMFfS4m3HzYfKTKkmMo9aU9kwG9a7E_MOjxzpSX2Dx2M9VkYOUj2jLVl5spC2J4ytC-QKjX4QsJjIU-3AO7TYRv6RzOZO-yvdEM1rzQ_8ZeNuRAG4Ej2xh-5VadcP9bu3_L6WEkf8sSB7YLdxGM1H5_tOBJa8KjerdRC-60ExBbrfs4kQ14FGZNLvk7MzcE2Ay4rhDZwOqxV1iNe-c4QFNDcBc2INwRqy2XyJF2lt1XH5bDZQt79MevRkT_XVOEeyMHJvI7UWFme9bEjOpcK15IR3-c3uMFTb5hAM8idL36JtMcwJiY3msz2aN4Ngo_l0j-bT9ubjPZo3Ez1PB6h-WndBeXftVPDrXnzb1Rq4G2I2-WINtBNc8GGbNwLLwVNbR8VqoBcBU-eHBrqhnnjnuLW4bZcGW1rmqEuwGsnrQIzCMgaSd3bOf5YQ54b8JuHmzFnNzhtmnK9p8t6isfOn7jI110K1jPVlZJtm9H1Ic9Ziq03sJYUFd6EuOp5gba9hPOq7jPFCwYX6UmP8pK7UtxtjV3V4R_8qr8dzLuAd99l0xc7vH3qDGK3X-P0LOvvTn16sX2BCkrcAw_a8r3-dn1sRGBaZGMDXztzM-eSguKHTwle4oLgOhyTcBAXMdnF9c7lsif3N7TR-vb8RQO8MQMG3XpVxj7floRt3r0cvfOuujMZ9V8E9qKSn_kIHjvvg8uPJRxNFVO3dy1uZDgfIQgyzHuf9_ejFkP_3IO9a6lqC_9m1hMN6aonAIEbzUN8lb8yDvLCitiXmAoBL5kDKYCkCOCFl1qckPEon2Kda4g3cElS-5wD2-n2-hxJEEQGlZndEuJu4S4JeGmcOOLjqtnBvS4NUhNmo707YICZFKiB0dSP7ecm3XvQSZ0Ktk2AjXKOxHLaeb9UQpn3elEPOm7AqMAbY-_MUWmMlgTZxNbuatkJgBh8XlVa3gOfDU3KIfy1MWE8ueb1FUlQV3NKuQghPzqxXW4hQ4pKCjYvK8545rFH9BY7-Cd_B6vVFD9tyWfcBYmXsQPL8RZP75xaVbd6uIIsWBe_knyqY6AgCOWA2LCkBj7hQSK8gZGvrHcsaoqx3TavFZdIVCpMsewzHxzVTF2Afd6RgsIkx3EmjQYMm_aDWGklHDaGsP166L26oxi105tU2zwoW4KES4A5Ny6qgYv-FFqXactwE6XWdWBCh2Bgf64WJL6YhFY4xn2xD8qzEr7dFH7ofi4yfrRyY3H390bajMX5UiHr4tpnnveGXHSSGRa1I9WJqvH9iAuiF1QDoisTgNViLi-xNqqLP-vsALlUyCjXBF0ZHJoEe0CcNWE2rB3Yfz1B5krosyMCDihw1Q8jm4FV6pw0BOhMuBne_oJbCyyZqjxPqk8VLdz6Oj5u5tiHxx272fo7U3ubsikhG6DRGhDv4bNuv7_HzR0_IjxkTdtqDH8GGhL7PYeEDP-zQMvHQYYeRw0Lfx6w3at5CeDiwfnLOp5xxNst1L20npzwzDs6ZU1uTPJq4r_c6YfVJotF10mtmnvRCw1m-i3OSYIpOpO9lwkzkBe0snYpanA5bTl4IEdqV_-w4C9S6J4jFUgAxnXtKuiqYQA_SLMXPk6icvs4A8LONcckttXK44tTIsiGbt0NSZiK5CEszpiDXtD7yFVxDNACM5cl596QXFn7mErOov1YpunI_8WTpwtx_bBY3LCuMtq_VsultyxNOiF9Fct6NbizNIxXaJWg_WeGXAizNTJC_SwVppkLbIdt7UwM9KoEpyd23Vn5NjTvuQI1Fj_8tjv8t6s3brnNregAg9E6_tuC_7RB5s1xn-MU3UE_8jhBg4X4Ofj4oIKKHOpMNI-pEiSPfQZUvL2KW7kxes8h02e58nkPVbt505fiaxfjwjxari2CdUP2hoa7W3TLGIWZ8T3RafzSoE3rKoY1PBnVCTzj0rP4IUSe086mktvLQzbIt3Yb5XZ3pHDY5Z03ikIdv2VUN77sqqrtufaP1TRng3xjlG5fmb9RC83eXQnbPnRlM1F_wijtIx-KaXlgdfhV539fNeMVXHHAnmgH3o5l52o3EyS-aWcWhxbJ-y8qgCpiYN3mEO218NRQrCznkm3iHGlMnCr5L4qxpHz7sFGHu2CUwFWF2XQT5BtfllVxNe3uZTIc1hJzImGLofcmDiN3KhcWzyta4fS857n63PdttYTzOgXuSaU96ReD5GIFtV1j_G2O5OvVj9rdDmeEx4qVIjtHoFaPgXd0G5StZIc9MvNbRqgy8e56BQlxotHysu6LPdKJRkklAcOzYLX6STzmFjeVXZzDV3QYQ45JvtWcpLdslDNN90CKiV7QQuMEIxAkJrhivoPAqqvSJfJ7dKHHXPSBJxu-qsHjrHiZVRVJ_wj8EJpzkE9ZhX4zvCYJBQia8Ms6hetLyPjBfpt4H97HGG4XlaODDiNtCjcjpwwfSAStYstvnsM6485CJz1WoxaTMcd-gB2FTfbphTYUfj7eToKK7F2Omvuv56B2dd02c4kumPrb0qXbHVrUiKGnPVM0dpGBpZPh85bHmxV-7R5BpHd5px9jIFNRBUudBol3gk8eBT11wg66IJpTpL4aWTn6wtM2ksdx_ygeBO853YTFONTY2jxo_Z97jXVg4oAAjgwXm3KzjXP8g998g7ngQ3wqXnwz_q_z7vw" rel="nofollow noreferrer" title="C++ (GCC) – Attempt This Online">Attempt This Online!</a></p>
<p>This matches the output of wastl's program up to 12 terms, and does so much faster (<s>62</s> <s>65</s> 2680 times faster on my machine).</p>
<p>Certain design elements were quite natural and are shared between both our programs – namely, the use of 128-bit integer coordinates, the coordinates of the starting tetrahedron, and multiplying all coordinates by 3 for each successive term. The remaining details are implemented from scratch though, without consulting wastl's program.</p>
<p>The fact that both versions of my program agree with wastl's up to <span class="math-container">\$A276272(12)\$</span> strongly suggests that they're all correct up to that point (and beyond it by using larger integers), and that the OEIS entry can finally be updated.</p>
<p>My previous version used affine transformations to rotate each polytet for comparison and deduplication. I wanted to keep that version up, rather than relegating it to the edit history, but the 65536 character limit prevented that.</p>
<p>This new version does its rotations entirely while remaining in tree representation, using Cartesian coordinates only to check for overlaps between tetrahedrons.</p>
<p>Compared to the previous affine transform version, it's about 40 times faster and uses 32 times less RAM (27 times less RAM than wastl's program).</p>
<p>It does deduplication by serializing the tree representation with every possible choice of singly-attached tetrahedron as its root node, doing 3 rotations of each, and choosing the serialization that is lexicographically least for hash-table comparison against polytets that were previously identified as unique using the same method.</p>
<p>As such, it's conceptually similar to the previous version – both take advantage of the fact that all polytets have some tetrahedrons that are attached on only one face, because due to a tetrahedron's dihedral angle being irrational, a polytet can never curve around and attach to one of its own faces.</p>
<p>So, the computationally expensive affine transformation is replaced with a tree re-rooting. This operation now being very fast, it can do a new optimization: Delaying the tetrahedron overlap/collision checking until after deduplication, so that a provisionally new polytet won't be checked for overlaps just to find that it's a duplicate.</p>
<p>The timings shown in the output are cumulative.</p>
<p>Output in <code>USE_GMP</code> (GNU Multiple Precision Arithmetic Library) mode:</p>
<pre><code>1: 1 [0 ms]
2: 1 [0 ms]
3: 1 [0 ms]
4: 4 [0 ms]
5: 10 [0 ms]
6: 39 [2 ms]
7: 164 [13 ms]
8: 767 [75 ms]
9: 3656 [400 ms]
10: 18186 [2347 ms]
11: 91532 [13428 ms]
12: 468203 [78222 ms]
13: 2417722 [459991 ms]
14: 12595984 [2762236 ms]
15: 66068726 [16173756 ms]
16: 348619611 [98104807 ms]
</code></pre>
<p>In this <code>USE_GMP</code> version, it is no longer possible for the calculations with Cartesian coordinates to overflow. As such, it could in theory keep going up to <span class="math-container">\$A276272(63)\$</span> given enough time and RAM, at which point it would no longer be able to serialize polytet trees at 1 byte per tetrahedron.</p>
<p>There's still plenty of room for further speed-ups, such as adding multithreading, and applying various more specific optimizations. Disk storage and merge-sorting could be used to do away with the RAM limit, allowing time to become the only limit.</p>
<p>Also, the STL implementation of hash tables is extremely inefficient in its RAM usage. I'm pretty sure that RAM usage could be dramatically decreased just by implementing my own hash table / unordered set, and plan to do just that to reach <span class="math-container">\$A276272(17)\$</span> in &lt;64 GB without using disk storage (which, in the current implementation, would require about 184 GB RAM; the calculation of <span class="math-container">\$A276272(16)\$</span> peaked at 34.9 GB RAM usage).</p>
<p>Output in basic 128-bit integer mode, which overflows starting at <span class="math-container">\$A276272(13)\$</span>:</p>
<pre><code>1: 1 [0 ms]
2: 1 [0 ms]
3: 1 [0 ms]
4: 4 [0 ms]
5: 10 [0 ms]
6: 39 [0 ms]
7: 164 [2 ms]
8: 767 [12 ms]
9: 3656 [77 ms]
10: 18186 [447 ms]
11: 91532 [2672 ms]
12: 468203 [16470 ms]
13: 2417697 [101231 ms]
14: 349124 [549295 ms]
</code></pre>
<h2>Output from the affine transform version</h2>
<p>This version used about 20% more RAM than wastl's program.</p>
<p>In <code>USE_GMP</code> mode:</p>
<pre><code>1: 1 [0 ms]
2: 1 [0 ms]
3: 1 [1 ms]
4: 4 [2 ms]
5: 10 [12 ms]
6: 39 [50 ms]
7: 164 [270 ms]
8: 767 [1556 ms]
9: 3656 [9505 ms]
10: 18186 [59459 ms]
11: 91532 [384340 ms]
12: 468203 [2399032 ms]
13: 2417722 [15053858 ms]
14: 12595984 [101318974 ms]
</code></pre>
<p>This version did not use GMP to solve for the affine transform, only to apply it after solving for it. Nor did it use GMP for storing the coordinates of vertices. As such, overflow would eventually happen. It still reaches <span class="math-container">\$A276272(14)\$</span> correctly though, at which point it used 42.3 GB RAM (getting close to my machine's 64 GB), so I can't run it beyond that point (nor would I want to, given how much faster the new tree version is).</p>
<p>In basic 128-bit integer mode, which overflows starting at <span class="math-container">\$A276272(13)\$</span>:</p>
<pre><code>1: 1 [0 ms]
2: 1 [0 ms]
3: 1 [0 ms]
4: 4 [0 ms]
5: 10 [2 ms]
6: 39 [10 ms]
7: 164 [53 ms]
8: 767 [296 ms]
9: 3656 [2350 ms]
10: 18186 [15845 ms]
11: 91532 [106165 ms]
12: 468203 [683449 ms]
13: 2417721 [4291118 ms]
14: 663520 [4734026 ms]
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.rust-lang.org/" rel="nofollow noreferrer">Rust</a>, 11 (hopefully correct) terms</h1>

<pre class="lang-rust prettyprint-override"><code>
use ::std::ops::{Add, Sub, Mul};
use ::std::rc::Rc;
use ::std::hash::{Hash, Hasher};
use ::std::collections::HashSet;
use ::std::iter;
use ::std::fmt::{self, Formatter, Display};
use ::std::time::Instant;

type Coord = i128;

#[derive(Copy, Clone, PartialEq, Eq, Debug)]
struct Vec3([Coord; 3]);

impl Vec3 {
    fn dot(self, other: Vec3) -&gt; Coord {
        self.0.iter().zip(other.0.iter()).map(|(a, b)| a * b).sum()
    }
}

impl Display for Vec3 {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        write!(f, "({}, {}, {})", self.0[0], self.0[1], self.0[2])
    }
}

impl Mul&lt;Vec3&gt; for Coord {
    type Output = Vec3;

    fn mul(self, mut vec: Vec3) -&gt; Vec3 {
        for i in &amp;mut vec.0 {
            *i *= self;
        }
        vec
    }
}

impl Add for Vec3 {
    type Output = Vec3;

    fn add(mut self, other: Vec3) -&gt; Vec3 {
        for (i, n) in self.0.iter_mut().enumerate() {
            *n += other.0[i];
        }
        self
    }
}

impl Sub for Vec3 {
    type Output = Vec3;

    fn sub(self, other: Vec3) -&gt; Vec3 {
        self + (-1 * other)
    }
}

#[derive(Clone, Debug)]
struct Tetrahedron([Vec3; 4]);

impl Default for Tetrahedron {
    fn default() -&gt; Tetrahedron {
        Tetrahedron([
            Vec3([-1, -1, -1]),
            Vec3([-1,  1,  1]),
            Vec3([ 1, -1,  1]),
            Vec3([ 1,  1, -1]),
        ])
    }
}

impl Display for Tetrahedron {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        write!(f, "Tetrahedron({}, {}, {}, {})", self.0[0], self.0[1], self.0[2], self.0[3])
    }
}

impl Tetrahedron {
    fn collides(&amp;self, other: &amp;Tetrahedron) -&gt; bool {
        let mut othervecs = [3 * self.0[1], 3 * self.0[2], 3 * self.0[3]];
        let sum = self.0[0] + self.0[1] + self.0[2] + self.0[3];
        let mut same = 0;

        for (i, &amp;vec) in self.0.iter().enumerate() {
            let sum = sum - vec;
            let vec = 3 * vec;
            let through = vec - sum;
            for (j, &amp;u) in other.0.iter().enumerate() {
                let u = 3 * u;
                if u == vec { same += 1 }
                let up = (sum - u).dot(through);
                for &amp;v in &amp;other.0[j+1..] {
                    let v = 3 * v;
                    let edge = v - u;
                    let ep = edge.dot(through);

                    if up.signum() != ep.signum() || up.abs() &gt;= ep.abs() {
                        continue
                    }

                    let intersection = ep * u + up * edge;
                    if othervecs.iter().enumerate().all(|(i, &amp;ov)| {
                        let mid = othervecs[(i+1)%3] + othervecs[(i+2)%3];
                        let ov = 2 * ov - mid;
                        (2 * intersection - ep * mid).dot(ep * ov) &gt; 0
                    }) {
                        return true
                    }
                }
            }

            if i != 3 { othervecs[i] = vec; }
        }
        if same == 4 { panic!("EQUAL TETRAHEDRA IN .collides()"); }
        false
    }

    // Mirroring also scales by 3
    fn mirror(&amp;self, i: usize) -&gt; Tetrahedron {
        let mut sum = Vec3([0; 3]);
        for (j, &amp;vec) in self.0.iter().enumerate() {
            if j != i { sum = sum + vec; }
        }

        let mut copy = self.clone();
        copy.scale();

        copy.0[i] = 2 * sum - copy.0[i];
        copy.swap(i, 3);
        copy.rotate_left(i);

        copy
    }

    fn scale(&amp;mut self) {
        for vec in self.0.iter_mut() {
            *vec = 3 * *vec;
        }
    }

    fn rotate_left(&amp;mut self, n: usize) {
        self.0[..3].rotate_left(n)
    }

    fn swap(&amp;mut self, a: usize, b: usize) {
        self.0.swap(a, b)
    }

    fn reverse(&amp;mut self) {
        self.0.reverse()
    }
}

type EndpointIter&lt;'a&gt; = Box&lt;dyn Iterator&lt;Item = Endpoint&gt; + 'a&gt;;

#[derive(Debug, Clone)]
struct Endpoint {
    tree: Rc&lt;TetraTree&gt;,
    hedron: Rc&lt;Tetrahedron&gt;,
}

impl Endpoint {
    fn iter_endpoints(&amp;self) -&gt; EndpointIter {
        let mut hedron = Rc::clone(&amp;self.hedron);
        //Rc::make_mut(&amp;mut hedron).swap(0, 3);
        Rc::make_mut(&amp;mut hedron).reverse();

        Box::new(self.clone().into_iter_directions()
            .chain(self.tree.iter_endpoints(
                Rc::new(TetraTree {
                    subtrees: [None, None, None],
                    hedron,
                })
            ))
        )
    }

    fn into_iter_directions(self) -&gt; EndpointIter&lt;'static&gt; {
        Box::new(iter::successors(Some(self), |this| {
            let mut this = this.clone();
            Rc::make_mut(&amp;mut this.tree).rotate_left(1);
            Rc::make_mut(&amp;mut this.hedron).0[1..].rotate_left(1);
            Some(this)
        }).take(3))
    }

    fn iter_extensions(&amp;self) -&gt; EndpointIter {
        let mut tree = self.tree.as_ref().clone();
        tree.scale();

        let mut hedron = self.hedron.as_ref().clone();
        //hedron.swap(0, 3);
        hedron.reverse();
        hedron.scale();

        Box::new(Endpoint {
            tree: Rc::new(tree),
            hedron: Rc::clone(&amp;self.hedron),
        }.into_iter_directions().filter_map(|endpoint| {
            let mut new = endpoint.hedron.mirror(3);
            new.swap(0, 3);
            if endpoint.tree.collides(&amp;new) {
                None
            } else {
                let mut hedron = endpoint.hedron;
                Rc::make_mut(&amp;mut hedron).scale();

                Some(Endpoint {
                    tree: Rc::new(TetraTree {
                        subtrees: [Some(endpoint.tree), None, None],
                        hedron,
                    }),
                    hedron: Rc::new(new),
                })
            }
        }).chain(self.tree.iter_extensions(Rc::new(TetraTree {
            subtrees: [None, None, None],
            hedron: Rc::new(hedron),
        }))))
    }

    fn iter_tetrahedra&lt;'a&gt;(&amp;'a self)
      -&gt; Box&lt;dyn Iterator&lt;Item = &amp;Tetrahedron&gt; + 'a&gt; {
        Box::new(
          iter::once(self.hedron.as_ref()).chain(self.tree.iter_tetrahedra())
        )
    }
}

impl Default for Endpoint {
    fn default() -&gt; Endpoint {
        Endpoint::from(Tetrahedron::default())
    }
}

impl From&lt;Tetrahedron&gt; for Endpoint {
    fn from(mut hedron: Tetrahedron) -&gt; Endpoint {
        let mirrored = hedron.mirror(0);
        hedron.scale();

        Endpoint {
            tree: Rc::new(TetraTree {
                subtrees: [None, None, None],
                hedron: Rc::new(mirrored),
            }),
            hedron: Rc::new(hedron),
        }
    }
}

impl Hash for Endpoint {
    fn hash&lt;H: Hasher&gt;(&amp;self, hasher: &amp;mut H) {
        let mut stuff: Vec&lt;_&gt; = self.tree.hash_helper(1).collect();
        stuff.push(self.tree.len());
        stuff.sort();
        stuff.hash(hasher);
    }
}

impl PartialEq for Endpoint {
    fn eq(&amp;self, other: &amp;Endpoint) -&gt; bool {
        self.iter_endpoints().any(|ep| ep.tree == other.tree)
    }
}

impl Eq for Endpoint {}

#[derive(Debug, Clone)]
struct TetraTree {
    subtrees: [Option&lt;Rc&lt;TetraTree&gt;&gt;; 3],
    hedron: Rc&lt;Tetrahedron&gt;,
}

impl TetraTree {
    fn iter_endpoints&lt;'x&gt;(&amp;'x self, behind: Rc&lt;TetraTree&gt;) -&gt; EndpointIter&lt;'x&gt; {
        let mut iterator = self.subtrees.iter().enumerate()
          .filter_map(|(i, opt)| opt.as_ref().map(|some| (i, some)));

        if let Some(first) = iterator.next() {
            let closure = move |(i, subtree): (usize, &amp;'x Rc&lt;TetraTree&gt;)| -&gt; EndpointIter&lt;'x&gt; {
                let mut behind = behind.as_ref().clone();
                behind.rotate_left(3-i);

                let mut this = self.clone();
                this.rotate_left(i);

                Rc::make_mut(&amp;mut this.hedron).reverse();

                this.subtrees.swap(1, 2);
                this.subtrees[0] = Some(Rc::new(behind));

                for (j, subtree) in this.subtrees.iter_mut().enumerate().skip(1)
                  .filter_map(|(j, s)| s.as_mut().map(|s| (j, s))) {
                    Rc::make_mut(subtree).rotate_left(j);
                }

                subtree.iter_endpoints(Rc::new(this))
            };
            Box::new(closure(first).chain(iterator.flat_map(closure)))
        } else {
            let mut hedron = self.hedron.as_ref().clone();
            //hedron.swap(0, 3);
            hedron.reverse();
            Endpoint {
                tree: Rc::clone(&amp;behind),
                hedron: Rc::new(hedron),
            }.into_iter_directions()
        }
    }

    fn rotate_left(&amp;mut self, i: usize) {
        self.subtrees.rotate_left(i);
        Rc::make_mut(&amp;mut self.hedron).rotate_left(i);
    }

    fn collides(&amp;self, hedron: &amp;Tetrahedron) -&gt; bool {
        self.hedron.collides(hedron) ||
          self.subtrees.iter()
            .filter_map(Option::as_ref)
            .any(|subtree| subtree.collides(hedron))
    }

    fn scale(&amp;mut self) {
        for subtree in self.subtrees.iter_mut().filter_map(Option::as_mut) {
            Rc::make_mut(subtree).scale();
        }
        Rc::make_mut(&amp;mut self.hedron).scale();
    }

    fn iter_extensions(&amp;self, behind: Rc&lt;TetraTree&gt;) -&gt; EndpointIter {
        Box::new(self.subtrees.iter().enumerate().flat_map(move |(i, next)| {
            let mut behind = behind.as_ref().clone();
            behind.rotate_left(3-i);

            let mut this = self.clone();
            this.rotate_left(i);

            let hedron = Rc::make_mut(&amp;mut this.hedron);
            hedron.reverse();

            this.subtrees.swap(1, 2);
            this.subtrees[0] = Some(Rc::new(behind));

            for (j, subtree) in this.subtrees.iter_mut().enumerate().skip(1)
              .filter_map(|(j, s)| s.as_mut().map(|s| (j, s))) {
                let subtree = Rc::make_mut(subtree);
                subtree.scale();
                subtree.rotate_left(j);
            }

            if let Some(next) = next {
                hedron.scale();
                next.iter_extensions(Rc::new(this))
            } else {
                let mut mirrored = hedron.mirror(3);
                mirrored.swap(0, 3);
                hedron.scale();

                if this.collides(&amp;mirrored) {
                    Box::new(iter::empty()) as EndpointIter
                } else {
                    Box::new(iter::once(Endpoint {
                        tree: Rc::new(this),
                        hedron: Rc::new(mirrored),
                    }))
                }
            }
        }))
    }

    fn iter_tetrahedra&lt;'a&gt;(&amp;'a self)
      -&gt; Box&lt;dyn Iterator&lt;Item = &amp;Tetrahedron&gt; + 'a&gt; {
        Box::new(iter::once(self.hedron.as_ref()).chain(
          self.subtrees.iter()
            .filter_map(Option::as_deref)
            .flat_map(TetraTree::iter_tetrahedra)
        ))
    }

    fn len(&amp;self) -&gt; usize {
        1usize + self.subtrees.iter()
              .filter_map(Option::as_deref).map(TetraTree::len).sum::&lt;usize&gt;()
    }

    fn hash_helper&lt;'a&gt;(&amp;'a self, behind: usize)
      -&gt; Box&lt;dyn Iterator&lt;Item = usize&gt; + 'a&gt; {
        let sub: Vec&lt;_&gt; = self.subtrees.iter().filter_map(Option::as_deref)
          .map(|a| (a, a.len())).collect();
        let sum = sub.iter()
          .map(|&amp;(_, len)| len).sum::&lt;usize&gt;() + behind + 1;
        Box::new(iter::once(behind).chain(
            sub.into_iter().flat_map(move |(sub, len)|
                        iter::once(len).chain(sub.hash_helper(sum - len)))
        ))
    }
}

impl PartialEq for TetraTree {
    fn eq(&amp;self, rhs: &amp;TetraTree) -&gt; bool {
        self.subtrees == rhs.subtrees
    }
}

impl Eq for TetraTree {}

fn main() {
    let verbose = std::env::args().skip(1).any(|arg| arg == "-v");
    let begin = Instant::now();

    println!("1: 1 [{}ms]", begin.elapsed().as_millis());
    if verbose {
        println!("{}\n--", Tetrahedron::default());
    }

    let mut polytets = HashSet::new();
    polytets.insert(Endpoint::default());

    for i in 2.. {
        println!("{}: {} [{}ms]", i, polytets.len(), begin.elapsed().as_millis());

        if verbose {
            for polytet in &amp;polytets {
                for hedron in polytet.iter_tetrahedra() {
                    println!("{}", hedron);
                }
                println!("--");
            }
        }

        polytets = polytets.iter()
          .flat_map(Endpoint::iter_extensions)
          .collect();
    }
}

</code></pre>
<p><a href="https://tio.run/##vVrrb9vIEf8s/xUbF3XIWKYt6z4UlCwgTXJIgN4rcfvFFQxKWlnMUSSPSzr2Wfrb05nZN0VFvmvRAFbIfcxrZ34zs1LViPrr16NGcBbHol7EcVGKOH56vVj02adm1mc/NNl25C6o5nH8ce4NrRKxgk3v4b8@w09e@XvmRZbxeZ0WORDHBZ947S1Ia155A8t1DRQFz5Z99n1RrZMaVvTZ21SUWfLoU6/TNY/jD7mokxzIHtWPJWdviqJasCuWDi7/BmN/uVnwKr3nwZuifOyzN1mR8z77OanqNMne/dZn@PeWz5q7cHok6qqZ1@xffD4MbojQiA2nIZBJ12VG4@zpqLfM2aKoAylkUYPWMc2F7Gyi@MOqHs5HFxGqGITR72kZ0FozFEbrpAw2QdJns3DDEvYK/o9Esw7Co972aKu4KtXZsqhcCcBQwYkUYRmzk3VTW3uRIGTJj1w0WU3ifKmA7YsA1h8HT9s@k3/hcZ9JQW8upuZxYB8vp5404BZjlGJC8hhlyfQ/NXUJYlyRmGA0FHPdZMpQKOE9nzum0tr0kFTK0lyqAYuiCxrvvUrZqyuSZASvW/iDSVcc8FfPMHvlSBaLAIl3H5onSZD2WR6iOM4J3sJmOEWeN2teJTUPQiVhzk6vmDrYm3Sq5cStrqAQU88TVDSz4ICQOM1OWXA2AJehVfqIrLdLP2859jWvq2TFF1WRBzfEk31n3fstXyboLCims1J7vJwNSJTWdM8jjGaRIXQ26DP5Nw37/jCjP2@YqdUdw8whMt0bHbtC/zdB4upk4@WZMWMeh764uyIiRKYLLrSc6tRPnJUk6awoMhIx4zXFEi2EcBDgPzdD8ARHDuf10n8dTslFkQggDbuyioBHGQr2@dJ5HpqtFEnJmsP@C/RbEzcnIFA7dLrCxuEPn2cY8yM9Ds8wjjK7o/WqKpq7Fczg/Bnuozni/Bk4N8TXh9hdxkSrUfQbotBLlzgiCT9JvSCmB2xrN5SwI5CiNmGE6K/kCSUJlOLkniBMY8Hn00EUTRVXqZhWa2TH@OIOrXiPhN1hZIhzLV5yBQpcRiK9yzFZsBew1HndbHA2mQl4ntCUfFaS9OZFXqd5w@Xr9shyTXOwmpAJG/mXaCM4/wYfUJqR4W@8r8PSUZJlkNfQHYp7yGyaMXlOisnZ7L4J0tNB@Nchepk3eImDI2djgda7RMBDWwEZPRngoCf5mZQc1sijojeQhE3YhVLaWqPidVPlDADSGMR8StuAtinaGMDXkTGdSlcckZvgH6yTMXHFvoOlZZKn8xfB8btf/vn6H@z63fXH1@/fvf34mn34kUUm6sPjUFJYJpngR8Ty/Jz9kFZVUaX5HYPhgol5knHBZo9sKLMqTWvISGPWiPR33gnNJlwp2iSkXqiyxomeZ8Yt6PgZbZFioJj4PXUN4fCcQ82lIWaOGSkgpjgckUqBdGkauJAmxdOUgWZG7Z4vUDCBWw0tmaqoQbzbjC/rILXUpCExnRKbE536Q5PlMdi7UrxK6xaEXikU2hqaLs8TW1Tk5hhs9XcTRcOpJ2QeWtlQHYdAoghAPdhBSmpPxaKVhN@j27f1Uxv0rM5AVHO8yxdlAeHyATQev0wmoOXfi4fx4jFnOJTURTWGBzxavXQCBwwr3WqaCgtVTtv6Qm@gAqfiPGYf52NyyGt4m0D2lo5px@U7zOgE6ZIABelcuBpTOZLc3FXD83Pl@lfAAvoPcjraFalcikd5fo6T6@RXTmd@YveF0soX2sf2rzPGJZ8DE8Zxzr8Erq9HIF9xSyos0kr1QXgavV40XyVpLlejpaKWooRByBxpGgtq0IIaETeJmN38SHWe/Zz25RIppnzZEssQP63rdMrWad7xS2iw6nQ@IfZGU9wLjVgzn3MhikoEn4o1lxT6bFOvUrGxuR4th0NwLvifiwYdNqYlqGHohc7gm@v1wUD9Anm3ayMJiGvREtswqoFIMAwdm9AhPNQ8F2SOZ7gbSqkhjg4yEbcVX8LhOyrShAt4O87qeGgnhfNzNem7pxp0fNGMuezMmbnR1TMhKufI3uQwNkg7IwjXbPf4drRMM4JS7Gy1O7f8AJhhcaEmtdYqpUm9erCmpSqmHrOHDGorZ1itEzrGAKVuxiGfOjWfZ@4W85EJtz2Y4NhSuZFvybYtdyLWDVna76kSdkWwF8Lgrl5gW1aouxvmW@nb3fhiXXuPpAeRpc3e9YkwbMdSrTE@wVQTnLxMZJY66jGMqn2Jx21@VPLxsQeeGZMAVORziTrt8NljAytSYBFx29ECtzKR1/96p69f4nhZFevAkT2OzS6Pzfewzst/XQyJmPXCmLU7Qk8IWVtjCHEssP2gutgHDN/Cg7YPH046bd/Q8kj/3IYHHci1Ed4WdpkF7xzH72N13TjRNfCKXlWP/z70S9@6WS7pImV8O/HAGnfdrnhWQrU7CCN1XSlxlHZFZSNWjgtlPIeztNOQ@LzlSDCQsuCoVcfcOHbpxH9rd/96gd/6kxytSgG6rfwRsLbcYKcn05G@kCJscaXYYb89WNN5buD4wE8lQv7YK/Am2Fc8p8rziO6UeeOXD4gVD6osnvFVmi9atWRHlfIw8U49VaCiD1zL3tHbEJx4qQu7jKKsoXmFT5uRaU4Afm/otgOfwlCGEqQn5EzgvkwrAUd3ZWSIcoBe9@4D0qpoKqwc1sU9Z8RPCRjGLFBtANrA13qzV22ruLQXkJYPnfVEr6cm3TJpeJbqHNeq2dodHGAFllwdzdfB8syvmxUhczaU8wd9dumy0bN4SXUlLazRQ2oRamK6ndWmxA7PZ9B9lxuJX1PgSwl0xxWQHhheoCHlTukGG8kKHEBneU91LYNnpc9KL3Xrota0Y9qUZFiryqxO20z@U@6jHE0lOuNsyyypSXa1jNKyVxH94fpzXwHaWYG20oqTV1Q1qU6tO2s4CWFvmfmcdjzd7aGNF7Qdt8tr3ZJ3d4Pi3b691crsv751LW1264WbDUFRF17RhO@aEoLjWB6YWUH5QO3e6FDY4RUeviJRW801SVcQdYsDcyooukPC1CCyXj1gfLv6W33acxOFX0keSg02mCxQI5iHrabmWaD7Tcw9BLl7ERc3erce@9F3T8geHcLhPwbD/wsU/tMgLL9ZmKm@vNP9Rh72Or5oBzsw21wGmzRPfgBM8H/FvV1j96iXfaj39l8OxHd1rHtLegW/Pb2gjctd1T5JL69fDGyZGl3nsNb9Dl@X9SOUvCwRXhTJLOaK3N5JjVm7TW7fOaD2fr@7r32g/tK9mlcD/49285md5p/Ebii/HfQ2eGMgTP5KwlGO2larOvYk9qaKch6JP5CPp98S6YBQUUsQYEW/UIjjMRGfBFYMp5fyrG9xWabjA4ch6TqnoAK63b@1MfugbSVgJAAYSZ8lqpNr9Xzu15Iz11Jy80lw20dzAxB1WAJkVlnglA1Ge/xHIaX1mB5x0lVOR8IR@GscYipx0f5zyJI46r4D6Ll9rfwyBReE1nG629J2W2b70moldFFzTZC@U9Lo88DuE1ab947202EDM/h1FspNCCS//61mhaBbVfyVD8/v4SirO2EThCxxYGzD4AM5Hp/dH@MJ4v4Zv0sxFaofBsERFF8kApYVGDrLXwTHg5gN2M3Tdi2mx325I@JZUgq@wI4ackwKCClkrw@oqWVCdS2Vp@2/87MzILDnzkdVLBrMyyJ7hCjG7K5@CyXdA9fpOXAFwas6sJdKLrkj@1OZyyjakSYGg1qtoFIxVMnbDykqu1hXVWKniNCX20aFJ9NvqdIDZtXk7j2bRn9X1mNdLJuOyF8BdtV5V@Vex3zWWk6ImsCxtmtlXbXQDXl0Tvk7OPsruLcIGvh7sipJa/Za0PtY4RF9iXYNbgenBxg1kr8uUkhjUw4GyCd4iGO5dqSDAOiAv@BWgAmiPPFYoEnV3cp1myForqaQz/gak7IkodlMniuPDVz/cgPwMYnkXoUUX/8D" rel="nofollow noreferrer" title="Rust – Try It Online">Try it online!</a> The footer contains some compatability implementations because TIO's Rust is a little old. (This has already been <a href="https://chat.stackexchange.com/transcript/message/54872387#54872387">reported</a> and added to the <a href="https://gist.github.com/cairdcoinheringaahing/46f79623ea7b5cfe67286d0a5e96d307" rel="nofollow noreferrer">list</a>.)</p>
<p>Output:</p>
<pre class="lang-rust prettyprint-override"><code>1: 1 [0ms]
2: 1 [0ms]
3: 1 [2ms]
4: 4 [8ms]
5: 10 [35ms]
6: 39 [139ms]
7: 164 [738ms]
8: 767 [4328ms]
9: 3656 [31298ms]
10: 18186 [287871ms]
11: 91532 [3154716ms]
</code></pre>
<p>As you can see, it also reports how long it took. (These are cumulated times.) You can use the <code>-v</code> option to list all tetrahedra for each polytet.</p>
<p>I don't really have a good way of verifying the results beyond A276272(5). I hope it works, but I'm not sure.</p>
<p>The idea is that we store the polytet as a tree of tetrahedra that also encodes orientation. But for collision detection we need actual tetrahedra. We start with the tetrahedron with vertices (-1, -1, -1), (-1, 1, 1), (1, -1, 1), (1, 1, -1) and scale all tetrahedra by 3 for every term. This avoids the need for fractions.</p>
<p>Can probably be made faster, but I don't know how.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/214203/">214203</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




