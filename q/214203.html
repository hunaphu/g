<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::214203</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>014</td><td>C++ GCC</td><td>251003T124500Z</td><td><a href="https://codegolf.stackexchange.com/questions/214203/gluing-tetrahedra-together/283991#283991">Deadcode</a></td></tr>
<tr d-ix="1"><td>011</td><td>Rust</td><td>201108T231337Z</td><td><a href="https://codegolf.stackexchange.com/questions/214203/gluing-tetrahedra-together/214928#214928">wastl</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C++ (GCC)</a>, <s>12</s> <s>13</s> 14+ terms</h1>
<pre class="lang-cpp prettyprint-override"><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;cstdint&gt;
#include &lt;cinttypes&gt;
#include &lt;array&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;functional&gt;
#include &lt;unordered_set&gt;
#include &lt;chrono&gt;

//#define USE_GMP

#ifdef USE_GMP
#include &lt;gmp.h&gt;
#   if GMP_NUMB_BITS != 64
#   error This is hard-coded for 64-bit limbs
#   endif
#endif

auto startTime = std::chrono::steady_clock::now();

typedef uint8_t TetIndex;
typedef uint8_t TetIndexFace; // lowest 2 bits are used for a face index
typedef __int128 Coord;
typedef std::array&lt;Coord, 3&gt; Coord3;
typedef std::array&lt;Coord3, 4&gt; Tetrahedron;
class Tet
{
    void initFaces()
    {
        faceAttached[0] = NULL; // t[0],t[1],t[2]
        faceAttached[1] = NULL; // t[0],t[1],t[3]
        faceAttached[2] = NULL; // t[0],t[2],t[3]
        faceAttached[3] = NULL; // t[1],t[2],t[3]
    }
public:
    Tetrahedron t;
    Tet *faceAttached[4];
    TetIndex index; // 1-based; 0=unassigned
    Tet(                    ) : t( ) {initFaces();}
    Tet(const Tetrahedron &amp;t) : t(t) {initFaces();}
    void assignIndex(TetIndex &amp;nextIndex)
    {
        if (index == 0)
            index = nextIndex++;
    }
};
class Polytet : public std::vector&lt;Tet&gt;
{
public:
    TetIndex nextIndex;
    void resetIndexing(size_t first) // This function should not be called if the polytet hasn't yet been populated
    {
       &#32;
        for (auto t=begin(); t!=end(); ++t)
            t-&gt;index = 0;
        (*this)[first].index = 1;
        nextIndex = 2;
    }
};

// vertex indices of faces with identical chirality
static int tetrahedronFaces[4][4] =
{
    {0, 1, 2, 3},
    {0, 3, 1, 2},
    {0, 2, 3, 1},
    {1, 3, 2, 0},
};

static int tetrahedronEdges[6][2] =
{
    {0, 1},
    {1, 2},
    {2, 0},
    {0, 3},
    {1, 3},
    {2, 3},
};

#ifndef USE_GMP
Coord3 operator+(const Coord3 &amp;a, const Coord3 &amp;b)
{
    Coord3 c;
    c[0] = a[0] + b[0];
    c[1] = a[1] + b[1];
    c[2] = a[2] + b[2];
    return c;
}
Coord3 operator-(const Coord3 &amp;a, const Coord3 &amp;b)
{
    Coord3 c;
    c[0] = a[0] - b[0];
    c[1] = a[1] - b[1];
    c[2] = a[2] - b[2];
    return c;
}
Coord3 operator*(const Coord3 &amp;a, const Coord b)
{
    Coord3 c;
    c[0] = a[0] * b;
    c[1] = a[1] * b;
    c[2] = a[2] * b;
    return c;
}
Coord dot(const Coord3 &amp;a, const Coord3 &amp;b)
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}
#endif

#ifdef USE_GMP
void mpz_set_int128(mpz_t &amp;dst, const __int128 &amp;src)
{
    __int128 abssrc = src &lt; 0 ? -src : src;
    mpz_import(dst, 2, -1, 8, 0, 0, &amp;abssrc);
    if (src &lt; 0)
        mpz_neg(dst, dst);
}
#endif

class TetrahedronOverlap
{
#ifdef USE_GMP
    mpz_t intersectNumerator, intersectDenominator, uNumerator, vNumerator, uvDenominator, uvNumeratorSum;
    mpz_t center[3], normal[3], tmp[3], p0p1[3], intersectionPoint[3], delta[3], edge1[3], edge2[3];
    mpz_t a[4][3];
    mpz_t b[4][3];
    mpz_t triangle[3][3];
    void setTetrahedron(mpz_t dst[4][3], const Tetrahedron &amp;src)
    {
        for (int p=0; p&lt;4; p++)
            for (int d=0; d&lt;3; d++)
                mpz_set_int128(dst[p][d], src[p][d]);
    }
    void dot(mpz_t &amp;result, const mpz_t a[3], const mpz_t b[3])
    {
        mpz_mul   (result, a[0], b[0]);
        mpz_addmul(result, a[1], b[1]);
        mpz_addmul(result, a[2], b[2]);
    }
public:
    TetrahedronOverlap()
    {
        mpz_inits(intersectNumerator, intersectDenominator, uNumerator, vNumerator, uvDenominator, uvNumeratorSum, NULL);
        for (int d=0; d&lt;3; d++)
        {
            mpz_init(center[d]);
            mpz_init(normal[d]);
            mpz_init(tmp[d]);
            mpz_init(p0p1[d]);
            mpz_init(intersectionPoint[d]);
            mpz_init(delta[d]);
            mpz_init(edge1[d]);
            mpz_init(edge2[d]);
        }
        for (int p=0; p&lt;4; p++)
        {
            for (int d=0; d&lt;3; d++)
            {
                mpz_init(a[p][d]);
                mpz_init(b[p][d]);
            }
        }
        for (int p=0; p&lt;3; p++)
            for (int d=0; d&lt;3; d++)
                mpz_init(triangle[p][d]);
    }
    ~TetrahedronOverlap()
    {
        mpz_clears(intersectNumerator, intersectDenominator, uNumerator, vNumerator, uvDenominator, uvNumeratorSum, NULL);
        for (int d=0; d&lt;3; d++)
        {
            mpz_clear(center[d]);
            mpz_clear(normal[d]);
            mpz_clear(tmp[d]);
            mpz_clear(p0p1[d]);
            mpz_clear(intersectionPoint[d]);
            mpz_clear(delta[d]);
            mpz_clear(edge1[d]);
            mpz_clear(edge2[d]);
        }
        for (int p=0; p&lt;4; p++)
        {
            for (int d=0; d&lt;3; d++)
            {
                mpz_clear(a[p][d]);
                mpz_clear(b[p][d]);
            }
        }
        for (int p=0; p&lt;3; p++)
            for (int d=0; d&lt;3; d++)
                mpz_clear(triangle[p][d]);
    }
    void setA(const Tetrahedron &amp;x) {setTetrahedron(a, x);}
    void setB(const Tetrahedron &amp;x) {setTetrahedron(b, x);}
    bool operator()()
    {
        // Take advantage of the fact that the two tetrahedrons are regular and congruent, and
        // just check if any edge of tetrahedron "a" intersects with any face of tetrahedron "b".
        // Don't count it if only the endpoint of an edge intersects.
        for (int edgeNum=0; edgeNum&lt;6; edgeNum++)
        {
            const mpz_t *p0 = a[tetrahedronEdges[edgeNum][0]];
            const mpz_t *p1 = a[tetrahedronEdges[edgeNum][1]];
            for (int faceNum=0; faceNum&lt;4; faceNum++)
            {
                mpz_t *normalizedTetrahedron[4][3]; // first 3 points are the face, and the 4th point is for calculating the normal
                for (int i=0; i&lt;4; i++)
                    for (int d=0; d&lt;3; d++)
                        normalizedTetrahedron[i][d] = &amp;b[tetrahedronFaces[faceNum][i]][d];
                // Center coordinates will be multiplied by 3 compared to original coordinates.
                // Get center of face by averaging its vertices' coordinates; the
                // division by 3 is implied by omitting the multiplication by 3.
                for (int d=0; d&lt;3; d++)
                    mpz_set(center[d], *(normalizedTetrahedron[0][d]));
                for (int p=1; p&lt;3; p++)
                    for (int d=0; d&lt;3; d++)
                        mpz_add(center[d], center[d], *(normalizedTetrahedron[p][d]));
                for (int d=0; d&lt;3; d++)
                {
                    mpz_neg(normal[d], center[d]);
                    mpz_addmul_ui(normal[d], *(normalizedTetrahedron[3][d]), 3);
                }
                for (int d=0; d&lt;3; d++)
                {
                    mpz_sub(tmp [d], *(normalizedTetrahedron[0][d]), p0[d]);
                    mpz_sub(p0p1[d],                         p1[d],  p0[d]);
                }
                dot(intersectNumerator  , normal, tmp);
                dot(intersectDenominator, normal, p0p1);
                int cmp = mpz_cmp_ui(intersectDenominator, 0);
                if (cmp == 0)
                    continue; // edge is parallel to face, which we don't count as an overlap
                if (cmp &lt; 0)
                {
                    mpz_neg(intersectNumerator  , intersectNumerator  );
                    mpz_neg(intersectDenominator, intersectDenominator);
                }
                if (mpz_cmp_ui(intersectNumerator, 0) &lt;= 0 || mpz_cmp(intersectNumerator, intersectDenominator) &gt;= 0)
                    continue;
                // These coordinates are all multiplied by intersectDenominator
                for (int d=0; d&lt;3; d++)
                {
                    mpz_mul(intersectionPoint[d], p0[d], intersectDenominator);
                    mpz_addmul(intersectionPoint[d], p0p1[d], intersectNumerator);
                }
                for (int i=0; i&lt;3; i++)
                    for (int d=0; d&lt;3; d++)
                        mpz_mul(triangle[i][d], *(normalizedTetrahedron[i][d]), intersectDenominator);
                // Check if the intersection point is inside the triangle
                for (int d=0; d&lt;3; d++)
                {
                    mpz_sub(delta[d], intersectionPoint[d], triangle[0][d]);
                    mpz_sub(edge1[d], triangle[1][d]      , triangle[0][d]);
                    mpz_sub(edge2[d], triangle[2][d]      , triangle[0][d]);
                }
                mpz_mul   (uNumerator, delta[1], edge2[0]);
                mpz_submul(uNumerator, delta[0], edge2[1]);
                mpz_mul   (vNumerator, delta[0], edge1[1]);
                mpz_submul(vNumerator, delta[1], edge1[0]);
                mpz_mul   (uvDenominator, edge1[1], edge2[0]);
                mpz_submul(uvDenominator, edge1[0], edge2[1]);
                cmp = mpz_cmp_ui(uvDenominator, 0);
                if (cmp == 0)
                    continue;
                if (cmp &lt; 0)
                {
                    mpz_neg(uNumerator, uNumerator);
                    mpz_neg(vNumerator, vNumerator);
                    mpz_neg(uvDenominator, uvDenominator);
                }
                if (mpz_cmp_ui(uNumerator, 0) &lt;= 0 || mpz_cmp_ui(vNumerator, 0) &lt;= 0)
                    continue;
                mpz_add(uvNumeratorSum, uNumerator, vNumerator);
                if (mpz_cmp(uvNumeratorSum, uvDenominator) &lt; 0)
                    return true;
            }
        }
        return false;
    }
#else
    const Tetrahedron *a, *b;
public:
    void setA(const Tetrahedron &amp;x) {a = &amp;x;}
    void setB(const Tetrahedron &amp;x) {b = &amp;x;}
    bool operator()()
    {
        // Take advantage of the fact that the two tetrahedrons are regular and congruent, and
        // just check if any edge of tetrahedron "a" intersects with any face of tetrahedron "b".
        // Don't count it if only the endpoint of an edge intersects.
        for (int edgeNum=0; edgeNum&lt;6; edgeNum++)
        {
            Coord3 p0 = (*a)[tetrahedronEdges[edgeNum][0]];
            Coord3 p1 = (*a)[tetrahedronEdges[edgeNum][1]];
            for (int faceNum=0; faceNum&lt;4; faceNum++)
            {
                Tetrahedron normalizedTetrahedron; // first 3 points are the face, and the 4th point is for calculating the normal
                for (int i=0; i&lt;4; i++)
                    normalizedTetrahedron[i] = (*b)[tetrahedronFaces[faceNum][i]];
                Coord3 center = {{0, 0, 0}}; // multiplied by 3 compared to original coordinates
                // Get center of face by averaging its vertices' coordinates; the
                // division by 3 is implied by omitting the multiplication by 3.
                for (int p=0; p&lt;3; p++)
                    for (int d=0; d&lt;3; d++)
                        center[d] += normalizedTetrahedron[p][d];
                Coord3 normal;
                for (int d=0; d&lt;3; d++)
                    normal[d] = normalizedTetrahedron[3][d] * 3 - center[d];
                Coord intersectNumerator   = dot(normal, normalizedTetrahedron[0] - p0);
                Coord intersectDenominator = dot(normal,                       p1 - p0);
                if (intersectDenominator == 0)
                    continue; // edge is parallel to face, which we don't count as an overlap
                if (intersectDenominator &lt; 0)
                {
                    intersectNumerator   = -intersectNumerator;
                    intersectDenominator = -intersectDenominator;
                }
                if (intersectNumerator &lt;= 0 || intersectNumerator &gt;= intersectDenominator)
                    continue;
                // These coordinates are all multiplied by intersectDenominator
                Coord3 intersectionPoint = p0 * intersectDenominator + (p1 - p0) * intersectNumerator;
                Coord3 triangle[3];
                for (int i=0; i&lt;3; i++)
                    triangle[i] = normalizedTetrahedron[i] * intersectDenominator;
                // Check if the intersection point is inside the triangle
                Coord3 delta = intersectionPoint - triangle[0];
                Coord3 edge1 = triangle[1]       - triangle[0];
                Coord3 edge2 = triangle[2]       - triangle[0];
                Coord uNumerator = delta[1]*edge2[0] - delta[0]*edge2[1];
                Coord vNumerator = delta[0]*edge1[1] - delta[1]*edge1[0];
                Coord uvDenominator = edge1[1]*edge2[0] - edge1[0]*edge2[1];
                if (uvDenominator == 0)
                    continue;
                if (uvDenominator &lt; 0)
                {
                    uNumerator = -uNumerator;
                    vNumerator = -vNumerator;
                    uvDenominator = -uvDenominator;
                }
                if (uNumerator &lt;= 0 || vNumerator &lt;= 0)
                    continue;
                if (uNumerator + vNumerator &lt; uvDenominator)
                    return true;
            }
        }
        return false;
    }
#endif
};

void attachNewTet(Tet &amp;t, Tet &amp;tetToAttachTo, const int faceNum)
{
    Coord3 &amp;newVertex = t.t[0];
    newVertex = {{0, 0, 0}};
    // Get center of face by averaging its vertices' coordinates.
    for (int p=0; p&lt;4; p++)
    {
        if (p == 3 - faceNum)
            continue;
        for (int d=0; d&lt;3; d++)
            newVertex[d] += tetToAttachTo.t[p][d];
    }
    // Finalize the new vertex
    for (int d=0; d&lt;3; d++)
        newVertex[d] = newVertex[d]/3 * 2 - tetToAttachTo.t[3 - faceNum][d];
    // Copy the other vertices
    for (int p=0; p&lt;3; p++)
    {
        int p1 = tetrahedronFaces[faceNum][p];
        for (int d=0; d&lt;3; d++)
            t.t[1+p][d] = tetToAttachTo.t[p1][d];
    }
    t.faceAttached[0] = NULL;
    t.faceAttached[1] = NULL;
    t.faceAttached[2] = NULL;
    t.faceAttached[3] = &amp;tetToAttachTo;
    tetToAttachTo.faceAttached[faceNum] = &amp;t;
}

// First two tetrahedrons are implied. Each element is a subsequent tetrahedron, with the value indicating where
// it's attached. The lower 2 bits indicate which face (can only have 3 different values, because at least 1 face
// will always already be attached). The remaining bits indicate which tetrahedron (which can never be zero,
// because that one is attached implicitly).
class CompressedPolytet : public std::vector&lt;TetIndexFace&gt;
{
public:
    void append(Polytet &amp;polytet, Tet &amp;tetToCompress, int vertexMap[4], int faceRotation)
    // indices of vertexMap[] are compressed-output vertices; elements of vertexMap[] are the original vertices of tetToCompress
    {
        tetToCompress.assignIndex(polytet.nextIndex);
        for (int _faceNum=0; _faceNum&lt;3; _faceNum++)
        {
            int rotatedFaceNum = (_faceNum + faceRotation) % 3;
            int faceNum = 3 - vertexMap[3 - rotatedFaceNum];
            if (!tetToCompress.faceAttached[faceNum])
                continue;
            Tet *attachedTet = tetToCompress.faceAttached[faceNum];
            attachedTet-&gt;assignIndex(polytet.nextIndex);
            push_back((((TetIndexFace)(tetToCompress.index - 1)) &lt;&lt; 2) + _faceNum);
           &#32;
            int attachedFace = 0;
            while (attachedTet-&gt;faceAttached[attachedFace] != &amp;tetToCompress)
                attachedFace++;
            int vertexMap2[4];
            int rotation = 0;
            while (vertexMap[tetrahedronFaces[rotatedFaceNum][rotation]] != tetrahedronFaces[faceNum][0])
                rotation++;
            vertexMap2[1] = tetrahedronFaces[attachedFace][0];
            vertexMap2[3] = tetrahedronFaces[attachedFace][1];
            vertexMap2[2] = tetrahedronFaces[attachedFace][2];
            vertexMap2[0] = tetrahedronFaces[attachedFace][3];
            /*if (faceNum == 3)
            {
                int tmp = vertexMap2[3];
                vertexMap2[3] = vertexMap2[2];
                vertexMap2[2] = tmp;
            }*/
            append(polytet, *attachedTet, vertexMap2, rotation);
        }
    }
};

namespace std
{
    template&lt;&gt;
    struct hash&lt;CompressedPolytet&gt;
    {
        std::size_t operator()(const CompressedPolytet &amp;polytet) const noexcept
        {
            std::size_t seed = polytet.size();
            for (auto i=polytet.cbegin(); i!=polytet.cend(); ++i)
                seed ^= std::hash&lt;uint32_t&gt;{}(*i) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2);
            return seed;
        }
    };
};

int main(int argc, char *argv[])
{
    static Tetrahedron start =
    {{
        {{-9,-9,-9}},
        {{-9, 9, 9}},
        {{ 9,-9, 9}},
        {{ 9, 9,-9}}
    }};

    TetrahedronOverlap overlap;

    auto *polytets = new std::unordered_set&lt;CompressedPolytet&gt;;
    polytets-&gt;insert(CompressedPolytet()); // add empty vector as the starter polytet (meaning it has two tetrahedrons)
    size_t prevPolytetCount = 0;
   &#32;
    size_t blahNum = 0;

    for (int tetCount=1;;)
    {
        auto currentTime = std::chrono::steady_clock::now();
        size_t polytetCount = polytets-&gt;size();
        std::cout &lt;&lt; tetCount &lt;&lt; ": " &lt;&lt; polytetCount &lt;&lt; " [" &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(currentTime - startTime).count() &lt;&lt; " ms]" &lt;&lt; std::endl;
        if (prevPolytetCount &gt; polytetCount)
        {
            std::cerr &lt;&lt; "Quit due to apparent overflow" &lt;&lt; std::endl;
            break;
        }
        prevPolytetCount = polytetCount;
        if (++tetCount &lt;= 2)
            continue;
        /*if (tetCount &gt; 6)
            break;*/

        Polytet polytet;
        polytet.reserve(tetCount); // Important, to ensure pointers don't change
        Tet &amp;t0    = polytet.emplace_back(start);
        attachNewTet(polytet.emplace_back(), t0, 3);

        auto *newPolytets = new std::unordered_set&lt;CompressedPolytet&gt;;
        polytet.resize(tetCount);
        for (auto basePolytet=polytets-&gt;cbegin(); basePolytet!=polytets-&gt;cend(); ++basePolytet)
        {
            int tetNumToUncompress = 2;
            for (auto elementToUncompress=basePolytet-&gt;cbegin(); elementToUncompress!=basePolytet-&gt;cend(); ++elementToUncompress)
            {
                int faceNum          = *elementToUncompress &amp; 3;
                int tetNumToAttachTo = *elementToUncompress &gt;&gt; 2;
                Tet &amp;tetToAttachTo = polytet[tetNumToAttachTo];
                attachNewTet(polytet[tetNumToUncompress++], tetToAttachTo, faceNum);
            }
            if (tetNumToUncompress != tetCount - 1)
            {
                std::cerr &lt;&lt; "Error! Got " &lt;&lt; tetNumToUncompress &lt;&lt; ", expected " &lt;&lt; tetCount - 1 &lt;&lt; std::endl;
                exit(-1);
            }

            Tet &amp;newTet = polytet[tetCount - 1];
            for (int tetNumToAttachTo = 0; tetNumToAttachTo &lt; tetCount-1; tetNumToAttachTo++)
            {
                Tet &amp;tetToAttachTo = polytet[tetNumToAttachTo];
                for (int faceNum=0; faceNum&lt;3; faceNum++) // skip last face because it's always already attached
                {
                    if (tetToAttachTo.faceAttached[faceNum])
                        continue;
                    attachNewTet(newTet, tetToAttachTo, faceNum);
                    // Canonicalize the rotation of this new polytet in compressed form, so that it can be compared against others
                    bool haveRunningLeast = false;
                    CompressedPolytet runningLeastPolytet;

                    Tet *t = &amp;polytet[1];
                    for (int i=0; i&lt;tetCount; i++)
                    {
                        int attachedFace;
                        int vertexMap[4];
                        {
                            Tet &amp;singlyAttachedTet = polytet[i];
                            for (int j=0; j&lt;3; j++)
                                if (singlyAttachedTet.faceAttached[j])
                                    goto skipThisTet; // not a singly attached tet
                            t = singlyAttachedTet.faceAttached[3];
                            attachedFace = 0;
                            while (t-&gt;faceAttached[attachedFace] != &amp;singlyAttachedTet)
                                attachedFace++;
                            static int vertexMapTable[4][4] =
                            {
                                {3, 0, 2, 1},
                                {2, 0, 1, 3},
                                {1, 0, 3, 2},
                                {0, 1, 2, 3},
                            };
                            memcpy(vertexMap, vertexMapTable[attachedFace], sizeof(vertexMap));
                        }
                        for (int rotationStep=0; rotationStep&lt;3; rotationStep++)
                        {
                            polytet.resetIndexing(i);
                            CompressedPolytet newRotatedPolytet;
                            newRotatedPolytet.reserve(tetCount - 2);
                            newRotatedPolytet.append(polytet, *t, vertexMap, rotationStep);

                            // Update the running "least" rotation
                            if (!haveRunningLeast ||
                                std::lexicographical_compare(
                                    newRotatedPolytet  .begin(), newRotatedPolytet  .end(),
                                    runningLeastPolytet.begin(), runningLeastPolytet.end()))
                            {
                                haveRunningLeast = true;
                                runningLeastPolytet = newRotatedPolytet;
                            }
                        }
                    skipThisTet:;
                    }
                    if (auto [insertedItem, wasInserted] = newPolytets-&gt;emplace(runningLeastPolytet); wasInserted)
                    {
                        // Check for overlap between this newly attached tetrahedron and the existing ones,
                        // and defer this until after the deduplication, to save a lot of time
                        overlap.setA(newTet.t);
                        for (auto tetCheckIntersection=polytet.cbegin(); tetCheckIntersection!=polytet.cend(); ++tetCheckIntersection)
                        {
                            if (&amp;*tetCheckIntersection == &amp;tetToAttachTo || &amp;*tetCheckIntersection == &amp;newTet)
                                continue; // skip this check for speed (it'll always be false anyway)
                            overlap.setB(tetCheckIntersection-&gt;t);
                            if (overlap())
                            {
                                newPolytets-&gt;erase(insertedItem);
                                break;
                            }
                        }
                    }
                    tetToAttachTo.faceAttached[faceNum] = NULL;
                }
            }

            polytet[1].faceAttached[0] = NULL;
            polytet[1].faceAttached[1] = NULL;
            polytet[1].faceAttached[2] = NULL;
        }

        delete polytets;
        polytets = newPolytets;

        for (int p=0; p&lt;4; p++)
            for (int d=0; d&lt;3; d++)
                start[p][d] *= 3;
    }
&#9;return 0;
}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=7Txdb-RGcs_Rr-iVEXlmNKOdj8WerdHoYPtsYwHbt7G1AQJhIvSQrRnuckiGbOrDWuWP3MsBhzzmLb8mvyZV_cVusskZ7XrjHBDCXnGaVdXV1VXVVcVu_uU_gywuC_z_ah0E_3V5OCp4uAiOj6fjw-Hh6M_Tw-Vf_6Pk16Mv_vtf_vZZlARxGTJyBkBRerI5P6iaorTgOaNbuw1aomTtwgWIm3CnCX7z-4wVdiPNc3rvNMTrNI_4xunhhgU8ze2WOCoc4tdlEvAoTWhst5ZJmocsZ-FVwVxeNnmapOcHB8-ffxay6yhh5M0v3159_-PrA4C6hibzu0JabzMxSEJIdE3g2dVPb378-urrVxe_kGcL8vKFeMTyPM3JxSYqCPy3oXk4CtKQheQaml--GK0iTuJouyokdBJG1wefyT8HtOQpKTjN-UW0ZWQB9-HpqWT29LTgjIb3V0GcBu9OT5P0ttefHxygSJHfEsT7xRUnF4y_SkJ2N2998h0N2Jw8f07i9JYVnEwJ8FQQmjNSFopRSq4BikQIbwhdXQGlyfQL8k0Kcq06EFyKmTwTT4Zkdi5hZu1AsyF5cY485XTDQhjh_CCIaVFg08HDAciG3KRRCCxEHDkuen3RKB_hhRx-xTkNAP9yvARx_fTmhx_EyDj8HvLLCf4zXfoxJq0YsxaMqQ9j2oUxq2FM6hiPB1m5iqPgVPyypEH4XDeRgUPzxdI8EdMpJ0l0MBmtKMzgnIwXZQKyjNYJCzVwj3iuPjkl8KRPHiw5zx8NTpAmBXf4OuISh3txxJTJngVzPcPlUcLu5G19HsGYemIMZLEg4_6BzZ9qJwb5-HiuBPeoFeZ1Gt9zENMpkbKUqiZ9xtkFGv5DXcqSJUN0XvGes0I9Bp_WK6JfGVjOdZQXMF6QsLBr7WxIsUnLOCRJysmKkYDGMZgPDIdvGMkUVxtaJJ9zcs8QhiXQnpUx5WpeKilUCgTm1xOegC9WbB0lIFzCny3AR-Dd8TF3RcRH51pK47l50htwYLV_KVhfnmiISQVhRg_NU0uo4BPJDcu51KwIZpek10KtC3ILnplEIUt4BKMlwSbKaRzx-wNwWtAECJzwSlmEboDCwn9koYz6YTwkkyGZgpN4HJqWmWy0WqayUbdMxE9oHEMLcunv8dtwDT2-XApbtXu06JheFDXDg92XBTNTPcLCkNgrg3RjJM1YTkHVjpWxqOYjOiRuw6qvGFINgRR6IH0XxT_HZAV_dPtEtk9k-8S0T2X7VLZPVXvOeJknSPWxztroN2Bt1MLaqIW10X6sDTpZI3swNiCrJldWY8WSaWzwQ8KU7y0jhY2dD1Zy1rDPwUrOFHY1kGN_NCt7LagQrmab_YpxiVpUe_iTk6Ow4Lpns94eFXmgezeNdFVAMwYJ8O8ZGZM_khHenmKDHCeSjLZZmvOeIAvKPALl_gL0Xvx3JGn0JTT6YUWr8jBIImFriQ__9O1RmQVbm9-fwXHENANWawPWpDgaLMsLcM4_lVupAsOq7U8sSbdRIltLC-LGui9vXLDq2S_ldm51FTCkC0vtEFx0vqWxuOXbTPzNxtlE3JjewaW_TuGXaA1ZzKm4Y-BTJuZuCnd2JxT9m9u0ajZBiEyTdcyg2TwRSgAKYMlPKQHIWZLQmuAswEIZ3MVDrBnoCrPFeE6ysxfwz_Gxu04YmBBhwrMZ_FOH0Qxbaom8ZMvLEHiBjuVtXy8XZhhoP0qBYQUtY6PDWkjVWLSMZsv6KPDJtozhrqeJoJENhefpzx04GoYAasFNBNxkJ9xUwE2rMbQEYEqVG1GnsCmIe4reJ9bkoQgcreHsmsAHZyo1nz1lBaEtGQdA2UY7AFpM-1NhR-2Pm9bVDittrv25tMTu51P3-ePeNvLwZGt58NqO4IQ6huIFWXlBHvfgfPaR1i0nVXukpkX_-55mEMSM5n8PdiAY7TQECdFlCRKi1RTk43ZbkM_3NAYJ3GENEqDDHCqA390eJCvdBiFhfj-LUJPbbhJ6rf7KlxHfQSpcW8cherxzcmJ4_vWeuCsLd5WmsYmVe_2GGWJKSt8xQsMbmnC6ZpirYfoJ-RpEHRvKxS9-m9pZkiz25GwNmWhOaBLi0rzOSzCQIf60yb8tgeVgw4J3GCDS5F5EQaIbaxyH9LCyeZUnIqyoItVhV4cndg9_SjFBDtIS5iri2EuaxPeCb4gzMzQTJEET2XPVzUlTHxACnAfOuLo9e2lu27XbjkwG2VgkDI2sUlFZQjCynHegT3agT-rohnuUluJe3aJVqtv9rA0YkF4s-pWFllapkBTlLUoCZEaEZKUqKI1hYvbFrxcwgVL0WPAABiHfD7BwESVrASB7afBgxhLhKCLkP_JZnQO7w0L15R9YhMYKIj9aXTZKD0p0SwBCqKbzAXF8I5YFmENI83AFEmWOOMaKDkSOPMriiEEieg8SC9JtBuICCaUkzaM1gMc24omP_vdMZyK6joLEKKyrdI3CxNor1luw0vK5TW2OcvZRDKObqMD6k2AKC81bwySsotzMkeY_oFyDN1l8yiyo3KBaSodk0PNPy1j4UI-_t3z3pM13f6iGqIjf5m8PVrOdrO7ovmmKmhlMnU1UYTHj6cziH-btqoxsxDbWZ4L1IZl5CD5-gvEU5QpjILLH1GOG3T1SJKYipqEPRlz6cRux5igxF23GpIToKoAoAXgoOXhOQKrxkFkPIko0AKEsZCyxzXDy_JTGPvRr0hPojeq3vmB9AZsu5VsbuQgWBDwRFpxjdEbSd99uomBDbhmMpFpRaYErZ6oKM219n_m67lZrv4h9rR0q4BByJOVr3Wv6cUi-ebDyjXGfnIGwyfv3esb2TmL65Hz3NPmc9sWGFcxZZXDhhRmsrTK-Tj-BIWNRxJeNKKvdW_6anqqztJFUVtyU8tP8lgoqZr9hUKGFYYL_aNnp3CLl3PaUDwYYOnjGJdkWUBVgRUkRhTIM03x8Iuetk0pf2RNbjRjGLemaTUwnoBbaRERj4voAYlOX2PRJxJp6YxUU7dKDlMHEFHTHbWkpsIWq0cQdG9xJG67q96YVd9KOq_pt4k4MbivPerxuSUV3uPeQfeg7Rt1YAmtEPnLt-y3XLntGyy5fZCPdeKtXO5Aapa2PXM7KzmUMIW6aEE-VrA6j64U4f_2uZVr1ytog4ojAP3t4qddsPK9z6CsIKeBrGhdM120-Y_DjQI20VncZUPDwq7lT_N9Z46GYZd7tW9VZ2dD_X8f5X6njqHe1ooLTG9D-U4o4GneyG_eTVXBsJfKGH_-3CjhtEZKQ4KrfXY9peg39jl8WSxbk4UG-ph4_PopxP7Uc83ddjemobDdg9wx1TfWBHC9a5i7zl8nUzEicD6-T4GWKGqSNB1HTIAMQ5qhiuYUnb74JlDGX11l7W5ECyGe-mKRG2FqtaoT9FziQFsJyo5uP7O-U-XuZeUI41SL8UbPdHyS1yHjka983VvLwpIMkzyNI5r2J3O-c3yt7a6RoIBxY2wZ-wR2TntY9G6RjDlQ31uaUDtveI_e2cuhW646WLfx_ytxZDVQkUWThkevITi9bBSXSIMC3sl0FsD_-1MafPgXfCr_REamEcKATOqChE8yBztLaKN00KSmsidzT51CfdPF049qupmGzpWl0sIWWWyP1gRmhS-UJzsyR7qjc4bocCY5udkDXpTRyGvZ1bWXTpd24TR8ksIrEsUOvlql9qiRNbCXE_bVy77jY5v4Tu8Xd57j5_QhSGfmX8YtU7oK_SPVmMivmru0UPUrY7T_LbcxgcCfc6LDdbkeY4uHHRIgymOvaVlEpHgpeVD0wyDED6J60faIsMzgV5TlCO-F2fPeoB_wdxs3gpmVWwG7V7u-Dffp0-ls4P5_PwNFP0bPVeLCGXHGDvj7NZLaYwj-5kbFXqjO_VBFAOOjWxCNbPk2gqDmT40y9Y26Ic1KXJz9pOZbiezrpfDrtfCqOlrhGoeAcHh0cLQWBiRt5D8T0YzbprSyoTOaEfAv4hMVsy-SaS0lRrgr2b1hpsNGGsmKAk3hD45LJEwQy57yFSWXYYcQ_L5SdI20InMRJpFwfRFI4TEW1wgJ7AYayWE7YgCWC1YDTuAZ60L3oqBiSFQtoCSEY5SRmFIY0EajYo3ifT-Nbeg8dxzkeo8LX-5qHvmQiZ1saJciqjw278tGTTchTwkBPkdivLE-H2JnmQxRt0kRE7LonKdEg4vF9_0Rtn_4GsticFQULdx1kMae36idapOfMMjwiookcqQMotvfUXYnivzLzH2l2-UK-DhDy-jnlIj_ta7O0DoFUGEuhH4FhfZSWPCu5Mdq51hYvnjBynbBrFFVeqrisGbfz7MQ-Y6RGelKdMPLY-JVVmtH3aPFXnuKMGyAgdo5SYeF3EhbrGxoPFk1HbOQfyWzewL82iOj9KnngL5d2LTjCheKZO3SvSTeXZ_-qL86TaXXEHwuyB3WXhoU-Ot93IvDKymJztaLBux5ctkL3ey4T8rjSiEz6fXJ2RqZ9kLIWeI1mQ9SaO6TrnonCCyw3BnfiDMEZso2-xHOdruk05Wwj6NNpNj9msqfm6F5DszChaWO1UpbGqlbTnEtNaykYb18Exx510bj1IVjsT5a-pdURWCNTsNBne6DXcwMLfboH-rQdfbwHej3_fT5A8zO2C8a7q4ArjqOJ92DOwJuRd10uzkA7waUctlkt3h48d21UrgZmEbBtfmiRG5qJb2wSlqcBE7plRYa2BKuRCrE5g2UMNO_sXPwsIPwPxEnHzVljNTuvuXGxpqlzldYLEX3Wqr4W6mWsrwL-JGV3Act4i6-2qRcMFtyFPoh5gq29mvOozlpGCw0XmEOX0bOq0Zy-jJqmIzr6V3VaW0gBj1zPplf8_OGxN4jQe43vvmSzP_zhy9WXWKcRGODYXvbNr_NzcHMudypfwseNuZmLyUF1w6BFrHA0XweQF21oDrOdr28ulzolUmcl7bcL4pQ5WcjJqWT48DD6cij-e1QnIE0rwf_cViJgPa1EUpCsIqN40zxVoIuTCkBMxECJvJDphBSqc5Dfo2NSPBoTD8QWoOG9BmCv3xeVVBqGBHSY3xMZXWGtFIMSIRWI5_Th3d6W0UQmfajejShZ6oLSN-jqRvXzjSjAGo9uQ61iupGRwFgN24QoGnExmc_rqY2QTVDmGPLu_XEAo6CKQZe5Slx105CUIaRDHTUYcH94Sg7xr0MJ28mlaHdYCstcOJarAKLxM-fRFgLyqGBg0mFx3rOHNaq-f9A_EXXsXl_2sC2WVR9gjtZ7CJFN16V_7nDZFtxJtliei07-qYSJDiFvAWGDB6UiwUAlvYYMpa13vFaQVLyrG6nQyaZS2Gy5Yzg-roS6AHewoyCAKNZwJzUExZNp0y5V9V_R0U4Oz77nN8zQlLbyShwgpfhKGaTCkqLMmay-srzQLxw2NFlXZVeZcYzxtvK_Ys0ImIz_xCRbGueUfbwYfeh-LDe6ukYxAC_x-oN9Rm38aAjV8N0sQvSGH1hQFBaVAVVrhvX8mQ1g1g8LoCvhgMfgJS7SN4lOsqpj-k2uVLJlgy-sjmwGPaDParCGVw_sPgGQDpjMtSADDylyVM-U6oPXVYw2ArhmNik0q4WVFl7WSXtiLZ8uXjbn4_gYt6q5RUl_iuJWc5XV1mdXBuzSljHx2SFn1299ix-deUa-T7n0zx76CDYk7C6DBQ_CjUPHtUOHHc4NL3YX8d6ovvv58cD5KSSfCMG5Ije9tO2b8Mw45OmN1orl0aT5eK_9FR-lGl37PGb2Pg90nMW7KCMxVqJkEVnVhWT5yy1G6eC80WHLe1epQrvKfB07AVrfCODlGICczj01XV9YzaVJmuBXQnRl2SS6YmdTVAhPrQOtKLGKSSjm7ZAUqayhwZKMlbYVqzZ80DUEvSBYUSlu7vPAS-y4wmLhz2WCIdwPoia4sN8-1K9m9pFbuK_1sunFFXUVpK8TFu9rLrzqL1RNKND-XtWvBXjVCx7-LjWkXfFrh2zvTQ_0qAChxPdfOWUkPe6ogzReZvxvcfxv0W7edu1aMQPAz1PU-3UV_22HytvXOsXvbIF54ud8gIqIc_ArPpTIHqqCLYyokySOfAdXvvTfvroLVvVLVYV2l60aXO2WTVcpq35Z398xanVBVzEz3_vpwu7WMQExE2_mptW3ezqhpwLa-nJPJ_REQM-qbwF1Qje-WNR2PXaLbMu2QXZfFfSGdck5kzgUaVt6XcH7jqiZrlufGHvTDvgXzsRbNPs3WqH9u8sgu-fOTiaqD2lFHazj1XS9sDr8LMubr-v5iu9qgDeyGQg_6gWW3UQaZTS7eDZ0RNZvWRn0BS7mTRbiCyWxGsqVhRyKd1WHhlInCfEyoLGmvX-_U4VFYBfDVATpOqfZBtflK7Wa9vZymQ3REHKicoqh96FIInYbF16eVbai7XsoaPe7_dluD-MJDpr7GPbkVyaeT1HYdoP1P7GWq1M_ZT8e6ozIES9lUYyFrziD6OqWFq9Ug3pz_9pkqyrx7nkGCnmhhfnUcMXs6EKnpIp_ENjxW_wyng4Ka8uvKVnqnc2gxoV4o5wmrGjXMCzzAUbIrlkuaYMTiGJCr7loYPAoLM1-XFHdKPDlMiVxKnaq82jb3EqmL8X9iTgwIIPkE97hX6zP-oFDQiG8snahearPPjBfQdoH96HOG5XlaOCjiG8_apnT-_ekA1aKZHfM4exwFSmTmKvAqEmRYXm8B2lT9RJ_xWQcj2cToKG7F2umvu75-B2dd02clkuqv4TzsX7HNbWcFqxnm-YOVvCqVRt911Pdi791jyTT2aPSTrFWKaiSpM79MrvAJ08DnzbBLb5CFjNuPtxZNOqDhesmreX-t_z8mqiMyn1aZLDQFbLHg39Qb4MgPXiU32pWn2z-q_r7Pw" rel="nofollow noreferrer" title="C++ (GCC) – Attempt This Online">Attempt This Online!</a></p>
<p>This matches the output of wastl's program up to 12 terms, and does so much faster (<s>62</s> <s>65</s> 2600 times faster on my machine).</p>
<p>Certain design elements were quite natural and are shared between both our programs – namely, the use of 128-bit integer coordinates, the coordinates of the starting tetrahedron, and multiplying all coordinates by 3 for each successive term. The remaining details are implemented from scratch though, without consulting wastl's program.</p>
<p>The fact that both versions of my program agree with wastl's up to <span class="math-container">\$A276272(12)\$</span> strongly suggests that they're all correct up to that point (and beyond it by using larger integers), and that the OEIS entry can finally be updated.</p>
<p>My previous version used affine transformations to rotate each polytet for comparison and deduplication. I wanted to keep that version up, rather than relegating it to the edit history, but the 65536 character limit prevented that.</p>
<p>This new version does its rotations entirely while remaining in tree representation, using Cartesian coordinates only to check for overlaps between tetrahedrons.</p>
<p>Compared to the previous affine transform version, it's 32 times faster when both are in <code>USE_GMP</code> mode. In basic 128-bit integer mode, it's 40 times faster. In both modes, it uses about 32 times less RAM than the affine transform version (about 27 times less RAM than wastl's program).</p>
<p>It does deduplication by serializing the tree representation with every possible choice of singly-attached tetrahedron as its root node, doing 3 rotations of each, and choosing the serialization that is lexicographically least for hash-table comparison against polytets that were previously identified as unique using the same method.</p>
<p>As such, it's conceptually similar to the previous version – both take advantage of the fact that all polytets have some tetrahedrons that are attached on only one face, because due to a tetrahedron's dihedral angle being irrational, a polytet can never curve around and attach to one of its own faces.</p>
<p>So, the computationally expensive affine transformation is replaced with a tree re-rooting. This operation now being very fast, it can do a new optimization: Delaying the tetrahedron overlap/collision checking until after deduplication, so that a provisionally new polytet won't be checked for overlaps just to find that it's a duplicate.</p>
<p>The timings shown in the output are cumulative.</p>
<p>Output in basic 128-bit integer mode:</p>
<pre><code>1: 1 [0 ms]
2: 1 [0 ms]
3: 1 [0 ms]
4: 4 [0 ms]
5: 10 [0 ms]
6: 39 [0 ms]
7: 164 [2 ms]
8: 767 [13 ms]
9: 3656 [78 ms]
10: 18186 [455 ms]
11: 91532 [2775 ms]
12: 468203 [17162 ms]
</code></pre>
<p>Output in <code>USE_GMP</code> mode:</p>
<pre><code>1: 1 [0 ms]
2: 1 [0 ms]
3: 1 [0 ms]
4: 4 [0 ms]
5: 10 [0 ms]
6: 39 [2 ms]
7: 164 [12 ms]
8: 767 [72 ms]
9: 3656 [399 ms]
10: 18186 [2288 ms]
11: 91532 [13316 ms]
12: 468203 [78887 ms]
13: 2417722 [467574 ms]
14: 12595984 [2817342 ms]
</code></pre>
<p>There's still plenty of room for further speed-ups, such as adding multithreading, and applying various more specific optimizations. Disk storage and merge-sorting could be used to do away with the RAM limit, allowing time to become the only limit.</p>
<h2>Output from the affine transform version</h2>
<p>The version uses about 20% more RAM than wastl's program.</p>
<p>In basic 128-bit integer mode:</p>
<pre><code>1: 1 [0 ms]
2: 1 [0 ms]
3: 1 [0 ms]
4: 4 [0 ms]
5: 10 [2 ms]
6: 39 [10 ms]
7: 164 [53 ms]
8: 767 [296 ms]
9: 3656 [2350 ms]
10: 18186 [15845 ms]
11: 91532 [106165 ms]
12: 468203 [683449 ms]
13: 2417721 [4291118 ms]
14: 663520 [4734026 ms]
</code></pre>
<p>The 128-bit math is clearly overflowing beyond <span class="math-container">\$A276272(13)\$</span>, and as the version below shows, that value itself is also incorrect.</p>
<p>In <code>USE_GMP</code> mode:</p>
<pre><code>1: 1 [0 ms]
2: 1 [0 ms]
3: 1 [1 ms]
4: 4 [2 ms]
5: 10 [12 ms]
6: 39 [53 ms]
7: 164 [269 ms]
8: 767 [1607 ms]
9: 3656 [9653 ms]
10: 18186 [61997 ms]
11: 91532 [389137 ms]
12: 468203 [2459990 ms]
13: 2417722 [15555313 ms]
</code></pre>
<p>It may even be enough to reach <span class="math-container">\$A276272(14)\$</span>, though that's projected to use 42 GB RAM (getting close to my machine's 64 GB), so I won't be able to run it beyond that.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.rust-lang.org/" rel="nofollow noreferrer">Rust</a>, 11 (hopefully correct) terms</h1>

<pre class="lang-rust prettyprint-override"><code>
use ::std::ops::{Add, Sub, Mul};
use ::std::rc::Rc;
use ::std::hash::{Hash, Hasher};
use ::std::collections::HashSet;
use ::std::iter;
use ::std::fmt::{self, Formatter, Display};
use ::std::time::Instant;

type Coord = i128;

#[derive(Copy, Clone, PartialEq, Eq, Debug)]
struct Vec3([Coord; 3]);

impl Vec3 {
    fn dot(self, other: Vec3) -&gt; Coord {
        self.0.iter().zip(other.0.iter()).map(|(a, b)| a * b).sum()
    }
}

impl Display for Vec3 {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        write!(f, "({}, {}, {})", self.0[0], self.0[1], self.0[2])
    }
}

impl Mul&lt;Vec3&gt; for Coord {
    type Output = Vec3;

    fn mul(self, mut vec: Vec3) -&gt; Vec3 {
        for i in &amp;mut vec.0 {
            *i *= self;
        }
        vec
    }
}

impl Add for Vec3 {
    type Output = Vec3;

    fn add(mut self, other: Vec3) -&gt; Vec3 {
        for (i, n) in self.0.iter_mut().enumerate() {
            *n += other.0[i];
        }
        self
    }
}

impl Sub for Vec3 {
    type Output = Vec3;

    fn sub(self, other: Vec3) -&gt; Vec3 {
        self + (-1 * other)
    }
}

#[derive(Clone, Debug)]
struct Tetrahedron([Vec3; 4]);

impl Default for Tetrahedron {
    fn default() -&gt; Tetrahedron {
        Tetrahedron([
            Vec3([-1, -1, -1]),
            Vec3([-1,  1,  1]),
            Vec3([ 1, -1,  1]),
            Vec3([ 1,  1, -1]),
        ])
    }
}

impl Display for Tetrahedron {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        write!(f, "Tetrahedron({}, {}, {}, {})", self.0[0], self.0[1], self.0[2], self.0[3])
    }
}

impl Tetrahedron {
    fn collides(&amp;self, other: &amp;Tetrahedron) -&gt; bool {
        let mut othervecs = [3 * self.0[1], 3 * self.0[2], 3 * self.0[3]];
        let sum = self.0[0] + self.0[1] + self.0[2] + self.0[3];
        let mut same = 0;

        for (i, &amp;vec) in self.0.iter().enumerate() {
            let sum = sum - vec;
            let vec = 3 * vec;
            let through = vec - sum;
            for (j, &amp;u) in other.0.iter().enumerate() {
                let u = 3 * u;
                if u == vec { same += 1 }
                let up = (sum - u).dot(through);
                for &amp;v in &amp;other.0[j+1..] {
                    let v = 3 * v;
                    let edge = v - u;
                    let ep = edge.dot(through);

                    if up.signum() != ep.signum() || up.abs() &gt;= ep.abs() {
                        continue
                    }

                    let intersection = ep * u + up * edge;
                    if othervecs.iter().enumerate().all(|(i, &amp;ov)| {
                        let mid = othervecs[(i+1)%3] + othervecs[(i+2)%3];
                        let ov = 2 * ov - mid;
                        (2 * intersection - ep * mid).dot(ep * ov) &gt; 0
                    }) {
                        return true
                    }
                }
            }

            if i != 3 { othervecs[i] = vec; }
        }
        if same == 4 { panic!("EQUAL TETRAHEDRA IN .collides()"); }
        false
    }

    // Mirroring also scales by 3
    fn mirror(&amp;self, i: usize) -&gt; Tetrahedron {
        let mut sum = Vec3([0; 3]);
        for (j, &amp;vec) in self.0.iter().enumerate() {
            if j != i { sum = sum + vec; }
        }

        let mut copy = self.clone();
        copy.scale();

        copy.0[i] = 2 * sum - copy.0[i];
        copy.swap(i, 3);
        copy.rotate_left(i);

        copy
    }

    fn scale(&amp;mut self) {
        for vec in self.0.iter_mut() {
            *vec = 3 * *vec;
        }
    }

    fn rotate_left(&amp;mut self, n: usize) {
        self.0[..3].rotate_left(n)
    }

    fn swap(&amp;mut self, a: usize, b: usize) {
        self.0.swap(a, b)
    }

    fn reverse(&amp;mut self) {
        self.0.reverse()
    }
}

type EndpointIter&lt;'a&gt; = Box&lt;dyn Iterator&lt;Item = Endpoint&gt; + 'a&gt;;

#[derive(Debug, Clone)]
struct Endpoint {
    tree: Rc&lt;TetraTree&gt;,
    hedron: Rc&lt;Tetrahedron&gt;,
}

impl Endpoint {
    fn iter_endpoints(&amp;self) -&gt; EndpointIter {
        let mut hedron = Rc::clone(&amp;self.hedron);
        //Rc::make_mut(&amp;mut hedron).swap(0, 3);
        Rc::make_mut(&amp;mut hedron).reverse();

        Box::new(self.clone().into_iter_directions()
            .chain(self.tree.iter_endpoints(
                Rc::new(TetraTree {
                    subtrees: [None, None, None],
                    hedron,
                })
            ))
        )
    }

    fn into_iter_directions(self) -&gt; EndpointIter&lt;'static&gt; {
        Box::new(iter::successors(Some(self), |this| {
            let mut this = this.clone();
            Rc::make_mut(&amp;mut this.tree).rotate_left(1);
            Rc::make_mut(&amp;mut this.hedron).0[1..].rotate_left(1);
            Some(this)
        }).take(3))
    }

    fn iter_extensions(&amp;self) -&gt; EndpointIter {
        let mut tree = self.tree.as_ref().clone();
        tree.scale();

        let mut hedron = self.hedron.as_ref().clone();
        //hedron.swap(0, 3);
        hedron.reverse();
        hedron.scale();

        Box::new(Endpoint {
            tree: Rc::new(tree),
            hedron: Rc::clone(&amp;self.hedron),
        }.into_iter_directions().filter_map(|endpoint| {
            let mut new = endpoint.hedron.mirror(3);
            new.swap(0, 3);
            if endpoint.tree.collides(&amp;new) {
                None
            } else {
                let mut hedron = endpoint.hedron;
                Rc::make_mut(&amp;mut hedron).scale();

                Some(Endpoint {
                    tree: Rc::new(TetraTree {
                        subtrees: [Some(endpoint.tree), None, None],
                        hedron,
                    }),
                    hedron: Rc::new(new),
                })
            }
        }).chain(self.tree.iter_extensions(Rc::new(TetraTree {
            subtrees: [None, None, None],
            hedron: Rc::new(hedron),
        }))))
    }

    fn iter_tetrahedra&lt;'a&gt;(&amp;'a self)
      -&gt; Box&lt;dyn Iterator&lt;Item = &amp;Tetrahedron&gt; + 'a&gt; {
        Box::new(
          iter::once(self.hedron.as_ref()).chain(self.tree.iter_tetrahedra())
        )
    }
}

impl Default for Endpoint {
    fn default() -&gt; Endpoint {
        Endpoint::from(Tetrahedron::default())
    }
}

impl From&lt;Tetrahedron&gt; for Endpoint {
    fn from(mut hedron: Tetrahedron) -&gt; Endpoint {
        let mirrored = hedron.mirror(0);
        hedron.scale();

        Endpoint {
            tree: Rc::new(TetraTree {
                subtrees: [None, None, None],
                hedron: Rc::new(mirrored),
            }),
            hedron: Rc::new(hedron),
        }
    }
}

impl Hash for Endpoint {
    fn hash&lt;H: Hasher&gt;(&amp;self, hasher: &amp;mut H) {
        let mut stuff: Vec&lt;_&gt; = self.tree.hash_helper(1).collect();
        stuff.push(self.tree.len());
        stuff.sort();
        stuff.hash(hasher);
    }
}

impl PartialEq for Endpoint {
    fn eq(&amp;self, other: &amp;Endpoint) -&gt; bool {
        self.iter_endpoints().any(|ep| ep.tree == other.tree)
    }
}

impl Eq for Endpoint {}

#[derive(Debug, Clone)]
struct TetraTree {
    subtrees: [Option&lt;Rc&lt;TetraTree&gt;&gt;; 3],
    hedron: Rc&lt;Tetrahedron&gt;,
}

impl TetraTree {
    fn iter_endpoints&lt;'x&gt;(&amp;'x self, behind: Rc&lt;TetraTree&gt;) -&gt; EndpointIter&lt;'x&gt; {
        let mut iterator = self.subtrees.iter().enumerate()
          .filter_map(|(i, opt)| opt.as_ref().map(|some| (i, some)));

        if let Some(first) = iterator.next() {
            let closure = move |(i, subtree): (usize, &amp;'x Rc&lt;TetraTree&gt;)| -&gt; EndpointIter&lt;'x&gt; {
                let mut behind = behind.as_ref().clone();
                behind.rotate_left(3-i);

                let mut this = self.clone();
                this.rotate_left(i);

                Rc::make_mut(&amp;mut this.hedron).reverse();

                this.subtrees.swap(1, 2);
                this.subtrees[0] = Some(Rc::new(behind));

                for (j, subtree) in this.subtrees.iter_mut().enumerate().skip(1)
                  .filter_map(|(j, s)| s.as_mut().map(|s| (j, s))) {
                    Rc::make_mut(subtree).rotate_left(j);
                }

                subtree.iter_endpoints(Rc::new(this))
            };
            Box::new(closure(first).chain(iterator.flat_map(closure)))
        } else {
            let mut hedron = self.hedron.as_ref().clone();
            //hedron.swap(0, 3);
            hedron.reverse();
            Endpoint {
                tree: Rc::clone(&amp;behind),
                hedron: Rc::new(hedron),
            }.into_iter_directions()
        }
    }

    fn rotate_left(&amp;mut self, i: usize) {
        self.subtrees.rotate_left(i);
        Rc::make_mut(&amp;mut self.hedron).rotate_left(i);
    }

    fn collides(&amp;self, hedron: &amp;Tetrahedron) -&gt; bool {
        self.hedron.collides(hedron) ||
          self.subtrees.iter()
            .filter_map(Option::as_ref)
            .any(|subtree| subtree.collides(hedron))
    }

    fn scale(&amp;mut self) {
        for subtree in self.subtrees.iter_mut().filter_map(Option::as_mut) {
            Rc::make_mut(subtree).scale();
        }
        Rc::make_mut(&amp;mut self.hedron).scale();
    }

    fn iter_extensions(&amp;self, behind: Rc&lt;TetraTree&gt;) -&gt; EndpointIter {
        Box::new(self.subtrees.iter().enumerate().flat_map(move |(i, next)| {
            let mut behind = behind.as_ref().clone();
            behind.rotate_left(3-i);

            let mut this = self.clone();
            this.rotate_left(i);

            let hedron = Rc::make_mut(&amp;mut this.hedron);
            hedron.reverse();

            this.subtrees.swap(1, 2);
            this.subtrees[0] = Some(Rc::new(behind));

            for (j, subtree) in this.subtrees.iter_mut().enumerate().skip(1)
              .filter_map(|(j, s)| s.as_mut().map(|s| (j, s))) {
                let subtree = Rc::make_mut(subtree);
                subtree.scale();
                subtree.rotate_left(j);
            }

            if let Some(next) = next {
                hedron.scale();
                next.iter_extensions(Rc::new(this))
            } else {
                let mut mirrored = hedron.mirror(3);
                mirrored.swap(0, 3);
                hedron.scale();

                if this.collides(&amp;mirrored) {
                    Box::new(iter::empty()) as EndpointIter
                } else {
                    Box::new(iter::once(Endpoint {
                        tree: Rc::new(this),
                        hedron: Rc::new(mirrored),
                    }))
                }
            }
        }))
    }

    fn iter_tetrahedra&lt;'a&gt;(&amp;'a self)
      -&gt; Box&lt;dyn Iterator&lt;Item = &amp;Tetrahedron&gt; + 'a&gt; {
        Box::new(iter::once(self.hedron.as_ref()).chain(
          self.subtrees.iter()
            .filter_map(Option::as_deref)
            .flat_map(TetraTree::iter_tetrahedra)
        ))
    }

    fn len(&amp;self) -&gt; usize {
        1usize + self.subtrees.iter()
              .filter_map(Option::as_deref).map(TetraTree::len).sum::&lt;usize&gt;()
    }

    fn hash_helper&lt;'a&gt;(&amp;'a self, behind: usize)
      -&gt; Box&lt;dyn Iterator&lt;Item = usize&gt; + 'a&gt; {
        let sub: Vec&lt;_&gt; = self.subtrees.iter().filter_map(Option::as_deref)
          .map(|a| (a, a.len())).collect();
        let sum = sub.iter()
          .map(|&amp;(_, len)| len).sum::&lt;usize&gt;() + behind + 1;
        Box::new(iter::once(behind).chain(
            sub.into_iter().flat_map(move |(sub, len)|
                        iter::once(len).chain(sub.hash_helper(sum - len)))
        ))
    }
}

impl PartialEq for TetraTree {
    fn eq(&amp;self, rhs: &amp;TetraTree) -&gt; bool {
        self.subtrees == rhs.subtrees
    }
}

impl Eq for TetraTree {}

fn main() {
    let verbose = std::env::args().skip(1).any(|arg| arg == "-v");
    let begin = Instant::now();

    println!("1: 1 [{}ms]", begin.elapsed().as_millis());
    if verbose {
        println!("{}\n--", Tetrahedron::default());
    }

    let mut polytets = HashSet::new();
    polytets.insert(Endpoint::default());

    for i in 2.. {
        println!("{}: {} [{}ms]", i, polytets.len(), begin.elapsed().as_millis());

        if verbose {
            for polytet in &amp;polytets {
                for hedron in polytet.iter_tetrahedra() {
                    println!("{}", hedron);
                }
                println!("--");
            }
        }

        polytets = polytets.iter()
          .flat_map(Endpoint::iter_extensions)
          .collect();
    }
}

</code></pre>
<p><a href="https://tio.run/##vVrrb9vIEf8s/xUbF3XIWKYt6z4UlCwgTXJIgN4rcfvFFQxKWlnMUSSPSzr2Wfrb05nZN0VFvmvRAFbIfcxrZ34zs1LViPrr16NGcBbHol7EcVGKOH56vVj02adm1mc/NNl25C6o5nH8ce4NrRKxgk3v4b8@w09e@XvmRZbxeZ0WORDHBZ947S1Ia155A8t1DRQFz5Z99n1RrZMaVvTZ21SUWfLoU6/TNY/jD7mokxzIHtWPJWdviqJasCuWDi7/BmN/uVnwKr3nwZuifOyzN1mR8z77OanqNMne/dZn@PeWz5q7cHok6qqZ1@xffD4MbojQiA2nIZBJ12VG4@zpqLfM2aKoAylkUYPWMc2F7Gyi@MOqHs5HFxGqGITR72kZ0FozFEbrpAw2QdJns3DDEvYK/o9Esw7Co972aKu4KtXZsqhcCcBQwYkUYRmzk3VTW3uRIGTJj1w0WU3ifKmA7YsA1h8HT9s@k3/hcZ9JQW8upuZxYB8vp5404BZjlGJC8hhlyfQ/NXUJYlyRmGA0FHPdZMpQKOE9nzum0tr0kFTK0lyqAYuiCxrvvUrZqyuSZASvW/iDSVcc8FfPMHvlSBaLAIl3H5onSZD2WR6iOM4J3sJmOEWeN2teJTUPQiVhzk6vmDrYm3Sq5cStrqAQU88TVDSz4ICQOM1OWXA2AJehVfqIrLdLP2859jWvq2TFF1WRBzfEk31n3fstXyboLCims1J7vJwNSJTWdM8jjGaRIXQ26DP5Nw37/jCjP2@YqdUdw8whMt0bHbtC/zdB4upk4@WZMWMeh764uyIiRKYLLrSc6tRPnJUk6awoMhIx4zXFEi2EcBDgPzdD8ARHDuf10n8dTslFkQggDbuyioBHGQr2@dJ5HpqtFEnJmsP@C/RbEzcnIFA7dLrCxuEPn2cY8yM9Ds8wjjK7o/WqKpq7Fczg/Bnuozni/Bk4N8TXh9hdxkSrUfQbotBLlzgiCT9JvSCmB2xrN5SwI5CiNmGE6K/kCSUJlOLkniBMY8Hn00EUTRVXqZhWa2TH@OIOrXiPhN1hZIhzLV5yBQpcRiK9yzFZsBew1HndbHA2mQl4ntCUfFaS9OZFXqd5w@Xr9shyTXOwmpAJG/mXaCM4/wYfUJqR4W@8r8PSUZJlkNfQHYp7yGyaMXlOisnZ7L4J0tNB@Nchepk3eImDI2djgda7RMBDWwEZPRngoCf5mZQc1sijojeQhE3YhVLaWqPidVPlDADSGMR8StuAtinaGMDXkTGdSlcckZvgH6yTMXHFvoOlZZKn8xfB8btf/vn6H@z63fXH1@/fvf34mn34kUUm6sPjUFJYJpngR8Ty/Jz9kFZVUaX5HYPhgol5knHBZo9sKLMqTWvISGPWiPR33gnNJlwp2iSkXqiyxomeZ8Yt6PgZbZFioJj4PXUN4fCcQ82lIWaOGSkgpjgckUqBdGkauJAmxdOUgWZG7Z4vUDCBWw0tmaqoQbzbjC/rILXUpCExnRKbE536Q5PlMdi7UrxK6xaEXikU2hqaLs8TW1Tk5hhs9XcTRcOpJ2QeWtlQHYdAoghAPdhBSmpPxaKVhN@j27f1Uxv0rM5AVHO8yxdlAeHyATQev0wmoOXfi4fx4jFnOJTURTWGBzxavXQCBwwr3WqaCgtVTtv6Qm@gAqfiPGYf52NyyGt4m0D2lo5px@U7zOgE6ZIABelcuBpTOZLc3FXD83Pl@lfAAvoPcjraFalcikd5fo6T6@RXTmd@YveF0soX2sf2rzPGJZ8DE8Zxzr8Erq9HIF9xSyos0kr1QXgavV40XyVpLlejpaKWooRByBxpGgtq0IIaETeJmN38SHWe/Zz25RIppnzZEssQP63rdMrWad7xS2iw6nQ@IfZGU9wLjVgzn3MhikoEn4o1lxT6bFOvUrGxuR4th0NwLvifiwYdNqYlqGHohc7gm@v1wUD9Anm3ayMJiGvREtswqoFIMAwdm9AhPNQ8F2SOZ7gbSqkhjg4yEbcVX8LhOyrShAt4O87qeGgnhfNzNem7pxp0fNGMuezMmbnR1TMhKufI3uQwNkg7IwjXbPf4drRMM4JS7Gy1O7f8AJhhcaEmtdYqpUm9erCmpSqmHrOHDGorZ1itEzrGAKVuxiGfOjWfZ@4W85EJtz2Y4NhSuZFvybYtdyLWDVna76kSdkWwF8Lgrl5gW1aouxvmW@nb3fhiXXuPpAeRpc3e9YkwbMdSrTE@wVQTnLxMZJY66jGMqn2Jx21@VPLxsQeeGZMAVORziTrt8NljAytSYBFx29ECtzKR1/96p69f4nhZFevAkT2OzS6Pzfewzst/XQyJmPXCmLU7Qk8IWVtjCHEssP2gutgHDN/Cg7YPH046bd/Q8kj/3IYHHci1Ed4WdpkF7xzH72N13TjRNfCKXlWP/z70S9@6WS7pImV8O/HAGnfdrnhWQrU7CCN1XSlxlHZFZSNWjgtlPIeztNOQ@LzlSDCQsuCoVcfcOHbpxH9rd/96gd/6kxytSgG6rfwRsLbcYKcn05G@kCJscaXYYb89WNN5buD4wE8lQv7YK/Am2Fc8p8rziO6UeeOXD4gVD6osnvFVmi9atWRHlfIw8U49VaCiD1zL3tHbEJx4qQu7jKKsoXmFT5uRaU4Afm/otgOfwlCGEqQn5EzgvkwrAUd3ZWSIcoBe9@4D0qpoKqwc1sU9Z8RPCRjGLFBtANrA13qzV22ruLQXkJYPnfVEr6cm3TJpeJbqHNeq2dodHGAFllwdzdfB8syvmxUhczaU8wd9dumy0bN4SXUlLazRQ2oRamK6ndWmxA7PZ9B9lxuJX1PgSwl0xxWQHhheoCHlTukGG8kKHEBneU91LYNnpc9KL3Xrota0Y9qUZFiryqxO20z@U@6jHE0lOuNsyyypSXa1jNKyVxH94fpzXwHaWYG20oqTV1Q1qU6tO2s4CWFvmfmcdjzd7aGNF7Qdt8tr3ZJ3d4Pi3b691crsv751LW1264WbDUFRF17RhO@aEoLjWB6YWUH5QO3e6FDY4RUeviJRW801SVcQdYsDcyooukPC1CCyXj1gfLv6W33acxOFX0keSg02mCxQI5iHrabmWaD7Tcw9BLl7ERc3erce@9F3T8geHcLhPwbD/wsU/tMgLL9ZmKm@vNP9Rh72Or5oBzsw21wGmzRPfgBM8H/FvV1j96iXfaj39l8OxHd1rHtLegW/Pb2gjctd1T5JL69fDGyZGl3nsNb9Dl@X9SOUvCwRXhTJLOaK3N5JjVm7TW7fOaD2fr@7r32g/tK9mlcD/49285md5p/Ebii/HfQ2eGMgTP5KwlGO2larOvYk9qaKch6JP5CPp98S6YBQUUsQYEW/UIjjMRGfBFYMp5fyrG9xWabjA4ch6TqnoAK63b@1MfugbSVgJAAYSZ8lqpNr9Xzu15Iz11Jy80lw20dzAxB1WAJkVlnglA1Ge/xHIaX1mB5x0lVOR8IR@GscYipx0f5zyJI46r4D6Ll9rfwyBReE1nG629J2W2b70moldFFzTZC@U9Lo88DuE1ab947202EDM/h1FspNCCS//61mhaBbVfyVD8/v4SirO2EThCxxYGzD4AM5Hp/dH@MJ4v4Zv0sxFaofBsERFF8kApYVGDrLXwTHg5gN2M3Tdi2mx325I@JZUgq@wI4ackwKCClkrw@oqWVCdS2Vp@2/87MzILDnzkdVLBrMyyJ7hCjG7K5@CyXdA9fpOXAFwas6sJdKLrkj@1OZyyjakSYGg1qtoFIxVMnbDykqu1hXVWKniNCX20aFJ9NvqdIDZtXk7j2bRn9X1mNdLJuOyF8BdtV5V@Vex3zWWk6ImsCxtmtlXbXQDXl0Tvk7OPsruLcIGvh7sipJa/Za0PtY4RF9iXYNbgenBxg1kr8uUkhjUw4GyCd4iGO5dqSDAOiAv@BWgAmiPPFYoEnV3cp1myForqaQz/gak7IkodlMniuPDVz/cgPwMYnkXoUUX/8D" rel="nofollow noreferrer" title="Rust – Try It Online">Try it online!</a> The footer contains some compatability implementations because TIO's Rust is a little old. (This has already been <a href="https://chat.stackexchange.com/transcript/message/54872387#54872387">reported</a> and added to the <a href="https://gist.github.com/cairdcoinheringaahing/46f79623ea7b5cfe67286d0a5e96d307" rel="nofollow noreferrer">list</a>.)</p>
<p>Output:</p>
<pre class="lang-rust prettyprint-override"><code>1: 1 [0ms]
2: 1 [0ms]
3: 1 [2ms]
4: 4 [8ms]
5: 10 [35ms]
6: 39 [139ms]
7: 164 [738ms]
8: 767 [4328ms]
9: 3656 [31298ms]
10: 18186 [287871ms]
11: 91532 [3154716ms]
</code></pre>
<p>As you can see, it also reports how long it took. (These are cumulated times.) You can use the <code>-v</code> option to list all tetrahedra for each polytet.</p>
<p>I don't really have a good way of verifying the results beyond A276272(5). I hope it works, but I'm not sure.</p>
<p>The idea is that we store the polytet as a tree of tetrahedra that also encodes orientation. But for collision detection we need actual tetrahedra. We start with the tetrahedron with vertices (-1, -1, -1), (-1, 1, 1), (1, -1, 1), (1, 1, -1) and scale all tetrahedra by 3 for every term. This avoids the need for fractions.</p>
<p>Can probably be made faster, but I don't know how.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/214203/">214203</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




