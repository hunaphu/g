<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::214203</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>013</td><td>C++ GCC</td><td>251003T124500Z</td><td><a href="https://codegolf.stackexchange.com/questions/214203/gluing-tetrahedra-together/283991#283991">Deadcode</a></td></tr>
<tr d-ix="1"><td>011</td><td>Rust</td><td>201108T231337Z</td><td><a href="https://codegolf.stackexchange.com/questions/214203/gluing-tetrahedra-together/214928#214928">wastl</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C++ (GCC)</a>, <s>12</s> 13+ terms</h1>
<pre class="lang-cpp prettyprint-override"><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;cstdint&gt;
#include &lt;cinttypes&gt;
#include &lt;array&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;functional&gt;
#include &lt;unordered_set&gt;
#include &lt;chrono&gt;

//#define USE_GMP
//#define DEBUG_PRINT

#ifdef USE_GMP
#include &lt;gmp.h&gt;
#   if GMP_NUMB_BITS != 64
#   error This is hard-coded for 64-bit limbs
#   endif
#endif

auto startTime = std::chrono::steady_clock::now();

void quitOverflow()
{
    auto currentTime = std::chrono::steady_clock::now();
    std::cerr &lt;&lt; "Quitting due to detected overflow" &lt;&lt; " [" &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(currentTime - startTime).count() &lt;&lt; " ms]" &lt;&lt; std::endl;
    exit(-1);
}

typedef __int128 Coord;
typedef std::array&lt;Coord, 3&gt; Coord3;
typedef std::array&lt;Coord3, 4&gt; Tetrahedron;
class Tet
{
    void initFaces()
    {
        faceAttached[0] = false; // t[0],t[1],t[2]
        faceAttached[1] = false; // t[0],t[1],t[3]
        faceAttached[2] = false; // t[0],t[2],t[3]
        faceAttached[3] = false; // t[1],t[2],t[3]
    }
public:
    Tetrahedron t;
    bool faceAttached[4];
    Tet(                    ) : t( ) {initFaces();}
    Tet(const Tetrahedron &amp;t) : t(t) {initFaces();}
};
typedef std::vector&lt;Tet&gt; Polytet;

// vertex indices of faces with identical chirality
static int tetrahedronFaces[4][4] =
{
    {0, 2, 1, 3},
    {0, 1, 3, 2},
    {0, 3, 2, 1},
    {1, 2, 3, 0},
};

static int tetrahedronEdges[6][2] =
{
    {0, 1},
    {1, 2},
    {2, 0},
    {0, 3},
    {1, 3},
    {2, 3},
};

Coord3 operator-(const Coord3 &amp;a)
{
    Coord3 c;
    c[0] = -a[0];
    c[1] = -a[1];
    c[2] = -a[2];
    return c;
}
Coord3 operator+(const Coord3 &amp;a, const Coord3 &amp;b)
{
    Coord3 c;
    c[0] = a[0] + b[0];
    c[1] = a[1] + b[1];
    c[2] = a[2] + b[2];
    return c;
}
Coord3 operator-(const Coord3 &amp;a, const Coord3 &amp;b)
{
    Coord3 c;
    c[0] = a[0] - b[0];
    c[1] = a[1] - b[1];
    c[2] = a[2] - b[2];
    return c;
}
Coord3 operator*(const Coord3 &amp;a, const Coord b)
{
    Coord3 c;
    c[0] = a[0] * b;
    c[1] = a[1] * b;
    c[2] = a[2] * b;
    return c;
}
#ifndef USE_GMP
Coord dot(const Coord3 &amp;a, const Coord3 &amp;b)
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}
#endif

#ifdef USE_GMP
void mpz_set_int128(mpz_t &amp;dst, const __int128 &amp;src)
{
    __int128 abssrc = src &lt; 0 ? -src : src;
    mpz_import(dst, 2, -1, 8, 0, 0, &amp;abssrc);
    if (src &lt; 0)
        mpz_neg(dst, dst);
}
void mpz_get_int128(__int128 &amp;dst, const mpz_t &amp;src)
{
    dst = 0;
    size_t count;
    uint64_t limbs[2];

    mpz_export(limbs, &amp;count, -1, sizeof(uint64_t), 0, 0, src);

    if (count &gt; 2)
        quitOverflow();

    bool isNegative = mpz_sgn(src) &lt; 0;

    ((uint64_t*)&amp;dst)[0] = limbs[0];
    if (count &gt; 1)
    {
        if (limbs[1] &gt; INT64_MAX)
            if (!isNegative || limbs[1] &gt; (uint64_t)INT64_MIN || limbs[0] != 0)
                quitOverflow();
        ((uint64_t*)&amp;dst)[1] = limbs[1];
    }

    if (isNegative)
        dst = -dst;
}
#endif

class TetrahedronOverlap
{
#ifdef USE_GMP
    mpz_t intersectNumerator, intersectDenominator, uNumerator, vNumerator, uvDenominator, uvNumeratorSum;
    mpz_t center[3], normal[3], tmp[3], p0p1[3], intersectionPoint[3], delta[3], edge1[3], edge2[3];
    mpz_t a[4][3];
    mpz_t b[4][3];
    mpz_t triangle[3][3];
    void setTetrahedron(mpz_t dst[4][3], const Tetrahedron &amp;src)
    {
        for (int p=0; p&lt;4; p++)
            for (int d=0; d&lt;3; d++)
                mpz_set_int128(dst[p][d], src[p][d]);
    }
    void dot(mpz_t &amp;result, const mpz_t a[3], const mpz_t b[3])
    {
        mpz_mul   (result, a[0], b[0]);
        mpz_addmul(result, a[1], b[1]);
        mpz_addmul(result, a[2], b[2]);
    }
public:
    TetrahedronOverlap()
    {
        mpz_inits(intersectNumerator, intersectDenominator, uNumerator, vNumerator, uvDenominator, uvNumeratorSum, NULL);
        for (int d=0; d&lt;3; d++)
        {
            mpz_init(center[d]);
            mpz_init(normal[d]);
            mpz_init(tmp[d]);
            mpz_init(p0p1[d]);
            mpz_init(intersectionPoint[d]);
            mpz_init(delta[d]);
            mpz_init(edge1[d]);
            mpz_init(edge2[d]);
        }
        for (int p=0; p&lt;4; p++)
        {
            for (int d=0; d&lt;3; d++)
            {
                mpz_init(a[p][d]);
                mpz_init(b[p][d]);
            }
        }
        for (int p=0; p&lt;3; p++)
            for (int d=0; d&lt;3; d++)
                mpz_init(triangle[p][d]);
    }
    ~TetrahedronOverlap()
    {
        mpz_clears(intersectNumerator, intersectDenominator, uNumerator, vNumerator, uvDenominator, uvNumeratorSum, NULL);
        for (int d=0; d&lt;3; d++)
        {
            mpz_clear(center[d]);
            mpz_clear(normal[d]);
            mpz_clear(tmp[d]);
            mpz_clear(p0p1[d]);
            mpz_clear(intersectionPoint[d]);
            mpz_clear(delta[d]);
            mpz_clear(edge1[d]);
            mpz_clear(edge2[d]);
        }
        for (int p=0; p&lt;4; p++)
        {
            for (int d=0; d&lt;3; d++)
            {
                mpz_clear(a[p][d]);
                mpz_clear(b[p][d]);
            }
        }
        for (int p=0; p&lt;3; p++)
            for (int d=0; d&lt;3; d++)
                mpz_clear(triangle[p][d]);
    }
    void setA(const Tetrahedron &amp;x) {setTetrahedron(a, x);}
    void setB(const Tetrahedron &amp;x) {setTetrahedron(b, x);}
    bool operator()()
    {
        // Take advantage of the fact that the two tetrahedrons are regular and congruent, and
        // just check if any edge of tetrahedron "a" intersects with any face of tetrahedron "b".
        // Don't count it if only the endpoint of an edge intersects.
        for (int edgeNum=0; edgeNum&lt;6; edgeNum++)
        {
            const mpz_t *p0 = a[tetrahedronEdges[edgeNum][0]];
            const mpz_t *p1 = a[tetrahedronEdges[edgeNum][1]];
            for (int faceNum=0; faceNum&lt;4; faceNum++)
            {
                mpz_t *normalizedTetrahedron[4][3]; // first 3 points are the face, and the 4th point is for calculating the normal
                for (int i=0; i&lt;4; i++)
                    for (int d=0; d&lt;3; d++)
                        normalizedTetrahedron[i][d] = &amp;b[tetrahedronFaces[faceNum][i]][d];
                // Center coordinates will be multiplied by 3 compared to original coordinates.
                // Get center of face by averaging its vertices' coordinates; the
                // division by 3 is implied by omitting the multiplication by 3.
                for (int d=0; d&lt;3; d++)
                    mpz_set(center[d], *(normalizedTetrahedron[0][d]));
                for (int p=1; p&lt;3; p++)
                    for (int d=0; d&lt;3; d++)
                        mpz_add(center[d], center[d], *(normalizedTetrahedron[p][d]));
                for (int d=0; d&lt;3; d++)
                {
                    mpz_neg(normal[d], center[d]);
                    mpz_addmul_ui(normal[d], *(normalizedTetrahedron[3][d]), 3);
                }
                for (int d=0; d&lt;3; d++)
                {
                    mpz_sub(tmp [d], *(normalizedTetrahedron[0][d]), p0[d]);
                    mpz_sub(p0p1[d],                         p1[d],  p0[d]);
                }
                dot(intersectNumerator  , normal, tmp);
                dot(intersectDenominator, normal, p0p1);
                int cmp = mpz_cmp_ui(intersectDenominator, 0);
                if (cmp == 0)
                    continue; // edge is parallel to face, which we don't count as an overlap
                if (cmp &lt; 0)
                {
                    mpz_neg(intersectNumerator  , intersectNumerator  );
                    mpz_neg(intersectDenominator, intersectDenominator);
                }
                if (mpz_cmp_ui(intersectNumerator, 0) &lt;= 0 || mpz_cmp(intersectNumerator, intersectDenominator) &gt;= 0)
                    continue;
                // These coordinates are all multiplied by intersectDenominator
                for (int d=0; d&lt;3; d++)
                {
                    mpz_mul(intersectionPoint[d], p0[d], intersectDenominator);
                    mpz_addmul(intersectionPoint[d], p0p1[d], intersectNumerator);
                }
                for (int i=0; i&lt;3; i++)
                    for (int d=0; d&lt;3; d++)
                        mpz_mul(triangle[i][d], *(normalizedTetrahedron[i][d]), intersectDenominator);
                // Check if the intersection point is inside the triangle
                for (int d=0; d&lt;3; d++)
                {
                    mpz_sub(delta[d], intersectionPoint[d], triangle[0][d]);
                    mpz_sub(edge1[d], triangle[1][d]      , triangle[0][d]);
                    mpz_sub(edge2[d], triangle[2][d]      , triangle[0][d]);
                }
                mpz_mul   (uNumerator, delta[1], edge2[0]);
                mpz_submul(uNumerator, delta[0], edge2[1]);
                mpz_mul   (vNumerator, delta[0], edge1[1]);
                mpz_submul(vNumerator, delta[1], edge1[0]);
                mpz_mul   (uvDenominator, edge1[1], edge2[0]);
                mpz_submul(uvDenominator, edge1[0], edge2[1]);
                cmp = mpz_cmp_ui(uvDenominator, 0);
                if (cmp == 0)
                    continue;
                if (cmp &lt; 0)
                {
                    mpz_neg(uNumerator, uNumerator);
                    mpz_neg(vNumerator, vNumerator);
                    mpz_neg(uvDenominator, uvDenominator);
                }
                if (mpz_cmp_ui(uNumerator, 0) &lt;= 0 || mpz_cmp_ui(vNumerator, 0) &lt;= 0)
                    continue;
                mpz_add(uvNumeratorSum, uNumerator, vNumerator);
                if (mpz_cmp(uvNumeratorSum, uvDenominator) &lt; 0)
                    return true;
            }
        }
        return false;
    }
#else
    const Tetrahedron *a, *b;
public:
    void setA(const Tetrahedron &amp;x) {a = &amp;x;}
    void setB(const Tetrahedron &amp;x) {b = &amp;x;}
    bool operator()()
    {
        // Take advantage of the fact that the two tetrahedrons are regular and congruent, and
        // just check if any edge of tetrahedron "a" intersects with any face of tetrahedron "b".
        // Don't count it if only the endpoint of an edge intersects.
        for (int edgeNum=0; edgeNum&lt;6; edgeNum++)
        {
            Coord3 p0 = (*a)[tetrahedronEdges[edgeNum][0]];
            Coord3 p1 = (*a)[tetrahedronEdges[edgeNum][1]];
            for (int faceNum=0; faceNum&lt;4; faceNum++)
            {
                Tetrahedron normalizedTetrahedron; // first 3 points are the face, and the 4th point is for calculating the normal
                for (int i=0; i&lt;4; i++)
                    normalizedTetrahedron[i] = (*b)[tetrahedronFaces[faceNum][i]];
                Coord3 center = {{0, 0, 0}}; // multiplied by 3 compared to original coordinates
                // Get center of face by averaging its vertices' coordinates; the
                // division by 3 is implied by omitting the multiplication by 3.
                for (int p=0; p&lt;3; p++)
                    for (int d=0; d&lt;3; d++)
                        center[d] += normalizedTetrahedron[p][d];
                Coord3 normal;
                for (int d=0; d&lt;3; d++)
                    normal[d] = normalizedTetrahedron[3][d] * 3 - center[d];
                Coord intersectNumerator   = dot(normal, normalizedTetrahedron[0] - p0);
                Coord intersectDenominator = dot(normal,                       p1 - p0);
                if (intersectDenominator == 0)
                    continue; // edge is parallel to face, which we don't count as an overlap
                if (intersectDenominator &lt; 0)
                {
                    intersectNumerator   = -intersectNumerator;
                    intersectDenominator = -intersectDenominator;
                }
                if (intersectNumerator &lt;= 0 || intersectNumerator &gt;= intersectDenominator)
                    continue;
                // These coordinates are all multiplied by intersectDenominator
                Coord3 intersectionPoint = p0 * intersectDenominator + (p1 - p0) * intersectNumerator;
                Coord3 triangle[3];
                for (int i=0; i&lt;3; i++)
                    triangle[i] = normalizedTetrahedron[i] * intersectDenominator;
                // Check if the intersection point is inside the triangle
                Coord3 delta = intersectionPoint - triangle[0];
                Coord3 edge1 = triangle[1]       - triangle[0];
                Coord3 edge2 = triangle[2]       - triangle[0];
                Coord uNumerator = delta[1]*edge2[0] - delta[0]*edge2[1];
                Coord vNumerator = delta[0]*edge1[1] - delta[1]*edge1[0];
                Coord uvDenominator = edge1[1]*edge2[0] - edge1[0]*edge2[1];
                if (uvDenominator == 0)
                    continue;
                if (uvDenominator &lt; 0)
                {
                    uNumerator = -uNumerator;
                    vNumerator = -vNumerator;
                    uvDenominator = -uvDenominator;
                }
                if (uNumerator &lt;= 0 || vNumerator &lt;= 0)
                    continue;
                if (uNumerator + vNumerator &lt; uvDenominator)
                    return true;
            }
        }
        return false;
    }
#endif
};

void attachNewTet(Tet &amp;t, const Tet &amp;tetToAttachTo, const int faceNum)
{
    Coord3 &amp;newVertex = t.t[3];
    newVertex = {{0, 0, 0}};
    // Get center of face by averaging its vertices' coordinates; the
    // division by 3 is implied by omitting the multiplication by 3.
    for (int p=0; p&lt;4; p++)
    {
        if (p == 3 - faceNum)
            continue;
        for (int d=0; d&lt;3; d++)
            newVertex[d] += tetToAttachTo.t[p][d];
    }
    // Finalize the new vertex
    for (int d=0; d&lt;3; d++)
        newVertex[d] += newVertex[d] - tetToAttachTo.t[3 - faceNum][d] * 3;
    // Copy the other vertices
    for (int p=0; p&lt;3; p++)
    {
        int p1 = tetrahedronFaces[faceNum][p];
        for (int d=0; d&lt;3; d++)
            t.t[p][d] = tetToAttachTo.t[p1][d] * 3;
    }
    t.faceAttached[0] = true;
    t.faceAttached[1] = false;
    t.faceAttached[2] = false;
    t.faceAttached[3] = false;
}

class NormalizedPolytet : public std::vector&lt;Tetrahedron&gt;
{
public:
    NormalizedPolytet(const Polytet &amp;polytet)
    {
        reserve(polytet.size());
        for (auto tet=polytet.cbegin(); tet!=polytet.cend(); ++tet)
        {
            Tetrahedron &amp;t = emplace_back(tet-&gt;t);
            std::sort(t.begin(), t.end());
        }
        std::sort(this-&gt;begin(), this-&gt;end());
    }
};

bool operator&lt;(const Polytet &amp;_a, const Polytet &amp;_b)
// implicitly assume a.size()==b.size()
{
    NormalizedPolytet a(_a), b(_b);
    for (auto ta=a.cbegin(), tb=b.cbegin(); ta!=a.cend(); ++ta,++tb)
    {
        auto result = *ta &lt;=&gt; *tb;
        if (result != 0)
            return result &lt; 0;
    }
    return false;
}
bool operator&gt;(const Polytet &amp;a, const Polytet &amp;b)
{
    return !(a &lt; b);
}
bool operator==(const Polytet &amp;_a, const Polytet &amp;_b)
// implicitly assume a.size()==b.size()
{
    NormalizedPolytet a(_a), b(_b);
    for (auto ta=a.cbegin(), tb=b.cbegin(); ta!=a.cend(); ++ta,++tb)
    {
        auto result = *ta &lt;=&gt; *tb;
        if (result != 0)
            return false;
    }
    return true;
}

#ifdef USE_GMP
void verifyTetrahedron(mpz_t t[4][3], const mpz_t mpz_power9_8, mpz_t edge[3])
{
    for (int edgeNum=0; edgeNum&lt;6; edgeNum++)
    {
        auto p0 = t[tetrahedronEdges[edgeNum][0]];
        auto p1 = t[tetrahedronEdges[edgeNum][1]];
        for (int d=0; d&lt;3; d++)
        {
            mpz_sub(edge[d], p1[d], p0[d]);
            mpz_mul(edge[d], edge[d], edge[d]);
        }
        for (int d=1; d&lt;3; d++)
            mpz_add(edge[0], edge[0], edge[d]);
        if (mpz_cmp(edge[0], mpz_power9_8) != 0)
            quitOverflow();
    }
}
#else
void verifyTetrahedron(const Tet &amp;t, Coord power9_2)
{
    Coord targetDistSquared = power9_2 * 4;
    for (int edgeNum=0; edgeNum&lt;6; edgeNum++)
    {
        Coord3 p0 = t.t[tetrahedronEdges[edgeNum][0]];
        Coord3 p1 = t.t[tetrahedronEdges[edgeNum][1]];
        Coord3 diff = p1 - p0;
        Coord distSquared = 0;
        for (int d=0; d&lt;3; d++)
            distSquared += diff[d] * diff[d];
        if (distSquared != targetDistSquared)
            quitOverflow();
    }
}
#endif

namespace std
{
    template&lt;&gt;
    struct hash&lt;Polytet&gt;
    {
        std::size_t operator()(const Polytet &amp;_polytet) const noexcept
        {
            NormalizedPolytet polytet(_polytet);
            std::size_t seed = polytet.size();
            for (auto t=polytet.cbegin(); t!=polytet.cend(); ++t)
            {
                for (auto c=t-&gt;cbegin(); c!=t-&gt;cend(); ++c)
                {
                    for (auto i=c-&gt;cbegin(); i!=c-&gt;cend(); ++i)
                    {
                        seed ^= std::hash&lt;uint64_t&gt;{}((uint64_t)(*i      )) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2);
                        seed ^= std::hash&lt;uint64_t&gt;{}((uint64_t)(*i &gt;&gt; 64)) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2);
                    }
                }
            }
            return seed;
        }
    };
};

int main(int argc, char *argv[])
{
    static const Tetrahedron start =
    {{
        {{-1,-1,-1}},
        {{-1, 1, 1}},
        {{ 1,-1, 1}},
        {{ 1, 1,-1}}
    }};
    Polytet startPolytet;
    startPolytet.emplace_back(start);

#ifdef USE_GMP
    mpz_t mpz_power3, mpz_power9_2, mpz_power9_8;
    mpz_init(mpz_power3  ); mpz_set_ui(mpz_power3  , 1);
    mpz_init(mpz_power9_2); mpz_set_ui(mpz_power9_2, 2);
    mpz_init(mpz_power9_8); mpz_set_ui(mpz_power9_8, 8);
    mpz_t
        x , y , z ,
        x0, y0, z0,
        x1, y1, z1,
        x2, y2, z2,
        x3, y3, z3,
        xx_numerator_mpz, xx_denominator_mpz,
        xy_numerator_mpz, xy_denominator_mpz,
        xz_numerator_mpz, xz_denominator_mpz,
        yx_numerator_mpz, yx_denominator_mpz,
        yy_numerator_mpz, yy_denominator_mpz,
        yz_numerator_mpz, yz_denominator_mpz,
        zx_numerator_mpz, zx_denominator_mpz,
        zy_numerator_mpz, zy_denominator_mpz,
        zz_numerator_mpz, zz_denominator_mpz;
    mpz_t nt_mpz[4][3];
    mpz_t edge[3]; // scratch for verifyTetrahedron()
    mpz_inits(
        x , y , z ,
        x0, y0, z0,
        x1, y1, z1,
        x2, y2, z2,
        x3, y3, z3,
        xx_numerator_mpz, xx_denominator_mpz,
        xy_numerator_mpz, xy_denominator_mpz,
        xz_numerator_mpz, xz_denominator_mpz,
        yx_numerator_mpz, yx_denominator_mpz,
        yy_numerator_mpz, yy_denominator_mpz,
        yz_numerator_mpz, yz_denominator_mpz,
        zx_numerator_mpz, zx_denominator_mpz,
        zy_numerator_mpz, zy_denominator_mpz,
        zz_numerator_mpz, zz_denominator_mpz, NULL);
    for (int p=0; p&lt;4; p++)
        for (int d=0; d&lt;3; d++)
            mpz_init(nt_mpz[p][d]);
    for (int d=0; d&lt;3; d++)
        mpz_init(edge[d]);
#endif
    TetrahedronOverlap overlap;
    Coord power3   = 1;
    Coord power9_2 = 2;
    auto *polytets = new std::unordered_set&lt;Polytet&gt;;
    polytets-&gt;insert(startPolytet);
    size_t prevPolytetCount = 0;
    for (int tetCount=1;;)
    {
        auto currentTime = std::chrono::steady_clock::now();
        size_t polytetCount = polytets-&gt;size();
        std::cout &lt;&lt; tetCount &lt;&lt; ": " &lt;&lt; polytetCount &lt;&lt; " [" &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(currentTime - startTime).count() &lt;&lt; " ms]" &lt;&lt; std::endl;
        if (prevPolytetCount &gt; polytetCount)
        {
            std::cerr &lt;&lt; "Quit due to apparent overflow" &lt;&lt; std::endl;
            break;
        }
        prevPolytetCount = polytetCount;
        ++tetCount;
#ifdef DEBUG_PRINT
        if (tetCount &gt; 6)
            break;
#endif
#ifdef USE_GMP
        mpz_mul_ui(mpz_power3  , mpz_power3  , 3);
        mpz_mul_ui(mpz_power9_2, mpz_power9_2, 9);
        mpz_mul_ui(mpz_power9_8, mpz_power9_8, 9);
#endif
        power3   *= 3;
        power9_2 *= 9;
        auto *newPolytets = new std::unordered_set&lt;Polytet&gt;;
        for (auto basePolytet=polytets-&gt;cbegin(); basePolytet!=polytets-&gt;cend(); ++basePolytet)
        {
            for (auto tetToAttachTo=basePolytet-&gt;cbegin(); tetToAttachTo!=basePolytet-&gt;cend(); ++tetToAttachTo)
            {
                for (int faceNum=0; faceNum&lt;4; faceNum++)
                {
                    if (!tetToAttachTo-&gt;faceAttached[faceNum])
                    {
                        Polytet newPolytet;
                        newPolytet.reserve(tetCount);
                        Tet *tetCopyToAttachTo; // take note of this just for speed
                        for (auto tetToCopy=basePolytet-&gt;cbegin(); tetToCopy!=basePolytet-&gt;cend(); ++tetToCopy)
                        {
                            Tet &amp;t = newPolytet.emplace_back();
                            for (int p=0; p&lt;4; p++)
                            for (int d=0; d&lt;3; d++)
                                t.t[p][d] = tetToCopy-&gt;t[p][d] * 3;
                            memcpy(t.faceAttached, tetToCopy-&gt;faceAttached, sizeof(t.faceAttached));
                            if (tetToCopy == tetToAttachTo)
                            {
                                t.faceAttached[faceNum] = true;
                                tetCopyToAttachTo = &amp;t;
                            }
                        }
                        Tet &amp;t = newPolytet.emplace_back();
                        attachNewTet(t, *tetToAttachTo, faceNum);
                        // Check for overlap between this newly attached tetrahedron and the existing ones
                        overlap.setA(t.t);
                        for (auto tetCheckIntersection=newPolytet.cbegin(); tetCheckIntersection!=newPolytet.cend(); ++tetCheckIntersection)
                        {
                            if (&amp;*tetCheckIntersection == tetCopyToAttachTo || &amp;*tetCheckIntersection == &amp;t)
                                continue; // skip this check for speed (it'll always be false anyway)
                            overlap.setB(tetCheckIntersection-&gt;t);
                            if (overlap())
                                goto discardThisNewPolytet;
                        }
                        // Canonicalize the rotation of this new polytet, so that it can be compared against others
                        bool haveRunningLeast = false;
                        Polytet runningLeastPolytet;
                        for (auto tetToRotateNormalize=newPolytet.cbegin(); tetToRotateNormalize!=newPolytet.cend(); ++tetToRotateNormalize)
                        {
                            // only rotate-normalize to tetrahedrons with exactly 1 attached face; every polytet is guaranteed to have some
                            int faceToRotateNormalize;
                            {
                                int attachCount = 0;
                                for (int i=0; i&lt;4; i++)
                                    if (tetToRotateNormalize-&gt;faceAttached[i])
                                    {
                                        faceToRotateNormalize = i;
                                        if (++attachCount &gt; 1)
                                            break;
                                    }
                                if (attachCount &gt; 1)
                                    continue;
                            }
                            Tetrahedron n;
                            for (int i=0; i&lt;4; i++)
                                n[i] = tetToRotateNormalize-&gt;t[tetrahedronFaces[faceToRotateNormalize][i]];
                            for (int faceRotation=0; faceRotation&lt;3; faceRotation++)
                            {
                                // Solve for an affine transformation that rotates and translates the polytet so that "tetToRotateNormalize" goes into the same position as the first face of the "start" tetrahedron
                                Coord xx_numerator =   ( n[2][1] - n[3][1])*(n[0][2] - n[1][2])  - (n[0][1] - n[1][1])*(n[2][2] - n[3][2]) ; Coord xx_denominator = (-(n[1][0]*n[2][1]*n[0][2]) + n[1][0]*n[3][1]*n[0][2] + n[0][0]*n[2][1]*n[1][2] - n[0][0]*n[3][1]*n[1][2] + n[1][0]*n[0][1]*n[2][2] - n[0][0]*n[1][1]*n[2][2] + n[0][0]*n[3][1]*n[2][2] - n[1][0]*n[3][1]*n[2][2] + n[3][0]*(-(n[1][1]*n[0][2]) + n[2][1]*n[0][2] + n[0][1]*n[1][2] - n[2][1]*n[1][2] - n[0][1]*n[2][2] + n[1][1]*n[2][2]) + (-(n[1][0]*n[0][1]) + n[0][0]*n[1][1] - n[0][0]*n[2][1] + n[1][0]*n[2][1])*n[3][2] + n[2][0]*(-(n[3][1]*n[0][2]) - n[0][1]*n[1][2] + n[3][1]*n[1][2] + n[1][1]*(n[0][2] - n[3][2]) + n[0][1]*n[3][2]));
                                Coord xy_numerator = (-((n[2][0] - n[3][0])*(n[0][2] - n[1][2])) + (n[0][0] - n[1][0])*(n[2][2] - n[3][2])); Coord xy_denominator = (-(n[1][0]*n[2][1]*n[0][2]) + n[1][0]*n[3][1]*n[0][2] + n[0][0]*n[2][1]*n[1][2] - n[0][0]*n[3][1]*n[1][2] + n[1][0]*n[0][1]*n[2][2] - n[0][0]*n[1][1]*n[2][2] + n[0][0]*n[3][1]*n[2][2] - n[1][0]*n[3][1]*n[2][2] + n[3][0]*(-(n[1][1]*n[0][2]) + n[2][1]*n[0][2] + n[0][1]*n[1][2] - n[2][1]*n[1][2] - n[0][1]*n[2][2] + n[1][1]*n[2][2]) + (-(n[1][0]*n[0][1]) + n[0][0]*n[1][1] - n[0][0]*n[2][1] + n[1][0]*n[2][1])*n[3][2] + n[2][0]*(-(n[3][1]*n[0][2]) - n[0][1]*n[1][2] + n[3][1]*n[1][2] + n[1][1]*(n[0][2] - n[3][2]) + n[0][1]*n[3][2]));
                                Coord xz_numerator =   ( n[2][0] - n[3][0])*(n[0][1] - n[1][1])  - (n[0][0] - n[1][0])*(n[2][1] - n[3][1]) ; Coord xz_denominator = (-(n[1][0]*n[2][1]*n[0][2]) + n[1][0]*n[3][1]*n[0][2] + n[0][0]*n[2][1]*n[1][2] - n[0][0]*n[3][1]*n[1][2] + n[1][0]*n[0][1]*n[2][2] - n[0][0]*n[1][1]*n[2][2] + n[0][0]*n[3][1]*n[2][2] - n[1][0]*n[3][1]*n[2][2] + n[3][0]*(-(n[1][1]*n[0][2]) + n[2][1]*n[0][2] + n[0][1]*n[1][2] - n[2][1]*n[1][2] - n[0][1]*n[2][2] + n[1][1]*n[2][2]) + (-(n[1][0]*n[0][1]) + n[0][0]*n[1][1] - n[0][0]*n[2][1] + n[1][0]*n[2][1])*n[3][2] + n[2][0]*(-(n[3][1]*n[0][2]) - n[0][1]*n[1][2] + n[3][1]*n[1][2] + n[1][1]*(n[0][2] - n[3][2]) + n[0][1]*n[3][2]));
                                Coord yx_numerator =  -((n[1][1] - n[3][1])*(n[0][2] - n[2][2])) + (n[0][1] - n[2][1])*(n[1][2] - n[3][2]) ; Coord yx_denominator = (-(n[1][0]*n[2][1]*n[0][2]) + n[1][0]*n[3][1]*n[0][2] + n[0][0]*n[2][1]*n[1][2] - n[0][0]*n[3][1]*n[1][2] + n[1][0]*n[0][1]*n[2][2] - n[0][0]*n[1][1]*n[2][2] + n[0][0]*n[3][1]*n[2][2] - n[1][0]*n[3][1]*n[2][2] + n[3][0]*(-(n[1][1]*n[0][2]) + n[2][1]*n[0][2] + n[0][1]*n[1][2] - n[2][1]*n[1][2] - n[0][1]*n[2][2] + n[1][1]*n[2][2]) + (-(n[1][0]*n[0][1]) + n[0][0]*n[1][1] - n[0][0]*n[2][1] + n[1][0]*n[2][1])*n[3][2] + n[2][0]*(-(n[3][1]*n[0][2]) - n[0][1]*n[1][2] + n[3][1]*n[1][2] + n[1][1]*(n[0][2] - n[3][2]) + n[0][1]*n[3][2]));
                                Coord yy_numerator =   ( n[1][0] - n[3][0])*(n[0][2] - n[2][2])  - (n[0][0] - n[2][0])*(n[1][2] - n[3][2]) ; Coord yy_denominator = (-(n[1][0]*n[2][1]*n[0][2]) + n[1][0]*n[3][1]*n[0][2] + n[0][0]*n[2][1]*n[1][2] - n[0][0]*n[3][1]*n[1][2] + n[1][0]*n[0][1]*n[2][2] - n[0][0]*n[1][1]*n[2][2] + n[0][0]*n[3][1]*n[2][2] - n[1][0]*n[3][1]*n[2][2] + n[3][0]*(-(n[1][1]*n[0][2]) + n[2][1]*n[0][2] + n[0][1]*n[1][2] - n[2][1]*n[1][2] - n[0][1]*n[2][2] + n[1][1]*n[2][2]) + (-(n[1][0]*n[0][1]) + n[0][0]*n[1][1] - n[0][0]*n[2][1] + n[1][0]*n[2][1])*n[3][2] + n[2][0]*(-(n[3][1]*n[0][2]) - n[0][1]*n[1][2] + n[3][1]*n[1][2] + n[1][1]*(n[0][2] - n[3][2]) + n[0][1]*n[3][2]));
                                Coord yz_numerator =  -((n[1][0] - n[3][0])*(n[0][1] - n[2][1])) + (n[0][0] - n[2][0])*(n[1][1] - n[3][1]) ; Coord yz_denominator = (-(n[1][0]*n[2][1]*n[0][2]) + n[1][0]*n[3][1]*n[0][2] + n[0][0]*n[2][1]*n[1][2] - n[0][0]*n[3][1]*n[1][2] + n[1][0]*n[0][1]*n[2][2] - n[0][0]*n[1][1]*n[2][2] + n[0][0]*n[3][1]*n[2][2] - n[1][0]*n[3][1]*n[2][2] + n[3][0]*(-(n[1][1]*n[0][2]) + n[2][1]*n[0][2] + n[0][1]*n[1][2] - n[2][1]*n[1][2] - n[0][1]*n[2][2] + n[1][1]*n[2][2]) + (-(n[1][0]*n[0][1]) + n[0][0]*n[1][1] - n[0][0]*n[2][1] + n[1][0]*n[2][1])*n[3][2] + n[2][0]*(-(n[3][1]*n[0][2]) - n[0][1]*n[1][2] + n[3][1]*n[1][2] + n[1][1]*(n[0][2] - n[3][2]) + n[0][1]*n[3][2]));
                                Coord zx_numerator =  -((n[0][1] - n[3][1])*(n[1][2] - n[2][2])) + (n[1][1] - n[2][1])*(n[0][2] - n[3][2]) ; Coord zx_denominator = (-(n[1][0]*n[2][1]*n[0][2]) + n[1][0]*n[3][1]*n[0][2] + n[0][0]*n[2][1]*n[1][2] - n[0][0]*n[3][1]*n[1][2] + n[1][0]*n[0][1]*n[2][2] - n[0][0]*n[1][1]*n[2][2] + n[0][0]*n[3][1]*n[2][2] - n[1][0]*n[3][1]*n[2][2] + n[3][0]*(-(n[1][1]*n[0][2]) + n[2][1]*n[0][2] + n[0][1]*n[1][2] - n[2][1]*n[1][2] - n[0][1]*n[2][2] + n[1][1]*n[2][2]) + (-(n[1][0]*n[0][1]) + n[0][0]*n[1][1] - n[0][0]*n[2][1] + n[1][0]*n[2][1])*n[3][2] + n[2][0]*(-(n[3][1]*n[0][2]) - n[0][1]*n[1][2] + n[3][1]*n[1][2] + n[1][1]*(n[0][2] - n[3][2]) + n[0][1]*n[3][2]));
                                Coord zy_numerator =   ( n[0][0] - n[3][0])*(n[1][2] - n[2][2])  - (n[1][0] - n[2][0])*(n[0][2] - n[3][2]) ; Coord zy_denominator = (-(n[1][0]*n[2][1]*n[0][2]) + n[1][0]*n[3][1]*n[0][2] + n[0][0]*n[2][1]*n[1][2] - n[0][0]*n[3][1]*n[1][2] + n[1][0]*n[0][1]*n[2][2] - n[0][0]*n[1][1]*n[2][2] + n[0][0]*n[3][1]*n[2][2] - n[1][0]*n[3][1]*n[2][2] + n[3][0]*(-(n[1][1]*n[0][2]) + n[2][1]*n[0][2] + n[0][1]*n[1][2] - n[2][1]*n[1][2] - n[0][1]*n[2][2] + n[1][1]*n[2][2]) + (-(n[1][0]*n[0][1]) + n[0][0]*n[1][1] - n[0][0]*n[2][1] + n[1][0]*n[2][1])*n[3][2] + n[2][0]*(-(n[3][1]*n[0][2]) - n[0][1]*n[1][2] + n[3][1]*n[1][2] + n[1][1]*(n[0][2] - n[3][2]) + n[0][1]*n[3][2]));
                                Coord zz_numerator =   ( n[0][0] - n[3][0])*(n[1][1] - n[2][1])  - (n[1][0] - n[2][0])*(n[0][1] - n[3][1]) ; Coord zz_denominator = ( n[1][0]*n[2][1]*n[0][2] - n[1][0]*n[3][1]*n[0][2] - n[0][0]*n[2][1]*n[1][2] + n[0][0]*n[3][1]*n[1][2] - n[1][0]*n[0][1]*n[2][2] + n[0][0]*n[1][1]*n[2][2] - n[0][0]*n[3][1]*n[2][2] + n[1][0]*n[3][1]*n[2][2] + n[3][0]*(n[1][1]*n[0][2] - n[2][1]*n[0][2] - n[0][1]*n[1][2] + n[2][1]*n[1][2] + n[0][1]*n[2][2] - n[1][1]*n[2][2]) + n[1][0]*n[0][1]*n[3][2] - n[0][0]*n[1][1]*n[3][2] + n[0][0]*n[2][1]*n[3][2] - n[1][0]*n[2][1]*n[3][2] + n[2][0]*(n[3][1]*n[0][2] + n[0][1]*n[1][2] - n[3][1]*n[1][2] - n[0][1]*n[3][2] + n[1][1]*(-n[0][2] + n[3][2])));
                                Coord x0_ = ( n[1][0]*n[2][1]*n[0][2] - n[1][0]*n[3][1]*n[0][2] - n[0][0]*n[2][1]*n[1][2] + n[0][0]*n[3][1]*n[1][2] - n[1][0]*n[0][1]*n[2][2] + n[0][0]*n[1][1]*n[2][2] + n[0][0]*n[3][1]*n[2][2] - n[1][0]*n[3][1]*n[2][2] + n[3][0]*(n[2][1]*(n[0][2] - n[1][2]) + n[1][1]*(n[0][2] + n[2][2]) - n[0][1]*(n[1][2] + n[2][2])) + n[1][0]*(n[0][1] + n[2][1])*n[3][2] - n[0][0]*(n[1][1] + n[2][1])*n[3][2] + n[2][0]*(n[3][1]*(-n[0][2] + n[1][2]) - n[1][1]*(n[0][2] + n[3][2]) + n[0][1]*(n[1][2] + n[3][2])));
                                Coord y0_ = ( n[1][0]*n[2][1]*n[0][2] + n[1][0]*n[3][1]*n[0][2] - n[0][0]*n[2][1]*n[1][2] - n[0][0]*n[3][1]*n[1][2] - n[3][0]*((n[1][1] + n[2][1])*n[0][2] + (-n[0][1] + n[2][1])*n[1][2]) - n[1][0]*n[0][1]*n[2][2] + n[0][0]*n[1][1]*n[2][2] + n[3][0]*(n[0][1] + n[1][1])*n[2][2] - n[0][0]*n[3][1]*n[2][2] - n[1][0]*n[3][1]*n[2][2] + (-(n[1][0]*n[0][1]) + n[0][0]*n[1][1] + (n[0][0] + n[1][0])*n[2][1])*n[3][2] + n[2][0]*(n[3][1]*(n[0][2] + n[1][2]) + n[0][1]*(n[1][2] - n[3][2]) - n[1][1]*(n[0][2] + n[3][2])));
                                Coord z0_ = (-n[1][0]*n[2][1]*n[0][2] - n[1][0]*n[3][1]*n[0][2] + n[0][0]*n[2][1]*n[1][2] + n[0][0]*n[3][1]*n[1][2] - n[3][0]*n[2][1]*(n[0][2] + n[1][2]) + n[1][0]*n[0][1]*n[2][2] - n[0][0]*n[1][1]*n[2][2] - n[0][0]*n[3][1]*n[2][2] - n[1][0]*n[3][1]*n[2][2] + n[3][0]*n[1][1]*(n[0][2] + n[2][2]) + n[3][0]*n[0][1]*(-n[1][2] + n[2][2]) + n[1][0]*(n[0][1] + n[2][1])*n[3][2] + n[0][0]*(-n[1][1] + n[2][1])*n[3][2] + n[2][0]*(n[3][1]*(n[0][2] + n[1][2]) + n[1][1]*(n[0][2] - n[3][2]) - n[0][1]*(n[1][2] + n[3][2])));
#ifdef USE_GMP
                                mpz_set_int128(xx_numerator_mpz, xx_numerator); mpz_set_int128(xx_denominator_mpz, xx_denominator);
                                mpz_set_int128(xy_numerator_mpz, xy_numerator); mpz_set_int128(xy_denominator_mpz, xy_denominator);
                                mpz_set_int128(xz_numerator_mpz, xz_numerator); mpz_set_int128(xz_denominator_mpz, xz_denominator);
                                mpz_set_int128(yx_numerator_mpz, yx_numerator); mpz_set_int128(yx_denominator_mpz, yx_denominator);
                                mpz_set_int128(yy_numerator_mpz, yy_numerator); mpz_set_int128(yy_denominator_mpz, yy_denominator);
                                mpz_set_int128(yz_numerator_mpz, yz_numerator); mpz_set_int128(yz_denominator_mpz, yz_denominator);
                                mpz_set_int128(zx_numerator_mpz, zx_numerator); mpz_set_int128(zx_denominator_mpz, zx_denominator);
                                mpz_set_int128(zy_numerator_mpz, zy_numerator); mpz_set_int128(zy_denominator_mpz, zy_denominator);
                                mpz_set_int128(zz_numerator_mpz, zz_numerator); mpz_set_int128(zz_denominator_mpz, zz_denominator);
                                mpz_set_int128(x0, x0_);
                                mpz_set_int128(y0, y0_);
                                mpz_set_int128(z0, z0_);
#endif
                                // Apply the affine transformation to the polytet
                                Polytet newRotatedPolytet;
                                newRotatedPolytet.reserve(tetCount);
                                for (auto tetToRotate=newPolytet.cbegin(); tetToRotate!=newPolytet.cend(); ++tetToRotate)
                                {
                                    Tet &amp;nt = newRotatedPolytet.emplace_back();
                                    for (int vertexNum=0; vertexNum&lt;4; vertexNum++)
                                    {
#ifdef USE_GMP
                                        mpz_set_int128(x1, tetToRotate-&gt;t[vertexNum][0]);
                                        mpz_set_int128(y1, tetToRotate-&gt;t[vertexNum][1]);
                                        mpz_set_int128(z1, tetToRotate-&gt;t[vertexNum][2]);

                                        mpz_set(x, x0); mpz_mul(x, x, mpz_power3); mpz_div(x, x, zz_denominator_mpz);
                                        mpz_set(y, y0); mpz_mul(y, y, mpz_power3); mpz_div(y, y, zz_denominator_mpz);
                                        mpz_set(z, z0); mpz_mul(z, z, mpz_power3); mpz_div(z, z, zz_denominator_mpz);

                                        mpz_set(x2, x1); mpz_mul(x2, x2, xx_numerator_mpz); mpz_mul(x2, x2, mpz_power9_2); mpz_div(x2, x2, xx_denominator_mpz);
                                        mpz_set(x3, y1); mpz_mul(x3, x3, xy_numerator_mpz); mpz_mul(x3, x3, mpz_power9_2); mpz_div(x3, x3, xy_denominator_mpz); mpz_add(x2, x2, x3);
                                        mpz_set(x3, z1); mpz_mul(x3, x3, xz_numerator_mpz); mpz_mul(x3, x3, mpz_power9_2); mpz_div(x3, x3, xz_denominator_mpz); mpz_add(x2, x2, x3); mpz_div(x2, x2, mpz_power3); mpz_add(x, x, x2);
                                        mpz_set(y2, x1); mpz_mul(y2, y2, yx_numerator_mpz); mpz_mul(y2, y2, mpz_power9_2); mpz_div(y2, y2, yx_denominator_mpz);
                                        mpz_set(y3, y1); mpz_mul(y3, y3, yy_numerator_mpz); mpz_mul(y3, y3, mpz_power9_2); mpz_div(y3, y3, yy_denominator_mpz); mpz_add(y2, y2, y3);
                                        mpz_set(y3, z1); mpz_mul(y3, y3, yz_numerator_mpz); mpz_mul(y3, y3, mpz_power9_2); mpz_div(y3, y3, yz_denominator_mpz); mpz_add(y2, y2, y3); mpz_div(y2, y2, mpz_power3); mpz_add(y, y, y2);
                                        mpz_set(z2, x1); mpz_mul(z2, z2, zx_numerator_mpz); mpz_mul(z2, z2, mpz_power9_2); mpz_div(z2, z2, zx_denominator_mpz);
                                        mpz_set(z3, y1); mpz_mul(z3, z3, zy_numerator_mpz); mpz_mul(z3, z3, mpz_power9_2); mpz_div(z3, z3, zy_denominator_mpz); mpz_add(z2, z2, z3);
                                        mpz_set(z3, z1); mpz_mul(z3, z3, zz_numerator_mpz); mpz_mul(z3, z3, mpz_power9_2); mpz_div(z3, z3, zz_denominator_mpz); mpz_add(z2, z2, z3); mpz_div(z2, z2, mpz_power3); mpz_add(z, z, z2);

                                        mpz_get_int128(nt.t[vertexNum][0], x);
                                        mpz_get_int128(nt.t[vertexNum][1], y);
                                        mpz_get_int128(nt.t[vertexNum][2], z);

                                        mpz_set(nt_mpz[vertexNum][0], x);
                                        mpz_set(nt_mpz[vertexNum][1], y);
                                        mpz_set(nt_mpz[vertexNum][2], z);
#else
                                        nt.t[vertexNum][0] = x0_*power3/zz_denominator + (tetToRotate-&gt;t[vertexNum][0]*xx_numerator*power9_2/xx_denominator + tetToRotate-&gt;t[vertexNum][1]*xy_numerator*power9_2/xy_denominator + tetToRotate-&gt;t[vertexNum][2]*xz_numerator*power9_2/xz_denominator)/power3;
                                        nt.t[vertexNum][1] = y0_*power3/zz_denominator + (tetToRotate-&gt;t[vertexNum][0]*yx_numerator*power9_2/yx_denominator + tetToRotate-&gt;t[vertexNum][1]*yy_numerator*power9_2/yy_denominator + tetToRotate-&gt;t[vertexNum][2]*yz_numerator*power9_2/yz_denominator)/power3;
                                        nt.t[vertexNum][2] = z0_*power3/zz_denominator + (tetToRotate-&gt;t[vertexNum][0]*zx_numerator*power9_2/zx_denominator + tetToRotate-&gt;t[vertexNum][1]*zy_numerator*power9_2/zy_denominator + tetToRotate-&gt;t[vertexNum][2]*zz_numerator*power9_2/zz_denominator)/power3;
#endif
                                    }
#ifdef USE_GMP
                                    verifyTetrahedron(nt_mpz, mpz_power9_8, edge);
#else
                                    verifyTetrahedron(nt, power9_2);
#endif
                                    memcpy(nt.faceAttached, tetToRotate-&gt;faceAttached, sizeof(nt.faceAttached));
                                }
                                // Update the running "least" rotation
                                if (!haveRunningLeast ||
                                    runningLeastPolytet &gt; newRotatedPolytet)
                                {
                                    haveRunningLeast = true;
                                    runningLeastPolytet = newRotatedPolytet;
                                }
                                // Switch to the next rotation of this face
                                Coord3 tmpFace = n[2];
                                n[2] = n[1];
                                n[1] = n[0];
                                n[0] = tmpFace;
                            }
                        }
                        newPolytets-&gt;insert(runningLeastPolytet);
                    }
                discardThisNewPolytet:;
                }
            }
        }
#ifdef DEBUG_PRINT
        for (auto thisPolytet=newPolytets-&gt;cbegin(); thisPolytet!=newPolytets-&gt;cend(); ++thisPolytet)
        {
            bool first = true;
            for (auto thisTet=thisPolytet-&gt;cbegin(); thisTet!=thisPolytet-&gt;cend(); ++thisTet)
            {
                printf(first ? "\n{" : ",\n");
                first = false;
                printf("{{%" PRId64 ", %" PRId64 ", %" PRId64 "}, {%" PRId64 ", %" PRId64 ", %" PRId64 "}, {%" PRId64 ", %" PRId64 ", %" PRId64 "}, {%" PRId64 ", %" PRId64 ", %" PRId64 "}}",
                    (int64_t)thisTet-&gt;t[0][0], (int64_t)thisTet-&gt;t[0][1], (int64_t)thisTet-&gt;t[0][2],
                    (int64_t)thisTet-&gt;t[1][0], (int64_t)thisTet-&gt;t[1][1], (int64_t)thisTet-&gt;t[1][2],
                    (int64_t)thisTet-&gt;t[2][0], (int64_t)thisTet-&gt;t[2][1], (int64_t)thisTet-&gt;t[2][2],
                    (int64_t)thisTet-&gt;t[3][0], (int64_t)thisTet-&gt;t[3][1], (int64_t)thisTet-&gt;t[3][2]);
            }
            printf("}\n");
        }
#endif
        delete polytets;
        polytets = newPolytets;
    }
    delete polytets;
#ifdef USE_GMP
    mpz_clears(
        mpz_power3, mpz_power9_2, mpz_power9_8,
        x , y , z ,
        x0, y0, z0,
        x1, y1, z1,
        x2, y2, z2,
        x3, y3, z3,
        xx_numerator_mpz, xx_denominator_mpz,
        xy_numerator_mpz, xy_denominator_mpz,
        xz_numerator_mpz, xz_denominator_mpz,
        yx_numerator_mpz, yx_denominator_mpz,
        yy_numerator_mpz, yy_denominator_mpz,
        yz_numerator_mpz, yz_denominator_mpz,
        zx_numerator_mpz, zx_denominator_mpz,
        zy_numerator_mpz, zy_denominator_mpz,
        zz_numerator_mpz, zz_denominator_mpz, NULL);
    for (int p=0; p&lt;4; p++)
        for (int d=0; d&lt;3; d++)
            mpz_clear(nt_mpz[p][d]);
    for (int d=0; d&lt;3; d++)
        mpz_clear(edge[d]);
#endif
&#9;return 0;
}

</code></pre>
<p><a href="https://ato.pxeger.com/run?1=7T1dc9tIcs_RrxhpK16SIiWCdPlsSdTVendva6v2fM7aTqXKp6hAEJJwpgAeAEoiZeaPpCp1L_eYt_yZ5Neke74wnyBIyfFdRShbIme6e3q6e3p6GjOjf__PaDadF_j__DKK_uvjXq8oJ6Nof3_Q3-vu9f4w2Dv7y1_n5UXv5f_8x39_k6TRdD6JyQkAJdnB1elOVZRkRZnH4bVaBiVJeqnDRYiblloRfC8Xs7hQC8M8DxdawfQyy5PySmvhJo7KLFdLpkmhEb-Yp1GZZGk4VUvnaZZP4jyenBexzstVnqXZ6c7O4eE3k_giSWPy4d2P5z_9_q1S8sOPrz_8dP7215_fvN8B3AsollAVqcvrGe06ISS5IFB3_ubD71-fv_75_TuyOyIvntOqOM-znLy_SgoC_67CfNKLskk8IRdQ_OJ5b5yUZJpcjwsGnU6Si51v2K-dcF5mpCjDvHyfXMdkBJ8nR0esC0dHRRmHk8V5NM2iT0dHaXbbah_v7NxkyYT8eZ6Uf7iJ84splu7c7wBpQqlF8zyP0-b0EJFBQUfIyQnZ-yegXYLayWQeE6A4iUtQEnQo4w3uUTDykf7WWpjM8xB1dR6FRXmiVV0nU9BsHGXppDhtqVz2Kgm0D6JsnpatNmvhujir2gCRTRm78V1StnoBML_a2UG7Q_Wdn4MRBoOX5PsMLONYllNcaosntKZLhqcMZugHGnbJ81PyPi7z8CqeQAeOd6JpWBRYxIVN1ZCkSfm7MIoL0AEWsip8LqD0u7IMI8D_2D8DVVyE0yI-JoeHpISCbvkxwB-DMzdK4EcZelAGTpRBHcrQRAlMlNXObD6eJtER_aZIhJRMGeMsm-pEn58dC-AWcTxtckSgpk3uFfEdryQOmEhRak09KxlOaeGsDB0yd3ICyKfkbTZdlDGwCQOfgOmW8R0obJIALskuKM8FuQWHRJIJ2GIShVMSXSV5OE3KxQ7YJBQBQknKihXaMvQQ_pERt4T7fpcMuiQAy1p1ZQl-hXKlZMjARElAv0JhH0qgH54Wf5xcQosvzqh6lRY1OuLzgFGTLSowQwVmyFtktk6yWQzDNst7XPS8-FkoHAsviJheI2bPvRB-i5KAlwSyZMBLBrwkj8t5niKNldnuvtlul-gF41pGkA-yT8YmO8gNLTeYQp5oeQPWLJFswVrPw1rPw1qvGWudWtZIA8Y6ZGxzpRRWLMlClR-YN1N14mTtTrKyscw4NWSmM2ZaRB46Y6Y5bLrDZLGSU6YxW1M3fD1bYhjAZ4AWfi3Js0lRipbl5PCsyCPRuiwMxwUU42wJP09In_yW9PDjERawfiPJ5HqW5WWLkoVB1INB9RLGG_33jNHg8ylECy1Oqy0dL5JI40uGDz_o9CXZv6zYr5hVesD7pLAPlcByn8_gyTKGejp7spI5EHnx_JzHHlSIsifxHe0JrQHeKRbrENLJLloCuS36x_omO0cxyCkZVN3TIxIOSyeHpHgTX4Jru8GAhKrqMkXxtFE-HLAlm-y0sdttZqaMdzF41JYDc8LFSgYOtnNKILIDar__7l8qDgXUrsLQ589EQar6zdF_flNBAEMQ9PV1eq6ei3K7T0HVJzHwV5VQK7aqNpiSe_BLHQMyFhGTBDY_DWdgGcbwEBovcVqJc4i_yjfza-ZAulXZD3GaXScpK50rEDfK5_mNDlbVvZtfHytNRTHShQiiSyBKvw6n9GN5PaO_Z_1ZQD_I1iFgfJvBN1o6iadlSD_FMPMF8tMAPqmNhDgL60VjuwjWL2F6OY2hWNbQMQfuQpEfdxkgZkZCjDotCKFjTzc6DPFbOGHPRv1jMjt5Dj_293UTkTAThJmcDOGHCSMYVpwY8jI7-zg5o4OPfWwLm5HdQG_LXUMeF_Op4S9CpS9CRsMzsxdYcz2foskKIuiSu3TeUgwa4cLJBEAVuIDCBWvhBhRuUPXBE1dyU7YCauqBIfYrWl_YkrvkzYdfflG6s06B95oqBZ8tPgomqmQ0AD42_AA4Yvy1dBz5q-3R5YdlY85fz0Ziff1Ar181HiP3G4-We-fYoZyE2kBxgoydIKsGnA8fOLqZUoVHskf0vzUcBtE0DvO_h3FAGa0dCAyibiQwCO9QYNX-scDqGw4GBlwzGhhAzXCoAL76eGCs1A8IBvP1RgRXrn9IiLn6O1dW4K5N7o15HNYadyKXIHBfN8QdK7g0cBUrrVbbGoaHh-R9-Ckm4eQmTMvwMsaMQnkVY1YBoo6rsKTfyttMXcsXJMxjWPVczqdhTsJ0glPzZT6PMfyGryr5P82B5egqjj5hcBimCxoF0WaUfuyFe9WY59kMhMXkhgU73jtQW_ghS7_lSwaSlNhKlk4XlG-IM2c4TJBEmLKWq2YObHtACHAeqHH-8eSF_Oi3bjUy6cz6dLlp5T44lTMIRs6Oa9CDNeiBiS65R2lx7vlHHJX8Y7PRBgwwLwYLqIliVTwkRXlfJDlwOyRUsswUuMXEVPv023NQIBN9UlAGo3AagbnQhCwCsFYsHmRfEuxFgvwnrlGnwa4ZoeJxdyzBwQoifzb-aCXIuOjOAAihbOcD4vieTgugwyyf4AxEk3HTKRnHBCLHMplNk3hCxguQWJRdz0BcE8xGZ3lyCeBTFfHARf-nWKxERLYPiYUwr4aXKEwIJWlWEPOB36rUjlHOLoqT5CYpYAZhTGG-_1oyCbNoKXUk-I9oMpyC2yxuogW-Nqim0i7ptNxq6VMf6vD3iu8OfL57WwvhEb_KXwNWZ2tZXdO8PRQFM5hokVGFwoyjMYV_0Nv5PFERfawPKetdMnQQXH2B_hTzMcZApIHqcYVd31MkxiOmrguGPqLaR8zuJa5F7ZiUEJEFoCkAByUNTwtIBR4y60BEiUYgFJZVgk-oPDelvgsd00mI7szq4APzC4zpOXs5wibBgoAnCqfTeIrOiPnu26skuiK3MfSkmlHDAmfOjCdmfG2fuJquN2u3iF2lNSagEdIk5SptpH7skksPynqj3yYnIGzMqXHIxouYNjldryaX035_FRexNsvgxAsaNGYZV6NfYCBjUsS1GuGjtrH8BT2eZ_GR5KPYlvJmfosHFcNHDCqEMGTwn5zVOreEO7eG8sEAQwTPOCWrAqoCrCQtkgkLwwQfX8h5i0WlK-2JpVIMfc9yTSUmFqAKWkCjMfpsQWygExtsRMy2GyWhqKYemAwCmdDt-5alwBaaho3bl7iBD5e3e-PFDfy4vF0bN5C4Xp5Ff_WUimiwcZdd6Gt6bU2BBpEHzn2POXepGp3X-SIV6caZvVqDZKW2HjidzWunMYS4sSE2lawIo81EnDt_51GrmFktIpoI3NrDh7-ULXOTQ1dCiAOzLSQ8b_NNDF92eE-NvEsnBA8_PtaS_2tzPCGuMu-aZnXGKvRTHuf_JI_D3-zTDE6rE7Y3SeII3GA97hfL4KhG5Aw__rYSOL4IiUpw3K7Px9heQ-wQYcmSEbm_Zy_9-6sV7fem6Zi_62xMTWbbgm0Y6srsA9kfeXQ3c6fJuGYYzvZ5EnxkUoP4eKA5DdIBYfYqlj08OdebQBnX8mLV7ktSAPmZKyYxCCuzlUHY_YAD8RCmmyucZL_Syt_JzAbhlEf4PbvcHSR5ZNxzlTeNlRw8iSDJUQWLeedC7iuv7_l4s5ZoIByY2zpuwe2TlrA9FaRGB7wZZXNKzdhusPZW1tDe0Z2cefj_kmtn3lG6iCIjh1x76vLSKyi6DAJ8ZbXLAZrjD1T8wSb4SviNjogvCDtiQQc0xAKzI1ZpPko3NiWOFbAdoRr1oI6nG33sChoqW4JGDVs4cg1SW64IdSobODNNur35GtelSbB3swbalFJPK2jq2ua2S7vRi7YSWEViX6NnrNS-1CKNbiVciQMlId29_ya-xR348J88K5VNcPAtLt9nbIv_-0zUKJG3sdv4WRrf_jPbcg_D7qCULk4tV-NMWvk4ceKjxIZ1uzT0Tac0iYIxk5REvQ00CdqklHjQqEn_oFTDxZXo8-8wDAevzxYZ8S0_8rDTpE2zPe17z2pe6a2IGaUCv89mbO2ZwY9c6sop1KFbqAhA3b13GTM720yepZAZccgy0PvABFoe2Cd4qtFm1CqHdVzVg_pq5RAOHmhim3vfyEmcH2MhR4QlTcyDLkJEpzAC1bSKRYEnTAS9ZzP2wRR_DvFUfhO3ePUBbglvqW9pqcDpWTOoHgmwaBzDAG21j7F0tyoGP4OF-_uyKb05fPSzPjibwXAFEZ2Pw-hTCxB7p6UR11MhFLiLvTzgLXdBsLQ157YrBeEqKXqnFRL9qiLSY0U7WuroxBTeuTzVUBWN23jSiLqaKCmn4LaKAtw6CbkMR6Mx_8Sdpa3ksHUeAk_jFhA7rsYMk3Y4CqWYge8xkFOkHu5idSXusAs_xqZ2KSW2Kxfk3IGw7GR0Cr_HlczQqXEIe8M7n0t4_Yk4f8DkrE80K12Ep6YIbQmaB0N2W8AeGbctWqPRkz40fWhzu1LOXNbKfWwGfHNysbC3wRub4Fkh_pxlt3H-6vxll5dhXEn3k9_r7r1RFtGQAc0dlk0ThwwlWIOi5Qs3374q3o6xd6lB9ZbWsfETX95IWPND_T7QCe7Hcc9b4oUApSNeA1UfNMpq7l-CqVprO8zHdXZltSNy-B4rUcPCLl-P8EYGWhwIgyC_jMsfkqJ89-c5TRmOJCTMuM-PH2Q3atYZZ_iGtqMmnOvRAgcaRM0X2Au24jeqoVbtar-59eGjIkMQhi2xyIR_0nWtQoNiLVE3VTQ7UpSG13Exw3AbJkquw5JOw2V8ckq_FuBMopJchcXVCfePp4ZG2CTLzqIpb11MxywiD-5g0iy-i-JZ6RmKtlfm-C1JyBUbMC6KmBudGsw4XiIwj-6KZpyxzLoXChXNaATRS0Uu2qXfJaWo6TK5opiMIpVisku_S4qJe8XopkrFhSL6V35XANWuOLd2er-qDrG1W52EIbTbsGLt372Kh7_5zavxK0yAURonJ-RFW347xeOB7mX5pq0CqRfPH9yqvbjXS_RvfAJFoqb3hugQA0QczdchKAE_wOiLYMK8CnPSgc83H-WsyI91228r6a0HZMSGUKWe-_te0KX_VvzItizFQ-VGKaGwjlLCKDCG-fpajB_asjwez5mUJQda9E1r8Dyn92ShnGOG2nwz0GefY4lBj8FUSLhPTR5-mydaDfSi7UPEycaNSNse1CC-9CJCaPNSQaxc0h3wsoD_S1LJ-a4PZfB_2VfKQPIL-L8MlDJgZwH_lwOlDIS1gP_LoVJ2d56KNNA5NN_FkkmVCqJlFfTCgl7UQC8t6KUfemFxsqjhZGFxsqjhZGFxsqjhZGlxsqzhZGlxsqzhZGlxsrQ4UWyBpCWW2IdMeRhM3xUVEZCLrqi7tiOntmaSRevJvP6fm5d2yG7dybAmMWR1upQZq3qkah2-dp6TofHwEGvtw4niHeexEvELzw0xV2CVY9Q_IgNWTmOZDo-tCkKTjiwa0O52kqEmwxLwvdMkLeK8bKkzl7jOiIV-szy-4RXf0xezMiCXghBVsAI7dq5Kt7lNSWVBb75i3oxDGeVsXmI4IzHwEqQjQq9A0ih93euX8KGJb1O-pxqXvpW1fdmUuGgqnOG2EtytpF405Wgdn3Eeh59c62qH2lW2KhSakjTKsF9KfwJjucwbdYRCYvzwIyR6EKN_U8-MuFDM0Am-vVqL8rJrZGhe6aOXjR0-NjsjkeyWxXRBPiKvjBRLBwbl2w2HKD7VamUcFjGvH1X2Xy1flPpdFUCuZxSA2kOyIiNdJfdHCqrapAa0a0Cp-eoKqtF6b-ONaG5awg53NQ56p9pLA_EqZNPFnlgCVHr1L9EqmAPxUkAObj8W5oU6FG62qNhn94vhVss0K_kuy6RguyNReMUMFlpemoaCkXStchGgXrEI4d-x5Zef6CF9TaEISFsz1UhH9mbNrSFenIZ7zsRjvfnCjvdORWFHdQSu5zq-jmaLlv7KqquS0iv4BUI6vOuMn_pwr8so4uvUmrFnPvWqYiJwjhzthV4tvmnLuMG4ZtjgY-ca1tc8xKy01_dllw5A9X29eDftpyA3_aCl8cCOjOPyNo5TNlaBLXyHwuWobUkWm1_ju6Sg79az1LENVDyc-gHd8w0GWsOVNvApfz8re4hGiqQ0D2BB7mqgqiuwQLf1CmjEzzouityiDSP6_Jn4wZ-V64e2tkex-JTMmJoiqUXqU8FrlN9OpySc3oaLAk9X03dFuLscCupbURT1uuVi1X4v65JKJu4yWd-nywwvHE2KKMwneKXqmwbTlH9EoU2HaZbi1Y5iZ0SelWyvh5iCMKbhcQe4r4xt-oegNApTlJbc7Bxehgmm8Oi-Br9x0_eUV-FN_Os8TWEo_BKH9A4v5Q2d6xHzcq5gre25MS3-il2LZbrcOzosSP_osEC3HR2gCnoqgYo_7sk9iqQ0TlbQow_xXRjhC9ugcjfowY5JDKa0EOrCjT2X8zAPwSLZbnSUO-jw2t6JqD4iTrM6V2_K62camgimDBsLzrpnk43_VoNi4jQ6YgSLiSdM3LyHkmmX-HCH5_r-qrzv76vikrf6NX2MNWDd43cSKj9bcePf5tecAfW9QNowetzQXvgBEbe5lO4zIxak5wSJkz8k8Cv3tmI9JL5j_Kp-X9eB9ZYJDuZdNoXhj-2D6w4v6E3f0Km0uED2qdOnzp35oIJFLVg_pV9xdhCeRcwDey5x7cE0FeMGaPRdgFSE14hZJLSJkFFih4Xk-S0o2aN5lj3V3a3tFUueqZlbUCEhLdDm4IxtGaYHN4KzdqdFb4AYsLIAP7VxgzMrDmQxBx1I0CEDPa4am2ibZlu9FkXsn3V4qx3eEr52q6qGahWt6RtIgWyzb-AEEkdQ6_OagYUTaDX7DmoDVQyOmn3Wa6gRfTP7NHD1xeiDs1dGKxqv9C2lKkwK39a6EEhVacLTRDNgSuSaE_yK3gz13vQs3veJR-5QotnQsJKHoMCK1sR8iuEuNMMF_lqcV9FA3224VFRcBpUinYbbPq4aezLcJ8N9HMNduj2uy3A111p5XJfhag678rjLJ8N9MtzHMdyFESpQjxsYlqc3OjA8bqAIm4IGJn_HVWNPhvtkuI9juAuHxw1qQ4WBEeP2ZXF_neE-hQpPhvtYhrt0e9yaUIF1zopxNcN1hwqLp1DhyXAfyXCXrlChb1ie7ka1UCEw7NnJ33HV2JPhPhnu4xiuK1ToOzyuabg8VAgcHtdvuE-hwpPhPpbhurIKHsPVXGu94bpDhaUVKpgy66i9c5utJXlNSG6z7XnN1tKs06Bt41xrtobRavbYt-wxUO3E7pI9ZnSbtXs39A7KodXvgYVj6sQyY48vMURuK6FvEeRW3VMpcRtunhrrn_-NG9MDfaBgzvU-xeEa9qvppRJ6y7AyHjWJ1uW4lUbYdpiRdAQOKId56GoNKpYcDFu-TGN4U5NYrDEJ_7ToNwn_tNirVOWWkGiUC8Ss1iWzsWUNbQ0GgvQ6Z1Znf82mQmXJKKXarp0EpXk4rMOhf2Wmq7WdDWY9Zh29zR2GP2iqdxhDDcfX8U1Dq-3UWnHj9xsqVF-OZdOBNPQflWg4keYOxC8oTyzkcXiVhXh2yvsecSgvYX8Dz3liSZYoh_gqeOt8jV7WwGhNmq5zUHU82CeCjDeTW_DgOl1Vx4PjnJFetjkPzjNbNTw4TnQZ7wu24MF1EqyOB4cuFg_UhfN8WR0PDl0sHqgL56m1Gh4cZ9qMhMwWPLjOwtXx4NDF8oG6cJ6wq-PBoYvlA3WBpzQhJN7CkOjxzi0Ql_RM6Ll9vsf3HB6S72YzfiW0Z19Upm5_WktROUXC9kZN1u5VFY-FssnZEvE4N76u3e-6fpvr-l10zbZI0q38Kd_Lb3R3k5MiWn9xTx27040fMJJfcA-g_NJ076jzbwU3ecwBEHRVIeNeQskLjU6bbwk1R0gtZeffQmhIeVlLmf6R2k1Jt-7QD3Cfg7cB4Xf16B-vmiQ3vMr2Rpt3qLVAJ6K0it89rbKqR2kV_abaKn73tMqqnK1uLuIBCC5QZYwFg651tN0B4rg3gqqiovBwsdBT9xp_UED_L_z8cRAffxUFiz95PZTshOvPkTVheulkevlgph1adzJtqcMyJYpBh81d3a0yvk4uTMtZ8EsTzLDWAeLppELhEYaxaTkLfoGDGfI6QHz8VRT8SpCd2MZyFqblyCb9ltOU6TrLUZm21OG0HOb6FttYztK0nCW7asO6OsIB4umkQuERXLFpOUt27Yd1WYUDxMdfRcGvBNmJbSxnaVqObNJvOU2ZrrMclWlLHU7L4dPXYNPp6rIKNlI8g6uFRPQPDT8WOfzjUovHIzcAcltNzvzCkQd21E1pmz66KYnuVX-kqMljqxBCe1j1dZi9HBrv2va1U1lWRNxRw5WOsOVD4-DFfm3s21FDCoXGojGNAdBYOmnoK-JD1sfmwrcNFIS12FpYC6ewFhsJa-EU1mIjYS2cwlo8srAGKKzl1sJaOoW13EhYS6ewlhsJa-kU1tIjrIZ5DHxW26xa7Yu4mGMw70zBe4828g0uwt3qLtSNesZvWkidVy0IOTsvW0g3u20Bn_XHIQ8PyYfZBBplp6bZsWSyN8WDyXvyFHWjU5W71nHoz58bicRxGJqc2imVx8raOE5tN7shwserI_3zSKp5d5vgLXM8bZfGd6V9sB1totkruiH-ZWY89Ykcw_BtkMVjjgpf-jQBDhiw68-Z2MDsrn3G0OPfsqFcaCTvEHPorvEdos7LCo5sbN9do9Kh_fDj6w8_nb_99ec372WlkucE-uIaJa0LSqazAtk1YKpcZwXju0yJXmDATq-67F9nCVzfSKFpsvMeWdHrNVbem4PXHqizHALVixZj6Ldk74_p_R45InvdP6Z7rj8dzxn3XLfAqe3d3__jHgFZT148B1LE92XVJV8NcLXXdZpgS9yMywWIk2-fBdueqsBfBeFw40YCfyOBv5Fgs0YG_kYG_kYGmzUy9Dcy9Dcy5Jlhlbo-qoV1rXTbXJlhwCSexqV821KoV7GpV6291epZUxaq51reCCbqXLlgtFrc1l3Sq1zo-XQh6dOFpI91ISk1xm1vJGXI1pWk_8Av6O7jn7f467y86L38C__Ff_8v" rel="nofollow noreferrer" title="C++ (GCC)  Attempt This Online">Attempt This Online!</a></p>
<p>This matches the output of wastl's program up to 12 terms, and does so much faster (<s>62</s> 65 times faster on my machine).</p>
<p>Certain design elements were quite natural and are shared between both our programs  namely, the use of 128-bit integer coordinates, the coordinates of the starting tetrahedron, and multiplying all coordinates by 3 for each successive term. The remaining details are implemented from scratch though, without consulting wastl's program.</p>
<p>The finding of standardized rotations of each polytet (for comparison purposes) is done by solving for the affine transformation that moves one of the faces of one of the tetrahedrons to the first face of the starting tetrahedron. For speed, this is limited only to the attached faces of those tetrahedrons that have only one attached face, taking advantage of the fact that it's guaranteed that all polytets will have some (because a polytet can never curve around and perfectly meet one of its own faces).</p>
<p>Edits:</p>
<ul>
<li>Added optional <code>USE_GMP</code> (GNU Multiple Precision Arithmetic Library)
<ul>
<li>for applying the affine transform (but not solving for it)</li>
<li>for checking for tetrahedron overlaps/collisions (this further slows down the GMP version by about 14%)</li>
<li>fixed a bug in importing 128-bit integers; this gave it an incorrect result for <span class="math-container">\$A276272(13)\$</span> and made it incorrectly detect an overflow immediately after reaching it, preventing it from going towards <span class="math-container">\$A276272(14)\$</span> even for a moment</li>
</ul>
</li>
<li>Improved non-GMP version speed by 4%</li>
<li>Added verification of transformed tetrahedron edge lengths. Combined with <code>USE_GMP</code> enabled on the overlap checking code, this detects the exact moment an overflow occurs and avoids reporting any incorrect polytet counts.</li>
</ul>
<p>Output:</p>
<pre><code>1: 1 [0 ms]
2: 1 [0 ms]
3: 1 [0 ms]
4: 4 [0 ms]
5: 10 [2 ms]
6: 39 [10 ms]
7: 164 [53 ms]
8: 767 [296 ms]
9: 3656 [2350 ms]
10: 18186 [15845 ms]
11: 91532 [106165 ms]
12: 468203 [683449 ms]
13: 2417721 [4291118 ms]
14: 663520 [4734026 ms]
</code></pre>
<p>(The timings shown are cumulative.)</p>
<p>The 128-bit math is clearly overflowing beyond <span class="math-container">\$A276272(13)\$</span> [and as the <code>USE_GMP</code> version shows, that value itself is also incorrect, due to overflows occuring in the overlap checking code]. In any case, the fact that this agrees with wastl's program up to <span class="math-container">\$A276272(12)\$</span> strongly suggests that they're both correct up to that point (and would be beyond it by using larger integers), and that the OEIS entry can finally be updated.</p>
<p>It uses about 20% more RAM than wastl's program, but that can probably be improved. There's still plenty of room for further speed-ups, such as adding multithreading. Storing polytets in compressed form could extend the point at which RAM imposes a limit; disk storage and merge-sorting could be used to do away with that limit.</p>
<p>Output with GMP enabled:</p>
<pre><code>1: 1 [0 ms]
2: 1 [0 ms]
3: 1 [1 ms]
4: 4 [2 ms]
5: 10 [12 ms]
6: 39 [53 ms]
7: 164 [269 ms]
8: 767 [1607 ms]
9: 3656 [9653 ms]
10: 18186 [61997 ms]
11: 91532 [389137 ms]
12: 468203 [2459990 ms]
13: 2417722 [15555313 ms]
</code></pre>
<p>With <code>USE_GMP</code> enabled, the GNU Multiple Precision Arithmetic Library is used for applying the affine transform (but not solving for it) and checking for tetrahedron overlaps  but not for any other calculations, so overflow will still eventually happen. This is about 3 times slower, and allows <span class="math-container">\$A276272(13)\$</span> to be correctly calculated. It may even be enough to reach <span class="math-container">\$A276272(14)\$</span>, though that's projected to use 42 GB RAM (getting close to my machine's 64 GB), so I won't be able to run it beyond that.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.rust-lang.org/" rel="nofollow noreferrer">Rust</a>, 11 (hopefully correct) terms</h1>

<pre class="lang-rust prettyprint-override"><code>
use ::std::ops::{Add, Sub, Mul};
use ::std::rc::Rc;
use ::std::hash::{Hash, Hasher};
use ::std::collections::HashSet;
use ::std::iter;
use ::std::fmt::{self, Formatter, Display};
use ::std::time::Instant;

type Coord = i128;

#[derive(Copy, Clone, PartialEq, Eq, Debug)]
struct Vec3([Coord; 3]);

impl Vec3 {
    fn dot(self, other: Vec3) -&gt; Coord {
        self.0.iter().zip(other.0.iter()).map(|(a, b)| a * b).sum()
    }
}

impl Display for Vec3 {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        write!(f, "({}, {}, {})", self.0[0], self.0[1], self.0[2])
    }
}

impl Mul&lt;Vec3&gt; for Coord {
    type Output = Vec3;

    fn mul(self, mut vec: Vec3) -&gt; Vec3 {
        for i in &amp;mut vec.0 {
            *i *= self;
        }
        vec
    }
}

impl Add for Vec3 {
    type Output = Vec3;

    fn add(mut self, other: Vec3) -&gt; Vec3 {
        for (i, n) in self.0.iter_mut().enumerate() {
            *n += other.0[i];
        }
        self
    }
}

impl Sub for Vec3 {
    type Output = Vec3;

    fn sub(self, other: Vec3) -&gt; Vec3 {
        self + (-1 * other)
    }
}

#[derive(Clone, Debug)]
struct Tetrahedron([Vec3; 4]);

impl Default for Tetrahedron {
    fn default() -&gt; Tetrahedron {
        Tetrahedron([
            Vec3([-1, -1, -1]),
            Vec3([-1,  1,  1]),
            Vec3([ 1, -1,  1]),
            Vec3([ 1,  1, -1]),
        ])
    }
}

impl Display for Tetrahedron {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        write!(f, "Tetrahedron({}, {}, {}, {})", self.0[0], self.0[1], self.0[2], self.0[3])
    }
}

impl Tetrahedron {
    fn collides(&amp;self, other: &amp;Tetrahedron) -&gt; bool {
        let mut othervecs = [3 * self.0[1], 3 * self.0[2], 3 * self.0[3]];
        let sum = self.0[0] + self.0[1] + self.0[2] + self.0[3];
        let mut same = 0;

        for (i, &amp;vec) in self.0.iter().enumerate() {
            let sum = sum - vec;
            let vec = 3 * vec;
            let through = vec - sum;
            for (j, &amp;u) in other.0.iter().enumerate() {
                let u = 3 * u;
                if u == vec { same += 1 }
                let up = (sum - u).dot(through);
                for &amp;v in &amp;other.0[j+1..] {
                    let v = 3 * v;
                    let edge = v - u;
                    let ep = edge.dot(through);

                    if up.signum() != ep.signum() || up.abs() &gt;= ep.abs() {
                        continue
                    }

                    let intersection = ep * u + up * edge;
                    if othervecs.iter().enumerate().all(|(i, &amp;ov)| {
                        let mid = othervecs[(i+1)%3] + othervecs[(i+2)%3];
                        let ov = 2 * ov - mid;
                        (2 * intersection - ep * mid).dot(ep * ov) &gt; 0
                    }) {
                        return true
                    }
                }
            }

            if i != 3 { othervecs[i] = vec; }
        }
        if same == 4 { panic!("EQUAL TETRAHEDRA IN .collides()"); }
        false
    }

    // Mirroring also scales by 3
    fn mirror(&amp;self, i: usize) -&gt; Tetrahedron {
        let mut sum = Vec3([0; 3]);
        for (j, &amp;vec) in self.0.iter().enumerate() {
            if j != i { sum = sum + vec; }
        }

        let mut copy = self.clone();
        copy.scale();

        copy.0[i] = 2 * sum - copy.0[i];
        copy.swap(i, 3);
        copy.rotate_left(i);

        copy
    }

    fn scale(&amp;mut self) {
        for vec in self.0.iter_mut() {
            *vec = 3 * *vec;
        }
    }

    fn rotate_left(&amp;mut self, n: usize) {
        self.0[..3].rotate_left(n)
    }

    fn swap(&amp;mut self, a: usize, b: usize) {
        self.0.swap(a, b)
    }

    fn reverse(&amp;mut self) {
        self.0.reverse()
    }
}

type EndpointIter&lt;'a&gt; = Box&lt;dyn Iterator&lt;Item = Endpoint&gt; + 'a&gt;;

#[derive(Debug, Clone)]
struct Endpoint {
    tree: Rc&lt;TetraTree&gt;,
    hedron: Rc&lt;Tetrahedron&gt;,
}

impl Endpoint {
    fn iter_endpoints(&amp;self) -&gt; EndpointIter {
        let mut hedron = Rc::clone(&amp;self.hedron);
        //Rc::make_mut(&amp;mut hedron).swap(0, 3);
        Rc::make_mut(&amp;mut hedron).reverse();

        Box::new(self.clone().into_iter_directions()
            .chain(self.tree.iter_endpoints(
                Rc::new(TetraTree {
                    subtrees: [None, None, None],
                    hedron,
                })
            ))
        )
    }

    fn into_iter_directions(self) -&gt; EndpointIter&lt;'static&gt; {
        Box::new(iter::successors(Some(self), |this| {
            let mut this = this.clone();
            Rc::make_mut(&amp;mut this.tree).rotate_left(1);
            Rc::make_mut(&amp;mut this.hedron).0[1..].rotate_left(1);
            Some(this)
        }).take(3))
    }

    fn iter_extensions(&amp;self) -&gt; EndpointIter {
        let mut tree = self.tree.as_ref().clone();
        tree.scale();

        let mut hedron = self.hedron.as_ref().clone();
        //hedron.swap(0, 3);
        hedron.reverse();
        hedron.scale();

        Box::new(Endpoint {
            tree: Rc::new(tree),
            hedron: Rc::clone(&amp;self.hedron),
        }.into_iter_directions().filter_map(|endpoint| {
            let mut new = endpoint.hedron.mirror(3);
            new.swap(0, 3);
            if endpoint.tree.collides(&amp;new) {
                None
            } else {
                let mut hedron = endpoint.hedron;
                Rc::make_mut(&amp;mut hedron).scale();

                Some(Endpoint {
                    tree: Rc::new(TetraTree {
                        subtrees: [Some(endpoint.tree), None, None],
                        hedron,
                    }),
                    hedron: Rc::new(new),
                })
            }
        }).chain(self.tree.iter_extensions(Rc::new(TetraTree {
            subtrees: [None, None, None],
            hedron: Rc::new(hedron),
        }))))
    }

    fn iter_tetrahedra&lt;'a&gt;(&amp;'a self)
      -&gt; Box&lt;dyn Iterator&lt;Item = &amp;Tetrahedron&gt; + 'a&gt; {
        Box::new(
          iter::once(self.hedron.as_ref()).chain(self.tree.iter_tetrahedra())
        )
    }
}

impl Default for Endpoint {
    fn default() -&gt; Endpoint {
        Endpoint::from(Tetrahedron::default())
    }
}

impl From&lt;Tetrahedron&gt; for Endpoint {
    fn from(mut hedron: Tetrahedron) -&gt; Endpoint {
        let mirrored = hedron.mirror(0);
        hedron.scale();

        Endpoint {
            tree: Rc::new(TetraTree {
                subtrees: [None, None, None],
                hedron: Rc::new(mirrored),
            }),
            hedron: Rc::new(hedron),
        }
    }
}

impl Hash for Endpoint {
    fn hash&lt;H: Hasher&gt;(&amp;self, hasher: &amp;mut H) {
        let mut stuff: Vec&lt;_&gt; = self.tree.hash_helper(1).collect();
        stuff.push(self.tree.len());
        stuff.sort();
        stuff.hash(hasher);
    }
}

impl PartialEq for Endpoint {
    fn eq(&amp;self, other: &amp;Endpoint) -&gt; bool {
        self.iter_endpoints().any(|ep| ep.tree == other.tree)
    }
}

impl Eq for Endpoint {}

#[derive(Debug, Clone)]
struct TetraTree {
    subtrees: [Option&lt;Rc&lt;TetraTree&gt;&gt;; 3],
    hedron: Rc&lt;Tetrahedron&gt;,
}

impl TetraTree {
    fn iter_endpoints&lt;'x&gt;(&amp;'x self, behind: Rc&lt;TetraTree&gt;) -&gt; EndpointIter&lt;'x&gt; {
        let mut iterator = self.subtrees.iter().enumerate()
          .filter_map(|(i, opt)| opt.as_ref().map(|some| (i, some)));

        if let Some(first) = iterator.next() {
            let closure = move |(i, subtree): (usize, &amp;'x Rc&lt;TetraTree&gt;)| -&gt; EndpointIter&lt;'x&gt; {
                let mut behind = behind.as_ref().clone();
                behind.rotate_left(3-i);

                let mut this = self.clone();
                this.rotate_left(i);

                Rc::make_mut(&amp;mut this.hedron).reverse();

                this.subtrees.swap(1, 2);
                this.subtrees[0] = Some(Rc::new(behind));

                for (j, subtree) in this.subtrees.iter_mut().enumerate().skip(1)
                  .filter_map(|(j, s)| s.as_mut().map(|s| (j, s))) {
                    Rc::make_mut(subtree).rotate_left(j);
                }

                subtree.iter_endpoints(Rc::new(this))
            };
            Box::new(closure(first).chain(iterator.flat_map(closure)))
        } else {
            let mut hedron = self.hedron.as_ref().clone();
            //hedron.swap(0, 3);
            hedron.reverse();
            Endpoint {
                tree: Rc::clone(&amp;behind),
                hedron: Rc::new(hedron),
            }.into_iter_directions()
        }
    }

    fn rotate_left(&amp;mut self, i: usize) {
        self.subtrees.rotate_left(i);
        Rc::make_mut(&amp;mut self.hedron).rotate_left(i);
    }

    fn collides(&amp;self, hedron: &amp;Tetrahedron) -&gt; bool {
        self.hedron.collides(hedron) ||
          self.subtrees.iter()
            .filter_map(Option::as_ref)
            .any(|subtree| subtree.collides(hedron))
    }

    fn scale(&amp;mut self) {
        for subtree in self.subtrees.iter_mut().filter_map(Option::as_mut) {
            Rc::make_mut(subtree).scale();
        }
        Rc::make_mut(&amp;mut self.hedron).scale();
    }

    fn iter_extensions(&amp;self, behind: Rc&lt;TetraTree&gt;) -&gt; EndpointIter {
        Box::new(self.subtrees.iter().enumerate().flat_map(move |(i, next)| {
            let mut behind = behind.as_ref().clone();
            behind.rotate_left(3-i);

            let mut this = self.clone();
            this.rotate_left(i);

            let hedron = Rc::make_mut(&amp;mut this.hedron);
            hedron.reverse();

            this.subtrees.swap(1, 2);
            this.subtrees[0] = Some(Rc::new(behind));

            for (j, subtree) in this.subtrees.iter_mut().enumerate().skip(1)
              .filter_map(|(j, s)| s.as_mut().map(|s| (j, s))) {
                let subtree = Rc::make_mut(subtree);
                subtree.scale();
                subtree.rotate_left(j);
            }

            if let Some(next) = next {
                hedron.scale();
                next.iter_extensions(Rc::new(this))
            } else {
                let mut mirrored = hedron.mirror(3);
                mirrored.swap(0, 3);
                hedron.scale();

                if this.collides(&amp;mirrored) {
                    Box::new(iter::empty()) as EndpointIter
                } else {
                    Box::new(iter::once(Endpoint {
                        tree: Rc::new(this),
                        hedron: Rc::new(mirrored),
                    }))
                }
            }
        }))
    }

    fn iter_tetrahedra&lt;'a&gt;(&amp;'a self)
      -&gt; Box&lt;dyn Iterator&lt;Item = &amp;Tetrahedron&gt; + 'a&gt; {
        Box::new(iter::once(self.hedron.as_ref()).chain(
          self.subtrees.iter()
            .filter_map(Option::as_deref)
            .flat_map(TetraTree::iter_tetrahedra)
        ))
    }

    fn len(&amp;self) -&gt; usize {
        1usize + self.subtrees.iter()
              .filter_map(Option::as_deref).map(TetraTree::len).sum::&lt;usize&gt;()
    }

    fn hash_helper&lt;'a&gt;(&amp;'a self, behind: usize)
      -&gt; Box&lt;dyn Iterator&lt;Item = usize&gt; + 'a&gt; {
        let sub: Vec&lt;_&gt; = self.subtrees.iter().filter_map(Option::as_deref)
          .map(|a| (a, a.len())).collect();
        let sum = sub.iter()
          .map(|&amp;(_, len)| len).sum::&lt;usize&gt;() + behind + 1;
        Box::new(iter::once(behind).chain(
            sub.into_iter().flat_map(move |(sub, len)|
                        iter::once(len).chain(sub.hash_helper(sum - len)))
        ))
    }
}

impl PartialEq for TetraTree {
    fn eq(&amp;self, rhs: &amp;TetraTree) -&gt; bool {
        self.subtrees == rhs.subtrees
    }
}

impl Eq for TetraTree {}

fn main() {
    let verbose = std::env::args().skip(1).any(|arg| arg == "-v");
    let begin = Instant::now();

    println!("1: 1 [{}ms]", begin.elapsed().as_millis());
    if verbose {
        println!("{}\n--", Tetrahedron::default());
    }

    let mut polytets = HashSet::new();
    polytets.insert(Endpoint::default());

    for i in 2.. {
        println!("{}: {} [{}ms]", i, polytets.len(), begin.elapsed().as_millis());

        if verbose {
            for polytet in &amp;polytets {
                for hedron in polytet.iter_tetrahedra() {
                    println!("{}", hedron);
                }
                println!("--");
            }
        }

        polytets = polytets.iter()
          .flat_map(Endpoint::iter_extensions)
          .collect();
    }
}

</code></pre>
<p><a href="https://tio.run/##vVrrb9vIEf8s/xUbF3XIWKYt6z4UlCwgTXJIgN4rcfvFFQxKWlnMUSSPSzr2Wfrb05nZN0VFvmvRAFbIfcxrZ34zs1LViPrr16NGcBbHol7EcVGKOH56vVj02adm1mc/NNl25C6o5nH8ce4NrRKxgk3v4b8@w09e@XvmRZbxeZ0WORDHBZ947S1Ia155A8t1DRQFz5Z99n1RrZMaVvTZ21SUWfLoU6/TNY/jD7mokxzIHtWPJWdviqJasCuWDi7/BmN/uVnwKr3nwZuifOyzN1mR8z77OanqNMne/dZn@PeWz5q7cHok6qqZ1@xffD4MbojQiA2nIZBJ12VG4@zpqLfM2aKoAylkUYPWMc2F7Gyi@MOqHs5HFxGqGITR72kZ0FozFEbrpAw2QdJns3DDEvYK/o9Esw7Co972aKu4KtXZsqhcCcBQwYkUYRmzk3VTW3uRIGTJj1w0WU3ifKmA7YsA1h8HT9s@k3/hcZ9JQW8upuZxYB8vp5404BZjlGJC8hhlyfQ/NXUJYlyRmGA0FHPdZMpQKOE9nzum0tr0kFTK0lyqAYuiCxrvvUrZqyuSZASvW/iDSVcc8FfPMHvlSBaLAIl3H5onSZD2WR6iOM4J3sJmOEWeN2teJTUPQiVhzk6vmDrYm3Sq5cStrqAQU88TVDSz4ICQOM1OWXA2AJehVfqIrLdLP2859jWvq2TFF1WRBzfEk31n3fstXyboLCims1J7vJwNSJTWdM8jjGaRIXQ26DP5Nw37/jCjP2@YqdUdw8whMt0bHbtC/zdB4upk4@WZMWMeh764uyIiRKYLLrSc6tRPnJUk6awoMhIx4zXFEi2EcBDgPzdD8ARHDuf10n8dTslFkQggDbuyioBHGQr2@dJ5HpqtFEnJmsP@C/RbEzcnIFA7dLrCxuEPn2cY8yM9Ds8wjjK7o/WqKpq7Fczg/Bnuozni/Bk4N8TXh9hdxkSrUfQbotBLlzgiCT9JvSCmB2xrN5SwI5CiNmGE6K/kCSUJlOLkniBMY8Hn00EUTRVXqZhWa2TH@OIOrXiPhN1hZIhzLV5yBQpcRiK9yzFZsBew1HndbHA2mQl4ntCUfFaS9OZFXqd5w@Xr9shyTXOwmpAJG/mXaCM4/wYfUJqR4W@8r8PSUZJlkNfQHYp7yGyaMXlOisnZ7L4J0tNB@Nchepk3eImDI2djgda7RMBDWwEZPRngoCf5mZQc1sijojeQhE3YhVLaWqPidVPlDADSGMR8StuAtinaGMDXkTGdSlcckZvgH6yTMXHFvoOlZZKn8xfB8btf/vn6H@z63fXH1@/fvf34mn34kUUm6sPjUFJYJpngR8Ty/Jz9kFZVUaX5HYPhgol5knHBZo9sKLMqTWvISGPWiPR33gnNJlwp2iSkXqiyxomeZ8Yt6PgZbZFioJj4PXUN4fCcQ82lIWaOGSkgpjgckUqBdGkauJAmxdOUgWZG7Z4vUDCBWw0tmaqoQbzbjC/rILXUpCExnRKbE536Q5PlMdi7UrxK6xaEXikU2hqaLs8TW1Tk5hhs9XcTRcOpJ2QeWtlQHYdAoghAPdhBSmpPxaKVhN@j27f1Uxv0rM5AVHO8yxdlAeHyATQev0wmoOXfi4fx4jFnOJTURTWGBzxavXQCBwwr3WqaCgtVTtv6Qm@gAqfiPGYf52NyyGt4m0D2lo5px@U7zOgE6ZIABelcuBpTOZLc3FXD83Pl@lfAAvoPcjraFalcikd5fo6T6@RXTmd@YveF0soX2sf2rzPGJZ8DE8Zxzr8Erq9HIF9xSyos0kr1QXgavV40XyVpLlejpaKWooRByBxpGgtq0IIaETeJmN38SHWe/Zz25RIppnzZEssQP63rdMrWad7xS2iw6nQ@IfZGU9wLjVgzn3MhikoEn4o1lxT6bFOvUrGxuR4th0NwLvifiwYdNqYlqGHohc7gm@v1wUD9Anm3ayMJiGvREtswqoFIMAwdm9AhPNQ8F2SOZ7gbSqkhjg4yEbcVX8LhOyrShAt4O87qeGgnhfNzNem7pxp0fNGMuezMmbnR1TMhKufI3uQwNkg7IwjXbPf4drRMM4JS7Gy1O7f8AJhhcaEmtdYqpUm9erCmpSqmHrOHDGorZ1itEzrGAKVuxiGfOjWfZ@4W85EJtz2Y4NhSuZFvybYtdyLWDVna76kSdkWwF8Lgrl5gW1aouxvmW@nb3fhiXXuPpAeRpc3e9YkwbMdSrTE@wVQTnLxMZJY66jGMqn2Jx21@VPLxsQeeGZMAVORziTrt8NljAytSYBFx29ECtzKR1/96p69f4nhZFevAkT2OzS6Pzfewzst/XQyJmPXCmLU7Qk8IWVtjCHEssP2gutgHDN/Cg7YPH046bd/Q8kj/3IYHHci1Ed4WdpkF7xzH72N13TjRNfCKXlWP/z70S9@6WS7pImV8O/HAGnfdrnhWQrU7CCN1XSlxlHZFZSNWjgtlPIeztNOQ@LzlSDCQsuCoVcfcOHbpxH9rd/96gd/6kxytSgG6rfwRsLbcYKcn05G@kCJscaXYYb89WNN5buD4wE8lQv7YK/Am2Fc8p8rziO6UeeOXD4gVD6osnvFVmi9atWRHlfIw8U49VaCiD1zL3tHbEJx4qQu7jKKsoXmFT5uRaU4Afm/otgOfwlCGEqQn5EzgvkwrAUd3ZWSIcoBe9@4D0qpoKqwc1sU9Z8RPCRjGLFBtANrA13qzV22ruLQXkJYPnfVEr6cm3TJpeJbqHNeq2dodHGAFllwdzdfB8syvmxUhczaU8wd9dumy0bN4SXUlLazRQ2oRamK6ndWmxA7PZ9B9lxuJX1PgSwl0xxWQHhheoCHlTukGG8kKHEBneU91LYNnpc9KL3Xrota0Y9qUZFiryqxO20z@U@6jHE0lOuNsyyypSXa1jNKyVxH94fpzXwHaWYG20oqTV1Q1qU6tO2s4CWFvmfmcdjzd7aGNF7Qdt8tr3ZJ3d4Pi3b691crsv751LW1264WbDUFRF17RhO@aEoLjWB6YWUH5QO3e6FDY4RUeviJRW801SVcQdYsDcyooukPC1CCyXj1gfLv6W33acxOFX0keSg02mCxQI5iHrabmWaD7Tcw9BLl7ERc3erce@9F3T8geHcLhPwbD/wsU/tMgLL9ZmKm@vNP9Rh72Or5oBzsw21wGmzRPfgBM8H/FvV1j96iXfaj39l8OxHd1rHtLegW/Pb2gjctd1T5JL69fDGyZGl3nsNb9Dl@X9SOUvCwRXhTJLOaK3N5JjVm7TW7fOaD2fr@7r32g/tK9mlcD/49285md5p/Ebii/HfQ2eGMgTP5KwlGO2larOvYk9qaKch6JP5CPp98S6YBQUUsQYEW/UIjjMRGfBFYMp5fyrG9xWabjA4ch6TqnoAK63b@1MfugbSVgJAAYSZ8lqpNr9Xzu15Iz11Jy80lw20dzAxB1WAJkVlnglA1Ge/xHIaX1mB5x0lVOR8IR@GscYipx0f5zyJI46r4D6Ll9rfwyBReE1nG629J2W2b70moldFFzTZC@U9Lo88DuE1ab947202EDM/h1FspNCCS//61mhaBbVfyVD8/v4SirO2EThCxxYGzD4AM5Hp/dH@MJ4v4Zv0sxFaofBsERFF8kApYVGDrLXwTHg5gN2M3Tdi2mx325I@JZUgq@wI4ackwKCClkrw@oqWVCdS2Vp@2/87MzILDnzkdVLBrMyyJ7hCjG7K5@CyXdA9fpOXAFwas6sJdKLrkj@1OZyyjakSYGg1qtoFIxVMnbDykqu1hXVWKniNCX20aFJ9NvqdIDZtXk7j2bRn9X1mNdLJuOyF8BdtV5V@Vex3zWWk6ImsCxtmtlXbXQDXl0Tvk7OPsruLcIGvh7sipJa/Za0PtY4RF9iXYNbgenBxg1kr8uUkhjUw4GyCd4iGO5dqSDAOiAv@BWgAmiPPFYoEnV3cp1myForqaQz/gak7IkodlMniuPDVz/cgPwMYnkXoUUX/8D" rel="nofollow noreferrer" title="Rust  Try It Online">Try it online!</a> The footer contains some compatability implementations because TIO's Rust is a little old. (This has already been <a href="https://chat.stackexchange.com/transcript/message/54872387#54872387">reported</a> and added to the <a href="https://gist.github.com/cairdcoinheringaahing/46f79623ea7b5cfe67286d0a5e96d307" rel="nofollow noreferrer">list</a>.)</p>
<p>Output:</p>
<pre class="lang-rust prettyprint-override"><code>1: 1 [0ms]
2: 1 [0ms]
3: 1 [2ms]
4: 4 [8ms]
5: 10 [35ms]
6: 39 [139ms]
7: 164 [738ms]
8: 767 [4328ms]
9: 3656 [31298ms]
10: 18186 [287871ms]
11: 91532 [3154716ms]
</code></pre>
<p>As you can see, it also reports how long it took. (These are cumulated times.) You can use the <code>-v</code> option to list all tetrahedra for each polytet.</p>
<p>I don't really have a good way of verifying the results beyond A276272(5). I hope it works, but I'm not sure.</p>
<p>The idea is that we store the polytet as a tree of tetrahedra that also encodes orientation. But for collision detection we need actual tetrahedra. We start with the tetrahedron with vertices (-1, -1, -1), (-1, 1, 1), (1, -1, 1), (1, 1, -1) and scale all tetrahedra by 3 for every term. This avoids the need for fractions.</p>
<p>Can probably be made faster, but I don't know how.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/214203/">214203</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




