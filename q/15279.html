<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::15279</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td></td><td>231101T145229Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/266405#266405">ShadowRa</a></td></tr>
<tr d-ix="1"><td>nan</td><td></td><td>140215T030500Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/20939#20939">Claudia</a></td></tr>
<tr d-ix="2"><td>nan</td><td></td><td>230223T231215Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/258186#258186">ShadowRa</a></td></tr>
<tr d-ix="3"><td>nan</td><td></td><td>180621T203844Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/167265#167265">user4180</a></td></tr>
<tr d-ix="4"><td>nan</td><td></td><td>211120T053723Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/237486#237486">Nate T</a></td></tr>
<tr d-ix="5"><td>nan</td><td></td><td>211120T091213Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/237488#237488">user1004</a></td></tr>
<tr d-ix="6"><td>nan</td><td></td><td>211111T211221Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/237192#237192">pxeger</a></td></tr>
<tr d-ix="7"><td>nan</td><td>In Pure Bash or any other pure shellscript</td><td>211111T105825Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/237161#237161">user1004</a></td></tr>
<tr d-ix="8"><td>nan</td><td></td><td>210803T161859Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/233047#233047">pxeger</a></td></tr>
<tr d-ix="9"><td>nan</td><td></td><td>210803T155127Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/233046#233046">pxeger</a></td></tr>
<tr d-ix="10"><td>nan</td><td>To print a range of characters shorter than echo {a..z}|tr d ' '</td><td>191122T105136Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/196271#196271">builder-</a></td></tr>
<tr d-ix="11"><td>nan</td><td></td><td>190907T214028Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/191457#191457">GammaFun</a></td></tr>
<tr d-ix="12"><td>nan</td><td></td><td>190202T102447Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/179409#179409">F. Hauri</a></td></tr>
<tr d-ix="13"><td>nan</td><td></td><td>190202T104624Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/179411#179411">F. Hauri</a></td></tr>
<tr d-ix="14"><td>002</td><td>In a case statement</td><td>180721T131131Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/168989#168989">Bastian </a></td></tr>
<tr d-ix="15"><td>nan</td><td></td><td>181124T111842Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/176457#176457">primo</a></td></tr>
<tr d-ix="16"><td>nan</td><td></td><td>181019T160116Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/174315#174315">Digital </a></td></tr>
<tr d-ix="17"><td>nan</td><td></td><td>180730T211839Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/169577#169577">Okx</a></td></tr>
<tr d-ix="18"><td>nan</td><td></td><td>180802T002031Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/169788#169788">Digital </a></td></tr>
<tr d-ix="19"><td>nan</td><td></td><td>180730T212025Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/169578#169578">Okx</a></td></tr>
<tr d-ix="20"><td>nan</td><td></td><td>180115T194039Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/153274#153274">Dennis</a></td></tr>
<tr d-ix="21"><td>nan</td><td></td><td>171202T150721Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/149716#149716">F. Hauri</a></td></tr>
<tr d-ix="22"><td>nan</td><td></td><td>170724T102132Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/135322#135322">jimmy230</a></td></tr>
<tr d-ix="23"><td>nan</td><td>Undocumented</td><td>140413T041447Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/25802#25802">Digital </a></td></tr>
<tr d-ix="24"><td>nan</td><td>When assigning noncontinuous array items</td><td>170629T101320Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/129002#129002">manatwor</a></td></tr>
<tr d-ix="25"><td>nan</td><td></td><td>141107T034030Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/41201#41201">Dennis</a></td></tr>
<tr d-ix="26"><td>nan</td><td></td><td>140603T202240Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/30112#30112">user1640</a></td></tr>
<tr d-ix="27"><td>nan</td><td></td><td>170127T230237Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/108424#108424">lynn</a></td></tr>
<tr d-ix="28"><td>nan</td><td></td><td>160108T231154Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/68934#68934">F. Hauri</a></td></tr>
<tr d-ix="29"><td>nan</td><td></td><td>170119T044558Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/107308#107308">Evan Kra</a></td></tr>
<tr d-ix="30"><td>nan</td><td></td><td>170105T185613Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/105774#105774">user6391</a></td></tr>
<tr d-ix="31"><td>nan</td><td></td><td>161106T210430Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/98803#98803">Glenn Ra</a></td></tr>
<tr d-ix="32"><td>nan</td><td></td><td>151224T150648Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/67634#67634">mikeserv</a></td></tr>
<tr d-ix="33"><td>nan</td><td></td><td>150330T104554Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/48278#48278">jimmy230</a></td></tr>
<tr d-ix="34"><td>nan</td><td>If you need to pass the content of a variable to STDIN of the next process in a pipeline</td><td>141106T231936Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/41182#41182">Digital </a></td></tr>
<tr d-ix="35"><td>000</td><td>Element 0 of an array may be accessed with the variable name only</td><td>141106T231314Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/41181#41181">Digital </a></td></tr>
<tr d-ix="36"><td>009</td><td>split has another deprecated</td><td>140603T201947Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/30111#30111">user1640</a></td></tr>
<tr d-ix="37"><td>nan</td><td>Avoid $ ...command...</td><td>140409T134517Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/25572#25572">user1640</a></td></tr>
<tr d-ix="38"><td>nan</td><td></td><td>140603T201816Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/30110#30110">user1640</a></td></tr>
<tr d-ix="39"><td>nan</td><td></td><td>140421T192659Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/26140#26140">user344</a></td></tr>
<tr d-ix="40"><td>nan</td><td>Instead of grep E</td><td>140409T135215Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/25574#25574">user1640</a></td></tr>
<tr d-ix="41"><td>nan</td><td> is a command that does nothing</td><td>140409T134718Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/25573#25573">user1640</a></td></tr>
<tr d-ix="42"><td>nan</td><td></td><td>131115T091411Z</td><td><a href="https://codegolf.stackexchange.com/questions/15279/tips-for-golfing-in-bash/15280#15280">manatwor</a></td></tr>
</table>
<div id="pu0" class="pu"><h2>Compress long runs of decimal digits using alternate base representation</h2>
<p><code>bash</code>'s arithmetic context supports numbers in arbitrary alternate bases more compactly that any other language I know of (e.g. Python's <code>int(string,base)</code> has overhead of six characters for the <code>int</code>, <code>(</code>, <code>)</code>, and <code>,</code>, if you aren't given the string from elsewhere, two more for the <code>'</code> or <code>&quot;</code> around the literal, plus 1-2 characters for the base). By contrast, <code>bash</code> only needs three characters to impose arithmetic context, <code>$[]</code> (if you're not already in it), and just one character to impose alternate base context, and the same 1-2 characters for the base, so <code>bash</code> needs 2-6 characters to do what Python (which is relatively good on this score) needs 6-9 characters to do.</p>
<p>Bash also supports higher bases for integer literals than most languages (topping out at base 64, rather than base 36 as is common; if you use a base above 36, it uses a digit &quot;alphabet&quot; of up to <code>0-9a-zA-Z@_</code>).</p>
<p>Between these two features, you can shave up to three characters off long strings of decimal digits by replacing them with arithmetic context (using <a href="https://codegolf.stackexchange.com/a/15280/70305">the shorter form of arithmetic expansion</a>) of a base 64 value. The best savings occur when the digits in question require an even multiple of six bits to represent in binary, and no savings are available unless the decimal representation of the integer is at least 15 characters long, but when it works, it's a great way to shorten further. If you're using it as a number in an existing arithmetic context that does other math, you can save up to 6 characters (since the <code>$[]</code> is already paid for by the need to do math, so it doesn't count against the cost of the alternate base), and benefits begin to appear at just 8 decimal digits.</p>
<p>For the best case scenario, a program that needs a literal string numerically equivalent to a number between (with <code>_</code> for readability)
<code>1_000_000_000_000_000_000</code> and <code>1_152_921_504_606_846_975</code> can represent such a number as either:</p>
<pre class="lang-bash prettyprint-override"><code>1000000000000000000
# or shaving three characters
$[64#TwJHeDp000]
</code></pre>
<p>If you were already in arithmetic context, it saves six instead:</p>
<pre class="lang-bash prettyprint-override"><code>$[var%1000000000000000000]
# becomes
$[var%64#TwJHeDp000]
</code></pre>
<p>NB: Here's a bash script to convert a decimal number like 1000000000000000000 to the radix 64 representation above (this is NOT base64 encoding, it's just converting number formats).</p>
<pre class="lang-none prettyprint-override"><code>A=({0..9} {a..z} {A..Z} @ _)
for x in `bc&lt;&lt;&lt;&quot;obase=64;1000000000000000000&quot;`;{ printf ${A[x]};}
</code></pre>
</div>
<div id="pu1" class="pu"><p>More tips</p>

<ol>
<li>Abuse the ternary operator, <code>((test)) &amp;&amp; cmd1 || cmd2</code> or <code>[ test ] &amp;&amp; cmd1 || cmd2</code>, as much as possible.</li>
</ol>
<p>Examples (length counts always exclude the top line):</p>
<pre class="lang-sh prettyprint-override"><code>    t=&quot;$something&quot;
    if [ $t == &quot;hi&quot; ];then
    cmd1
    cmd2
    elif [ $t == &quot;bye&quot; ];then
    cmd3
    cmd4
    else
    cmd5
    if [ $t == &quot;sup&quot; ];then
    cmd6
    fi
    fi
</code></pre>
<p>By using ternary operators only, this can easily be shortened to:</p>
<pre class="lang-sh prettyprint-override"><code>    t=&quot;$something&quot;
    [ $t == &quot;hi&quot; ]&amp;&amp;{
    cmd1;cmd2
    }||[ $t == &quot;bye&quot; ]&amp;&amp;{
    cmd3;cmd4
    }||{
    cmd5
    [ $t == &quot;sup&quot; ]&amp;&amp;cmd6
    }
</code></pre>
<p>As nyuszika7h pointed out in the comments, this specific example could be shortened even further using <code>case</code>:</p>
<pre class="lang-sh prettyprint-override"><code>    t=&quot;$something&quot;
    case $t in &quot;hi&quot;)cmd1;cmd2;;&quot;bye&quot;)cmd3;cmd4;;*)cmd5;[ $t == &quot;sup&quot; ]&amp;&amp;cmd6;esac
</code></pre>
<ol>
<li><p>Also, prefer parentheses to braces as much as possible. Since parentheses are a metacharacter, and not a word, they never require spaces in any context. This also means run as many commands in a subshell as possible, because curly braces (i.e. <code>{</code> and <code>}</code>) are reserved words, not meta-characters, and thus have to have whitespace on both sides to parse correctly, but meta-characters don't. I assume that you know by now that subshells don't affect the parent environment, so assuming that all the example commands can safely be run in a subshell (which isn't typical in any case), you can shorten the above code to this:</p>
<pre class="lang-sh prettyprint-override"><code> t=$something
 [ $t == &quot;hi&quot; ]&amp;&amp;(cmd1;cmd2)||[ $t == &quot;bye&quot; ]&amp;&amp;(cmd3;cmd4)||(cmd5;[ $t == &quot;sup&quot; ]&amp;&amp;cmd6)
</code></pre>
</li>
</ol>
<p>Also, if you can't, using parentheses can still minify it some. One thing to keep in mind is that it only works for integers, which renders it useless for the purposes of this example (but it is much better than using <code>-eq</code> for integers).</p>
<ol>
<li><p>One more thing, avoid quotes where possible. Using that above advice, you can further minify it. Example:</p>
<pre class="lang-sh prettyprint-override"><code> t=$something
 [ $t == hi ]&amp;&amp;(cmd1;cmd2)||[ $t == bye ]&amp;&amp;(cmd3;cmd4)||(cmd5;[ $t == sup ]&amp;&amp;cmd6)
</code></pre>
</li>
<li><p>In testing conditions, prefer single brackets to double brackets as much as possible with a few exceptions. It drops two characters for free, but it isn't as robust in some cases (it's a Bash extension - see below for an example). Also, use the single equals argument rather than the double. It is a free character to drop.</p>
<pre class="lang-sh prettyprint-override"><code> [[ $f == b ]]&amp;&amp;: # ... &lt;-- Bad
 [ $f == b ]&amp;&amp;: # ... &lt;-- Better
 [ $f = b ]&amp;&amp;: # ... &lt;-- Best.  word splits and pathname-expands the contents of $f.  Esp. bad if it starts with -
</code></pre>
</li>
</ol>
<p>Note this caveat, especially in checking for null output or an undefined variable:</p>
<pre class="lang-sh prettyprint-override"><code>    [[ $f ]]&amp;&amp;:    # double quotes aren't needed inside [[, which can save chars
    [ &quot;$f&quot; = '' ]&amp;&amp;: &lt;-- This is significantly longer
    [ -n &quot;$f&quot; ]&amp;&amp;:
</code></pre>
<p>In all technicality, this specific example would be best with <code>case</code> ... <code>in</code>:</p>
<pre class="lang-sh prettyprint-override"><code>    t=$something
    case $t in hi)cmd1;cmd2;;bye)cmd3;cmd4;;*)cmd5;[ $t == sup ]&amp;&amp;cmd6;esac
</code></pre>
<p>So, the moral of this post is this:</p>
<ol>
<li>Abuse the boolean operators as much as possible, and <strong>always</strong> use them instead of <code>if</code>/<code>if-else</code>/etc. constructs.</li>
<li>Use parentheses as much as possible and run as many segments as possible in subshells because parentheses are meta-characters and not reserved words.</li>
<li>Avoid quotes as much as physically possible.</li>
<li>Check out <code>case</code> ... <code>in</code>, since it may save quite a few bytes, particularly in string matching.</li>
</ol>
<p>P.S.: Here's a list of meta-characters recognized in Bash regardless of context (and can separate words):</p>
<pre class="lang-sh prettyprint-override"><code>&lt; &gt; ( ) ; &amp; | &lt;space&gt; &lt;tab&gt;
</code></pre>
<hr />
<p>EDIT: As manatwork pointed out, the double parenthesis test only works for integers. Also, indirectly, I found that you need to have whitespace surrounding the <code>==</code> operator. Corrected my post above.</p>
<p>I also was too lazy to recalculate the length of each segment, so I simply removed them. It should be easy enough to find a string length calculator online if necessary.</p>
</div>
<div id="pu2" class="pu"><h4>Output a string based on a test string or numeric test with <code>expr</code></h4>
<p>From <a href="https://codegolf.stackexchange.com/q/258174/70305">my question</a>:
For any form of test <a href="https://www.man7.org/linux/man-pages/man1/expr.1.html" rel="nofollow noreferrer"><code>expr</code></a> supports (numerical or string equality, inequality, less than, greater than, regex pattern match, with support for math), there are often ways to use it to improve on the naive approach to echoing a particular string based on a given test. For example, the most straightforward approach to performing an &quot;is a program argument a substring of a fixed string?&quot; test, echoing the string <code>true</code> or <code>false</code> based on the result, assuming the substring contains no regex special characters, is:</p>
<pre><code>[[ FIXEDSTRING =~ $1 ]]&amp;&amp;echo true||echo false
</code></pre>
<p>But with <code>expr</code>, we can shave off six characters by careful use of <code>&amp;</code> and <code>|</code> to select the string that results from the overall test:</p>
<pre><code>expr true \&amp; FIXEDSTRING : .*$1 \| false
</code></pre>
<p>Changing the <code>*</code> to <code>\*</code> (and costing a character) if there is a possibility that the command will be run in a directory where <code>.*$1</code> would match existing files.</p>
<p>The ordering is important here; <code>\&amp;</code> evaluates to the <em>first</em> argument (not the second like in Python and similar language) when the overall &quot;and&quot; expression is true, so <code>true \&amp;</code> must come before the pattern match test <code>FIXEDSTRING : .*$1</code>. The <code>.*</code> is needed because pattern matching is implicitly anchored at the beginning, as with <code>^</code>, so the <code>.*</code> lets it match anywhere. And no, sadly, you can't remove any of these spaces; <code>expr</code> expects each operand and operator to be a completely separate argument, so it doesn't need to do any tokenizing of its own, which means the spaces must be there so the shell can tokenize it.</p>
<p>For the specific case of a regex match, you can shorten it four more characters with <code>sed</code>, :</p>
<pre><code>sed &quot;/$1/ctrue
cfalse&quot;&lt;&lt;&lt;FIXEDSTRING
</code></pre>
<p>Similar uses allow replacing the various forms of numerical test and echo:</p>
<pre><code>[ $1 -gt 0 ]&amp;&amp;echo yes||echo no
[[ $1&gt;0 ]]&amp;&amp;echo yes||echo no
(($1&gt;0))&amp;&amp;echo yes||echo no
</code></pre>
<p>with:</p>
<pre><code>expr yes \&amp; $1 \&gt; 0 \| no
</code></pre>
<p>which, even with the need to escape the <code>&gt;</code>, and despite numerical tests with <code>(())</code> allowing you to drop all whitespace, is still two characters shorter than the shortest of the naive approaches. If the comparison is more complex, you can mix-and-match:</p>
<pre><code>expr yes \&amp; $[$1&gt;0] \| no
</code></pre>
<p>is the same length as the purely <code>expr</code>-based approach, but grows more slowly in more complex cases (as fewer things need escaping, and spaces aren't needed between terms).</p>
</div>
<div id="pu3" class="pu"><h2><code>tr -cd</code> is shorter than <code>grep -o</code></h2>
<p>For example, if you need to count spaces, <code>grep -o &lt;char&gt;</code> (print only the matched) gives 10 bytes while <code>tr -cd &lt;char&gt;</code> (delete complement of <code>&lt;char&gt;</code>) gives 9.</p>
<pre><code># 16 bytes
grep -o \ |wc -l
# 15 bytes
tr -cd \ |wc -c
</code></pre>
<p>(<a href="https://codegolf.stackexchange.com/a/167212/41805" title="link to answer where tr is better than grep">source</a>)</p>
<p>Note that they both give slightly different outputs. <code>grep -o</code> returns line separated results while <code>tr -cd</code> gives them all on the same line, so <code>tr</code> might not always be favourable.</p>
</div>
<div id="pu4" class="pu"><h3>ONE-LINE CONDITIONAL SETTER</h3>
<p>NOTE: I see now that this first bit is already present on the first page, so I updated to add another tip (<em>below the phrase '<strong>EDIT-POINT:</strong>'</em>) which adds to the initial syntax to achieve a different outcome.</p>
<p>Here is a super efficient way to do control statements in bash.</p>
<p>instead of</p>
<pre><code>if [ -e &quot;${var}&quot; ]
then
   echo &quot;${var}&quot;
else
   echo &quot;empty&quot;
fi
</code></pre>
<p>which translates to the one-liner:</p>
<pre><code>if [ -e &quot;${var}&quot; ]; then echo &quot;${var}&quot;; else echo &quot;empty&quot;; fi
</code></pre>
<p>...you can use logical and / or like so:</p>
<pre><code>[ -e &quot;${var}&quot; ] &amp;&amp; echo &quot;${var}&quot; || echo &quot;empty&quot;
</code></pre>
<p>The second bit runs only if the first bit returns a <code>0</code> exit code. If either of the first two bits fail to exit with 0 (in other words, if false when used with <code>[] / test</code> command), the third bit runs. This means that in production / distribution use cases, this form is often a bad idea (if the <code>if</code> logic runs but fails fails, the <code>else</code> statement runs..), but for code golf, it is ore than sufficient, so long as you test it on the command line first.</p>
<p>It also works with the <code>if</code> / <code>&amp;&amp;</code> (no <code>else</code> / <code>||</code>), e.g.</p>
<pre><code>[ -e &quot;${var}&quot; ] &amp;&amp; echo &quot;${var}&quot;
</code></pre>
<p>if that is what you need. This version runs exactly as the long form, without the caveat mentioned above.</p>
<p><strong>EDIT-POINT:</strong></p>
<p>Another advantage of using this syntax is that you can put the entire command inside a variable. When you need to set a variable to a value that is based on a condition, this saves a lot of space.</p>
<p>For example,</p>
<pre><code>if [ -e &quot;${var}&quot; ]
then
   TEXT=&quot;${var}&quot;
else
    TEXT=&quot;empty&quot;
fi
</code></pre>
<p>can be dropped to:</p>
<pre><code>TEXT=$([ -e &quot;${var}&quot; ] &amp;&amp; echo &quot;${var}&quot; || echo &quot;empty&quot;)
</code></pre>
<p>As a code golf tip, this has limited uses, but they do exist. The space gained or lost depends on the size of the variable name. It adds up to the same as setting a four-letter variable (so ends in unity in the example above.)</p>
<p>Since we use single-letter variable names in code golf, this normally doesn't save any space at all. The space saving effect kicks in when we have no control over the name, in cases where we are using an environment variable in a cheeky way, or when a variable name is provided via a constraint in the question.</p>
</div>
<div id="pu5" class="pu"><h1>Know <code>grep</code> options</h1>
<p>See also <a href="https://man.archlinux.org/man/grep.1p.en" rel="nofollow noreferrer">man 1p grep</a> and <a href="https://www.gnu.org/software/grep/manual/html_node/Command_002dline-Options.html" rel="nofollow noreferrer">manual for GNU Grep</a>.</p>
<h2><code>grep -x foo</code> is equivalent to <code>grep '^foo$</code></h2>
<p>This is POSIX-compatible.</p>
<blockquote>
<p>Consider only input lines that use all characters in the line excluding the terminating &lt;newline&gt; to match an entire fixed string or regular expression to be matching lines.</p>
</blockquote>
<p>For example, the following two are equal:</p>
<blockquote>
<pre><code>grep -E '^abc$|^def$'
</code></pre>
</blockquote>
<blockquote>
<pre><code>grep -F -x 'abc
def'
</code></pre>
</blockquote>
</div>
<div id="pu6" class="pu"><h1>Use <code>$_</code> (the underscore variable)</h1>
<p>The special shell variable <code>$_</code> always contains the last argument to the most recently executed command. If you have any sort of immediate repetition in your code, it can probably be reduced with this.</p>
<pre><code>touch hello;cat hello
touch hello;cat $_
</code></pre>
<p>More details can be found in <a href="https://unix.stackexchange.com/q/377618">this</a> Unix &amp; Linux question.</p>
<p>(I can't believe this hasn't been posted before, and, as far as I can tell, barely ever even been <em>used</em> in code golf before!)</p>
</div>
<div id="pu7" class="pu"><h1>In Pure Bash (or any other pure shellscript), use <code>.</code> for looping.</h1>
<p>For example, if you want to display each value of 1^2, 2^2, 3^2, ..., 999^2, 1000^2,</p>
<pre class="lang-bash prettyprint-override"><code>echo $[++x*x]
((x&gt;999))||. x
</code></pre>
<p>(where filename is <code>x</code>) is shorter than</p>
<pre class="lang-bash prettyprint-override"><code>for((;x++&lt;1000;));{
echo $[x*x]
}
</code></pre>
<p><a href="https://tio.run/##S0oszvhfkpiZo6Cbp22soGJgV8GVWpGarJCaV6aQBJRUAPEL8otKFAIcQzxs/6cmZ@QrqERra1doVcRyaWhU2FlaWmpq1tToKVT8/w8A" rel="nofollow noreferrer" title="Bash – Try It Online">Try it online!</a></p>
</div>
<div id="pu8" class="pu"><h1>Abuse function definitions to check for equality</h1>
<p>If you want to check if two strings are equal to each other, the obvious way is to use the <code>[[</code>/<code>test</code>/<code>[</code> builtins:</p>
<pre class="lang-bash prettyprint-override"><code>[[ $a == b ]]
[[ $a = b ]]
[ $a = b ]
</code></pre>
<p>But in fact often a shorter way is to define a do-nothing function under the name of <code>b</code> and then try to call it with <code>$a</code>.</p>
<pre class="lang-bash prettyprint-override"><code>b()(:);$a
# zsh only:
b():;$a
</code></pre>
<p>Depending on the possible values <code>$a</code> can take, you might need to add some  characters to ensure that it never coincides with the name of a real command:</p>
<pre class="lang-bash prettyprint-override"><code>,b()(:);,$a
# zsh only:
,b();,$a
</code></pre>
<p>If you're testing and immediately using <code>&amp;&amp;</code>, then you can put generally put the command after the <code>&amp;&amp;</code> as the body of the function:</p>
<pre class="lang-bash prettyprint-override"><code>[ $a = b ]&amp;&amp;foo
b()(foo);$a
# zsh only:
b()foo;$a
</code></pre>
<p>Here are a few answers I've abused this in (Zsh not Bash, but the same idea applies):</p>
<ul>
<li><a href="https://codegolf.stackexchange.com/a/219018">https://codegolf.stackexchange.com/a/219018</a></li>
<li><a href="https://codegolf.stackexchange.com/a/219167">https://codegolf.stackexchange.com/a/219167</a></li>
</ul>

</div>
<div id="pu9" class="pu"><h1>Use <code>{..}</code> expansions with <code>eval</code></h1>
<p>Occasionally loops can be shortened by using <code>eval</code> with a brace expansion. For example, to run a command <code>foo</code> with all letters a-z sequentially; instead of:</p>
<pre class="lang-bash prettyprint-override"><code>for x in {a..z};{ foo $x;}
# or, zsh only:
for x ({a..z})foo $x
</code></pre>
<pre><code>eval foo\ {a..z}\;
# or, zsh only:
eval ';foo '{a..z}
</code></pre>
<p>If you need to reuse the loop variable, it tends to be shorter to use a normal for-loop though.</p>
<p>I can't remember exactly the first answer I saw to do this, <a href="https://codegolf.stackexchange.com/a/222723">but</a> <a href="https://codegolf.stackexchange.com/a/222782">I</a> <a href="https://codegolf.stackexchange.com/a/224833">now</a> <a href="https://codegolf.stackexchange.com/a/226210">use</a> <a href="https://codegolf.stackexchange.com/a/226028">it</a> <a href="https://codegolf.stackexchange.com/a/225508">a</a> <a href="https://codegolf.stackexchange.com/a/230405">lot</a> (those examples are all Zsh because it's obviously superior to Bash, but it's a similar general idea).</p>
</div>
<div id="pu10" class="pu"><p>To print a range of characters (shorter than <code>echo {a..z}|tr -d ' '</code>):</p>

<pre><code>printf "%s" {a..z}
</code></pre>

<p>Print range in reverse order (shorter than <code>printf "%s" {a..z}|rev</code>):</p>

<pre><code>printf "%s" {z..a}
</code></pre>
</div>
<div id="pu11" class="pu"><p>It is <strong>almost always</strong> better to receive input as arguments to a script or function instead of on stdin. Examples:</p>

<p><em>Input: a string</em>:</p>

<pre><code># == stdin ==
read a;echo $a
echo `&lt;&amp;0`
# == arguments ==
echo "$1"       # if $1 can have globbing characters/newlines/tabs
echo $1         # if $1 does not have any problematic characters
</code></pre>

<p><em>Input: a list of strings</em>:</p>

<pre><code># == stdin ==
while read s; do echo $s; done          # one-time use, split on newlines
read -a a;for s in ${a[@]};{echo $s;}   # read one line from stdin; splits on spaces
mapfile a;for s in "${a[@]}";{echo $s;} # read to EOF, split on newlines
# == arguments ==
for s;{ echo $s;}
</code></pre>

<p>The exception: a list of strings <strong>and</strong> other arguments:</p>

<pre><code>read i;while read s; do echo ${s[$i]}; done   # both on stdin
i=$1;shift;for s;{ echo ${s[$i]};}            # both as arguments
read i;for s;{ echo ${s[$i]};}                # list as arguments, other as stdin
</code></pre>

<p>Additionally, <code>read</code> will mangle backslashes without <code>-r</code>, and will stop on newlines without <code>-d ''</code>, making it even more expensive in worst case scenarios.</p>
</div>
<div id="pu12" class="pu"><h1>This work under simple shell</h1>

<pre><code>cd `mktemp -d` &amp;&amp;&gt;'c'a't'
ln -s /proc/loadavg /proc/uptime .
</code></pre>

<p>Then now</p>

<pre><code>procs=$(*)
echo $procs
0.30 0.08 0.03 1/612 31671 322787.60 1259967.99
</code></pre>

<p>Nota: Of course, <code>&gt;cat</code> could be written <code>&gt;$(echo -e \\0143\\0141t)</code></p>

<h2>Care, from there, you could encouter some issues due to Locales!</h2>

<p><strong>Goto last demo using <code>LC_ALL=C</code></strong></p>

<p>Same way:</p>

<pre><code>mv cat grep
mv loadavg Mem
ln -s /proc/meminfo Zdatas
rm uptime

mems=$(*)
echo $mems 
MemTotal: 16386788 kB MemFree: 9816320 kB MemAvailable: 12144892 kB
</code></pre>

<p>or worst...</p>

<pre><code>mv grep sed
mv Mem s+\\\(Mem\\\|Swap\\\).\*\:++p\;d
</code></pre>

<p>then</p>

<pre><code>memsw=$(*)
echo $memsw 
16386788 kB 9834080 kB 12163596 kB 0 kB 20971516 kB 20971516 kB
</code></pre>

<p>So simple is this!</p>

<pre><code>declare -p procs mems memsw
declare -- procs="0.14 0.12 0.05 1/612 32078
324221.56 1265616.26"
declare -- mems="MemTotal:       16386788 kB
MemFree:         9832212 kB
MemAvailable:   12161688 kB"
declare -- memsw="       16386788 kB
         9834080 kB
   12163596 kB
            0 kB
      20971516 kB
       20971516 kB"
</code></pre>

<h2>Last test using <code>LANG=C</code></h2>

<p>(or not)</p>

<pre><code>cd `mktemp -d` &amp;&amp;&gt;'c'a't'
ln -s /proc/meminfo zdatas
cp c* y+-+-+\;s+\\\(Mem\\\|Swap\\\).\*\:\ \*++p\;d
rename 'y/act/esd/' ???
*
</code></pre>

<p>may render something like</p>

<pre><code>378908 kB
31940 kB
217924 kB
0 kB
102396 kB
102396 kB
</code></pre>

<p>Or</p>

<pre><code>cd `mktemp -d`
ln -s +++\;s+\\\(Mem\\\|Swap\\\).\*\:\ \*++p\;d /proc/me*o ed .
rename 's/^/chr(113+(20&gt;length?1.3*length:8))/e' *
*
</code></pre>
</div>
<div id="pu13" class="pu"><h1>Changing behaviour of <code>+=</code> by setting <em>integer</em> flag</h1>

<p>Try this many times:</p>

<pre><code>unset i
i=1
for a in {1..10} ;do
    i+=1
    ((RANDOM%9)) || declare -i i
  done
echo $i
11117
</code></pre>

<p>or in one line</p>

<pre><code>unset i;i=1;for a in {1..10};do i+=1;((RANDOM%9))||declare -i i;done;echo $i
</code></pre>

<p>This could answer something between <code>20</code> to <code>11111111111</code>...</p>
</div>
<div id="pu14" class="pu"><p>In a case statement, it is valid to omit the last ';;' - which saves 2 bytes:</p>

<pre><code>#!/bin/sh

case $I in
0)cmdA;;
1)cmdB;;
*)cmdC
esac
</code></pre>
</div>
<div id="pu15" class="pu"><h1>One-line <code>for</code> loops</h1>

<p>An arithmetic expression concatenated with a range expansion will be evaluated for each item in the range. For example the following:</p>



<pre class="lang-sh prettyprint-override"><code>: $[expression]{0..9}
</code></pre>

<p>will evaluate <code>expression</code> 10 times.</p>

<p>This is often significantly shorter than the equivalent <code>for</code> loop:</p>

<pre class="lang-sh prettyprint-override"><code>for((;10&gt;n++;expression with n)){ :;}
: $[expression with ++n]{0..9}
</code></pre>

<p>If you don't mind command not found errors, you can remove the inital <code>:</code>. For iterations larger than 10, you can also use character ranges, for example <code>{A..z}</code> will iterate 58 times.</p>

<p>As a practical example, the following both produce the first 50 triangular numbers, each on their own line:</p>

<pre class="lang-sh prettyprint-override"><code>for((;50&gt;d++;)){ echo $[n+=d];} # 31 bytes
printf %d\\n $[n+=++d]{A..r}    # 28 bytes
</code></pre>
</div>
<div id="pu16" class="pu"><h1>Assign and Print quoted strings</h1>
<p>If you want to assign a quoted string to a variable, and then print the value of that variable, then the usual way to do that would be:</p>
<pre><code>a=&quot;Programming Puzzles &amp; Code Golf&quot;;echo $a
</code></pre>
<p>If <code>a</code> was previously unset, this may be shortened to:</p>
<pre><code>echo ${a=Programming Puzzles &amp; Code Golf}
</code></pre>
<p>If <code>a</code> was previously set, then this should be used instead:</p>
<pre><code>echo ${a+Programming Puzzles &amp; Code Golf}
</code></pre>
<p>Note this is only useful if the string requires quotes (e.g. contains whitespace).  Without quotes, <code>a=123;echo $a</code> is just as short.</p>
</div>
<div id="pu17" class="pu"><h1>Shorten file names</h1>

<p>In a recent challenge I was trying to read the file <code>/sys/class/power_supply/BAT1/capacity</code>, however this can be shortened to <code>/*/*/*/*/capac*y</code> as no other file exists with that format.</p>

<p>For example, if you had a directory <code>foo/</code> containing the files <code>foo, bar, foobar, barfoo</code> and you wanted to reference the file <code>foo/barfoo</code>, you can use <code>foo/barf*</code> to save a byte.</p>

<p>The <code>*</code> represents "anything", and is equivalent to the regex <code>.*</code>.</p>
</div>
<div id="pu18" class="pu"><p>Sometimes it is shorter to use the <code>expr</code> builtin for displaying the result of a simple arithmetic expression instead of the usual <code>echo $[ ]</code>.  For example:</p>

<pre><code>expr $1 % 2
</code></pre>

<p>is one byte shorter than:</p>

<pre><code>echo $[$1%2]
</code></pre>
</div>
<div id="pu19" class="pu"><h1>Alternative to cat</h1>

<p>Say you are trying to read a file and use it in something else. What you might do is:</p>

<pre><code>echo foo `cat bar`
</code></pre>

<p>If the contents of <code>bar</code> was <code>foobar</code>, this would print <code>foo foobar</code>.</p>

<p>However, there is an alternative if you are using this method, which saves 3 bytes:</p>

<pre><code>echo foo `&lt;bar`
</code></pre>
</div>
<div id="pu20" class="pu"><h1>Loop over arguments</h1>

<p>As noted in <a href="https://unix.stackexchange.com/q/417292/11630">Bash “for” loop without a “in foo bar…” part</a>, the <code>in "$@;"</code> in <code>for x in "$@;"</code> is redundant.</p>

<p>From <a href="https://tio.run/##S0oszvj/PyM1p0AhLb/o/38A" rel="noreferrer" title="Bash – Try It Online"><code>help for</code></a>:</p>

<pre><code>for: for NAME [in WORDS ... ] ; do COMMANDS; done
    Execute commands for each member in a list.

    The `for' loop executes a sequence of commands for each member in a
    list of items.  If `in WORDS ...;' is not present, then `in "$@"' is
    assumed.  For each element in WORDS, NAME is set to that element, and
    the COMMANDS are executed.

    Exit Status:
    Returns the status of the last command executed.
</code></pre>

<p>For example, if we want to square all numbers given positional arguments to a Bash script or a function, we can do this.</p>

<pre><code>for n;{ echo $[n*n];}
</code></pre>

<p><a href="https://tio.run/##S0oszvj/Py2/SCHPulohNTkjX0ElOk8rL9a69v///0ZG/42Njf@bAAEA" rel="noreferrer" title="Bash – Try It Online">Try it online!</a></p>
</div>
<div id="pu21" class="pu"><h2>Doing 2 embed loop with 1 <code>for</code> instruction:</h2>

<pre><code>for ((l=i=0;l&lt;=99;i=i&gt;98?l++,0:++i)) ;do
    printf "I: %2d, L: %2d\n" $i $l
done |
    tee &gt;(wc) | (head -n4;echo ...;tail -n 5)
I:  0, L:  0
I:  1, L:  0
I:  2, L:  0
I:  3, L:  0
...
I: 96, L: 99
I: 97, L: 99
I: 98, L: 99
I: 99, L: 99
  10000   40000  130000
</code></pre>
</div>
<div id="pu22" class="pu"><h2>Print the first word in a string</h2>
<p>If the string is in the variable <code>a</code> and doesn't contain escape and format characters (<code>\</code> and <code>%</code>), use this:</p>
<pre><code>printf $a
</code></pre>
<p>But it would be longer than the following code if it is needed to save the result into a variable instead of printing:</p>
<pre><code>x=($a)
$x
</code></pre>
</div>
<div id="pu23" class="pu"><p><strong><em>Undocumented</em></strong>, but works in every version I've run into for legacy <code>sh</code> backwards compatibility:</p>

<p><code>for</code> loops allow you to use <code>{</code> <code>}</code> instead of <code>do</code> <code>done</code>.  E.g. replace:</p>



<pre><code>for i in {1..10};do echo $i; done
</code></pre>

<p>with:</p>

<pre><code>for i in {1..10};{ echo $i;}
</code></pre>
</div>
<div id="pu24" class="pu"><p>When assigning noncontinuous array items, you can still skip the successive indices of continuous chunks:</p>

<pre><code>bash-4.4$ a=([1]=1 [2]=2 [3]=3 [21]=1 [22]=2 [23]=3 [31]=1)

bash-4.4$ b=([1]=1 2 3 [21]=1 2 3 [31]=1)
</code></pre>

<p>The result is the same:</p>

<pre><code>bash-4.4$ declare -p a b
declare -a a=([1]="1" [2]="2" [3]="3" [21]="1" [22]="2" [23]="3" [31]="1")
declare -a b=([1]="1" [2]="2" [3]="3" [21]="1" [22]="2" [23]="3" [31]="1")
</code></pre>

<p>According to <code>man bash</code>:</p>

<blockquote>
  <p>Arrays are assigned to using compound assignments of the form <em>name</em>=(value<i>1</i> ... value<i>n</i>), where each <em>value</em> is of the form [<em>subscript</em>]=<em>string</em>. Indexed array assignments do not require anything but  <em>string</em>. When assigning to indexed arrays, if the optional brackets and subscript are supplied, that index is assigned to; otherwise the index of the element assigned is the last index assigned to by the statement plus one.</p>
</blockquote>
</div>
<div id="pu25" class="pu"><p>
The normal, lengthy and boring way to define a function is</p>

<pre class="lang-sh prettyprint-override"><code>f(){ CODE;}
</code></pre>

<p>As <a href="//stackoverflow.com/q/21186724" title="Why is whitespace sometimes needed around metacharacters?">this guy</a> found out, you absolutely need the space before <code>CODE</code> and the semicolon after it.</p>

<p>This is a little trick I've learned from <a href="/users/11259">@DigitalTrauma</a>:</p>

<pre class="lang-sh prettyprint-override"><code>f()(CODE)
</code></pre>

<p>That is two characters shorter and it works just as well, provided that you don't need to carry over any changes in variables' values after the function returns (<a href="https://codegolf.stackexchange.com/a/20939">the parentheses run the body in a subshell</a>).</p>

<p>As <a href="https://codegolf.stackexchange.com/users/25180/user23013">@jimmy23013</a> points out in the comments, even the parentheses may be unnecessary.</p>

<p>The <a href="http://www.gnu.org/software/bash/manual/bashref.html#Shell-Functions" rel="noreferrer" title="Bash Reference Manual # 3.3 Shell Functions">Bash Reference Manual</a> shows that functions can be defined as follows:</p>

<blockquote>
<pre class="lang-sh prettyprint-override"><code>name () compound-command [ redirections ]
</code></pre>
  
  <p>or</p>

<pre class="lang-sh prettyprint-override"><code>function name [()] compound-command [ redirections ]
</code></pre>
</blockquote>

<p>A <a href="http://www.gnu.org/software/bash/manual/bashref.html#Compound-Commands" rel="noreferrer" title="Bash Reference Manual # 3.2.4 Compound Commands">compound command</a> can be:</p>

<ul>
<li>a Looping Construct: <code>until</code>, <code>while</code> or <code>for</code></li>
<li>a Conditional Construct: <code>if</code>, <code>case</code>, <code>((...))</code> or <code>[[...]]</code></li>
<li>Grouped Commands: <code>(...)</code> or <code>{...}</code></li>
</ul>

<p>That means all of the following are valid:</p>

<pre class="lang-sh prettyprint-override"><code>$ f()if $1;then $2;fi
$ f()($1&amp;&amp;$2)
$ f()(($1))                # This one lets you assign integer values
</code></pre>

<p>And I've been using curly brackets like a sucker...</p>
</div>
<div id="pu26" class="pu"><p>A shorter syntax for infinite loops (which can be escaped with <code>break</code> or <code>exit</code> statements) is</p>

<pre><code>for((;;)){ code;}
</code></pre>

<p>This is shorter than <code>while true;</code> and <code>while :;</code>.</p>

<p>If you don't need <code>break</code> (with <code>exit</code> as the only way to escape), you can use a recursive function instead.</p>

<pre><code>f(){ code;f;};f
</code></pre>

<p>If you do need break, but you don't need exit and you don't need to carry over any variable modification outside the loop, you can use a recursive function <a href="https://codegolf.stackexchange.com/a/20939">with parentheses around the body</a>, which run the function body in a subshell.</p>

<pre><code>f()(code;f);f
</code></pre>
</div>
<div id="pu27" class="pu"><h1>Alternatives to <code>head</code></h1>

<p><code>line</code> is three bytes shorter than <code>head -1</code>, but is being <a href="https://git.kernel.org/cgit/utils/util-linux/util-linux.git/tree/Documentation/deprecated.txt#n57" rel="nofollow noreferrer">deprecated</a>.</p>

<p><code>sed q</code> is two bytes shorter than <code>head -1</code>.</p>

<p><code>sed 9q</code> is one byte shorter than <code>head -9</code>.</p>
</div>
<div id="pu28" class="pu"><h3>Use arithmetic <code>(( ... ))</code> for conditions</h3>

<p>You could replace:</p>

<pre><code>if [ $i -gt 5 ] ; then
    echo Do something with i greater than 5
fi
</code></pre>

<p>by</p>

<pre><code>if((i&gt;5));then
    echo Do something with i greater than 5
fi
</code></pre>

<p>(Note: There is no space after <code>if</code>)</p>

<p>or even</p>

<pre><code>((i&gt;5))&amp;&amp;{
    echo Do something with i greater than 5
}
</code></pre>

<p>... or if only one command</p>

<pre><code>((i&gt;5))&amp;&amp;echo Echo or do something with i greater than 5
</code></pre>

<h3>Further: Hide variable setting in arithmetic construct:</h3>

<pre><code>((i&gt;5?c=1:0))&amp;&amp;echo Nothing relevant there...
# ...
((c))&amp;&amp;echo Doing something else if i was greater than 5
</code></pre>

<p>or same</p>

<pre><code>((c=i&gt;5?c=0,1:0))&amp;&amp;echo Nothing relevant there...
# ...
((c))&amp;&amp;echo Doing something else if i was greater than 5
</code></pre>

<p>... where <em>if i > 5, then c = 1</em> (not 0;)</p>
</div>
<div id="pu29" class="pu"><p>Use tail recursion to make loops shorter:</p>

<p>These are equivalent in behavior (though probably not in memory/PID usage):</p>

<pre><code>while :;do body; done
f()(body;f);f
body;exec $0
body;$0
</code></pre>

<p>And these are roughly equivalent:</p>

<pre><code>while condition; do body; done
f()(body;condition&amp;&amp;f);f
body;condition&amp;&amp;exec $0
body;condition&amp;&amp;$0
</code></pre>

<p>(technically the last three will always execute the body at least once)</p>

<p>Using <code>$0</code> requires your script to be in a file, not pasted into the bash prompt.</p>

<p>Eventually your stack might overflow, but you save some bytes.</p>
</div>
<div id="pu30" class="pu"><p>Quotes can be omitted when printing strings.</p>

<pre><code>echo "example"
echo example
</code></pre>

<p>Output in SM-T335 LTE, Android 5.1.1:</p>

<pre><code>u0_a177@milletlte:/ $ echo "example"
example
u0_a177@milletlte:/ $ echo example
example
</code></pre>
</div>
<div id="pu31" class="pu"><h1>Use <code>pwd</code> instead of <code>echo</code> to generate a line of output</h1>

<p>Need to put a line on stdout but don't care about the contents, and want to restrict your answer to shell builtins? <code>pwd</code> is a byte shorter than <code>echo</code>.</p>
</div>
<div id="pu32" class="pu"><h3>Expand away the tests</h3>
<p>Essentially, the shell is a kind of macro language, or at least a hybrid or some kind. Every command-line can be basically broken into two parts: the parsing/input part and the expansion/output part.</p>
<p>The first part is what most people focus on because it's the most simple: you see what you get. The second part is what many avoid ever even trying to understand very well and is why people say things like <em><code>eval</code> is evil</em> and <em>always quote your expansions</em> - people want the result of the first part to equal the first. That's ok - but it leads to unnecessarily long code branches and tons of extraneous testing.</p>
<p>Expansions are <em>self-testing</em>. The <em><code>${param[[:]#%+-=?]word}</code></em> forms are more than enough to validate the contents of a parameter, are nestable, and are all based around evaluating for <em>NUL</em> - which is what most people expect of tests anyway. <code>+</code> can be especially handy in loops:</p>
<pre><code>r()while IFS= read -r r&amp;&amp;&quot;${r:+set}&quot; -- &quot;$@&quot; &quot;${r:=$*}&quot;;do :;done 2&gt;&amp;-

IFS=x
printf %s\\n some lines\ of input here '' some more|{ r;echo &quot;$r&quot;; }
</code></pre>
<hr />
<pre><code>somexlines ofxinputxhere
</code></pre>
<p>...while <code>read</code> pulls in not blank lines <code>&quot;${r:+set}&quot;</code> expands to <code>&quot;set&quot;</code> and the positionals get <code>$r</code> appended. But when a blank line is <code>read</code>, <code>$r</code> is empty and <code>&quot;${r:+set}&quot;</code> expands to <code>&quot;&quot;</code> - which is an invalid command. But because the command-line is expanded <em>before</em> the <code>&quot;&quot;</code> null command is searched, <code>&quot;${r:=$*}&quot;</code> takes the values of all of the positionals concatenated on the first byte in <code>$IFS</code> as well. <code>r()</code> could be called again in <code>|{</code> compound command <code>;}</code> w/ a different value for <code>$IFS</code> to get the next input paragraph as well, since it is illegal for a shell's <code>read</code> to buffer beyond the next <code>\n</code>ewline in input.</p>
</div>
<div id="pu33" class="pu"><h1>Use <code>if</code> to group commands</h1>
<p>Compared to <a href="https://codegolf.stackexchange.com/a/20939/25180">this tip</a> which removes the <code>if</code> at all, this should only work better in some very rare cases, such as when you need the return values from the <code>if</code>.</p>
<p>If you have a command group which ends with a <code>if</code>, like these:</p>
<pre><code>a&amp;&amp;{ b;if c;then d;else e;fi;}
a&amp;&amp;(b;if c;then d;else e;fi)
</code></pre>
<p>You can wrap the commands before <code>if</code> in the condition instead:</p>
<pre><code>a&amp;&amp;if b;c;then d;else e;fi
</code></pre>
<p>Or if your function ends with a <code>if</code>:</p>
<pre><code>f(){ a;if b;then c;else d;fi;}
</code></pre>
<p>You can remove the braces:</p>
<pre><code>f()if a;b;then c;else d;fi
</code></pre>
</div>
<div id="pu34" class="pu"><p>If you need to pass the content of a variable to STDIN of the next process in a pipeline, it is common to echo the variable into a pipeline.  But you can achieve the same thing with a <code>&lt;&lt;&lt;</code> <a href="http://www.gnu.org/software/bash/manual/bashref.html#Here-Strings" rel="noreferrer">bash here string</a>:</p>

<pre><code>$ s="code golf"
$ echo "$s"|cut -b4-6
e g
$ cut -b4-6&lt;&lt;&lt;"$s"
e g
$ 
</code></pre>
</div>
<div id="pu35" class="pu"><p>Element 0 of an array may be accessed with the variable name only, a five byte saving over explicitly specifying an index of 0:</p>

<pre><code>$ a=(code golf)
$ echo ${a[0]}
code
$ echo $a
code
$ 
</code></pre>
</div>
<div id="pu36" class="pu"><p><code>split</code> has another (deprecated, but nobody cares) syntax for splitting input into sections of <code>N</code> lines each: instead of <code>split -lN</code> you can use <code>split -N</code> e.g. <code>split -9</code>.</p>
</div>
<div id="pu37" class="pu"><p>Avoid <code>$( ...command... )</code>, there is an alternative which saves one char and does the same thing:</p>

<pre><code>` ...command... `
</code></pre>
</div>
<div id="pu38" class="pu"><p>Use a pipe to the <code>:</code> command instead of <code>/dev/null</code>. The <code>:</code> built-in will eat all its input.</p>
</div>
<div id="pu39" class="pu"><h1>Use <code>[</code> instead of <code>[[</code> and <code>test</code> when possible</h1>

<p><strong>Example:</strong></p>

<pre><code>[ -n $x ]
</code></pre>

<p><br></p>

<h1>Use <code>=</code> instead of <code>==</code> for comparison</h1>

<p><strong>Example:</strong></p>

<pre><code>[ $x = y ]
</code></pre>

<p>Note that you <strong>must</strong> have spaces around the equals sign or else it won't work. Same applies to <code>==</code> based on my tests.</p>
</div>
<div id="pu40" class="pu"><p>Instead of <code>grep -E</code>, <code>grep -F</code>, <code>grep -r</code>, use <code>egrep</code>, <code>fgrep</code>, <code>rgrep</code>, saving two chars. The shorter ones are deprecated but work fine.</p>

<p>(You did ask for one tip per answer!)</p>
</div>
<div id="pu41" class="pu"><p><code>:</code> is a command that does nothing, its exit status always succeeds, so it can be used instead of <code>true</code>.</p>
</div>
<div id="pu42" class="pu"><p>For arithmetic expansion use <code>$[…]</code> instead of <code>$((…))</code>:</p>

<pre><code>bash-4.1$ echo $((1+2*3))
7

bash-4.1$ echo $[1+2*3]
7
</code></pre>

<p>In arithmetic expansions don't use <code>$</code>:</p>

<pre><code>bash-4.1$ a=1 b=2 c=3

bash-4.1$ echo $[$a+$b*$c]
7

bash-4.1$ echo $[a+b*c]
7
</code></pre>

<p>Arithmetic expansion is performed on indexed array subscripts, so don't use <code>$</code> neither there:</p>

<pre><code>bash-4.1$ a=(1 2 3) b=2 c=3

bash-4.1$ echo ${a[$c-$b]}
2

bash-4.1$ echo ${a[c-b]}
2
</code></pre>

<p>In arithmetic expansions don't use <code>${…}</code>:</p>

<pre><code>bash-4.1$ a=(1 2 3)

bash-4.1$ echo $[${a[0]}+${a[1]}*${a[2]}]
7

bash-4.1$ echo $[a[0]+a[1]*a[2]]
7
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/15279/">15279</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




