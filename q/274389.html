<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::274389</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>026</td><td>Haskell + hgl</td><td>240724T135452Z</td><td><a href="https://codegolf.stackexchange.com/questions/274389/reduce-a-string-up-to-idempotency/274410#274410">Wheat Wi</a></td></tr>
<tr d-ix="1"><td>016</td><td>sed 4.2.2</td><td>240725T052036Z</td><td><a href="https://codegolf.stackexchange.com/questions/274389/reduce-a-string-up-to-idempotency/274428#274428">Digital </a></td></tr>
<tr d-ix="2"><td>043</td><td>JavaScript ES6</td><td>240724T081140Z</td><td><a href="https://codegolf.stackexchange.com/questions/274389/reduce-a-string-up-to-idempotency/274391#274391">Arnauld</a></td></tr>
<tr d-ix="3"><td>082</td><td>Python 3.8 prerelease</td><td>240724T095658Z</td><td><a href="https://codegolf.stackexchange.com/questions/274389/reduce-a-string-up-to-idempotency/274399#274399">Jitse</a></td></tr>
<tr d-ix="4"><td>030</td><td>Charcoal</td><td>240725T083936Z</td><td><a href="https://codegolf.stackexchange.com/questions/274389/reduce-a-string-up-to-idempotency/274432#274432">Neil</a></td></tr>
<tr d-ix="5"><td>105</td><td>Setanta</td><td>240725T071331Z</td><td><a href="https://codegolf.stackexchange.com/questions/274389/reduce-a-string-up-to-idempotency/274430#274430">bb94</a></td></tr>
<tr d-ix="6"><td>029</td><td>Wolfram Language Mathematica</td><td>240724T225458Z</td><td><a href="https://codegolf.stackexchange.com/questions/274389/reduce-a-string-up-to-idempotency/274424#274424">att</a></td></tr>
<tr d-ix="7"><td>008</td><td>Nekomata</td><td>240725T021308Z</td><td><a href="https://codegolf.stackexchange.com/questions/274389/reduce-a-string-up-to-idempotency/274425#274425">alephalp</a></td></tr>
<tr d-ix="8"><td>009</td><td>QuadR ≡</td><td>240724T085533Z</td><td><a href="https://codegolf.stackexchange.com/questions/274389/reduce-a-string-up-to-idempotency/274394#274394">Ad&#225;</a></td></tr>
<tr d-ix="9"><td>014</td><td>Brachylog</td><td>240724T223135Z</td><td><a href="https://codegolf.stackexchange.com/questions/274389/reduce-a-string-up-to-idempotency/274422#274422">Unrelate</a></td></tr>
<tr d-ix="10"><td>018</td><td>Perl 5 + pl</td><td>240724T205349Z</td><td><a href="https://codegolf.stackexchange.com/questions/274389/reduce-a-string-up-to-idempotency/274421#274421">Dom Hast</a></td></tr>
<tr d-ix="11"><td>015</td><td>Brachylog</td><td>240724T203657Z</td><td><a href="https://codegolf.stackexchange.com/questions/274389/reduce-a-string-up-to-idempotency/274420#274420">DLosc</a></td></tr>
<tr d-ix="12"><td>011</td><td>Retina 0.8.2</td><td>240724T173832Z</td><td><a href="https://codegolf.stackexchange.com/questions/274389/reduce-a-string-up-to-idempotency/274417#274417">Neil</a></td></tr>
<tr d-ix="13"><td>048</td><td>R</td><td>240724T103921Z</td><td><a href="https://codegolf.stackexchange.com/questions/274389/reduce-a-string-up-to-idempotency/274402#274402">pajonk</a></td></tr>
<tr d-ix="14"><td>010</td><td>Japt</td><td>240724T093257Z</td><td><a href="https://codegolf.stackexchange.com/questions/274389/reduce-a-string-up-to-idempotency/274397#274397">Shaggy</a></td></tr>
<tr d-ix="15"><td>008</td><td>05AB1E legacy</td><td>240724T083148Z</td><td><a href="https://codegolf.stackexchange.com/questions/274389/reduce-a-string-up-to-idempotency/274393#274393">Kevin Cr</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.haskell.org" rel="nofollow noreferrer">Haskell</a> + <a href="https://gitlab.com/wheatwizard/haskell-golfing-library" rel="nofollow noreferrer">hgl</a>, 26 bytes</h1>
<pre><code>yyc$sk$h_&gt;~l2 aT(mY&lt;xys)ʃ
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m708I7E4OzUnZ8FNxczcgvyiEoXC0sSczLTM1BSFgKLUnNKUVC6oRMDS0pI0XYs9abaVlckqxdkqGfF2dTlGCokhGrmRNhWVxZqnmiFKbk7OTczMU7BVSMnnUlDIjVfQKChSsFFI0wTyFBSiFZQSlcAsHSALiZkEhEgSQB4QI0tj8MEIXUsyiEZiQORjIU5bsABCAwA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>This uses the <a href="https://codegolf.stackexchange.com/questions/274389/reduce-a-string-up-to-idempotency/274410#comment590952_274389">adapted rule from Nitrodon</a>, which has not been proven correct, but at least has not been proven incorrect.</p>
<h2>Explanation</h2>
<ul>
<li><code>yyc</code>: Repeat a function until reaching a fixed point.</li>
<li><code>sk</code>: Replace all matches of a parser with their results.</li>
<li><code>h_</code>: Parse some string.</li>
<li><code>&gt;~</code>: Feed the result of that parse into a function to create a second parse.</li>
<li><code>mY&lt;xys</code>: Parse some number of characters from the input</li>
<li><code>aT</code>: Ignore the result of that and give the result of ...</li>
<li><code>ʃ</code>: Parse the input string and return it.</li>
</ul>
<p>This finds occurrences of <code>xyx</code> where <code>y</code> is made up of a subset of the characters of <code>x</code>, and replaces them with <code>x</code> until a fixed point is reached. <code>y</code> can potentially be empty here.</p>
<h1>Reflection</h1>
<p>This is ok. I'm not too happy with it but I initially expected much worse. This really has more of a glue problem than anything else.</p>
<ul>
<li>I could add <code>l2 aT</code> and <code>l2 aK</code>, they will probably be used again sometime.</li>
<li>I have <code>(?*&gt;)</code> and <code>(&lt;*?)</code> for <code>aT&lt;py</code> and <code>aK^.py</code> and <code>(+*&gt;)</code> and <code>(&lt;*+)</code> for <code>aT&lt;so</code> and <code>aK^.so</code>. I could use <code>(**&gt;) = aT&lt;my</code> and <code>(&lt;**) = aK^.py</code>.</li>
</ul>
<p>The above are minor fixes, but I think the thing that would <em>really</em> fix the glue problem is having a version of <code>(&gt;~)</code> which just returns the result from the left-hand side instead of the right hand-side. So:</p>
<pre><code>(&lt;~) =
  f' $ fb &lt; ap pM
</code></pre>
<p>In which case this could look like:</p>
<pre><code>yyc$sk$h_&lt;~(mY&lt;xys)&gt;~ʃ
</code></pre>
<p>Although this wouldn't make this answer shorter than implementing either of the above, this does seem like the solution lightest on the glue and an operation which has a large reuse potential</p>
<h1>Old versions</h1>
<p>Here are some old versions which use the incorrect algorithm given in the question and currently used by all the other answers:</p>
<h2>Parser, <s>21</s> 13 bytes</h2>
<pre><code>yyc$sk$h_&gt;~ʃ
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m708I7E4OzUnZ8FNxczcgvyiEoXC0sSczLTM1BSFgKLUnNKUVC6oRMDS0pI0XYv1abaVlckqxdkqGfF2daeaIaI3J-cmZuYp2Cqk5HMpKOTGK2gUFCnYKKRpAnkKCtEKSolKYJYOkIXETAJCJAkgD4iRpTH4YISuJRlEIzEg8rEQpy1YAKEB" rel="nofollow noreferrer">Attempt This Online!</a></p>
<h3>Explanation</h3>
<ul>
<li><code>yyc</code>: Repeat until reaching a fixed point.</li>
<li><code>sk</code>: Apply a parser as many times as possible to substrings.</li>
<li><code>h_&gt;~ʃ</code>: Parse some string twice. This returns the parsed string only once.</li>
</ul>
<h2>No parser, 21 bytes</h2>
<pre><code>yyc$mBl&lt;(he~&lt;&lt;gr)&lt;&lt;pt
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m708I7E4OzUnZ8FNxczcgvyiEoXC0sSczLTM1BSFgKLUnNKUVC6oRMDS0pI0XYvtabaVlckquU45NhoZqXU2NulFmjY2BSUQ2Zs9uYmZeQq2Cin5XAoKufEKGgVFCjYKaZpAnoJCtIJSohKYpQNkITGTgBBJAsgDYmRpDD4YoYgkg9QkAakkmEQsxE0LFkBoAA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<h3>Explanation</h3>
<ul>
<li><code>yyc</code>: Repeat until reaching a fixed point.</li>
<li><code>pt</code>: Get all partitions.</li>
<li><code>gr</code>: Group each partition into groups of contiguous equal elements.</li>
<li><code>he</code>: Get the first element of each group.</li>
<li><code>mBl</code>: Get the smallest result.</li>
</ul>
<h2>Reflection</h2>
<p>Although I only have two versions of this answer I am splitting the reflection into three based on three <em>potential</em> solutions to this challenge.</p>
<h2>Parser version</h2>
<p>I am happy with the parser version. I was annoyed by the operator precedence between <code>(~&lt;)</code> and <code>(#|)</code>/<code>(++)</code> in the original version of the answer, but I'm not sure it's actually wrong in general, and now it's no longer a problem.</p>
<p>In the interest in coming up with <em>something</em> to improve here:</p>
<ul>
<li>Maybe <code>yyc&lt;sk</code> could have a builtin? I think this idiom of &quot;apply a parser repeatedly to substrings until reaching a fixed point&quot; could come up again. I just really kind of don't like making more parser consumers.</li>
<li>Weird as it is, I think <code>fb ʃ</code> could have a builtin. This isn't the first time I've used it, you can also use it for things like palindrome checking. Although I don't think it's useful enough to justify a 2 byte name and with a 3 byte name it wouldn't even save anything here.</li>
</ul>
<h2>Regex version</h2>
<p>I don't think I could reasonably do this with regex right now, since I haven't implemented back-referencing yet. This is just yet another push to do that.</p>
<h2>Non-parser version</h2>
<p>I am rather frustrated with trying to build a non-parser version here. There is a lot to improve on this front.</p>
<ul>
<li>A contiguous nub function would be useful.</li>
<li>I would like an &quot;unpairs&quot; function that basically undoes what <code>pA</code> does.</li>
<li><code>sps</code> finds all the splits into two pieces. But here I'd like all partitions into <em>3</em> pieces. It'd be good to have builtin which takes a number, <span class="math-container">\$n\$</span>, and finds all the partitions into <span class="math-container">\$n\$</span> pieces, with presets for small numbers like 3. <code>pST eL3</code> almost does what I want, but it returns a list which is a bit annoying. It's also inefficient and 7 bytes long.</li>
</ul>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.gnu.org/software/sed/" rel="nofollow noreferrer">sed 4.2.2</a>, 16</h1>
<pre><code>:
s/(.+)\1/\1/
t
</code></pre>
<ul>
<li>-1 byte thanks to @Neil .</li>
</ul>
<p><a href="https://tio.run/##NYaxCsIwGIT3e4tsSjAx6qBSGjo4dOqikMFNgymiv5AMccmjG/@Cct99d9Ffa90j6pmS87PRDFKtyMjMG0JYSC01jOSwV@xSCo7BMw@k4NO0l@F0C3C961yH/rcuw@y2y/WGgVJKTP0fi4HugmvRUNsQtR96pZGesS4OXw" rel="nofollow noreferrer" title="sed 4.2.2 – Try It Online">Try it online!</a></p>
</div>
<div id="pu2" class="pu"><h1>JavaScript (ES6), 43 bytes</h1>
<p><em>-2 thanks to <a href="https://codegolf.stackexchange.com/users/76323/l4m2">@l4m2</a></em></p>

<pre class="lang-javascript prettyprint-override"><code>f=s=&gt;s==(s=s.replace(/(.+)\1/,&quot;$1&quot;))?s:f(s)
</code></pre>
<p><a href="https://tio.run/##bZLBToMwGMfve4quMQECFqcedFshO3jYaRdNSCYHwrqh4jpoY2aMPIGJF4/6Hj7PXsBHwA5oC05o4fv39/3b7yPcR08Ri/O7DT9e0wUpyyVm2GMYmwwzlJNNGsXEdE1kW7cD14FHA2hZPhsuTWaVo3kPgDmAEKjLaavQqfkWtrlWiuul//lzhysleb/vQ821kNx2bRcqrmLFB7a4oeQqbvHTDpdK8qIoWucXB/VfJ0SMR1hzGWrOE8I15wc8nt2sEnW@VpIH02ASTGDD96rrn@oEZ68mf/oLOt9fK9X/5cXJ2bkYsOq/UrDFEUL9/YSVv3p3/A33JUd@t74ZfeiL2XCtJB9Tb0yp19Q/rqOWX8BMZGSZByueNQlhL@yhJc2vojgxzTlgPHcA2W5IzMkChBbAHngRW6SEg5wwgIH4rXlujcRaTNeMpgSldGVWPpHg1FlY7@ED4@f7fff5IZ4GGAJj9/VmCP@rNSp/AQ" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
</div>
<div id="pu3" class="pu"><h1><a href="https://docs.python.org/3.8/" rel="nofollow noreferrer">Python 3.8 (pre-release)</a>, 82 bytes</h1>

<pre class="lang-python prettyprint-override"><code>lambda s:(n:=len(s))==[s:=s.replace((x:=s[i%n:i%~n])+x,x)for i in range(n**3)]or s
</code></pre>
<p><a href="https://tio.run/##XY9fb4IwFMXf@RSlibEVhn/YgyMW46NPvmwJiTMLcyhkWCrtEnzhq7PbFpkZtNxzfvc09IqbyiseLkXdndh7V6aXz68UyYjwiJUZJ5JSxvYyYjKoM1Gmx4yQBty@GPGoGLX8QL3Gb@ipqlGBCo7qlJ8zwieTkB6Ayc50uPDRh4@qH6Uzl1QQqepAirJQQAX8aEZp5CCb1DFmUsN9ZAAHCkHGeEx9RO4xSuFMnUlkHoZOuqOZqAuuiO4wpoO@TtEOY/QUI4wd3FjVaPmob72@gXHdtXVQHexNvam1UB089@C1XgsNFn9gYVDbtha0YF7zDNbFAqMcrPJMDUxZdty9nXNLrHRwsk02ycYyrQFtH5lFST9HogeZvyxn4TOs/kbGAg@CwNXbYqgDWt9RoKfdVd8u7B4OzsGrqqpi@MS2swJhYGwa/@AV6PU6UFC/" rel="nofollow noreferrer" title="Python 3.8 (pre-release) – Try It Online">Try it online!</a></p>
<p>-14 bytes thanks to xnor</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 30 bytes</h1>
<pre><code>Ｗ⌈ΦＥθ⌈ΦＥλ✂θμλ¹№θ×²μκ≔⪫⪪θ×²ιιθθ
</code></pre>
<p><a href="https://tio.run/##bUzLCsIwELz7FXvcQDzotaUgggehINQfCCHYxU3aJq0KId8ek6PgwAzMg9Gj8npSnPN7JDaAvfqQ3SxeiFfji51xkfAnZQkDkza1thKKPQgh4Txtbq3ZnawJeCylqJDwLAqnEOjh8DqRw2Fm@p1S3VHhIprdzVN9Ek3ObYypa2NKXd6/@As" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Explanation:</p>
<pre><code>Ｗ⌈ΦＥθ⌈ΦＥλ✂θμλ¹№θ×²μκ
</code></pre>
<p>While there are substrings of the input that appear doubled in the input, take the maximum, and...</p>
<pre><code>≔⪫⪪θ×²ιιθ
</code></pre>
<p>... deduplicate that substring from the input.</p>
<pre><code>θ
</code></pre>
<p>Output the finally reduced string.</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://try-setanta.ie" rel="nofollow noreferrer">Setanta</a>, 105 bytes</h1>
<pre><code>gniomh(s){le t idir(0,fad@s)le j idir(1,fad@s+1)le i idir(0,j){t=cuid@s(i,j)s=athchuir@s(t+t,t)}toradh s}
</code></pre>
<p><a href="https://try-setanta.ie/editor/EhEKBlNjcmlwdBCAgIDIiL2cCw" rel="nofollow noreferrer">Try on try-setanta.ie</a></p>
</div>
<div id="pu6" class="pu"><h1><a href="https://www.wolfram.com/wolframscript/" rel="nofollow noreferrer">Wolfram Language (Mathematica)</a>, <s>31</s> 29 bytes</h1>
<pre><code>f[a___,b__,b__,c___]=f[a,b,c]
</code></pre>
<p><a href="https://tio.run/##TdDBaoNAEAbgu0@hYyktbkxje2ghNRtKDzmlYAqCiGzERGl1RbdgLr66nXWsDe4y//@B4FgKlWelUEUqhuEUiSRJ2HG6KZb4FZEdWRoPH01Rqche@CfO33LRiFRlTcttBuYdMNtjcA/xLef8IN@7usnatpAVDxS@dg7q70JFN0HaFLXaVfWPImdgQDwAmAvfBMwdpU7H63yZ8gWLZW2o4TTAWTpLqjgNWDn4UNdBg/cP3kh93xP0WA55hqckGJMB@EvUbIos3X@ecxKKBoS7cBtuyXRG2l0bUTjtEepFVi/PD49PeKYvGiu667qWvsQ4Z9r8kau33csvC@@EczNgLf21lD45FvgF" rel="nofollow noreferrer" title="Wolfram Language (Mathematica) – Try It Online">Try it online!</a></p>
<p>Input <code>[characters...]</code>. Return the characters of the reduced string, wrapped in <code>f</code>.</p>
<p><a href="https://reference.wolfram.com/language/ref/NonCommutativeMultiply.html" rel="nofollow noreferrer"><code>NonCommutativeMultiply</code> (<code>**</code>)</a> is a conveniently <a href="https://reference.wolfram.com/language/ref/Flat.html" rel="nofollow noreferrer"><code>Flat</code></a> <a href="https://codegolf.stackexchange.com/a/82740">undefined operator</a>. Unfortunately, it needs to be <a href="https://reference.wolfram.com/language/ref/Unprotect.html" rel="nofollow noreferrer"><code>Unprotect</code></a>ed before we can add a definition. <a href="https://tio.run/##TZBNa8JAEIbv@yvMpEgbY6y2hxY0rkgPHtSCCgERCSGaUJMNyaToJX89zjqplf2Y531gYGcTH6Mw8TEO/HqTZrnCMEAJC2tqzS2o/f3esugamWZ7uyOsD6OFSqcqSUqkrt9wXp4wzk4X8Z3HKW7NrnuQchr5uR9gmBfStKH1DLY5sOEFdm0p5Vp9nbM8LIpYpXKF1HZcZacYt0@rII8znKVZiextELCrAVpdtwXEZ6azxke@NHyhYBhjTlQFdHqdHkeqAvodWpw1aDH4F4ObqqqKRUVhHYW0ExY3EkA/hneH7ILl5hixYRTgzbyJN2GnmdTs0bHymjk8PUj/8@P17Z1286JbJO84jqEPa6p3Nf5Tjp52qX4MOo28JwFD5Q6VctlTgCs" rel="nofollow noreferrer" title="Wolfram Language (Mathematica) – Try It Online">Try it online!</a></p>
</div>
<div id="pu7" class="pu"><h1><a href="https://github.com/AlephAlpha/Nekomata" rel="nofollow noreferrer">Nekomata</a>, 8 bytes</h1>
<pre><code>ʷ{JYᵗƶ¿j
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m70iLzU7PzexJHFNtJJurpKOgpKuoVLsgqWlJWm6FmtPba_2iny4dfqxbYf2Zy0pTkouhsosuDlPSYlLqQKEwUQlkFBUtAeS2vra-kDKUBsIwbQRmK6rqwOSIRmpQJQLZJVkpJZAWMn-oekZQDrCM8IxwhHI8ISzIkBmG1paGBibABGQraenpwjCCCbISv_8bEUgBjFt8u1s8vPtlCDOBAA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<pre><code>ʷ{JYᵗƶ¿j
ʷ{          Loop until failure:
  J             Nondeterministically split the input into parts
                e.g. &quot;QUAQUAUAL&quot; may become [&quot;QUA&quot;, &quot;QUA&quot;, &quot;UA&quot;, &quot;L&quot;]
   Y            Run length encode
                e.g. [&quot;QUA&quot;, &quot;QUA&quot;, &quot;UA&quot;, &quot;L&quot;] -&gt; [&quot;QUA&quot;, &quot;UA&quot;, &quot;L&quot;], [2, 1, 1]
    ᵗƶ          Check that at least one count is greater than 1
                e.g. [2, 1, 1] passes
      ¿         If the check passes, drop the counts; otherwise fail
                e.g. [&quot;QUA&quot;, &quot;UA&quot;, &quot;L&quot;], [2, 1, 1] -&gt; [&quot;QUA&quot;, &quot;UA&quot;, &quot;L&quot;]
       j        Join
                e.g. [&quot;QUA&quot;, &quot;UA&quot;, &quot;L&quot;] -&gt; &quot;QUAUAL&quot;
</code></pre>
<p>This may output the same result multiple times. You can add the <code>-1</code> flag to only output the first result.</p>
</div>
<div id="pu8" class="pu"><h1><a href="https://github.com/abrudz/QuadRS" rel="nofollow noreferrer">QuadR</a> <code>≡</code>, 9 bytes</h1>
<p><em>Blatant rip-off of <a href="https://codegolf.stackexchange.com/questions/274389/reduce-a-string-up-to-idempotency#comment590875_274391">l4m2's golf</a> of <a href="https://codegolf.stackexchange.com/a/274391/43319">Arnauld's JavaScript solution</a> — go upvote!</em></p>
<pre><code>(.+)\1
\1
</code></pre>
<p><a href="https://tio.run/##KyxNTCn6/19DT1szxpArxvD/f64KrgogquRSVLTn0tbX1ucy1AZCIGkEJOvq6rhCMlKBKJerJCO1BEQn@4emZ3BFeEY4RjhyeULpiAouQ0sLA2MTIOLS09NTBGEYw57LPz9bEYjtuWzy7Wzy8@3@P@pcCAA" rel="nofollow noreferrer" title="QuadR – Try It Online">Try it online!</a></p>
</div>
<div id="pu9" class="pu"><h1><a href="https://github.com/JCumin/Brachylog" rel="nofollow noreferrer">Brachylog</a>, <s>15</s> 14 bytes</h1>
<pre><code>{c~c₂ᶠo∋~jᵗc}ˡ
</code></pre>
<p><a href="https://tio.run/##SypKTM6ozMlPN/pfXa6koGunoFRu/6htw6Ompoe7Omsfbp3wvzq5LhnE3bYg/1FHd13Ww63Tk2tPL/z/P1opMNQRiEIdfZR0lICoAoTBRCWQUFS0B5La@tr6QMpQGwjBtBGYrqurA5IhGalAlAtklWSklkBYyf6h6RlAOsIzwjHCEcjwhLMiQGYbWloYGJsAEZCtp6enCMIIJshK//xsRSAGMW3y7Wzy8@2UYgE" rel="nofollow noreferrer" title="Brachylog – Try It Online">Try it online!</a></p>
<p>I wouldn't be surprised if there's a better way to do this.</p>
<p>...But, I mostly just took <a href="https://codegolf.stackexchange.com/questions/274389/reduce-a-string-up-to-idempotency/274420#comment590899_274389">Jitse's comment about requiring recursion</a> as a challenge.</p>
<pre><code>{           }ˡ    Left reduce by:
 c                Concatenate the new element to the accumulator,
  ~c₂             then partition that result into two possibly-empty slices,
     ᶠo∋          trying the partitions in lexicographic order.
        ~jᵗ       Un-double the last slice,
           c      and concatenate the slices back together.
</code></pre>
</div>
<div id="pu10" class="pu"><h1><a href="https://www.perl.org/" rel="nofollow noreferrer">Perl 5</a> + <code>-pl</code>, 18 bytes</h1>

<pre class="lang-perl prettyprint-override"><code>1while s;(.+)\K\1;</code></pre>
<p><a href="https://dom111.github.io/code-sandbox/#eyJsYW5nIjoid2VicGVybC01LjI4LjEiLCJjb2RlIjoiMXdoaWxlIHM7KC4rKVxcS1xcMTsiLCJhcmdzIjoiLXBsIiwiaW5wdXQiOiJcbnhcbnh4XG54eVxuISE/XG4rLysvXG4xKzErMVxuMSsyKzFcbn5+flxuVGhlVGhlbVxudGhldGhlbVxuY09VZ2hcblhJWEFYQVxuSVhJWEFYQVxuWHhcbjE5ODAzNDAzNFxuLi4uIS4uLiFcbi4uLiEuLi4/XG5Pb2shT29rP1xuPG8+PG9vPlxuUVVBTFFVQVVBTCJ9" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu11" class="pu"><h1><a href="https://github.com/JCumin/Brachylog" rel="nofollow noreferrer">Brachylog</a>, <s>16</s> 15 bytes</h1>
<pre><code>~c₃↺{h&amp;~j}ʰ↻c↰|
</code></pre>
<p><a href="https://tio.run/##SypKTM6ozMlPN/r/vy75UVPzo7Zd1RlqdVm1pzY8atud/KhtQ83//0qeEZ4RjhGOSv8jAA" rel="nofollow noreferrer" title="Brachylog – Try It Online">Try it online!</a></p>
<h3>Explanation</h3>
<p>I wouldn't be surprised if there's a better way to do this.</p>
<pre><code>~c₃↺{h&amp;~j}ʰ↻c↰|
~c₃               &quot;Unconcatenate&quot; the input string into three substrings
   ↺              Rotate the first element to the end
    {    }ʰ       Apply this predicate to the new first element:
     h&amp;             Assert that it is nonempty
       ~j           Assert that it consists of a substring repeated twice,
                    and return that substring
           ↻      Rotate the final element back to the beginning
             c    Concatenate the list back together
              ↰   Call the main predicate again on the result
               |  If there was no way to partition the input string that
                  satisfied the assertions, return the input unchanged
</code></pre>
</div>
<div id="pu12" class="pu"><h1><a href="https://github.com/m-ender/retina/wiki/The-Language/a950ad7d925ec9316e3e2fb2cf5d49fd15d23e3d" rel="nofollow noreferrer">Retina 0.8.2</a>, 11 bytes</h1>
<pre><code>+`(.+)\1
$1
</code></pre>
<p><a href="https://tio.run/##K0otycxL/P9fO0FDT1szxpBLxfD/f64KrgogquRSVLTn0tbX1ucy1AZCIGkEJOvq6rhCMlKBKJerJCO1BEQn@4emZ3BFeEY4RjhyeULpiAouQ0sLA2MTIOLS09NTBGEYw57LPz9bEYjtuWzy7Wzy8@0A" rel="nofollow noreferrer" title="Retina 0.8.2 – Try It Online">Try it online!</a> Link includes test cases. Explanation: Blatant rip-off of @Adám's rip-off of @l4m2's golf of @Arnauld's answer.</p>
</div>
<div id="pu13" class="pu"><h1><a href="https://www.r-project.org" rel="noreferrer">R</a>, 48 bytes</h1>
<pre class="lang-r prettyprint-override"><code>\(s){while(s!=(s=sub(&quot;(.+)\\1&quot;,&quot;\\1&quot;,s,,T)))0;s}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=XdHBSsNAEAZgvPoU3fWyS9JtUj1UbFJyLAhFaGAPOVkSIyoBN8UWMS_iJQo-gU-jT-PMrrOmktnN_N8QyCavb4_9e5V8bNtqPPuKCmHk81N9e18KwxJhErO9FlyoQBZFzENudxOGaylldGFe3HPfR5-V4Fd5BpVnl1weQ-TyZDROR5xj2FHaufg_733eW2BsQQIdSjAJJkTQIcUBXGTYOpwOcfrLXdcRdhbWdQn1QGh79LYu24G35JtVflOTuoCslzrTGTkmy8tDJ9b-3NodPD6fRadnUP6NLdiZUorhohF0A178sXJfaNXcMVh-4DMO5006b5qUZhC5-3d97-4_" rel="noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu14" class="pu"><h1><a href="https://github.com/ETHproductions/japt" rel="noreferrer">Japt</a>, 10 <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" rel="noreferrer">bytes</a></h1>
<p>I didn't understand the spec <em>at all</em> so this is based on the worked example &amp; test cases.</p>
<pre><code>e&quot;(.+)%1&quot;Ï
</code></pre>
<p><a href="https://petershaggynoble.github.io/Japt-Interpreter/?v=1.4.6&amp;code=ZSIoLispJTEizw&amp;input=WyJRVUFRVUFVQUwiLCIiLCJ4IiwieHgiLCJ4eSIsIiEhPyIsIisvKy8iLCIxKzErMSIsIjErMisxIiwifn5%2bIiwiVGhlVGhlbSIsInRoZXRoZW0iLCJjT1VnaCIsIlhJWEFYQSIsIklYSVhBWEEiLCJYeCIsIjE5ODAzNDAzNCIsIi4uLiEuLi4hIiwiLi4uIS4uLj8iLCJPb2shT29rPyIsIjxvPjxvbz4iXS1tUg" rel="noreferrer">Try it</a> (includes all test cases)</p>
</div>
<div id="pu15" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands/2649a799300cbf3770e2db37ce177d4a19035a25" rel="noreferrer">05AB1E (legacy)</a>, 8 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="noreferrer">bytes</a></h1>
<pre><code>Δ.œ€ÔJéн
</code></pre>
<p><a href="https://tio.run/##ASMA3P8wNWFiMWX//86ULsWT4oKsw5RKw6nQvf//MTEuMCsxKzFlMQ" rel="noreferrer">Try it online</a> or <a href="https://tio.run/##MzBNTDJM/V9Waa@k8KhtkoKSfaXS/3NT9I5OftS05vAUr8MrL@z9r6QXpvM/WklJR6kChMFEJZBQVLQHktr62vpAylAbCMG0EZiuq6sDkiEZqUCUC2SVZKSWQFjJ/qHpGUA6wjPCMcIRyPCEsyJAZhtaWhgYmwARkK2np6cIwggmyEr//GxFIAYxbfLtbPLz7UDaDPUMQG5INVSKBQA" rel="noreferrer">verify all test cases</a>.</p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>Δ         # Loop until the result no longer changes:
 .œ       #  Get all partitions of the current string
          #  (which will use the implicit input-string in the first iteration)
   €      #  Map over each partition:
    Ô     #   Connected uniquify all parts in this partition
     J    #  Join each connected uniquified partition back together
      é   #  Sort these strings by length (shortest to longest)
       н  #  Pop and keep the first/shortest one
          # (after the loop, the result is output implicitly)
</code></pre>
<p>Uses the <a href="https://github.com/Adriandmen/05AB1E/wiki/Commands/2649a799300cbf3770e2db37ce177d4a19035a25" rel="noreferrer">legacy version of 05AB1E</a> instead of the <a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="noreferrer">latest version</a>, since the connected uniquify builtin <code>Ô</code> will interpret stringified numbers as numbers instead of strings. E.g. with input <code>11.0+1+1e1</code>, the legacy program correctly connected uniqifies <code>[&quot;1&quot;,&quot;1&quot;,&quot;.0&quot;,&quot;+1&quot;,&quot;+1&quot;,&quot;e1&quot;]</code> to <code>[&quot;1&quot;,&quot;.0&quot;,&quot;+1&quot;,&quot;e1&quot;]</code> → <code>&quot;1.0+1e1&quot;</code>, whereas the new version of 05AB1E will connected uniquify <code>[&quot;1&quot;,&quot;1.0&quot;,&quot;+1&quot;,&quot;+1e1&quot;]</code> to <code>[&quot;1&quot;]</code> → <code>&quot;1&quot;</code>, since it interprets them all as the same number (<code>1</code>): <a href="https://tio.run/##ASMA3P9vc2FiaWX//86ULsWT4oKsw5RKw6nQvf//MTEuMCsxKzFlMQ" rel="noreferrer">try it online</a>.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/274389/">274389</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




