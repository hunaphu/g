<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::83046</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>004</td><td>APLNARS</td><td>250120T115029Z</td><td><a href="https://codegolf.stackexchange.com/questions/83046/golf-the-repeated-totient-function/277774#277774">Rosario</a></td></tr>
<tr d-ix="1"><td>004</td><td>J</td><td>160616T101228Z</td><td><a href="https://codegolf.stackexchange.com/questions/83046/golf-the-repeated-totient-function/83054#83054">miles</a></td></tr>
<tr d-ix="2"><td>039</td><td>Perl 6</td><td>160616T175129Z</td><td><a href="https://codegolf.stackexchange.com/questions/83046/golf-the-repeated-totient-function/83081#83081">Brad Gil</a></td></tr>
<tr d-ix="3"><td>088</td><td>Javascript</td><td>160617T181052Z</td><td><a href="https://codegolf.stackexchange.com/questions/83046/golf-the-repeated-totient-function/83182#83182">Washingt</a></td></tr>
<tr d-ix="4"><td>020</td><td>CJam</td><td>160617T055334Z</td><td><a href="https://codegolf.stackexchange.com/questions/83046/golf-the-repeated-totient-function/83116#83116">Dennis</a></td></tr>
<tr d-ix="5"><td>070</td><td>Python 2</td><td>160616T160015Z</td><td><a href="https://codegolf.stackexchange.com/questions/83046/golf-the-repeated-totient-function/83072#83072">Dennis</a></td></tr>
<tr d-ix="6"><td>040</td><td>Haskell</td><td>160616T152439Z</td><td><a href="https://codegolf.stackexchange.com/questions/83046/golf-the-repeated-totient-function/83071#83071">flawr</a></td></tr>
<tr d-ix="7"><td>033</td><td>PARI/GP</td><td>160616T174523Z</td><td><a href="https://codegolf.stackexchange.com/questions/83046/golf-the-repeated-totient-function/83079#83079">Charles</a></td></tr>
<tr d-ix="8"><td>036</td><td>Julia</td><td>160616T173525Z</td><td><a href="https://codegolf.stackexchange.com/questions/83046/golf-the-repeated-totient-function/83078#83078">Dennis</a></td></tr>
<tr d-ix="9"><td>084</td><td>Hoon</td><td>160616T165237Z</td><td><a href="https://codegolf.stackexchange.com/questions/83046/golf-the-repeated-totient-function/83075#83075">RenderSe</a></td></tr>
<tr d-ix="10"><td>004</td><td>Actually</td><td>160616T102344Z</td><td><a href="https://codegolf.stackexchange.com/questions/83046/golf-the-repeated-totient-function/83055#83055">user4594</a></td></tr>
<tr d-ix="11"><td>005</td><td>MATL</td><td>160616T092520Z</td><td><a href="https://codegolf.stackexchange.com/questions/83046/golf-the-repeated-totient-function/83047#83047">Luis Men</a></td></tr>
<tr d-ix="12"><td>002</td><td>05AB1E</td><td>160616T094407Z</td><td><a href="https://codegolf.stackexchange.com/questions/83046/golf-the-repeated-totient-function/83051#83051">Adnan</a></td></tr>
<tr d-ix="13"><td>003</td><td>Jelly</td><td>160616T093304Z</td><td><a href="https://codegolf.stackexchange.com/questions/83046/golf-the-repeated-totient-function/83049#83049">Martin E</a></td></tr>
<tr d-ix="14"><td>017</td><td>Mathematica</td><td>160616T093014Z</td><td><a href="https://codegolf.stackexchange.com/questions/83046/golf-the-repeated-totient-function/83048#83048">Martin E</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>APL(NARS), 4 chars</h1>
<pre><code>13π⍣
</code></pre>
<p>13π is the function of exercise repeted ⍣ times, test:</p>
<pre><code>  13π⍣1 10
4
  13π⍣2 10
2
  13π⍣3 10
1
  13π⍣1 100
40
  13π⍣4 100
4
</code></pre>
</div>
<div id="pu1" class="pu"><h1>J, <s>6</s> 4 bytes</h1>

<pre><code>5&amp;p:
</code></pre>

<p>Straight-forward approach. Nests the totient function <em>n</em> times on an initial value of <em>x</em>.</p>

<h2>Usage</h2>

<pre><code>   f =: 5&amp;p:
   5 f 100
2
</code></pre>

<h2>Explanation</h2>

<p>Normally, <code>5&amp;p:</code> is a monad that computes the totient of its argument. However, when used dyadically, it nests itself on an initial value of its LHS according to the number of times on its RHS.</p>
</div>
<div id="pu2" class="pu"><h1><a href="http://perl6.org" rel="nofollow">Perl 6</a>, <s> 47 45 44 43 42 41 </s> 39 bytes</h1>



<pre class="lang-perl6 prettyprint-override"><code><s>{($^x,{+(^$^x .grep: {$_ gcd$x==1})}...*)[$^n]}
{($^x,{+(^$^x Xgcd $x).grep: *==1}...*)[$^n]}
{($^x,{+grep *==1,(^$^x Xgcd $x)}...*)[$^n]}
{($^x,{+grep *==1,(^$^x Xgcd$x)}...*)[$^n]}
{($^x,{+grep 2>*,(^$^x Xgcd$x)}...*)[$^n]}
{($^x,{+grep 2>*,(^$_ Xgcd$_)}...*)[$^n]}</s>
{($^x,{sum 2 X>(^$_ Xgcd$_)}...*)[$^n]}</code></pre>

<h3>Explanation:</h3>

<pre class="lang-perl6 prettyprint-override"><code>{ # parameters are $n,$x ( declared as placeholder parameters )
  (

    $^x, # seed sequence generator with second argument

    { # parameter is $_
      sum
        2
        X[&gt;] # crossed compared using &amp;infix«&gt;»
        (
          0 ..^ $_ # from 0 up to and excluding the parameter
          X[gcd]   # cross apply &amp;infix:&lt;gcd&gt; with:
          $_       # the parameter
        )
    }

    ...  # keep applying that block

    *    # forever

  )[ $^n ] # grab the one at the index indicated by the first argument
}
</code></pre>

<h3>Test:</h3>

<pre class="lang-perl6 prettyprint-override"><code>use v6.c;
use Test;

my @tests = (
  (1, 10) =&gt;  4,
  (2, 10) =&gt;  2,
  (3, 10) =&gt;  1,
  (1,100) =&gt; 40,
  (2,100) =&gt; 16,
  (3,100) =&gt;  8,
  (4,100) =&gt;  4,
  (5,100) =&gt;  2,
  (6,100) =&gt;  1,
);

plan +@tests;

my &amp;repeated-totient = {($^x,{sum 2 X&gt;(^$_ Xgcd$_)}...*)[$^n]}

for @tests -&gt; $_ ( :key(@input), :value($expected) ) {
  is repeated-totient(|@input), $expected, .gist
}
</code></pre>

<pre class="lang-none prettyprint-override"><code>1..9
ok 1 - (1 10) =&gt; 4
ok 2 - (2 10) =&gt; 2
ok 3 - (3 10) =&gt; 1
ok 4 - (1 100) =&gt; 40
ok 5 - (2 100) =&gt; 16
ok 6 - (3 100) =&gt; 8
ok 7 - (4 100) =&gt; 4
ok 8 - (5 100) =&gt; 2
ok 9 - (6 100) =&gt; 1
</code></pre>
</div>
<div id="pu3" class="pu"><h2>Javascript, 88 <s>95</s></h2>

<pre><code>g=(a,b)=&gt;b?g(b,a%b):a==1
t=(x,n=x,o=0)=&gt;n?t(x,--n,o+g(x,n)):o
f=(n,x)=&gt;n?f(n-1,t(x)):x
</code></pre>

<p>The first function returns true/false if the greatest commom divisor is 1. The second function calculates the <em>totient</em>. The third function is a simple recursion to do the totient n times.</p>

<p>I took this idea from the wikipedia link:</p>

<blockquote>
  <p>It can be defined more formally as the number of integers k in the range 1 ≤ k ≤ n for which the greatest common divisor gcd(n, k) = 1;</p>
</blockquote>
</div>
<div id="pu4" class="pu"><h1>CJam, 20 bytes</h1>

<pre><code>q~{_mf1|1-{1$\/-}/}*
</code></pre>

<p><a href="http://cjam.tryitonline.net/#code=cX57X21mMXwxLXsxJFwvLX0vfSo&amp;input=MTAwIDM" rel="nofollow">Try it online!</a></p>

<h3>How it works</h3>

<pre><code>q~                    Read and evaluate all input. Pushes x and n.
  {               }*  Repeat n times:
   _mf                  Compute the prime factorization of a copy of x.
      1|1-              Add and remove 1 from the prime factorization.
                        | deduplicates and - handles the edge case 1mf -&gt; [1].
          {     }/      For each remaining prime p:
           1$             Push a copy of x.
             \/           Swap with p and divide, pushing x/p.
               -          Subtract from x, pushing x-x/p.
</code></pre>
</div>
<div id="pu5" class="pu"><h1>Python 2, <s>84</s> <s>78</s> 70 bytes</h1>

<pre class="lang-python prettyprint-override"><code>n,x=input();exec('k=m=1;'+'x-=(x%k&lt;m%k)*x/k;m*=k*k;k+=1;'*x)*n;print x
</code></pre>
<p><em>Thanks to @xnor for golfing off 8 bytes!</em></p>
<p>Test it on <a href="http://ideone.com/qVLteW" rel="nofollow noreferrer">Ideone</a>.</p>
<h3>Background</h3>
<p>By <a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function#Euler.27s_product_formula" rel="nofollow noreferrer">Euler's product formula</a>,</p>
<p><img src="https://i.sstatic.net/xsXir.png" alt="Euler's product formula" /></p>
<p>where <strong>φ</strong> denotes Euler's totient function and <strong>p</strong> varies only over prime numbers.</p>
<p>To identify primes, we use a corollary of <a href="https://en.wikipedia.org/wiki/Wilson%27s_theorem" rel="nofollow noreferrer">Wilson's theorem</a>:</p>
<p><img src="https://i.sstatic.net/ordYr.png" alt="corollary of Wilson's theorem" /></p>
<h3>How it works</h3>
<p>After reading the input, we construct and execute a certain string. The executed code is roughly equivalent to the following.</p>
<pre class="lang-python prettyprint-override"><code>r = range(x)
for _ in range(n):
    k = 1
    m = 1
    for _ in r:
        x -= (x % k &lt; m % k) * x / k
        m *= k**2
        k += 1
</code></pre>
<p>The inner loop will set <strong>x = φ(x)</strong>, so executing it <strong>n</strong> times stores the desired output in <strong>x</strong>.</p>
<p>At all times, the variable <strong>m</strong> will be equal to the square of the factorial of <strong>k - 1</strong>. In fact, we set <strong>k = 1</strong> and <strong>m = 0!<sup>2</sup> = 1</strong> at the beginning of the inner loop.</p>
<p><strong>k</strong> varies from its initial value <strong>1</strong> to the initial value of <strong>x</strong> and is incremented each time the sinner loop is executed. <strong>m</strong> is updated accordingly by multiplying it by the &quot;old&quot; value of <strong>k<sup>2</sup></strong>.</p>
<p>For the actual calculation of <strong>x</strong>, recall that <code>m%k</code> will yield <strong>1</strong> if <strong>m</strong> is prime and <strong>0</strong> if not. This means that <code>x%k&lt;m%k</code> will yield <strong>True</strong> if and only if both <strong>k</strong> is a prime number and <strong>x</strong> is divisible by <strong>k</strong>.</p>
<p>In this case, <code>(x%k&lt;m%k)*x/k</code> yields <strong>x / k</strong>, and subtracting it from <strong>x</strong> replaces its previous value with <strong>x(1 - 1/k)</strong>, as in Euler's product formula. Otherwise, <code>(x%k&lt;m%k)*x/k</code> yields <strong>0</strong> and <strong>x</strong> remains unchanged.</p>
</div>
<div id="pu6" class="pu"><h1>Haskell, <s>49</s> <s>46</s> <s>44</s> 40 bytes</h1>
<p>Thanks @xnor for another again named solution:</p>
<pre><code>x%0=x
x%n=sum[1|1&lt;-gcd x&lt;$&gt;[1..x]]%(n-1)
</code></pre>
<p>Old version:</p>
<p>The following is an unnamed pointless function that takes two arguments: (Thanks @Lynn for another two bytes!)</p>
<pre><code>(!!).iterate(\y-&gt;sum[1|t&lt;-[1..y],gcd y t&lt;2])
</code></pre>
<p>To use it, you can e.g. assign it a name (<code>f=(!!).(...</code>) and then call it via <code>f 10 1</code> (as an example for the first test case).</p>
<p>Explanation: The lambda function <code>(\y-&gt;sum[1|t&lt;-[1..y],gcd y t&lt;2])</code> is the totient function. <code>iterate f x</code> produces an infinite list <code>[x,f(x),f(f(x)),f(f(f(x))),...]</code> and <code>!!</code> is just for accessing this list at a specific index.</p>
<p>Older version:</p>
<pre><code>x#n=(iterate(\y-&gt;sum[1|t&lt;-[1..y],gcd y t&lt;2])x)!!n
</code></pre>
<p>Usage e.g. for the first test case: <code>10#1</code>.</p>
</div>
<div id="pu7" class="pu"><h1><a href="http://pari.math.u-bordeaux.fr" rel="nofollow">PARI/GP</a>, 33 bytes</h1>

<p>Straightforward iteration:</p>

<pre><code>f(n,x)=for(i=1,x,n=eulerphi(n));n
</code></pre>

<p>Straightforward recursion:</p>

<pre><code>f(n,x)=if(x,n,f(eulerphi(n),x-1))
</code></pre>
</div>
<div id="pu8" class="pu"><h1>Julia, 36 bytes</h1>



<pre class="lang-julia prettyprint-override"><code>n\x=n&gt;0?~-n\sum(k-&gt;gcd(k,x)&lt;2,1:x):x
</code></pre>

<p><a href="http://julia.tryitonline.net/#code=blx4PW4-MD9-LW5cc3VtKGstPmdjZChrLHgpPDIsMTp4KTp4Cgpmb3IgKG4seCkgaW4gKCAoMSwxMCksICgyLDEwKSwgKDMsMTApLCAoMSwgMTAwKSwgKDIsIDEwMCksICgzLCAxMDApLCAoNCwgMTAwKSwgKDUsIDEwMCksICg2LCAxMDApICkKICAgIEBwcmludGYoIiUxZCAlM2QgJTJkXG4iLCBuLCB4LCBuXHgpCmVuZA&amp;input=" rel="nofollow">Try it online!</a></p>
</div>
<div id="pu9" class="pu"><h2><a href="https://github.com/urbit/urbit" rel="nofollow noreferrer">Hoon</a>, 84 bytes</h2>
<pre><code>|*((pair) ?~(p q $(p (dec p), q (lent (skim (gulf 1 q) |=(@ =(1 d:(egcd +&lt; q))))))))
</code></pre>
<p>Ungolfed:</p>
<pre><code>|*  (pair)
  ?~  p
    q
  %=  $
    p  (dec p)
    q  (lent (skim (gulf 1 q) |=(@ =(1 d:(egcd +&lt; q)))))
  ==
</code></pre>
</div>
<div id="pu10" class="pu"><h2>Actually, 4 bytes</h2>
<pre><code>`▒`n
</code></pre>
<p><a href="http://actually.tryitonline.net/#code=YOKWkmBu&amp;input=MTAwCjI" rel="nofollow noreferrer">Try it online!</a></p>
<p>This program takes <code>x</code> as the first input, and <code>n</code> as the second input.</p>
<p>Explanation:</p>
<pre><code>`▒`n
`▒`n  call the following function n times:
 ▒      totient(x)
</code></pre>
</div>
<div id="pu11" class="pu"><h1><a href="https://github.com/lmendo/MATL" rel="nofollow noreferrer">MATL</a>, 5 bytes</h1>
<pre><code>:&quot;_Zp
</code></pre>
<p><a href="http://matl.tryitonline.net/#code=OiJfWnA&amp;input=MgoxMDAKCg" rel="nofollow noreferrer"><strong>Try it online!</strong></a></p>
<pre><code>:        % Take n implicitly. Generate vector [1 2 ... n]
&quot;        % For each loop, that is, repeat n times
  _Zp    %   Euler's totient function. Takes x implicitly first time
         % End for. Display implicitly
</code></pre>
<hr />
<p>Without using Euler's totient function: <strong>9 bytes</strong></p>
<pre><code>:&quot;t:Zd1=s
</code></pre>
<p><a href="http://matl.tryitonline.net/#code=OiJ0OlpkMT1z&amp;input=MgoxMDAKCg" rel="nofollow noreferrer"><strong>Try it online!</strong></a></p>
<pre><code>:        % Take n implicitly. Generate range [1 2 ... n]
&quot;        % For each loop, that is, repeat n times
  t      %   Duplicate. Takes x implicitly first time. Call that t
  :      %   Range [1 2 ... t]
  Zd     %   GCD of t and [1 2 ... t], elementwise
  1=s    %   How many times the result equals 1: Euler's totient
         % End for. Display implicitly
</code></pre>
</div>
<div id="pu12" class="pu"><h1><a href="http://github.com/Adriandmen/05AB1E" rel="noreferrer">05AB1E</a>, 2 bytes</h1>
<p>Code:</p>
<pre><code>FÕ
</code></pre>
<p>Explanation:</p>
<pre><code>F   # Do the following n times:
 Õ  #   ..Calculate the totient
</code></pre>
<p>Uses the <strong>CP-1252</strong> encoding. <a href="http://05ab1e.tryitonline.net/#code=RsOV&amp;input=MQoxMDA" rel="noreferrer">Try it online!</a>.</p>
</div>
<div id="pu13" class="pu"><h2><a href="https://github.com/DennisMitchell/jelly" rel="nofollow">Jelly</a>, 3 bytes</h2>

<pre><code>ÆṪ¡
</code></pre>

<p>Expects <code>x</code> as the first argument and <code>n</code> as the second.</p>

<p><a href="http://jelly.tryitonline.net/#code=w4bhuarCoQ&amp;input=&amp;args=MTAw+Mg" rel="nofollow">Try it online!</a></p>

<p>This is as straightforward as it gets: <code>ÆṪ</code> is the built-in totient function and <code>¡</code> applies this function as many times as the second argument.</p>
</div>
<div id="pu14" class="pu"><h2>Mathematica, 17 bytes</h2>

<pre><code>EulerPhi~Nest~##&amp;
</code></pre>

<p>An unnamed function which takes <code>x</code> as the first argument and <code>n</code> as the second. Here <code>EulerPhi~Nest~##</code> is short for <code>Nest[EulerPhi, ##]</code> and then <code>##</code> expands to a sequence of both arguments so we get <code>Nest[EulerPhi, x, n]</code>. And <code>EulerPhi</code> is of course the totient function.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/83046/">83046</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




