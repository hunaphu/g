<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::218059</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>094</td><td>Wolfram Language Mathematica</td><td>210128T004920Z</td><td><a href="https://codegolf.stackexchange.com/questions/218059/is-this-an-l-shape/218105#218105">att</a></td></tr>
<tr d-ix="1"><td>166</td><td>JavaScript ES6</td><td>210127T101810Z</td><td><a href="https://codegolf.stackexchange.com/questions/218059/is-this-an-l-shape/218075#218075">Arnauld</a></td></tr>
<tr d-ix="2"><td>069</td><td>Charcoal</td><td>210130T005034Z</td><td><a href="https://codegolf.stackexchange.com/questions/218059/is-this-an-l-shape/218246#218246">Neil</a></td></tr>
<tr d-ix="3"><td>180</td><td>Scala</td><td>210127T161224Z</td><td><a href="https://codegolf.stackexchange.com/questions/218059/is-this-an-l-shape/218086#218086">user</a></td></tr>
<tr d-ix="4"><td>338</td><td>Perl 5 cperl</td><td>210129T164034Z</td><td><a href="https://codegolf.stackexchange.com/questions/218059/is-this-an-l-shape/218234#218234">Kjetil S</a></td></tr>
<tr d-ix="5"><td>044</td><td>APL Dyalog Unicode</td><td>210129T111848Z</td><td><a href="https://codegolf.stackexchange.com/questions/218059/is-this-an-l-shape/218217#218217">ngn</a></td></tr>
<tr d-ix="6"><td>167</td><td>Python 3.9 + NumPy</td><td>210127T225403Z</td><td><a href="https://codegolf.stackexchange.com/questions/218059/is-this-an-l-shape/218102#218102">Artyer</a></td></tr>
<tr d-ix="7"><td>048</td><td>APL Dyalog Extended</td><td>210127T075035Z</td><td><a href="https://codegolf.stackexchange.com/questions/218059/is-this-an-l-shape/218067#218067">Ad&#225;</a></td></tr>
<tr d-ix="8"><td>170</td><td>Julia</td><td>210127T134830Z</td><td><a href="https://codegolf.stackexchange.com/questions/218059/is-this-an-l-shape/218082#218082">MarcMush</a></td></tr>
<tr d-ix="9"><td>112</td><td>Retina</td><td>210127T113659Z</td><td><a href="https://codegolf.stackexchange.com/questions/218059/is-this-an-l-shape/218077#218077">Neil</a></td></tr>
<tr d-ix="10"><td>nan</td><td>J</td><td>210127T055846Z</td><td><a href="https://codegolf.stackexchange.com/questions/218059/is-this-an-l-shape/218064#218064">Jonah</a></td></tr>
<tr d-ix="11"><td>104</td><td>APL Dyalog Unicode</td><td>210127T065100Z</td><td><a href="https://codegolf.stackexchange.com/questions/218059/is-this-an-l-shape/218066#218066">Razetime</a></td></tr>
<tr d-ix="12"><td>017</td><td>05AB1E</td><td>210127T091133Z</td><td><a href="https://codegolf.stackexchange.com/questions/218059/is-this-an-l-shape/218070#218070">Kevin Cr</a></td></tr>
<tr d-ix="13"><td>500</td><td>JavaScript V8</td><td>210127T022139Z</td><td><a href="https://codegolf.stackexchange.com/questions/218059/is-this-an-l-shape/218062#218062">rydwolf</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.wolfram.com/wolframscript/" rel="nofollow noreferrer">Wolfram Language (Mathematica)</a>, <s>107 ... 100 97</s> 94 bytes</h1>
<pre><code>FreeQ[#|Reverse@#&amp;@{z={y=0...}...,e:{a:y,1..,b:y}..,{a:y,c:m_..,d:n_..,b:y}..,z}/;c+d==Max@+e]
</code></pre>
<p><a href="https://tio.run/##fVDLCoMwELz7FQXBi0GTa0ogl/ZW6OMoImlMqQctWCnVNP66ja31lSJLyO7OMjs7KSuuImVFwllzIc02F@IQ2K@jeIj8LqjtUFkRWRLoeZ7SDwgsGS4B0ukZl7oFPjXHaaTzGGfRgFTKX3M3JmTHntQVYbPPk6ygl2DDrzef2qFTnzjLamlJCQEEqAuogLVa6LQ/VLol5QcewD7rYAj6GKBZjYwaLc5DYCwYJKKZZPTnhAXC9qKJ8m5oTGCQ/ZyY3v/dPhc64kBjBwy7TIMmAn4mKUs1bw" rel="nofollow noreferrer" title="Wolfram Language (Mathematica) – Try It Online">Try it online!</a></p>
<p>The pattern identifies an L shape with the long leg on top.</p>
<pre><code>FreeQ[
{                                                           }   pattern:
 z={y=0...}...,  {a:y,   ,b:y}..,{a:y,             ,b:y}..,z     margin of 0s
               e:{    1..    }..                                 rows of 1s
                                 {    c:m_..,d:n_..    }..       rows with two distinct parts (..01.. or ..10..)
#|Reverse@#&amp;@ %                                                 or reflected
  /;c+d==Max@+e                                                  enforce leg widths
]
</code></pre>
</div>
<div id="pu1" class="pu"><h1>JavaScript (ES6), <s> 175 </s> 166 bytes</h1>
<p>Expects a list of binary strings.</p>
<pre class="lang-javascript prettyprint-override"><code>m=&gt;m.map(M=r=&gt;(M|=v='0b'+r|0,m&amp;=v||~0,v),m=~0).map(v=&gt;v?(b=v+(v&amp;-v))&amp;b-1?3:v^m?2^v&lt;M:1:0).join``.match(`^0*(1+${s=(g=m=&gt;m?2+g(m&amp;m-1):'')(m)}|${s}1+)0*$`)&amp;&amp;M*2&amp;M/2&amp;m^m
</code></pre>
<p><a href="https://tio.run/##jVHBcoIwEL37FU7GCYmA3aU3ppFbb9x6szKgVdQh4IDNTKfor1NKK8Qpave0Sd6@t@9lF6moWObb/cFOs7dVtRaVFFM5kdGe@SIXU@aXQgkDFoaZl2BJKlRZnsBS3JLiBLxBKjFVHlsIZTJFbcU5XdjoPboqkJ4TqCffRbeG7rJtGob1xGG5YWEAY4bm6LMQLBbfop5jxkxSaSN3DYMzyY9l/XxEk8N4FHJK/bFD/QeHykBWyywtsmQ1SbKYkdlL/n7YfMwJH@j3azYbDIcEAOsCYvUeAIAM5rx3ska2wHNzHQ1NtTitR73HfgzcoW6XRs0AXpjpp7vgI6/p7DlKimtZ4U13v@Sd5IX49Rj19H72vuO1pe/y/48Q/I292xTx5k@DFmkDq74A" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<h2>How?</h2>
<h3>Step 1</h3>
<p>We first convert the input matrix <span class="math-container">\$m[\:]\$</span> into a list of integers. At the same time, we compute the bit mask <span class="math-container">\$M\$</span> of all rows OR'd together and the bit mask <span class="math-container">\$m\$</span> of all non-empty rows AND'd together.</p>
<pre class="lang-javascript prettyprint-override"><code>m.map(M =                  // start with M zero'ish
  r =&gt;                     // for each row r in m[]:
  ( M |= v = '0b' + r | 0, //   turn r into an integer v by parsing it as binary
                           //   and update M by doing M = M OR v
    m &amp;= v || ~0,          //   if v is not equal to 0, update m by doing m = m AND v
    v                      //   yield v as the actual value for the map()
  ),                       //
  m = ~0                   //   start with all bits set in m
)                          // end of map()
</code></pre>
<p>If the shape is valid:</p>
<ul>
<li><span class="math-container">\$m\$</span> is the pattern for the vertical leg</li>
<li><span class="math-container">\$M\$</span> is the pattern for the horizontal leg</li>
<li>the list returned by <code>map()</code> contains only <span class="math-container">\$m\$</span>, <span class="math-container">\$M\$</span> and optional <span class="math-container">\$0\$</span>'s</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code> input     | bin -&gt; dec |  M |  m
-----------+------------+----+-----
 &quot;0000000&quot; |      0     |  0 | ~0
 &quot;0100000&quot; |     32     | 32 | 32
 &quot;0100000&quot; |     32     | 32 | 32
 &quot;0111110&quot; |     62     | 62 | 32
 &quot;0000000&quot; |      0     | 62 | 32
</code></pre>
<h3>Step 2</h3>
<p>We convert the list into a string of digits, using <span class="math-container">\$0\$</span> for empty rows, <span class="math-container">\$1\$</span> for rows equal to <span class="math-container">\$m\$</span>, <span class="math-container">\$2\$</span> for rows equal to <span class="math-container">\$M\$</span>, or <span class="math-container">\$3\$</span> for invalid rows.</p>
<pre class="lang-javascript prettyprint-override"><code>.map(v =&gt;                  // for each value v in the list:
  v ?                      //   if v is not equal to 0:
    (b = v + (v &amp; -v))     //     if adding to v the least significant bit set in v
    &amp; b - 1 ?              //     results in more than one bit set:
      3                    //       this is an invalid row where at least one 0
                           //       breaks a pattern of consecutive 1's
    :                      //     else:
      v ^ m ?              //       if v is not equal to m:
        2 ^                //         yield 2 if v = M
        v &lt; M              //         or yield 3 if v != M (invalid)
      :                    //       else (v = m):
        1                  //         yield 1
  :                        //   else (empty row):
    0                      //     yield 0
)                          // end of map()
.join``                    // join all digits
</code></pre>
<h3>Step 3</h3>
<p>We build a regular expression to test whether the string is valid.</p>
<pre class="lang-javascript prettyprint-override"><code>.match(                    // test the resulting string:
  &quot;^0*(&quot; +                 //   optional leading 0's
                           //   followed by either:
  &quot;1+&quot; +                   //     one or several 1's
  ( s =                    //     followed by as many 2's as the number of bits set
    ( g = m =&gt;             //     in m
        m ?                //
          2 + g(m &amp; m - 1) //     this string of 2's is computed with the recursive
        :                  //     function g and saved in s
          ''               //
    )(m)                   //
  ) +                      //
  &quot;|&quot; +                    //   or:
  s + &quot;1+&quot; +               //     as many 2's as the number of bits set
                           //     in m, followed by one or several 1's
  &quot;)0*$&quot;                   //   followed by optional trailing 0's
)                          // end of match()
</code></pre>
<h3>Step 4</h3>
<p>Finally, we make sure that <span class="math-container">\$m\$</span> and <span class="math-container">\$M\$</span> form a right angle.</p>
<p>Either <span class="math-container">\$m\text{ AND }(M\times 2)\$</span> or <span class="math-container">\$m\text{ AND }\lfloor M/2\rfloor\$</span> must be different from <span class="math-container">\$m\$</span>:</p>
<pre class="lang-javascript prettyprint-override"><code>M * 2 &amp; M / 2 &amp; m ^ m
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 69 bytes</h1>
<pre><code>ＦＬθＦＬ§θ⁰Ｆ⌊⟦ικ⟧Ｆ⁻ιλＦ⁻κλＦ²Ｆ²⁼θＥθＥρ¬∨∨∨‹ςμ›ςι∨‹τν›τκ‹λ⌊⟦⎇π⁻ςμ⁻ις⎇ξ⁻τν⁻κτ
</code></pre>
<p><a href="https://tio.run/##jZA/D8IgEMV3P8WNR4JJdXVyMMbEf4Nbw0AUlZRSe6WNfnqkKhU3ySXw3g9e7jheJR0rabw/VwS4VvbirlgzBqmeu5U9qTvWHDIW2UZbXbYl5ppDIRK3bTBY5tcpEmf63fekrcNF3UrT9PEbeYsbcdhWDnf0qbVqGuw4lIzDkpR0inqpWdAROw42wUEWrOcvaEJu7PmgyEp64O3ltUPw0H7XP4u37hF88oeRHGNh8veaeZ/neRa@iMMkqUzwEcB/4H3OhBB@3Jkn" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Works by enumerating all possible <code>L</code> shapes on the original grid looking for a match. So many nested loops, I've actually used the <code>t</code> variable for the first time ever. This is an important milestone, since there are no trivial loop variables left. Outputs a Charcoal boolean, i.e. <code>-</code> if the shape was an <code>L</code>, nothing if not. Explanation:</p>
<pre><code>ＦＬθＦＬ§θ⁰
</code></pre>
<p>Loop over all potential bottom right corners of the rectangle enclosing the <code>L</code> shape. (Zero values will be trivially excluded as there won't be room for a pivot.)</p>
<pre><code>Ｆ⌊⟦ικ⟧
</code></pre>
<p>Loop over all potential pivot sizes. (Obviously there must be room for the pivot in both dimensions as it is square.)</p>
<pre><code>Ｆ⁻ιλＦ⁻κλ
</code></pre>
<p>Loop over all potential top left corners of the enclosing rectangle.</p>
<pre><code>Ｆ²Ｆ²
</code></pre>
<p>Loop over all orientations of the <code>L</code> within the rectangle.</p>
<pre><code>⁼θＥθＥρ¬∨∨∨‹ςμ›ςι∨‹τν›τκ‹λ⌊⟦⎇π⁻ςμ⁻ις⎇ξ⁻τν⁻κτ
</code></pre>
<p>Recreate the <code>L</code> based on the specification, eliminating all points <code>(v, t)</code> outside the rectangle <code>(m, n) - (i, k)</code> (inclusive) but also all points which are more than <code>l</code> away from at least one of the appropriate adjacent edges for the given orientation, and see if that equals the original input.</p>
<p>Here is an example of an enumerated <code>L</code> shape. In this figure, <code>i</code> is <code>5</code>, <code>k</code> is <code>11</code>, <code>l</code> is <code>3</code>, <code>m</code> is <code>2</code>, <code>n</code> is <code>5</code>, and <code>p</code> is <code>1</code> (for top) and <code>x</code> is <code>0</code> (for right) for the position of the pivot.</p>
<pre><code>+-----n-----k
|
|
m     ----+++
|     ----+++
|     ----+++
i         |||
</code></pre>
</div>
<div id="pu3" class="pu"><h1>Scala, <s>249</s> <s>185</s> 180 bytes</h1>
<pre class="lang-scala prettyprint-override"><code>Seq.iterate(_,8)(_.transpose.map(_.reverse)dropWhile(!_.toSet(1)))drop 4 exists{m=&gt;Set(m,m.transpose).flatMap(_.dropWhile(!_.toSet(0)).map(_.reverse.dropWhile(_&lt;1)).toSet).size==1}
</code></pre>
<p><a href="https://scastie.scala-lang.org/Z9gMhLMEQ42mufvdLTTTyA" rel="nofollow noreferrer">Try it online!</a></p>
<p>This is shamefully long. It takes a <code>List[List[Int]]</code> as input (even though the type is <code>Seq[Seq[Int]] =&gt; Boolean</code>). The result is a <code>Boolean</code>.</p>
<h2>Explanation</h2>
<p>Then we make a <code>Seq</code> of length 8 by repeatedly rotating the matrix clockwise (<code>t(_)map(_.reverse)</code>) and then dropping empty rows at the beginning (<code>dropWhile(!_.toSet(1))</code>).</p>
<pre class="lang-scala prettyprint-override"><code>Seq.iterate(_, 8)(t(_)map(_.reverse)dropWhile(!_.toSet(1)))
</code></pre>
<p>Just applying it 4 times would be enough to trim on all sides, but we also want all orientations. We first <code>drop 4</code> so only trimmed matrices remain. Then we use <code>exists</code> to check if any of them meet a certain condition. However, this function won't work for all orientations, it'll only work for upside-down L's (that's why all 4 orientations were generated):</p>
<pre><code>#####
#####
##
</code></pre>
<p>First, we make a <code>Set</code> out of <code>m</code> and its transpose, and for both of them, we drop the rows at the start that only contain <code>#</code>'s. For the rest of the rows in both, we reverse them and strip leading zeroes, then deduplicate them using <code>toSet</code>. The results for both <code>m</code> and its transpose are combined because we used <code>flatMap</code>, and then we make sure there is exactly one element. Thus, we eliminate legless shapes (less than one element) and shapes with extraneous <code>#</code>'s (more than one element).</p>
</div>
<div id="pu4" class="pu"><h1><a href="http://perl11.org/cperl/" rel="nofollow noreferrer">Perl 5 (cperl)</a>, 338 bytes</h1>

<pre class="lang-perl prettyprint-override"><code>sub L{($w,$h,$v,$m)=@_;join$/,map{$x=$_;join'',map$_&lt;=$w|($m?$x&gt;$h-$w:$x&lt;=$w)|0,1..$v}1..$h}
sub r{my($i,@r);map/\n/?($i=0):$r[$i++]=~s/^/$_/,pop()=~/./gs;join$/,@r}
sub d{my$_=pop;/.*/;length$&amp;,0+split$/}
sub f{$s=pop;map$s=r($s)=~s,^(0+\n)+,,r,1..4;@m=map{$m=$_;map$m=r($m),1..4}map{L(@L=($_,d($s))),L(@L,1)}1..min(d($s))-1;grep/$s/,@m}
</code></pre>
<p><a href="https://tio.run/##bVHBctsgEL3zFTSzUwsLG5hpL5ZJdMmpbnNJT3HicRvZppWQBpTYHcf59LoLisZJWw7Avn379i00hSs/jr43eBxtTbdLZ41dezoodoiZqrDtshxkJG/dQ6F9U5pWzO3cCj6dXmZESoVLvjmllIRgFAISAxnX6VAvh3oNyp4adFQnp3rVvzjqddd/Lr26OhXh5ZKQfLUs/X@mUOg3bmiadK2iWN8bMy@jqN5jSMYJe4Z8M10sjvORuIcgOmgL3@qE0qRaNvQGFvpc3XIaX5dxQvt1SsuQjr4ZpSwjq9olUYXtkZ6AsQ0H/Cymc1hkCMG6bvUqJliIG2dsS9MUDEc6JumudjSW0At6RofD4Zera3r16d3cntEJIvVPvGXkcPQP3@hsn8CWw4bDI4cKuyyyH7WxIDha3MNOQwcMBgGAxVTD9imB6gJ257AZwXYCu4CxJ8nVeAyPh7BvDiSIu331C53y3LEMq/FPxAXGWrIJuBswaXqrn724E7AQvKmbhOlnMRZr33vIXSd0j0L4WkjJxHgosrKw63YD77lM42@D6HirPfjICl69dgl4lPT8LpHp3LKUcxdcfsjySsf5qjBfIFeBXLGYPYTULMlnOoEFvw8ijPEAcMXCfJWxSQePVLZ2RSPAo9nqcDz@rpvW1NYfR59nxreTydfWlBoL/gA" rel="nofollow noreferrer" title="Perl 5 (cperl) – Try It Online">Try it online!</a></p>
<p>Creates all possible L's with all possible rotations and mirrors up to the dimensions of the input (with all 0-margins shaved off). Sees if any of those L's is equal to the shaved input.</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://www.dyalog.com/" rel="nofollow noreferrer">APL (Dyalog Unicode)</a>, 44 bytes</h1>
<p>thanks @Adám <a href="https://chat.stackexchange.com/transcript/message/56895801#56895801">for the <code>⍸⍣¯1</code> trick</a></p>

<pre class="lang-apl prettyprint-override"><code>(⊂a)∊(⍉¨⊢,⌽¨)⍣2≥∘i¨⍳⌈/,i←⌊/↑⍳⍴a←⍸⍣¯1(⊢-⌊/)⍸⎕
</code></pre>
<p><a href="https://tio.run/##VU/BSsNQELznK95tE0zpW48evPcbxEOwRILBlJBLKb2oxCT2BYsUvAhaEXrzoAUReumn7I/E3aSp6YNk2ZnZ2VlvFPaGYy@MLisqF0FE6aO2KLv3K5uKG8@hrLDJ5NsVFUuXZpvtyiHzfkz5B2XPAcPmi2ZZ3w14kGZFn9K5QObbE8D8sHj7iey17AntCFQuKt5g@bWiRHaF6QRcYEK@GMisgRcjpU/cX8TggyLzksTe0L/unfLP4kHY2zdT9sCRqf@Jhzs14B2TWI7iSGRWeETFrQTmFczHZ1zPmUZpprJkb6pGUTj2gzCsEjEh80v5m1j5fExzXcn3p3NQYFP@SkXKBB@4PoHoCtgQfC8IwVPx1MIEtEZ@WnWr1hqEY0B61fa6fmpfcFewC@qOWgyx8cXW/kCmExdQCjRwLWl1NY7NfoW7XteBdsk6On2QqnbBdqYOKD38AQ" rel="nofollow noreferrer" title="APL (Dyalog Unicode) – Try It Online">Try it online!</a></p>
<p><code>⍸⍣¯1(⊢-⌊/)⍸</code> trim surrounding 0s</p>
<p><code>≥∘i¨⍳⌈/,i←⌊/↑⍳⍴a</code> generate L-shapes</p>
<p><code>(⍉¨⊢,⌽¨)⍣2</code> add reflections</p>
<p><code>(⊂a)∊</code> test if the (trimmed) input is among them</p>
</div>
<div id="pu6" class="pu"><h1><a href="https://www.python.org/downloads/release/python-391/" rel="nofollow noreferrer">Python 3.9</a> + <a href="https://numpy.org/" rel="nofollow noreferrer">NumPy</a>, 167 bytes</h1>
<pre class="lang-py prettyprint-override"><code>lambda a:min(c:=(a:=a[[slice(min(i),max(i)+1)for i in a.nonzero()]]).sum(0))-min(r:=a.sum(1))|len(c)-max(r)|sum((a[:-1]^a[1:]).any(1))*sum((a[:,:-1]^a[:,1:]).any(0))-1
</code></pre>
<p>Expected input is a 2D numpy array of 0/1 (or False/True) values.</p>
<p>Returns falsey for L shape, truthy for not L shape.</p>
<p>Explanation:</p>
<p>First remove the &quot;margin&quot; / 0 column and row vectors around the input if there is any.</p>
<p>Then for both axes:</p>
<ul>
<li>Check that the row/column vector only changes once when going along that axis (this ensures that there are only 2 unique ones (one for the leg parallel, and one for the leg perpendicular), and these are all next to each other)</li>
<li>Take the sum along the axis. There should only be 2 unique values. The smaller one is the width of the leg perpendicular to the axis.
Check that the two widths are the same</li>
</ul>
<p>Then check that the width of both legs is the same</p>
<p>And then check that the length of one of the legs is the entire length of the array</p>
<p>Ungolfed + test runner (since TIO doesn't have numpy):</p>
<pre class="lang-py prettyprint-override"><code>def is_L_shape(a):
    # Remove zero vectors surrounding a
    a = a[tuple(slice(min(i), max(i)+1) for i in a.nonzero())]

    # Check columns have L-like sums
    col_sums = a.sum(0)
    col_width = min(col_sums)
    cols_in_order = sum(~(a[:,:-1]==a[:,1:]).all(0)) == 1  # Only one column should be different from the next

    # Check rows have L-like sums
    row_sums = a.sum(1)
    row_width = min(row_sums)
    rows_in_order = sum(~(a[:-1]==a[1:]).all(1)) == 1  # Only one row should be different from the next

    # Check that the legs span the entire column/row
    col_correct_length = col_sums.max() == len(row_sums)
    # row_correct_length = row_sums.max() == len(col_sums)

    return col_width == row_width and col_correct_length and cols_in_order and rows_in_order

# Test runner
f = \
lambda a:...

def run_test(s):
    import numpy as np
    s = s.strip('\n')
    if s.endswith('!'): s = s[:-1]
    a = np.row_stack([np.array(list(map(ord, line))) for line in s.split('!\n')]) == ord('#')
    is_L = not f(a)
    print(np.array(a, dtype=int), 'is an L' if is_L else 'is not an L', 'as expected' if bool(is_L) == bool(expected) else '(failure)' + '!\n'*20, end='\n\n')

expected = True

run_test('''
#    !
#    !
#####!
''')

run_test('''
#####!
#####!
   ##!
''')

run_test('''
  #### !
  #### !
  ##   !
''')

run_test('''
###!
  #!
   !
''')

run_test('''
      !
      !
  #   !
  ##  !
      !
      !
''')

run_test('''
   ## !
##### !
##### !
      !
      !
''')

expected = False

run_test('''
####!
''')

run_test('''
##  !
####!
''')

run_test('''
#####!
#### !
##   !
##   !
''')

run_test('''
#####!
#####!
  ## !
''')

run_test('''
  #    !
#######!
  #    !
  #    !
''')

run_test('''
## !
 ##!
''')

run_test('''
#####!
# ###!
#####!
# #  !
###  !
''')

run_test('''
##  #!
#  ##!
''')

run_test('''
    !
 ## !
 ## !
    !
''')

run_test('''
# #!
   !
#  !
''')

run_test('''
       !
  #    !
 ####  !
''')

run_test('''
###!
# #!
## !
''')

run_test('''
###!
   !
###!
## !
## !
''')

run_test('''
### !
### !
### !
   #!
   #!
''')

run_test('''
## !
## !
  #!
''')

run_test('''
## !
## !
  #!
  #!
''')

run_test('''
#########!
#########!
''')
run_test('''
#!
''')
run_test('''
###!
''')
</code></pre>
</div>
<div id="pu7" class="pu"><h1><a href="https://github.com/abrudz/dyalog-apl-extended" rel="nofollow noreferrer">APL (Dyalog Extended)</a>, 48 <a href="https://codegolf.meta.stackexchange.com/a/9429/43319" title="When can APL characters be counted as 1 byte each?">bytes</a> (<a href="https://github.com/abrudz/SBCS" rel="nofollow noreferrer" title=".dyalog files using a single byte character set">SBCS</a>)</h1>

<p>Anonymous tacit prefix function. Takes Boolean (0/1) matrix with 0s indicating the shape. Requires 0-based indexing.</p>
<pre class="lang-apl prettyprint-override"><code>{(=/⍵-⍥⍴e)∧i≡,e←(⊂∘⊃+∘⍳∘|1+⊃∘⌽-⊃)i←⍸⍵}1⍉⍤⌂deb⍣2⊢
</code></pre>
<p><a href="https://tio.run/##SyzI0U2pTMzJT9dNrShJzUtJTfn/qG@qp/@jtgkGXOlAsjrNFigAZDxqm/iod2vt/2oNW30gQ/dR79JHvVtSNR91LM981LlQJxWoRuNRV9OjjhmPupq1QVTvZiBZY6gN5IO4PXt1gSzNTJBhvTtAhhk@6u181LvkUU9TSmrSo97FRo@6Fv1PA8v3gTT1rgFacWi9McjuvqnBQc5AMsTDM/h/uoK6sjoUg4A6VzqMhaAVFBTgMlBhDHXqcEkcRkAlgAyYMEwCSsLNV0A3QwHVLGWYEVBVUCMxrYA4HWE8mKsAsQGZAgkCAA" rel="nofollow noreferrer" title="APL (Dyalog Extended) – Try It Online">Try it online!</a></p>
<p><code>0</code>…<code>⊢</code>⁠ with 0 as left argument and the unmodified argument as right argument:</p>
<p> …<code>⍣2</code> repeat twice</p>
<p>  …<code>⍤⌂deb</code> <strong>d</strong>elete <strong>e</strong>nding (leading and trailing) <strong>b</strong>lanks (1s), then:</p>
<p>   <code>⍉</code> transpose (so we end up deleting the top and bottom blank rows too)</p>
<p><code>{</code>…<code>}</code> apply the following lambda, with <code>⍵</code> representing its argument:</p>
<p> <code>⍸⍵</code> <strong>i</strong>ndices where there are 1s</p>
<p> <code>i←</code> save as <code>i</code></p>
<p> <code>(</code>…<code>)</code> apply the following tacit function to that:</p>
<p>  <code>⊃</code> the [index of the] first [blank]</p>
<p>  …<code>-</code> subtract that from:</p>
<p>   <code>⊃∘</code> the [index of the] first of the:</p>
<p>    <code>⌽</code> reversed [indices of blanks, i.e. the index of the last blank]</p>
<p>  <code>1+</code> increment that [to get inclusive range]</p>
<p>  <code>∘|</code> take the absolute value of that [getting the absolute range], then:</p>
<p>   <code>∘⍳</code> get the indices of that range, then:</p>
<p>    …<code>+</code> add that to:</p>
<p>     <code>⊂∘</code> the whole of…</p>
<p>      <code>⊃</code> [index of the] first [blank, giving a matrix of indices of the entire supposed blank area]</p>
<p> <code>e←</code> save as <code>e</code></p>
<p> <code>,</code> ravel into a list of indices</p>
<p> <code>i≡</code> identical to the actual list of indices of blanks?</p>
<p> <code>(</code>…<code>)∧</code> and…</p>
<p>  <code>⍵</code>…<code>e</code> considering the argument and the matrix of supposed blanks…</p>
<p>   <code>-⍥</code> are the differences in…</p>
<p>    <code>⍴</code> shapes [between heights and widths]</p>
<p>  <code>=/</code> equal? [i.e. does the height-difference match the width-difference?]</p>
</div>
<div id="pu8" class="pu"><h1><a href="http://julialang.org/" rel="nofollow noreferrer">Julia</a>, <s>175</s> 170 bytes</h1>

<pre class="lang-julia prettyprint-override"><code>a-&gt;try
r=rotr90
for _=1:4
while sum(a[1,:])&lt;1
a=a[2:end,:]end
a=r(a)end
for _=1:4
a=r(a,a[end])end
a[a[1]]
while sum(a)&gt;0
a[a[a[:,1],:]]
a=a[2:end,2:end]end
a[1]catch
end
</code></pre>
<p><a href="https://tio.run/##jVLBboQgEL3zFUQPq4k1a9NLTdl7v4GShmy10ljcINttP6Cn/mV/xA6ggu5uUoKEefPmDePM27EVvPgcajLwm51WX0gR1Wl1v0V1p/AzKco7dGpEW@H@@J5wWmQlSx8KxAmnt2UlX8CGE2yV8NTcfJzFMk4BZdbFKQgwFgqmu62FOS2zgoEYC6Tt6eQhbs/1vkFgDbrqdY8JpiiKIhT//nzPe22ZBaTMMkOX58AX/xcza7yf7zmPpY3n7B2RiTc9KI6X8t7pVVwlYVXLnFeSnidbl@XoPmBd7xoLs4XPvvQQV09o@ZzX1OKpffY/IIbQa2KanUKzP6D/CX2UmgpCNvEGm0ETWEjcClkxZ5urgfpDK7QLZXmep8iOpbGN184PwrAOSkjdSsdcIGNiB/ZNd0rqGVsyoycZpXYu/wA" rel="nofollow noreferrer" title="Julia 1.0 – Try It Online">Try it online!</a></p>
<p>returns <code>0</code> if L-shaped and <code>nothing</code> otherwise</p>
<p>It's probably not the most efficient approch but I'm glad I could match the javascript answer</p>
<p><strong>Ungolfed version</strong></p>
<pre class="lang-julia prettyprint-override"><code>function f(a)
    try
        # remove margins
        for _=1:4
            while sum(a[1,:])&lt;1
                a=a[2:end,:]
            end
            a=rotr90(a)
        end

        # rotate `a[end]` times, meaning until a[end]==0
        for _=1:4
            a=rotr90(a,a[end])
        end
        a[a[1]] # check that a[1]!=0, by erroring if a[1]==0
       &#32;
        while sum(a)&gt;0
            a[a[1,:]] # check that first line and col are all ones
            a[a[:,1]]
            a=a[2:end,2:end] # remove first line an col
        end
        a[1] # check that a is not empty (errors if empty)
    catch
        nothing
    end
end
</code></pre>
<p><a href="https://tio.run/##jVNLbuMwDN3rFKy9qA0YQVx002Dcfc/gMVqNK8easaVAYtrJAbrqLXuRjD7xR06CDuGfHp/4SIr@ve84zf8ej81e1MilgCahKQFjqA7ubS0GxXr5xqCnasuFHh2NVPBc5Jv7EbH23vKOgd73CS3zbFOlP/LAb40WtLzbMPFq/IHTQCQkKonqYT3kNXDmyUmkyOCFlsZRvQDynukMekYFF1vYC@QdeGdRrL9JftLL/JZQdqSVpraqMup1y@o/gC1FsNBNsc7g1wGYUlJZed44fK5MLnQqfVyHeZS@eQuJhiuN0HHBgIpXqKWpTJnvrgMpmD4LsclMluRy592zmk43iG1DX6k8X5YNXIOQCKzf4QESV7q2hTvAN7CmWLdjEMNuTXPIENzcR2QaNRRQkiiKSPz1@TFey5U1Q8occ@6aOOaO/xezdvo@v0YdRzs9R@8JGXhDQnEchp@cUxRfybyqUPOK6LnYsixPnzYs611ic7V52pcS8fXMV5PmtWjxcHyuD6QiZJvYw07NYb@ZuUjKJ4ElL4rb@Nb9lRy4cHNY@bUbSQPpXcfRb61Wq1VKiPXatfW6@XETtTM/HnbCMwPkJOxB3cr3pBmxkBn9FFHq5vIf" rel="nofollow noreferrer" title="Julia 1.0 – Try It Online">Try it online!</a></p>
</div>
<div id="pu9" class="pu"><h1><a href="https://github.com/m-ender/retina/wiki/The-Language" rel="nofollow noreferrer">Retina</a>, 112 bytes</h1>
<pre><code>^\s+¶|¶\s+$

/^( .*¶)+ .*$/+m`^ 

/^(.* ¶)+.* $/+m` $

/^#* /&amp;G^`
/(?m)^ /&amp;V`
/^##+(¶#.*)+/+`^#+¶#|(¶)#
$1
^\s+$
</code></pre>
<p><a href="https://tio.run/##bVDBTuMwEL3PV4zkCCUNalTYExcOIAGn5bDiskuIRaZNpMRTYhdUxHflA/JjZWw3WrRLInuSp/fezLyBXGv06lCkl31W/kY1jY@5lMekeErvq2V@KP/YfBo/plFqAlCUKS4X05jlUpIi76sSA7pcoEelBBQDVy2wOLkpK4j@8vNQeVjl6TSq5SLLi7wqlTRQH4JkCpIV@I7J4XDfvrJD274Trk7RvTF2tJFjNq6xeIba1PgDlH/9A/BFcPa/YBUE50dyvBHRC381ZAn1QGjYXQBcM1n/iY1@pWDEg2t4w0Z3ghvqt27vzS3EzmKA29C9jUKN9mUnhnBsBfDTEPIanTC9cCYO9Oy02ew6PXyZLMoAbrUVxUCzxlhHug4@b/zPJjN/zbvhW7pQIjnSw4ErbfwYbU3Gteu9DB738FkdE/RLQrC/YuO0uCL7ZQbsWSJruCM7z4J/J1KxHcDdHMmWuz33rWFMfQy20VvyOdStfWZjJAmqM9GEQf1Cnw" rel="nofollow noreferrer" title="Retina – Try It Online">Try it online!</a> Link includes test suite with header that extracts the <code>#</code>-based test cases from the input and automatically right-pads them. Explanation:</p>
<pre><code>^\s+¶|¶\s+$

/^( .*¶)+ .*$/+m`^ 

/^(.* ¶)+.* $/+m` $

</code></pre>
<p>Remove any margins. Annoyingly, this costs almost 50% of the code size.</p>
<pre><code>/^#* /&amp;G^`
</code></pre>
<p>If the first line contains a space then reverse the rows.</p>
<pre><code>/(?m)^ /&amp;V`
</code></pre>
<p>If the first column contains a space then reverse each line.</p>
<pre><code>/^##+(¶#.*)+/+`
</code></pre>
<p>Repeat while the there are at least two rows and columns of which the first of each only contains <code>#</code>s...</p>
<pre><code>^#+¶#|(¶)#
$1
</code></pre>
<p>... completely delete the first row and column.</p>
<pre><code>^\s+$
</code></pre>
<p>Check that the entire <code>L</code> was deleted.</p>
</div>
<div id="pu10" class="pu"><h1><a href="http://jsoftware.com/" rel="nofollow noreferrer">J</a>, <sup>51</sup> <sup>48</sup> 79 bytes</h1>
<pre><code>(1-'10+1'rxin'012'{~2,@,.],|:)*1&amp;#.(,~&amp;{:-:,&amp;(0{#/.~)+0{,)&amp;(|.^:({.&gt;{:)@-.&amp;0)+/
</code></pre>
<p><a href="https://tio.run/##hZBRS8MwFIXf8ysuXkhybXqX9jG1YyD45JOvojJkxY2hYvcgZPSv12aNa9F1C8mB5Hz3niSb9opVBaUDBQYsuG6lDLcP93etzlKV2SRTX9/rd2WzXPkmNwvDT2bv6DqTyNo00rvUGamtxxk3lFhvSOo9Pzvtee4dLVKWlpJZS0JUy/W25C7GCuyGOB4FhQKic8o0cHOsi0A/L2EoACaxzuqhHjusqYYg4FIcDKHYd57uFvwzN8PDbSAwgfhc1vXo5/DfA08pxbKgw@@O6@AvNcTH8KCIU1jwMeovtlvVu5L1owNdVARaoZIlFfySk@S5WL2@fUBgIHQabcPz2x8" rel="nofollow noreferrer" title="J – Try It Online">Try it online!</a></p>
<p><em>+31 thanks to Bubbler for catching a bug not revealed by the original cases</em></p>
<p><strong>NOTE: All test cases are passing again when I run locally on j902, but this now fails on TIO due to a <a href="https://www.mail-archive.com/beta@forums.jsoftware.com/msg02071.html" rel="nofollow noreferrer">J regex bug on linux/TIO</a>.</strong></p>
<p>Consider the column and row sums of:</p>
<pre><code>11111 = 5
11111 = 5
00011 = 2 (count of 2s is 1)
-----
22233
(count of 2s is 3)
</code></pre>
<p>as well as the count of the smallest number in each: 2 in this case.</p>
<p>The insight is:</p>
<pre><code>2 + (column count of 2s) = 5
2 + (row    count of 2s) = 3
</code></pre>
<p>and this fact is basically all you need to solve it.  The rest is mechanics and likely the J could be golfed a bit more.  I'll try to do that and improve this explanation tomorrow.</p>
</div>
<div id="pu11" class="pu"><h1><a href="https://www.dyalog.com/" rel="nofollow noreferrer">APL (Dyalog Unicode)</a>, 104 bytes</h1>

<pre class="lang-apl prettyprint-override"><code>{i←0⋄{(~×/1=,⍵)∧(⍴⍵)≡+/¨1⌷¨(⍉⍵)⍵}⌽∘⍉⍣{(~⊃⌽⊖⍺)∨i=4⊣i+←1}{×≢⍵:⍵⋄,0}p∧⌿⍵∧/⍨p←⌊/0~⍨+/⍵}{(¯1+⌊⌿c)↓⍵↑⍨⌈⌿c←↑⍸⍵}
</code></pre>
<p><a href="https://tio.run/##dU7NSsNAEL77FAs9bEIakqAnIScverW@QFEaAgVzlSW9tIQkZosiWq/aQ3MQerEoggjpm8yLxJnNJqLFhd2d72e@mWE0ti@uhuPLoK5FCMmNC9czYUy2C8fz@yA3JqQrA@SrKrMny6lKD4q3qkQyU6TcxFB8QvqoiCU2Qz4lJn8A@YH9ZegfQL4MLYz3YrFdQPaMXYd4cVjfjSOcAcUX4XTlgCwjdEKRO@4EgeXQCGFUa89CEo3nJiR35E5uUYciJY5aCL@Tux4RlHPaRL7g@tV6n9T5/eD0CN@z45NBHaBHIGg7aZsGco6lwW3b5rh4w414j/uNz2TxXsAQ60uHK0ZVPz9jrFM0vePjnfhPhBawaOlW0G@Xz/5msN9ZvTZCu3Tk7ohmdR3/DQ" rel="nofollow noreferrer" title="APL (Dyalog Unicode) – Try It Online">Try it online!</a></p>
<p>A train of two dfns which takes a matrix of 0's and 1's as argument.</p>
<p>Can be simplified a lot using Jonah's idea.</p>
<p>It simplifies the matrix like so:</p>
<pre class="lang-apl prettyprint-override"><code>#####
##### →  ####
   ##       #
</code></pre>
<p>rotates it to put the corner at the top left:</p>
<pre class="lang-apl prettyprint-override"><code>##
#
#
#
</code></pre>
<p>and then checks if the first row and first column match its shape.</p>
</div>
<div id="pu12" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="noreferrer">05AB1E</a>, <s>31</s> <s>30</s> 17 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="noreferrer">bytes</a></h1>
<pre><code>ø‚O0δÚDWδåsεÔg&lt;}Q
</code></pre>
<p><a href="https://tio.run/##yy9OTMpM/f//8I5HDbP8Dc5tOTzLJRxILi0@t/XwlHSb2sD//6OjDXQMQTBWB4NlgMYCw9hYAA" rel="noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/V@m5JlXUFpipaBkX6nDVel1aLcOl5J/aQlMzOX/4R2PGmb5G5zbcniWSziQXFp8buvhKek2tYH/dQ5ts/8fHR1tqGMAgbE6aGwojI3VUYhG4uqgsCEa4MqgHDA0gEpj40NsgWpBmIXKMkBjIWnCcBuKo3E7GaYI2ZeYxmL1JUQ7ki@xhBWKcoQ8Kh/hZpj/sFlugNUhhjCT4OKoJoKk4RGJEisGGMGJNWARJiDFL8wLMIsMUKQMccclvhiE6gBTsbEA" rel="noreferrer">verify all test cases</a>.</p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>ø            # Zip/transpose the (implicit) input-matrix, swapping rows/columns
 ‚           # Pair it together with the (implicit) input-matrix
  O          # Take the sum of each row of both matrices
             # Remove any leading/trailing rows/columns of 0s:
    δ        #  Map over both the inner lists of row-sums:
   0 Ú       #   And trim all leading/trailing 0s
      D      # Duplicate it
             # Check if the pivot is a square:
       W     #  Get the flattened minimum (without popping)
        δ    #  Map over both lists of row-sums:
         å   #   And check if this minimum is present in the row-sums
             #  (this will result in [1,1] if the minimum sum is present in both the
             #   row-sums and column-sums, which means the pivot is a square)
             # Check if the matrix forms an L-shape:
      s      #  Swap so the duplicated pair of row-sums is at the top again
       ε     #  Map over both inner lists:
        Ô    #   Connected uniquify the sums
         g   #   Pop and push the length
          &lt;  #   And decrease this by 1
       }     #  Close the map
             #  (this will result in [1,1] if the matrix forms an L-shape, which means
             #   the lengths were 2 for both the row-sums and column-sums after the
             #   connected uniquify)
             # Check that all four values are truthy:
        Q    #  Check if both pairs are equal
             # (after which the result is output implicitly)
</code></pre>
<p>NOTE: the <code>Q</code> would also incorrectly result in truthy if both pairs are <span class="math-container">\$[1,0]\$</span> for example, but there isn't any test case where both pairs would be the same apart from the truthy <span class="math-container">\$[1,1]\$</span> test cases. (If there were, we could have used <code>«P</code> - merge; check if all four are truthy - instead.) The reason why the pairs can never be the same except for the truthy test cases:</p>
<ol>
<li>We check if the flattened minimum of the sums is present in both inner lists. Since we took the minimum from the lists, this can only ever result in <span class="math-container">\$[1,1]\$</span>, <span class="math-container">\$[0,1]\$</span>, or <span class="math-container">\$[1,0]\$</span> (this will also result in <span class="math-container">\$[1,1]\$</span> if the input-matrix is empty).</li>
<li>The <code>εÔg&lt;}</code> will however not result in <span class="math-container">\$[1,1]\$</span> for empty matrices, nor will it ever result in <span class="math-container">\$[0,1]\$</span> or <span class="math-container">\$[1,0]\$</span>. For either the sums of rows or columns to result in <span class="math-container">\$0\$</span>, it would mean all values in those rows/columns are equal, but this implicitly means the same applies vice-versa and it's a rectangle matrix of the same values. The <code>εÔg&lt;}</code> can only result in:
<ul>
<li><span class="math-container">\$[-1,-1]\$</span>: which meant the input was empty, or only contained <span class="math-container">\$0\$</span>s (<a href="https://tio.run/##yy9OTMpM/f//8I5HDbP8Dc5tOTzLJRxILi0@t/XwlHSbWqDw///RsQA" rel="noreferrer">try it online</a>);</li>
<li><span class="math-container">\$[0,0]\$</span>: which meant the input-matrix was a rectangle of <span class="math-container">\$1\$</span>s, after we've trimmed all leading/trailing <span class="math-container">\$0\$</span>s (<a href="https://tio.run/##yy9OTMpM/f//8I5HDbP8Dc5tOTzLJRxILi0@t/XwlHSbWqDw///R0QY6YBirA2QZAiE6CyIbCwA" rel="noreferrer">try it online</a>);</li>
<li><span class="math-container">\$[1,1]\$</span>: our expected truthy result for L-shaped matrices (<a href="https://tio.run/##yy9OTMpM/f//8I5HDbP8Dc5tOTzLJRxILi0@t/XwlHSbWqDw///R0QY6BjqGUGgQq4OTD6INYmMB" rel="noreferrer">try it online</a>);</li>
<li>or larger than <span class="math-container">\$[1,1]\$</span> - i.e. <span class="math-container">\$[1,3]\$</span>, <span class="math-container">\$[2,4]\$</span>, etc.: if the input-matrix contained gaps in one or multiple of the rows/columns (<a href="https://tio.run/##yy9OTMpM/f//8I5HDbP8Dc5tOTzLJRxILi0@t/XwlHSbWqDw///R0QY6BjqGsTrRhjqGYBrEN4DShrGxAA" rel="noreferrer">try it online</a>).</li>
</ul>
</li>
</ol>
</div>
<div id="pu13" class="pu"><h1><a href="https://v8.dev/" rel="noreferrer">JavaScript (V8)</a>, 500 bytes</h1>
<p>Lots of golfing possible.</p>

<pre class="lang-javascript prettyprint-override"><code>M=&gt;{R=M.map(m=&gt;m.join``);if(R.find(r=&gt;r.match(/10+1/)))return;o = [];for(i=n=0;i&lt;R[L=&quot;length&quot;];i++)if((r=R[i]).includes`1`){if(n)return;n=0;o.push([r.indexOf`1`,r.lastIndexOf`1`])}else{if(o[L])n=1;else continue}if(o.every(r=&gt;r[0]==o[0][0])){}else if(o.every(r=&gt;r[1]==o[0][1]))o=o.map(r=&gt;[R[0][L]-r[1],R[1][L]-r[0]]);else return;d=[];for(i=0;i&lt;o[L];i++){if(o[i][1]!=(d[0]||0)[0])d.unshift([o[i][1],1]);else d[0][1]++}return d[L]== 2&amp;&amp;(d[0][1]==o[0][1]-o[0][0]+1||d[1][1]==o[o[L]-1][1]-o[o[L]-1][0]+1)}
</code></pre>
<p><a href="https://tio.run/##xVFda4MwFH3vr3B9KAl@1Oxp4NL3gWXgawgoNc4Um0jUslH727vEj66MMiwrm1wCOffcc06u22SfVBvFy9rdP50yfFrj1SHCa2@XlGCHVztvK7mIYxjwDERexkUKFF4p3a83OVgi30ZLCKFidaNEIC1sERpkUgGOBfYD/hyREM8LJt7qfE4DbttQK2mNiHAKPS42RZOyKkYxPOiGGJXMsPTKpsoBUZqWsvfXTLMc5RVJVb@cAQqPrKiYGZYkpFBgFBjA2khRc9Gwo@l4bM/URxed@BRjqU9dEB66aes7B40cpDkSy24fukMiA4bUNRQn0kd/8SmFve2QP8XnPZgtmGjd4/uc3Ag/YJDqwbb1oYmSeo2ocp7VgAwEB42iaR/Fto@9vAZCndB6XCzA0DvndYe32ahtUxOw75kELhoI48Ww4PFUKi5qkAEys/RHfMf6KuqcQXQL2NcleKE501udzX5pi/7CFv3Da9E124ngvW0n/o672vrXNv8DeLvtdIcpSz59Ag" rel="noreferrer" title="JavaScript (V8) – Try It Online">Try it online!</a></p>
<p>Outputs truthy/falsy. Inputs as a multidimensional array of <code>0</code> and <code>1</code>.</p>
<p><strong>Explanation:</strong></p>
<ol>
<li>Join into rows, and do a regex to check for lines that have two vertical parts (<code>10+1</code>, which can't be <code>L</code> shapes)</li>
<li>Create a list of the first and last index of each <code>1</code> for every line containing a <code>1</code>, and return a falsy value immediately if there's a line with no <code>1</code>s between two that have ones (which can't be <code>L</code> shapes)</li>
<li>If the &quot;stem&quot; of the <code>L</code> is on the right, flip it horizontally</li>
<li>Make a list of each group of lines where the width of the <code>1</code>s is the same, and note its height</li>
<li>Check if there are two of these sections (i.e., ensure it's not a rectangle or an <code>E</code>/<code>F</code>/jagged thingy)</li>
<li>Check if the width of the stroke is the same horizontally and vertically</li>
</ol>
<p><strong>Ungolfed:</strong></p>
<pre class="lang-javascript prettyprint-override"><code>f = (matrix) =&gt; {
    var rows = matrix.map(m =&gt; m.join(&quot;&quot;));
    
    if (rows.find(r =&gt; r.match(/10+1/)))
        return false;
    
    var o = [];
    var n;
    
    for (var r, i = 0; i &lt; rows.length; i++) {
        r = rows[i];
        
        if (r.includes(&quot;1&quot;)) {
            if (n)
                return false;
            
            n = false;
            
            o.push([r.indexOf(&quot;1&quot;), r.lastIndexOf(&quot;1&quot;)]);
        } else {
            if (o.length)
                n = true;
            else
                continue;
        }
    }
    
    if (o.every(r =&gt; r[0] == o[0][0])) {
    } else if (o.every(r =&gt; r[1] == o[0][1])) {
        o = o.map(r =&gt; [rows[0].length - r[1], rows[1].length - r[0]]);
    } else {
        return false;
    }
    
    var d = [];
    
    for (i = 0; i &lt; o.length; i++) {
        if (o[i][1] != (d[0]||0)[0])
            d.unshift([o[i][1], 1]);
        else
            d[0][1]++;
    }
    
    return d.length == 2 &amp;&amp; (d[0][1] == o[0][1] - o[0][0] + 1 || d[1][1] == o[o.length - 1][1] - o[o.length - 1][0] + 1);
}
<span class="math-container">```</span>
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/218059/">218059</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




