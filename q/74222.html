<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::74222</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>032</td><td>Zsh</td><td>241215T062809Z</td><td><a href="https://codegolf.stackexchange.com/questions/74222/reimplement-the-wc-coreutil/277276#277276">roblogic</a></td></tr>
<tr d-ix="1"><td>248</td><td>Pascal</td><td>230306T010009Z</td><td><a href="https://codegolf.stackexchange.com/questions/74222/reimplement-the-wc-coreutil/258853#258853">Kai Burg</a></td></tr>
<tr d-ix="2"><td>079</td><td>Ruby p0</td><td>221020T205526Z</td><td><a href="https://codegolf.stackexchange.com/questions/74222/reimplement-the-wc-coreutil/253515#253515">Jordan</a></td></tr>
<tr d-ix="3"><td>014</td><td>Jelly</td><td>181228T155232Z</td><td><a href="https://codegolf.stackexchange.com/questions/74222/reimplement-the-wc-coreutil/178106#178106">Erik the</a></td></tr>
<tr d-ix="4"><td>115</td><td>Powershell</td><td>180926T151303Z</td><td><a href="https://codegolf.stackexchange.com/questions/74222/reimplement-the-wc-coreutil/172839#172839">mazzy</a></td></tr>
<tr d-ix="5"><td>025</td><td>Pip s</td><td>180925T184528Z</td><td><a href="https://codegolf.stackexchange.com/questions/74222/reimplement-the-wc-coreutil/172805#172805">DLosc</a></td></tr>
<tr d-ix="6"><td>023</td><td>05AB1E</td><td>180925T132259Z</td><td><a href="https://codegolf.stackexchange.com/questions/74222/reimplement-the-wc-coreutil/172798#172798">Kevin Cr</a></td></tr>
<tr d-ix="7"><td>178</td><td>C</td><td>160227T191319Z</td><td><a href="https://codegolf.stackexchange.com/questions/74222/reimplement-the-wc-coreutil/74342#74342">user4677</a></td></tr>
<tr d-ix="8"><td>140</td><td>Haskell</td><td>160227T061226Z</td><td><a href="https://codegolf.stackexchange.com/questions/74222/reimplement-the-wc-coreutil/74318#74318">arjanen</a></td></tr>
<tr d-ix="9"><td>065</td><td>Retina</td><td>160226T180849Z</td><td><a href="https://codegolf.stackexchange.com/questions/74222/reimplement-the-wc-coreutil/74265#74265">FryAmThe</a></td></tr>
<tr d-ix="10"><td>066</td><td>Lua</td><td>160226T153514Z</td><td><a href="https://codegolf.stackexchange.com/questions/74222/reimplement-the-wc-coreutil/74250#74250">Jesse Pa</a></td></tr>
<tr d-ix="11"><td>039</td><td>Seriously</td><td>160226T034654Z</td><td><a href="https://codegolf.stackexchange.com/questions/74222/reimplement-the-wc-coreutil/74233#74233">user4594</a></td></tr>
<tr d-ix="12"><td>061</td><td>Perl</td><td>160226T131731Z</td><td><a href="https://codegolf.stackexchange.com/questions/74222/reimplement-the-wc-coreutil/74245#74245">Kenney</a></td></tr>
<tr d-ix="13"><td>049</td><td>Perl</td><td>160226T134152Z</td><td><a href="https://codegolf.stackexchange.com/questions/74222/reimplement-the-wc-coreutil/74247#74247">Ton Hosp</a></td></tr>
<tr d-ix="14"><td>140</td><td>PowerShell</td><td>160226T142021Z</td><td><a href="https://codegolf.stackexchange.com/questions/74222/reimplement-the-wc-coreutil/74248#74248">AdmBorkB</a></td></tr>
<tr d-ix="15"><td>065</td><td>POSIX awk</td><td>160226T093056Z</td><td><a href="https://codegolf.stackexchange.com/questions/74222/reimplement-the-wc-coreutil/74240#74240">muru</a></td></tr>
<tr d-ix="16"><td>115</td><td>JavaScript ES6</td><td>160226T114815Z</td><td><a href="https://codegolf.stackexchange.com/questions/74222/reimplement-the-wc-coreutil/74243#74243">Neil</a></td></tr>
<tr d-ix="17"><td>038</td><td>MATL</td><td>160226T051107Z</td><td><a href="https://codegolf.stackexchange.com/questions/74222/reimplement-the-wc-coreutil/74236#74236">David</a></td></tr>
<tr d-ix="18"><td>081</td><td>Julia</td><td>160226T013047Z</td><td><a href="https://codegolf.stackexchange.com/questions/74222/reimplement-the-wc-coreutil/74226#74226">Alex A.</a></td></tr>
<tr d-ix="19"><td>021</td><td>Pyth</td><td>160226T055411Z</td><td><a href="https://codegolf.stackexchange.com/questions/74222/reimplement-the-wc-coreutil/74238#74238">isaacg</a></td></tr>
<tr d-ix="20"><td>108</td><td>Ruby</td><td>160226T035410Z</td><td><a href="https://codegolf.stackexchange.com/questions/74222/reimplement-the-wc-coreutil/74234#74234">afuous</a></td></tr>
<tr d-ix="21"><td>077</td><td>Python 2</td><td>160226T025536Z</td><td><a href="https://codegolf.stackexchange.com/questions/74222/reimplement-the-wc-coreutil/74231#74231">Logic Kn</a></td></tr>
<tr d-ix="22"><td>026</td><td>CJam</td><td>160226T014542Z</td><td><a href="https://codegolf.stackexchange.com/questions/74222/reimplement-the-wc-coreutil/74227#74227">Dennis</a></td></tr>
<tr d-ix="23"><td>253</td><td>AppleScript</td><td>160226T015818Z</td><td><a href="https://codegolf.stackexchange.com/questions/74222/reimplement-the-wc-coreutil/74229#74229">Addison </a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.zsh.org/" rel="nofollow noreferrer">Zsh</a>, 32 bytes</h1>

<pre class="lang-none prettyprint-override"><code>echo ${(wf)#S} ${(w)#S} $[$#S+1]
</code></pre>
<p><a href="https://tio.run/##qyrO@B9sq5SRqVCSkVqUypVWlJqYnViVn5lSzJWpkJirkJdfopCoUJSflF@iqKjIpcRVnmxjY6MS/D81OSNfQaVaozxNUzm4FsyCMKJVlIO1DWP//wcA" rel="nofollow noreferrer" title="Zsh – Try It Online">Try it online!</a></p>
<p>Using Zsh <a href="https://zsh.sourceforge.io/Doc/Release/Expansion.html#Parameter-Expansion-Flags" rel="nofollow noreferrer">parameter expansion flags</a>. <code>(f)</code> splits a string on newlines. <code>(w)</code> counts 'words' in a string; usually space delimited, but with <code>(s)</code> or <code>(f)</code> flags the 'words' can be delimited by other separators. And finally <code>$#S</code> counts the bytes in string <code>S</code>, but omits the terminating null byte so I had to add <code>1</code>.</p>
</div>
<div id="pu1" class="pu"><h2>Pascal, 248 bytes</h2>
<p>This complete <code>program</code> requires a processor supporting “Extended Pascal” as defined by ISO standard 10206.</p>
<ul>
<li>The variable <code>input</code> possesses the built-in data type <code>text</code>.
As such any newline character (sometimes it’s CR, sometimes LF, sometimes CR+LF, or something else) is <em>automagically</em> converted into a single space character (<code>' '</code>).
In order to distinguish from a space character as <em>payload</em> of a line, and a space character that resulted from this conversion, you will need to query the function <code>EOLn</code>.</li>
<li>A <code>text</code> variable is conceptually similar to a <code>file of char</code>.
This <code>program</code> in fact counts <em>characters</em>, i. e. actually behaves like <code>wc ‑m</code>.
However, since the task states that characters strictly draw from the ASCII character set, there is no difference.</li>
</ul>
<pre class="lang-pascal prettyprint-override"><code>program c(input,output);var l,w,c,z:integer value 0;p:char;begin p:=' ';while not EOF do begin c:=c+1;l:=l+ord(EOLn);w:=w+card([p]*[' ','   ']-[input^]);p:=input^;get(input)end;z:=trunc(ln(card([0..l,0..w,0..c]))/ln(10))+2;writeLn(l:z-1,w:z,c:z)end.
</code></pre>
<p>Ungolfed and annotated version:</p>
<pre class="lang-pascal prettyprint-override"><code>{ By listing a `program` parameter of the spelling `input`,
  there’s an implicit `reset(input)` which implies a `get(input)`. }
program wordCount(input, output);
    var
        { `line`, `word` and `character` are singular, because they kind
          of enumerate these units as if input was a zero-based `array`. }
        line, word, character, width: integer value 0;
        previousCharacter: char;
    begin
        { This program counts “word beginnings” as words. This is the
          _change_ from “space character” _to_ “non-space character”. }
        previousCharacter := ' ';
        
        while not EOF(input) do
        begin
            character := character + 1;
            { As per POSIX specification a line is payload _plus_ one newline. }
            line := line + ord(EOLn(input));
            { The second character literal is an HT (horizontal tabulator). }
            word := word + card([previousCharacter] * [' ', '   '] - [input^]);
            
            { Prepare `previousCharacter` for _next_ iteration. }
            previousCharacter := input^;
            { Advance “reading cursor”. }
            get(input);
        end;
        
        { To produce POSIX-compliant output write:
        
            writeLn(line:1, ' ', word:1, ' ', character:1);
        
          As per task specification we will determine a common width though.
          We use ⌊ln(N) / ln(10)⌋ + 1 as the base formula, where N needs to be
          the largest number from `line`, `word` and `character`. This can be
          found by the expression |[0, line] ∪ [0, word] ∪ [0, character] ∩ ℤ|.
          We add another +1 for the space _between_ numbers. }
        width := trunc(ln(card([0..line, 0..word, 0..character])) / ln(10)) + 2;
        writeLn(line:width-1, word:width, character:width);
    end.
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a> <code>-p0</code>, 79 bytes</h1>
<p>Includes a trailing space in the output.</p>
<pre class="lang-ruby prettyprint-override"><code>a=[/
/,/\S+/,/./m].map{$_.scan(_1).size}
$_=&quot;%#{a.map{_1.to_s.size}.max}d &quot;*3%a
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m72kqDSpcnm0km6BgVLsgqWlJWm6Fjf9E22j9bn0dfRjgrWBpJ5-bqxebmJBtUq8XnFyYp5GvKGmXnFmVWotl0q8rZKqcnUiWDreUK8kP74YIgUUqahNUVDSMlZNhBgLNX3BqkQuLq4krmSuFC6ICAA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<h2><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a> <code>-p0</code>, 84 bytes</h2>
<p>No trailing space.</p>
<pre class="lang-ruby prettyprint-override"><code>a=[/
/,/\S+/,/./m].map{$_.scan(_1).size}
$_=[&quot;%#{a.map{_1.to_s.size}.max}d&quot;]*3*&quot; &quot;%a
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m72kqDSpcnm0km6BgVLsgqWlJWm6FjdDEm2j9bn0dfRjgrWBpJ5-bqxebmJBtUq8XnFyYp5GvKGmXnFmVWotl0q8bbSSqnJ1Ilg-3lCvJD--GCIHFKmoTVGK1TLWUlJQUk2EmA21YsGqRC4uriSuZK4ULogIAA" rel="nofollow noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 14 bytes</h1>

<pre><code>»⁶Ḳ¹ƇLṭċ⁷$;LWG
</code></pre>

<p><a href="https://tio.run/##ATcAyP9qZWxsef//wrvigbbhuLLCucaHTOG5rcSL4oG3JDtMV0f///8iICBhIGIgYyBkIGUgZiAgXG4i" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>

<p>-1 thanks to <a href="https://codegolf.stackexchange.com/users/12012/dennis">Dennis</a>.</p>
</div>
<div id="pu4" class="pu"><h1>Powershell, <s>123</s> 115 bytes</h1>



<pre class="lang-powershell prettyprint-override"><code>switch -r($args|% t*y){'\s'{$a=0}'\S'{$w+=!$a;$a=1}'(?s).'{$b++}'
'{$l++}}$c="$b".Length
"{0,$c} {1,$c} $b"-f$l,+$w
</code></pre>

<p>Test script:</p>

<pre class="lang-powershell prettyprint-override"><code>$f = {

switch -r($args|% t*y){    # evaluate all matched cases
    '\s'   {$a=0}          # any whitespace (newline not included)
    '\S'   {$w+=!$a;$a=1}  # any not-whitespace (newline not included)
    '(?s).'{$b++}          # any char (newline included!)
    '`n'   {$l++}          # new line char
}
$c="$b".Length
"{0,$c} {1,$c} $b"-f$l,+$w


}

@(
    , ("a b c d`n", "1 4 8")
    , ("a b c d e f`n", " 1  6 12")
    , ("  a b c d e f  `n", " 1  6 16")
    , ("a`nb`nc`nd`n", "4 4 8")
    , ("a`n`n`nb`nc`nd`n", " 6  4 10")
    , ("abc123{}[]()...`n", " 1  1 16")
    , ("`n", "1 0 1")
    , ("   `n", "1 0 4")
    , ("`n`n`n`n`n", "5 0 5")
    , ("`n`n`na`nb`n", "5 2 7")
) | % {
    $s,$e = $_
    $r = &amp;$f $s
    "$($e-eq$r): $r"
}
</code></pre>

<p>Output:</p>

<pre class="lang-powershell prettyprint-override"><code>True: 1 4 8
True:  1  6 12
True:  1  6 16
True: 4 4 8
True:  6  4 10
True:  1  1 16
True: 1 0 1
True: 1 0 4
True: 5 0 5
True: 5 2 7
</code></pre>

<p>Explanation:</p>

<ul>
<li><code>$args|% t*y</code> splits arument strings into chars</li>
<li><code>switch -r($args|% t*y)</code> evaluate <em>all matched cases</em>

<ul>
<li><code>'\s'</code> case for any whitespace</li>
<li><code>'\S'</code> case for any non-whitespace</li>
<li><code>'(?s).'</code> case for any char (newline included)</li>
<li><code>'\n'</code> case for newline char (newline represent itself)</li>
</ul></li>
<li><code>$c="$b".Length</code> calculate a length of bytes number. $b is always max($l,$w,$b) by design</li>
<li><code>"{0,$c} {1,$c} $b"-f$l,+$w</code> format numbers with same length. The variable $w converts to int. It need for strings without words. Other variables formats 'as is' because 'The input will always contain a trailing newline' and $l and $b cannot be 0.</li>
</ul>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/dloscutoff/pip" rel="nofollow noreferrer">Pip</a> <code>-s</code>, 25 bytes</h1>

<pre><code>sX##a-#_._M[nNa`\S+`Na#a]
</code></pre>

<p>Takes the multiline string as a command-line argument. <a href="https://tio.run/##K8gs@P@/OEJZOVFXOV4v3jc6zy8xISZYO8EvUTkx9v///7rF/xO5uLiSuJK5UrgA" rel="nofollow noreferrer" title="Pip – Try It Online">Try it online!</a></p>

<p><em>Thanks to <a href="https://codegolf.stackexchange.com/a/74227/16766">Dennis's CJam answer</a> for making me realize that the longest number is always the character count.</em></p>

<h3>Explanation</h3>

<pre><code>                           s is space; n is newline; a is 1st cmdline arg (implicit)
           [            ]  Construct a list of three elements:
            nNa             Number of newlines in a
               `\S+`Na      Regex search: number of runs of non-whitespace characters in a
                      #a    Length of a (i.e. number of characters in a)
          M                To each element of that list, map this function:
   #a                       Number of characters in a
  #                         Length of that number
     -#_                    Subtract length of each element
sX                          Construct a string of that many spaces
        ._                  Prepend it to the element
                           The resulting list is autoprinted, space-separated (-s flag)
</code></pre>

<hr>

<p>Here's a 29-byte solution with flags <code>-rs</code> that takes input from stdin:</p>

<pre><code>[#g`\S+`NST:gY#g+1]MsX#y-#_._
</code></pre>

<p><a href="https://tio.run/##K8gs@P8/Wjk9ISZYO8EvOMQqPVI5Xdsw1rc4QrlSVzleL/7//0QuLq4krmSuFIVUrv@6RcUA" rel="nofollow noreferrer" title="Pip – Try It Online">Try it online!</a></p>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, <s>24</s> 23 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>¨¶¡¹… 
    S¡õK¹)€g§Zg&gt;jJ¦
</code></pre>
<p><code>j</code> is currently bugged, so could have been 21 bytes without the <code>§</code> and <code>J</code>..</p>
<p><a href="https://tio.run/##AT4Awf9vc2FiaWX//8KowrbCocK54oCmIAoJU8Khw7VLwrkp4oKsZ8KnWmc@akrCpv//IiIiYQoKCmIKYwpkCiIiIg" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/V9W@f/QikPbDi2sfNSwTIGLM/jQwsNbvSs1HzWtST@0PCrdLsvr0LL/QDmlw/uVdP5HKyUqJCkkK6TE5CnpwNgKqQppYL6CApKIggJETUxeUkxeckxeCowLgihCScmGRsbVtdGxGpp6enpgMahxClAODMI5EFOVYgE" rel="nofollow noreferrer">verify all test cases</a>.</p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>¨          # Remove the trailing newline of the (implicit) input
 ¶¡        # And split it on newlines
¹… 
    S¡     # Take the first input again, and split it on [&quot; \n\t&quot;]
      õK   # Then remove all empty string items
¹          # And take the first input again as is
)          # Wrap all three value of the stack to a single list
 €g        # Take the length of each of the items
   §       # Cast the integers to strings (should have been implicit, but `j` is bugged)
    Z      # Take the max (always the last / amount of bytes) (without popping the list)
     g&gt;    # Take the length + 1 of this max
       j   # Append leading spaces so all items or of this length
        J  # Join them together (should have been done by the `j` already, but it's bugged)
         ¦ # Remove the leading space (and output implicitly to STDOUT)
</code></pre>
</div>
<div id="pu7" class="pu"><h1>C, <strike>180</strike> 178 bytes</h1>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
main(b,w,l,c,d){d=' ';b=w=l=0;while((c=fgetc(stdin))!=EOF){if(!isspace(c)&amp;&amp;isspace(d))w++;b++;d=c;if(c==10)l++;}printf("%d %d %d\n",l,w,b);}
</code></pre>
</div>
<div id="pu8" class="pu"><h1>Haskell, 140 bytes</h1>
<pre><code>import Text.Printf
w h=let{l=length;s=show.l;c=s h;m=s.words$h;n=s.lines$h;f=maximum$map l[c, m, n];p=printf&quot;%*s&quot;f}in p n++' ':p m++' ':p c
</code></pre>
<p>The ungolfed version is hereunder, with expanded variable and function names:</p>
<pre><code>import Text.Printf

wc str =
  let charcount = show.length $ str
      wordcount = show.length.words $ str
      linecount = show.length.lines $ str
      fieldwidth = maximum $ map length [charcount, wordcount, linecount]
      printer = printf &quot;%*s&quot; fieldwidth
  in printer linecount ++ (' ' : printer wordcount ++ (' ' : printer charcount))
</code></pre>
<p>This is a function that accepts a string and returns a string. It just uses the <code>Prelude</code> functions <code>words</code> (resp. <code>lines</code>) to get the number of words (resp. lines) given that they seem to use the same definition as <code>wc</code>, then gets the longest value (as a string) amongst the counts and use the printf format taking the width amongst its arguments for formatting.</p>
</div>
<div id="pu9" class="pu"><h1>Retina, 65</h1>

<pre><code>^((\S+)|(¶)|.)*
$#3 $#2 $.0
+`(\b(.)+ )(?!.*\b(?&lt;-2&gt;.)+$)
a$1
a
&lt;space&gt;
</code></pre>

<p><a href="http://retina.tryitonline.net/#code=XigoXFMrKXwowrYpfC4pKgokIzMgJCMyICQuMAorYChcYiguKSsgKSg_IS4qXGIoPzwtMj4uKSskKQphJDEKYQog&amp;input=YWEKCgpiIGMgZCBlIGYgZyBoIGkgaiBrCmwKbQo" rel="nofollow">Try it Online!</a></p>

<p>The first stage is the actual wc program, the rest of it is for padding. The <code>a</code> placeholder thing is probably unnecessary, and some of the groups can probably be simplified a bit.</p>
</div>
<div id="pu10" class="pu"><h1>Lua, <s>74</s> 66 bytes</h1>

<p>Golfed:</p>

<pre><code>t=arg[1]_,l=t:gsub('\n','')_,w=t:gsub('%S+','')print(l,w,t:len())
</code></pre>

<p>Ungolfed:</p>

<pre><code>text = arg[1]
_,lines = text:gsub('\n','')
_,words = text:gsub('%S+','')
print(lines, words, text:len())
</code></pre>

<p>Receives input through command line arguments.</p>

<p>We rename the first argument (<code>arg[1]</code>) to save bytes. <code>string.gsub</code> returns the number of replacements as well as the modified string, so we're using that to count first <code>'\n'</code> (newlines), then <code>'%S+'</code> (instances of one or more non-whitespace characters, as many as possible, i.e. words). We can use anything we want for the replacement string, so we use the empty string (<code>''</code>) to save bytes. Then we just use <code>string.len</code> to find the length of the string, i.e. the number of bytes. Then, finally, we print it all.</p>
</div>
<div id="pu11" class="pu"><h2><a href="https://github.com/Mego/Seriously" rel="noreferrer">Seriously</a>, 39 bytes</h2>
<pre><code>&quot;
 &quot;╩╜l;$l╝@╜sl'
╜ck`#╛#&quot;{:&gt;%d}&quot;%f`M' j
</code></pre>
<p><a href="http://seriously.tryitonline.net/#code=IgogIuKVqeKVnGw7JGzilZ1A4pWcc2wnCuKVnGNrYCPilZsjIns6PiVkfSIlZmBNJyBq&amp;input=ImFiYzEyM3t9W10oKS4uLlxuIg" rel="noreferrer">Try it online!</a></p>
<p>Explanation (newlines are replaced with <code>\n</code>):</p>
<pre><code>&quot;\n &quot;╩╜l;$l╝@╜sl'\n╜ck`#╛#&quot;{:&gt;%d}&quot;%f`M' j
&quot;\n &quot;                                      push a string containing a newline and a space
     ╩                                     push input to register 0 (we'll call it s)
      ╜l;                                  push two copies of len(s) (byte count)
         $l╝                               push len(str(len(s))) to register 1
                                            (this will serve as the field width in the output)
            @╜sl                           push word count by getting the length of the list formed by
                                            splitting s on spaces and newlines
                '\n╜c                      count newlines in input
                     k                     push stack to list
                      `#╛#&quot;{:&gt;%d}&quot;%f`M     map:
                       #                     listify
                        ╛#                   push reg 1 (field width), listify
                          &quot;{:&gt;%d}&quot;           push that string
                                  %          do old-style string formatting for field width
                                   f         do new-style string formatting to pad the field appropriately
                                      ' j  join on spaces
</code></pre>
</div>
<div id="pu12" class="pu"><h1>Perl, <s>71</s> <s>62</s> 61 bytes</h1>

<p><em>includes +1 for <code>-n</code></em></p>

<pre><code>$;=length($b+=y///c);$w+=split$"}{printf"%$;d %$;d $b",$.,$w
</code></pre>

<p>Commented:</p>

<pre><code>while (&lt;&gt;) {                         # implicit because of -n
    $; = length(                     # printf formatting: width
       $b += y///c                   # count characters
    );
    $w += split $"                   # count words
}{                                   # explicit: end while, begin END block
    printf "%$;d %$;d $b", $., $w    #  $. = $INPUT_LINE_NUMBER
}                                    # implicit because of -n
</code></pre>

<ul>
<li>Save another byte, again thanks to @TonHospel.</li>
<li>Save 9 bytes thanks to @TonHospel showing me a few tricks of the trade!</li>
</ul>
</div>
<div id="pu13" class="pu"><h1>Perl, 49 bytes</h1>

<p>Added +3 for <code>-an0</code></p>

<p>Input on STDIN or 1 or more filenames as arguments.
Run as <code>perl -an0 wc.pl</code></p>

<p><code>wc.pl</code>:</p>

<pre><code>/\z/g;pos=~//;printf"%@+d %@+d $`
",y/
//,~~@F
</code></pre>

<p>Explanation:</p>

<pre><code>-n0      slurps the whole input into $_ and says we will do our own printing
-a       tells perl to split the input on whitespace into array @F
/\z/g    Matches the absolute end of the input. g modifier so the position 
         is remembered in pos which will now contain the input length
pos=~//  An empy regex repeats the last succesful match, so /\z/ again.
         After that $` will contain the the number of input characters and
         the array @+ will contain the length of this number
printf   All preparation is complete, we can go print the result
"%@+d"   will become e.g. %6d if the number of characters is a number of
         length 6, so lines and words will get printed right aligned 
         in a field of length 6.
$`       $` we can directly interpolate since it won't contain a %
y/\n//   Count the number of newlines in $_
~~@F     The array of words @F in scalar context gives the number of words
</code></pre>
</div>
<div id="pu14" class="pu"><h2>PowerShell, 140 bytes</h2>
<pre><code>param($a)$c=&quot;$((($l=($a-split&quot;`n&quot;).Count-1),($w=($a-split&quot;\S+&quot;).Count-1),($b=$a.length)|sort)[-1])&quot;.Length;
&quot;{0,$c} {1,$c} {2,$c}&quot;-f$l,$w,$b
</code></pre>
<p><sub>(newline left in for clarity :D)</sub></p>
<p>The first line takes input <code>$a</code>, and then the next part is all one statement. We're setting <code>$c</code> equal to <em>some-string's</em> <code>.length</code>. This will form our requisite padding. Inside the string is an immediate code block <code>$(...)</code>, so that code will be executed before evaluated into the string.</p>
<p>In the code block, we're sending three items through the <code>|sort</code> command, and then taking the biggest one <code>(...)[-1]</code>. This is where we're ensuring to get the columns to the correct width. The three items are <code>$l</code> the line count, where we <code>-split</code> on newlines, the <code>$w</code> word count, where we <code>-split</code> on whitespace, and <code>$b</code> the length.</p>
<p>The second line is our output using the <code>-f</code> operator (which is a pseudo-shorthand for <code>String.Format()</code>). It's another way of inserting expanded variables into strings. Here, we're saying that we want all of the output to be padded to the left so that each column is <code>$c</code> wide. The padding is done via spaces. The <code>0</code>, <code>1</code>, and <code>2</code> correspond to the <code>$l</code>, <code>$w</code>, and <code>$b</code> that are arguments to the format operator, so the line count, word count, and byte count are padded and output appropriately.</p>
<p>Note that this either requires the string to have already-expanded newlines (e.g., doing a <code>Get-Content</code> on a text file or something, and then either piping or saving that to a variable, then calling this code on that input), or use the PowerShell-styled escape characters with backticks (meaning <code> `n</code> instead of <code>\n</code>).</p>
<p><strong>Example</strong></p>
<pre><code>PS C:\Tools\Scripts\golfing&gt; .\reimplement-wc.ps1 &quot;This line`nis broken`ninto three lines.`n&quot;
 3  7 38
</code></pre>
</div>
<div id="pu15" class="pu"><h1>POSIX awk, <strike>79</strike> <strike>75</strike> <strike>67</strike> 65 bytes</h1>

<pre><code>{w+=NF;c+=length+1}END{d=length(c)"d %";printf"%"d d"d\n",NR,w,c}
</code></pre>

<p>Edit: saved 4 bytes since POSIX allows a bare <code>length</code>, saved 7 bytes by discounting the invocation part, and saved two bytes thanks to Doorknob's tip for adding <code>d %</code> to <code>d</code>.</p>

<p>This was originally for GNU awk, but best I can tell, it uses only POSIX awk functionality.</p>

<p>Better formatted:</p>

<pre><code>gawk '{
  w += NF
  c += length($0) + 1  # length($0) misses the newline
}
END {
  d = length(c) # GNU awk's length returns the length of string representation of number
  printf "%"d"d %"d"d %d\n", NR, w, c
}'
</code></pre>
</div>
<div id="pu16" class="pu"><h2>JavaScript (ES6), 115 bytes</h2>

<pre><code>s=&gt;[/\n\/g,/\S+/g,/[^]/g].map(r=&gt;l=(s.match(r)||[]).length).map(n=&gt;(' '.repeat(99)+n).slice(-`${l}`.length)).join` `
</code></pre>

<p>Does not require any input. Formatting was painful. If there was an upper limit on the amount of padding I could reduce <code>(' '.repeat(99)+n)</code> to something shorter e.g. <code>`    ${n}`</code>.</p>
</div>
<div id="pu17" class="pu"><h1>MATL, 38 bytes</h1>

<pre><code>'\n'32cZtttnGnw-wPZvPYbnqbnvvV!3Z"vX:!
</code></pre>

<p>You can <a href="http://matl.tryitonline.net/#code=J1xuJzMyY1p0dHRuR253LXdQWnZQWWJucWJudnZWITNaInZYOiE&amp;input=JyAgYSBiIGMgZCBlIGYgIFxuJw" rel="nofollow">try it online!</a>
This shouldn't be so long though...</p>

<p>Explanation, for the calculation,</p>

<pre><code>'\n'32cZt  %// Takes implicit input and replaces any \n with a space
tt         %// Duplicate that string twice
nGnw-w     %// Length of the string with \n's minus length with spaces to give number of \n's
PZvPYbnq   %// Take string with spaces, flip it, remove leading spaces, flip it again,
           %// split on spaces, find length and decrement for number of words
bn         %// get length of string with spaces, the number of characters
</code></pre>

<p>The last part does the output formatting</p>

<pre><code>vvV!       %// concatenate the 3 numbers to a column vector, convert to string and transpose
3Z"v       %// make string '   ' and concatenate on the bottom of previous string
X:!        %// linearise and transpose to get correct output (impicitly printed)
</code></pre>
</div>
<div id="pu18" class="pu"><h1>Julia, <s>112</s> 81 bytes</h1>



<pre class="lang-default prettyprint-override"><code>f(s,n=endof,l="$(n(s))",g=r-&gt;lpad(n(split(s,r))-1,n(l)))=g(r"\n")" "g(r"\S+")" "l
</code></pre>

<p>This is a function that accepts a string and returns a string.</p>

<p>We save the following as function arguments:</p>

<ul>
<li><code>n = endof</code> function, which gets the last index of an indexable collection (in this case is the length of the string)</li>
<li><code>l = "$(n(s))</code>, the length of the input converted to a string using interpolation</li>
<li>A lambda function <code>g</code> that accepts a regular expression and returns the length - 1 of the input split on that regex, left padded with spaces to match the length of <code>l</code>.</li>
</ul>

<p>We get the number of lines using <code>g(r"\n")</code> and the number of words using <code>g(r"\S+")</code>, then we join those together with <code>l</code> delimited by spaces.</p>

<p>Saved 31 bytes thanks to Dennis!</p>
</div>
<div id="pu19" class="pu"><h1>Pyth, 21 bytes</h1>

<pre><code>jdm.[;l`lQ`ld[@bQcQ)Q
</code></pre>

<p><a href="https://pyth.herokuapp.com/?code=jdm.%5B%3Bl%60lQ%60ld%5B%40bQcQ%29Q&amp;test_suite=1&amp;test_suite_input=%22a+b+c+d%5Cn%22%0A%22a+b+c+d+e+f%5Cn%22%0A%22++a+b+c+d+e+f++%5Cn%22%0A%22a%5Cnb%5Cnc%5Cnd%5Cn%22%0A%22a%5Cn%5Cn%5Cnb%5Cnc%5Cnd%5Cn%22%0A%22abc123%7B%7D%5B%5D%28%29...%5Cn%22%0A%22%5Cn%22%0A%22+++%5Cn%22%0A%22%5Cn%5Cn%5Cn%5Cn%5Cn%22%0A%22%5Cn%5Cn%5Cna%5Cnb%5Cn%22&amp;debug=0">Test suite</a></p>

<p>Pyth has some very nice built-ins here. We start by making a list (<code>[</code>) of the newlines in the string (<code>@bQ</code>), the words in the string (<code>cQ)</code>) and the string itself (<code>Q</code>). Then, we pad (<code>.[</code>) the length of each string (<code>ld</code>) with spaces (<code>;</code> in this context) out to the length of the number of characters (<code>l`lQ</code>). Finally, join on spaces (<code>jd</code>).</p>
</div>
<div id="pu20" class="pu"><h2>Ruby, 108 bytes</h2>
<pre><code>f=-&gt;s{a=[s.count($/),s.split(/\S+/).size-1,s.size].map(&amp;:to_s)
a.map{|b|&quot; &quot;*(a.map(&amp;:size).max-b.size)+b}*&quot; &quot;}
</code></pre>
</div>
<div id="pu21" class="pu"><h1>Python 2, <s>100</s> 77 bytes</h1>

<p>This solution is a Python function that accepts a multi-line string and prints the required counts to stdout. Note that I use a format string to build a format string (which requires a <code>%%</code> to escape the first format placeholder).</p>

<p><em>Edit: Saved 23 bytes due to print optimisations by Dennis.</em></p>



<pre class="lang-python prettyprint-override"><code>def d(b):c=len(b);a='%%%us'%len(`c`);print a%b.count('\n'),a%len(b.split()),c
</code></pre>

<p>Before the minifier, it looks like this:</p>

<pre class="lang-python prettyprint-override"><code>def wc(text) :
    size = len(text);
    numfmt = '%%%us' % len(`size`);
    print numfmt % text.count('\n'), numfmt % len(text.split()), size
</code></pre>
</div>
<div id="pu22" class="pu"><h1>CJam, <s>31</s> 26 bytes</h1>

<pre><code>q_)/_S*S%@_]:,:s),f{Se[}S*
</code></pre>

<p><a href="http://cjam.tryitonline.net/#code=cV8pL19TKlMlQF9dOiw6cyksZntTZVt9Uyo&amp;input=YWJjMTIze31bXSgpLi4uCg" rel="nofollow">Try it online!</a></p>

<h3>How it works</h3>

<pre><code>q_                         e# Read all input from STDIN and push two copies.
  )                        e# Pop the last character (linefeed) of the second copy.
   /                       e# Split the remaining string at linefeeds.
    _                      e# Push a copy.
     S*                    e# Join the copy, separating by spaces.
       S%                  e# Split at runs of spaces.
         @_                e# Rotate the original input on top and push a copy.
           ]               e# Wrap all four items in an array.
            :,             e# Get the length of each item.
              :s           e# Cast the lengths (integers) to strings.
                )          e# Pop the last length (byte count).
                 ,         e# Get the number of digits.
                  f{Se[}   e# Left-pad all three length with spaces to that length.
                        S* e# Join, separating by spaces.
</code></pre>
</div>
<div id="pu23" class="pu"><h1>AppleScript, 253 bytes</h1>

<p>This assumes that AppleScript's text item delimiters are set to space (if I need to count the stuff to force that assumption, I'll add it).</p>

<pre><code>set w to(display dialog""default answer"")'s text returned
set x to b(w)
set y to w's text item's number
set z to w's paragraph's number
a(x,z)&z&a(x,y)&y&" "&x
on a(x,n)
set o to" "
repeat b(x)-b(n)
set o to o&" "
end
o
end
on b(n)
count(n as text)
end</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/74222/">74222</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




