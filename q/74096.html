<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::74096</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td></td><td>200315T015036Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/201065#201065">JayXon</a></td></tr>
<tr d-ix="1"><td>nan</td><td></td><td>240112T205829Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/269179#269179">mousetai</a></td></tr>
<tr d-ix="2"><td>nan</td><td></td><td>220622T151938Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/248943#248943">mousetai</a></td></tr>
<tr d-ix="3"><td>nan</td><td></td><td>220801T124532Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/250584#250584">mousetai</a></td></tr>
<tr d-ix="4"><td>nan</td><td></td><td>220923T194211Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/252195#252195">naffetS</a></td></tr>
<tr d-ix="5"><td>nan</td><td>When using string formatting for example with print!</td><td>190722T155710Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/188625#188625">ruohola</a></td></tr>
<tr d-ix="6"><td>nan</td><td></td><td>211218T125254Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/239745#239745">Ezhik</a></td></tr>
<tr d-ix="7"><td>nan</td><td></td><td>211216T031117Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/239614#239614">alephalp</a></td></tr>
<tr d-ix="8"><td>nan</td><td></td><td>211209T102730Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/238271#238271">Ezhik</a></td></tr>
<tr d-ix="9"><td>nan</td><td></td><td>211204T074732Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/238059#238059">Ezhik</a></td></tr>
<tr d-ix="10"><td>nan</td><td>Use the ? operator to unwrap infallible results. ? is used for error propagation in conjunction with the result and option types</td><td>201204T163120Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/215982#215982">Aiden4</a></td></tr>
<tr d-ix="11"><td>nan</td><td>When working with strings with newlines in them</td><td>190722T162447Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/188627#188627">ruohola</a></td></tr>
<tr d-ix="12"><td>nan</td><td></td><td>200804T074731Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/209065#209065">TehPers</a></td></tr>
<tr d-ix="13"><td>nan</td><td></td><td>200731T200235Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/208910#208910">madlaina</a></td></tr>
<tr d-ix="14"><td>nan</td><td></td><td>200226T045903Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/200134#200134">JayXon</a></td></tr>
<tr d-ix="15"><td>nan</td><td></td><td>200108T020007Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/197792#197792">JayXon</a></td></tr>
<tr d-ix="16"><td>nan</td><td></td><td>190804T082440Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/189212#189212">JayXon</a></td></tr>
<tr d-ix="17"><td>000</td><td>When using whole number floating point numbers</td><td>190723T175201Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/188674#188674">ruohola</a></td></tr>
<tr d-ix="18"><td>nan</td><td></td><td>190515T202310Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/185614#185614">Maya</a></td></tr>
<tr d-ix="19"><td>nan</td><td></td><td>180219T123306Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/156134#156134">0..</a></td></tr>
<tr d-ix="20"><td>nan</td><td></td><td>160224T212211Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/74097#74097">Doorknob</a></td></tr>
<tr d-ix="21"><td>000</td><td>If you need many mutable variables</td><td>161109T070403Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/99124#99124">user6126</a></td></tr>
<tr d-ix="22"><td>nan</td><td></td><td>160706T213349Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/84662#84662">raggy</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Replace all <code>filter_map</code> with <code>flat_map</code></h1>
<p>It works because:</p>
<ul>
<li><p><code>filter_map</code> takes a <code>FnMut(Self::Item) -&gt; Option&lt;B&gt;</code></p>
</li>
<li><p><code>flat_map</code> takes a <code>FnMut(Self::Item) -&gt; impl IntoIterator</code></p>
</li>
<li><p><a href="https://doc.rust-lang.org/std/option/enum.Option.html#impl-IntoIterator-for-Option%3CT%3E" rel="nofollow noreferrer"><code>Option</code> implements <code>IntoIterator</code></a>, which will return an
iterator with one item for <code>Some</code> and empty iterator for <code>None</code></p>
</li>
</ul>
</div>
<div id="pu1" class="pu"><h2>Using slice patterns to get both an array and variables with the same value</h2>
<p>It is a common trick to use array slicing to compactly assign many variables to the same value:</p>
<pre class="lang-rs prettyprint-override"><code>let[a,b,c]=[0;3]
// vs
let(a,b,c)=(0,0,0)
// or
let a=0;let b=0;let c=0;
</code></pre>
<p>I've never really seen this used on arrays, even though it also saves bytes there:</p>
<pre class="lang-rs prettyprint-override"><code>let[a,..@b]=[0;99]; // store &quot;the rest&quot; of the slice in b
// vs
let(a,b)=(0,[0;98]);
// or
let a=0;let b=[0;98];
</code></pre>
<p>Saves just one byte so may not be worth it if it increases the array size by one byte.</p>
<p>It works for mutable variables too:</p>
<pre class="lang-rs prettyprint-override"><code>let[mut v,mut u@..]=[0;99];
// vs
let(mut u,mut v)=(0,[0;98]);
</code></pre>
</div>
<div id="pu2" class="pu"><h1><code>if let</code> can sometimes be shorter than <code>match</code></h1>
<p>Using <code>match</code>:</p>
<pre><code>match a{M(v)=&gt;expr,_=&gt;other}
</code></pre>
<p>Using <code>if let</code> costs 2 bytes if there are only 2 branches and 1 is wildcard:</p>
<pre><code>if let M(v)=a{expr}else{other}
</code></pre>
<p>More effective when your <code>match</code> needed <code>{}</code> anyways, like if the types don't match. For example:</p>
<pre><code>match a{M(v)=&gt;{expr;}_=&gt;{other;}}
</code></pre>
<p>vs.:</p>
<pre><code>if let M(v)=a{expr;}else{other;}
</code></pre>
<p>saves 1 byte.</p>
</div>
<div id="pu3" class="pu"><h1>Get the nth element of a <code>String</code> or <code>&amp;str</code> slice</h1>
<p>In rust you can't directly index a string or slice. If you want to build a string from indexes of another string you would typically do this:</p>
<pre class="lang-rs prettyprint-override"><code>s.chars().nth(n).unwrap() // char
s.bytes().nth(n).unwrap() // u8
</code></pre>
<p>Shorter is this, but it will depend <code>s</code> so won't work if <code>s</code> is generated from a expression:</p>
<pre class="lang-rs prettyprint-override"><code>s.as_bytes()[n]as char // char, supports only single byte characters
s.as_bytes()[n] // u8
</code></pre>
<p>However, if you are ok with a <code>&amp;str</code> (like if you want to collect into a <code>String</code> or concatenate with a existing <code>String</code>). This also supports only single byte characters.</p>
<pre class="lang-rs prettyprint-override"><code>&amp;s[n..][..1] // &amp;str
&amp;s[n..=n] // &amp;str, if `n` is a single variable or sufficiently short expression
</code></pre>
<p>If your expression is a literal you can use byte string instead to index it directly:</p>
<pre class="lang-rs prettyprint-override"><code>b&quot;hello world&quot;[n] // u8
b&quot;hello world&quot;[n]as char // char
</code></pre>
</div>
<div id="pu4" class="pu"><h1>Use <code>@</code> to define multiple variables to the same value</h1>
<p><code>@</code> is meant to define an alias for pattern matching (like destructuring an array but also getting the original array at the same time). But it works with plain variables too.</p>
<pre><code>let a=2;let b=2; // 16 bytes
let(a,b)=(2,2);  // 15 bytes
let a@b=2;       // 10 bytes
</code></pre>
<p>It works in destructuring too:</p>
<pre><code>let a=1;let b=1;let c=2;let d=2; // 32 bytes
let(a,b,c,d)=(1,1,2,2);          // 23 bytes
let(a@b,c@d)=(1,2);              // 19 bytes
</code></pre>
</div>
<div id="pu5" class="pu"><p>When using string formatting for example with <code>print!()</code>, one can use both numbered and unnumbered formatters to save one byte per item to format:</p>
<p>Best shown with an example:</p>
<pre class="lang-rust prettyprint-override"><code>fn main() {
    print!(
        &quot;{}{}{}. Yes, {0}{}{2}. All you other{1}{2}s are just imitating.&quot;,
        &quot;I'm&quot;, &quot; Slim&quot;, &quot; Shady&quot;, &quot; the real&quot;,
    );
}
</code></pre>
<p>Which outputs:</p>
<blockquote>
<pre><code>I'm Slim Shady. Yes, I'm the real Shady. All you other Slim Shadys are just imitating.
</code></pre>
</blockquote>
<p>So the unnumbered formatters will get assigned to the items in order, this allows you to skip the index on them. Note that you can only use one unnumbered formatter per item to format, after that it will get used up.</p>
</div>
<div id="pu6" class="pu"><h1><code>scan</code> and <code>fold</code> on <code>Iterator</code>s can be used for stateful iteration</h1>
<p>If your closure consists of variable declarations and iterating over something while keeping an internal state, you might be able to save some bytes by using <code>scan</code> or <code>fold</code> instead of a <code>for</code> loop:</p>
<pre class="lang-rust prettyprint-override"><code>|i:&amp;str|{let(mut a,mut b,mut c)=(1,2,0);for x in i.chars(){/*AAA*/;/*BBB*/;c=/*CCC*/}c}
</code></pre>
<p><code>scan</code> is good for handling many mutable variables, at the cost of some operations (such as assignment) requiring dereferencing with <code>*</code> and needing to collect the final value using a method like <code>last</code>:</p>
<pre class="lang-rust prettyprint-override"><code>|i:&amp;str|i.chars().scan((1,2),|(a,b),x|{/*AAA*/;/*BBB*/;Some(/*CCC*/)}).last()
</code></pre>
<p><code>fold</code> can also be used in a similar manner by passing values in the accumulator:</p>
<pre class="lang-rust prettyprint-override"><code>|i:&amp;str|i.chars().fold((1,2,3),|(a,b,c),x|(/*AAA*/,/*BBB*/,/*CCC*/)).2
</code></pre>
</div>
<div id="pu7" class="pu"><h1>Do-while loops</h1>
<p>Rust does not have a C-style do-while loop:</p>
<pre class="lang-c prettyprint-override"><code>do{do_work();}while(condition);
</code></pre>
<p>But blocks are also expressions in Rust, so you can write:</p>
<pre class="lang-rust prettyprint-override"><code>while{do_work();condition}{}
</code></pre>
</div>
<div id="pu8" class="pu"><h1><code>(0..).scan</code> can be shorter than <code>std::iter::successors</code></h1>
<p>If you want to make endless sequences that are based on previous state:</p>
<pre class="lang-rust prettyprint-override"><code>std::iter::successors(Some(a),|x,_|Some(/*something*/))
</code></pre>
<p>This will be shorter by a character:</p>
<pre class="lang-rust prettyprint-override"><code>(0..).scan(a,|x,_|{let y=*x;*x=/*something*/;Some(y)})
</code></pre>
<p>If you don't mind dropping the first case, it can be even shorter:</p>
<pre class="lang-rust prettyprint-override"><code>(0..).scan(a,|x,_|{*x=/*something*/;Some(*x)})
</code></pre>
</div>
<div id="pu9" class="pu"><h1>Loops are sometimes shorter than iterators</h1>
<p>Even with the extra curly braces, in some cases it can be shorter to declare a mutable variable and use a loop instead of using <code>Iterator</code> methods.</p>
<p>For example, to do something with every third element of a slice and then return the last index:</p>
<pre class="lang-rust prettyprint-override"><code>|n:&amp;[_]|{let mut i=0;while i&lt;n.len(){println!(&quot;{}&quot;,n[i]);i+=3}i-3}
</code></pre>
<pre class="lang-rust prettyprint-override"><code>|n:&amp;[_]|(0..=n.len()/3).map(|i|{println!(&quot;{}&quot;,n[i*3]);i*3}).last().unwrap()
</code></pre>
</div>
<div id="pu10" class="pu"><p>Use the <code>?</code> operator to unwrap infallible results. <code>?</code> is used for error propagation in conjunction with the result and option types, and <a href="https://codegolf.meta.stackexchange.com/a/13262/97691">per this meta post</a> returning them with infallible results is a standard output method. For example, the following code summing the value of a string when interpreted in base a and b, with <code>?</code>:</p>
<pre class="lang-rust prettyprint-override"><code>|s,a,b|Ok(i32::from_str_radix(s,a)?+i32::from_str_radix(s,b)?)
</code></pre>
<p>and without:</p>
<pre class="lang-rust prettyprint-override"><code>|s,a,b|i32::from_str_radix(s,a).unwrap()+i32::from_str_radix(s,b).unwrap()
</code></pre>
<p>As you can see, with <code>?</code> it is much shorter, and it works with options as well, although often for smaller gains.</p>
</div>
<div id="pu11" class="pu"><p>When working with strings with newlines in them, you save one byte if you use a literal line break in the source code vs having a <code>\n</code> in the string and/or using <code>println</code>.</p>
<pre class="lang-rust prettyprint-override"><code>print!(&quot;Hello
World!
&quot;);
</code></pre>
<p>is 2 bytes less than:</p>
<pre class="lang-rust prettyprint-override"><code>println!(&quot;Hello\nWorld!&quot;);
</code></pre>
</div>
<div id="pu12" class="pu"><h1>Prefer todo! over panic!</h1>
<p><a href="https://doc.rust-lang.org/std/macro.todo.html" rel="noreferrer"><code>todo!</code></a> is shorter than <code>panic!</code> by 1 byte, so prefer to use it if you need to panic and exit the program. It's also shorter than <code>print!</code> by a byte, so it can shorten your program if you can output to stderr instead of stdout.</p>
<pre><code>todo!(&quot;optional message for stderr&quot;)
</code></pre>
</div>
<div id="pu13" class="pu"><h1>Declare multiple variables using pattern matching</h1>
<p>(Somewhat of an extension of <a href="https://codegolf.stackexchange.com/a/99124/97519">https://codegolf.stackexchange.com/a/99124/97519</a>)</p>
<p>Using multiple <code>let</code> statements:</p>
<pre><code>let a=x;let b=y;
let a=x;let b=y;let c=z;
</code></pre>
<p>Using a tuple match saves 1 char for 2 variables and 3 more chars for ever variable after:</p>
<pre><code>let(a,b)=(x,y);
let(a,b,c)=(x,y,z);
</code></pre>
<p>Similarly, you can use array patterns for initializing multiple mutable variables to the same value (this works with immutable variables too but is pretty useless):</p>
<pre><code>let[mut a,mut b]=[x;2];
</code></pre>
</div>
<div id="pu14" class="pu"><h1>Use <code>..=</code></h1>

<p>Replace all <code>..i+1</code> with <code>..=i</code> to save 1 byte, works on both array index <code>a[i..=i]</code> and range <code>(0..=n)</code></p>
</div>
<div id="pu15" class="pu"><h1>Use closure parameter to define variable instead of <code>let</code></h1>

<pre class="lang-rust prettyprint-override"><code>{let(a,b)=(A,B);X}
</code></pre>

<p>can be replaced by</p>

<pre class="lang-rust prettyprint-override"><code>(|a,b|X)(A,B)
</code></pre>

<p>to save 5 bytes if the type of <code>a</code> and <code>b</code> can be inferred, it usually works when they are integers or are passed to another function directly in <code>X</code>.</p>

<p>This works well on 2 or more variables, but for a single variable, this could still save 2 bytes if it allows you to get rid of the <code>{}</code>.</p>
</div>
<div id="pu16" class="pu"><h1>Converting <code>&amp;str</code> to <code>String</code></h1>

<p>Never do these:</p>

<pre class="lang-rust prettyprint-override"><code>s.to_string()  // 13 bytes
s.to_owned()   // 12 bytes
</code></pre>

<p>This is always shorter:</p>

<pre class="lang-rust prettyprint-override"><code>s.repeat(1)    // 11 bytes
</code></pre>

<p>If <code>s</code> is a string literal:</p>

<pre class="lang-rust prettyprint-override"><code>format!(s)     // 10 bytes
</code></pre>

<p>For example: use <code>format!("")</code> instead of <code>String::new()</code> to save 2 bytes.</p>

<p>If type inference works:</p>

<pre class="lang-rust prettyprint-override"><code>s.into()       // 8 bytes
</code></pre>
</div>
<div id="pu17" class="pu"><p>When using whole number floating point numbers, you can omit the trailing <code>.0</code> to save one byte.</p>

<pre><code>let a=1.
</code></pre>

<p>is 1 byte less than:</p>

<pre><code>let a=1.0
</code></pre>
</div>
<div id="pu18" class="pu"><h1>Skipping trailing semicolons</h1>

<p>In functions returning <code>()</code>, where the last expression is also of type <code>()</code>, you don't need the trailing <code>;</code>:</p>

<pre><code>fn main(){print!("Hello, world!")}
</code></pre>
</div>
<div id="pu19" class="pu"><h1>Reading lines</h1>

<p>After considering various things, I think that is generally the shortest way to retrieve a line. The line has a newline, it can be removed by trimming (<code>.trim()</code>) or if that cannot be done by slicing.</p>

<pre><code>let y=&amp;mut"".into();std::io::stdin().read_line(y);
</code></pre>

<p>For multiple lines, <code>lines</code> iterator can be used, the iterated line doesn't end in newline then. A glob import is needed to import <code>BufRead</code>, needed for <code>lines</code> to be available for <code>StdinLock&lt;'_&gt;</code> type.</p>

<pre><code>use std::io::*;let y=stdin();y.lock().lines()
</code></pre>
</div>
<div id="pu20" class="pu"><h2>Use closures instead of functions</h2>

<p>A closure: </p>

<pre><code>|n|n+1
</code></pre>

<p>is shorter than a function:</p>

<pre><code>fn f(n:i32)-&gt;i32{n+1}
</code></pre>

<hr>

<p>Closures longer than one statement need braces but are still far shorter than a function.</p>
</div>
<div id="pu21" class="pu"><p>If you need many mutable variables, it can waste a lot of space declaring them and initializing them, since each requires the mut keyword and you can't do anything like a=b=c=0. A solution then is to declare a mutable array</p>

<pre><code>let mut a=[0;5];
</code></pre>

<p>You spend 3 extra bytes each time you use them vs. a normal variable:</p>

<pre><code>a[0]+=1;
</code></pre>

<p>but it can often still be worth it.</p>

<p>Using tuples for the same trick is often an even better option:</p>

<pre><code>let mut t=(1,4,"this", 0.5, 'c');
</code></pre>

<p>This has the advantage of saving a byte on each use vs. the array:</p>

<pre><code>t.0=2
</code></pre>

<p>It also lets them be of different types. On the downside, it requires more characters to initialize.</p>
</div>
<div id="pu22" class="pu"><h1>Avoid .iter().enumerate()</h1>

<p>Let's say you have some x that implements the IntoIterator Trait and you need to call a function f that takes the index of an element and a reference to it.
The standard way of doing this is</p>

<pre><code>x.iter().enumerate().map(f)
</code></pre>

<p>instead you can do</p>

<pre><code>(0..).zip(x).map(f)
</code></pre>

<p>and save yourself not only the unusually long enumerate but also the call to iter!</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/74096/">74096</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




