<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::74096</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td>Use the ? operator to unwrap infallible results. ? is used for error propagation in conjunction with the result and option types</td><td>201204T163120Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/215982#215982">Aiden4</a></td></tr>
<tr d-ix="1"><td>nan</td><td></td><td>220801T124532Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/250584#250584">mousetai</a></td></tr>
<tr d-ix="2"><td>nan</td><td></td><td>240513T084122Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/273074#273074">mousetai</a></td></tr>
<tr d-ix="3"><td>nan</td><td></td><td>240417T173802Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/272646#272646">ShadowRa</a></td></tr>
<tr d-ix="4"><td>nan</td><td></td><td>240417T140656Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/272642#272642">ShadowRa</a></td></tr>
<tr d-ix="5"><td>nan</td><td></td><td>200315T015036Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/201065#201065">JayXon</a></td></tr>
<tr d-ix="6"><td>nan</td><td></td><td>240112T205829Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/269179#269179">mousetai</a></td></tr>
<tr d-ix="7"><td>nan</td><td></td><td>220622T151938Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/248943#248943">mousetai</a></td></tr>
<tr d-ix="8"><td>nan</td><td></td><td>220923T194211Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/252195#252195">naffetS</a></td></tr>
<tr d-ix="9"><td>nan</td><td>When using string formatting for example with print!</td><td>190722T155710Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/188625#188625">ruohola</a></td></tr>
<tr d-ix="10"><td>nan</td><td></td><td>211218T125254Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/239745#239745">Ezhik</a></td></tr>
<tr d-ix="11"><td>nan</td><td></td><td>211216T031117Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/239614#239614">alephalp</a></td></tr>
<tr d-ix="12"><td>nan</td><td></td><td>211209T102730Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/238271#238271">Ezhik</a></td></tr>
<tr d-ix="13"><td>nan</td><td></td><td>211204T074732Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/238059#238059">Ezhik</a></td></tr>
<tr d-ix="14"><td>nan</td><td>When working with strings with newlines in them</td><td>190722T162447Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/188627#188627">ruohola</a></td></tr>
<tr d-ix="15"><td>nan</td><td></td><td>200804T074731Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/209065#209065">TehPers</a></td></tr>
<tr d-ix="16"><td>nan</td><td></td><td>200731T200235Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/208910#208910">madlaina</a></td></tr>
<tr d-ix="17"><td>nan</td><td></td><td>200226T045903Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/200134#200134">JayXon</a></td></tr>
<tr d-ix="18"><td>nan</td><td></td><td>200108T020007Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/197792#197792">JayXon</a></td></tr>
<tr d-ix="19"><td>nan</td><td></td><td>190804T082440Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/189212#189212">JayXon</a></td></tr>
<tr d-ix="20"><td>000</td><td>When using whole number floating point numbers</td><td>190723T175201Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/188674#188674">ruohola</a></td></tr>
<tr d-ix="21"><td>nan</td><td></td><td>190515T202310Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/185614#185614">Maya</a></td></tr>
<tr d-ix="22"><td>nan</td><td></td><td>180219T123306Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/156134#156134">null</a></td></tr>
<tr d-ix="23"><td>nan</td><td></td><td>160224T212211Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/74097#74097">Doorknob</a></td></tr>
<tr d-ix="24"><td>000</td><td>If you need many mutable variables</td><td>161109T070403Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/99124#99124">user6126</a></td></tr>
<tr d-ix="25"><td>nan</td><td></td><td>160706T213349Z</td><td><a href="https://codegolf.stackexchange.com/questions/74096/tips-for-golfing-in-rust/84662#84662">raggy</a></td></tr>
</table>
<div id="pu0" class="pu"><p>Use the <code>?</code> operator to unwrap infallible results. <code>?</code> is used for error propagation in conjunction with the result and option types, and <a href="https://codegolf.meta.stackexchange.com/a/14275/70305">per this meta post</a> returning them with infallible results is a standard output method. For example, the following code summing the value of a string when interpreted in base a and b, with <code>?</code>:</p>
<pre class="lang-rust prettyprint-override"><code>|s,a,b|Ok(i32::from_str_radix(s,a)?+i32::from_str_radix(s,b)?)
</code></pre>
<p>and without:</p>
<pre class="lang-rust prettyprint-override"><code>|s,a,b|i32::from_str_radix(s,a).unwrap()+i32::from_str_radix(s,b).unwrap()
</code></pre>
<p>As you can see, with <code>?</code> it is much shorter, and it works with options as well, although often for smaller gains.</p>
</div>
<div id="pu1" class="pu"><h1>Get the nth element of a <code>String</code> or <code>&amp;str</code> slice</h1>
<p>In rust you can't directly index a string or slice. If you want to build a string from indexes of another string you would typically do this:</p>
<pre class="lang-rs prettyprint-override"><code>s.chars().nth(n).unwrap() // char
s.bytes().nth(n).unwrap() // u8
</code></pre>
<p>Shorter is this, but it will depend <code>s</code> so won't work if <code>s</code> is generated from a expression:</p>
<pre class="lang-rs prettyprint-override"><code>s.as_bytes()[n]as char // char, supports only single byte characters
s.as_bytes()[n] // u8
</code></pre>
<p>However, if you are ok with a <code>&amp;str</code> (like if you want to collect into a <code>String</code> or concatenate with a existing <code>String</code>). This also supports only single byte characters.</p>
<pre class="lang-rs prettyprint-override"><code>&amp;s[n..][..1] // &amp;str
&amp;s[n..=n] // &amp;str, if `n` is a single variable or sufficiently short expression
</code></pre>
<p>If your expression is a literal you can use byte string instead to index it directly:</p>
<pre class="lang-rs prettyprint-override"><code>b&quot;hello world&quot;[n] // u8
b&quot;hello world&quot;[n]as char // char
</code></pre>
<h2>Modifying the nth element of a <code>String</code></h2>
<p>If you need to make multiple modifications:</p>
<pre class="lang-rs prettyprint-override"><code>unsafe{s.as_mut_vec()}
</code></pre>
<p>Gives you an array that allows very compact manipulation of the string. The original string can still be accessed after the last use of the mutable slice eg. for printing.</p>
<p>This would obviously be a terrible idea outside of golfing.</p>
<p>If you <em>don't</em> need to convert it back afterwards you can just do</p>
<pre class="lang-rs prettyprint-override"><code>s.into_bytes()
</code></pre>
<h2>A comparison of techniques</h2>
<p>Consumes mean methods that take <code>self</code> so you won't be able to use the string again afterwards.</p>
<p>Note any method on <code>&amp;str</code> can also be called on a <code>String</code></p>
<h3>Single Use</h3>
<div class="s-table-container"><table class="s-table">
<thead>
<tr>
<th>Code</th>
<th>Bytes</th>
<th>on what type</th>
<th>Unicode Safe</th>
<th>Consumes</th>
<th>Return Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s.chars().nth(n).unwrap()</code></td>
<td>25</td>
<td><code>&amp;str</code></td>
<td>Yes</td>
<td>No</td>
<td><code>char</code></td>
</tr>
<tr>
<td><code>s.bytes().nth(n).unwrap()</code></td>
<td>25</td>
<td><code>&amp;str</code></td>
<td>No</td>
<td>No</td>
<td><code>u8</code></td>
</tr>
<tr>
<td><code>s.as_bytes()[n]</code></td>
<td>15</td>
<td><code>&amp;str</code></td>
<td>No</td>
<td>No</td>
<td><code>u8</code></td>
</tr>
<tr>
<td><code>&amp;s[n..][..1]</code></td>
<td>12</td>
<td><code>&amp;str</code></td>
<td>No</td>
<td>No</td>
<td><code>&amp;str</code></td>
</tr>
<tr>
<td><code>&amp;s[n..m]</code></td>
<td>8</td>
<td><code>&amp;str</code></td>
<td>No</td>
<td>No</td>
<td><code>&amp;str</code></td>
</tr>
<tr>
<td><code>unsafe{&amp;s.as_bytes_mut()[n]}</code></td>
<td>28</td>
<td><code>&amp;str</code></td>
<td>No</td>
<td>No</td>
<td><code>&amp;mut u8</code></td>
</tr>
<tr>
<td><code>unsafe{&amp;s.as_mut_vec()[n]}</code></td>
<td>26</td>
<td><code>String</code></td>
<td>No</td>
<td>No</td>
<td><code>&amp;mut u8</code></td>
</tr>
</tbody>
</table></div>
<h3>Multi Use</h3>
<p>For assignment to a variable if you need to take multiple slices and/or modifications. All of these return a format compatible with standard <code>x[n]</code> indexing.</p>
<div class="s-table-container"><table class="s-table">
<thead>
<tr>
<th>Code</th>
<th>Bytes</th>
<th>on what type</th>
<th>Unicode Safe</th>
<th>Consumes</th>
<th>Return Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s.as_bytes()</code></td>
<td>12</td>
<td><code>&amp;str</code></td>
<td>No</td>
<td>No</td>
<td><code>&amp;[u8]</code></td>
</tr>
<tr>
<td><code>s.chars().collect::Vec&lt;_&gt;()</code></td>
<td>27</td>
<td><code>&amp;str</code></td>
<td>Yes</td>
<td>No</td>
<td><code>Vec&lt;char&gt;</code></td>
</tr>
<tr>
<td><code>unsafe{s.as_mut_bytes()}</code></td>
<td>24</td>
<td><code>&amp;str</code></td>
<td>No</td>
<td>No</td>
<td><code>&amp;mut[u8]</code></td>
</tr>
<tr>
<td><code>unsafe{s.as_mut_vec()}</code></td>
<td>22</td>
<td><code>String</code></td>
<td>No</td>
<td>No</td>
<td><code>&amp;mut Vec&lt;u8&gt;</code></td>
</tr>
<tr>
<td><code>s.into_bytes()</code></td>
<td>14</td>
<td><code>String</code></td>
<td>No</td>
<td>Yes</td>
<td><code>Vec&lt;u8&gt;</code></td>
</tr>
</tbody>
</table></div>
</div>
<div id="pu2" class="pu"><h2>Abuse <code>reduce</code> to do something special with the first element of an iterator</h2>
<p>It's very inconvenient when the first element of an iterator is a special case, since all ways to deal with it are quite long.</p>
<p>You can use <code>.next()</code>: <strong>(~73 bytes)</strong></p>
<pre class="lang-rs prettyprint-override"><code>let mut a=m.iter();let f=a.next().unwrap();for i in a{do_something(f,i)};
</code></pre>
<p>A lot shorter is using collect. Depending on what you need later with the array this may be the shortest choice. <strong>(~62 bytes)</strong></p>
<pre class="lang-rs prettyprint-override"><code>let a:Vec&lt;_&gt;=m.collect();for i in a[1..]{do_something(a[0],i)}
</code></pre>
<p>However, a pro move I saw JoKing use was to use <code>reduce</code>. <code>reduce</code> already handles the first case special so all that is necessary is to just return it and don't modify it. This is <strong>(~36 bytes)</strong></p>
<pre class="lang-rs prettyprint-override"><code>m.reduce(|f,a|{do_something(f,a);f})
</code></pre>
</div>
<div id="pu3" class="pu"><h3>Fallible unpacking can let you avoid filtering</h3>
<p>If you have an iterable input, e.g. command-line arguments, where some values are known to be bad (the program name is not useful), and others can be split into multiple discrete values, the normal solution to loop over <code>.skip(n)</code> to bypass the bad values (e.g. <code>.skip(1)</code> to skip the program name in the arguments), <code>split</code>/<code>collect</code> the rest to a <code>Vec</code>, and use the values by indexing (unless they're referred to many times, it's not worth the cost to unpack). For example, imagine a program that receives four numbers at a time, comma-separated as command-line arguments, and must compute a value using each value individually. The simple solution (using <a href="https://codegolf.stackexchange.com/a/201065/70305">the <code>flat_map</code> trick</a> to avoid a level of <code>unwrap</code>ing or use of <code>filter_map</code>) is:</p>
<pre class="lang-rust prettyprint-override"><code>fn main(){
  for a in std::env::args().skip(1){
     let v:Vec&lt;u32&gt;=a.split(',').flat_map(str::parse).collect();
     println!(&quot;{},{}&quot;,v[0]+v[1],v[2]+v[3])
  }
}
</code></pre>
<p>And that's not bad. But the <code>.skip(1)</code> costs eight characters, and all the indexing costs 12 more, for a total of 20 characters we'd like to avoid. By using <code>if let</code> with slice-unpacking, we can imply the skip (assuming the program name isn't four numbers separated by embedded commas), and unpack to individual names, while still saving characters:</p>
<pre class="lang-rust prettyprint-override"><code>fn main(){
  for a in std::env::args(){
    let v:Vec&lt;u32&gt;=a.split(',').flat_map(str::parse).collect();
    if let[m,n,o,p]=a.split(',').flat_map(str::parse).collect::&lt;Vec&lt;u32&gt;&gt;()[..]{
      println!(&quot;{},{}&quot;,m+n,o+p)
    }
  }
}
</code></pre>
<p>The difference here is pretty trivial (the second version shaves 8+12=20 characters by avoiding <code>.skip(1)</code> and indexing four times, but it costs 18 more to wrap in <code>if let</code>, use a turbofish on <code>collect</code> instead of letting type-inference handle it the pattern itself is longer (<code>let[m,n,o,p]</code> vs. <code>let v</code>), and <code>[..]</code> is needed to convert from <code>Vec</code> to slice for the pattern matching.</p>
<p>But:</p>
<ol>
<li>Unpacking more values only costs two characters more per name, and saves three characters the first time said value is used, and if you need to use any given value more than once, it saves three more characters per use, etc.</li>
<li>Frequently, type-inference can figure out the type of the matched values, and that will allow you to replace <code>iterator.collect::&lt;Vec&lt;u32&gt;&gt;()</code> with <code>Vec::from_iter(iterator)</code>, saving eight characters and making it much quicker to reach the break even point.</li>
</ol>
<p>If the iterator had no invalid values to skip, this wouldn't be worth as much (the <code>.skip(1)</code> is 40% of the savings here), but the general pattern can be useful even then if you have enough things to unpack, and use them often enough.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=c03fabd4d826582d78ad9a6c0be269fc" rel="nofollow noreferrer">Try both out on the Rust Playground</a></p>
</div>
<div id="pu4" class="pu"><h3>Use <code>for</code> loops or <code>map</code> to unwrap known <code>Some</code>/<code>Ok</code> values when <code>?</code> isn't an option</h3>
<p>When it's too expensive to declare a return value that would allow you to use <code>?</code> to handle known <code>Some</code>/<code>Ok</code> values, and scope is not an issue, you can use the fact that <code>Option</code> and <code>Result</code> implement <code>IntoIterator</code> and a custom version of <code>map</code> to shorten variable declarations by using a <code>for</code> loop or their <code>map</code> method.</p>
<pre class="lang-rust prettyprint-override"><code>// Unwrapping Some
if let Some(x)=returnsoption(){}  // Idiomatic fallible unwrap
let x=returnsoption().unwrap();   // Unconditional unwrap saves 1, and avoids nested scope
for x in returnsoption(){}        // for loop saves five more, as cost of nested scope
returnsoption().map(|x|{});       // One longer with map if {} needed, and even nastier, scope-wise, and usually needs semi-colon
returnsoption().map(|x|);         // Map one shorter when {} not needed and scope issues not a problem; can be two shorter in cases where semi-colon not needed

// Unwrapping Ok
if let Ok(x)=returnsresult(){}  // Idiomatic fallible unwrap
let x=returnsresult().unwrap(); // Unconditional unwrap avoids nested scope, but costs 1
for x in returnsresult(){}      // for loop saves four over next best option
returnsresult().map(|x|{});        // One longer with map if {} needed, and even nastier, scope-wise, and usually needs semi-colon
returnsresult().map(|x|);          // Map one shorter when {} not needed and scope issues not a problem; can be two shorter in cases where semi-colon not needed
</code></pre>
<p>This even saves something when it means you need to use the turbofish, e.g., if the type of <code>x</code> can't be deduced:</p>
<pre class="lang-rust prettyprint-override"><code>let x:u32=s.parse().unwrap();
// vs.
for x in s.parse::&lt;u32&gt;(){}
</code></pre>
<p>saves two characters over <code>let</code>, even with the turbofish adding three characters, though <code>map</code> remains better if the scope issues aren't a problem:</p>
<pre class="lang-rust prettyprint-override"><code>// If scope issues aren't a problem, saves 2-4/3-5 (depending on need for semi-colon) more:
s.parse().map(|x:u32|{});
s.parse().map(|x:u32|);
</code></pre>
<p>All the uses of <code>map</code> will produce a compile-time warning due to the result being unused, so avoid them if that's a problem.</p>
</div>
<div id="pu5" class="pu"><h1>Replace all <code>filter_map</code> with <code>flat_map</code></h1>
<p>It works because:</p>
<ul>
<li><p><code>filter_map</code> takes a <code>FnMut(Self::Item) -&gt; Option&lt;B&gt;</code></p>
</li>
<li><p><code>flat_map</code> takes a <code>FnMut(Self::Item) -&gt; impl IntoIterator</code></p>
</li>
<li><p><a href="https://doc.rust-lang.org/std/option/enum.Option.html#impl-IntoIterator-for-Option%3CT%3E" rel="nofollow noreferrer"><code>Option</code> implements <code>IntoIterator</code></a>, which will return an
iterator with one item for <code>Some</code> and empty iterator for <code>None</code></p>
</li>
</ul>
</div>
<div id="pu6" class="pu"><h2>Using slice patterns to get both an array and variables with the same value</h2>
<p>It is a common trick to use array slicing to compactly assign many variables to the same value:</p>
<pre class="lang-rs prettyprint-override"><code>let[a,b,c]=[0;3]
// vs
let(a,b,c)=(0,0,0)
// or
let a=0;let b=0;let c=0;
</code></pre>
<p>I've never really seen this used on arrays, even though it also saves bytes there:</p>
<pre class="lang-rs prettyprint-override"><code>let[a,..@b]=[0;99]; // store &quot;the rest&quot; of the slice in b
// vs
let(a,b)=(0,[0;98]);
// or
let a=0;let b=[0;98];
</code></pre>
<p>Saves just one byte so may not be worth it if it increases the array size by one byte.</p>
<p>It works for mutable variables too:</p>
<pre class="lang-rs prettyprint-override"><code>let[mut v,mut u@..]=[0;99];
// vs
let(mut u,mut v)=(0,[0;98]);
</code></pre>
</div>
<div id="pu7" class="pu"><h1><code>if let</code> can sometimes be shorter than <code>match</code></h1>
<p>Using <code>match</code>:</p>
<pre><code>match a{M(v)=&gt;expr,_=&gt;other}
</code></pre>
<p>Using <code>if let</code> costs 2 bytes if there are only 2 branches and 1 is wildcard:</p>
<pre><code>if let M(v)=a{expr}else{other}
</code></pre>
<p>More effective when your <code>match</code> needed <code>{}</code> anyways, like if the types don't match. For example:</p>
<pre><code>match a{M(v)=&gt;{expr;}_=&gt;{other;}}
</code></pre>
<p>vs.:</p>
<pre><code>if let M(v)=a{expr;}else{other;}
</code></pre>
<p>saves 1 byte.</p>
</div>
<div id="pu8" class="pu"><h1>Use <code>@</code> to define multiple variables to the same value</h1>
<p><code>@</code> is meant to define an alias for pattern matching (like destructuring an array but also getting the original array at the same time). But it works with plain variables too.</p>
<pre><code>let a=2;let b=2; // 16 bytes
let(a,b)=(2,2);  // 15 bytes
let a@b=2;       // 10 bytes
</code></pre>
<p>It works in destructuring too:</p>
<pre><code>let a=1;let b=1;let c=2;let d=2; // 32 bytes
let(a,b,c,d)=(1,1,2,2);          // 23 bytes
let(a@b,c@d)=(1,2);              // 19 bytes
</code></pre>
</div>
<div id="pu9" class="pu"><p>When using string formatting for example with <code>print!()</code>, one can use both numbered and unnumbered formatters to save one byte per item to format:</p>
<p>Best shown with an example:</p>
<pre class="lang-rust prettyprint-override"><code>fn main() {
    print!(
        &quot;{}{}{}. Yes, {0}{}{2}. All you other{1}{2}s are just imitating.&quot;,
        &quot;I'm&quot;, &quot; Slim&quot;, &quot; Shady&quot;, &quot; the real&quot;,
    );
}
</code></pre>
<p>Which outputs:</p>
<blockquote>
<pre><code>I'm Slim Shady. Yes, I'm the real Shady. All you other Slim Shadys are just imitating.
</code></pre>
</blockquote>
<p>So the unnumbered formatters will get assigned to the items in order, this allows you to skip the index on them. Note that you can only use one unnumbered formatter per item to format, after that it will get used up.</p>
</div>
<div id="pu10" class="pu"><h1><code>scan</code> and <code>fold</code> on <code>Iterator</code>s can be used for stateful iteration</h1>
<p>If your closure consists of variable declarations and iterating over something while keeping an internal state, you might be able to save some bytes by using <code>scan</code> or <code>fold</code> instead of a <code>for</code> loop:</p>
<pre class="lang-rust prettyprint-override"><code>|i:&amp;str|{let(mut a,mut b,mut c)=(1,2,0);for x in i.chars(){/*AAA*/;/*BBB*/;c=/*CCC*/}c}
</code></pre>
<p><code>scan</code> is good for handling many mutable variables, at the cost of some operations (such as assignment) requiring dereferencing with <code>*</code> and needing to collect the final value using a method like <code>last</code>:</p>
<pre class="lang-rust prettyprint-override"><code>|i:&amp;str|i.chars().scan((1,2),|(a,b),x|{/*AAA*/;/*BBB*/;Some(/*CCC*/)}).last()
</code></pre>
<p><code>fold</code> can also be used in a similar manner by passing values in the accumulator:</p>
<pre class="lang-rust prettyprint-override"><code>|i:&amp;str|i.chars().fold((1,2,3),|(a,b,c),x|(/*AAA*/,/*BBB*/,/*CCC*/)).2
</code></pre>
</div>
<div id="pu11" class="pu"><h1>Do-while loops</h1>
<p>Rust does not have a C-style do-while loop:</p>
<pre class="lang-c prettyprint-override"><code>do{do_work();}while(condition);
</code></pre>
<p>But blocks are also expressions in Rust, so you can write:</p>
<pre class="lang-rust prettyprint-override"><code>while{do_work();condition}{}
</code></pre>
</div>
<div id="pu12" class="pu"><h1><code>(0..).scan</code> can be shorter than <code>std::iter::successors</code></h1>
<p>If you want to make endless sequences that are based on previous state:</p>
<pre class="lang-rust prettyprint-override"><code>std::iter::successors(Some(a),|x,_|Some(/*something*/))
</code></pre>
<p>This will be shorter by a character:</p>
<pre class="lang-rust prettyprint-override"><code>(0..).scan(a,|x,_|{let y=*x;*x=/*something*/;Some(y)})
</code></pre>
<p>If you don't mind dropping the first case, it can be even shorter:</p>
<pre class="lang-rust prettyprint-override"><code>(0..).scan(a,|x,_|{*x=/*something*/;Some(*x)})
</code></pre>
</div>
<div id="pu13" class="pu"><h1>Loops are sometimes shorter than iterators</h1>
<p>Even with the extra curly braces, in some cases it can be shorter to declare a mutable variable and use a loop instead of using <code>Iterator</code> methods.</p>
<p>For example, to do something with every third element of a slice and then return the last index:</p>
<pre class="lang-rust prettyprint-override"><code>|n:&amp;[_]|{let mut i=0;while i&lt;n.len(){println!(&quot;{}&quot;,n[i]);i+=3}i-3}
</code></pre>
<pre class="lang-rust prettyprint-override"><code>|n:&amp;[_]|(0..=n.len()/3).map(|i|{println!(&quot;{}&quot;,n[i*3]);i*3}).last().unwrap()
</code></pre>
</div>
<div id="pu14" class="pu"><p>When working with strings with newlines in them, you save one byte if you use a literal line break in the source code vs having a <code>\n</code> in the string and/or using <code>println</code>.</p>
<pre class="lang-rust prettyprint-override"><code>print!(&quot;Hello
World!
&quot;);
</code></pre>
<p>is 2 bytes less than:</p>
<pre class="lang-rust prettyprint-override"><code>println!(&quot;Hello\nWorld!&quot;);
</code></pre>
</div>
<div id="pu15" class="pu"><h1>Prefer todo! over panic!</h1>
<p><a href="https://doc.rust-lang.org/std/macro.todo.html" rel="noreferrer"><code>todo!</code></a> is shorter than <code>panic!</code> by 1 byte, so prefer to use it if you need to panic and exit the program. It's also shorter than <code>print!</code> by a byte, so it can shorten your program if you can output to stderr instead of stdout.</p>
<pre><code>todo!(&quot;optional message for stderr&quot;)
</code></pre>
</div>
<div id="pu16" class="pu"><h1>Declare multiple variables using pattern matching</h1>
<p>(Somewhat of an extension of <a href="https://codegolf.stackexchange.com/a/99124/97519">https://codegolf.stackexchange.com/a/99124/97519</a>)</p>
<p>Using multiple <code>let</code> statements:</p>
<pre><code>let a=x;let b=y;
let a=x;let b=y;let c=z;
</code></pre>
<p>Using a tuple match saves 1 char for 2 variables and 3 more chars for ever variable after:</p>
<pre><code>let(a,b)=(x,y);
let(a,b,c)=(x,y,z);
</code></pre>
<p>Similarly, you can use array patterns for initializing multiple mutable variables to the same value (this works with immutable variables too but is pretty useless):</p>
<pre><code>let[mut a,mut b]=[x;2];
</code></pre>
</div>
<div id="pu17" class="pu"><h1>Use <code>..=</code></h1>

<p>Replace all <code>..i+1</code> with <code>..=i</code> to save 1 byte, works on both array index <code>a[i..=i]</code> and range <code>(0..=n)</code></p>
</div>
<div id="pu18" class="pu"><h1>Use closure parameter to define variable instead of <code>let</code></h1>

<pre class="lang-rust prettyprint-override"><code>{let(a,b)=(A,B);X}
</code></pre>

<p>can be replaced by</p>

<pre class="lang-rust prettyprint-override"><code>(|a,b|X)(A,B)
</code></pre>

<p>to save 5 bytes if the type of <code>a</code> and <code>b</code> can be inferred, it usually works when they are integers or are passed to another function directly in <code>X</code>.</p>

<p>This works well on 2 or more variables, but for a single variable, this could still save 2 bytes if it allows you to get rid of the <code>{}</code>.</p>
</div>
<div id="pu19" class="pu"><h1>Converting <code>&amp;str</code> to <code>String</code></h1>

<p>Never do these:</p>

<pre class="lang-rust prettyprint-override"><code>s.to_string()  // 13 bytes
s.to_owned()   // 12 bytes
</code></pre>

<p>This is always shorter:</p>

<pre class="lang-rust prettyprint-override"><code>s.repeat(1)    // 11 bytes
</code></pre>

<p>If <code>s</code> is a string literal:</p>

<pre class="lang-rust prettyprint-override"><code>format!(s)     // 10 bytes
</code></pre>

<p>For example: use <code>format!("")</code> instead of <code>String::new()</code> to save 2 bytes.</p>

<p>If type inference works:</p>

<pre class="lang-rust prettyprint-override"><code>s.into()       // 8 bytes
</code></pre>
</div>
<div id="pu20" class="pu"><p>When using whole number floating point numbers, you can omit the trailing <code>.0</code> to save one byte.</p>

<pre><code>let a=1.
</code></pre>

<p>is 1 byte less than:</p>

<pre><code>let a=1.0
</code></pre>
</div>
<div id="pu21" class="pu"><h1>Skipping trailing semicolons</h1>

<p>In functions returning <code>()</code>, where the last expression is also of type <code>()</code>, you don't need the trailing <code>;</code>:</p>

<pre><code>fn main(){print!("Hello, world!")}
</code></pre>
</div>
<div id="pu22" class="pu"><h1>Reading lines</h1>

<p>After considering various things, I think that is generally the shortest way to retrieve a line. The line has a newline, it can be removed by trimming (<code>.trim()</code>) or if that cannot be done by slicing.</p>

<pre><code>let y=&amp;mut"".into();std::io::stdin().read_line(y);
</code></pre>

<p>For multiple lines, <code>lines</code> iterator can be used, the iterated line doesn't end in newline then. A glob import is needed to import <code>BufRead</code>, needed for <code>lines</code> to be available for <code>StdinLock&lt;'_&gt;</code> type.</p>

<pre><code>use std::io::*;let y=stdin();y.lock().lines()
</code></pre>
</div>
<div id="pu23" class="pu"><h2>Use closures instead of functions</h2>

<p>A closure: </p>

<pre><code>|n|n+1
</code></pre>

<p>is shorter than a function:</p>

<pre><code>fn f(n:i32)-&gt;i32{n+1}
</code></pre>

<hr>

<p>Closures longer than one statement need braces but are still far shorter than a function.</p>
</div>
<div id="pu24" class="pu"><p>If you need many mutable variables, it can waste a lot of space declaring them and initializing them, since each requires the mut keyword and you can't do anything like a=b=c=0. A solution then is to declare a mutable array</p>

<pre><code>let mut a=[0;5];
</code></pre>

<p>You spend 3 extra bytes each time you use them vs. a normal variable:</p>

<pre><code>a[0]+=1;
</code></pre>

<p>but it can often still be worth it.</p>

<p>Using tuples for the same trick is often an even better option:</p>

<pre><code>let mut t=(1,4,"this", 0.5, 'c');
</code></pre>

<p>This has the advantage of saving a byte on each use vs. the array:</p>

<pre><code>t.0=2
</code></pre>

<p>It also lets them be of different types. On the downside, it requires more characters to initialize.</p>
</div>
<div id="pu25" class="pu"><h1>Avoid .iter().enumerate()</h1>

<p>Let's say you have some x that implements the IntoIterator Trait and you need to call a function f that takes the index of an element and a reference to it.
The standard way of doing this is</p>

<pre><code>x.iter().enumerate().map(f)
</code></pre>

<p>instead you can do</p>

<pre><code>(0..).zip(x).map(f)
</code></pre>

<p>and save yourself not only the unusually long enumerate but also the call to iter!</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/74096/">74096</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




