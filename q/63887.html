<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::63887</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>081</td><td>C++14</td><td>151114T233615Z</td><td><a href="https://codegolf.stackexchange.com/questions/63887/gamma-function-golf/63893#63893">Zereges</a></td></tr>
<tr d-ix="1"><td>013</td><td>APL Dyalog Unicode</td><td>200527T065040Z</td><td><a href="https://codegolf.stackexchange.com/questions/63887/gamma-function-golf/205279#205279">Bubbler</a></td></tr>
<tr d-ix="2"><td>389</td><td>Python</td><td>151115T022107Z</td><td><a href="https://codegolf.stackexchange.com/questions/63887/gamma-function-golf/63908#63908">TanMath</a></td></tr>
<tr d-ix="3"><td>040</td><td>Mathematica</td><td>151117T134437Z</td><td><a href="https://codegolf.stackexchange.com/questions/63887/gamma-function-golf/64108#64108">alephalp</a></td></tr>
<tr d-ix="4"><td>114</td><td>Prolog</td><td>151117T132706Z</td><td><a href="https://codegolf.stackexchange.com/questions/63887/gamma-function-golf/64107#64107">Emigna</a></td></tr>
<tr d-ix="5"><td>021</td><td>Pyth</td><td>151115T185352Z</td><td><a href="https://codegolf.stackexchange.com/questions/63887/gamma-function-golf/63961#63961">lirtosia</a></td></tr>
<tr d-ix="6"><td>025</td><td>Minkolang 0.12</td><td>151115T071537Z</td><td><a href="https://codegolf.stackexchange.com/questions/63887/gamma-function-golf/63929#63929">El&#39;e</a></td></tr>
<tr d-ix="7"><td>073</td><td>Python 3</td><td>151115T051907Z</td><td><a href="https://codegolf.stackexchange.com/questions/63887/gamma-function-golf/63917#63917">TanMath</a></td></tr>
<tr d-ix="8"><td>035</td><td>TIBASIC</td><td>151115T060843Z</td><td><a href="https://codegolf.stackexchange.com/questions/63887/gamma-function-golf/63922#63922">lirtosia</a></td></tr>
<tr d-ix="9"><td>041</td><td>Julia</td><td>151115T055657Z</td><td><a href="https://codegolf.stackexchange.com/questions/63887/gamma-function-golf/63921#63921">Alex A.</a></td></tr>
<tr d-ix="10"><td>045</td><td>Japt</td><td>151115T033710Z</td><td><a href="https://codegolf.stackexchange.com/questions/63887/gamma-function-golf/63910#63910">ETHprodu</a></td></tr>
<tr d-ix="11"><td>141</td><td>Julia</td><td>151115T000344Z</td><td><a href="https://codegolf.stackexchange.com/questions/63887/gamma-function-golf/63899#63899">Alex A.</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>C++14, <s>86</s> <s>85</s> 81 bytes</h1>
<pre class="lang-cpp prettyprint-override"><code>    [](auto t){auto v=1.;for(int x=1;x&lt;1e9;++x)v*=pow(1+1./x,t)/(1+t/x);return v/t;};
</code></pre>
<p>I didn't spend much time on this one. I just looked an approximation that seemed the easiest to implement (in the manner of bytes). It will take some time to compute the value (since the loop is over all positive integers), but time limitation is not specified in the challenge. It is anonymous function (lambda), which takes any argument (convertible to  <code>T</code> on which <code>pow(double, T)</code> and <code>operator/(T, int)</code> can be called) and returns <code>double</code>.</p>
<p>Ungolfed with usage</p>
<pre class="lang-cpp prettyprint-override"><code>    #include &lt;iostream&gt;
    int main()
    {
        auto r = [](auto t)
        {
            auto v = 1.;
            for (int x = 1; x &lt; 1e9; ++x)
                v *= pow(1 + 1. / x, t) / (1 + t / x);
            return v / t;
        };
        std::cout &lt;&lt; r(-2.71828182846); // outputs -0.952682
    }
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.dyalog.com/" rel="nofollow noreferrer">APL (Dyalog Unicode)</a>, 13 <a href="https://github.com/abrudz/SBCS" rel="nofollow noreferrer">bytes</a></h1>



<pre class="lang-apl prettyprint-override"><code>1e8∘(*÷⊣!+)÷⊢
</code></pre>

<p><a href="https://tio.run/##SyzI0U2pTMzJT///3zDV/FHHDA2tw9sfdS1W1NYE0Yv@pz1qm/Cot@9RV/Oh9caP2iY@6psaHOQMJEM8PIP/qzvn5xaUlqSmKJQl5pSmFlup66QdWqFgqHBovZGeqYKxnqGJoamlkZkpWMDc0MLIAoRNzBQMjRQMgCos9MzMTY0NLIHyhgZ6hlwhRaWp7om5uYlAa6sVgYLaj3q31nKpByWWZOYDTdcAGX94uwJcnSb5lgEA" rel="nofollow noreferrer" title="APL (Dyalog Unicode) – Try It Online">Try it online!</a></p>

<p>The above code uses the <code>!</code> function, but it is used as <a href="https://en.wikipedia.org/wiki/Binomial_coefficient#Generalization_and_connection_to_the_binomial_series" rel="nofollow noreferrer">generalized binomial coefficient</a>, not factorial. A version without the <code>!</code> symbol altogether:</p>

<h1><a href="https://www.dyalog.com/" rel="nofollow noreferrer">APL (Dyalog Unicode)</a>, 20 <a href="https://github.com/abrudz/SBCS" rel="nofollow noreferrer">bytes</a></h1>



<pre class="lang-apl prettyprint-override"><code>1e8∘(*×(×/⊢÷+)∘⍳⍨)÷⊢
</code></pre>

<p><a href="https://tio.run/##SyzI0U2pTMzJT///3zDV/FHHDA2tw9M1Dk/Xf9S16PB2bU2gyKPezY96V2ge3g4U@p/2qG3Co96@R13Nh9YbP2qb@KhvanCQM5AM8fAM/q/unJ9bUFqSmqJQlphTmlpspa6TdmiFgqHCofVGeqYKxnqGJoamlkZmpmABc0MLIwsQNjFTMDRSMACqsNAzMzc1NrAEyhsa6BlyhRSVpron5uYmAq2tVgQKaj/q3VrLpR6UWJKZDzRdA2T84e0KcHWa5Fv239cxIjzY1sgdAA" rel="nofollow noreferrer" title="APL (Dyalog Unicode) – Try It Online">Try it online!</a></p>

<p>In both cases, <code>1e7</code> is used instead of <code>1e8</code> to show that the actual values calculated are close enough to the true values.</p>

<h3>How it works: the math</h3>

<p>Uses the formula used in <a href="https://codegolf.stackexchange.com/a/63917/78410">TanMath's Python answer</a> and therefore <a href="https://codegolf.stackexchange.com/a/63893/78410">Zereges' C++ answer</a>.</p>

<p>Basically, the solutions by TanMath/Zereges compute the following, which I developed further to suit better to APL:</p>

<p><span class="math-container">$$
\begin{align}
\Gamma(x) &amp;\approx \frac1x \prod_{i=1}^{n}{\Bigl(1+\frac{1}{i}\Bigr)^x \div \Bigl(1+\frac{x}{i}\Bigr)} \\
&amp;= \frac1x \prod_{i=1}^{n}{\Bigl(\frac{i+1}{i}\Bigr)^x \times \Bigl(\frac{i}{x+i}\Bigr)} \\
&amp;= \frac1x \Bigl(\prod_{i=1}^{n}{\frac{i+1}{i}}\Bigr)^x \times \prod_{i=1}^{n}{\Bigl(\frac{i}{x+i}\Bigr)} \\
&amp;\approx \frac{n^x}x \times \prod_{i=1}^{n}{\Bigl(\frac{i}{x+i}\Bigr)} \tag{1}\label{eq1}\\
&amp;= \frac{n^x}x \div \binom{x+n}{n} \tag{2}\label{eq2}\\
\end{align}
$$</span></p>

<p>The second solution uses equation <span class="math-container">\$\eqref{eq1}\$</span> while the first uses equation <span class="math-container">\$\eqref{eq2}\$</span>, both using <span class="math-container">\$n=10^8\$</span> in order to get enough precision.</p>

<h3>How it works: the code</h3>

<pre class="lang-apl prettyprint-override"><code>1e8∘(*÷⊣!+)÷⊢  ⍝ Input←x; n←1e8
1e8∘(    +)    ⍝ n+x
       ⊣!      ⍝ binom(n+x, n)
     *÷        ⍝ n^x ÷ binom(n+x, n)
           ÷⊢  ⍝ Divide by x

1e8∘(*×(×/⊢÷+)∘⍳⍨)÷⊢  ⍝ Input←x; n←1e8
1e8∘(  (     )∘⍳⍨)    ⍝ Generate 1..n; for each i in 1..n,
          ⊢÷+         ⍝ i÷(x+i)
        ×/            ⍝ Product over all i
     *×               ⍝ Multiply n^x
                  ÷⊢  ⍝ Divide by x
</code></pre>
</div>
<div id="pu2" class="pu"><h1>Python, <s>348</s> <s>448</s> <s>407</s> <s>390</s> 389 bytes</h1>

<p>Special thanks to @Mego!</p>

<p> A crossed out 448 is (almost) still a 448! :p </p>

<p>This is based on the Lanzcos approximation. Golfed from <a href="http://web.archive.org/web/20150905222455/http://en.literateprograms.org/Gamma_function_with_the_Lanczos_approximation_(Python)" rel="nofollow noreferrer">here</a></p>

<pre><code>from cmath import*
C=[0.9999999999998099,676.5203681218851,-1259.1392167224028,771.3234287776531,-17‌6.6150291621406,12.507343278686905,-0.13857109526572012,9.984369578019572e-6,1.5‌​056327351493116e-7]
def g(z):
 z-=1;if z.real&lt;0.5:return pi/(sin(pi*z)*gamma(1-z))
 else:
  x=C[0]
  for i in range(1,9):x+=C[i]/(z+i)
  t=z+7.5;return sqrt(2*pi)*t**(z+0.5)*exp(-t)*x
</code></pre>
</div>
<div id="pu3" class="pu"><h1>Mathematica, 40 bytes</h1>

<pre><code>NProduct[(1+1/n)^#/(1+#/n),{n,1,∞}]/#&amp;
</code></pre>
</div>
<div id="pu4" class="pu"><h1>Prolog, 114 bytes</h1>
<p>This is a translation of Zereges' C++ answer.</p>
<pre><code>q(F,F,V,Z):-X is V/Z,write(X).
q(F,T,V,Z):-W is(1+1/F)**Z/(1+Z/F)*V,I is F+1,q(I,T,W,Z).
p(N):-q(1.0,1e9,1,N),!.
</code></pre>
<p>Try it out online <a href="http://swish.swi-prolog.org/" rel="nofollow noreferrer">here</a><br>
Run it with a query of the form:</p>
<pre><code>p(12).
</code></pre>
<p>Running it with 1e9 recursions takes about 15 minutes.<br>
If you decrease it to 1e6 it takes about 1 second which makes for easier (but less acurate) testing. <br>
Running it in an interpreter on you computer/laptop is most likely faster for most people as well.<br></p>
</div>
<div id="pu5" class="pu"><h1>Pyth, 21 bytes</h1>
<p>As with my TI-BASIC answer, I haven't been able to test this with the full 8^10 iterations, but everything seems good with smaller cases.</p>
<pre><code>cu*Gc^hc1HQhcQHS^8T1Q
</code></pre>
<p>Explanation:</p>
<pre><code>                            [implicit: Q=input]
                ^8T         8**10
               S^8T         [1,2,3,...,8**10]
  *Gc^hc1HQhcQH             lambda G,H:G*(1+1/H)**Q/(1+Q/H)
                   1        Base case
 u*Gc^hc1HQhcQHS^8T1        Reduce with base case 1
c                   Q       Divide by Q
</code></pre>
<p>Try it <a href="https://pyth.herokuapp.com/?code=cu%2aGc%5Ehc1HQhcQHS2000+1Q&amp;input=1%0A-2.5%0A3.14159265%0A-2.71828182846%0A12%0A0.5%0A8.675309%0A-10.1&amp;test_suite=1&amp;test_suite_input=1%0A-2.5%0A3.14159265%0A-2.71828182846%0A12%0A0.5%0A8.675309%0A-10.1&amp;debug=0" rel="nofollow noreferrer">here</a> with 2000 iterations instead of 8^10.</p>
</div>
<div id="pu6" class="pu"><h2><a href="https://github.com/elendiastarman/Minkolang" rel="noreferrer">Minkolang 0.12</a>, <s>35</s> <s>34</s> 25 bytes</h2>
<pre><code>n$zl8;dz;z$:r[i1+dz+$:*]N
</code></pre>
<p>This does halt with an error (on trying to divide by 0), but that is allowed as per <a href="http://meta.codegolf.stackexchange.com/a/4781/12914">Meta consensus</a>. Add a <code>.</code> at the end for a program that halts normally. <a href="http://play.starmaninnovations.com/minkolang/?code=%28n%24zl4%3Bdz%3Bz%24%3Ar%5Bi1%2Bdz%2B%24%3A*%5DNlO%24I%29%2E&amp;input=1%0A-2%2E5%0A3.14159265%0A-2.71828182846%0A12%0A0.5%0A8.675309%0A-10.1" rel="noreferrer">Try all test cases at once.</a> (The loop iterates only 1e4 times so it would finish sooner rather than later.)</p>
<h3>Explanation</h3>
<p>Zereges used one of the <a href="https://en.wikipedia.org/wiki/Gamma_function#Alternative_definitions" rel="noreferrer">alternative, infinite product definitions</a>. As it turns out, the other is much more amenable to implement in Minkolang.</p>
<p><a href="https://i.sstatic.net/8Kwcf.gif" rel="noreferrer"><img src="https://i.sstatic.net/8Kwcf.gif" alt="Euler's alternative formulation of the gamma function" /></a></p>
<p>This is a limit as <code>n</code> goes to infinity, which means that I can calculate both <code>n!</code> and <code>(t+n)</code> as I go. So I take out <code>1/t</code> (because <code>0!=1</code>) and <code>n^t</code> because that one cannot be calculated sequentially without knowing the ending value of <code>n</code>. As it happens, because <code>n</code> is the limit, I can use it twice. Once as a factor in the calculation and once as the number of times to run the loop.</p>
<p>An sequential infinite product has to start with something, usually 1. In this case, it's <code>n^t/t</code>. In the body of the loop, I calculate <code>k/(t+k)</code> and multiply this with the product so far. At the end, the whole product has been calculated and output. This is essentially what my program does, with <code>n</code> high enough that the answer is precise enough.</p>
<p><a href="https://i.sstatic.net/SMTIL.gif" rel="noreferrer"><img src="https://i.sstatic.net/SMTIL.gif" alt="exploded version of the infinite product" /></a></p>
<pre><code>n                            Take number from input
 $z                          Store it in the register (this is t; retrieved with z)
   l8;                       10^8 (this is n, the limit)
      d                      n,n
       z;                    n,n^t
         z$:                 n,n^t/t
            r                Reverse stack -&gt; n^t/t,n
             [               For loop that runs n times
              i1+            k
                 d           k,k
                  z+         k,t+k
                    $:       k/(t+k)
                      *      Multiply
                       ]N    Close for loop and output as integer
</code></pre>
<p>As there is no <code>.</code>, it wraps around and starts over. However, <code>n</code> now produces <code>-1</code> because the input is empty, which eventually leads to attempting to divide by 0, which halts the program.</p>
</div>
<div id="pu7" class="pu"><h1>Python 3, <s>74</s> <s>68</s> <s>78</s> 73 bytes</h1>

<p>Thanks @Mego and @xnor</p>

<p>This is a translation of the C++ answer by Zereges. Basically, this is an alternate definition of the gamma function, hence more accurate (and what is great is that is uses less bytes!)</p>

<p>I am sorry for all the mistakes!</p>

<pre><code>def g(z,v=1):
 for i in range(1,10**9):v*=(1+1/i)**z/(1+z/i)
 return v/z
</code></pre>
</div>
<div id="pu8" class="pu"><h1>TI-BASIC, 35 bytes</h1>
<pre><code>Input Z
1
For(I,1,ᴇ9
Ans(1+I⁻¹)^Z/(1+Z/I
End
Ans/Z
</code></pre>
<p>This uses the same algorithm as Zereges.</p>
<p>Caveat: I haven't actually tested this with the full 1e9 iterations; based on the time taken for smaller values, I expect the runtime to be on the order of <em>months</em>. However, it appears to converge, and there should be no problems with rounding errors. TI stores numbers as decimal floats with 14 digits of precision.</p>
</div>
<div id="pu9" class="pu"><h1>Julia, 41 bytes</h1>



<pre class="lang-julia prettyprint-override"><code>x-&gt;prod([(1+1/i)^x/(1+x/i)for i=1:1E7])/x
</code></pre>

<p>This is a translation of Zereges' C++ answer. While my other Julia answer finishes instantaneously, this is rather slow. It computes the test cases in a couple seconds each on my computer.</p>

<p>Ungolfed:</p>

<pre class="lang-julia prettyprint-override"><code>function f(x::Real)
    prod([(1 + 1/i)^x / (1 + x/i) for i = 1:1E7]) / x
end
</code></pre>
</div>
<div id="pu10" class="pu"><h1>Japt, 45 bytes</h1>

<p><strong>Japt</strong> is a shortened version of <strong>Ja</strong>vaScri<strong>pt</strong>. <a href="https://codegolf.stackexchange.com/a/62685/42545">Interpreter</a></p>

<pre><code>$for(V=X=1;X&lt;1e9;)$V*=(1+1/X pU /(1+U/X++;V/U
</code></pre>

<p>Of course, 1e9 = 1,000,000,000 iterations takes forever, so for testing, try replacing the <code>9</code> with a <code>6</code>. (1e6 is accurate to ~5 significant figures. Using 1e8 on an input of <code>12</code> is enough to get the first six.)</p>

<p>Test-case results: (using 1e7 precision)</p>

<pre><code>       1:  1
    -2.5: -0.9453083...
      pi:  2.2880370...
      -e: -0.9526812...
      12:  39916536.5...
     0.5:  1.7724538...
8.675309:  20248.319...
   -10.1: -0.0000022...
</code></pre>

<h3>How it works</h3>

<pre><code>         // Implicit: U = input number
$for(    // Ordinary for loop.
V=X=1;   //  Set V and X to 1.
X&lt;1e9;)$ //  Repeat while X is less than 1e9.
V*=      // Multiply V by:
(1+1/X   //  1 plus (1 over X),
pU /     //  to the power of U, divided by
(1+U/X++ //  1 plus (U over X). Increment X by 1.
;V/U     // Output the result of (V over U).
</code></pre>
</div>
<div id="pu11" class="pu"><h1>Julia, 141 bytes</h1>



<pre class="lang-julia prettyprint-override"><code>z-&gt;(z-=1;a=90;c(k)=(k=big(k);(-1)^(k-1)/factorial(k-1)*(a-k)^(k-.5)*exp(a-k));(z+a)^(z+.5)*exp(-z-a)*(√(2π)+sum([c(k)/(z+k)for k=1:a-1])))
</code></pre>

<p>This creates an unnamed lambda function that accepts a real number and returns a real number. It uses <a href="https://en.wikipedia.org/wiki/Spouge%27s_approximation">Spounge's approximation</a> to compute Gamma.</p>

<p>Ungolfed:</p>

<pre class="lang-julia prettyprint-override"><code>function Γ(z::Real)
    # Spounge's approxmation is for Γ(z+1), so subtract 1
    z -= 1

    # Choose a number for the constant a, which determines the
    # bound on the error
    a = 90

    # Define a function for the sequence c_k
    function c(k::Integer)
        # Convert k to a BigInt
        k = big(k)
        return (-1)^(k-1) / factorial(k-1) * (a-k)^(k-1/2) * exp(a-k)
    end

    # Compute the approximation
    return (z+a)^(z+1/2) * exp(-z-a) * (√(2π) + sum([c(k)/(z+k) for k=1:a-1]))
end
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/63887/">63887</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




